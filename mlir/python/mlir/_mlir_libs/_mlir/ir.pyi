# Originally imported via:
#   stubgen {...} -m mlir._mlir_libs._mlir.ir
# Local modifications:
#   * Rewrite references to 'mlir.ir.' to local types
#   * Add __all__ with the following incantation:
#       egrep '^class ' ir.pyi | awk -F ' |:|\\(' '{print "    \"" $2 "\","}'
#   * Local edits to signatures and types that MyPy did not auto detect (or
#     detected incorrectly).

from typing import Any, ClassVar, List, Optional

from typing import overload

__all__ = [
    "AffineAddExpr",
    "AffineBinaryExpr",
    "AffineCeilDivExpr",
    "AffineConstantExpr",
    "AffineDimExpr",
    "AffineExpr",
    "AffineExprList",
    "AffineFloorDivExpr",
    "AffineMap",
    "AffineMapAttr",
    "AffineModExpr",
    "AffineMulExpr",
    "AffineSymbolExpr",
    "ArrayAttr",
    "ArrayAttributeIterator",
    "Attribute",
    "BF16Type",
    "Block",
    "BlockArgument",
    "BlockArgumentList",
    "BlockIterator",
    "BlockList",
    "BoolAttr",
    "ComplexType",
    "Context",
    "DenseElementsAttr",
    "DenseFPElementsAttr",
    "DenseIntElementsAttr",
    "Dialect",
    "DialectDescriptor",
    "Dialects",
    "DictAttr",
    "F16Type",
    "F32Type",
    "F64Type",
    "FlatSymbolRefAttr",
    "FloatAttr",
    "FunctionType",
    "IndexType",
    "InferTypeOpInterface",
    "InsertionPoint",
    "IntegerAttr",
    "IntegerSet",
    "IntegerSetConstraint",
    "IntegerSetConstraintList",
    "IntegerType",
    "Location",
    "MemRefType",
    "Module",
    "NamedAttribute",
    "NoneType",
    "OpAttributeMap",
    "OpOperandList",
    "OpResult",
    "OpResultList",
    "OpView",
    "Operation",
    "OperationIterator",
    "OperationList",
    "RankedTensorType",
    "Region",
    "RegionIterator",
    "RegionSequence",
    "ShapedType",
    "StringAttr",
    "SymbolTable",
    "TupleType",
    "Type",
    "TypeAttr",
    "UnitAttr",
    "UnrankedMemRefType",
    "UnrankedTensorType",
    "Value",
    "VectorType",
    "_GlobalDebug",
    "_OperationBase",
]


class AffineAddExpr(AffineBinaryExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class AffineBinaryExpr(AffineExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def lhs(self) -> AffineExpr: ...
    @property
    def rhs(self) -> AffineExpr: ...

class AffineCeilDivExpr(AffineBinaryExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class AffineConstantExpr(AffineExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def value(self) -> int: ...

class AffineDimExpr(AffineExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def position(self) -> int: ...

class AffineExpr:
    def __init__(self, *args, **kwargs) -> None: ...
    def _CAPICreate(self) -> AffineExpr: ...
    def compose(self, arg0) -> AffineExpr: ...
    def dump(self) -> None: ...
    def get_add(self, *args, **kwargs) -> Any: ...
    def get_ceil_div(self, *args, **kwargs) -> Any: ...
    def get_constant(self, *args, **kwargs) -> Any: ...
    def get_dim(self, *args, **kwargs) -> Any: ...
    def get_floor_div(self, *args, **kwargs) -> Any: ...
    def get_mod(self, *args, **kwargs) -> Any: ...
    def get_mul(self, *args, **kwargs) -> Any: ...
    def get_symbol(self, *args, **kwargs) -> Any: ...
    def __add__(self, other) -> Any: ...
    @overload
    def __eq__(self, arg0: AffineExpr) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __mod__(self, other) -> Any: ...
    def __mul__(self, other) -> Any: ...
    def __radd__(self, other) -> Any: ...
    def __rmod__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __sub__(self, other) -> Any: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def context(self) -> object: ...

class AffineExprList:
    def __init__(self, *args, **kwargs) -> None: ...
    def __add__(self, arg0: AffineExprList) -> List[AffineExpr]: ...
    @overload
    def __getitem__(self, arg0: int) -> AffineExpr: ...
    @overload
    def __getitem__(self, arg0: slice) -> AffineExprList: ...
    def __len__(self) -> int: ...

class AffineFloorDivExpr(AffineBinaryExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class AffineMap:
    def __init__(self, *args, **kwargs) -> None: ...
    def _CAPICreate(self) -> AffineMap: ...
    def compress_unused_symbols(self, *args, **kwargs) -> Any: ...
    def dump(self) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def get_constant(self, *args, **kwargs) -> Any: ...
    def get_empty(self, *args, **kwargs) -> Any: ...
    def get_identity(self, *args, **kwargs) -> Any: ...
    def get_major_submap(self, n_results: int) -> AffineMap: ...
    def get_minor_identity(self, *args, **kwargs) -> Any: ...
    def get_minor_submap(self, n_results: int) -> AffineMap: ...
    def get_permutation(self, *args, **kwargs) -> Any: ...
    def get_submap(self, result_positions: List[int]) -> AffineMap: ...
    def replace(self, expr: AffineExpr, replacement: AffineExpr, n_result_dims: int, n_result_syms: int) -> AffineMap: ...
    @overload
    def __eq__(self, arg0: AffineMap) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def context(self) -> object: ...
    @property
    def is_permutation(self) -> bool: ...
    @property
    def is_projected_permutation(self) -> bool: ...
    @property
    def n_dims(self) -> int: ...
    @property
    def n_inputs(self) -> int: ...
    @property
    def n_symbols(self) -> int: ...
    @property
    def results(self) -> Any: ...

class AffineMapAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...

class AffineModExpr(AffineBinaryExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class AffineMulExpr(AffineBinaryExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class AffineSymbolExpr(AffineExpr):
    def __init__(self, expr: AffineExpr) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def position(self) -> int: ...

class ArrayAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    def __add__(self, arg0: list) -> ArrayAttr: ...
    def __getitem__(self, arg0: int) -> Attribute: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> int: ...
    @property
    def type(self) -> Type: ...

class ArrayAttributeIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> ArrayAttributeIterator: ...
    def __next__(self) -> Attribute: ...

class Attribute:
    def __init__(self, cast_from_type: Attribute) -> None: ...
    def _CAPICreate(self) -> Attribute: ...
    def dump(self) -> None: ...
    def get_named(self, *args, **kwargs) -> Any: ...
    def parse(self, *args, **kwargs) -> Any: ...
    @overload
    def __eq__(self, arg0: Attribute) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def context(self) -> object: ...
    @property
    def type(self) -> Any: ...

class BF16Type(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class Block:
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, operation: _OperationBase) -> None: ...
    def create_after(self, *args) -> Block: ...
    def create_at_start(self, *args, **kwargs) -> Any: ...
    def create_before(self, *args) -> Block: ...
    @overload
    def __eq__(self, arg0: Block) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __iter__(self) -> Any: ...
    @property
    def arguments(self) -> Any: ...
    @property
    def operations(self) -> Any: ...
    @property
    def owner(self) -> object: ...
    @property
    def region(self) -> Region: ...

class BlockArgument(Value):
    def __init__(self, value: Value) -> None: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    def set_type(self, type: Type) -> None: ...
    @property
    def arg_number(self) -> int: ...
    @property
    def owner(self) -> Block: ...

class BlockArgumentList:
    def __init__(self, *args, **kwargs) -> None: ...
    def __add__(self, arg0: BlockArgumentList) -> List[BlockArgument]: ...
    @overload
    def __getitem__(self, arg0: int) -> BlockArgument: ...
    @overload
    def __getitem__(self, arg0: slice) -> BlockArgumentList: ...
    def __len__(self) -> int: ...
    @property
    def types(self) -> List[Type]: ...

class BlockIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> BlockIterator: ...
    def __next__(self) -> Block: ...

class BlockList:
    def __init__(self, *args, **kwargs) -> None: ...
    def append(self, *args) -> Block: ...
    def __getitem__(self, arg0: int) -> Block: ...
    def __iter__(self) -> BlockIterator: ...
    def __len__(self) -> int: ...

class BoolAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...
    @property
    def value(self) -> bool: ...

class ComplexType(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def element_type(self) -> Type: ...

class Context:
    current: ClassVar[Context] = ...  # read-only
    allow_unregistered_dialects: bool
    def __init__(self) -> None: ...
    def _CAPICreate(self) -> object: ...
    def _get_context_again(self) -> object: ...
    def _get_live_count(self, *args, **kwargs) -> Any: ...
    def _get_live_module_count(self) -> int: ...
    def _get_live_operation_count(self) -> int: ...
    def enable_multithreading(self, enable: bool) -> None: ...
    def get_dialect_descriptor(self, *args, **kwargs) -> Any: ...
    def is_registered_operation(self, operation_name: str) -> bool: ...
    def __enter__(self) -> object: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def d(self) -> Any: ...
    @property
    def dialects(self) -> Any: ...

class DenseElementsAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def get_splat(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    def __len__(self) -> int: ...
    @property
    def is_splat(self) -> bool: ...
    @property
    def type(self) -> Type: ...

class DenseFPElementsAttr(DenseElementsAttr):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    def __getitem__(self, arg0: int) -> float: ...
    @property
    def type(self) -> Type: ...

class DenseIntElementsAttr(DenseElementsAttr):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    def __getitem__(self, arg0: int) -> int: ...
    @property
    def type(self) -> Type: ...

class Dialect:
    def __init__(self, descriptor: object) -> None: ...
    @property
    def descriptor(self) -> object: ...

class DialectDescriptor:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def namespace(self) -> str: ...

class Dialects:
    def __init__(self, *args, **kwargs) -> None: ...
    def __getattr__(self, arg0: str) -> object: ...
    def __getitem__(self, arg0: str) -> object: ...

class DictAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    def __contains__(self, arg0: str) -> bool: ...
    @overload
    def __getitem__(self, arg0: str) -> Attribute: ...
    @overload
    def __getitem__(self, arg0: int) -> NamedAttribute: ...
    def __len__(self) -> int: ...
    @property
    def type(self) -> Type: ...

class F16Type(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class F32Type(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class F64Type(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class FlatSymbolRefAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...
    @property
    def value(self) -> str: ...

class FloatAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def get_f32(self, *args, **kwargs) -> Any: ...
    def get_f64(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...
    @property
    def value(self) -> float: ...

class FunctionType(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def inputs(self) -> list: ...
    @property
    def results(self) -> list: ...

class IndexType(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class InferTypeOpInterface:
    def __init__(self, object: object, context: Context = ...) -> None: ...
    def inferReturnTypes(self, operands: Optional[List[Value]] = ..., attributes: Optional[Attribute] = ..., regions: Optional[List[Region]] = ..., context: Context = ..., loc: Location = ...) -> List[Type]: ...
    @property
    def operation(self) -> object: ...
    @property
    def opview(self) -> object: ...

class InsertionPoint:
    current: ClassVar[InsertionPoint] = ...  # read-only
    @overload
    def __init__(self, block: Block) -> None: ...
    @overload
    def __init__(self, beforeOperation: _OperationBase) -> None: ...
    def at_block_begin(self, *args, **kwargs) -> Any: ...
    def at_block_terminator(self, *args, **kwargs) -> Any: ...
    def insert(self, operation: _OperationBase) -> None: ...
    def __enter__(self) -> object: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    @property
    def block(self) -> Block: ...

class IntegerAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...
    @property
    def value(self) -> int: ...

class IntegerSet:
    def __init__(self, *args, **kwargs) -> None: ...
    def _CAPICreate(self) -> IntegerSet: ...
    def dump(self) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def get_empty(self, *args, **kwargs) -> Any: ...
    def get_replaced(self, dim_exprs: list, symbol_exprs: list, num_result_dims: int, num_result_symbols: int) -> IntegerSet: ...
    @overload
    def __eq__(self, arg0: IntegerSet) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def constraints(self) -> Any: ...
    @property
    def context(self) -> object: ...
    @property
    def is_canonical_empty(self) -> bool: ...
    @property
    def n_dims(self) -> int: ...
    @property
    def n_equalities(self) -> int: ...
    @property
    def n_inequalities(self) -> int: ...
    @property
    def n_inputs(self) -> int: ...
    @property
    def n_symbols(self) -> int: ...

class IntegerSetConstraint:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> AffineExpr: ...
    @property
    def is_eq(self) -> bool: ...

class IntegerSetConstraintList:
    def __init__(self, *args, **kwargs) -> None: ...
    def __add__(self, arg0: IntegerSetConstraintList) -> List[IntegerSetConstraint]: ...
    @overload
    def __getitem__(self, arg0: int) -> IntegerSetConstraint: ...
    @overload
    def __getitem__(self, arg0: slice) -> IntegerSetConstraintList: ...
    def __len__(self) -> int: ...

class IntegerType(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get_signed(self, *args, **kwargs) -> Any: ...
    def get_signless(self, *args, **kwargs) -> Any: ...
    def get_unsigned(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def is_signed(self) -> bool: ...
    @property
    def is_signless(self) -> bool: ...
    @property
    def is_unsigned(self) -> bool: ...
    @property
    def width(self) -> int: ...

class Location:
    current: ClassVar[Location] = ...  # read-only
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def _CAPICreate(self) -> Location: ...
    def callsite(self, *args, **kwargs) -> Any: ...
    def file(self, *args, **kwargs) -> Any: ...
    def name(self, *args, **kwargs) -> Any: ...
    def unknown(self, *args, **kwargs) -> Any: ...
    def __enter__(self) -> object: ...
    @overload
    def __eq__(self, arg0: Location) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def context(self) -> object: ...

class MemRefType(ShapedType):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def affine_map(self) -> AffineMap: ...
    @property
    def layout(self) -> Attribute: ...
    @property
    def memory_space(self) -> Attribute: ...

class Module:
    def __init__(self, *args, **kwargs) -> None: ...
    def _CAPICreate(self) -> object: ...
    def create(self, *args, **kwargs) -> Any: ...
    def dump(self) -> None: ...
    def parse(self, *args, **kwargs) -> Any: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def body(self) -> Any: ...
    @property
    def context(self) -> object: ...
    @property
    def operation(self) -> object: ...

class NamedAttribute:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def attr(self) -> Attribute: ...
    @property
    def name(self) -> str: ...

class NoneType(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class OpAttributeMap:
    def __init__(self, *args, **kwargs) -> None: ...
    def __contains__(self, arg0: str) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    @overload
    def __getitem__(self, arg0: str) -> Attribute: ...
    @overload
    def __getitem__(self, arg0: int) -> NamedAttribute: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: Attribute) -> None: ...

class OpOperandList:
    def __init__(self, *args, **kwargs) -> None: ...
    def __add__(self, arg0: OpOperandList) -> List[Value]: ...
    @overload
    def __getitem__(self, arg0: int) -> Value: ...
    @overload
    def __getitem__(self, arg0: slice) -> OpOperandList: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: int, arg1: Value) -> None: ...

class OpResult(Value):
    def __init__(self, value: Value) -> None: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def owner(self) -> object: ...
    @property
    def result_number(self) -> int: ...

class OpResultList:
    def __init__(self, *args, **kwargs) -> None: ...
    def __add__(self, arg0: OpResultList) -> List[OpResult]: ...
    @overload
    def __getitem__(self, arg0: int) -> OpResult: ...
    @overload
    def __getitem__(self, arg0: slice) -> OpResultList: ...
    def __len__(self) -> int: ...
    @property
    def types(self) -> List[Type]: ...

class OpView(_OperationBase):
    _ODS_OPERAND_SEGMENTS: ClassVar[None] = ...
    _ODS_REGIONS: ClassVar[tuple] = ...
    _ODS_RESULT_SEGMENTS: ClassVar[None] = ...
    def __init__(self, operation: object) -> None: ...
    @classmethod
    def build_generic(self, *args, **kwargs) -> Any: ...
    @property
    def context(self) -> object: ...
    @property
    def operation(self) -> object: ...

class Operation(_OperationBase):
    def __init__(self, *args, **kwargs) -> None: ...
    def _CAPICreate(self) -> object: ...
    def create(self, *args, **kwargs) -> Any: ...
    def erase(self) -> None: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def context(self) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def opview(self) -> object: ...
    @property
    def parent(self) -> object: ...

class OperationIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> OperationIterator: ...
    def __next__(self) -> object: ...

class OperationList:
    def __init__(self, *args, **kwargs) -> None: ...
    def __getitem__(self, arg0: int) -> object: ...
    def __iter__(self) -> OperationIterator: ...
    def __len__(self) -> int: ...

class RankedTensorType(ShapedType):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def encoding(self) -> Optional[Attribute]: ...

class Region:
    __hash__: ClassVar[None] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def __eq__(self, arg0: Region) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __iter__(self) -> Any: ...
    @property
    def blocks(self) -> Any: ...
    @property
    def owner(self) -> object: ...

class RegionIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> RegionIterator: ...
    def __next__(self) -> Region: ...

class RegionSequence:
    def __init__(self, *args, **kwargs) -> None: ...
    def __getitem__(self, arg0: int) -> Region: ...
    def __len__(self) -> int: ...

class ShapedType(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get_dim_size(self, dim: int) -> int: ...
    def is_dynamic_dim(self, dim: int) -> bool: ...
    def is_dynamic_size(self, *args, **kwargs) -> Any: ...
    def is_dynamic_stride_or_offset(self, dim_size: int) -> bool: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def element_type(self) -> Type: ...
    @property
    def has_rank(self) -> bool: ...
    @property
    def has_static_shape(self) -> bool: ...
    @property
    def rank(self) -> int: ...
    @property
    def shape(self) -> List[int]: ...

class StringAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def get_typed(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...
    @property
    def value(self) -> str: ...

class SymbolTable:
    def __init__(self, arg0: _OperationBase) -> None: ...
    def erase(self, operation: _OperationBase) -> None: ...
    def insert(self, operation: _OperationBase) -> Attribute: ...
    def __contains__(self, arg0: str) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> object: ...

class TupleType(Type):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get_tuple(self, *args, **kwargs) -> Any: ...
    def get_type(self, pos: int) -> Type: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def num_types(self) -> int: ...

class Type:
    def __init__(self, cast_from_type: Type) -> None: ...
    def _CAPICreate(self) -> Type: ...
    def dump(self) -> None: ...
    def parse(self, *args, **kwargs) -> Any: ...
    @overload
    def __eq__(self, arg0: Type) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def context(self) -> object: ...

class TypeAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...
    @property
    def value(self) -> Type: ...

class UnitAttr(Attribute):
    def __init__(self, cast_from_attr: Attribute) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def type(self) -> Type: ...

class UnrankedMemRefType(ShapedType):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...
    @property
    def memory_space(self) -> Attribute: ...

class UnrankedTensorType(ShapedType):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class Value:
    def __init__(self, *args, **kwargs) -> None: ...
    def _CAPICreate(self) -> Value: ...
    def dump(self) -> None: ...
    @overload
    def __eq__(self, arg0: Value) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def context(self) -> Any: ...
    @property
    def owner(self) -> object: ...
    @property
    def type(self) -> Type: ...

class VectorType(ShapedType):
    def __init__(self, cast_from_type: Type) -> None: ...
    def get(self, *args, **kwargs) -> Any: ...
    def isinstance(self, *args, **kwargs) -> Any: ...

class _GlobalDebug:
    flag: ClassVar[bool] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class _OperationBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def detach_from_parent(self) -> object: ...
    def get_asm(self, binary: bool = ..., large_elements_limit: Optional[int] = ..., enable_debug_info: bool = ..., pretty_debug_info: bool = ..., print_generic_op_form: bool = ..., use_local_scope: bool = ...) -> object: ...
    def move_after(self, other: _OperationBase) -> None: ...
    def move_before(self, other: _OperationBase) -> None: ...
    def print(self, file: object = ..., binary: bool = ..., large_elements_limit: Optional[int] = ..., enable_debug_info: bool = ..., pretty_debug_info: bool = ..., print_generic_op_form: bool = ..., use_local_scope: bool = ...) -> None: ...
    def verify(self) -> bool: ...
    @overload
    def __eq__(self, arg0: _OperationBase) -> bool: ...
    @overload
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def _CAPIPtr(self) -> object: ...
    @property
    def attributes(self) -> Any: ...
    @property
    def location(self) -> Location: ...
    @property
    def operands(self) -> Any: ...
    @property
    def regions(self) -> Any: ...
    @property
    def result(self) -> Any: ...
    @property
    def results(self) -> Any: ...
