//===- EnumPythonBindingGen.cpp - Generator of Python API for ODS enums ---===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// EnumPythonBindingGen uses ODS specification of MLIR enum attributes to
// generate the corresponding Python binding classes.
//
//===----------------------------------------------------------------------===//

#include "mlir/TableGen/Attribute.h"
#include "mlir/TableGen/GenInfo.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/TableGen/Record.h"

using namespace mlir;
using namespace mlir::tblgen;

/// File header and includes.
constexpr const char *fileHeader = R"Py(
# Autogenerated by mlir-tblgen; don't manually edit.

from enum import Enum
from ._ods_common import _cext as _ods_cext
_ods_ir = _ods_cext.ir

# Convenience decorator for registering user-friendly Attribute builders.
def _register_attribute_builder(kind):
    def decorator_builder(func):
        _ods_ir.AttrBuilder.insert(kind, func)
        return func

    return decorator_builder

)Py";

/// Makes enum case name Python-compatible, i.e. UPPER_SNAKE_CASE.
static std::string makePythonEnumCaseName(StringRef name) {
  return StringRef(llvm::convertToSnakeFromCamelCase(name)).upper();
}

/// Emits the Python class for the given enum.
static void emitEnumClass(StringRef enumName, StringRef description,
                          ArrayRef<EnumAttrCase> cases, raw_ostream &os) {
  os << llvm::formatv("class {0}(Enum):\n", enumName);
  if (!description.empty())
    os << llvm::formatv("    \"\"\"{0}\"\"\"\n", description);
  os << "\n";

  for (const EnumAttrCase &enumCase : cases) {
    os << llvm::formatv("    {0} = {1}\n",
                        makePythonEnumCaseName(enumCase.getSymbol()),
                        enumCase.getValue());
  }

  os << "\n";
  os << llvm::formatv("    def _as_int(self):\n");
  for (const EnumAttrCase &enumCase : cases) {
    os << llvm::formatv("        if self is {0}.{1}:\n", enumName,
                        makePythonEnumCaseName(enumCase.getSymbol()));
    os << llvm::formatv("            return {0}\n", enumCase.getValue());
  }
  os << llvm::formatv("        assert False, \"Unknown {0} enum entry.\"\n\n\n",
                      enumName);
}

/// Attempts to extract the bitwidth B from string "uintB_t" describing the
/// type. This bitwidth information is not readily available in ODS. Returns
/// `false` on success, `true` on failure.
static bool extractUIntBitwidth(StringRef uintType, int64_t &bitwidth) {
  if (!uintType.consume_front("uint"))
    return true;
  if (!uintType.consume_back("_t"))
    return true;
  return uintType.getAsInteger(/*Radix=*/10, bitwidth);
}

/// Emits an attribute builder for the given enum attribute to support automatic
/// conversion between enum values and attributes in Python. Returns
/// `false` on success, `true` on failure.
static bool emitAttributeBuilder(const EnumAttr &enumAttr, raw_ostream &os) {
  int64_t bitwidth;
  if (extractUIntBitwidth(enumAttr.getUnderlyingType(), bitwidth)) {
    llvm::errs() << "failed to identify bitwidth of "
                 << enumAttr.getUnderlyingType();
    return true;
  }

  os << llvm::formatv("@_register_attribute_builder(\"{0}\")\n",
                      enumAttr.getAttrDefName());
  os << llvm::formatv(
      "def _{0}(x, context):\n",
      llvm::convertToSnakeFromCamelCase(enumAttr.getAttrDefName()));
  os << llvm::formatv(
      "    return "
      "_ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless({0}, "
      "context=context), x._as_int())\n\n",
      bitwidth);
  return false;
}

/// Emits Python bindings for all enums in the record keeper. Returns
/// `false` on success, `true` on failure.
static bool emitPythonEnums(const llvm::RecordKeeper &recordKeeper,
                            raw_ostream &os) {
  os << fileHeader;
  std::vector<llvm::Record *> defs =
      recordKeeper.getAllDerivedDefinitionsIfDefined("EnumAttrInfo");
  for (const llvm::Record *def : defs) {
    EnumAttr enumAttr(*def);
    if (enumAttr.isBitEnum()) {
      llvm::errs() << "bit enums not supported\n";
      return true;
    }
    emitEnumClass(enumAttr.getEnumClassName(), enumAttr.getSummary(),
                  enumAttr.getAllCases(), os);
    emitAttributeBuilder(enumAttr, os);
  }
  return false;
}

// Registers the enum utility generator to mlir-tblgen.
static mlir::GenRegistration
    genPythonEnumBindings("gen-python-enum-bindings",
                          "Generate Python bindings for enum attributes",
                          &emitPythonEnums);
