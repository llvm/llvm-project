// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP___CONFIG
#define _LIBCPP___CONFIG

#include <__config_site>

#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
#  pragma GCC system_header
#endif

#ifdef __cplusplus

#  include <__configuration/abi.h>
#  include <__configuration/attributes.h>
#  include <__configuration/availability.h>
#  include <__configuration/compiler.h>
#  include <__configuration/experimental.h>
#  include <__configuration/hardening.h>
#  include <__configuration/language.h>
#  include <__configuration/platform.h>

// The attributes supported by clang are documented at https://clang.llvm.org/docs/AttributeReference.html

// _LIBCPP_VERSION represents the version of libc++, which matches the version of LLVM.
// Given a LLVM release LLVM XX.YY.ZZ (e.g. LLVM 17.0.1 == 17.00.01), _LIBCPP_VERSION is
// defined to XXYYZZ.
#  define _LIBCPP_VERSION 230000

#  define _LIBCPP_CONCAT_IMPL(_X, _Y) _X##_Y
#  define _LIBCPP_CONCAT(_X, _Y) _LIBCPP_CONCAT_IMPL(_X, _Y)
#  define _LIBCPP_CONCAT3(X, Y, Z) _LIBCPP_CONCAT(X, _LIBCPP_CONCAT(Y, Z))

#  if __STDC_HOSTED__ == 0
#    define _LIBCPP_FREESTANDING
#  endif

#  define _LIBCPP_TOSTRING2(x) #x
#  define _LIBCPP_TOSTRING(x) _LIBCPP_TOSTRING2(x)

#  ifndef __has_constexpr_builtin
#    define __has_constexpr_builtin(x) 0
#  endif

// This checks wheter a Clang module is built
#  ifndef __building_module
#    define __building_module(...) 0
#  endif

// '__is_identifier' returns '0' if '__x' is a reserved identifier provided by
// the compiler and '1' otherwise.
#  ifndef __is_identifier
#    define __is_identifier(__x) 1
#  endif

#  define __has_keyword(__x) !(__is_identifier(__x))

#  ifndef __has_warning
#    define __has_warning(...) 0
#  endif

#  if !defined(_LIBCPP_COMPILER_CLANG_BASED) && __cplusplus < 201103L
#    error "libc++ only supports C++03 with Clang-based compilers. Please enable C++11"
#  endif

#  if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)
#    define _LIBCPP_ABI_VCRUNTIME
#  endif

#  if defined(__MVS__)
#    include <features.h> // for __NATIVE_ASCII_F
#  endif

#  if defined(_WIN32)
#    define _LIBCPP_WIN32API
#    define _LIBCPP_SHORT_WCHAR 1
// Both MinGW and native MSVC provide a "MSVC"-like environment
#    define _LIBCPP_MSVCRT_LIKE
// If mingw not explicitly detected, assume using MS C runtime only if
// a MS compatibility version is specified.
#    if defined(_MSC_VER) && !defined(__MINGW32__)
#      define _LIBCPP_MSVCRT // Using Microsoft's C Runtime library
#    endif
#    if (defined(_M_AMD64) || defined(__x86_64__)) || (defined(_M_ARM) || defined(__arm__))
#      define _LIBCPP_HAS_BITSCAN64 1
#    else
#      define _LIBCPP_HAS_BITSCAN64 0
#    endif
#    define _LIBCPP_HAS_OPEN_WITH_WCHAR 1
#  else
#    define _LIBCPP_HAS_OPEN_WITH_WCHAR 0
#    define _LIBCPP_HAS_BITSCAN64 0
#  endif // defined(_WIN32)

#  if defined(_AIX) && !defined(__64BIT__)
// The size of wchar is 2 byte on 32-bit mode on AIX.
#    define _LIBCPP_SHORT_WCHAR 1
#  endif

// Libc++ supports various implementations of std::random_device.
//
// _LIBCPP_USING_DEV_RANDOM
//      Read entropy from the given file, by default `/dev/urandom`.
//      If a token is provided, it is assumed to be the path to a file
//      to read entropy from. This is the default behavior if nothing
//      else is specified. This implementation requires storing state
//      inside `std::random_device`.
//
// _LIBCPP_USING_ARC4_RANDOM
//      Use arc4random(). This allows obtaining random data even when
//      using sandboxing mechanisms. On some platforms like Apple, this
//      is the recommended source of entropy for user-space programs.
//      When this option is used, the token passed to `std::random_device`'s
//      constructor *must* be "/dev/urandom" -- anything else is an error.
//
// _LIBCPP_USING_GETENTROPY
//      Use getentropy().
//      When this option is used, the token passed to `std::random_device`'s
//      constructor *must* be "/dev/urandom" -- anything else is an error.
//
// _LIBCPP_USING_FUCHSIA_CPRNG
//      Use Fuchsia's zx_cprng_draw() system call, which is specified to
//      deliver high-quality entropy and cannot fail.
//      When this option is used, the token passed to `std::random_device`'s
//      constructor *must* be "/dev/urandom" -- anything else is an error.
//
// _LIBCPP_USING_WIN32_RANDOM
//      Use rand_s(), for use on Windows.
//      When this option is used, the token passed to `std::random_device`'s
//      constructor *must* be "/dev/urandom" -- anything else is an error.
#  if defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) ||                     \
      defined(__DragonFly__)
#    define _LIBCPP_USING_ARC4_RANDOM
#  elif defined(__wasi__) || defined(__EMSCRIPTEN__)
#    define _LIBCPP_USING_GETENTROPY
#  elif defined(__Fuchsia__)
#    define _LIBCPP_USING_FUCHSIA_CPRNG
#  elif defined(_LIBCPP_WIN32API)
#    define _LIBCPP_USING_WIN32_RANDOM
#  else
#    define _LIBCPP_USING_DEV_RANDOM
#  endif

#  ifndef _LIBCPP_CXX03_LANG

#    define _LIBCPP_ALIGNOF(...) alignof(__VA_ARGS__)
#    define _ALIGNAS_TYPE(x) alignas(x)
#    define _ALIGNAS(x) alignas(x)
#    define _NOEXCEPT noexcept
#    define _NOEXCEPT_(...) noexcept(__VA_ARGS__)
#    define _LIBCPP_CONSTEXPR constexpr

#  else

#    define _LIBCPP_ALIGNOF(...) _Alignof(__VA_ARGS__)
#    define _ALIGNAS_TYPE(x) __attribute__((__aligned__(_LIBCPP_ALIGNOF(x))))
#    define _ALIGNAS(x) __attribute__((__aligned__(x)))
#    define nullptr __nullptr
#    define _NOEXCEPT throw()
#    define _NOEXCEPT_(...)
#    define static_assert(...) _Static_assert(__VA_ARGS__)
#    define decltype(...) __decltype(__VA_ARGS__)
#    define _LIBCPP_CONSTEXPR

typedef __char16_t char16_t;
typedef __char32_t char32_t;

#  endif

#  define _LIBCPP_PREFERRED_ALIGNOF(_Tp) __alignof(_Tp)

#  if __has_extension(blocks) && defined(__APPLE__)
#    define _LIBCPP_HAS_BLOCKS_RUNTIME 1
#  else
#    define _LIBCPP_HAS_BLOCKS_RUNTIME 0
#  endif

#  ifdef _LIBCPP_COMPILER_CLANG_BASED
#    define _LIBCPP_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
#    define _LIBCPP_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
#    define _LIBCPP_CLANG_DIAGNOSTIC_IGNORED(str) _Pragma(_LIBCPP_TOSTRING(clang diagnostic ignored str))
#    define _LIBCPP_GCC_DIAGNOSTIC_IGNORED(str)
#  elif defined(_LIBCPP_COMPILER_GCC)
#    define _LIBCPP_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
#    define _LIBCPP_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
#    define _LIBCPP_CLANG_DIAGNOSTIC_IGNORED(str)
#    define _LIBCPP_GCC_DIAGNOSTIC_IGNORED(str) _Pragma(_LIBCPP_TOSTRING(GCC diagnostic ignored str))
#  else
#    define _LIBCPP_DIAGNOSTIC_PUSH
#    define _LIBCPP_DIAGNOSTIC_POP
#    define _LIBCPP_CLANG_DIAGNOSTIC_IGNORED(str)
#    define _LIBCPP_GCC_DIAGNOSTIC_IGNORED(str)
#  endif

// Macros to enter and leave a state where deprecation warnings are suppressed.
#  define _LIBCPP_SUPPRESS_DEPRECATED_PUSH                                                                             \
    _LIBCPP_DIAGNOSTIC_PUSH _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wdeprecated")                                           \
        _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wdeprecated-declarations")
#  define _LIBCPP_SUPPRESS_DEPRECATED_POP _LIBCPP_DIAGNOSTIC_POP

// Clang modules take a significant compile time hit when pushing and popping diagnostics.
// Since all the headers are marked as system headers unless _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER is defined, we can
// simply disable this pushing and popping when _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER isn't defined.
#  ifdef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
#    define _LIBCPP_PUSH_EXTENSION_DIAGNOSTICS                                                                         \
      _LIBCPP_DIAGNOSTIC_PUSH                                                                                          \
      _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wc++11-extensions")                                                           \
      _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wc++14-extensions")                                                           \
      _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wc++17-extensions")                                                           \
      _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wc++20-extensions")                                                           \
      _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wc++23-extensions")                                                           \
      _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wc++14-extensions")                                                             \
      _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wc++17-extensions")                                                             \
      _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wc++20-extensions")                                                             \
      _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wc++23-extensions")
#    define _LIBCPP_POP_EXTENSION_DIAGNOSTICS _LIBCPP_DIAGNOSTIC_POP
#  else
#    define _LIBCPP_PUSH_EXTENSION_DIAGNOSTICS
#    define _LIBCPP_POP_EXTENSION_DIAGNOSTICS
#  endif

// clang-format off

// The unversioned namespace is used when we want to be ABI compatible with other standard libraries in some way. There
// are two main categories where that's the case:
// - Historically, we have made exception types ABI compatible with libstdc++ to allow throwing them between libstdc++
//   and libc++. This is not used anymore for new exception types, since there is no use-case for it anymore.
// - Types and functions which are used by the compiler are in the unversioned namespace, since the compiler has to know
//   their mangling without the appropriate declaration in some cases.
// If it's not clear whether using the unversioned namespace is the correct thing to do, it's not. The versioned
// namespace (_LIBCPP_BEGIN_NAMESPACE_STD) should almost always be used.
#  define _LIBCPP_BEGIN_UNVERSIONED_NAMESPACE_STD                                                                      \
    _LIBCPP_PUSH_EXTENSION_DIAGNOSTICS namespace _LIBCPP_NAMESPACE_VISIBILITY std {

#  define _LIBCPP_END_UNVERSIONED_NAMESPACE_STD } _LIBCPP_POP_EXTENSION_DIAGNOSTICS

#  define _LIBCPP_BEGIN_NAMESPACE_STD _LIBCPP_BEGIN_UNVERSIONED_NAMESPACE_STD inline namespace _LIBCPP_ABI_NAMESPACE {
#  define _LIBCPP_END_NAMESPACE_STD } _LIBCPP_END_UNVERSIONED_NAMESPACE_STD

// TODO: This should really be in the versioned namespace
#define _LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL _LIBCPP_BEGIN_UNVERSIONED_NAMESPACE_STD namespace experimental {
#define _LIBCPP_END_NAMESPACE_EXPERIMENTAL } _LIBCPP_END_UNVERSIONED_NAMESPACE_STD

#define _LIBCPP_BEGIN_NAMESPACE_LFTS _LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL inline namespace fundamentals_v1 {
#define _LIBCPP_END_NAMESPACE_LFTS } _LIBCPP_END_NAMESPACE_EXPERIMENTAL

#define _LIBCPP_BEGIN_NAMESPACE_LFTS_V2 _LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL inline namespace fundamentals_v2 {
#define _LIBCPP_END_NAMESPACE_LFTS_V2 } _LIBCPP_END_NAMESPACE_EXPERIMENTAL

#ifdef _LIBCPP_ABI_NO_FILESYSTEM_INLINE_NAMESPACE
#  define _LIBCPP_BEGIN_NAMESPACE_FILESYSTEM _LIBCPP_BEGIN_NAMESPACE_STD namespace filesystem {
#  define _LIBCPP_END_NAMESPACE_FILESYSTEM } _LIBCPP_END_NAMESPACE_STD
#else
#  define _LIBCPP_BEGIN_NAMESPACE_FILESYSTEM _LIBCPP_BEGIN_NAMESPACE_STD                                               \
                                             inline namespace __fs { namespace filesystem {

#  define _LIBCPP_END_NAMESPACE_FILESYSTEM }} _LIBCPP_END_NAMESPACE_STD
#endif

// clang-format on

#  if !defined(__SIZEOF_INT128__) || defined(_MSC_VER)
#    define _LIBCPP_HAS_INT128 0
#  else
#    define _LIBCPP_HAS_INT128 1
#  endif

#  ifdef _LIBCPP_CXX03_LANG
#    define _LIBCPP_DECLARE_STRONG_ENUM(x)                                                                             \
      struct _LIBCPP_EXPORTED_FROM_ABI x {                                                                             \
        enum __lx
// clang-format off
#    define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x)                                                                      \
      __lx __v_;                                                                                                       \
      _LIBCPP_HIDE_FROM_ABI x(__lx __v) : __v_(__v) {}                                                                 \
      _LIBCPP_HIDE_FROM_ABI explicit x(int __v) : __v_(static_cast<__lx>(__v)) {}                                      \
      _LIBCPP_HIDE_FROM_ABI operator int() const { return __v_; }                                                      \
      };
// clang-format on

#  else // _LIBCPP_CXX03_LANG
#    define _LIBCPP_DECLARE_STRONG_ENUM(x) enum class x
#    define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x)
#  endif // _LIBCPP_CXX03_LANG

#  ifdef __FreeBSD__
#    define _DECLARE_C99_LDBL_MATH 1
#  endif

// If we are getting operator new from the MSVC CRT, then allocation overloads
// for align_val_t were added in 19.12, aka VS 2017 version 15.3.
#  if defined(_LIBCPP_MSVCRT) && defined(_MSC_VER) && _MSC_VER < 1912
#    define _LIBCPP_HAS_LIBRARY_ALIGNED_ALLOCATION 0
#  elif defined(_LIBCPP_ABI_VCRUNTIME) && !defined(__cpp_aligned_new)
// We're deferring to Microsoft's STL to provide aligned new et al. We don't
// have it unless the language feature test macro is defined.
#    define _LIBCPP_HAS_LIBRARY_ALIGNED_ALLOCATION 0
#  elif defined(__MVS__)
#    define _LIBCPP_HAS_LIBRARY_ALIGNED_ALLOCATION 0
#  else
#    define _LIBCPP_HAS_LIBRARY_ALIGNED_ALLOCATION 1
#  endif

#  if !_LIBCPP_HAS_LIBRARY_ALIGNED_ALLOCATION || (!defined(__cpp_aligned_new) || __cpp_aligned_new < 201606)
#    define _LIBCPP_HAS_ALIGNED_ALLOCATION 0
#  else
#    define _LIBCPP_HAS_ALIGNED_ALLOCATION 1
#  endif

#  if defined(__APPLE__) || defined(__FreeBSD__)
#    define _LIBCPP_WCTYPE_IS_MASK
#  endif

// FIXME: using `#warning` causes diagnostics from system headers which include deprecated headers. This can only be
// enabled again once https://github.com/llvm/llvm-project/pull/168041 (or a similar feature) has landed, since that
// allows suppression in system headers.
#  if defined(__DEPRECATED) && __DEPRECATED && !defined(_LIBCPP_DISABLE_DEPRECATION_WARNINGS) && 0
#    define _LIBCPP_DIAGNOSE_DEPRECATED_HEADERS 1
#  else
#    define _LIBCPP_DIAGNOSE_DEPRECATED_HEADERS 0
#  endif

#  if _LIBCPP_STD_VER <= 11
#    define _LIBCPP_EXPLICIT_SINCE_CXX14
#  else
#    define _LIBCPP_EXPLICIT_SINCE_CXX14 explicit
#  endif

#  if _LIBCPP_STD_VER >= 23
#    define _LIBCPP_EXPLICIT_SINCE_CXX23 explicit
#  else
#    define _LIBCPP_EXPLICIT_SINCE_CXX23
#  endif

#  if _LIBCPP_STD_VER >= 14
#    define _LIBCPP_CONSTEXPR_SINCE_CXX14 constexpr
#  else
#    define _LIBCPP_CONSTEXPR_SINCE_CXX14
#  endif

#  if _LIBCPP_STD_VER >= 17
#    define _LIBCPP_CONSTEXPR_SINCE_CXX17 constexpr
#  else
#    define _LIBCPP_CONSTEXPR_SINCE_CXX17
#  endif

#  if _LIBCPP_STD_VER >= 20
#    define _LIBCPP_CONSTEXPR_SINCE_CXX20 constexpr
#  else
#    define _LIBCPP_CONSTEXPR_SINCE_CXX20
#  endif

#  if _LIBCPP_STD_VER >= 23
#    define _LIBCPP_CONSTEXPR_SINCE_CXX23 constexpr
#  else
#    define _LIBCPP_CONSTEXPR_SINCE_CXX23
#  endif

#  if _LIBCPP_STD_VER >= 26
#    define _LIBCPP_CONSTEXPR_SINCE_CXX26 constexpr
#  else
#    define _LIBCPP_CONSTEXPR_SINCE_CXX26
#  endif

// Thread API
// clang-format off
#  if _LIBCPP_HAS_THREADS &&                                                                                           \
      !_LIBCPP_HAS_THREAD_API_PTHREAD &&                                                                               \
      !_LIBCPP_HAS_THREAD_API_WIN32 &&                                                                                 \
      !_LIBCPP_HAS_THREAD_API_EXTERNAL

#    if defined(__FreeBSD__) ||                                                                                        \
        defined(__wasi__) ||                                                                                           \
        defined(__NetBSD__) ||                                                                                         \
        defined(__OpenBSD__) ||                                                                                        \
        defined(__NuttX__) ||                                                                                          \
        defined(__linux__) ||                                                                                          \
        defined(__GNU__) ||                                                                                            \
        defined(__APPLE__) ||                                                                                          \
        defined(__MVS__) ||                                                                                            \
        defined(_AIX) ||                                                                                               \
        defined(__EMSCRIPTEN__)
// clang-format on
#      undef _LIBCPP_HAS_THREAD_API_PTHREAD
#      define _LIBCPP_HAS_THREAD_API_PTHREAD 1
#    elif defined(__Fuchsia__)
// TODO(44575): Switch to C11 thread API when possible.
#      undef _LIBCPP_HAS_THREAD_API_PTHREAD
#      define _LIBCPP_HAS_THREAD_API_PTHREAD 1
#    elif defined(_LIBCPP_WIN32API)
#      undef _LIBCPP_HAS_THREAD_API_WIN32
#      define _LIBCPP_HAS_THREAD_API_WIN32 1
#    else
#      error "No thread API"
#    endif // _LIBCPP_HAS_THREAD_API
#  endif   // _LIBCPP_HAS_THREADS

#  if !_LIBCPP_HAS_THREAD_API_PTHREAD
#    define _LIBCPP_HAS_COND_CLOCKWAIT 0
#  elif (defined(__ANDROID__) && __ANDROID_API__ >= 30) || _LIBCPP_GLIBC_PREREQ(2, 30)
#    define _LIBCPP_HAS_COND_CLOCKWAIT 1
#  else
#    define _LIBCPP_HAS_COND_CLOCKWAIT 0
#  endif

#  if !_LIBCPP_HAS_THREADS && _LIBCPP_HAS_THREAD_API_PTHREAD
#    error _LIBCPP_HAS_THREAD_API_PTHREAD may only be true when _LIBCPP_HAS_THREADS is true.
#  endif

#  if !_LIBCPP_HAS_THREADS && _LIBCPP_HAS_THREAD_API_EXTERNAL
#    error _LIBCPP_HAS_THREAD_API_EXTERNAL may only be true when _LIBCPP_HAS_THREADS is true.
#  endif

#  if !_LIBCPP_HAS_MONOTONIC_CLOCK && _LIBCPP_HAS_THREADS
#    error _LIBCPP_HAS_MONOTONIC_CLOCK may only be false when _LIBCPP_HAS_THREADS is false.
#  endif

#  if _LIBCPP_HAS_THREADS && !defined(__STDCPP_THREADS__)
#    define __STDCPP_THREADS__ 1
#  endif

// The glibc and Bionic implementation of pthreads implements
// pthread_mutex_destroy as nop for regular mutexes. Additionally, Win32
// mutexes have no destroy mechanism.
//
// This optimization can't be performed on Apple platforms, where
// pthread_mutex_destroy can allow the kernel to release resources.
// See https://llvm.org/D64298 for details.
//
// TODO(EricWF): Enable this optimization on Bionic after speaking to their
//               respective stakeholders.
// clang-format off
#  if (_LIBCPP_HAS_THREAD_API_PTHREAD && defined(__GLIBC__)) ||                                                        \
      (_LIBCPP_HAS_THREAD_API_C11 && defined(__Fuchsia__)) ||                                                          \
       _LIBCPP_HAS_THREAD_API_WIN32
// clang-format on
#    define _LIBCPP_HAS_TRIVIAL_MUTEX_DESTRUCTION 1
#  else
#    define _LIBCPP_HAS_TRIVIAL_MUTEX_DESTRUCTION 0
#  endif

// Destroying a condvar is a nop on Windows.
//
// This optimization can't be performed on Apple platforms, where
// pthread_cond_destroy can allow the kernel to release resources.
// See https://llvm.org/D64298 for details.
//
// TODO(EricWF): This is potentially true for some pthread implementations
// as well.
#  if (_LIBCPP_HAS_THREAD_API_C11 && defined(__Fuchsia__)) || _LIBCPP_HAS_THREAD_API_WIN32
#    define _LIBCPP_HAS_TRIVIAL_CONDVAR_DESTRUCTION 1
#  else
#    define _LIBCPP_HAS_TRIVIAL_CONDVAR_DESTRUCTION 0
#  endif

#  if defined(__BIONIC__) || defined(__NuttX__) || defined(__Fuchsia__) || defined(__wasi__) ||                        \
      _LIBCPP_HAS_MUSL_LIBC || defined(__OpenBSD__) || _LIBCPP_LIBC_LLVM_LIBC
#    define _LIBCPP_PROVIDES_DEFAULT_RUNE_TABLE
#  endif

#  if __has_feature(cxx_atomic) || __has_extension(c_atomic) || __has_keyword(_Atomic)
#    define _LIBCPP_HAS_C_ATOMIC_IMP 1
#    define _LIBCPP_HAS_GCC_ATOMIC_IMP 0
#    define _LIBCPP_HAS_EXTERNAL_ATOMIC_IMP 0
#  elif defined(_LIBCPP_COMPILER_GCC)
#    define _LIBCPP_HAS_C_ATOMIC_IMP 0
#    define _LIBCPP_HAS_GCC_ATOMIC_IMP 1
#    define _LIBCPP_HAS_EXTERNAL_ATOMIC_IMP 0
#  endif

#  if !_LIBCPP_HAS_C_ATOMIC_IMP && !_LIBCPP_HAS_GCC_ATOMIC_IMP && !_LIBCPP_HAS_EXTERNAL_ATOMIC_IMP
#    define _LIBCPP_HAS_ATOMIC_HEADER 0
#  else
#    define _LIBCPP_HAS_ATOMIC_HEADER 1
#    ifndef _LIBCPP_ATOMIC_FLAG_TYPE
#      define _LIBCPP_ATOMIC_FLAG_TYPE bool
#    endif
#  endif

// We often repeat things just for handling wide characters in the library.
// When wide characters are disabled, it can be useful to have a quick way of
// disabling it without having to resort to #if-#endif, which has a larger
// impact on readability.
#  if !_LIBCPP_HAS_WIDE_CHARACTERS
#    define _LIBCPP_IF_WIDE_CHARACTERS(...)
#  else
#    define _LIBCPP_IF_WIDE_CHARACTERS(...) __VA_ARGS__
#  endif

// clang-format off
#  define _LIBCPP_PUSH_MACROS _Pragma("push_macro(\"min\")") _Pragma("push_macro(\"max\")") _Pragma("push_macro(\"refresh\")") _Pragma("push_macro(\"move\")") _Pragma("push_macro(\"erase\")")
#  define _LIBCPP_POP_MACROS _Pragma("pop_macro(\"min\")") _Pragma("pop_macro(\"max\")") _Pragma("pop_macro(\"refresh\")") _Pragma("pop_macro(\"move\")") _Pragma("pop_macro(\"erase\")")
// clang-format on

#  ifndef _LIBCPP_NO_AUTO_LINK
#    if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_BUILDING_LIBRARY)
#      if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
#        pragma comment(lib, "c++.lib")
#      else
#        pragma comment(lib, "libc++.lib")
#      endif
#    endif // defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_BUILDING_LIBRARY)
#  endif   // _LIBCPP_NO_AUTO_LINK

// Configures the fopen close-on-exec mode character, if any. This string will
// be appended to any mode string used by fstream for fopen/fdopen.
//
// Not all platforms support this, but it helps avoid fd-leaks on platforms that
// do.
#  if defined(__BIONIC__)
#    define _LIBCPP_FOPEN_CLOEXEC_MODE "e"
#  else
#    define _LIBCPP_FOPEN_CLOEXEC_MODE
#  endif

// c8rtomb() and mbrtoc8() were added in C++20 and C23. Support for these
// functions is gradually being added to existing C libraries. The conditions
// below check for known C library versions and conditions under which these
// functions are declared by the C library.
//
// GNU libc 2.36 and newer declare c8rtomb() and mbrtoc8() in C++ modes if
// __cpp_char8_t is defined or if C2X extensions are enabled. Determining
// the latter depends on internal GNU libc details that are not appropriate
// to depend on here, so any declarations present when __cpp_char8_t is not
// defined are ignored.
#  if _LIBCPP_GLIBC_PREREQ(2, 36) && defined(__cpp_char8_t)
#    define _LIBCPP_HAS_C8RTOMB_MBRTOC8 1
#  else
#    define _LIBCPP_HAS_C8RTOMB_MBRTOC8 0
#  endif

// There are a handful of public standard library types that are intended to
// support CTAD but don't need any explicit deduction guides to do so. This
// macro is used to mark them as such, which suppresses the
// '-Wctad-maybe-unsupported' compiler warning when CTAD is used in user code
// with these classes.
#  if _LIBCPP_STD_VER >= 17
#    ifdef _LIBCPP_COMPILER_CLANG_BASED
#      define _LIBCPP_CTAD_SUPPORTED_FOR_TYPE(_ClassName)                                                              \
        template <class... _Tag>                                                                                       \
        [[maybe_unused]] _ClassName(typename _Tag::__allow_ctad...)->_ClassName<_Tag...>
#    else
#      define _LIBCPP_CTAD_SUPPORTED_FOR_TYPE(ClassName)                                                               \
        template <class... _Tag>                                                                                       \
        ClassName(typename _Tag::__allow_ctad...)->ClassName<_Tag...>
#    endif
#  else
#    define _LIBCPP_CTAD_SUPPORTED_FOR_TYPE(_ClassName) static_assert(true, "")
#  endif

#  if defined(__OBJC__) && defined(_LIBCPP_APPLE_CLANG_VER)
#    define _LIBCPP_WORKAROUND_OBJCXX_COMPILER_INTRINSICS
#  endif

#  define _PSTL_PRAGMA(x) _Pragma(#x)

// Enable SIMD for compilers that support OpenMP 4.0
#  if (defined(_OPENMP) && _OPENMP >= 201307)

#    define _PSTL_UDR_PRESENT
#    define _PSTL_PRAGMA_SIMD _PSTL_PRAGMA(omp simd)
#    define _PSTL_PRAGMA_DECLARE_SIMD _PSTL_PRAGMA(omp declare simd)
#    define _PSTL_PRAGMA_SIMD_REDUCTION(PRM) _PSTL_PRAGMA(omp simd reduction(PRM))
#    define _PSTL_PRAGMA_SIMD_SCAN(PRM) _PSTL_PRAGMA(omp simd reduction(inscan, PRM))
#    define _PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM) _PSTL_PRAGMA(omp scan inclusive(PRM))
#    define _PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM) _PSTL_PRAGMA(omp scan exclusive(PRM))

// Declaration of reduction functor, where
// NAME - the name of the functor
// OP - type of the callable object with the reduction operation
// omp_in - refers to the local partial result
// omp_out - refers to the final value of the combiner operator
// omp_priv - refers to the private copy of the initial value
// omp_orig - refers to the original variable to be reduced
#    define _PSTL_PRAGMA_DECLARE_REDUCTION(NAME, OP)                                                                   \
      _PSTL_PRAGMA(omp declare reduction(NAME:OP : omp_out(omp_in)) initializer(omp_priv = omp_orig))

#  elif defined(_LIBCPP_COMPILER_CLANG_BASED)

#    define _PSTL_PRAGMA_SIMD _Pragma("clang loop vectorize(enable) interleave(enable)")
#    define _PSTL_PRAGMA_DECLARE_SIMD
#    define _PSTL_PRAGMA_SIMD_REDUCTION(PRM) _Pragma("clang loop vectorize(enable) interleave(enable)")
#    define _PSTL_PRAGMA_SIMD_SCAN(PRM) _Pragma("clang loop vectorize(enable) interleave(enable)")
#    define _PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM)
#    define _PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM)
#    define _PSTL_PRAGMA_DECLARE_REDUCTION(NAME, OP)

#  else // (defined(_OPENMP) && _OPENMP >= 201307)

#    define _PSTL_PRAGMA_SIMD
#    define _PSTL_PRAGMA_DECLARE_SIMD
#    define _PSTL_PRAGMA_SIMD_REDUCTION(PRM)
#    define _PSTL_PRAGMA_SIMD_SCAN(PRM)
#    define _PSTL_PRAGMA_SIMD_INCLUSIVE_SCAN(PRM)
#    define _PSTL_PRAGMA_SIMD_EXCLUSIVE_SCAN(PRM)
#    define _PSTL_PRAGMA_DECLARE_REDUCTION(NAME, OP)

#  endif // (defined(_OPENMP) && _OPENMP >= 201307)

#  define _PSTL_USE_NONTEMPORAL_STORES_IF_ALLOWED

#endif // __cplusplus

#endif // _LIBCPP___CONFIG
