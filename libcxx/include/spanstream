// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_SPANSTREAM
#define _LIBCPP_SPANSTREAM

// clang-format off

/*
  Span-based streams [span.streams]

  template<class charT, class traits = char_traits<charT>>
    class basic_spanbuf;

  template<class charT, class traits>
    void swap(basic_spanbuf<charT, traits>& x, basic_spanbuf<charT, traits>& y);

  using spanbuf = basic_spanbuf<char>;
  using wspanbuf = basic_spanbuf<wchar_t>;

  template<class charT, class traits = char_traits<charT>>
    class basic_ispanstream;

  template<class charT, class traits>
    void swap(basic_ispanstream<charT, traits>& x, basic_ispanstream<charT, traits>& y);

  using ispanstream = basic_ispanstream<char>;
  using wispanstream = basic_ispanstream<wchar_t>;

  template<class charT, class traits = char_traits<charT>>
    class basic_ospanstream;

  template<class charT, class traits>
    void swap(basic_ospanstream<charT, traits>& x, basic_ospanstream<charT, traits>& y);

  using ospanstream = basic_ospanstream<char>;
  using wospanstream = basic_ospanstream<wchar_t>;

  template<class charT, class traits = char_traits<charT>>
    class basic_spanstream;

  template<class charT, class traits>
    void swap(basic_spanstream<charT, traits>& x, basic_spanstream<charT, traits>& y);

  using spanstream = basic_spanstream<char>;
  using wspanstream = basic_spanstream<wchar_t>;
*/

// clang-format on

#include <__assert> // all public C++ headers provide the assertion handler
#include <__availability>
#include <__concepts/convertible_to.h>
#include <__config>
#include <__fwd/spanstream.h>
#include <__memory/addressof.h>
#include <__ranges/concepts.h>
#include <__utility/cmp.h>
#include <__utility/forward.h>
#include <__utility/move.h>
#include <__utility/swap.h>
#include <iostream>
#include <span>
#include <streambuf>
#include <version>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

#if _LIBCPP_STD_VER >= 23

// Class template basic_spanbuf [spanbuf]

template <class _CharT, class _Traits>
class _LIBCPP_TEMPLATE_VIS basic_spanbuf : public basic_streambuf<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [spanbuf.cons], constructors

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf() : basic_spanbuf(ios_base::in | ios_base::out) {}

  _LIBCPP_HIDE_FROM_ABI explicit basic_spanbuf(ios_base::openmode __which)
      : basic_spanbuf(std::span<_CharT>(), __which) {}

  _LIBCPP_HIDE_FROM_ABI explicit basic_spanbuf(std::span<_CharT> __s,
                                               ios_base::openmode __which = ios_base::in | ios_base::out)
      : basic_streambuf<_CharT, _Traits>{}, __mode_{__which}, __buf_{__s} {
    this->span(__s);
  }

  basic_spanbuf(const basic_spanbuf&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf(basic_spanbuf&& __rhs)
      : basic_streambuf<_CharT, _Traits>{std::move(__rhs)},
        __mode_{std::move(__rhs.__mode_)},
        __buf_{std::move(__rhs.__buf_)} {}

  // [spanbuf.assign], assignment and swap

  basic_spanbuf& operator=(const basic_spanbuf&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf& operator=(basic_spanbuf&& __rhs) {
    basic_spanbuf __tmp{std::move(__rhs)};
    this->swap(__tmp);
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI void swap(basic_spanbuf& __rhs) {
    basic_streambuf<_CharT, _Traits>::swap(__rhs);
    std::swap(__mode_, __rhs.__mode_);
    std::swap(__buf_, __rhs.__buf_);
  }

  // [spanbuf.members], member functions

  _LIBCPP_HIDE_FROM_ABI std::span<_CharT> span() const noexcept {
    if (__mode_ & ios_base::out) {
      return std::span<_CharT>(this->pbase(), this->pptr());
    }
    return __buf_;
  }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept {
    __buf_ = __s;

    if (__mode_ & ios_base::out) {
      this->setp(__s.data(), __s.data() + __s.size());
      if (__mode_ & ios_base::ate) {
        this->pbump(__s.size());
      }
    }

    if (__mode_ & ios_base::in) {
      this->setg(__s.data(), __s.data(), __s.data() + __s.size());
    }
  }

protected:
  // [spanbuf.virtuals], overridden virtual functions

  _LIBCPP_HIDE_FROM_ABI basic_streambuf<_CharT, _Traits>* setbuf(_CharT* __s, streamsize __n) override {
    this->span(std::span<_CharT>(__s, __n));
    return this;
  }

  _LIBCPP_HIDE_FROM_ABI pos_type
  seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out) override {
    const pos_type __error(off_type(-1));

    if ((__which & ios_base::in) && (__which & ios_base::out) && (ios_base::cur == __way))
      return __error;

    off_type __baseoff = [this, __way, __which] {
      switch (__way) {
      case ios_base::beg:
        return off_type(0);

      case ios_base::cur:
        if (__which & ios_base::out)
          return off_type(this->pptr() - this->pbase());
        return off_type(this->gptr() - this->eback());

      case ios_base::end:
        if ((__which & ios_base::out) && !(__which & ios_base::in))
          return off_type(this->pptr() - this->pbase());
        return off_type(__buf_.size());
      }
    }();

    off_type __newoff;
    if (__builtin_add_overflow(__baseoff, __off, &__newoff) || (__newoff < off_type(0)) ||
        (std::cmp_greater(__newoff, __buf_.size())))
      return __error;

    if (__which & ios_base::in) {
      if ((this->gptr() == nullptr) && (__newoff != off_type(0)))
        return __error;
      this->setg(this->eback(), this->eback() + __newoff, this->egptr());
    }

    if (__which & ios_base::out) {
      if ((this->pptr() == nullptr) && (__newoff != off_type(0)))
        return __error;
      this->setp(this->pbase(), this->epptr());
      this->pbump(__newoff);
    }

    return pos_type(__newoff);
  }

  _LIBCPP_HIDE_FROM_ABI pos_type seekpos(pos_type __sp,
                                         ios_base::openmode __which = ios_base::in | ios_base::out) override {
    return seekoff(off_type(__sp), ios_base::beg, __which);
  }

private:
  ios_base::openmode __mode_; // exposition only
  std::span<_CharT> __buf_;   // exposition only
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_spanbuf<_CharT, _Traits>& __x, basic_spanbuf<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::spanbuf;
#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
using std::wspanbuf;
#  endif

// Class template basic_ispanstream [ispanstream]

template <class _CharT, class _Traits>
class _LIBCPP_TEMPLATE_VIS basic_ispanstream : public basic_istream<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [ispanstream.cons], constructors

  _LIBCPP_HIDE_FROM_ABI explicit basic_ispanstream(std::span<_CharT> __s, ios_base::openmode __which = ios_base::in)
      : basic_istream<_CharT, _Traits>(std::addressof(__sb_)),
        __sb_(basic_spanbuf<_CharT, _Traits>(__s, __which | ios_base::in)) {}

  basic_ispanstream(const basic_ispanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ispanstream(basic_ispanstream&& __rhs)
      : basic_istream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_)) {
    basic_istream<_CharT, _Traits>::set_rdbuf(std::addressof(__sb_));
  }

  template <ranges::borrowed_range _ROSeq>
    requires(!convertible_to<_ROSeq, std::span<_CharT>>) && convertible_to<_ROSeq, std::span<const _CharT>>
  _LIBCPP_HIDE_FROM_ABI explicit basic_ispanstream(_ROSeq&& __s)
      : basic_istream<_CharT, _Traits>(std::addressof(__sb_)) {
    std::span<const _CharT> __sp(std::forward<_ROSeq>(__s));
    this->span(std::span<_CharT>(std::span<_CharT>(const_cast<_CharT*>(__sp.data()), __sp.size())));
  }

  basic_ispanstream& operator=(const basic_ispanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ispanstream& operator=(basic_ispanstream&& __rhs) {
    basic_ispanstream __tmp{std::move(__rhs)};
    this->swap(__tmp);
    return *this;
  }

  // [ispanstream.swap], swap

  _LIBCPP_HIDE_FROM_ABI void swap(basic_ispanstream& __rhs) {
    basic_istream<_CharT, _Traits>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
  }

  // [ispanstream.members], member functions

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf<_CharT, _Traits>* rdbuf() const noexcept {
    return const_cast<basic_spanbuf<_CharT, _Traits>*>(std::addressof(__sb_));
  }

  _LIBCPP_HIDE_FROM_ABI std::span<const _CharT> span() const noexcept { return rdbuf()->span(); }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept { rdbuf()->span(__s); }

  template <ranges::borrowed_range _ROSeq>
    requires(!convertible_to<_ROSeq, std::span<_CharT>>) && convertible_to<_ROSeq, std::span<const _CharT>>
  _LIBCPP_HIDE_FROM_ABI void span(_ROSeq&& __s) noexcept {
    std::span<const _CharT> __sp(std::forward<_ROSeq>(__s));
    this->span(std::span<_CharT>(const_cast<_CharT*>(__sp.data()), __sp.size()));
  }

private:
  basic_spanbuf<_CharT, _Traits> __sb_; // exposition only
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_ispanstream<_CharT, _Traits>& __x, basic_ispanstream<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::ispanstream;
#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
using std::wispanstream;
#  endif

// Class template basic_ospanstream [ospanstream]

template <class _CharT, class _Traits>
class _LIBCPP_TEMPLATE_VIS basic_ospanstream : public basic_ostream<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [ospanstream.cons], constructors

  _LIBCPP_HIDE_FROM_ABI explicit basic_ospanstream(std::span<_CharT> __s, ios_base::openmode __which = ios_base::out)
      : basic_ostream<_CharT, _Traits>(std::addressof(__sb_)),
        __sb_(basic_spanbuf<_CharT, _Traits>(__s, __which | ios_base::out)) {}

  basic_ospanstream(const basic_ospanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ospanstream(basic_ospanstream&& __rhs)
      : basic_ostream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_)) {
    basic_ostream<_CharT, _Traits>::set_rdbuf(std::addressof(__sb_));
  }

  basic_ospanstream& operator=(const basic_ospanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ospanstream& operator=(basic_ospanstream&& __rhs) {
    basic_ospanstream __tmp{std::move(__rhs)};
    this->swap(__tmp);
    return *this;
  }

  // [ospanstream.swap], swap

  _LIBCPP_HIDE_FROM_ABI void swap(basic_ospanstream& __rhs) {
    basic_ostream<_CharT, _Traits>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
  }

  // [ospanstream.members], member functions

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf<_CharT, _Traits>* rdbuf() const noexcept {
    return const_cast<basic_spanbuf<_CharT, _Traits>*>(std::addressof(__sb_));
  }

  _LIBCPP_HIDE_FROM_ABI std::span<_CharT> span() const noexcept { return rdbuf()->span(); }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept { rdbuf()->span(__s); }

private:
  basic_spanbuf<_CharT, _Traits> __sb_; // exposition only
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_ospanstream<_CharT, _Traits>& __x, basic_ospanstream<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::ospanstream;
#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
using std::wospanstream;
#  endif

template <class _CharT, class _Traits>
class _LIBCPP_TEMPLATE_VIS basic_spanstream : public basic_iostream<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [spanstream.cons], constructors

  _LIBCPP_HIDE_FROM_ABI explicit basic_spanstream(std::span<_CharT> __s,
                                                  ios_base::openmode __which = ios_base::out | ios_base::in)
      : basic_iostream<_CharT, _Traits>(std::addressof(__sb_)), __sb_(basic_spanbuf<_CharT, _Traits>(__s, __which)) {}

  basic_spanstream(const basic_spanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanstream(basic_spanstream&& __rhs)
      : basic_iostream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_)) {
    basic_iostream<_CharT, _Traits>::set_rdbuf(std::addressof(__sb_));
  }

  basic_spanstream& operator=(const basic_spanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanstream& operator=(basic_spanstream&& __rhs) {
    basic_spanstream __tmp{std::move(__rhs)};
    this->swap(__tmp);
    return *this;
  }

  // [spanstream.swap], swap

  void swap(basic_spanstream& __rhs) {
    basic_iostream<_CharT, _Traits>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
  }

  // [spanstream.members], members

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf<_CharT, _Traits>* rdbuf() const noexcept {
    return const_cast<basic_spanbuf<_CharT, _Traits>*>(std::addressof(__sb_));
  }

  _LIBCPP_HIDE_FROM_ABI std::span<_CharT> span() const noexcept { return rdbuf()->span(); }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept { rdbuf()->span(__s); }

private:
  basic_spanbuf<_CharT, _Traits> __sb_; // exposition only
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_spanstream<_CharT, _Traits>& __x, basic_spanstream<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::spanstream;
#  ifndef _LIBCPP_HAS_NO_WIDE_CHARACTERS
using std::wspanstream;
#  endif

#endif // _LIBCPP_STD_VER >= 23

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#if _LIBCPP_STD_VER <= 20 && !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES)
#  include <type_traits>
#endif

#endif // _LIBCPP_SPANSTREAM
