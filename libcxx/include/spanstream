// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_SPANSTREAM
#define _LIBCPP_SPANSTREAM

// clang-format off

/*
  Span-based streams [span.streams]

  template<class charT, class traits = char_traits<charT>>
    class basic_spanbuf;

  template<class charT, class traits>
    void swap(basic_spanbuf<charT, traits>& x, basic_spanbuf<charT, traits>& y);

  using spanbuf = basic_spanbuf<char>;
  using wspanbuf = basic_spanbuf<wchar_t>;

  template<class charT, class traits = char_traits<charT>>
    class basic_ispanstream;

  template<class charT, class traits>
    void swap(basic_ispanstream<charT, traits>& x, basic_ispanstream<charT, traits>& y);

  using ispanstream = basic_ispanstream<char>;
  using wispanstream = basic_ispanstream<wchar_t>;

  template<class charT, class traits = char_traits<charT>>
    class basic_ospanstream;

  template<class charT, class traits>
    void swap(basic_ospanstream<charT, traits>& x, basic_ospanstream<charT, traits>& y);

  using ospanstream = basic_ospanstream<char>;
  using wospanstream = basic_ospanstream<wchar_t>;

  template<class charT, class traits = char_traits<charT>>
    class basic_spanstream;

  template<class charT, class traits>
    void swap(basic_spanstream<charT, traits>& x, basic_spanstream<charT, traits>& y);

  using spanstream = basic_spanstream<char>;
  using wspanstream = basic_spanstream<wchar_t>;
*/

// clang-format on

#if __cplusplus < 201103L && defined(_LIBCPP_USE_FROZEN_CXX03_HEADERS)
#  include <__cxx03/__config>
#else

#  include <__config>

#  if _LIBCPP_HAS_LOCALIZATION

#    include <__concepts/convertible_to.h>
#    include <__fwd/spanstream.h>
#    include <__memory/addressof.h>
#    include <__ranges/concepts.h>
#    include <__utility/cmp.h>
#    include <__utility/exchange.h>
#    include <__utility/forward.h>
#    include <__utility/move.h>
#    include <__utility/swap.h>
#    include <ios>
#    include <istream>
#    include <ostream>
#    include <span>
#    include <streambuf>
#    include <version>

#    if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#      pragma GCC system_header
#    endif

_LIBCPP_PUSH_MACROS
#    include <__undef_macros>

#    if _LIBCPP_STD_VER >= 23

_LIBCPP_BEGIN_NAMESPACE_STD

// Class template basic_spanbuf [spanbuf]

template <class _CharT, class _Traits>
class basic_spanbuf : public basic_streambuf<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [spanbuf.cons], constructors

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf() : basic_spanbuf(ios_base::in | ios_base::out) {}

  _LIBCPP_HIDE_FROM_ABI explicit basic_spanbuf(ios_base::openmode __which)
      : basic_spanbuf(std::span<_CharT>(), __which) {}

  _LIBCPP_HIDE_FROM_ABI explicit basic_spanbuf(std::span<_CharT> __s,
                                               ios_base::openmode __which = ios_base::in | ios_base::out)
      : basic_streambuf<_CharT, _Traits>{}, __mode_(__which) {
    span(__s);
  }

  basic_spanbuf(const basic_spanbuf&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf(basic_spanbuf&& __rhs)
      : basic_streambuf<_CharT, _Traits>{std::move(__rhs)},
        __mode_{std::move(__rhs.__mode_)},
        __buf_{std::exchange(__rhs.__buf_, {})} {}

  // [spanbuf.assign], assignment and swap

  basic_spanbuf& operator=(const basic_spanbuf&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf& operator=(basic_spanbuf&& __rhs) {
    basic_spanbuf __tmp{std::move(__rhs)};
    swap(__tmp);
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI void swap(basic_spanbuf& __rhs) {
    basic_streambuf<_CharT, _Traits>::swap(__rhs);
    std::swap(__mode_, __rhs.__mode_);
    std::swap(__buf_, __rhs.__buf_);
  }

  // [spanbuf.members], member functions

  _LIBCPP_HIDE_FROM_ABI std::span<_CharT> span() const noexcept {
    if (__mode_ & ios_base::out) {
      return std::span<_CharT>{this->pbase(), this->pptr()};
    }
    return __buf_;
  }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept {
    __buf_ = __s;

    if (__mode_ & ios_base::out) {
      this->setp(__s.data(), __s.data() + __s.size());
      if (__mode_ & ios_base::ate) {
        this->pbump(__s.size());
      }
    }

    if (__mode_ & ios_base::in) {
      this->setg(__s.data(), __s.data(), __s.data() + __s.size());
    }
  }

protected:
  // [spanbuf.virtuals], overridden virtual functions

  _LIBCPP_HIDE_FROM_ABI basic_streambuf<_CharT, _Traits>* setbuf(_CharT* __s, streamsize __n) override {
    span(std::span<_CharT>(__s, __n));
    return this;
  }

  _LIBCPP_HIDE_FROM_ABI pos_type
  seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out) override {
    const auto __error = static_cast<pos_type>(off_type{-1});

    // Mode: `in` and `out`
    if ((__which & ios_base::in) && (__which & ios_base::out) && (ios_base::cur == __way))
      return __error;

    // Mode: none
    if (!((__which & ios_base::in) || (__which & ios_base::out)) && (ios_base::cur == __way))
      return __error;

    // Calculate `__baseoff`

    std::size_t __baseoff;

    switch (__way) {
    case ios_base::beg:
      __baseoff = 0Z;
      break;

    case ios_base::cur:
      if (__which & ios_base::out)
        __baseoff = this->pptr() - this->pbase();
      else
        __baseoff = this->gptr() - this->eback();
      break;

    case ios_base::end:
      if ((__mode_ & ios_base::out) && !(__mode_ & ios_base::in))
        __baseoff = this->pptr() - this->pbase();
      else
        __baseoff = __buf_.size();
      break;

    default:
      return __error;
    };

    // Calculate `__newoff`

    off_type __newoff;

    if (__builtin_add_overflow(__baseoff, __off, std::addressof(__newoff)) || (__newoff < off_type{0}) ||
        std::cmp_greater(__newoff, __buf_.size()))
      return __error;

    // Set pointers

    if (__which & ios_base::in) {
      if ((this->gptr() == nullptr) && (__newoff != off_type{0}))
        return __error;
      this->setg(this->eback(), this->eback() + __newoff, this->egptr());
    }

    if (__which & ios_base::out) {
      if ((this->pptr() == nullptr) && (__newoff != off_type{0}))
        return __error;
      this->setp(this->pbase(), this->epptr());
      this->pbump(__newoff);
    }

    return static_cast<pos_type>(__newoff);
  }

  _LIBCPP_HIDE_FROM_ABI pos_type seekpos(pos_type __sp,
                                         ios_base::openmode __which = ios_base::in | ios_base::out) override {
    return seekoff(static_cast<off_type>(__sp), ios_base::beg, __which);
  }

private:
  ios_base::openmode __mode_;
  std::span<_CharT> __buf_;
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_spanbuf<_CharT, _Traits>& __x, basic_spanbuf<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::spanbuf;
#      if _LIBCPP_HAS_WIDE_CHARACTERS
using std::wspanbuf;
#      endif

// Class template basic_ispanstream [ispanstream]

template <class _CharT, class _Traits>
class basic_ispanstream : public basic_istream<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [ispanstream.cons], constructors

  _LIBCPP_HIDE_FROM_ABI explicit basic_ispanstream(std::span<_CharT> __s, ios_base::openmode __which = ios_base::in)
      : basic_istream<_CharT, _Traits>(std::addressof(__sb_)),
        __sb_(basic_spanbuf<_CharT, _Traits>(__s, __which | ios_base::in)) {}

  basic_ispanstream(const basic_ispanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ispanstream(basic_ispanstream&& __rhs)
      : basic_istream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_)) {
    basic_istream<_CharT, _Traits>::set_rdbuf(std::addressof(__sb_));
  }

  template <ranges::borrowed_range _ROSeq>
    requires(!convertible_to<_ROSeq, std::span<_CharT>>) && convertible_to<_ROSeq, std::span<const _CharT>>
  _LIBCPP_HIDE_FROM_ABI explicit basic_ispanstream(_ROSeq&& __s)
      : basic_istream<_CharT, _Traits>(std::addressof(__sb_)), __sb_(basic_spanbuf<_CharT, _Traits>(ios_base::in)) {
    std::span<const _CharT> __sp(std::forward<_ROSeq>(__s));
    this->span(std::span<_CharT>(const_cast<_CharT*>(__sp.data()), __sp.size()));
  }

  basic_ispanstream& operator=(const basic_ispanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ispanstream& operator=(basic_ispanstream&& __rhs) {
    basic_ispanstream __tmp{std::move(__rhs)};
    this->swap(__tmp);
    return *this;
  }

  // [ispanstream.swap], swap

  _LIBCPP_HIDE_FROM_ABI void swap(basic_ispanstream& __rhs) {
    basic_istream<_CharT, _Traits>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
  }

  // [ispanstream.members], member functions

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf<_CharT, _Traits>* rdbuf() const noexcept {
    return const_cast<basic_spanbuf<_CharT, _Traits>*>(std::addressof(__sb_));
  }

  _LIBCPP_HIDE_FROM_ABI std::span<const _CharT> span() const noexcept { return rdbuf()->span(); }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept { rdbuf()->span(__s); }

  template <ranges::borrowed_range _ROSeq>
    requires(!convertible_to<_ROSeq, std::span<_CharT>>) && convertible_to<_ROSeq, std::span<const _CharT>>
  _LIBCPP_HIDE_FROM_ABI void span(_ROSeq&& __s) noexcept {
    std::span<const _CharT> __sp(std::forward<_ROSeq>(__s));
    this->span(std::span<_CharT>(const_cast<_CharT*>(__sp.data()), __sp.size()));
  }

private:
  basic_spanbuf<_CharT, _Traits> __sb_;
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_ispanstream<_CharT, _Traits>& __x, basic_ispanstream<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::ispanstream;
#      if _LIBCPP_HAS_WIDE_CHARACTERS
using std::wispanstream;
#      endif

// Class template basic_ospanstream [ospanstream]

template <class _CharT, class _Traits>
class basic_ospanstream : public basic_ostream<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [ospanstream.cons], constructors

  _LIBCPP_HIDE_FROM_ABI explicit basic_ospanstream(std::span<_CharT> __s, ios_base::openmode __which = ios_base::out)
      : basic_ostream<_CharT, _Traits>(std::addressof(__sb_)),
        __sb_(basic_spanbuf<_CharT, _Traits>(__s, __which | ios_base::out)) {}

  basic_ospanstream(const basic_ospanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ospanstream(basic_ospanstream&& __rhs)
      : basic_ostream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_)) {
    basic_ostream<_CharT, _Traits>::set_rdbuf(std::addressof(__sb_));
  }

  basic_ospanstream& operator=(const basic_ospanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_ospanstream& operator=(basic_ospanstream&& __rhs) {
    basic_ospanstream __tmp{std::move(__rhs)};
    this->swap(__tmp);
    return *this;
  }

  // [ospanstream.swap], swap

  _LIBCPP_HIDE_FROM_ABI void swap(basic_ospanstream& __rhs) {
    basic_ostream<_CharT, _Traits>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
  }

  // [ospanstream.members], member functions

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf<_CharT, _Traits>* rdbuf() const noexcept {
    return const_cast<basic_spanbuf<_CharT, _Traits>*>(std::addressof(__sb_));
  }

  _LIBCPP_HIDE_FROM_ABI std::span<_CharT> span() const noexcept { return rdbuf()->span(); }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept { rdbuf()->span(__s); }

private:
  basic_spanbuf<_CharT, _Traits> __sb_;
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_ospanstream<_CharT, _Traits>& __x, basic_ospanstream<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::ospanstream;
#      if _LIBCPP_HAS_WIDE_CHARACTERS
using std::wospanstream;
#      endif

template <class _CharT, class _Traits>
class basic_spanstream : public basic_iostream<_CharT, _Traits> {
public:
  using char_type   = _CharT;
  using int_type    = typename _Traits::int_type;
  using pos_type    = typename _Traits::pos_type;
  using off_type    = typename _Traits::off_type;
  using traits_type = _Traits;

  // [spanstream.cons], constructors

  _LIBCPP_HIDE_FROM_ABI explicit basic_spanstream(std::span<_CharT> __s,
                                                  ios_base::openmode __which = ios_base::out | ios_base::in)
      : basic_iostream<_CharT, _Traits>(std::addressof(__sb_)), __sb_(basic_spanbuf<_CharT, _Traits>(__s, __which)) {}

  basic_spanstream(const basic_spanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanstream(basic_spanstream&& __rhs)
      : basic_iostream<_CharT, _Traits>(std::move(__rhs)), __sb_(std::move(__rhs.__sb_)) {
    basic_iostream<_CharT, _Traits>::set_rdbuf(std::addressof(__sb_));
  }

  basic_spanstream& operator=(const basic_spanstream&) = delete;

  _LIBCPP_HIDE_FROM_ABI basic_spanstream& operator=(basic_spanstream&& __rhs) {
    basic_spanstream __tmp{std::move(__rhs)};
    this->swap(__tmp);
    return *this;
  }

  // [spanstream.swap], swap

  _LIBCPP_HIDE_FROM_ABI void swap(basic_spanstream& __rhs) {
    basic_iostream<_CharT, _Traits>::swap(__rhs);
    __sb_.swap(__rhs.__sb_);
  }

  // [spanstream.members], members

  _LIBCPP_HIDE_FROM_ABI basic_spanbuf<_CharT, _Traits>* rdbuf() const noexcept {
    return const_cast<basic_spanbuf<_CharT, _Traits>*>(std::addressof(__sb_));
  }

  _LIBCPP_HIDE_FROM_ABI std::span<_CharT> span() const noexcept { return rdbuf()->span(); }

  _LIBCPP_HIDE_FROM_ABI void span(std::span<_CharT> __s) noexcept { rdbuf()->span(__s); }

private:
  basic_spanbuf<_CharT, _Traits> __sb_;
};

template <class _CharT, class _Traits>
_LIBCPP_HIDE_FROM_ABI void swap(basic_spanstream<_CharT, _Traits>& __x, basic_spanstream<_CharT, _Traits>& __y) {
  __x.swap(__y);
}

using std::spanstream;
#      if _LIBCPP_HAS_WIDE_CHARACTERS
using std::wspanstream;
#      endif

_LIBCPP_END_NAMESPACE_STD

#    endif // _LIBCPP_STD_VER >= 23

_LIBCPP_POP_MACROS

#  endif // _LIBCPP_HAS_LOCALIZATION

#  if _LIBCPP_STD_VER <= 20 && !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES)
#    include <type_traits>
#  endif

#endif // __cplusplus < 201103L && defined(_LIBCPP_USE_FROZEN_CXX03_HEADERS)

#endif // _LIBCPP_SPANSTREAM
