// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXECUTION
#define _LIBCPP_EXECUTION

/*
namespace std::execution {
  struct sequenced_policy;
  struct parallel_policy;
  struct parallel_unsequenced_policy;
  struct unsequenced_policy; // since C++20

  inline constexpr sequenced_policy seq = implementation-defined;
  inline constexpr parallel_policy par = implementation-defined;
  inline constexpr parallel_unsequenced_policy par_unseq = implementation-defined;
  inline constexpr unsequenced_policy unseq = implementation-defined; // since C++20
}

namespace std {
  template <class T>
  struct is_execution_policy;

  template <class T>
  inline constexpr bool is_execution_policy_v;
}
*/

#include <__assert> // all public C++ headers provide the assertion handler
#include <__config>
#include <__type_traits/integral_constant.h>
#include <version>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

#if defined(_LIBCPP_HAS_PARALLEL_ALGORITHMS) && _LIBCPP_STD_VER >= 17

_LIBCPP_BEGIN_NAMESPACE_STD

namespace execution {
struct __disable_user_instantiations_tag {
  explicit __disable_user_instantiations_tag() = default;
};

struct sequenced_policy {
  constexpr explicit sequenced_policy(__disable_user_instantiations_tag) {}
  sequenced_policy(const sequenced_policy&)            = delete;
  sequenced_policy& operator=(const sequenced_policy&) = delete;
};

inline constexpr sequenced_policy seq{__disable_user_instantiations_tag{}};

struct parallel_policy {
  constexpr explicit parallel_policy(__disable_user_instantiations_tag) {}
  parallel_policy(const parallel_policy&)            = delete;
  parallel_policy& operator=(const parallel_policy&) = delete;
};

inline constexpr parallel_policy par{__disable_user_instantiations_tag{}};

struct parallel_unsequenced_policy {
  constexpr explicit parallel_unsequenced_policy(__disable_user_instantiations_tag) {}
  parallel_unsequenced_policy(const parallel_unsequenced_policy&)            = delete;
  parallel_unsequenced_policy& operator=(const parallel_unsequenced_policy&) = delete;
};

inline constexpr parallel_unsequenced_policy par_unseq{__disable_user_instantiations_tag{}};

#  if _LIBCPP_STD_VER >= 20

struct unsequenced_policy {
  constexpr explicit unsequenced_policy(__disable_user_instantiations_tag) {}
  unsequenced_policy(const unsequenced_policy&)            = delete;
  unsequenced_policy& operator=(const unsequenced_policy&) = delete;
};

inline constexpr unsequenced_policy unseq{__disable_user_instantiations_tag{}};

#  endif // _LIBCPP_STD_VER >= 20

} // namespace execution

template <class>
inline constexpr bool is_execution_policy_v = false;

template <>
inline constexpr bool is_execution_policy_v<execution::sequenced_policy> = true;

template <>
inline constexpr bool is_execution_policy_v<execution::parallel_policy> = true;

template <>
inline constexpr bool is_execution_policy_v<execution::parallel_unsequenced_policy> = true;

#  if _LIBCPP_STD_VER >= 20
template <>
inline constexpr bool is_execution_policy_v<execution::unsequenced_policy> = true;
#  endif

template <class _Tp>
struct is_execution_policy : bool_constant<is_execution_policy_v<_Tp>> {};

_LIBCPP_END_NAMESPACE_STD

#endif // defined(_LIBCPP_HAS_PARALLEL_ALGORITHMS) && _LIBCPP_STD_VER >= 17

#endif // _LIBCPP_EXECUTION
