// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_INPLACE_VECTOR
#define _LIBCPP_INPLACE_VECTOR

/*
   inplace_vector synopsis

// mostly freestanding
#include <compare>              // see [compare.syn]
#include <initializer_list>     // see [initializer.list.syn]

namespace std {
  // [inplace.vector], class template inplace_vector
  template<class T, size_t N>
  class inplace_vector {        // partially freestanding
  public:
    // types:
    using value_type             = T;
    using pointer                = T*;
    using const_pointer          = const T*;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using iterator               = implementation-defined; // see [container.requirements]
    using const_iterator         = implementation-defined; // see [container.requirements]
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // [inplace.vector.cons], construct/copy/destroy
    constexpr inplace_vector() noexcept;
    constexpr explicit inplace_vector(size_type n);                         // freestanding-deleted
    constexpr inplace_vector(size_type n, const T& value);                  // freestanding-deleted
    template<class InputIterator>
      constexpr inplace_vector(InputIterator first, InputIterator last);    // freestanding-deleted
    template<container-compatible-range<T> R>
      constexpr inplace_vector(from_range_t, R&& rg);                       // freestanding-deleted
    constexpr inplace_vector(const inplace_vector&);
    constexpr inplace_vector(inplace_vector&&)
      noexcept(N == 0 || is_nothrow_move_constructible_v<T>);
    constexpr inplace_vector(initializer_list<T> il);                       // freestanding-deleted
    constexpr ~inplace_vector();
    constexpr inplace_vector& operator=(const inplace_vector& other);
    constexpr inplace_vector& operator=(inplace_vector&& other)
      noexcept(N == 0 || (is_nothrow_move_assignable_v<T> &&
                          is_nothrow_move_constructible_v<T>));
    constexpr inplace_vector& operator=(initializer_list<T>);               // freestanding-deleted
    template<class InputIterator>
      constexpr void assign(InputIterator first, InputIterator last);       // freestanding-deleted
    template<container-compatible-range<T> R>
      constexpr void assign_range(R&& rg);                                  // freestanding-deleted
    constexpr void assign(size_type n, const T& u);                         // freestanding-deleted
    constexpr void assign(initializer_list<T> il);                          // freestanding-deleted

    // iterators
    constexpr iterator               begin()         noexcept;
    constexpr const_iterator         begin()   const noexcept;
    constexpr iterator               end()           noexcept;
    constexpr const_iterator         end()     const noexcept;
    constexpr reverse_iterator       rbegin()        noexcept;
    constexpr const_reverse_iterator rbegin()  const noexcept;
    constexpr reverse_iterator       rend()          noexcept;
    constexpr const_reverse_iterator rend()    const noexcept;

    constexpr const_iterator         cbegin()  const noexcept;
    constexpr const_iterator         cend()    const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend()   const noexcept;

    // [inplace.vector.capacity] size/capacity
    constexpr bool empty() const noexcept;
    constexpr size_type size() const noexcept;
    static constexpr size_type max_size() noexcept;
    static constexpr size_type capacity() noexcept;
    constexpr void resize(size_type sz);                                    // freestanding-deleted
    constexpr void resize(size_type sz, const T& c);                        // freestanding-deleted
    static constexpr void reserve(size_type n);                             // freestanding-deleted
    static constexpr void shrink_to_fit() noexcept;

    // element access
    constexpr reference       operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    constexpr reference       at(size_type n);                              // freestanding-deleted
    constexpr const_reference at(size_type n) const;                        // freestanding-deleted
    constexpr reference       front();
    constexpr const_reference front() const;
    constexpr reference       back();
    constexpr const_reference back() const;

    // [inplace.vector.data], data access
    constexpr       T* data()       noexcept;
    constexpr const T* data() const noexcept;

    // [inplace.vector.modifiers], modifiers
    template<class... Args>
      constexpr reference emplace_back(Args&&... args);                     // freestanding-deleted
    constexpr reference push_back(const T& x);                              // freestanding-deleted
    constexpr reference push_back(T&& x);                                   // freestanding-deleted
    template<container-compatible-range<T> R>
      constexpr void append_range(R&& rg);                                  // freestanding-deleted
    constexpr void pop_back();

    template<class... Args>
      constexpr pointer try_emplace_back(Args&&... args);
    constexpr pointer try_push_back(const T& x);
    constexpr pointer try_push_back(T&& x);
    template<container-compatible-range<T> R>
      constexpr ranges::borrowed_iterator_t<R> try_append_range(R&& rg);

    template<class... Args>
      constexpr reference unchecked_emplace_back(Args&&... args);
    constexpr reference unchecked_push_back(const T& x);
    constexpr reference unchecked_push_back(T&& x);

    template<class... Args>
      constexpr iterator emplace(const_iterator position, Args&&... args);  // freestanding-deleted
    constexpr iterator insert(const_iterator position, const T& x);         // freestanding-deleted
    constexpr iterator insert(const_iterator position, T&& x);              // freestanding-deleted
    constexpr iterator insert(const_iterator position, size_type n,         // freestanding-deleted
                              const T& x);
    template<class InputIterator>
      constexpr iterator insert(const_iterator position,                    // freestanding-deleted
                                InputIterator first, InputIterator last);
    template<container-compatible-range<T> R>
      constexpr iterator insert_range(const_iterator position, R&& rg);     // freestanding-deleted
    constexpr iterator insert(const_iterator position,                      // freestanding-deleted
                              initializer_list<T> il);
    constexpr iterator erase(const_iterator position);
    constexpr iterator erase(const_iterator first, const_iterator last);
    constexpr void swap(inplace_vector& x)
      noexcept(N == 0 || (is_nothrow_swappable_v<T> &&
                          is_nothrow_move_constructible_v<T>));
    constexpr void clear() noexcept;

    constexpr friend bool operator==(const inplace_vector& x,
                                     const inplace_vector& y);
    constexpr friend synth-three-way-result<T>
      operator<=>(const inplace_vector& x, const inplace_vector& y);
    constexpr friend void swap(inplace_vector& x, inplace_vector& y)
      noexcept(N == 0 || (is_nothrow_swappable_v<T> &&
                          is_nothrow_move_constructible_v<T>))
      { x.swap(y); }
  };

  // [inplace.vector.erasure], erasure
  template<class T, size_t N, class U = T>
    constexpr typename inplace_vector<T, N>::size_type
      erase(inplace_vector<T, N>& c, const U& value);
  template<class T, size_t N, class Predicate>
    constexpr typename inplace_vector<T, N>::size_type
      erase_if(inplace_vector<T, N>& c, Predicate pred);
} // namespace std
*/

#include <__algorithm/copy.h>
#include <__algorithm/equal.h>
#include <__algorithm/lexicographical_compare_three_way.h>
#include <__algorithm/min.h>
#include <__algorithm/move.h>
#include <__algorithm/move_backward.h>
#include <__algorithm/remove.h>
#include <__algorithm/remove_if.h>
#include <__algorithm/rotate.h>
#include <__algorithm/swap_ranges.h>
#include <__compare/synth_three_way.h>
#include <__config>
#include <__cstddef/size_t.h>
#include <__iterator/distance.h>
#include <__iterator/iterator_traits.h>
#include <__iterator/move_iterator.h>
#include <__iterator/reverse_iterator.h>
#include <__iterator/size.h>
#include <__iterator/wrap_iter.h>
#include <__memory/addressof.h>
#include <__memory/construct_at.h>
#include <__memory/pointer_traits.h>
#include <__memory/voidify.h>
#include <__ranges/access.h>
#include <__ranges/concepts.h>
#include <__ranges/container_compatible_range.h>
#include <__ranges/dangling.h>
#include <__ranges/from_range.h>
#include <__type_traits/conditional.h>
#include <__type_traits/is_nothrow_assignable.h>
#include <__type_traits/is_nothrow_constructible.h>
#include <__type_traits/is_swappable.h>
#include <__type_traits/is_trivially_assignable.h>
#include <__type_traits/is_trivially_constructible.h>
#include <__type_traits/is_trivially_destructible.h>
#include <__type_traits/is_trivially_relocatable.h>
#include <__utility/cmp.h>
#include <__utility/forward.h>
#include <__utility/unreachable.h>
#include <new>
#include <stdexcept>

// standard-mandated includes

// [inplace.vector.syn]
#include <compare>
#include <initializer_list>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

#if _LIBCPP_STD_VER >= 26

template <class _Tp, size_t _Capacity>
class _LIBCPP_TEMPLATE_VIS inplace_vector;

template <size_t _MaximumPadding, size_t _Capacity>
_LIBCPP_HIDE_FROM_ABI auto __inplace_vector_size_type() {
  if constexpr (_MaximumPadding >= sizeof(size_t)) {
    // Unconditionally use size_t in this case. Using a smaller size
    // will not change the size of the inplace_vector because it will
    // only introduce more padding bits
    return static_cast<size_t>(0);
  } else if constexpr (_Capacity <= static_cast<unsigned char>(-1) && (sizeof(unsigned char) < sizeof(size_t))) {
    return static_cast<unsigned char>(0);
  } else if constexpr (_Capacity <= static_cast<unsigned short>(-1) && (sizeof(unsigned short) < sizeof(size_t))) {
    return static_cast<unsigned short>(0);
  } else if constexpr (_Capacity <= static_cast<unsigned int>(-1) && (sizeof(unsigned int) < sizeof(size_t))) {
    return static_cast<unsigned int>(0);
  } else if constexpr (_Capacity <= static_cast<unsigned long>(-1) && (sizeof(unsigned long) < sizeof(size_t))) {
    return static_cast<unsigned long>(0);
  } else {
    return static_cast<size_t>(0);
  }
}

[[__noreturn__]] _LIBCPP_HIDE_FROM_ABI inline void __inplace_vector_throw_out_of_range() {
  __throw_out_of_range("inplace_vector");
  unreachable();
}

template <class _Tp, size_t _Capacity>
class _LIBCPP_TEMPLATE_VIS __inplace_vector_array {
  friend inplace_vector<_Tp, _Capacity>;
  using __small_size_type = decltype(__inplace_vector_size_type<alignof(_Tp), _Capacity>());

  union {
    _Tp __elems_[_Capacity];
  };
  __small_size_type __sz_;

  // When __constexpr is true, do not actually destroy any elements
  // so that this can be used as a constexpr variable (otherwise it
  // would be rejected for being uninitialized)
  static constexpr bool __constexpr = is_trivially_default_constructible_v<_Tp> && is_trivially_destructible_v<_Tp>;
  static constexpr bool __trivial_copy_construct = is_trivially_copy_constructible_v<_Tp>;
  static constexpr bool __trivial_move_construct = is_trivially_move_constructible_v<_Tp>;
  static constexpr bool __trivial_copy_assign =
      is_trivially_destructible_v<_Tp> && is_trivially_copy_constructible_v<_Tp> && is_trivially_copy_assignable_v<_Tp>;
  static constexpr bool __trivial_move_assign =
      is_trivially_destructible_v<_Tp> && is_trivially_move_constructible_v<_Tp> && is_trivially_move_assignable_v<_Tp>;

  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array() noexcept : __sz_(0) {
    if consteval {
      extern _LIBCPP_HIDE_FROM_ABI void
      __this_inplace_vector_cannot_be_used_in_a_constant_expression_because_the_type_is_not_trivial();
      __this_inplace_vector_cannot_be_used_in_a_constant_expression_because_the_type_is_not_trivial();
    }

    // Start the lifetime of the array without starting the lifetime
    // of any of its elements
    // TODO: When start_lifetime_as is implemented on all compilers, remove
    // this conditional
#  ifdef __cpp_lib_start_lifetime_as
    std::start_lifetime_as<_Tp[_Capacity]>(__elems_);
#  else
    ::new (std::__voidify(__elems_)) unsigned char[sizeof(_Tp[_Capacity])];
#  endif
  }
  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array() noexcept
    requires(__constexpr)
      : __elems_(), __sz_(0) {
    if !consteval {
      std::destroy(__elems_, __elems_ + _Capacity);
    }
  }
  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array(const __inplace_vector_array&) noexcept
      /* strengthened */
    requires(__trivial_copy_construct)
  = default;
  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array(__inplace_vector_array&&) noexcept
      /* strengthened */
    requires(__trivial_move_construct)
  = default;

  constexpr _LIBCPP_HIDE_FROM_ABI ~__inplace_vector_array() {
    __small_size_type __size = __sz_;
    __sz_                    = 0;
    std::destroy(__elems_, __elems_ + __size);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI ~__inplace_vector_array()
    requires(is_trivially_destructible_v<_Tp>)
  = default;

  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array& operator=(const __inplace_vector_array&) noexcept
    requires(__trivial_copy_assign)
  = default;
  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array& operator=(__inplace_vector_array&&) noexcept
    requires(__trivial_move_assign)
  = default;

  using __trivially_relocatable =
      __conditional_t<__libcpp_is_trivially_relocatable<_Tp>::value, inplace_vector<_Tp, _Capacity>, void>;
};

template <class _Tp>
class _LIBCPP_TEMPLATE_VIS __inplace_vector_array<_Tp, 0> {
private:
  friend inplace_vector<_Tp, 0>;
  using __small_size_type = size_t;

  static constexpr bool __constexpr              = true;
  static constexpr bool __trivial_copy_construct = true;
  static constexpr bool __trivial_move_construct = true;
  static constexpr bool __trivial_copy_assign    = true;
  static constexpr bool __trivial_move_assign    = true;

  static_assert((static_cast<_Tp (*)[1]>(nullptr) == nullptr), "inplace_vector<T, 0> must still have a valid T");
  static constexpr _Tp* __elems_           = nullptr;
  static constexpr __small_size_type __sz_ = 0;

  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array() noexcept = default;
  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array(const __inplace_vector_array&) noexcept /* strengthened */ =
      default;
  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array(__inplace_vector_array&&) noexcept = default;
  constexpr _LIBCPP_HIDE_FROM_ABI ~__inplace_vector_array()                                 = default;

  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array& operator=(const __inplace_vector_array&) noexcept = default;
  constexpr _LIBCPP_HIDE_FROM_ABI __inplace_vector_array& operator=(__inplace_vector_array&&) noexcept      = default;

  using __trivially_relocatable = inplace_vector<_Tp, 0>;
};

template <class _Tp, size_t _Capacity>
class _LIBCPP_TEMPLATE_VIS inplace_vector : private __inplace_vector_array<_Tp, _Capacity> {
  using __base = __inplace_vector_array<_Tp, _Capacity>;
  using __base::__elems_, __base::__sz_;
  using __small_size_type = __base::__small_size_type;

  static constexpr _LIBCPP_HIDE_FROM_ABI bool __do_destroy() noexcept {
    if consteval {
      // Do not destroy elements of the array in a constant expression
      return !__base::__constexpr;
    }
    return true;
  }

public:
  // types
  using value_type      = _Tp;
  using pointer         = _Tp*;
  using const_pointer   = const _Tp*;
  using reference       = value_type&;
  using const_reference = const value_type&;
  using size_type       = size_t;
  using difference_type = ptrdiff_t;
#  ifdef _LIBCPP_ABI_BOUNDED_ITERATORS
  using iterator       = __bounded_iter<__wrap_iter<pointer>>;
  using const_iterator = __bounded_iter<__wrap_iter<const_pointer>>;
#  else
  using iterator       = __wrap_iter<pointer>;
  using const_iterator = __wrap_iter<const_pointer>;
#  endif
  using reverse_iterator       = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  using __trivially_relocatable = __base::__trivially_relocatable;

  // [inplace.vector.cons], construct/copy/destroy
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector() noexcept = default;
  constexpr _LIBCPP_HIDE_FROM_ABI explicit inplace_vector(size_type __n) : inplace_vector() {
    if (__n > capacity())
      __throw_bad_alloc();
    // TODO: investigate optimization for trivially constructible _Tp that,
    // for small _Capacity, unconditionally value_construct all the elements to turn
    // "memset(data(), 0, sizeof(_Tp) * __n)" into
    // "memset(data(), 0, sizeof(_Tp[_Capacity]))" which might optimize better
    for (size_type __i = 0; __i < __n; ++__i) {
      unchecked_emplace_back();
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__i + 1zu == __sz_, "inplace_vector modified before its lifetime began");
    }
  }
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector(size_type __n, const _Tp& __value) : inplace_vector() {
    if (__n > capacity())
      __throw_bad_alloc();
    for (size_type __i = 0; __i < __n; ++__i) {
      unchecked_emplace_back(__value);
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__i + 1zu == __sz_, "inplace_vector modified before its lifetime began");
    }
  }

  // NOTE: [sequence.reqmts]p(67.1) does not apply to this constructor but apply
  // it anyways so the (size_type, const T&) constructor can never be ambiguous
  template <class _InputIterator>
    requires(__has_input_iterator_category<_InputIterator>::value)
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector(_InputIterator __first, _InputIterator __last) : inplace_vector() {
    if constexpr (__has_forward_iterator_category<_InputIterator>::value) {
      __append_with_size(__first, __last, std::distance(__first, __last));
      return;
    }
    __append_with_sentinel(__first, __last);
  }
  template <_ContainerCompatibleRange<_Tp> _Range>
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector(from_range_t, _Range&& __rg) : inplace_vector() {
    append_range<true>(__rg);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI
  inplace_vector(const inplace_vector& __other) noexcept(is_nothrow_copy_constructible_v<_Tp>) /* strengthened */
      : inplace_vector() {
    _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(this != std::addressof(__other), "inplace_vector self-assign");
    __small_size_type __expected_size = __other.__sz_;
    for (__small_size_type __i = 0; __i < __expected_size; ++__i) {
      unchecked_push_back(__other.data()[__i]);
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__i + 1zu == __sz_, "inplace_vector modified before it's lifetime began");
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
          __other.__sz_ == __expected_size, "inplace_vector modified while it's being copied from");
    }
  }
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector(const inplace_vector&) noexcept
      /* strengthened */
    requires(__base::__trivial_copy_construct)
  = default;
  constexpr _LIBCPP_HIDE_FROM_ABI
  inplace_vector(inplace_vector&& __other) noexcept(is_nothrow_move_constructible_v<_Tp>) /* strengthened */
      : inplace_vector() {
    _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(this != std::addressof(__other), "inplace_vector self-assign");
    __small_size_type __expected_size = __other.__sz_;
    for (__small_size_type __i = 0; __i < __expected_size; ++__i) {
      unchecked_push_back(std::move(__other.data()[__i]));
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__i + 1zu == __sz_, "inplace_vector modified before it's lifetime began");
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
          __other.__sz_ == __expected_size, "inplace_vector modified while it's being copied from");
    }
  }
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector(inplace_vector&&) noexcept
      /* strengthened */
    requires(__base::__trivial_move_construct)
  = default;
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector(initializer_list<_Tp> __il)
      : inplace_vector(__il.begin(), __il.end()) {}

  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector& operator=(const inplace_vector& __other) noexcept(
      is_nothrow_copy_assignable_v<_Tp> && is_nothrow_copy_constructible_v<_Tp>) /* strengthened */ {
    static_assert(_Capacity != 0, "Should have picked the trivial operator");
    if (this != std::addressof(__other)) [[likely]] {
      __small_size_type __assign = std::min(size(), __other.size());
      std::copy(__other.data(), __other.data() + __assign, data());
      if (__other.size() > size()) {
        __append_with_size(__other.data() + __assign, __other.data() + __other.size(), __other.size() - __assign);
      } else {
        __resize_down(__other.size());
      }
    }
    return *this;
  }
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector& operator=(const inplace_vector&) noexcept
      /* strengthened */
    requires(__base::__trivial_copy_assign)
  = default;
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector& operator=(inplace_vector&& __other) noexcept(
      is_nothrow_move_assignable_v<_Tp> && is_nothrow_move_constructible_v<_Tp>) {
    static_assert(_Capacity != 0, "Should have picked the trivial operator");
    if (this != std::addressof(__other)) [[likely]] {
      __small_size_type __assign = std::min(size(), __other.size());
      std::move(__other.data(), __other.data() + __assign, data());
      if (__other.size() > size()) {
        __append_with_size(std::make_move_iterator(__other.data() + __assign),
                           std::make_move_iterator(__other.data() + __other.size()),
                           __other.size() - __assign);
      } else {
        __resize_down(__other.size());
      }
    }
    return *this;
  }
  constexpr _LIBCPP_HIDE_FROM_ABI inplace_vector& operator=(inplace_vector&&) noexcept
      /* strengthened */
    requires(__base::__trivial_move_assign)
  = default;

  constexpr _LIBCPP_HIDE_FROM_ABI ~inplace_vector() = default;

private:
  constexpr _LIBCPP_HIDE_FROM_ABI iterator __make_iter(pointer __p) const noexcept {
#  ifdef _LIBCPP_ABI_BOUNDED_ITERATORS
    return std::__make_bounded_iter(__p, __wrap_iter<pointer>(__elems_ + 0), __wrap_iter<pointer>(__elems_ + __sz_));
#  else
    return iterator(__p);
#  endif
  }

  constexpr _LIBCPP_HIDE_FROM_ABI const_iterator __make_iter(const_pointer __p) const noexcept {
    return __make_iter(const_cast<pointer>(__p));
  }

  template <class _First, class _Sent>
  constexpr _LIBCPP_HIDE_FROM_ABI void __assign_with_size(_First&& __first, _Sent&& __sent, size_t __n) {
    if (__n > capacity()) [[unlikely]]
      __throw_bad_alloc();
    if constexpr (is_trivially_copyable_v<_Tp>) {
      clear();
      __append_with_size(std::forward<_First>(__first), std::forward<_Sent>(__sent), __n);
      return;
    }
    const size_t __initial_size   = size();
    const size_t __assigned_elems = std::min(__initial_size, __n);
    const size_t __remaining      = __n - __assigned_elems;
    for (size_t __i = 0; __i < __assigned_elems; ++__i) {
      data()[__i] = *__first;
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__first != __sent, "Iterators modified during assignment or size was wrong");
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
          size() == __initial_size, "Iterator or assignment modified container size during assign");
      ++__first;
    }
    __append_with_size(std::forward<_First>(__first), std::forward<_Sent>(__sent), __remaining);
  }

  template <class _First, class _Sent>
  constexpr _LIBCPP_HIDE_FROM_ABI void __assign_with_sentinel(_First&& __first, _Sent&& __sent) {
    if constexpr (is_trivially_destructible_v<_Tp>) {
      clear();
      __append_with_sentinel(std::forward<_First>(__first), std::forward<_Sent>(__sent));
      return;
    }
    size_t __existing = __sz_;
    for (size_t __i = 0; __i < __existing; ++__i) {
      if (__first == __sent)
        return;
      data()[__i] = *__first;
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__first != __sent, "Iterators modified during assignment");
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
          __existing + __i == __sz_, "Iterator or assignment modified container size during assign");
      ++__first;
    }
    __append_with_sentinel(std::forward<_First>(__first), std::forward<_Sent>(__sent));
  }

public:
  template <class _InputIterator>
    requires(__has_input_iterator_category<_InputIterator>::value)
  constexpr _LIBCPP_HIDE_FROM_ABI void assign(_InputIterator __first, _InputIterator __last) {
    if constexpr (__has_forward_iterator_category<_InputIterator>::value) {
      __assign_with_size(__first, __last, std::distance(__first, __last));
      return;
    }
    __assign_with_sentinel(__first, __last);
  }
  template <_ContainerCompatibleRange<_Tp> _Range>
  constexpr _LIBCPP_HIDE_FROM_ABI void assign_range(_Range&& __rg) {
    if constexpr (ranges::sized_range<_Range&>) {
      return __assign_with_size(ranges::begin(__rg), ranges::end(__rg), ranges::size(__rg));
    } else if constexpr (ranges::forward_range<_Range&>) {
      decltype(auto) __first(ranges::begin(__rg));
      decltype(auto) __last(ranges::end(__rg));
      return __assign_with_size(__first, __last, ranges::distance(__first, __last));
    }
    return __assign_with_sentinel(ranges::begin(__rg), ranges::end(__rg));
  }
  constexpr _LIBCPP_HIDE_FROM_ABI void assign(size_type __n, const _Tp& __u) {
    if (__n > capacity()) [[unlikely]]
      __throw_bad_alloc();
    if constexpr (is_trivially_copyable_v<_Tp>) {
      clear();
    } else {
      const size_t __initial_size   = size();
      const size_t __assigned_elems = std::min(__initial_size, __n);
      for (size_t __i = 0; __i < __assigned_elems; ++__i) {
        data()[__i] = __u;
        _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
            __sz_ == __initial_size, "inplace_vector element assignment modified container size during assign");
      }
    }
    resize(__n, __u);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI void assign(initializer_list<_Tp> __il) { assign(__il.begin(), __il.end()); }

  // iterators
  constexpr _LIBCPP_HIDE_FROM_ABI iterator begin() noexcept { return __make_iter(data()); }
  constexpr _LIBCPP_HIDE_FROM_ABI const_iterator begin() const noexcept { return __make_iter(data()); }
  constexpr _LIBCPP_HIDE_FROM_ABI iterator end() noexcept { return __make_iter(data() + size()); }
  constexpr _LIBCPP_HIDE_FROM_ABI const_iterator end() const noexcept { return __make_iter(data() + size()); }
  constexpr _LIBCPP_HIDE_FROM_ABI reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  constexpr _LIBCPP_HIDE_FROM_ABI reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  constexpr _LIBCPP_HIDE_FROM_ABI const_iterator cbegin() const noexcept { return begin(); }
  constexpr _LIBCPP_HIDE_FROM_ABI const_iterator cend() const noexcept { return end(); }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reverse_iterator crend() const noexcept { return rend(); }

  // [inplace.vector.capacity] size/capacity
  [[nodiscard]] constexpr _LIBCPP_HIDE_FROM_ABI bool empty() const noexcept { return __sz_ == 0; }
  [[nodiscard]] constexpr _LIBCPP_HIDE_FROM_ABI size_type size() const noexcept {
    _LIBCPP_ASSERT_UNCATEGORIZED(__sz_ <= capacity(), "inplace_vector has impossible size");
    // Let the optimizer know about this inequality
    if (__sz_ > capacity())
      unreachable();
    return __sz_;
  }
  [[nodiscard]] static _LIBCPP_HIDE_FROM_ABI constexpr size_type max_size() noexcept { return _Capacity; }
  [[nodiscard]] static _LIBCPP_HIDE_FROM_ABI constexpr size_type capacity() noexcept { return _Capacity; }

private:
  constexpr _LIBCPP_HIDE_FROM_ABI void __resize_down(__small_size_type __n) noexcept {
    _LIBCPP_ASSERT_INTERNAL(__n <= size(), "Trying to __resize_down to a greater number of elements");
    const const_pointer __old_last = __elems_ + __sz_;
    const const_pointer __new_last = __elems_ + __n;
    if constexpr (_Capacity) {
      __sz_ = __n;
    }
    if (__do_destroy())
      std::destroy(__new_last, __old_last);
    _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__sz_ == __n, "inplace_vector modified during element destruction");
  }

  template <class... _Arg>
  constexpr _LIBCPP_HIDE_FROM_ABI void __resize(size_type __n, const _Arg&... __arg) {
    if (__n > capacity())
      __throw_bad_alloc();

    if (__n <= __sz_) {
      __resize_down(__n);
      return;
    }

    size_type __remaining = __n - __sz_;
    for (size_type __i = 0; __i < __remaining; ++__i) {
      unchecked_emplace_back(__arg...);
    }
  }

public:
  constexpr _LIBCPP_HIDE_FROM_ABI void resize(size_type __sz) { __resize(__sz); }
  constexpr _LIBCPP_HIDE_FROM_ABI void resize(size_type __sz, const _Tp& __u) { __resize(__sz, __u); }

  static constexpr _LIBCPP_HIDE_FROM_ABI void reserve(size_type __n) {
    if (__n > capacity())
      __throw_bad_alloc();
  }
  static constexpr _LIBCPP_HIDE_FROM_ABI void shrink_to_fit() noexcept {}

  // ekenebt access
  constexpr _LIBCPP_HIDE_FROM_ABI reference operator[](size_type __n) noexcept /* strengthened */ {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__n < size(), "inplace_vector[] index out of bounds");
    return data()[__n];
  }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reference operator[](size_type __n) const noexcept /* strengthened */ {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__n < size(), "inplace_vector[] index out of bounds");
    return data()[__n];
  }
  constexpr _LIBCPP_HIDE_FROM_ABI reference at(size_type __n) {
    if (__n >= size())
      __inplace_vector_throw_out_of_range();
    return data()[__n];
  }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reference at(size_type __n) const {
    if (__n >= size())
      __inplace_vector_throw_out_of_range();
    return data()[__n];
  }
  constexpr _LIBCPP_HIDE_FROM_ABI reference front() noexcept /* strengthened */ {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(!empty(), "front() called on an empty inplace_vector");
    return *data();
  }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reference front() const noexcept /* strengthened */ {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(!empty(), "front() called on an empty inplace_vector");
    return *data();
  }
  constexpr _LIBCPP_HIDE_FROM_ABI reference back() noexcept /* strengthened */ {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(!empty(), "back() called on an empty inplace_vector");
    return data()[__sz_ - __small_size_type(1)];
  }
  constexpr _LIBCPP_HIDE_FROM_ABI const_reference back() const noexcept /* strengthened */ {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(!empty(), "back() called on an empty inplace_vector");
    return data()[__sz_ - __small_size_type(1)];
  }

  // [inplace.vector.daa], data access
  constexpr _LIBCPP_HIDE_FROM_ABI _Tp* data() noexcept { return __elems_; }
  constexpr _LIBCPP_HIDE_FROM_ABI const _Tp* data() const noexcept { return __elems_; }

private:
  template <class _It, class _Sent>
  constexpr _LIBCPP_HIDE_FROM_ABI void
  __append_with_size(_It&& __first, [[maybe_unused]] _Sent&& __last, size_type __n) {
    [[maybe_unused]] __small_size_type __expected_size = size();
    while (__n--) {
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__first != __last, "Iterators modified during assignment or size was wrong");

      unchecked_emplace_back(*__first);
      ++__first;

      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
          __sz_ == ++__expected_size, "Iterator or assignment modified container size during append");
    }
  }

  template <bool _ThrowOnMissingCapacity = true, class _It, class _Sent>
  constexpr _LIBCPP_HIDE_FROM_ABI void __append_with_sentinel(_It&& __it, _Sent&& __last) {
    const __small_size_type __initial_size             = __sz_;
    [[maybe_unused]] __small_size_type __expected_size = __sz_;
    pointer __p                                        = __elems_ + __initial_size;
    while (__p != __elems_ + capacity()) {
      if (__it == __last)
        return;
      unchecked_emplace_back(*__it);
      ++__expected_size;
      ++__it;
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
          __sz_ == __expected_size, "iterator operation modified container size during append");
    }
    if constexpr (_ThrowOnMissingCapacity) {
      if (__it == __last)
        return;

      // Exception safety: container must remain unchanged
      __resize_down(__initial_size);
      __throw_bad_alloc();
    }
  }

  template <bool _ThrowOnMissingCapacity, class _Range>
  constexpr _LIBCPP_HIDE_FROM_ABI __conditional_t<_ThrowOnMissingCapacity, void, ranges::borrowed_iterator_t<_Range>>
  __append_range(_Range&& __rg) {
    decltype(auto) __first(ranges::begin(__rg));
    size_t __remaining = capacity() - size();
    if (_ThrowOnMissingCapacity || __remaining != 0) {
      decltype(auto) __sent(ranges::end(__rg));
      if constexpr (ranges::sized_range<_Range&>) {
        auto __n = ranges::size(__rg);
        size_t __copied;
        if constexpr (_ThrowOnMissingCapacity) {
          if (std::cmp_greater(__n, __remaining))
            __throw_bad_alloc();
          __copied = static_cast<size_t>(__n);
        } else {
          if (std::cmp_greater(__n, __remaining))
            __copied = __remaining;
          else
            __copied = static_cast<size_t>(__n);
        }
        __append_with_size(__first, __sent, __copied);
      } else {
        __append_with_sentinel<_ThrowOnMissingCapacity>(__first, __sent);
      }
    }
    if constexpr (!_ThrowOnMissingCapacity)
      return __first;
  }

public:
  // [inplace.vector.modifiers], modifiers
  template <class... _Args>
  constexpr _LIBCPP_HIDE_FROM_ABI reference emplace_back(_Args&&... __args) {
    if (size() == capacity()) [[unlikely]]
      __throw_bad_alloc();
    return unchecked_emplace_back(std::forward<_Args>(__args)...);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI reference push_back(const _Tp& __x) { return emplace_back(__x); }
  constexpr _LIBCPP_HIDE_FROM_ABI reference push_back(_Tp&& __x) { return emplace_back(std::move(__x)); }
  template <_ContainerCompatibleRange<_Tp> _Range>
  constexpr _LIBCPP_HIDE_FROM_ABI void append_range(_Range&& __rg) {
    __append_range<true>(std::forward<_Range>(__rg));
  }

  constexpr _LIBCPP_HIDE_FROM_ABI void pop_back() noexcept /* strengthened */ {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(!empty(), "pop_back() called on an empty inplace_vector");
    if constexpr (_Capacity) {
      [[maybe_unused]] __small_size_type __expected_size = --__sz_;
      if (__do_destroy())
        std::destroy_at(__elems_ + __sz_ - 1);
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
          __sz_ == __expected_size, "inplace_vector modified during element destruction");
    } else {
      unreachable();
    }
  }

  template <class... _Args>
  constexpr _LIBCPP_HIDE_FROM_ABI pointer
  try_emplace_back(_Args&&... __args) noexcept(is_nothrow_constructible_v<_Tp, _Args...> // strengthened
  ) {
    if (size() == capacity())
      return nullptr;
    return std::addressof(unchecked_emplace_back(std::forward<_Args>(__args)...));
  }
  constexpr _LIBCPP_HIDE_FROM_ABI pointer
  try_push_back(const _Tp& __x) noexcept(is_nothrow_copy_constructible_v<_Tp>) // strengthened
  {
    return try_emplace_back(__x);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI pointer
  try_push_back(_Tp&& __x) noexcept(is_nothrow_move_constructible_v<_Tp> // strengthened
  ) {
    return try_emplace_back(std::move(__x));
  }
  template <_ContainerCompatibleRange<_Tp> _Range>
  constexpr _LIBCPP_HIDE_FROM_ABI ranges::borrowed_iterator_t<_Range> try_append_range(_Range&& __rg) {
    return __append_range<false>(std::forward<_Range>(__rg));
  }

  template <class... _Args>
  constexpr _LIBCPP_HIDE_FROM_ABI reference
  unchecked_emplace_back(_Args&&... __args) noexcept(is_nothrow_constructible_v<_Tp, _Args...> // strengthened
  ) {
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(
        size() < capacity(), "unchecked_emplace_back() called on an at-capacity inplace_vector");
    if constexpr (_Capacity == 0) {
      unreachable();
    }
    pointer __new                      = data() + size();
    [[maybe_unused]] size_t __old_size = __sz_;
    std::construct_at(__new, std::forward<_Args>(__args)...);
    _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__sz_ == __old_size, "inplace_vector modified during element construction");
    if constexpr (_Capacity) {
      ++__sz_;
    }
    return *__new;
  }
  constexpr _LIBCPP_HIDE_FROM_ABI reference
  unchecked_push_back(const _Tp& __x) noexcept(is_nothrow_copy_constructible_v<_Tp>) /* strengthened */ {
    return unchecked_emplace_back(__x);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI reference
  unchecked_push_back(_Tp&& __x) noexcept(is_nothrow_move_constructible_v<_Tp>) /* strengthened */ {
    return unchecked_emplace_back(std::move(__x));
  }

private:
  constexpr _LIBCPP_HIDE_FROM_ABI pointer __unwrap_iter(const_iterator __it) noexcept {
    return const_cast<pointer>(const_cast<const inplace_vector*>(this)->__unwrap_iter(__it));
  }
  constexpr _LIBCPP_HIDE_FROM_ABI const_pointer __unwrap_iter(const_iterator __it) const noexcept {
    const_pointer __p = std::to_address(__it);
    if constexpr (_Capacity == 0) {
      _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__p == nullptr, "Not an iterator into this inplace_vector<T, 0>");
    } else {
      _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(
          __elems_ <= __p && __p <= __elems_ + capacity(), "Not an iterator into this inplace_vector");
      _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__p <= __elems_ + __sz_, "This inplace_vector iterator is invalid");
    }
    return __p;
  }

public:
  template <class... _Args>
  constexpr _LIBCPP_HIDE_FROM_ABI iterator emplace(const_iterator __position, _Args&&... __args) {
    _Tp* const __p = __unwrap_iter(__position);
    if (size() == capacity())
      __throw_bad_alloc();

    if (__p == __elems_ + __sz_) {
      unchecked_emplace_back(std::forward<_Args>(__args)...);
    } else if (is_nothrow_constructible_v<_Tp, _Args&&...>) {
      unchecked_push_back(std::move(back()));
      std::move_backward(__p, __elems_ + __sz_ - 1, __elems_ + __sz_);
      std::destroy_at(__p);
      std::construct_at(__p, std::forward<_Args>(__args)...);
    } else {
      unchecked_emplace_back(std::forward<_Args>(__args)...);
      std::rotate(__p, __elems_ + __sz_ - 1, __elems_ + __sz_);
    }
    // (Update bounds for bounded iter)
    return __make_iter(__p);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __position, const _Tp& __x) {
    return emplace(__position, __x);
  }
  constexpr _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __position, _Tp&& __x) {
    return emplace(__position, std::move(__x));
  }
  constexpr _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __position, size_type __n, const _Tp& __x) {
    _Tp* const __p = __unwrap_iter(__position);
    if (__n > capacity() - size())
      __throw_bad_alloc();

    if (__p == __elems_ + __sz_) {
      resize(size() + __n, __x);
    } else {
      // Move the last __n elements over into newly constructed elements
      _Tp* const __old_end = __elems_ + __sz_;
      for (size_t __i = 0; __i < __n; ++__i) {
        unchecked_emplace_back(std::move(__elems_[__sz_ - __n]));
      }
      // Move over the remaining elements
      std::move_backward(__p, __old_end - __n, __old_end);
      // Insert the elements
      for (size_t __i = 0; __i < __n; ++__i) {
        __p[__i] = __x;
      }
    }
    return __make_iter(__p);
  }

private:
  template <class _Iterator, class _Sentinel, class _Size>
  constexpr _LIBCPP_HIDE_FROM_ABI iterator
  __insert_with_size(const_iterator __position, _Iterator&& __it, _Sentinel&& __sent, _Size __m) {
    _Tp* const __p = __unwrap_iter(__position);
    if (std::cmp_greater(__m, capacity() - size()))
      __throw_bad_alloc();
    auto __n = static_cast<__small_size_type>(__m);

    // Exception guarantee: Cannot modify the initial elements if copy/move construct/assign of _Tp throws or if
    // iterator operations throw, so elements must be rotated in if they can throw. Otherwise, optimise by moving
    // existing elements "out of the way" first then construct in-place to avoid swapping.
    bool __can_avoid_rotate = is_nothrow_copy_constructible_v<_Tp> && is_nothrow_move_assignable_v<_Tp> &&
                              noexcept(++__it) && noexcept(*__it) && is_nothrow_constructible_v<_Tp, decltype(*__it)>;

    if (__p == __elems_ + __sz_) {
      __append_with_size(std::forward<_Iterator>(__it), std::forward<_Sentinel>(__sent), __n);
    } else if (__can_avoid_rotate) {
      _Tp* const __old_end = __elems_ + __sz_;
      for (size_t __i = 0; __i < __n; ++__i) {
        unchecked_emplace_back(std::move(__elems_[__sz_ - __n]));
      }
      std::move_backward(__p, __old_end - __n, __old_end);

      [[maybe_unused]] __small_size_type __expected_size = __sz_;
      for (size_t __i = 0; __i < __n; ++__i) {
        std::destroy_at(__p + __i);
        // This has already been checked to not throw so the container will never contain a destructed element
        std::construct_at(__p + __i, *__it);
        ++__it;
        _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(
            __sz_ == __expected_size, "inplace_vector modified by iterator operation during insert");
      }
    } else {
      __append_with_size(std::forward<_Iterator>(__it), std::forward<_Sentinel>(__sent), __n);
      std::rotate(__p, __elems_ + __sz_ - __n, __elems_ + __sz_);
    }
    return __make_iter(__p);
  }

  template <class _Iterator, class _Sentinel>
  constexpr _LIBCPP_HIDE_FROM_ABI iterator
  __insert_with_sentinel(const_iterator __position, _Iterator&& __it, _Sentinel&& __sent) {
    _Tp* const __p = __unwrap_iter(__position);

    if (__p == __elems_ + __sz_) {
      __append_with_sentinel(std::forward<_Iterator>(__it), std::forward<_Sentinel>(__sent));
    } else {
      _Tp* const __original_end = __elems_ + __sz_;
      __append_with_sentinel(std::forward<_Iterator>(__it), std::forward<_Sentinel>(__sent));
      std::rotate(__p, __original_end, __elems_ + __sz_);
    }
    return __make_iter(__p);
  }

public:
  template <class _InputIterator>
    requires(__has_input_iterator_category<_InputIterator>::value)
  constexpr _LIBCPP_HIDE_FROM_ABI iterator
  insert(const_iterator __position, _InputIterator __first, _InputIterator __last) {
    if constexpr (__has_forward_iterator_category<_InputIterator>::value) {
      return __insert_with_size(__position, __first, __last, std::distance(__first, __last));
    }
    return __insert_with_sentinel(__position, __first, __last);
  }
  template <_ContainerCompatibleRange<_Tp> _Range>
  constexpr _LIBCPP_HIDE_FROM_ABI iterator insert_range(const_iterator __position, _Range&& __rg) {
    decltype(auto) __first(ranges::begin(__rg));
    decltype(auto) __sent(ranges::end(__rg));
    if constexpr (ranges::sized_range<_Range&>) {
      return __insert_with_size(__position, __first, __sent, ranges::size(__rg));
    } else {
      return __insert_with_sentinel(__position, __first, __sent);
    }
  }
  constexpr _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __position, initializer_list<_Tp> __il) {
    return insert(__position, __il.begin(), __il.end());
  }

  constexpr _LIBCPP_HIDE_FROM_ABI void erase(const_iterator __position) noexcept /* strengthened */ {
    _Tp* const __p = __unwrap_iter(__position);
    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__p != __elems_ + __sz_, "Cannot erase the end iterator");
    std::move(__p + 1, __elems_ + __sz_, __p);
    pop_back();
  }
  constexpr _LIBCPP_HIDE_FROM_ABI void erase(const_iterator __first, const_iterator __last) noexcept
  /* strengthened */ {
    _Tp* const __p = __unwrap_iter(__first);
    _Tp* const __q = __unwrap_iter(__last);
    _LIBCPP_ASSERT_VALID_INPUT_RANGE(__p <= __q, "inplace_vector::erase begin iterator is after end iterator");
    const __small_size_type __erased = __q - __p;
    std::move(__q, __elems_ + __sz_, __p);
    __resize_down(__sz_ - __erased);
  }

  constexpr _LIBCPP_HIDE_FROM_ABI void swap(inplace_vector& __x) noexcept(
      _Capacity == 0 || (is_nothrow_swappable_v<_Tp> && is_nothrow_move_constructible_v<_Tp>)) {
    inplace_vector* __smaller        = this;
    inplace_vector* __bigger         = std::addressof(__x);
    __small_size_type __smaller_size = __smaller->__sz_;
    __small_size_type __bigger_size  = __bigger->__sz_;
    if (__smaller_size > __bigger_size) {
      std::swap(__smaller, __bigger);
      std::swap(__smaller_size, __bigger_size);
    }

    std::swap_ranges(+__smaller->__elems_, __smaller->__elems_ + __smaller_size, +__bigger->__elems_);
    _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__smaller->__sz_ == __smaller_size && __bigger->__sz_ == __bigger_size,
                                        "inplace_vector modified when swapping elements");
    for (__small_size_type __i = __smaller_size; __i != __bigger_size; ++__i) {
      unchecked_push_back(std::move(__bigger->data()[__i++]));
      _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__smaller->__sz_ == __i && __bigger->__sz_ == __bigger_size,
                                          "inplace_vector modified when swapping elements");
    }
    __bigger->__resize_down(__smaller_size);
  }

  constexpr _LIBCPP_HIDE_FROM_ABI void clear() noexcept {
    if constexpr (_Capacity != 0) {
      __sz_ = 0;
    }
    if (__do_destroy())
      std::destroy(__elems_, __elems_ + __sz_);
    _LIBCPP_ASSERT_SEMANTIC_REQUIREMENT(__sz_ == 0, "inplace_vector modified by element destructor during clear()");
  }

  friend constexpr _LIBCPP_HIDE_FROM_ABI bool operator==(const inplace_vector& __x, const inplace_vector& __y) {
    size_t __sz = __x.size();
    if (__sz != __y.size())
      return false;
    return std::equal(__x.data(), __x.data() + __sz, __y.data());
  }
  // LWG4122
  friend constexpr _LIBCPP_HIDE_FROM_ABI auto operator<=>(const inplace_vector& __x, const inplace_vector& __y)
    requires(requires(const _Tp& __t) { __t < __t; })
  {
    return std::lexicographical_compare_three_way(
        __x.data(), __x.data() + __x.size(), __y.data(), __y.data() + __y.size(), std::__synth_three_way);
  }

  constexpr friend _LIBCPP_HIDE_FROM_ABI void swap(inplace_vector& __x, inplace_vector& __y) noexcept(
      _Capacity == 0 || (is_nothrow_swappable_v<_Tp> && is_nothrow_move_constructible_v<_Tp>)) {
    __x.swap(__y);
  }
};

template <class _Tp, size_t _Capacity, class _Up>
constexpr _LIBCPP_HIDE_FROM_ABI size_t erase(inplace_vector<_Tp, _Capacity>& __c, const _Up& __value) noexcept(
    is_nothrow_move_assignable_v<_Tp> && noexcept(static_cast<bool>(__value == __value)) // strengthened
) {
  auto __it = std::remove(__c.begin(), __c.end(), __value);
  auto __r  = __c.end() - __it;
  __c.erase(__it, __c.end());
  return __r;
}

template <class _Tp, size_t _Capacity, class _Predicate>
constexpr _LIBCPP_HIDE_FROM_ABI size_t erase_if(inplace_vector<_Tp, _Capacity>& __c, _Predicate __pred) noexcept(
    is_nothrow_move_assignable_v<_Tp> && noexcept(remove_cvref_t<_Predicate>(__pred)) &&
    noexcept(static_cast<bool>(!std::declval<remove_cvref_t<_Predicate>&>()(std::declval<_Tp&>()))) // strengthened
) {
  auto __it = std::remove_if(__c.begin(), __c.end(), __pred);
  auto __r  = __c.end() - __it;
  __c.erase(__it, __c.end());
  return __r;
}

#endif // _LIBCPP_STD_VER >= 26

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif // _LIBCPP_INPLACE_VECTOR
