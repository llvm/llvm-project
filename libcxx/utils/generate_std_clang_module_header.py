# ===----------------------------------------------------------------------===##
#
# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ===----------------------------------------------------------------------===##

import operator
import os.path

import libcxx.header_information

public_headers = libcxx.header_information.public_headers
header_include_requirements = libcxx.header_information.header_include_requirements
always_available_headers = frozenset(public_headers).difference(
    *header_include_requirements.values()
)

libcxx_include_directory = os.path.join(
    os.path.dirname(os.path.dirname(os.path.realpath(__file__))), "include"
)
with open(
    os.path.join(libcxx_include_directory, "__std_clang_module"), "w"
) as std_clang_module_header:
    std_clang_module_header.write(
        """\
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

// WARNING, this entire header is generated by
// utils/generate_std_clang_module_header.py
// DO NOT MODIFY!

// This header should not be directly included, it's exclusively to import all
// of the libc++ public clang modules for the `std` clang module to export. In
// other words, it's to facilitate `@import std;` in Objective-C++ and `import std`
// in Swift to expose all of the libc++ interfaces. This is generally not
// recommended, however there are some clients that need to import all of libc++
// without knowing what "all" is.
#if !__building_module(std)
#  error "Do not include this header directly, include individual headers instead"
#endif

#include <__config>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

"""
    )
    # Include the angle brackets in sorting so that <a.h> sorts before <a>
    # like check-format wants.
    for include in sorted([f"<{header}>" for header in always_available_headers]):
        std_clang_module_header.write(f"#include {include}\n")

    for requirements, headers in sorted(
        header_include_requirements.items(), key=operator.itemgetter(0)
    ):
        std_clang_module_header.write("\n")
        if len(requirements) == 1:
            std_clang_module_header.write("#ifndef ")
            std_clang_module_header.write(requirements[0])
        else:
            std_clang_module_header.write("#if")
            for index, requirement in enumerate(requirements):
                if index > 0:
                    std_clang_module_header.write(" &&")
                std_clang_module_header.write(f" !defined({requirement})")
        std_clang_module_header.write("\n")

        for include in sorted([f"<{header}>" for header in headers]):
            std_clang_module_header.write(f"#  include {include}\n")

        std_clang_module_header.write("#endif\n")
