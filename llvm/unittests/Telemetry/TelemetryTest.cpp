//===- llvm/unittest/Telemetry/TelemetryTest.cpp - Telemetry unittests ---===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "llvm/Telemetry/Telemetry.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/IR/DebugInfoMetadata.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/JSON.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/raw_ostream.h"
#include "gtest/gtest.h"
#include <chrono>
#include <ctime>
#include <vector>

#include <iostream>

namespace llvm {
namespace telemetry {
// Testing parameters.
// These are set by each test to force certain outcomes.
// Since the tests may run in parallel, each test will have
// its own TestContext populated.
struct TestContext {
  // Controlling whether there is vendor plugin.
  // In "real" implementation, the plugin-registration
  // framework will handle the overrides but for tests,
  // we just use a bool flag to decide which function to call.
  bool HasVendorPlugin = false;

  // These two fields contain data emitted by the framework for later
  // verifications by the tests.
  std::string Buffer = "";
  std::vector<json::Object> EmittedJsons;

  // The expected Uuid generated by the fake tool.
  std::string ExpectedUuid = "";
};

class JsonSerializer : public Serializer {
public:
  json::Object *getOutputObject() { return object.get(); }

  llvm::Error init() override {
    if (started)
      return createStringError("Serializer already in use");
    started = true;
    object = std::make_unique<json::Object>();
    return Error::success();
  }

  void write(StringRef KeyName, bool Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, int Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, size_t Value) override {
    writeHelper(KeyName, Value);
  }
  void write(StringRef KeyName, StringRef Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName,
             const std::map<std::string, std::string> &Value) override {
    json::Object Inner;
    for (auto kv : Value) {
      Inner.try_emplace(kv.first, kv.second);
    }
    writeHelper(KeyName, json::Value(std::move(Inner)));
  }

  llvm::Error finalize() override {
    if (!started)
      return createStringError("Serializer not currently in use");
    started = false;
    return Error::success();
  }

private:
  template <typename T> void writeHelper(StringRef Name, T Value) {
    assert(started && "serializer not started");
    object->try_emplace(Name, Value);
  }
  bool started = false;
  std::unique_ptr<json::Object> object;
};

class StringSerializer : public Serializer {
public:
  const std::string &getString() { return Buffer; }

  llvm::Error init() override {
    if (started)
      return createStringError("Serializer already in use");
    started = true;
    Buffer.clear();
    return Error::success();
  }

  void write(StringRef KeyName, bool Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, int Value) override {
    writeHelper(KeyName, Value);
  }

  void write(StringRef KeyName, size_t Value) override {
    writeHelper(KeyName, Value);
  }
  void write(StringRef KeyName, StringRef Value) override {
    assert(started && "serializer not started");
  }

  void write(StringRef KeyName,
             const std::map<std::string, std::string> &Value) override {
    std::string Inner;
    for (auto kv : Value) {
      writeHelper(StringRef(kv.first), StringRef(kv.second), &Inner);
    }
    writeHelper(KeyName, StringRef(Inner));
  }

  llvm::Error finalize() override {
    if (!started)
      return createStringError("Serializer not currently in use");
    started = false;
    return Error::success();
  }

private:
  template <typename T>
  void writeHelper(StringRef Name, T Value, std::string *Buff) {
    assert(started && "serializer not started");
    Buff->append((Name + ":" + llvm::Twine(Value) + "\n").str());
  }

  template <typename T> void writeHelper(StringRef Name, T Value) {
    writeHelper(Name, Value, &Buffer);
  }

  bool started = false;
  std::string Buffer;
};

namespace vendor {
struct VendorConfig : public Config {
  VendorConfig(bool Enable) : Config(Enable) {}
  std::string makeSessionId() override {
    static int seed = 0;
    return std::to_string(seed++);
  }
};

std::shared_ptr<Config> GetTelemetryConfig(const TestContext &Ctxt) {
  return std::make_shared<VendorConfig>(/*EnableTelemetry*/ true);
}

class JsonStorageDestination : public Destination {
public:
  JsonStorageDestination(TestContext *Ctxt) : CurrentContext(Ctxt) {}

  Error receiveEntry(const TelemetryInfo *Entry) override {
    if (Error err = serializer.init()) {
      return err;
    }
    Entry->serialize(serializer);
    if (Error err = serializer.finalize()) {
      return err;
    }

    json::Object copied = *serializer.getOutputObject();
    CurrentContext->EmittedJsons.push_back(std::move(copied));

    return Error::success();
  }

  llvm::StringLiteral name() const override { return "JsonDestination"; }

private:
  TestContext *CurrentContext;
  JsonSerializer serializer;
};

struct StartupInfo : public TelemetryInfo {
  std::string ToolName;

  void serialize(Serializer &serializer) const override {
    TelemetryInfo::serialize(serializer);
    serializer.write("ToolName", ToolName);
  }
};

struct ExitInfo : public TelemetryInfo {
  int ExitCode;
  std::string ExitDesc;
  void serialize(Serializer &serializer) const override {
    TelemetryInfo::serialize(serializer);
    serializer.write("ExitCode", ExitCode);
    serializer.write("ExitDesc", ExitDesc);
  }
};

class TestManager : public Manager {
public:
  static std::unique_ptr<TestManager>
  createInstance(Config *config, TestContext *CurrentContext) {
    if (!config->EnableTelemetry)
      return nullptr;
    CurrentContext->ExpectedUuid = config->makeSessionId();
    std::unique_ptr<TestManager> Ret = std::make_unique<TestManager>(
        CurrentContext, CurrentContext->ExpectedUuid);

    // Add a few destinations.
    Ret->addDestination(
        std::make_unique<JsonStorageDestination>(CurrentContext));

    return Ret;
  }

  TestManager(TestContext *Ctxt, std::string Id)
      : CurrentContext(Ctxt), SessionId(Id) {}

  Error dispatch(TelemetryInfo *Entry) override {
    Entry->SessionId = SessionId;
    for (auto &Dest : Destinations) {
      if (Error err = Dest->receiveEntry(Entry)) {
        return err;
      }
    }
    return Error::success();
  }

  void addDestination(std::unique_ptr<Destination> Dest) override {
    Destinations.push_back(std::move(Dest));
  }

  std::string getSessionId() { return SessionId; }

  Error atStartup(StartupInfo *Info) { return dispatch(Info); }

  Error atExit(ExitInfo *Info) { return dispatch(Info); }

private:
  TestContext *CurrentContext;
  const std::string SessionId;
  std::vector<std::unique_ptr<Destination>> Destinations;
};

} // namespace vendor

std::shared_ptr<Config> GetTelemetryConfig(const TestContext &Ctxt) {
  if (Ctxt.HasVendorPlugin)
    return vendor::GetTelemetryConfig(Ctxt);

  return std::make_shared<Config>(false);
}

TEST(TelemetryTest, TelemetryEnabled) {
  const std::string ToolName = "TelemetryTestTool";

  // Preset some params
  TestContext Context;
  Context.HasVendorPlugin = true;
  Context.Buffer.clear();
  Context.EmittedJsons.clear();

  std::shared_ptr<Config> Config = GetTelemetryConfig(Context);
  auto Manager = vendor::TestManager::createInstance(Config.get(), &Context);

  EXPECT_STREQ(Manager->getSessionId().c_str(), Context.ExpectedUuid.c_str());

  vendor::StartupInfo S;
  S.ToolName = ToolName;

  Error startupEmitStatus = Manager->atStartup(&S);
  EXPECT_FALSE(startupEmitStatus);
  const json::Object &StartupEntry = Context.EmittedJsons[0];
  json::Object ExpectedStartup(
      {{"SessionId", Context.ExpectedUuid}, {"ToolName", ToolName}});
  EXPECT_EQ(ExpectedStartup, StartupEntry);

  vendor::ExitInfo E;
  E.ExitCode = 0;
  E.ExitDesc = "success";
  Error exitEmitStatus = Manager->atExit(&E);
  EXPECT_FALSE(exitEmitStatus);
  const json::Object &ExitEntry = Context.EmittedJsons[1];
  json::Object ExpectedExit({{"SessionId", Context.ExpectedUuid},
                             {"ExitCode", 0},
                             {"ExitDesc", "success"}});
  EXPECT_EQ(ExpectedExit, ExitEntry);
}

} // namespace telemetry
} // namespace llvm
