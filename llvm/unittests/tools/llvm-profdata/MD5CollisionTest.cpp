//===- llvm/unittests/tools/llvm-profdata/MD5CollisionTest.cpp ------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

/// Test whether the MD5-key SampleProfileMap can handle collision correctly.
/// Probability of collision is rare but not negligible since we only use the
/// lower 64 bits of the MD5 value. A unit test is required because the function
/// names are not printable ASCII characters.

#include "llvm/ProfileData/SampleProfReader.h"
#include "llvm/Support/VirtualFileSystem.h"
#include "llvm/Testing/Support/Error.h"
#include "gtest/gtest.h"

/// According to https://en.wikipedia.org/wiki/MD5#Preimage_vulnerability, the
/// MD5 of the two strings are 79054025255fb1a26e4bc422aef54eb4.

// First 8 bytes of the MD5.
const uint64_t ExpectedHash = 0xa2b15f2525400579;

// clang-format off
const uint8_t ProfileData[] = {
    0x84, 0xe4, 0xd0, 0xb1, 0xf4, 0xc9, 0x94, 0xa8,
    0x53, 0x67, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00,

    /// Name Table
    0x02,
    /// String1
    0xd1, 0x31, 0xdd, 0x02, 0xc5, 0xe6, 0xee, 0xc4,
    0x69, 0x3d, 0x9a, 0x06, 0x98, 0xaf, 0xf9, 0x5c,
    0x2f, 0xca, 0xb5, 0x87, 0x12, 0x46, 0x7e, 0xab,
    0x40, 0x04, 0x58, 0x3e, 0xb8, 0xfb, 0x7f, 0x89,
    0x55, 0xad, 0x34, 0x06, 0x09, 0xf4, 0xb3, 0x02,
    0x83, 0xe4, 0x88, 0x83, 0x25, 0x71, 0x41, 0x5a,
    0x08, 0x51, 0x25, 0xe8, 0xf7, 0xcd, 0xc9, 0x9f,
    0xd9, 0x1d, 0xbd, 0xf2, 0x80, 0x37, 0x3c, 0x5b,
    0xd8, 0x82, 0x3e, 0x31, 0x56, 0x34, 0x8f, 0x5b,
    0xae, 0x6d, 0xac, 0xd4, 0x36, 0xc9, 0x19, 0xc6,
    0xdd, 0x53, 0xe2, 0xb4, 0x87, 0xda, 0x03, 0xfd,
    0x02, 0x39, 0x63, 0x06, 0xd2, 0x48, 0xcd, 0xa0,
    0xe9, 0x9f, 0x33, 0x42, 0x0f, 0x57, 0x7e, 0xe8,
    0xce, 0x54, 0xb6, 0x70, 0x80, 0xa8, 0x0d, 0x1e,
    0xc6, 0x98, 0x21, 0xbc, 0xb6, 0xa8, 0x83, 0x93,
    0x96, 0xf9, 0x65, 0x2b, 0x6f, 0xf7, 0x2a, 0x70, 0x00,
    /// String2
    0xd1, 0x31, 0xdd, 0x02, 0xc5, 0xe6, 0xee, 0xc4,
    0x69, 0x3d, 0x9a, 0x06, 0x98, 0xaf, 0xf9, 0x5c,
    0x2f, 0xca, 0xb5, 0x07, 0x12, 0x46, 0x7e, 0xab,
    0x40, 0x04, 0x58, 0x3e, 0xb8, 0xfb, 0x7f, 0x89,
    0x55, 0xad, 0x34, 0x06, 0x09, 0xf4, 0xb3, 0x02,
    0x83, 0xe4, 0x88, 0x83, 0x25, 0xf1, 0x41, 0x5a,
    0x08, 0x51, 0x25, 0xe8, 0xf7, 0xcd, 0xc9, 0x9f,
    0xd9, 0x1d, 0xbd, 0x72, 0x80, 0x37, 0x3c, 0x5b,
    0xd8, 0x82, 0x3e, 0x31, 0x56, 0x34, 0x8f, 0x5b,
    0xae, 0x6d, 0xac, 0xd4, 0x36, 0xc9, 0x19, 0xc6,
    0xdd, 0x53, 0xe2, 0x34, 0x87, 0xda, 0x03, 0xfd,
    0x02, 0x39, 0x63, 0x06, 0xd2, 0x48, 0xcd, 0xa0,
    0xe9, 0x9f, 0x33, 0x42, 0x0f, 0x57, 0x7e, 0xe8,
    0xce, 0x54, 0xb6, 0x70, 0x80, 0x28, 0x0d, 0x1e,
    0xc6, 0x98, 0x21, 0xbc, 0xb6, 0xa8, 0x83, 0x93,
    0x96, 0xf9, 0x65, 0xab, 0x6f, 0xf7, 0x2a, 0x70, 0x00,

    /// FuncOffsetTable
    0x02, 0x00, 0x00, 0x01, 0x17, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    /// Samples
    /// String1:10:1
    ///  1: 5
    ///  2.3: 6
    ///  4: String2:100
    ///   1: 100
    /// String2:7:3
    ///  9: 0
    0x01, 0x00, 0x0a, 0x02, 0x01, 0x00, 0x05, 0x00,
    0x02, 0x03, 0x06, 0x00, 0x01, 0x04, 0x00, 0x01,
    0x64, 0x01, 0x01, 0x00, 0x64, 0x00, 0x00,

    0x03, 0x01, 0x07, 0x01, 0x09, 0x00, 0x00, 0x00,
    0x00};
// clang-format on

using namespace llvm;
using namespace llvm::sampleprof;

TEST(MD5CollisionTest, TestCollision) {
  auto InputBuffer = MemoryBuffer::getMemBuffer(
      StringRef(reinterpret_cast<const char *>(ProfileData),
                sizeof(ProfileData)),
      "", false);
  LLVMContext Context;
  auto FileSystem = vfs::getRealFileSystem();
  auto Result = SampleProfileReader::create(InputBuffer, Context, *FileSystem);
  ASSERT_TRUE(Result);
  SampleProfileReader *Reader = Result->get();
  ASSERT_FALSE(Reader->read());

  std::vector<StringRef> &NameTable = *Reader->getNameTable();
  ASSERT_EQ(NameTable.size(), 2U);
  StringRef S1 = NameTable[0];
  StringRef S2 = NameTable[1];
  ASSERT_NE(S1, S2);
  ASSERT_EQ(MD5Hash(S1), ExpectedHash);
  ASSERT_EQ(MD5Hash(S2), ExpectedHash);

  // S2's MD5 value collides with S1, S1 is expected to be dropped when S2 is
  // inserted, as if S1 never existed.

  FunctionSamples ExpectedFS;
  ExpectedFS.setName(S2);
  ExpectedFS.setHeadSamples(3);
  ExpectedFS.setTotalSamples(7);
  ExpectedFS.addBodySamples(9, 0, 0);

  SampleProfileMap &Profiles = Reader->getProfiles();
  EXPECT_EQ(Profiles.size(), 1U);
  if (Profiles.size()) {
    auto &[Hash, FS] = *Profiles.begin();
    EXPECT_EQ(Hash, hash_code(ExpectedHash));
    EXPECT_EQ(FS, ExpectedFS);
  }

  // Inserting S2 again should fail, returning the existing sample unchanged.
  auto [It1, Inserted1] = Profiles.try_emplace(S2, FunctionSamples());
  EXPECT_FALSE(Inserted1);
  EXPECT_EQ(Profiles.size(), 1U);
  if (Profiles.size()) {
    auto &[Hash, FS] = *It1;
    EXPECT_EQ(Hash, hash_code(ExpectedHash));
    EXPECT_EQ(FS, ExpectedFS);
  }

  // Inserting S1 should success as if S2 never existed, and S2 is erased.
  FunctionSamples FS1;
  FS1.setName(S1);
  FS1.setHeadSamples(5);
  FS1.setTotalSamples(10);
  FS1.addBodySamples(1, 2, 5);

  auto [It2, Inserted2] = Profiles.try_emplace(S1, FS1);
  EXPECT_TRUE(Inserted2);
  EXPECT_EQ(Profiles.size(), 1U);
  if (Profiles.size()) {
    auto &[Hash, FS] = *It2;
    EXPECT_EQ(Hash, hash_code(ExpectedHash));
    EXPECT_EQ(FS, FS1);
  }
}
