//===-- ConnexISelDAGToDAG.cpp - A dag to dag inst selector for Connex ----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines a DAG pattern matching instruction selector for Connex,
// converting from a legalized dag to a Connex dag.
//
//===----------------------------------------------------------------------===//

#include "Connex.h"
#include "ConnexRegisterInfo.h"
#include "ConnexSubtarget.h"
#include "ConnexTargetMachine.h"
#include "llvm/CodeGen/FunctionLoweringInfo.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/IntrinsicsConnex.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/Endian.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetMachine.h"
#include <algorithm>
#include <optional>


#define DEBUG_TYPE "connex-isel"
#define PASS_NAME "Connex DAG->DAG Pattern Instruction Selection"

// RecoverFromLlvmIR.h must be put after DEBUG_TYPE, since it has LLVM_DEBUG()
#include "RecoverFromLlvmIR.h"

using namespace llvm;

#include "ConnexConfig.h"
#include "ConnexISelMisc.h"

/* To help reading ASM code we put some useful comments (INLINE Asm nodes)
     where the emulation of the unsupported operation of type i32/f16/etc
     starts and ends.
*/
#define MARKER_FOR_EMULATION

/* Important: These macros with BITCAST can add hazards due to delay slots.
    We recommend disabling these macros.
   */
#define BITCAST_MAY2017_05_28
// #define BITCAST_2018_06_F16

#define CrtDAG CurDAG

static bool isUnitSteppedZeroStartingVector(const BuildVectorSDNode *N) {
  unsigned int nOps = N->getNumOperands();

  assert(nOps > 1 && "isSplatVector has 0 or 1 sized build vector");

  LLVM_DEBUG(dbgs() << "Entered isUnitStridedZeroStartingVector()\n");

  for (unsigned int i = 0; i < nOps; ++i) {
    LLVM_DEBUG(dbgs() << "N->getOperand(" << i << ") = ";
               N->getOperand(i)->dump(); dbgs() << "\n");
  }

  LLVM_DEBUG(dbgs() << "Exiting isUnitStridedZeroStartingVector()\n");

  return true;
}

// Instruction Selector Implementation
namespace {

class ConnexDAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the ConnexSubtarget around so that we can
  /// make the right decision when generating code for different subtargets.
  // Inspired from BPF/BPFISelDAGToDAG.cpp (from Oct 2025)
  const ConnexSubtarget *Subtarget;

public:
  ConnexDAGToDAGISel() = delete;

  explicit ConnexDAGToDAGISel(ConnexTargetMachine &TM)
      : SelectionDAGISel(TM), Subtarget(nullptr) {}

private:
// Include the pieces autogenerated from the target description.
#include "ConnexGenDAGISel.inc"

  bool selectVectorAddr(SDNode *Parent, SDValue N, SDValue &Base);

  void selectBUILD_VECTOR(SDNode *Node);
  void selectVECTOR_SHUFFLE(SDNode *Node);

  SDNode *selectVSELECT(SDNode *Node);

  SDNode *selectReduceI32(SDNode *Node);
  SDNode *selectAddI32(SDNode *Node);
  SDNode *selectAbsI32(SDNode *Node);
  SDNode *selectSubI32(SDNode *Node);
  SDNode *selectMulI32(SDNode *Node);
  SDNode *selectSraI32(SDNode *Node);
  //
  SDNode *selectDivI16(SDNode *Node);
  //
  SDNode *selectReduceF16(SDNode *Node);
  SDNode *selectAddF16(SDNode *Node);
  SDNode *selectSubF16(SDNode *Node);
  SDNode *selectMulF16(SDNode *Node);
  SDNode *selectDivF16(SDNode *Node);
  SDNode *selectLtF16(SDNode *Node);

  void Select(SDNode *N) override;

  // Complex Pattern for address selection.
  bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectFIAddr(SDValue Addr, SDValue &Base, SDValue &Offset);

  // Added from MipsSEISelDAGToDAG.cpp
  bool selectAddrFrameIndex(SDValue Addr, SDValue &Base, SDValue &Offset) const;
  bool selectAddrFrameIndexOffset(SDValue Addr, SDValue &Base, SDValue &Offset,
                                  unsigned OffsetBits) const;
  bool selectAddrRegImm10(SDValue Addr, SDValue &Base, SDValue &Offset) const;
  bool selectAddrDefault(SDValue Addr, SDValue &Base, SDValue &Offset) const;
  bool selectIntAddrMSA(SDValue Addr, SDValue &Base, SDValue &Offset) const;

  // In Mips we have MipsSEIselDAGToDAG inheriting MipsIselDAGToDAG, but
  //     in Connex we do NOT, so we comment the override qualifier
  /// \brief Select constant vector splats.
  bool selectVSplat(SDNode *N, APInt &Imm,
                    unsigned MinSizeInBits) const; // override;
  /// \brief Select constant vector splats whose value fits in a given integer.
  bool selectVSplatCommon(SDValue N, SDValue &Imm, bool Signed,
                          unsigned ImmBitSize) const;
  /// \brief Select constant vector splats whose value fits in a uimm1.
  bool selectVSplatUimm1(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value fits in a uimm2.
  bool selectVSplatUimm2(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value fits in a uimm3.
  bool selectVSplatUimm3(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value fits in a uimm4.
  bool selectVSplatUimm4(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value fits in a uimm5.
  bool selectVSplatUimm5(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value fits in a uimm6.
  bool selectVSplatUimm6(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value fits in a uimm8.
  bool selectVSplatUimm8(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value fits in a simm5.
  bool selectVSplatSimm5(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value is a power of 2.
  bool selectVSplatUimmPow2(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value is the inverse of a
  /// power of 2.
  bool selectVSplatUimmInvPow2(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value is a run of set bits
  /// ending at the most significant bit
  bool selectVSplatMaskL(SDValue N, SDValue &Imm) const; // override;
  /// \brief Select constant vector splats whose value is a run of set bits
  /// starting at bit zero.
  bool selectVSplatMaskR(SDValue N, SDValue &Imm) const; // override;
}; // end class ConnexDAGToDAGISel

// Inspired from BPF/BPFISelDAGToDAG.cpp (from Oct 2025)
class ConnexDAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
  static char ID;
  ConnexDAGToDAGISelLegacy(ConnexTargetMachine &TM)
      : SelectionDAGISelLegacy(ID, std::make_unique<ConnexDAGToDAGISel>(TM)) {}
};
} // end namespace

char ConnexDAGToDAGISelLegacy::ID = 0;

INITIALIZE_PASS(ConnexDAGToDAGISelLegacy, DEBUG_TYPE, PASS_NAME, false, false)

// ComplexPattern used on Connex Load/Store instructions
bool ConnexDAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  // if Address is FI, get the TargetFrameIndex.
  SDLoc DL(Addr);
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    // TODO_CHANGE_BACKEND:
    Base = CrtDAG->getTargetFrameIndex(FIN->getIndex(), TYPE_SCALAR_ELEMENT);

    Offset = CrtDAG->getTargetConstant(0, DL, TYPE_SCALAR_ELEMENT);
    return true;
  }

  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress)
    return false;

  // Addresses of the form Addr+const or Addr|const
  if (CrtDAG->isBaseWithConstantOffset(Addr)) {
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    if (isInt<32>(CN->getSExtValue())) {
      // If the first operand is a FI, get the TargetFI Node
      if (FrameIndexSDNode *FIN =
              dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
        // TODO_CHANGE_BACKEND:
        Base =
            CrtDAG->getTargetFrameIndex(FIN->getIndex(), TYPE_SCALAR_ELEMENT);
      else
        Base = Addr.getOperand(0);

      // TODO_CHANGE_BACKEND:
      Offset = CrtDAG->getTargetConstant(CN->getSExtValue(), DL,
                                         TYPE_SCALAR_ELEMENT);

      return true;
    }
  }

  Base = Addr;
  // TODO_CHANGE_BACKEND:
  Offset = CrtDAG->getTargetConstant(0, DL, TYPE_SCALAR_ELEMENT);

  return true;
}

// ComplexPattern used on Connex FI instruction
bool ConnexDAGToDAGISel::SelectFIAddr(SDValue Addr, SDValue &Base,
                                      SDValue &Offset) {
  SDLoc DL(Addr);

  if (!CrtDAG->isBaseWithConstantOffset(Addr))
    return false;

  // Addresses of the form Addr+const or Addr|const
  ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
  if (isInt<32>(CN->getSExtValue())) {

    // If the first operand is a FI, get the TargetFI Node
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
      // TODO_CHANGE_BACKEND:
      Base = CrtDAG->getTargetFrameIndex(FIN->getIndex(), TYPE_SCALAR_ELEMENT);
    else
      return false;

    // TODO_CHANGE_BACKEND:
    Offset =
        CrtDAG->getTargetConstant(CN->getSExtValue(), DL, TYPE_SCALAR_ELEMENT);
    return true;
  }

  return false;
}

// Important: Note that recoverCExpressionFromSDNode() is used only for
//    REPEAT and BUILD_VECTOR nodes, in method Select().
std::string
recoverCExpressionFromSDNode(SDNode *theSDNode,
                             DenseMap<const Value *, SDValue> &SDBNodeMap,
                             bool failOver) {
  /*
  NOTE: the SelectionDAGISel::crtNodeMap, defined in
    lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,
    discussed at lists.llvm.org/pipermail/llvm-dev/2016-November/107361.html

  getNodeMap() (method defined by me) returns the NodeMap object from
    SelectionDAGBuilder.h with this definition:
          DenseMap<const Value*, SDValue> NodeMap;

  Note however that this info is not enough since some SDNodes get generated
    in the following phases of the back end, namely:
      - DAG combining - see lib/CodeGen/SelectionDAG/DAGCombiner.cpp

  This class gets invoked much later, after all the ones mentioned above have
    finished.
  */
  LLVM_DEBUG(
      dbgs()
      << "Entered recoverCExpressionFromSDNode() (ConnexISelDAGToDAG.cpp)\n");

  std::string res;

  // Important note: class SelectionDAGBuilder is forward declared.
  // assert(SDB != NULL);
  // assert(SDB->NodeMap[(const Value *)NULL]); // NodeMap is private
  // auto iterNodeMap = SDB->NodeMap.begin();

  // bool res = SDB->HasTailCall;

  // DenseMap<const Value*, SDValue> &SDBNodeMap = crtNodeMap;

  // unsigned size = SDB->NodeMap.size();
  LLVM_DEBUG(dbgs() << "recoverCExpressionFromSDNode(): SDB->NodeMap.size() = "
                    << SDBNodeMap.size() << ", theSDNode = ";
             theSDNode->dump();
             dbgs() << ", theSDNode (ptr) = " << theSDNode << "\n");

  /* We retrieve from the SDBNodeMap the associated LLVM IR Instruction for
    theSDNode (SDNode created by SelectionDAGBuilder). */

  int counter = 0;

  // See http://llvm.org/docs/doxygen/html/classllvm_1_1DenseMapBase.html
  for (auto iterNodeMap = SDBNodeMap.begin(); iterNodeMap != SDBNodeMap.end();
       iterNodeMap++, counter++) {

    // Type is: llvm::detail::DenseMapPair<const llvm::Value*, llvm::SDValue>
    auto tmp1 = (*iterNodeMap);

    // Value *crtValue = tmp1.first;
    const Instruction *crtValue = (const Instruction *)(tmp1.first);
    SDNode *crtSDNode = tmp1.second.getNode();

    LLVM_DEBUG(dbgs() << "recoverCExpressionFromSDNode(): [#" << counter
                      << "] tmp1.first = "
                      << *crtValue
                      /*
                      << ", tmp1.second = ";
                      tmp1.second.dump();
                      dbgs() << "\n"
                      */
                      << "\n");

    if (crtSDNode != nullptr) {
      LLVM_DEBUG(
          dbgs() << "recoverCExpressionFromSDNode(): tmp1.second.getNode() = ";
          crtSDNode->dump(); dbgs() << "\n");

      if (crtSDNode == theSDNode) {
        LLVM_DEBUG(
            dbgs() << "recoverCExpressionFromSDNode(): Found a match:...\n");

        /*
        This corresponds to cases like:
          From NEW_v128i16.zip/!/300_Opincaa/sSub/STDerr_llc_01
          recoverCExpressionFromSDNode():
            tmp1.first =   %broadcast.splatinsert10 =
              insertelement <128 x i16> undef, i16 %sub, i32 0, !dbg !8
          recoverCExpressionFromSDNode():
            tmp1.second.getNode() = t33: v128i16 = BUILD_VECTOR t35, t35, t35,
                                                                ... t35

        We can see here that the machine-independent back end instruction
          BUILD_VECTOR is more complex (less abstract) than the LLVM IR
          insertelement.
        The equivalent to BUILD_VECTOR LLVM IR program uses also a shufflevector
          instruction:
        %broadcast.splatinsert10 = insertelement <128 x i16> undef, i16 %sub,
                                                               i32 0, !dbg !8
        %broadcast.splat11 = shufflevector <128 x i16> %broadcast.splatinsert10,
                        <128 x i16> undef, <128 x i32> zeroinitializer, !dbg !8

        Note that recoverCExpressionFromSDNode() is used only for BUILD_VECTOR.

        For the SSD benchmark, the associated instruction is though
            ShuffleVector
         (see Tests/DawnCC/90_SSD/B/STDerr_llc_01).
        */
        /*
        assert( (crtValue->getOpcode() == Instruction::InsertElement) ||
                (crtValue->getOpcode() == Instruction::ShuffleVector)
              );
        */

        Instruction *crtValueOp1;

        switch (crtValue->getOpcode()) {
        case Instruction::InsertElement:
        case Instruction::ShuffleVector:
          if (crtValue->getOpcode() == Instruction::InsertElement) {
            crtValueOp1 = (Instruction *)(crtValue->getOperand(1));
          } else {
            crtValueOp1 = (Instruction *)(crtValue->getOperand(0));
            assert(crtValueOp1->getOpcode() == Instruction::InsertElement);
            // TODO: check that crtValueOp1->getOperand(0) is vec undef,
            //                  crtValueOp1->getOperand(2) is 0
            crtValueOp1 = (Instruction *)(crtValueOp1->getOperand(1));
          }
          LLVM_DEBUG(dbgs() << "  *crtValueOp1 = " << *crtValueOp1 << "\n");

          getExprForDMATransfer = true;
          // res = getExpr(crtValueOp1);
          res = canonicalizeExpression(getExpr(crtValueOp1), true);
          LLVM_DEBUG(dbgs() << "  getExpr(crtValueOp1) = " << res << "\n");
          break;
        default:
          getExprForDMATransfer = true;
          // res = getExpr(const_cast<Instruction *>(crtValue));
          res = canonicalizeExpression(
              getExpr(const_cast<Instruction *>(crtValue)), true);

          LLVM_DEBUG(dbgs() << "  getExpr(crtValue) = " << res << "\n");
          break;
        }
        break;
      }
    } else {
      LLVM_DEBUG(dbgs() << "recoverCExpressionFromSDNode(): "
                           "tmp1.second.getNode() == nullptr\n\n");
    }
  } // end for

  if (res.length() == 0) {
    if (failOver) {
// #define NVEC_STR "n.vec"
#define NVEC_STR "VTC_ceil"

      /* TODO: Find, if possible, a better solution. Keep track of the
         SelectionDAGs of all BBs, not just the current BB. */

      LLVM_DEBUG(
          dbgs()
          << "recoverCExpressionFromSDNode(): failOver == true --> we look "
             "for NVEC_STR (vector tripcount defined in LoopVectorize.cpp) "
             "in SDBNodeMap and retrieve for it\n");

      /* Although not a great alternative, we look in SDBNodeMap for
       *   an entry containing %n.vec - this should exist from a previous
       *   BB.
       */
      for (auto iterNodeMap = SDBNodeMap.begin();
           iterNodeMap != SDBNodeMap.end(); iterNodeMap++, counter++) {
        auto tmp1 = (*iterNodeMap);
        const Instruction *crtValue = (const Instruction *)(tmp1.first);

        LLVM_DEBUG(dbgs() << "recoverCExpressionFromSDNode(): *crtValue = "
                          << *crtValue << "\n");

        // See http://llvm.org/docs/doxygen/html/classllvm_1_1StringRef.html
        if (crtValue->getName().starts_with(NVEC_STR) == true) {
          getExprForDMATransfer = true;

          res = getExpr(const_cast<Instruction *>(crtValue));
          LLVM_DEBUG(dbgs() << "  recoverCExpressionFromSDNode(): res = " << res
                            << "\n");

          /* TODO: This is NOT good if the res already contains a constant such
             as 1 - OK we could take out CreateDiv in LoopVectorize.cpp, etc */

          // res = res + " / CONNEX_VECTOR_LENGTH";
          // Unfortunately, we hard code this also here...
        }
      }
    } else {
      assert(res.length() != 0);
    }
  }

  return res;
}

// Inspired from lib/Target/X86/X86ISelDAGToDAG.cpp
bool ConnexDAGToDAGISel::selectVectorAddr(SDNode *Parent, SDValue N,
                                          SDValue &Index) {
  LLVM_DEBUG(dbgs() << "Entered ConnexDAGToDAGISel::selectVectorAddr()\n");

  LLVM_DEBUG(dbgs() << "  selectVectorAddr(): Parent = "; Parent->dump(CrtDAG);
             dbgs() << "\n   N = "; N->dump(CrtDAG);
             /*
             dbgs() << "\n   Base.getNode() = " << Base.getNode();
             dbgs() << "\n     Base = "; Base->dump(CrtDAG);
             */
             dbgs() << "\n");

  // From llvm.org/docs/doxygen/html/classllvm_1_1MaskedGatherScatterSDNode.html
  MaskedGatherScatterSDNode *Mgs = dyn_cast<MaskedGatherScatterSDNode>(Parent);
  if (!Mgs)
    return false;

  /*
  // Retrieve the "scalar base pointer" (as said also at
  //  lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20150831/297534.html)
  Base = Mgs->getBasePtr();
  */
  Index = Mgs->getIndex();

  LLVM_DEBUG(dbgs() << "  selectVectorAddr(), after update: Parent = ";
             Parent->dump(CrtDAG); dbgs() << "\n   N = "; N->dump(CrtDAG);
             dbgs() << "\n   Index.getNode() = " << Index.getNode();
             dbgs() << "\n     Index = "; Index->dump(CrtDAG); dbgs() << "\n");

  LLVM_DEBUG(dbgs() << "Exiting ConnexDAGToDAGISel::selectVectorAddr()\n");

  return true;
}

SDNode *CreateInlineAsmNode(SelectionDAG *CrtDAG, std::string asmString,
                            SDNode *nodeSymImm, SDLoc &DL,
                            bool specialCase = false) {
  // This step is very Important:
  // Important: As of Oct 2016, we must malloc the char * that is passed to
  //  getTargetExternalSymbol as a reference, so we must make sure
  //  the value persists after we get out of this function.
  //   Hopefully no leak will happen either - maybe when deleting
  //     SDNode the destructor frees the char *.
  // With difficulty I found with Google this method doing
  // creation of the SDNode, which is used also by
  // getTargetExternalSymbol().
  //  template <typename SDNodeT, typename... ArgTypes>
  //    SDNodeT *newSDNode(ArgTypes &&... Args) {
  //      return new (NodeAllocator.template Allocate<SDNodeT>())
  //          SDNodeT(std::forward<ArgTypes>(Args)...);
  //  }
  char *exprStrChar = new char[MAXLEN_STR];
  // strcpy(exprStrChar, asmString.c_str());
  // Inspired from
  // www.appsloveworld.com/cplus/100/251/c-stdstring-alternative-to-strcpy See
  // https://en.cppreference.com/w/cpp/algorithm/copy_n
  std::copy_n(asmString.c_str(), asmString.size() + 1, exprStrChar);
  LLVM_DEBUG(dbgs() << "CreateInlineAsmNode(): exprStrChar = " << exprStrChar
                    << "\n");
  /*
  See http://llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html:
    SDValue getTargetExternalSymbol(const char *Sym, EVT VT,
                                    unsigned char TargetFlags=0)
  */
  SDValue extSym = CrtDAG->getTargetExternalSymbol(exprStrChar, MVT::i64);
  SDNode *extSymNode = extSym.getNode();
  LLVM_DEBUG(dbgs() << "CreateInlineAsmNode(): extSymNode = ";
             extSymNode->dump(); dbgs() << "\n");

  /*
   From http://llvm.org/doxygen/namespacellvm_1_1ISD.html
       "INLINEASM - Represents an inline asm block.
       This node always has two return values: a chain and a flag result.
       The inputs are as follows:
          Operand #0 : Input chain.
          Operand #1 : a ExternalSymbolSDNode with a pointer to the asm string.
          Operand #2 : a MDNodeSDNode with the !srcloc metadata.
          Operand #3 : HasSideEffect, IsAlignStack bits.
        After this, it is followed by a list of operands with this format:
          ConstantSDNode: Flags that encode whether it is a mem or not, the
           list of operands that follow, etc.
          See InlineAsm.h. ... however many operands ...
            Operand #last: Optional, an incoming flag."
  */
  std::vector<SDValue> opsInline;

  // This generates either:
  //    - a glue edge/link if the return type is MVT::Glue
  //    - a chain edge/link if the return type is MVT::Other
  //    between the nodeSymImm and the INLINEASM node.
  if (specialCase) {
    // opsInline.push_back(CrtDAG->getEntryNode());
  } else {
    opsInline.push_back(SDValue(nodeSymImm, 0));
  }
  //
  opsInline.push_back(extSym); // SDValue(extSym, 0));

  /* Creating a null-MDNode MDNodeSDNode object.
       Inspiring from (since only SelectionDAG can call constructor)
    http://llvm.org/docs/doxygen/html/SelectionDAGNodes_8h_source.html:
    class MDNodeSDNode : public SDNode {
      const MDNode *MD;
      friend class SelectionDAG;
      explicit MDNodeSDNode(const MDNode *md)
      : SDNode(ISD::MDNODE_SDNODE, 0, DebugLoc(), getSDVTList(MVT::Other)),
        MD(md)
      {}
     See also, although not helpful,
          http://llvm.org/docs/doxygen/html/classllvm_1_1MDNodeSDNode.html .
  */
  /* Does NOT work: MDNodeSDNode mdNodeSDNode; // = MDNodeSDNode::getMD();
   is private: MDNodeSDNode::MDNodeSDNode(mdNode); */

  // Creating a NON-null-MDNode MDNodeSDNode object (has a
  //        hexadecimal value when outputing the DOT file).
  /* From
    http://llvm.org/docs/doxygen/html/classllvm_1_1MDNode.html:
    Detailed Description
      Metadata nodes can be uniqued, like constants, or distinct.
  */
  // Actually inspired from
  //  http://ftp.nchc.org.tw/NetBSD/NetBSD-current/src/external/bsd/llvm/
  //        dist/llvm/unittests/IR/MetadataTest.cpp
  // We use std::nullopt instead of llvm::None following
  //                https://github.com/root-project/root/issues/14205
  MDNode *mdNode = MDNode::get(*(CrtDAG->getContext()), std::nullopt);
  /*
  From http://llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html
     <<SDValue getMDNode (const MDNode *MD)
      Return an MDNodeSDNode which holds an MDNode.>>
  */
  SDNode *mdNodeSDNode = CrtDAG->getMDNode(mdNode).getNode();
  //
  /* Avoiding error -
       see Tests/DawnCC/30l_dotprod_f16/5/STDerr_llc_01_old03:
     << Assertion `Op.getValueType() != MVT::Other &&
        Op.getValueType() != MVT::Glue &&
        "Chain and glue operands should occur at end of operand list!"' failed.
  */
  if (specialCase == false) {
    opsInline.push_back(SDValue(mdNodeSDNode, 0));
  }

  /*
  From http://llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html
     <<SDValue getTargetConstant (uint64_t Val, SDLoc DL, EVT VT,
                                  bool isOpaque=false)>>
  */
  SDValue targetConstant = CrtDAG->getTargetConstant(1, DL, MVT::i64);
  SDNode *targetConstantSDNode = targetConstant.getNode();
  //
  opsInline.push_back(SDValue(targetConstantSDNode, 0));

  if (specialCase)
    opsInline.push_back(SDValue(nodeSymImm, 0));

  // Note that you can also look at the .dot file output
  //   from the LLVM I-sel stage to get an idea on how an
  //   INLINEASM node looks.

  // Related to CODE2018_07_01
  SDNode *inlineAsmNode;
  if (specialCase == true) {
    inlineAsmNode = CrtDAG->getMachineNode(
        Connex::INLINEASM, DL,
        // Result types:
        // CrtDAG->getVTList(TYPE_VECTOR_I16),
        CrtDAG->getVTList(MVT::Other, MVT::Glue), opsInline);
  } else {
    SDValue inlineAsm = CrtDAG->getNode(
        // We use this non-machine SDNode to avoid
        //  <<Assertion `!AnyNotSched' failed.>> e.g.
        //  in middle.block
        ISD::INLINEASM, DL,
        // Result types:
        // CrtDAG->getVTList(TYPE_VECTOR_I16),
        CrtDAG->getVTList(MVT::Other, MVT::Glue), opsInline);
    inlineAsmNode = inlineAsm.getNode();
  }

  LLVM_DEBUG(dbgs() << "CreateInlineAsmNode(): inlineAsmNode = ";
             inlineAsmNode->dump();
             // dbgs() << '\n'
  );

  return inlineAsmNode;
} // End CreateInlineAsmNode()

static SDValue ChangeVectorType(SDValue InOp, MVT NVT, SelectionDAG &DAG,
                                bool FillWithZeroes = false) {
  // Check if InOp already has the right width.
  MVT InVT = InOp.getSimpleValueType();
  if (InVT == NVT)
    return InOp;

  if (InOp.isUndef())
    return DAG.getUNDEF(NVT);

  unsigned InNumElts = InVT.getVectorNumElements();
  unsigned WidenNumElts = NVT.getVectorNumElements();
  /*
  assert(WidenNumElts > InNumElts && WidenNumElts % InNumElts == 0 &&
         "Unexpected request for vector widening");
  */
  assert(WidenNumElts == InNumElts && "WidenNumElts == InNumElts failed");

  EVT EltVT = NVT.getVectorElementType();

  SDLoc dl(InOp);
  if (InOp.getOpcode() == ISD::CONCAT_VECTORS && InOp.getNumOperands() == 2) {
    SDValue N1 = InOp.getOperand(1);
    if ((ISD::isBuildVectorAllZeros(N1.getNode()) && FillWithZeroes) ||
        N1.isUndef()) {
      InOp = InOp.getOperand(0);
      InVT = InOp.getSimpleValueType();
      InNumElts = InVT.getVectorNumElements();
    }
  }

  if (ISD::isBuildVectorOfConstantSDNodes(InOp.getNode()) ||
      ISD::isBuildVectorOfConstantFPSDNodes(InOp.getNode())) {
    SmallVector<SDValue, 128> Ops;
    for (unsigned i = 0; i < InNumElts; ++i) {
      // Ops.push_back(InOp.getOperand(i));
      Ops.push_back(InOp.getOperand(0));
    }

#if 0
    SDValue FillVal = FillWithZeroes ? DAG.getConstant(0, dl, EltVT) :
      DAG.getUNDEF(EltVT);
    for (unsigned i = 0; i < WidenNumElts - InNumElts; ++i)
      Ops.push_back(FillVal);
#endif
    SDValue res = DAG.getBuildVector(NVT, dl, Ops);

    LLVM_DEBUG(dbgs() << "Exiting ChangeVectorType() with: res = "
                      << res.getNode() << ".\n");

    return res;
  }

  assert(0 && "ChangeVectorType(): I guess this case should not be reached");
  SDValue FillVal =
      FillWithZeroes ? DAG.getConstant(0, dl, NVT) : DAG.getUNDEF(NVT);
  return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, NVT, FillVal, InOp,
                     DAG.getIntPtrConstant(0, dl));
}

void ConnexDAGToDAGISel::selectBUILD_VECTOR(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectBUILD_VECTOR().\n");

  // NEW32
  EVT typeVecNode;
  SDLoc DL(Node);

  BuildVectorSDNode *BVN = cast<BuildVectorSDNode>(Node);
  APInt SplatValue, SplatUndef;
  unsigned SplatBitSize;
  bool HasAnyUndefs;
  unsigned LdiOp;
  EVT ResTy = BVN->getValueType(0);
  EVT ViaVecTy;

  bool needsConversionToResultType = true;

  SDNode *Res;

  if (ResTy == TYPE_VECTOR_I32) {
    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR(): We are in the case TYPE_VECTOR_I32\n");
    /*
    TODO:
    Although so far we do not have a test for this case, in principle we
      should lower the following target-independent SDNode:
        BUILD_VECTOR i32ct
    to:
        R0 = 1;
        R1 = VLOAD i32ct_lower16bits;
        R2 = VLOAD i32ct_higher16bits;
        CELLSHR R2, R0;
        WHERE_EQ (INDEX & 1 == 1) // for all odd indices
          R1 = R2 | R2;
        END_WHERE;
    */
  } else if (ResTy == TYPE_VECTOR_I16) {
    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR(): We are in the case TYPE_VECTOR_I16\n");
  }
  typeVecNode = ResTy;

  /*
   From http://llvm.org/docs/doxygen/html/classllvm_1_1BuildVectorSDNode.html:
   bool isConstantSplat(APInt &SplatValue, APInt &SplatUndef,
                        unsigned &SplatBitSize, bool &HasAnyUndefs,
                        unsigned MinSplatBits=0, bool isBigEndian=false) const
      Check if this is a constant splat, and if so, find the smallest element
          size that splats the vector.

     By constant splat we understand a vector filled with the same
       constant value in all elements.
   */
  if (BVN->isConstantSplat(SplatValue, SplatUndef, SplatBitSize, HasAnyUndefs,
                           8, true) == false) {
    LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): "
                         "BVN->isConstantSplat() == false:\n");

    /* Checking if we have a symbolic splat.
     From
      http://llvm.org/docs/doxygen/html/classllvm_1_1BuildVectorSDNode.html:
      SDValue getSplatValue (BitVector *UndefElements=nullptr) const
        <<Returns the splatted value or a null value if this is not a splat.>>
     */
    SDValue symbolicValue = BVN->getSplatValue();
    LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): symbolicValue.getNode() = "
                      << symbolicValue.getNode() << "\n");

    // Inspired vaguely from
    //    http://llvm.org/docs/doxygen/html/SelectionDAGNodes_8h_source.html
    if (symbolicValue.getNode() != nullptr) {
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): symbolicValue = ";
                 symbolicValue->dump(); dbgs() << "\n");
      // LdiOp = Connex::VLOAD_H_STR;

      /* For the case BUILD_VECTOR is a variable splat
          (contains the same variable in all elements of the vector),
          we retrieve the C expression from the variable and generate
       an inlineasm with VLOAD variable_C_Expression (so this is OPINCAA host
       and Connex ASM code together). */

      /*
      From http://llvm.org/docs/doxygen/html/namespacellvm_1_1ISD.html:
        <<INLINEASM - Represents an inline asm block.
        This node always has two return values: a chain and a flag result.
        The inputs are as follows:
          Operand #0 : Input chain.
          Operand #1 : a ExternalSymbolSDNode with a pointer to the asm string.
          Operand #2 : a MDNodeSDNode with the !srcloc metadata.
          Operand #3 : HasSideEffect, IsAlignStack bits.
        After this, it is followed by a list of operands with this format:
        ConstantSDNode: Flags that encode whether it is a mem or not,
           the number of operands that follow, etc.
        See InlineAsm.h. ... however many operands ...
          Operand #last: Optional, an incoming flag.
        >>
      Also, ISD::INLINEASM accepts only objects of type ConstantSDNode
        from 2nd operand onwards - see InstrEmitter.cpp, line 966:
        unsigned Flags =
        cast<ConstantSDNode>(Node->getOperand(i))->getZExtValue();

      Examples of creating an INLINEASM SDNode, in llc:
          From llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,
               (or llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp) :

                if (Glue.getNode())
                  AsmNodeOperands.push_back(Glue);
                if (!Changed)
                  return false;

                SDValue New = CrtDAG->getNode(ISD::INLINEASM, SDLoc(N),
                    CrtDAG->getVTList(MVT::Other, MVT::Glue), AsmNodeOperands);
                New->setNodeId(-1);
                ReplaceNode(N, New.getNode());

          Less useful: From SelectionDAGISel.cpp:
              void SelectionDAGISel::Select_INLINEASM(SDNode *N) {
                SDLoc DL(N);

                std::vector<SDValue> Ops(N->op_begin(), N->op_end());
                SelectInlineAsmMemoryOperands(Ops, DL);

                const EVT VTs[] = {MVT::Other, MVT::Glue};
                SDValue New = CrtDAG->getNode(ISD::INLINEASM, DL, VTs, Ops);
                New->setNodeId(-1);
                ReplaceUses(N, New.getNode());
                CrtDAG->RemoveDeadNode(N);
              }

          From SelectionDAGBuilder.cpp:
            Chain = DAG.getNode(ISD::INLINEASM, getCurSDLoc(),
                                DAG.getVTList(MVT::Other, MVT::Glue),
                                AsmNodeOperands);

      LESS relevant note: to create an InlineAsm Value in the LLVM program,
        in clang/opt, we can use the API described at:
          http://llvm.org/docs/doxygen/html/classllvm_1_1InlineAsm.html
          http://llvm.org/docs/doxygen/html/InlineAsm_8h_source.html
          http://llvm.org/docs/doxygen/html/InlineAsm_8cpp_source.html
      */

      SDValue InFlag(nullptr, 0); // NO Glue - Null incoming flag value.
      // Inspired from ConnexISelLowering.cpp
      MachineFunction &MF = CrtDAG->getMachineFunction();
      MachineRegisterInfo &RegInfo = MF.getRegInfo();
      /* From http://llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html
      SDValue SelectionDAG::getBasicBlock(MachineBasicBlock *MBB);
      // SDValue bb = CrtDAG->getBasicBlock(MachineBasicBlock *MBB);
      */

      SDNode *firstAsmInlineSDNode = NULL;
      for (auto dagIter = CrtDAG->allnodes_begin(); // allnodes_iterator
           dagIter != CrtDAG->allnodes_end(); dagIter++) {
        SDNode iterSDNode = *dagIter;
        /*
        LLVM_DEBUG(dbgs() << "dagIter = ";
                                iterSDNode.dump(CrtDAG);
                                dbgs() << '\n');
        */
        if (iterSDNode.getOpcode() == ISD::INLINEASM) {
          firstAsmInlineSDNode = &iterSDNode;
          break;
        }
      }

      // Using the MDNode - because Inline gives error:
      // firstAsmInlineSDNode = (firstAsmInlineSDNode->getOperand(2)).getNode();

      if (firstAsmInlineSDNode == NULL)
        firstAsmInlineSDNode = (CrtDAG->getEntryNode()).getNode();
      LLVM_DEBUG(dbgs() << "firstAsmInlineSDNode = " << firstAsmInlineSDNode
                        << "\n");
      LLVM_DEBUG(dbgs() << "firstAsmInlineSDNode = ";
                 firstAsmInlineSDNode->dump(); dbgs() << "[END]\n");

      SDValue firstAsmInlineSDValue = SDValue(firstAsmInlineSDNode, 0);
      LLVM_DEBUG(dbgs() << "firstAsmInlineSDValue = ";
                 firstAsmInlineSDValue->dump(); dbgs() << "[END]\n");

      /* TODO: Treat preoperly case
         typeVecNode == TYPE_VECTOR_I32.
         I.e., with multiple VLOAD_H, CELL_SH*, WHERE*, etc */

      SDNode *vloadSpecial = CrtDAG->getMachineNode(
          typeVecNode == TYPE_VECTOR_I16 ? Connex::VLOAD_H_SYM_IMM :
                                         // Connex::VLOAD_W_SYM_IMM,
              Connex::VLOAD_H_SYM_IMM,
          DL,
          //
          // We add MVT::Glue to the return
          // types to avoid that llc performs CSE
          // on these nodes: if this getMachineNode()
          // function is called more than once we
          // return the same value again and again
          // (i.e., perform CSE) since the node doesn't
          // take any actual inputs.
          // - see why this is so at
          //  llvm.org/docs/doxygen/html/SelectionDAG_8cpp_source.html
          CrtDAG->getVTList(
              // typeVecNode,
              TYPE_VECTOR_I16, MVT::Glue),
          //
          CrtDAG->getEntryNode()
          // We add a chain edge
          /* TODO Very Important - figure if
           I can do this better
           (maybe in Selection Lowering):
          //SDValue(firstAsmInlineSDNode, 0)
           firstAsmInlineSDValue */
          // SDValue(copyToRegAux, 0),
          // copyToRegAux
          /*
          Gives error: InstrEmitter.cpp:782:
          void llvm::InstrEmitter::EmitMachineNode(
          llvm::SDNode*, bool, bool,
          llvm::DenseMap<llvm::SDValue, unsigned int>&):
          Assertion `NumMIOperands >= II.getNumOperands()
          && NumMIOperands <= II.getNumOperands() +
          II.getNumImplicitDefs() + NumImpUses &&
          "#operands for dag node doesn't match
           .td file!"' failed.
          */
          // Node->getOperand(0)
      );
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): vloadSpecial = "
                        << vloadSpecial << ".\n"
                        << "vloadSpecial = ";
                 vloadSpecial->dump(); dbgs() << "\n");

      std::string exprStr = "1"; // This is Wrong - we just put an incorrect
                                 //     value MEGA-TODO(2021_02_02): see below
      /*
      // MEGA-TODO(2021_02_02):
      std::string exprStr = recoverCExpressionFromSDNode(Node, crtNodeMap,
                                                         true
                                                         );
      */

      // std::string exprStr = recoverCExpressionFromSDNode(
      //                                symbolicValue.getNode(), crtNodeMap);
      exprStr = "    " + exprStr;
      exprStr = exprStr + "; // MSA_I16";
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): exprStr = " << exprStr
                        << "\n");

      SDNode *inlineAsmNode =
          CreateInlineAsmNode(CrtDAG, exprStr, vloadSpecial, DL);

      // Very Important:
      // You might wonder why we require creating also
      //      SDNodes CopyToReg and CopyFromReg.
      // We put them to preserve the INLINEASM SDNode, which does NOT
      //   have a type and needs to be chained/glued to its VLOAD* and
      //   the result (Res) from this instr-selection needs to be
      //   a vector type (typeVecNode).
      // If we don't put them (e.g., we make
      //      Res = inlineAsmNode;
      //   we end up with erroneous cases like this
      //     (which gives an assertion failure like:
      //          "#operands for dag node doesn't match .td file!"):
      //   SU(10): t71: v128i16,glue = VLOAD_H_SYM_IMM t0
      //   SU(9): t74: ch,glue = inlineasm t71,
      //          TargetExternalSymbol:i64'    ((N +  -1) <<  1)) +  2) /
      //          (((int *)&CONNEX_VL)[0])) ...;
      //          // MSA_I10', MDNode:ch<0x1724220>, TargetConstant:i64<1>
      //   SU(8): t75: v64i32 = NOP_BITCONVERT_WH t74
      unsigned virtRegRes = RegInfo.createVirtualRegister(
          typeVecNode == TYPE_VECTOR_I16 ? &Connex::VectorHRegClass
                                         : &Connex::VectorHRegClass);

      // From http://llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html:
      // SDValue getCopyFromReg(SDValue Chain, SDLoc dl, unsigned Reg, EVT VT)
      // SDValue getCopyFromReg(SDValue Chain, SDLoc dl, unsigned Reg, EVT VT,
      //                                                           SDValue Glue)
      //
      // SDValue getCopyToReg (SDValue Chain, SDLoc dl, unsigned Reg, SDValue N)
      // SDValue getCopyToReg (SDValue Chain, SDLoc dl, unsigned Reg, SDValue N,
      //                       SDValue Glue)
      // SDValue getCopyToReg (SDValue Chain, SDLoc dl, SDValue Reg, SDValue N,
      //                       SDValue Glue)
      SDValue copyToRegRes = CrtDAG->getCopyToReg(
          // CrtDAG->getEntryNode(),
          // messes up scheduling
          // SDValue(vloadSpecial, 0),
          // this should be considered chain
          //  edge, even if VLOAD does NOT have
          // output ch port
          SDValue(inlineAsmNode, 0),
          // extSym,

          DL, virtRegRes, SDValue(vloadSpecial, 0), InFlag);

      SDValue copyFromRegRes =
          CrtDAG->getCopyFromReg(copyToRegRes, // chain
                                 DL, virtRegRes, typeVecNode
                                 //, copyToRegOp2
          );

      /*
      From http://llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html:
         SDValue  getRegister (unsigned Reg, EVT VT)
      */
      // Res = CrtDAG->getRegister(virtRegRes, TYPE_VECTOR_I16).getNode();
      Res = copyFromRegRes.getNode();

      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): Res = "; Res->dump();
                 dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): inlineAsmNode = ";
                 inlineAsmNode->dump(); dbgs() << "\n");

      /* TODO: Make sure I am not deleting an SDNode nc
       incoming on the chain port of Node, where nc is an arbitrary
       node which happened to be before Node. */
      // ReplaceNode(Node, Res);
      // return;

      needsConversionToResultType = false;
    } // End symbolicValue.getNode() != nullptr
    else {
      bool isUnitStepped = isUnitSteppedZeroStartingVector(BVN);
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): isUnitStepped = true\n");

      if (isUnitStepped) {
        LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): isUnitStepped = true\n");
        /*
        LLVM_DEBUG(dbgs() << "Select() for ISD::BUILD_VECTOR: Res = ";
                   Res->print(dbgs()); dbgs() << "\n");
        */

        LdiOp = Connex::LDIX_H;

        ViaVecTy = TYPE_VECTOR_I16;
        /*
        // return std::make_pair(false, nullptr);
        LLVM_DEBUG(
          dbgs() << "Select() for ISD::BUILD_VECTOR: exiting with 1st return"
                    "nullptr\n");

        return;
        */

        /* Important: We use Connex's LDIX (LDIX_H) instruction
           to load the immediate value Imm in all vector elements. */
        Res = CrtDAG->getMachineNode(LdiOp, DL, ViaVecTy);

        if (ResTy != ViaVecTy) {
          // If LdiOp is writing to a different register class to ResTy, then
          // fix it up here. This COPY_TO_REGCLASS should never cause a move.v
          // since the source and destination register sets contain the same
          // registers.
          const TargetLowering *TLI = getTargetLowering();
          MVT ResTySimple = ResTy.getSimpleVT();
          const TargetRegisterClass *RC = TLI->getRegClassFor(ResTySimple);

          LLVM_DEBUG(
              dbgs()
              << "selectBUILD_VECTOR(): before CrtDAG->getMachineNode()\n");
          Res = CrtDAG->getMachineNode(
              Connex::COPY_TO_REGCLASS, DL, ResTy, SDValue(Res, 0),
              CrtDAG->getTargetConstant(RC->getID(), DL,
                                        // TODO_CHANGE_BACKEND:
                                        // MVT::i64));
                                        TYPE_SCALAR_ELEMENT));
        }
      }
    }
  } // End BVN->isConstantSplat == false
  else {
    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR(): BVN->isConstantSplat() == true, "
               << "SplatValue = " << SplatValue << ", SplatUndef = "
               << SplatUndef << ", SplatBitSize = " << SplatBitSize << "\n");

    // TODO_CHANGE_BACKEND:
    // if (SplatBitSize == 8 || SplatBitSize == 16 || SplatBitSize == 32)
    if (SplatBitSize != TYPE_VECTOR_I16_ELEMENT_BITSIZE) {
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): SplatBitSize == "
                        << SplatBitSize
                        << "(8 is NOT supported in our back end)\n");
      // Important-TODO: kindda wicked hack - try to avoid by working
      //   defining in TableGen the right conversion records
      // TODO_CHANGE_BACKEND:
      SplatBitSize = 16;
      // SplatBitSize = 32;
      // SplatBitSize = 64;

      LLVM_DEBUG(
          dbgs() << "        --> Extending element type to SplatBitSize = "
                 << SplatBitSize << "\n");

      // See http://llvm.org/docs/doxygen/html/classllvm_1_1APInt.html
      llvm::SmallVector<char, 5> splatValueStr;
      SplatValue.toString(splatValueStr, 10, 1);
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR: SplatValue = " << splatValueStr
                        << "\n");
      LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR: SplatValue.getBitWidth() = "
                        << SplatValue.getBitWidth() << "\n");

      // TODO This should be performed through TableGen
      // if (SplatBitSize > SplatValue.getBitWidth())
      // See  http://llvm.org/docs/doxygen/html/classllvm_1_1APInt.html
      SplatValue = SplatValue.zextOrTrunc(SplatBitSize);

      LLVM_DEBUG(dbgs() << "Select() for ISD::BUILD_VECTOR: After, "
                           "SplatValue.getBitWidth() = "
                        << SplatValue.getBitWidth() << "\n");
    }

    llvm::SmallVector<char, 5> splatUndefStr;
    SplatUndef.toString(splatUndefStr, 10, 1);
    LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR: SplatUndef = " << splatUndefStr
                      << "\n");
    LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR: SplatBitSize = " << SplatBitSize
                      << "\n");

    /* TODO: VLOAD is NOT a feasible option if BUILD_VECTOR is loaded
     with DIFFERENT constant values. */

    switch (SplatBitSize) {
    default:
      // return std::make_pair(false, nullptr);
      LLVM_DEBUG(
          dbgs() << "selectBUILD_VECTOR: exiting with 2nd return nullptr\n");
      return;
    case 8:
      // LdiOp = Connex::VLOAD_B;
      LdiOp = Connex::VLOAD_H;
      // TODO_CHANGE_BACKEND:
      // ViaVecTy = MVT::v16i8;
      // ViaVecTy = MVT::v16i32;
      ViaVecTy = TYPE_VECTOR_I16;
      /*
      LdiOp = Connex::VLOAD_H;
      ViaVecTy = MVT::v8i64;
      */
      break;
    case 16:
      LdiOp = Connex::VLOAD_H;
      // TODO_CHANGE_BACKEND:
      ViaVecTy = TYPE_VECTOR_I16;
      break;
    case 32:
      // TODO_CHANGE_BACKEND:
      // TODO: We should add also WHERE and vload depending on index
      LdiOp = Connex::VLOAD_H;
      ViaVecTy = TYPE_VECTOR_I16;
      /*
      LdiOp = Connex::VLOAD_W;
      ViaVecTy = TYPE_VECTOR_I32; */
      break;
    case 64:
      assert(0 && "Connex supports only 16 bits"
                  "immediate operands - see ConnexISA.docx");
      LdiOp = Connex::VLOAD_W; // TODO: actually VLOAD_D
      // TODO_CHANGE_BACKEND:
      // ViaVecTy = MVT::v8i64;
      ViaVecTy = TYPE_VECTOR_I16;
      break;
      /*
      LdiOp = Connex::VLOAD_H; //VLOAD:
      ViaVecTy = MVT::v8i64;
      break;
      */
    }

    /*
    From http://llvm.org/docs/doxygen/html/APInt_8h_source.html:
        bool isSignedIntN(unsigned N) const
        Check if this APInt has an N-bits signed integer value.
    */
    if (!SplatValue.isSignedIntN(16)) {
      // return std::make_pair(false, nullptr);
      LLVM_DEBUG(
          dbgs() << "selectBUILD_VECTOR: exiting via 3rd return nullptr\n");

      return;
    }
    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR: SplatValue.isSignedIntN(16) == true\n");

    llvm::SmallVector<char, 5> splatValueStr;
    SplatValue.toString(splatValueStr, 10, 1);
    LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR: SplatValue = " << splatValueStr
                      << "\n");

    // See http://llvm.org/docs/doxygen/html/structllvm_1_1EVT.html
    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR: ViaVecTy.getVectorElementType() = "
               << ViaVecTy.getVectorElementType().getEVTString() << "\n");

    // See http://llvm.org/docs/doxygen/html/classllvm_1_1SDLoc.html and
    //    http://llvm.org/docs/doxygen/html/classllvm_1_1DebugLoc.html
    // LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR: DL = "
    //                   << DL.getDebugLoc().getLoc() << "\n");

    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR: before CrtDAG->getTargetConstant()\n");
    SDValue Imm = CrtDAG->getTargetConstant(SplatValue, DL,
                                            ViaVecTy.getVectorElementType());
    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR: after CrtDAG->getTargetConstant()\n");
    // See http://llvm.org/docs/doxygen/html/classllvm_1_1SDValue.html
    LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR: Imm = "; Imm.dump();
               dbgs() << "\n");

    /* Important: if we got this far then we use Connex's VLOAD (VLOAD_H)
      instruction to load the immediate value Imm in all vector elements. */
    Res = CrtDAG->getMachineNode(LdiOp, DL, ViaVecTy, Imm);

    // It doesn't make sense to use target independent BITCAST
    /*
    Res = CrtDAG->getMachineNode(ISD::BITCAST, DL,
                                  typeVecNode, SDValue(Res2, 0));
    */
  }

  if (ResTy == TYPE_VECTOR_I32 && needsConversionToResultType) {
    LLVM_DEBUG(
        dbgs() << "selectBUILD_VECTOR(): Adding NOP_BITCONVERT_HW node\n");

    SDNode *ResOrig = Res;
    Res = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL, typeVecNode,
                                 SDValue(ResOrig, 0));
  }

  /*
  return std::make_pair(true, Res);
  */
  LLVM_DEBUG(dbgs() << "selectBUILD_VECTOR(): Res = ";
             /* print() gives "Segmentation fault" when BUILD_VECTOR
              contains vars Res->print(dbgs()); dbgs() << "\n"); */
             Res->dump(CrtDAG); dbgs() << "\n");

  ReplaceNode(Node, Res);
} // End selectBUILD_VECTOR()

SDNode *ConnexDAGToDAGISel::selectReduceI32(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectReduceI32(): Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(
      dbgs() << "selectReduceI32(): We are in the case TYPE_VECTOR_I32\n");
  typeVecNode = TYPE_VECTOR_I32;

  // NOTE: Opnd 1 is a ct
  SDValue nodeOpSrc = Node->getOperand(2);

  // We need to preserve the node that was chained with Node to avoid
  //     it is removed
  SDValue nodeOpChain = Node->getOperand(0); // Opnd 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectReduceI32(): nodeOpSrc.getValueType() = "
                    << nodeOpSrc.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectReduceI32(): nodeOpSrc = ";
             (nodeOpSrc.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_I32);

#ifdef MARKER_FOR_EMULATION
  SDNode *nodeOpSrcCastBogus = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, MVT::Other,
      // This gives error: MVT::Glue,
      nodeOpSrc,
      // chain edge
      nodeOpChain);

  std::string exprStrBegin = "// Starting RED.i32 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCastBogus, DL);
  LLVM_DEBUG(dbgs() << "selectReduceI32: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");

  /* This node is also bogus, only for the sake of "sandwhiching"
      the INLINE assembly with 2 NOPs.
  */
  SDNode *nodeOpSrcCast = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_HH, DL, TYPE_VECTOR_I16, MVT::Other,
      /* Important: this can give
         error:
      <<Assertion
       `N->getNodeId() == -1
        &&
       "Node already inserted!">>
       MVT::Glue,
      */
      SDValue(nodeOpSrcCastBogus, 0),
      // chain
      SDValue(inlineAsmNodeBegin, 0));
#else
  SDNode *nodeOpSrcCast = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, MVT::Glue, nodeOpSrc,
      // chain edge
      nodeOpChain);
#endif

#include "Select_REDi32_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing RED.i32 emulation ;)";

  /*
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 reduceHigh16, DL);
  LLVM_DEBUG(dbgs() << "selectReduceI32(): inlineAsmNodeEnd = ";
                inlineAsmNodeEnd->dump(); dbgs() << "\n");

  LLVM_DEBUG(dbgs() << "selectReduceI32(): reduceHigh16 = ";
                    reduceHigh16->dump(CrtDAG); dbgs() << "\n");
  // return inlineAsmNodeEnd;
    // Gives error: <<SelectionDAG.cpp:6421:
    // void llvm::SelectionDAG::ReplaceAllUsesWith(llvm::SDNode*,
    // llvm::SDNode*): Assertion `(!From->hasAnyUseOfValue(i) ||
    // From->getValueType(i) == To->getValueType(i)) &&
    // "Cannot use this version of ReplaceAllUsesWith!"' failed.>>
  */

  SDNode *resHH = CreateInlineAsmNode(CrtDAG, exprStrEnd, reduceHigh16, DL);

  /*
  // This node is also bogus, only for the sake of "sandwhiching" the INLINE
  //   assembly with 2 instructions.
  SDNode *resHH = CrtDAG->getMachineNode(
    Connex::NOP_BITCONVERT_HH,
    DL,
    // Gives error: <<void llvm::SelectionDAG::ReplaceAllUsesWith(llvm::SDNode*,
    //   llvm::SDNode*): Assertion `(!From->hasAnyUseOfValue(i) ||
    //   From->getValueType(i) == To->getValueType(i)) &&
    //   "Cannot use this version of ReplaceAllUsesWith!"' failed.>>
    //     TYPE_VECTOR_I16,
    // Gives error: <<Assertion `NumMIOperands >= II.getNumOperands() &&
    //   NumMIOperands <= II.getNumOperands() + II.getNumImplicitDefs() +
    //   NumImpUses &&
    //   "#operands for dag node doesn't match .td file!"' failed.>> MVT::Other,
    SDValue(reduceHigh16, 0),
    // chain edge
    //SDValue(resH, 1)
    SDValue(inlineAsmNodeEnd, 0)
  );
  */
  LLVM_DEBUG(dbgs() << "selectReduceI32(): resHH = "; resHH->dump(CrtDAG);
             dbgs() << "\n");

  return resHH;
#else
  LLVM_DEBUG(dbgs() << "selectReduceI32(): reduceHigh16 = ";
             reduceHigh16->dump(CrtDAG); dbgs() << "\n");

  return reduceHigh16;
#endif
} // End selectReduceI32()

SDNode *ConnexDAGToDAGISel::selectReduceF16(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectReduceF16(): Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(
      dbgs() << "selectReduceF16(): We are in the case TYPE_VECTOR_F16\n");
  typeVecNode = TYPE_VECTOR_F16;

  // NOTE: Opnd 1 is a ct
  SDValue nodeOpSrc = Node->getOperand(2);

  // We need to preserve the node that was chained with Node to avoid
  //   it is removed.
  SDValue nodeOpChain = Node->getOperand(0); // Opnd 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectReduceF16(): nodeOpSrc.getValueType() = "
                    << nodeOpSrc.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectReduceF16(): nodeOpSrc = ";
             (nodeOpSrc.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_F16);

#ifdef MARKER_FOR_EMULATION
  SDNode *nodeOpSrcCastBogus1 = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_HH, DL, TYPE_VECTOR_I16, MVT::Other,
      // This gives error: MVT::Glue,
      nodeOpSrc,
      // chain edge
      nodeOpChain);

  std::string exprStrBegin = "// Starting red.f16 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCastBogus1, DL);
  LLVM_DEBUG(dbgs() << "selectReduceF16: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");

  /* This node is also bogus, only for the sake of "sandwhiching" the INLINE
     assembly with 2 NOPs. */
  SDNode *nodeOpSrcCast =
      CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HH,
                             // Important: this is a BOGUS
                             // NOP_BITCONVERT - we just put
                             // it since it has a Glue result
                             // while nodeOpSrcCast2 does NOT
                             DL, TYPE_VECTOR_I16, MVT::Other,
                             // Important: this gives error:
                             // <<Assertion `N->getNodeId()
                             // == -1 &&
                             // "Node already inserted!">>
                             // MVT::Glue,
                             SDValue(nodeOpSrcCastBogus1, 0),
                             // chain
                             SDValue(inlineAsmNodeBegin, 0));
#else
  SDNode *nodeOpSrcCast = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_HH, DL, TYPE_VECTOR_I16, MVT::Glue, nodeOpSrc,
      // chain edge
      nodeOpChain);
#endif

#include "Select_REDf16_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing red.f16 emulation ;)";
  /*
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 reduceH, DL);
  LLVM_DEBUG(dbgs() << "selectReduceF16(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
  */
  SDNode *reduceHH = CreateInlineAsmNode(CrtDAG, exprStrEnd, reduceH, DL);

  LLVM_DEBUG(dbgs() << "SelectReduceF16(): reduceH = "; reduceH->dump(CrtDAG);
             dbgs() << "\n");
  // return inlineAsmNodeEnd;
  //  Gives error: <<SelectionDAG.cpp:6421:
  //  void llvm::SelectionDAG::ReplaceAllUsesWith(llvm::SDNode*, llvm::SDNode*):
  //   Assertion `(!From->hasAnyUseOfValue(i) || From->getValueType(i) ==
  //   To->getValueType(i)) && "Cannot use this version of ReplaceAllUsesWith!"'
  //   failed.>>

  /*
  // This node is also bogus, only for the sake of "sandwhiching" the INLINE
  // assembly with 2 instructions.
  SDNode *reduceHH = CrtDAG->getMachineNode(
    Connex::NOP_BITCONVERT_HH,
    DL,
    // Gives error: <<void llvm::SelectionDAG::ReplaceAllUsesWith(llvm::SDNode*,
    //   llvm::SDNode*): Assertion `(!From->hasAnyUseOfValue(i) ||
    //   From->getValueType(i) == To->getValueType(i)) &&
    //   "Cannot use this version of ReplaceAllUsesWith!"' failed.>>
    //  TYPE_VECTOR_I16,
    // Gives error: <<Assertion `NumMIOperands >= II.getNumOperands() &&
    //   NumMIOperands <= II.getNumOperands() + II.getNumImplicitDefs() +
    //   NumImpUses && "#operands for dag node doesn't match .td file!"'
    //   failed.>>
    //   MVT::Other,
    SDValue(reduceH, 0),
    // chain edge
    //SDValue(reduceH, 1)
    SDValue(inlineAsmNodeEnd, 0)
  );
  */
  LLVM_DEBUG(dbgs() << "selectReduceF16(): reduceHH = "; reduceHH->dump(CrtDAG);
             dbgs() << "\n");

  return reduceHH;
#else
  LLVM_DEBUG(dbgs() << "selectReduceF16(): reduceH = "; reduceH->dump(CrtDAG);
             dbgs() << "\n");

  return reduceH;
#endif
} // End selectReduceF16()

SDNode *ConnexDAGToDAGISel::selectAddI32(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectAddI32(): Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  /* We look into doing "instruction-select" to
    OpDst = ADD OpSRC1, OpSRC2
  where the 3 operands are vectors of type <VFxi32>: */

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectAddI32(): We are in the case TYPE_VECTOR_I32\n");
  typeVecNode = TYPE_VECTOR_I32;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectAddI32(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectAddI32(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectAddI32(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectAddI32(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_I32);

  /*
  Very Important:
   We convert the v4i32 add operation into a sequence of nodes that take as
     input the v4i32 operands of the operation convert them to v8i16 operands
     using the NOP_BITCONVERT_WH nodes and then instantiating the SDNodes
     emulating the v4i32 add operation.
    At the end we put a NOP_BITCONVERT_HW SDNode converting the result from
      v8i16 to v4i32.
    Note that these NOP_BITCONVERT_* nodes are more helpful conceptually - but
      they also keep the nodes s.t. they are not scheduled badly.
  */

  SDNode *nodeOpSrcCast1 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16,
                                                  // MVT::Other,
                                                  MVT::Glue, nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting ADD.i32 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectAddI32: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16, MVT::Other,
                                                  // Important: it gives error:
                                                  // <<Assertion `N->getNodeId()
                                                  //  == -1 &&
                                                  // "Node already inserted!">>
                                                  // MVT::Glue,
                                                  nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
                                                  SDValue(inlineAsmNodeBegin, 0)
#else
                                                  SDValue(nodeOpSrcCast1, 1)
#endif
  );

#include "Select_ADDi32_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing ADD.i32 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resH,
                                                 DL);
  LLVM_DEBUG(dbgs() << "selectAddI32(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");

  LLVM_DEBUG(dbgs() << "selectAddI32(): resH = "; resH->dump(CrtDAG);
             dbgs() << "\n");
  // return inlineAsmNodeEnd;
  //  Gives error: <<SelectionDAG.cpp:6421:
  // void llvm::SelectionDAG::ReplaceAllUsesWith(llvm::SDNode*, llvm::SDNode*):
  // Assertion `(!From->hasAnyUseOfValue(i) ||
  // From->getValueType(i) == To->getValueType(i)) &&
  // "Cannot use this version of ReplaceAllUsesWith!"' failed.>>
#endif

  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resH, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
                                        SDValue(resH, 1)
#endif
  );
  LLVM_DEBUG(dbgs() << "selectAddI32(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectAddI32()

SDNode *ConnexDAGToDAGISel::selectAbsI32(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectAbsI32(): Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  /* We look into doing "instruction-select" to
    OpDst = ABS.i32 OpSRC1, OpSRC2
  where the 3 operands are vectors of type <VFxi32>: */

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectAbsI32(): We are in the case TYPE_VECTOR_I32\n");
  typeVecNode = TYPE_VECTOR_I32;

  SDValue nodeOpSrc1 = Node->getOperand(0);

  LLVM_DEBUG(dbgs() << "selectAbsI32(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectAbsI32(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_I32);

  /*
  Very Important:
   We convert the v4i32 add operation into a sequence of nodes that take as
     input the v4i32 operands of the operation convert them to v8i16 operands
     using the NOP_BITCONVERT_WH nodes and then instantiating the SDNodes
     emulating the v4i32 add operation.
    At the end we put a NOP_BITCONVERT_HW SDNode converting the result from
      v8i16 to v4i32.
    Note that these NOP_BITCONVERT_* nodes are more helpful conceptually - but
      they also keep the nodes s.t. they are not scheduled badly.
  */

#ifdef MARKER_FOR_EMULATION
  SDNode *nodeOpSrcCastBogus = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, MVT::Other,
      // This gives error: MVT::Glue,
      nodeOpSrc1
      // chain edge
      // nodeOpChain
  );

  std::string exprStrBegin = "// Starting ABS.i32 emulation ;)";
  SDNode *inlineAsmNodeBegin = CreateInlineAsmNode(CrtDAG, exprStrBegin,
                                                   // nodeOpSrcCast1, DL);
                                                   nodeOpSrcCastBogus, DL);
  LLVM_DEBUG(dbgs() << "selectAbsI32: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");

  /* This node is also bogus, only for the sake of "sandwhiching"
      the INLINE assembly with 2 NOPs. */
  SDNode *nodeOpSrcCast = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_HH, DL, TYPE_VECTOR_I16, MVT::Other,
      // Important: this gives error:
      // <<Assertion
      //  `N->getNodeId() == -1 &&
      //  "Node already inserted!">>
      //  MVT::Glue,
      SDValue(nodeOpSrcCastBogus, 0),
      // chain
      SDValue(inlineAsmNodeBegin, 0));
#endif

#include "Select_ABSi32_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing ABS.i32 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resH,
                                                 DL);
  LLVM_DEBUG(dbgs() << "selectAbsI32(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");

  LLVM_DEBUG(dbgs() << "selectAbsI32(): resH = "; resH->dump(CrtDAG);
             dbgs() << "\n");
  // return inlineAsmNodeEnd;
  //   Gives error: <<SelectionDAG.cpp:6421: void llvm::SelectionDAG::
  //   ReplaceAllUsesWith(llvm::SDNode*, llvm::SDNode*):
  //   Assertion `(!From->hasAnyUseOfValue(i) ||
  //   From->getValueType(i) == To->getValueType(i)) &&
  //   "Cannot use this version of ReplaceAllUsesWith!"' failed.>>
#endif

  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resH, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
                                        SDValue(resH, 1)
#endif
  );
  LLVM_DEBUG(dbgs() << "selectAbsI32(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectAbsI32()

SDNode *ConnexDAGToDAGISel::selectSubI32(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectSubI32(): Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectSubI32(): We are in the case TYPE_VECTOR_I32\n");
  typeVecNode = TYPE_VECTOR_I32;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectSubI32(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectSubI32(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectSubI32(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectSubI32(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_I32);

  SDNode *nodeOpSrcCast1 =
      CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16,
                             // MVT::Other,
                             MVT::Glue, nodeOpSrc1);
  //
  std::string exprStrBegin = "// Starting SUB.i32 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "Select() for SUB.i32: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
  //
  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, MVT::Other,
      // Important: it gives error:
      // <<Assertion
      //  `N->getNodeId() == -1 &&
      // "Node already inserted!">>
      //  MVT::Glue,
      nodeOpSrc2,
      // chain
      // SDValue(nodeOpSrcCast1, 1)
      SDValue(inlineAsmNodeBegin, 0));

#include "Select_SUBi32_OpincaaCodeGen.h"

  std::string exprStrEnd = "// Finishing SUB.i32 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resH,
                                                 DL);
  LLVM_DEBUG(dbgs() << "selectSubI32(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");

  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resH, 0),
                                        // chain edge
                                        // SDValue(resH, 1)
                                        SDValue(inlineAsmNodeEnd, 0));
  LLVM_DEBUG(dbgs() << "selectSubI32(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectSubI32()

SDNode *ConnexDAGToDAGISel::selectMulI32(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectMulI32(): [LATEST] Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectMulI32(): We are in the case TYPE_VECTOR_I32\n");
  typeVecNode = TYPE_VECTOR_I32;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectMulI32(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectMulI32(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectMulI32(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectMulI32(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_I32);

  SDNode *nodeOpSrcCast1 =
      CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
                             MVT::Other,
#else
                             MVT::Glue,
#endif
                             nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting MUL.i32 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectMulI32: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  TYPE_VECTOR_I16, MVT::Other,
                                                  // Important:this gives error:
                                                  //  <<Assertion
                                                  //   `N->getNodeId() == -1 &&
                                                  //  "Node already inserted!">>
                                                  //  MVT::Glue,
                                                  nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
                                                  SDValue(inlineAsmNodeBegin, 0)
#else
                                                  SDValue(nodeOpSrcCast1, 1)
#endif
  );

  // Note: COPY generated by TwoAddressInctruction in WHERE blocks and handled
  // by me in ConnexTargetMachine.cpp, etc.

//#include "Select_MULTi32_SignAndMagnitude_OpincaaCodeGen.h"
#include "Select_MULTi32_ComplementedRepresentation_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing MUL.i32 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resH,
                                                 DL);
  LLVM_DEBUG(dbgs() << "selectMulI32(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
#endif

  // End of method - we convert resH (vector of i16) to resW (vector of i32)
  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resH, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
                                        SDValue(resH, 1)
#endif
  );
  LLVM_DEBUG(dbgs() << "selectMulI32(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectMulI32()

SDNode *ConnexDAGToDAGISel::selectSraI32(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectSraI32(): [LATEST] Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectSraI32(): We are in the case TYPE_VECTOR_I32\n");
  typeVecNode = TYPE_VECTOR_I32;

  SDValue nodeOp0 = Node->getOperand(0);
  SDValue nodeOp1 = Node->getOperand(1);

  SDNode *nodeOpSrcCast1 =
      CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
                             MVT::Other,
#else
                             MVT::Glue,
#endif
                             nodeOp0);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting SHRA.i32 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectSraI32(): inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(
      Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, MVT::Other,
      // Important: this can give error:
      //  <<Assertion
      //    `N->getNodeId() == -1 &&
      //    "Node already inserted!">>
      // MVT::Glue,
      nodeOp1,
  // chain
#ifdef MARKER_FOR_EMULATION
      SDValue(inlineAsmNodeBegin, 0)
#else
      SDValue(nodeOpSrcCast1, 1)
#endif
  );

#include "Select_SHRAi32_OpincaaCodeGen.h"

  LLVM_DEBUG(dbgs() << "selectSraI32(): resH = "; resH->dump(CrtDAG);
             dbgs() << "\n");

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing SHRA.i32 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resH,
                                                 DL);
  LLVM_DEBUG(dbgs() << "selectSraI32(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
#endif

  // End of method - we convert resH (vector of i16) to resW (vector of i32)
  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resH, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
                                        SDValue(resH, 1)
#endif
  );

  LLVM_DEBUG(dbgs() << "selectSraI32(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectSraI32()

SDNode *ConnexDAGToDAGISel::selectAddF16(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectAddF16(): [LATEST] Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectAddF16(): We are in the case TYPE_VECTOR_F16\n");
  typeVecNode = TYPE_VECTOR_F16;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectAddF16(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectAddF16(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectAddF16(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectAddF16(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_F16);

  SDNode *nodeOpSrcCast1 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
                                                  MVT::Other,
  // It gives error: MVT::Glue,
#else
                                                  MVT::Glue,
#endif
                                                  nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting add.f16 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectAddF16: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16, MVT::Other,
                                                  // Important: it gives error:
                                                  //  <<Assertion
                                                  //    `N->getNodeId() == -1 &&
                                                  // "Node already inserted!">>
                                                  //  MVT::Glue,
                                                  nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
                                                  SDValue(inlineAsmNodeBegin, 0)
#else
                                                  SDValue(nodeOpSrcCast1, 1)
#endif
  );

  // Note: COPY generated by TwoAddressInctruction in WHERE blocks and handled
  //   by me in ConnexTargetMachine.cpp, etc.

#include "Select_ADDf16_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing add.f16 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resF16,
                                                 DL);
  LLVM_DEBUG(dbgs() << "selectAddF16(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
#endif

  // End of method - we convert resH (vector of i16) to resW (vector of i32)
  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resF16, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
                                        SDValue(resF16, 1)
#endif
  );
  LLVM_DEBUG(dbgs() << "selectAddF16(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectAddF16()

SDNode *ConnexDAGToDAGISel::selectSubF16(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectSubF16(): [LATEST] Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectSubF16(): We are in the case TYPE_VECTOR_F16\n");
  typeVecNode = TYPE_VECTOR_F16;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectSubF16(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectSubF16(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectSubF16(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectSubF16(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_F16);

  SDNode *nodeOpSrcCast1 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
                                                  MVT::Other,
  // This gives error: MVT::Glue,
#else
                                                  MVT::Glue,
#endif
                                                  nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting sub.f16 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectSubF16: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16, MVT::Other,
                                                  // Important: it gives error:
                                                  // <<Assertion
                                                  //   `N->getNodeId() == -1 &&
                                                  //  "Node already inserted!">>
                                                  //  MVT::Glue,
                                                  nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
                                                  SDValue(inlineAsmNodeBegin, 0)
#else
                                                  SDValue(nodeOpSrcCast1, 1)
#endif
  );

  // Note: COPY generated by TwoAddressInctruction in WHERE blocks and handled
  // by me in ConnexTargetMachine.cpp, etc.

#include "Select_SUBf16_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing sub.f16 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resF16,
                                                 DL);
  LLVM_DEBUG(dbgs() << "SelectSubF16(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
#endif

  // End of method - we convert resH (vector of i16) to resW (vector of i32)
  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resF16, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
                                        SDValue(resF16, 1)
#endif
  );
  LLVM_DEBUG(dbgs() << "selectSubF16(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectSubF16()

SDNode *ConnexDAGToDAGISel::selectLtF16(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectLtF16(): [LATEST] Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectLtF16(): We are in the case TYPE_VECTOR_F16\n");
  typeVecNode = TYPE_VECTOR_F16;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectLtF16(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectLtF16(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectLtF16(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectLtF16(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_F16);

  SDNode *nodeOpSrcCast1 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
                                                  MVT::Other,
  // It gives error: MVT::Glue,
#else
                                                  MVT::Glue,
#endif
                                                  nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting lt.f16 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectLtF16: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16, MVT::Other,
                                                  // Important: it gives error:
                                                  // <<Assertion
                                                  //   `N->getNodeId() == -1 &&
                                                  // "Node already inserted!">>
                                                  // MVT::Glue,
                                                  nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
                                                  SDValue(inlineAsmNodeBegin, 0)
#else
                                                  SDValue(nodeOpSrcCast1, 1)
#endif
  );

  // Note: COPY generated by TwoAddressInctruction in WHERE blocks and handled
  // by me in ConnexTargetMachine.cpp, etc)

#include "Select_LTf16_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing lt.f16 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd,
                                                 lastNode, // resF16,
                                                 DL);
  LLVM_DEBUG(dbgs() << "selectLtF16(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
#endif

  // End of method - we convert resH (vector of short/i16) to resW (vector of
  // i32)
  SDNode *resW =
      CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                             // typeVecNode,
                             TYPE_VECTOR_I16, MVT::Glue, SDValue(resF16, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                             SDValue(inlineAsmNodeEnd, 0)
#else
                             SDValue(resF16, 1)
#endif
      );
  LLVM_DEBUG(dbgs() << "selectLtF16(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectLtF16()

SDNode *ConnexDAGToDAGISel::selectMulF16(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectMulF16(): [LATEST] Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectMulF16(): We are in the case TYPE_VECTOR_F16\n");
  typeVecNode = TYPE_VECTOR_F16;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectMulF16(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectMulF16(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectMulF16(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectMulF16(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_F16);

  SDNode *nodeOpSrcCast1 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
                                                  MVT::Other,
  // This gives a serious error:
  // MVT::Glue,
#else
                                                  MVT::Glue,
#endif
                                                  nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting mult.f16 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectMulF16: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16, MVT::Other,
                                                  // Important: it gives error:
                                                  // <<Assertion
                                                  //   `N->getNodeId() == -1 &&
                                                  //  "Node already inserted!">>
                                                  // MVT::Glue,
                                                  nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
                                                  SDValue(inlineAsmNodeBegin, 0)
#else
                                                  SDValue(nodeOpSrcCast1, 1)
#endif
  );

  // Note: COPY generated by TwoAddressInctruction in WHERE blocks and handled
  //   by me in ConnexTargetMachine.cpp, etc.

#include "Select_MULTf16_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing mult.f16 emulation ;)";
  SDNode *inlineAsmNodeEnd =
      CreateInlineAsmNode(CrtDAG, exprStrEnd, lastNode, DL);
  LLVM_DEBUG(dbgs() << "selectMulF16(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
#endif

  // End of method - we convert resH (vector of i16) to resW (vector of i32)
  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resF16, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
#error Normally no longer supported
                                        SDValue(resF16, 1)
#endif
  );
  LLVM_DEBUG(dbgs() << "selectMulF16(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectMulF16()

SDNode *ConnexDAGToDAGISel::selectDivF16(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectDivF16(): [LATEST] Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)

  LLVM_DEBUG(dbgs() << "selectDivF16(): We are in the case TYPE_VECTOR_F16\n");
  typeVecNode = TYPE_VECTOR_F16;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectDivF16(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectDivF16(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectDivF16(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectDivF16(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_F16);

  SDNode *nodeOpSrcCast1 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
                                                  MVT::Other,
  // It gives error: MVT::Glue,
#else
                                                  MVT::Glue,
#endif
                                                  nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting div.f16 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectDivF16: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // The output type of the node
                                                  TYPE_VECTOR_I16, MVT::Other,
                                                  // Important: it gives error:
                                                  // <<Assertion
                                                  //   `N->getNodeId() == -1 &&
                                                  //  "Node already inserted!">>
                                                  // MVT::Glue,
                                                  nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
                                                  SDValue(inlineAsmNodeBegin, 0)
#else
                                                  SDValue(nodeOpSrcCast1, 1)
#endif
  );

  // Note: COPY generated by TwoAddressInctruction in WHERE blocks and handled
  // by me in ConnexTargetMachine.cpp, etc.

#include "Select_DIVf16_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing div.f16 emulation ;)";
  SDNode *inlineAsmNodeEnd =
      CreateInlineAsmNode(CrtDAG, exprStrEnd, lastNode, DL);
  LLVM_DEBUG(dbgs() << "selectDivF16(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");
#endif

  // End of method - we convert resH (vector of i16) to resW (vector of i32)
  SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                        typeVecNode, SDValue(resF16, 0),
  // chain edge
#ifdef MARKER_FOR_EMULATION
                                        SDValue(inlineAsmNodeEnd, 0)
#else
#error Normally no longer supported
                                        SDValue(resF16, 1)
#endif
  );
  LLVM_DEBUG(dbgs() << "selectDivF16(): resW = "; resW->dump(CrtDAG);
             dbgs() << "\n");

  return resW;
} // End selectDivF16()

SDNode *ConnexDAGToDAGISel::selectDivI16(SDNode *Node) {
  LLVM_DEBUG(dbgs() << "Entered selectDivI16(): Selecting Node = ";
             Node->dump(CrtDAG); dbgs() << "\n");

  SDLoc DL(Node);

  EVT ViaVecTy;
  EVT typeVecNode;

  SDValue nodeOpSrc1 = Node->getOperand(0);
  SDValue nodeOpSrc2 = Node->getOperand(1);

  LLVM_DEBUG(dbgs() << "selectDivI16(): nodeOpSrc1.getValueType() = "
                    << nodeOpSrc1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectDivI16(): nodeOpSrc1 = ";
             (nodeOpSrc1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectDivI16(): nodeOpSrc2.getValueType() = "
                    << nodeOpSrc2.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectDivI16(): nodeOpSrc2 = ";
             (nodeOpSrc2.getNode())->dump(); dbgs() << "\n");
  // assert(nodeOpSrc.getValueType() == TYPE_VECTOR_I32);

  SDNode *nodeOpSrcCast1 = CrtDAG->getMachineNode(
      // Important: this is a BOGUS
      //  NOP_BITCONVERT - we just
      //  put it since it has a chain
      //  result, while
      //  nodeOpSrc1 does NOT
      Connex::NOP_BITCONVERT_HH, DL, TYPE_VECTOR_I16,
#ifdef MARKER_FOR_EMULATION
      MVT::Other,
  // It gives error: MVT::Glue,
#else
      MVT::Glue,
#endif
      nodeOpSrc1);

#ifdef MARKER_FOR_EMULATION
  std::string exprStrBegin = "// Starting DIV.i16 emulation ;)";
  SDNode *inlineAsmNodeBegin =
      CreateInlineAsmNode(CrtDAG, exprStrBegin, nodeOpSrcCast1, DL);
  LLVM_DEBUG(dbgs() << "selectDivI16: inlineAsmNodeBegin = ";
             inlineAsmNodeBegin->dump(); dbgs() << "\n");
#endif

  SDNode *nodeOpSrcCast2 = CrtDAG->getMachineNode(
      // Important: this is a BOGUS
      //  NOP_BITCONVERT - we just
      //  put it since it has a Glue
      //  result, while
      //  nodeOpSrcCast1 does NOT
      Connex::NOP_BITCONVERT_HH, DL, TYPE_VECTOR_I16, MVT::Other,
      // It gives error: MVT::Glue,
      nodeOpSrc2,
  // chain
#ifdef MARKER_FOR_EMULATION
      SDValue(inlineAsmNodeBegin, 0)
#else
      SDValue(nodeOpSrcCast1, 1)
#endif
  );

#include "Select_DIVi16_OpincaaCodeGen.h"

#ifdef MARKER_FOR_EMULATION
  std::string exprStrEnd = "// Finishing DIV.i16 emulation ;)";
  SDNode *inlineAsmNodeEnd = CreateInlineAsmNode(CrtDAG, exprStrEnd, resH, DL);
  LLVM_DEBUG(dbgs() << "selectDivI16(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");

  LLVM_DEBUG(dbgs() << "selectDivI16(): resH = "; resH->dump(CrtDAG);
             dbgs() << "\n");
  // return inlineAsmNodeEnd;
  // Gives error: <<SelectionDAG.cpp:6421:
  //  void llvm::SelectionDAG::ReplaceAllUsesWith(llvm::SDNode*, llvm::SDNode*):
  //  Assertion `(!From->hasAnyUseOfValue(i) ||
  //  From->getValueType(i) == To->getValueType(i)) &&
  //  "Cannot use this version of ReplaceAllUsesWith!"' failed.>>

  SDNode *resHH = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HH, DL,
                                         TYPE_VECTOR_I16, SDValue(resH, 0),
                                         // chain edge
                                         SDValue(inlineAsmNodeEnd, 0));
  LLVM_DEBUG(dbgs() << "selectDivI16(): resHH = "; resHH->dump(CrtDAG);
             dbgs() << "\n");

  return resHH;
#else
  LLVM_DEBUG(dbgs() << "selectDivI16(): resH = ";
               resH->dump(CrtDAG);
             dbgs() << "\n");

  // Important: It gives error at ReplaceNode(Node, res) in the caller function
  //   because <<SelectionDAG.cpp:8167: void llvm::SelectionDAG::
  //   ReplaceAllUsesWith(llvm::SDNode*, llvm::SDNode*): Assertion
  //   `(!From->hasAnyUseOfValue(i) || From->getValueType(i) ==
  //   To->getValueType(i)) && "Cannot use this version of ReplaceAllUsesWith!"'
  //   failed.>>
  //  The reason for this error is that:
  //      Node = v8i16 = sdiv t..., t...
  //      resH = ch = END_WHERE t...:1
  //   So we can't replace Node that has return value type v8i16 with END_WHERE
  //      that has return value type ch(ain).
  return resH;
#endif
} // End selectDivI16()

SDNode *ConnexDAGToDAGISel::selectVSELECT(SDNode *vselectNode) {
  // Basically we expand ("instruction-select") the following
  //  machine-independent instruction:
  //    dst = VSELECT pred, true_assignment, false_assignment
  // to the following Connex machine instr sequence:
  //  (note the comparison is excluded from the listing below
  //    and will be scheduled before it)
  //
  //    // For pred == false
  //    dst = false_assignment
  //    WHERExy
  //        // For pred == true:
  //        dst = true_assignment
  //    END_WHERE
  //
  //    NOTE: we could use a WHERE !pred to assign for the false case,
  //      but our above solution "destructive" assignment is OK and
  //      it takes fewer instructions.

  // In the end I do VSELECT treatment here, in
  //   ConnexISelDAGToDAG, and not in ISelLowering::LowerOperation.
  //
  // Note that register allocation is performed after Instruction selection
  //   (see [Cardoso_2014], Figure on page 134).
  //
  //  Note that although it is not required to create virtual registers for
  //    the ORV_H machine instructions (since we failed to add a ch input port
  //    to the setcc - see 50_IfConversion/Setcc_with_ch_input_port_NOT_working
  //      - and I guess we would fail here also), we create it for the true
  //    ORV_H because we need to make the associated predecessor CopyToRegister
  //   a successor of WHEREEQ, otherwise the WHEREEQ would not have a successor.
  //    TODO if we are extremely precious:
  //     I guess we could make a succcessor of WHEREEQ the CopyToReg successor
  //       of ORV_H and could get rid of all input virtual registers.
  //  NOTE: we canNOT get rid of the virtual register that keeps the result of
  //    both ORV_H, because we can replace it only with a VSELECT (reminds me
  //    of dataflow machines and multiplexors :) ), BUT we want
  //    to lower VSELECT in other components.
  //
  //  Note that the nodes we create here have to have correct ordering,
  //    otherwise instruction selection can fail or have wrong semantics.

  // END_WHERE, etc are defined in anonymous enum in TableGen generated
  //    ConnexGenInstrInfo.inc

  // From http://llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html:
  //      LLVMContext * getContext () const

  SDLoc DL(vselectNode);

  EVT ViaVecTy;
  EVT typeVecNode;

  LLVM_DEBUG(dbgs() << "Entered selectVSELECT(): Selecting vselectNode = ";
             vselectNode->dump(CrtDAG); dbgs() << "\n");

  // EVT ResTy = Node->getValueType(1); // 0 is ch (chain)
  EVT ResTy = vselectNode->getValueType(0);
  LLVM_DEBUG(dbgs() << "  ResTy = " << ResTy.getEVTString() << "\n");

  // SDValue chain = DAG.getEntryNode();

  assert(vselectNode->getNumOperands() == 3);
  LLVM_DEBUG(dbgs() << "  selectVSELECT(): Initially vselectNode->use_size() = "
                    << vselectNode->use_size() << "\n");
  for (SDNode::use_iterator UI = vselectNode->use_begin(),
                            UE = vselectNode->use_end();
       UI != UE; ++UI) {
    // Note: UI is an SDNode *
    LLVM_DEBUG(
        dbgs() << "  selectVSELECT(): Initially a use of vselectNode is: ";
        // OLD, deprecated: UI->print(dbgs());
        // NOT working: dbgs() << *(UI->getNode()); // MEGA-MEGA-TODO: erase comments
        dbgs() << "\n");
  }

  // EVT nodeResType = vselectNode->getValueType(0);
  SDValue vselectNodeOp0 = vselectNode->getOperand(0);
  SDValue vselectNodeOp1 = vselectNode->getOperand(1);
  SDValue vselectNodeOp2 = vselectNode->getOperand(2);
  //
  LLVM_DEBUG(dbgs() << "selectVSELECT(): vselectNodeOp0.getValueType() = "
                    << vselectNodeOp0.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectVSELECT(): vselectNodeOp0 = ";
             (vselectNodeOp0.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectVSELECT(): vselectNodeOp1.getValueType() = "
                    << vselectNodeOp1.getValueType().getEVTString() << "\n");
  LLVM_DEBUG(dbgs() << "selectVSELECT(): vselectNodeOp1 = ";
             (vselectNodeOp1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectVSELECT(): vselectNodeOp2 = ";
             (vselectNodeOp2.getNode())->dump(); dbgs() << "\n");

  SDValue setCC = vselectNodeOp0;
  SDNode *setCCNode = setCC.getNode();
  SDValue setCCPred = vselectNodeOp0.getNode()->getOperand(2);
  SDNode *setCCPredNode = setCCPred.getNode();
  //
  LLVM_DEBUG(dbgs() << "selectVSELECT(): setCCPredNode = ";
             // << setCCPredNode
             setCCPredNode->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectVSELECT(): setCCNode = ";
             // << setCCPredNode
             setCCNode->dump(); dbgs() << "\n");

  SDValue setCCNodeOp0 = setCCNode->getOperand(0);
  SDValue setCCNodeOp1 = setCCNode->getOperand(1);
  SDValue setCCNodeOp2 = setCCNode->getOperand(2);
  //
  LLVM_DEBUG(dbgs() << "selectVSELECT(): setCCNodeOp0 = ";
             (setCCNodeOp0.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectVSELECT(): setCCNodeOp1 = ";
             (setCCNodeOp1.getNode())->dump(); dbgs() << "\n");
  LLVM_DEBUG(dbgs() << "selectVSELECT(): setCCNodeOp2 = ";
             (setCCNodeOp2.getNode())->dump(); dbgs() << "\n");

  assert(setCCPredNode->isMachineOpcode() == false);
  assert(setCCPredNode->getOpcode() == ISD::CONDCODE);

  // EVT ResTy = TYPE_VECTOR_I16;

  unsigned whereOpcode;
  unsigned wherePredOpcode;
  unsigned typeCmp = cast<CondCodeSDNode>(setCCPredNode)->get();

  switch (typeCmp) {
  case ISD::SETEQ:
    whereOpcode = Connex::WHEREEQ;
    wherePredOpcode = Connex::EQ_H;
    break;
  case ISD::SETLT:
    whereOpcode = Connex::WHERELT;
    wherePredOpcode = Connex::LT_H;
    break;
  case ISD::SETULT:
    whereOpcode = Connex::WHERELT;
    wherePredOpcode = Connex::ULT_H;
    break;
  case ISD::SETOLT: {
    // We do operator strength reduction if one of the operands is 0
    BuildVectorSDNode *BVN = cast<BuildVectorSDNode>(setCCNodeOp1);

    if (isSplatVector(BVN) && // (BuildVectorSDNode *)&setCCNodeOp1) &&
        setCCNodeOp1->getConstantOperandVal(0) == 0) {
      LLVM_DEBUG(
          dbgs()
          << "selectVSELECT(): operator strength reduction if one of the "
             "operands is 0\n");

      typeCmp = ISD::SETLT; // ISD::SETULT;
      ResTy = TYPE_VECTOR_I16;

      whereOpcode = Connex::WHERELT;
      wherePredOpcode = Connex::LT_H;
      break;
    }

    assert(0 && "selectVSELECT(): Comparison (typeCmp) NOT implemented "
                "--> MUST IMPLEMENT");
    whereOpcode = Connex::WHERELT;
    wherePredOpcode = Connex::LT_H;
    break;
  }
  default:
    assert(0 && "selectVSELECT(): Comparison (typeCmp) NOT implemented "
                "--> MUST IMPLEMENT");
    // "VSELECT NOT implemented for other types than i16 - "
    // "need to do WHERELT/ULT.i32/f16
    //   (WHEREEQ.i32/f16 is identical to WHEREEQ.i16)");
  }

  /*
  assert(ResTy == TYPE_VECTOR_I16 &&
         "VSELECT NOT implemented for other types than i16 - "
         "need to do WHERELT/ULT.i32/f16 "
         " (WHEREEQ.i32/f16 is identical to WHEREEQ.i16)");
  */

  switch (typeCmp) {
  // ISD::SETEQ/SETLT/SETULT follow the same code to add glue - hence NO break
  case ISD::SETEQ:
  case ISD::SETLT:
  case ISD::SETULT: {
    // Here we basically add a glue edge to work with e.g.
    //   pre-RA-sched(=source) to the predicate SDNode by creating a new
    //   predicate MachineSDNode.
    //  If we do NOT put it, this block of Connex (Machine) instructions
    //   implementing VSELECT can be broken by e.g. pre-RA-sched=source.
    SDNode *newNode = CrtDAG->getMachineNode(wherePredOpcode, DL,
                                             // TYPE_VECTOR_I16,
                                             ResTy, MVT::Glue,
                                             // The 1st vector for comparison
                                             setCCNodeOp0,
                                             // The 2nd vector for comparison
                                             setCCNodeOp1
                                             // Glue input edge
    );
    LLVM_DEBUG(dbgs() << "selectVSELECT(): newNode = "; newNode->dump();
               dbgs() << "\n");

    ReplaceNode(setCCNode, newNode);
    setCCNode = newNode;
    setCC = SDValue(newNode, 0);

    break;
  }
  //
  case ISD::SETOLT: {
    // This is lt.f16

    whereOpcode = Connex::WHEREEQ;
    ResTy = TYPE_VECTOR_F16;

    // We ISel an lt.f16 and compare its result with 1.
    SDNode *resLtF16 = selectLtF16(setCCNode);

    // VLOAD 1;
    SDValue ct1 = CrtDAG->getConstant(1, DL, MVT::i16, true, false);
    SDNode *vload1 = CrtDAG->getMachineNode(Connex::VLOAD_H, DL,
                                            TYPE_VECTOR_I16, MVT::Glue, ct1,
                                            // Glue input edge
                                            SDValue(resLtF16, 1));

    SDNode *newNode =
        CrtDAG->getMachineNode(Connex::EQ_H, DL, TYPE_VECTOR_I16, MVT::Glue,
                               SDValue(resLtF16, 0), SDValue(vload1, 0),
                               // Glue input edge
                               SDValue(vload1, 1));
    LLVM_DEBUG(dbgs() << "selectVSELECT(): newNode = "; newNode->dump();
               dbgs() << "\n");

    ReplaceNode(setCCNode, newNode);
    setCCNode = newNode;
    setCC = SDValue(newNode, 0);

    break;
  }
  default:
    assert(0 && "case not reachable");
    break;
  }

  SDValue ct1 = CrtDAG->getConstant(1 /* Num of cycles to NOP */, DL, MVT::i16,
                                    true, false);
  SDNode *nopCopyFalse =
      CrtDAG->getMachineNode(Connex::NOP_BPF, DL, MVT::Glue,
                             // Important: This is a small abuse
                             //  (trick): normally we should put
                             //  ct1 instead, BUT we need to
                             //  avoid that ISel does DCE with
                             //  setCCNode, so we put here the
                             //  only output the value of
                             //   setCCNode.
                             //  If setCCNode had a glue or
                             //  chain output we could have
                             //  used that output instead at
                             // the end of this argument list.
                             // ct1,
                             SDValue(setCCNode, 0)
                             // Important: This is
                             //   a small abuse (normally we
                             //   should put ct1 instead, BUT
                             //   IT WORKS - we need to avoid
                             //   ISel it does DCE with
                             //   setCCNode)
                             // glue (or chain) input edge
                             // SDValue(eq1, 1)
                             // SDValue(setCCNode, 1)
                             // Gives error: Assertion
                             //  `(!Node || ResNo <
                             //  Node->getNumValues()) &&
                             //  "Invalid result number for
                             // the given node!"' failed.
                             // SDValue(setCCNode, 0)
                             // Gives error: Assertion
                             //  `NumMIOperands >=
                             //           II.getNumOperands()
                             //  && NumMIOperands <=
                             //  II.getNumOperands() +
                             //  II.getNumImplicitDefs() +
                             //  NumImpUses && "#operands for
                             //  dag node doesn't match .td
                             //  file!"' failed.
      );

  SDNode *whereEq = CrtDAG->getMachineNode(whereOpcode, DL,
                                           // TYPE_VECTOR_I16,
                                           // MVT::Other,
                                           MVT::Glue,
                                           // SDValue(nopCopyFalse, 0),
                                           // vselectNodeOp2,
                                           // Glue/chain edge
                                           // SDValue(idxPredicate, 1)
                                           // setCCPred
                                           SDValue(nopCopyFalse, 0));

  // Important: Note that we use ORV_SPECIAL_H, which puts a tied-to constraint
  //  to allocate to the same physical vector register (dst) both vSelectNodeOp1
  //  and vSelectNodeOp2.
  // Therefore, this ORV_SPECIAL_H puts over the vSelectNodeOp2,
  //  the false value, the values of the selected (where the predicate is true)
  //  vSelectNodeOp1.
  SDNode *copyTrue = CrtDAG->getMachineNode(
      Connex::ORV_SPECIAL_H, DL,
      // TYPE_VECTOR_I16,
      // ResTy,
      CrtDAG->getVTList(vselectNode->getValueType(0), MVT::Glue),
      {
          vselectNodeOp1, vselectNodeOp1, vselectNodeOp2,
          // Glue edge
          // SDValue(whereEq, 1) // Glue edge
          SDValue(whereEq, 0) // Glue edge
      });

  SDNode *endWhere = CrtDAG->getMachineNode(Connex::END_WHERE, DL,
                                            // ResTy,
                                            // TYPE_VECTOR_I16,
                                            MVT::Other,
                                            // SDValue(copyTrue, 0),
                                            // MVT::Glue,
                                            /* Important: we put this bogus
                                              operand here to force the PostRA
                                              scheduler to keep the
                                              WHERE..END_WHERE block intact
                                              withOUT using instruction bundles.
                                            */
                                            // chain edge
                                            SDValue(copyTrue, 1) // Glue edge
  );
  std::string exprStrEnd = "// Finishing VSELECT emulation ;)";
  SDNode *inlineAsmNodeEnd =
      CreateInlineAsmNode(CrtDAG, exprStrEnd, endWhere, DL);
  LLVM_DEBUG(dbgs() << "selectVSELECT(): inlineAsmNodeEnd = ";
             inlineAsmNodeEnd->dump(); dbgs() << "\n");

  // SDNode *res = resW;
  SDNode *res = copyTrue;
  LLVM_DEBUG(dbgs() << "selectVSELECT(): res = "; res->dump(); dbgs() << "\n");

  return res;
} // End selectVSELECT()

// Note: all ISD opcodes can be also found at
//    http://llvm.org/docs/doxygen/html/namespacellvm_1_1ISD.html.
//  There are also Connex opcodes that are generated by TableGen.
void ConnexDAGToDAGISel::Select(SDNode *Node) {
  unsigned Opcode = Node->getOpcode();

  // Dump information about the Node being selected
  LLVM_DEBUG(
      dbgs() << "Entered ConnexDAGToDAGISel::Select(): Selecting Node = ";
      Node->dump(CrtDAG); dbgs() << "Opcode = " << Opcode << "\n");

  // If we have a (custom) Machine node, it means we already have selected it
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CrtDAG); dbgs() << '\n');
    return;
  }

  // tablegen selection should be handled here.
  switch (Opcode) {
  default:
    LLVM_DEBUG(dbgs() << "ConnexDAGToDAGISel::Select(): default case: Opcode = "
                      << Opcode << "\n");
    break;

  /* From http://llvm.org/docs/doxygen/html/ISDOpcodes_8h_source.html:
  /// OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...)
  /// This node represents a target intrinsic function with side effects that
  /// does not return a result.  The first operand is a chain pointer.  The
  /// second is the ID number of the intrinsic from the llvm::Intrinsic
  /// namespace.  The operands to the intrinsic follow.
  */
  case ISD::INTRINSIC_VOID: {
    LLVM_DEBUG(
        dbgs() << "ConnexDAGToDAGISel::Select(): case ISD::INTRINSIC_VOID"
               << "\n");

    unsigned intrinsicOpcode =
        cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();
    LLVM_DEBUG(dbgs() << "intrinsicOpcode = " << intrinsicOpcode << "\n");

    /*
    LLVM_DEBUG(dbgs() << "Intrinsic::connex_end_repeat = "
                      << Intrinsic::connex_end_repeat << "\n");
    LLVM_DEBUG(dbgs() << "Intrinsic::connex_reduce = "
                      << Intrinsic::connex_reduce << "\n");
    LLVM_DEBUG(dbgs() << "Intrinsic::connex_repeat_x_times = "
                      << Intrinsic::connex_repeat_x_times << "\n");
    */

    LLVM_DEBUG(dbgs() << "Node->getOperand(0) = "; Node->getOperand(0).dump();
               dbgs() << "\n");
    LLVM_DEBUG(dbgs() << "Node->getOperand(1) = "; Node->getOperand(1).dump();
               dbgs() << "\n");

    switch (intrinsicOpcode) {
    case Intrinsic::connex_repeat_x_times: {
      SDLoc DL(Node);

      /* llvm.connex.repeat.x.times SDNode has 3 operands:
          - 0, which is the chain - a bit to my surprise
               SelectionDAGBuilder puts as input to the chain port
               the node just above it, not SDNode t0
          - 1, which is the intrinsic's opcode
          - 2, which is the actual parameter
      t16: ch = llvm.connex.repeat.x.times t10, TargetConstant:i64<471>, t15
       */

      LLVM_DEBUG(dbgs() << "ConnexDAGToDAGISel::Select(): case "
                           "Intrinsic::connex_repeat_x_times"
                        << "\n");
      LLVM_DEBUG(dbgs() << "  Node->getOperand(2) = ";
                 Node->getOperand(2).dump(); dbgs() << "\n");

#define CODE2018_06_29

      SDNode *repeatSpecial =
          CrtDAG->getMachineNode(Connex::REPEAT_SYM_IMM, DL,
      // Return types
#ifdef CODE2018_06_29
                                 /* Gives error at "List Scheduling":
                                      - when doing things as correct as
                                        possible (glue edge put in
                                        CONNEX::INLINEASM as the last
                                        operand):
                                       <<Assertion `!AnyNotSched' failed.>>

                                      - glue edge put in ISD::INLINEASM as
                                          the last operand): <<Assertion
                                         `isMachineOpcode() &&
                                         "Not a MachineInstr opcode!"'
                                         failed.>>

                                      - <<Assertion `N->getNodeId() == -1
                                         && "Node already inserted!">>
                                        - because I put this Glue edge as
                                         1st operand of INLINEASM, which
                                         is documented as being wrong
                                 */
                                 MVT::Glue,
#else
                                 MVT::Other,
#endif
                                 // We add a chain edge
                                 /* Important: this was wrong since
                                  *   when we give ReplaceNode() it
                                  *   deletes the platform independent
                                  *   REPEAT SDNode which has as input
                                  *   opnd0 (Node->getOperand(0), an Inline
                                  *   ASM epxression, as discussed,
                                  *   fed on the chain input port) and
                                  *   opnd0 is not used by any other
                                  *   node.
                                  WRONG: CrtDAG->getEntryNode()

                                  * But now I give opnd0 as input
                                  * to the chain port of the new
                                  * machine-dependent node
                                  * and this avoids
                                  * opnd0 becoming a dead node and
                                  * be eventually removed.
                                  */
                                 Node->getOperand(0));
      LLVM_DEBUG(dbgs() << "Select() for Intrinsic::connex_repeat_x_times: "
                           "repeatSpecial = ";
                 repeatSpecial->dump(); dbgs() << "\n");

      SDNode *op2 = Node->getOperand(2).getNode();
      LLVM_DEBUG(dbgs() << "op2 = "; op2->dump(); dbgs() << "\n");

      std::string exprStr = "-1); // REPEAT_TIMES()";
      // This is wrong - we just put an incorrect value
      // MEGA-TODO(2021_02_02): see below
      /*
      // MEGA-TODO(2021_02_02):
      std::string exprStr = "    " +
                        recoverCExpressionFromSDNode(op2, crtNodeMap, true)
                            + ");";
      */

      SDNode *inlineAsmNode =
          CreateInlineAsmNode(CrtDAG, exprStr, repeatSpecial, DL
#ifdef CODE2018_06_29
                              ,
                              true
#endif
          );

      // ReplaceAllUsesWith(Node, inlineAsmNode);
      // CrtDAG->RemoveDeadNode(Node);
      // Gives at scheduling error: Assertion `Node2Index[SU->NodeNum] >
      // Node2Index[I->getSUnit()->NodeNum] &&
      // "Wrong topological sorting"' failed.
      // ReplaceNode defined in include/llvm/CodeGen/SelectionDAGISel.h .

      ReplaceNode(Node, inlineAsmNode);

      // This takes out the REPEAT and symbolic expression INLINE Asm
      // ReplaceNode(Node, Node->getOperand(0).getNode());
      return;
    }
    /*
    case Intrinsic::connex_end_repeat:
        // Note: this case is handled in TableGen match pattern in
        //   ConnexInstrInfo_REPEAT.td
    */
    default:
      break;
    }
  }

  /* From http://llvm.org/docs/doxygen/html/ISDOpcodes_8h_source.html:
  /// RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...)
  /// This node represents a target intrinsic function with side effects that
  /// returns a result.  The first operand is a chain pointer.  The second is
  /// the ID number of the intrinsic from the llvm::Intrinsic namespace.  The
  /// operands to the intrinsic follow.  The node has two results, the result
  /// of the intrinsic and an output chain.
  */
  case ISD::INTRINSIC_W_CHAIN: {
    LLVM_DEBUG(
        dbgs() << "ConnexDAGToDAGISel::Select(): case ISD::INTRINSIC_W_CHAIN"
               << "\n");
    unsigned Num = cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();
    LLVM_DEBUG(dbgs() << "Num = " << Num << "\n");
    switch (Num) {
    case Intrinsic::connex_load_byte:
    case Intrinsic::connex_load_half:
    case Intrinsic::connex_load_word: {
      SDLoc DL(Node);
      SDValue Chain = Node->getOperand(0);
      SDValue N1 = Node->getOperand(1);
      SDValue Skb = Node->getOperand(2);
      SDValue N3 = Node->getOperand(3);

      // TODO_CHANGE_BACKEND:
      // SDValue R6Reg = CrtDAG->getRegister(Connex::R6, MVT::i64);
      SDValue R6Reg = CrtDAG->getRegister(Connex::R6, TYPE_SCALAR_ELEMENT);

      Chain = CrtDAG->getCopyToReg(Chain, DL, R6Reg, Skb, SDValue());
      Node = CrtDAG->UpdateNodeOperands(Node, Chain, N1, R6Reg, N3);
      break;
    }
    case Intrinsic::connex_reduce: {
      // EVT ResTy = Node->getValueType(0);
      EVT ResTy = (Node->getOperand(2).getNode())->getValueType(0);

      LLVM_DEBUG(dbgs() << "Entered Select() for Intrinsic::connex_reduce:\n"
                        << "  ResTy = " << ResTy.getEVTString() << "\n");

      if (ResTy == TYPE_VECTOR_I32) {
        LLVM_DEBUG(dbgs() << "Select() for connex_reduce.i32\n");

        SDNode *reduceHigh16 = selectReduceI32(Node);

        ReplaceNode(Node, reduceHigh16);
        // Res // does NOT work - gives RT error: whereEq);
        // ReplaceNode(Node, nodeOpSrcCast);

        /*
        // See llvm.org/docs/doxygen/html/classllvm_1_1SelectionDAG.html
        CrtDAG->SelectNodeTo(Node,
                              Connex::RED_H,
                              TYPE_VECTOR_I16,
                              SDValue(vloadCt0_srcAux, 0));
        */
        return;
      } // End case Intrinsic::connex_reduce_i32
      else if (ResTy == TYPE_VECTOR_F16) {
        LLVM_DEBUG(dbgs() << "Select() for connex_reduce.f16\n");

        SDNode *reduceH = selectReduceF16(Node);

        ReplaceNode(Node, reduceH);

        return;
      } // End case Intrinsic::connex_reduce_f16
    }
    }
    break;
  }

  case ISD::FrameIndex: {
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    EVT VT = Node->getValueType(0);
    SDValue TFI = CrtDAG->getTargetFrameIndex(FI, VT);
    unsigned Opc = Connex::MOV_rr;
    if (Node->hasOneUse()) {
      CrtDAG->SelectNodeTo(Node, Opc, VT, TFI);
      return;
    }
    ReplaceNode(Node, CrtDAG->getMachineNode(Opc, SDLoc(Node), VT, TFI));
    return;
  }

  case ISD::INSERT_VECTOR_ELT: {
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::INSERT_VECTOR_ELT.\n");
    return;
  }
  /*
  case ISD::SETCC: {
    SDNode *res = Select...(Node);
    ReplaceNode(Node, res);
    return;
  }
  */
  case ISD::VSELECT: {
    SDNode *res = selectVSELECT(Node);
    ReplaceNode(Node, res);
    return;
  }
  case ISD::FNEG: {
    EVT ResTy = Node->getValueType(0);
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::FNEG: \n"
                      << "  ResTy = " << ResTy.getEVTString() << "\n");
    SDLoc DL(Node);
    SDValue nodeOpSrc = Node->getOperand(0);

    if (ResTy == TYPE_VECTOR_F16) {
      LLVM_DEBUG(dbgs() << "Select() for FNEG: "
                           "We are in the case TYPE_VECTOR_F16\n");

      SDNode *nodeOpSrcCast = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, ResTy, MVT::Glue, nodeOpSrc);

      SDValue ct0x8000 = CrtDAG->getConstant(0x8000, DL, MVT::i16, true, false);
      SDNode *vload0x8000 = CrtDAG->getMachineNode(
          Connex::VLOAD_H, DL, TYPE_VECTOR_I16, MVT::Glue, ct0x8000,
          // glue (or chain) input
          SDValue(nodeOpSrcCast, 1));

      SDNode *res = CrtDAG->getMachineNode(Connex::XORV_H, DL, ResTy, MVT::Glue,
                                           SDValue(nodeOpSrcCast, 0),
                                           SDValue(vload0x8000, 0),
                                           // glue (or chain) input edge
                                           SDValue(vload0x8000, 1));

      SDNode *resW = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                            ResTy, SDValue(res, 0),
                                            // chain edge
                                            SDValue(res, 1));
      ReplaceNode(Node, resW);

      LLVM_DEBUG(dbgs() << "Select() for FNEG: Node = "; Node->dump();
                 dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select() for FNEG: res = "; res->dump();
                 dbgs() << "\n");

      return;
    }
  }
  case ISD::FADD: {
    EVT ResTy = Node->getValueType(0);
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::FADD: \n"
                      << "  ResTy = " << ResTy.getEVTString() << "\n");

    SDLoc DL(Node);
    SDValue nodeOpSrc1 = Node->getOperand(0);
    SDValue nodeOpSrc2 = Node->getOperand(1);

    // NEW_FP16
    if (ResTy == TYPE_VECTOR_F16) {
      LLVM_DEBUG(dbgs() << "Select() for FADD: "
                           "We are in the case TYPE_VECTOR_F16\n");

      SDNode *res = selectAddF16(Node);
      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::FADD: Node = "; Node->dump();
                 dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select() for ISD::FADD: res = "; res->dump();
                 dbgs() << "\n");

      return;
    } else if (ResTy == MVT::f16) {
      // Scalar F16
      // TODO: We should emulate with BPF assembler the add.f16
      //   scalar op. This means we need to use a NOP_CONVERT_F16_TO_I64, etc
      LLVM_DEBUG(dbgs() << "Select() for FADD:We are in the case MVT::F16\n");

      SDNode *res = CrtDAG->getMachineNode(Connex::ADD_rr, // This is actually
                                                           // a BPF instruction
                                           DL, ResTy,
                                           // NOT working - error <<Assertion
                                           //  `(!From->hasAnyUseOfValue(i) ||
                                           //  From->getValueType(i) ==
                                           //  To->getValueType(i)) &&
                                           //  "Cannot use this version of
                                           // ReplaceAllUsesWith!"' failed.>>:
                                           //   MVT::i64,
                                           // MVT::Other,
                                           // nodeOpSrc1,
                                           // I guess this is not needed,
                                           //   since the auto-ISeled BPF
                                           //   instructions don't need it
                                           //   either
                                           nodeOpSrc1, nodeOpSrc2
                                           // opChain
      );

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for scalar ISD::FADD: Node = ";
                 Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select() for scalar ISD::FADD: res = "; res->dump();
                 dbgs() << "\n");

      return;
    }
  } // End ISD::FADD
  case ISD::FSUB: {
    EVT ResTy = Node->getValueType(0);
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::FSUB: \n"
                      << "  ResTy = " << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_F16) {
      LLVM_DEBUG(dbgs() << "Select() for FSUB: "
                           "We are in the case TYPE_VECTOR_F16\n");
      // typeVecNode = TYPE_VECTOR_F16;

      SDNode *res = selectSubF16(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::FSUB: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    }
  }
  case ISD::FMUL: {
    EVT ResTy = Node->getValueType(0);
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::FMUL: \n"
                      << "  ResTy = " << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_F16) {
      LLVM_DEBUG(dbgs() << "Select() for FMUL: "
                           "We are in the case TYPE_VECTOR_F16\n");
      // typeVecNode = TYPE_VECTOR_F16;

      // TODO
      SDNode *res = selectMulF16(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::FMUL: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    }
  }

  case ISD::ABS: {
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::ABS: \n"
                      << "  ResTy = " << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for ABS: "
                           "We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      SDNode *res = selectAbsI32(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::ABS: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      assert(0 && "Not implemented!");
      LLVM_DEBUG(dbgs() << "Select() for ABS: "
                           "We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End ISD::ADD

  // NEW32
  case ISD::ADD: {
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::ADD: \n"
                      << "  ResTy = " << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for ADD: "
                           "We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      SDNode *res = selectAddI32(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::ADD: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for ADD: "
                           "We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End ISD::ADD
  // NEW32
  case ISD::SUB: {
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::SUB.\n"
                      << "Select() for SUB: "
                         "ResTy = "
                      << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for SUB: "
                           "We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      SDNode *res = selectSubI32(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::SUB: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for SUB: "
                           "We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End ISD::SUB
  case ISD::MUL: {
    SDLoc DL(Node);

    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::MUL.\n");

    LLVM_DEBUG(dbgs() << "Select() for MUL: "
                         "ResTy = "
                      << ResTy.getEVTString() << "\n");
    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for MUL: "
                           "We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      SDNode *res = selectMulI32(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::MUL: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for ISD::MUL: We are in the case "
                           "TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End case ISD::MUL
  case ISD::FDIV: {
    EVT ResTy = Node->getValueType(0);
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::FDIV: \n"
                      << "  ResTy = " << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_F16) {
      LLVM_DEBUG(dbgs() << "Select() for FDIV: "
                           "We are in the case TYPE_VECTOR_F16\n");
      // typeVecNode = TYPE_VECTOR_F16;

      // TODO
      SDNode *res = selectDivF16(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::FDIV: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    }
    /*
    SDLoc DL(Node);

    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::FDIV.\n");

    LLVM_DEBUG(dbgs() << "Select() for FDIV: "
                         "ResTy = " << ResTy.getEVTString()
                      << "\n");
    */
  }
  // TODO: should be also case ISD::SDIVREM:
  case ISD::SDIV: {
    SDLoc DL(Node);

    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::DIV.\n");

    LLVM_DEBUG(dbgs() << "Select() for DIV: "
                         "ResTy = "
                      << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for DIV: "
                           "We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      assert(0 && "Not implemented");

      /* SDNode *res = SelectDivI32(Node);
      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::DIV: res = ";
                 res->dump(CrtDAG); dbgs() << "\n");
      */
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for ISD::DIV: "
                           "We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;

      SDNode *res = selectDivI16(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::DIV: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    }

    break;
  }
  case ISD::OR: {
    SDLoc DL(Node);

    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::OR.\n");
    LLVM_DEBUG(dbgs() << "Select() for OR: "
                         "ResTy = "
                      << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for OR: "
                           "We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      SDValue nodeOp0 = Node->getOperand(0);
      SDValue nodeOp1 = Node->getOperand(1);

      SDNode *nodeOp0Cast = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, nodeOp0);
      SDNode *nodeOp1Cast = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, nodeOp1);

      SDNode *Res16 = CrtDAG->getMachineNode(Connex::ORV_H, DL, TYPE_VECTOR_I16,
                                             // MVT::Other,
                                             SDValue(nodeOp0Cast, 0),
                                             SDValue(nodeOp1Cast, 0));
      LLVM_DEBUG(dbgs() << "Select() for ISD::OR: Res16 = ";
                 Res16->dump(CrtDAG); dbgs() << "\n");

      SDNode *Res = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                           typeVecNode, SDValue(Res16, 0));

      ReplaceNode(Node, Res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::OR: Res = "; Res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(
          dbgs() << "Select() for OR: We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End ISD::OR
  // NEW32
  case ISD::AND: {
    SDLoc DL(Node);

    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::AND.\n");

    LLVM_DEBUG(dbgs() << "Select() for AND: ResTy = " << ResTy.getEVTString()
                      << "\n");
    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(
          dbgs() << "Select() for AND: We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      SDValue nodeOp0 = Node->getOperand(0);
      SDValue nodeOp1 = Node->getOperand(1);

      SDNode *nodeOp0Cast = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, nodeOp0);
      SDNode *nodeOp1Cast = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, nodeOp1);

      SDNode *Res16 = CrtDAG->getMachineNode(
          Connex::ANDV_H, DL, TYPE_VECTOR_I16,
          // MVT::Other,
          SDValue(nodeOp0Cast, 0), SDValue(nodeOp1Cast, 0));
      LLVM_DEBUG(dbgs() << "Select() for ISD::AND: Res16 = ";
                 Res16->dump(CrtDAG); dbgs() << "\n");

      SDNode *Res = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                           typeVecNode, SDValue(Res16, 0));

      ReplaceNode(Node, Res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::AND: Res = "; Res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(
          dbgs() << "Select() for AND: We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End ISD::AND
  // NEW32
  case ISD::XOR: {
    SDLoc DL(Node);

    /* TODO: check that the flags are also equivalent: XOR i16
         sets flags like SUBC:
     see ConnexVector.cpp
      BINARY_OP_FLAGS_LIKE_SUBC(^) - look for the macros
    */

    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::XOR.\n");

    LLVM_DEBUG(dbgs() << "Select() for XOR: ResTy = " << ResTy.getEVTString()
                      << "\n");
    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(
          dbgs() << "Select() for XOR: We are in the case TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      SDValue nodeOp0 = Node->getOperand(0);
      SDValue nodeOp1 = Node->getOperand(1);

      SDNode *nodeOp0Cast = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, nodeOp0);
      SDNode *nodeOp1Cast = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, nodeOp1);

      SDNode *Res16 = CrtDAG->getMachineNode(
          Connex::XORV_H, DL, TYPE_VECTOR_I16,
          // MVT::Other,
          SDValue(nodeOp0Cast, 0), SDValue(nodeOp1Cast, 0));
      LLVM_DEBUG(dbgs() << "Select() for ISD::XOR: Res16 = ";
                 Res16->dump(CrtDAG); dbgs() << "\n");

      SDNode *Res = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL,
                                           typeVecNode, SDValue(Res16, 0));

      ReplaceNode(Node, Res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::XOR: Res = "; Res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(
          dbgs() << "Select() for XOR: We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End ISD::XOR
  // NEW32
  case ISD::SRA: { // Arithmetic Shift Right
    // See http://llvm.org/docs/LangRef.html#ashr-instruction
    //     and http://en.wikipedia.org/wiki/Arithmetic_shift
    SDLoc DL(Node);

    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::SRA.\n");
    LLVM_DEBUG(dbgs() << "Select() for SRA: "
                         "ResTy = "
                      << ResTy.getEVTString() << "\n");

    if (ResTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "selectSraI32() for MUL: We are in the case "
                           "TYPE_VECTOR_I32\n");
      // typeVecNode = TYPE_VECTOR_I32;

      /*
      TODO(INTERESTING)
      // ConstantSDNode *nodeOp0CtSDNode = cast<ConstantSDNode>(nodeOp1);
      BuildVectorSDNode *BVN = cast<BuildVectorSDNode>(nodeOp1.getNode());
      // TODO: need to discriminate case: immediate operand - it takes fewer
      cycles APInt SplatValue, SplatUndef; unsigned SplatBitSize; bool
      HasAnyUndefs; if (BVN->isConstantSplat(SplatValue, SplatUndef,
                               SplatBitSize, HasAnyUndefs,
                               8, true) == true) {
        LLVM_DEBUG(
          dbgs() << "Select() for SRA: BVN->isConstantSplat() == TRUE\n");
        // MEGA-TODO: in this case we should do ISHRA.i32 instead of SHRA.i32
      }
      */

      SDNode *res = selectSraI32(Node);

      ReplaceNode(Node, res);

      LLVM_DEBUG(dbgs() << "Select() for ISD::SRA: res = "; res->dump(CrtDAG);
                 dbgs() << "\n");
      return;
    } else if (ResTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(
          dbgs() << "Select() for SRA: We are in the case TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;
    }

    break;
  } // End ISD::SRA
  // NEW32
  case ISD::MGATHER: {
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::MGATHER.\n");
    LLVM_DEBUG(dbgs() << "  Select(): Node = "; Node->dump(); dbgs() << "\n");

    SDLoc DL(Node);
    EVT ViaVecTy;
    EVT typeVecNode;
    EVT ResTy = Node->getValueType(0);

    MaskedGatherSDNode *nodeGather = dyn_cast<MaskedGatherSDNode>(Node);
    assert(nodeGather != NULL);

    // See llvm.org/docs/doxygen/html/SelectionDAGNodes_8h_source.html#l02107
    SDValue indexVec = nodeGather->getIndex();
    SDValue passthruVec = nodeGather->getPassThru();

    LLVM_DEBUG(dbgs() << "Select() for MGATHER: indexVec = ";
               (indexVec.getNode())->dump(); dbgs() << "\n");
    LLVM_DEBUG(dbgs() << "Select() for MGATHER: passthruVec = ";
               (passthruVec.getNode())->dump(); dbgs() << "\n");

    EVT opIndexVecTy = indexVec.getValueType();
    EVT opValVecTy = passthruVec.getValueType();

    LLVM_DEBUG(dbgs() << "Select() for MGATHER: opIndexVecTy = "
                      << opIndexVecTy.getEVTString()
                      << ", opValVecTy = " << opValVecTy.getEVTString()
                      << ", ResTy = " << ResTy.getEVTString() << "\n");

    SDValue opChain = Node->getOperand(0);
    LLVM_DEBUG(dbgs() << "Select() for MGATHER: opChain = ";
               (opChain.getNode())->dump(); dbgs() << "\n");

    // NEW_FP16
    // if (opValVecTy == TYPE_VECTOR_F16)
    if (ResTy == TYPE_VECTOR_F16) {
      typeVecNode = TYPE_VECTOR_F16;

      LLVM_DEBUG(dbgs() << "Select() for MGATHER: We are in the case "
                           "ResTy == TYPE_VECTOR_F16\n");

#ifdef BITCAST_2018_06_F16
      SDNode *indexVec16 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // typeVecNode,
                                                  TYPE_VECTOR_I16,
                                                  // The address operand
                                                  indexVec);
#endif

      SDNode *Res16 = CrtDAG->getMachineNode(Connex::LD_INDIRECT_H, DL,
#ifdef BITCAST_2018_06_F16
                                             TYPE_VECTOR_I16,
#else
                                             typeVecNode,
      // We prevent getting error:
      //  <<Assertion
      // `(!From->hasAnyUseOfValue(i)
      // || From->getValueType(i) ==
      // To->getValueType(i)) &&
      // "Cannot use this version of
      // ReplaceAllUsesWith!"'
      // failed.>>
#endif
      // MVT::Other,
#ifdef BITCAST_2018_06_F16
                                             SDValue(indexVec16, 0), // indexVec
#else
                                             indexVec,
#endif
                                             opChain);

      SDNode *Res;
#ifdef BITCAST_2018_06_F16
      Res = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL, typeVecNode,
                                   SDValue(Res16, 0));
#else
      Res = Res16;
#endif

      // TODO: Use instead of Connex::NOP_BITCONVERT_WH a new node called
      //   Connex::NOP_BITCONVERT_F16H
      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    } else if (opIndexVecTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for MGATHER: We are in the case "
                           "TYPE_VECTOR_I32\n");
      typeVecNode = TYPE_VECTOR_I32;

      /* Very Important: we add opChain to chain this new node with the node
          the target-independent masked_gather node was chained with.
        If we do not do this then we will eventually have other useful
          chained nodes removed, resulting in a incorrect/partial program. */
      /* TODO: not sure if the chain is going to always be operand 0.
      However masked_gather has a chain following attribute SDNPHasChain,
        see include/llvm/Target/TargetSelectionDAG.td
        See also indirectly the other params (methods get*()) of
          MaskedGatherScatterSDNode at
      http://llvm.org/docs/doxygen/html/SelectionDAGNodes_8h_source.html
      */
#ifdef BITCAST_MAY2017_05_28
      SDNode *indexVec16 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // typeVecNode,
                                                  TYPE_VECTOR_I16,
                                                  // The address operand
                                                  indexVec);
#endif
      SDNode *Res16 = CrtDAG->getMachineNode(Connex::LD_INDIRECT_H, DL,
                                             // typeVecNode,
                                             TYPE_VECTOR_I16,
      // MVT::Other,
#ifdef BITCAST_MAY2017_05_28
                                             SDValue(indexVec16, 0), // indexVec
#else
                                             indexVec,
#endif
                                             opChain);
      SDNode *Res;
#ifdef BITCAST_MAY2017_05_28
      Res = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_HW, DL, typeVecNode,
                                   MVT::Other,
                                   // We need this only for DotProd.i16
                                   SDValue(Res16, 0));
#else
      Res = Res16;
#endif

      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    } else if (opIndexVecTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for MGATHER: We are in the case "
                           "TYPE_VECTOR_I16\n");
      typeVecNode = TYPE_VECTOR_I16;

      SDNode *Res = CrtDAG->getMachineNode(Connex::LD_INDIRECT_H, DL,
                                           // typeVecNode,
                                           TYPE_VECTOR_I16,
                                           /* Usually it comes with ch
                                              putting it here avoids error
                                            <<Assertion `ResNo < NumValues &&
                                           "Illegal result number!"' failed.>>
                                           */
                                           MVT::Other, indexVec, opChain);

      LLVM_DEBUG(dbgs() << "Res = "; Res->dump(CrtDAG); dbgs() << "\n");
      ReplaceNode(Node, Res);

      return;
    }
    // Res = CrtDAG->getMachineNode(Connex::LD_INDIRECT_W, DL, ViaVecTy,
    //                              Node->getOperand(0));
    // Res = CrtDAG->getMachineNode(LD_INDIRECT_W_DESC_BASE, DL, ViaVecTy,
    //                              Node->getOperand(0));
    // Res = CrtDAG->getMachineNode(ST_INDIRECT_H_DESC_BASE, DL, ViaVecTy,
    //                              Node->getOperand(0));

    break;
  } // End ISD::MGATHER
  // NEW32
  case ISD::MSCATTER: {
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::MSCATTER.\n");

    SDLoc DL(Node);
    MVT typeVecNode;
    // For SCATTER it is chain: EVT ResTy = Node->getValueType(0);
    // MVT mResTy = ResTy.getSimpleVT();

    MaskedScatterSDNode *nodeScatter = dyn_cast<MaskedScatterSDNode>(Node);
    // See llvm.org/docs/doxygen/html/SelectionDAGNodes_8h_source.html#l02107
    SDValue indexVec = nodeScatter->getIndex();
    SDValue sourceVec = nodeScatter->getValue();

    LLVM_DEBUG(dbgs() << "Select() for MSCATTER: indexVec = ";
               (indexVec.getNode())->dump(); dbgs() << "\n");
    LLVM_DEBUG(dbgs() << "Select() for MSCATTER: sourceVec = ";
               (sourceVec.getNode())->dump(); dbgs() << "\n");

    EVT opIndexVecTy = indexVec.getValueType();
        /*Node->getOperand(0).getValueType(); */ // getSimpleValueType();
    EVT opSourceVecTy = sourceVec.getValueType();

    LLVM_DEBUG(dbgs() << "Select() for MSCATTER: "
                      << "opIndexVecTy = " << opIndexVecTy.getEVTString()
                      << ", opSourceVecTy = " << opSourceVecTy.getEVTString()
                      << "\n");

    // NEW_FP16
    if (opSourceVecTy == TYPE_VECTOR_F16) {
      LLVM_DEBUG(dbgs() << "Select() for MSCATTER: We are in the case "
                           "opSourceVecTy == TYPE_VECTOR_F16\n");

// TODO: Use instead of Connex::NOP_BITCONVERT_WH a new node called
//    Connex::NOP_BITCONVERT_F16H
#ifdef BITCAST_2018_06_F16
      SDNode *sourceVec16 = CrtDAG->getMachineNode(
          Connex::NOP_BITCONVERT_WH, DL, TYPE_VECTOR_I16, sourceVec);
      SDNode *Res =
          CrtDAG->getMachineNode(Connex::ST_INDIRECT_H, DL, MVT::Other,
                                 indexVec, SDValue(sourceVec16, 0));
#else
      SDNode *Res = CrtDAG->getMachineNode(Connex::ST_INDIRECT_H, DL,
                                           MVT::Other, indexVec, sourceVec);
#endif

      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    } else if (opIndexVecTy == TYPE_VECTOR_I32) {
      LLVM_DEBUG(dbgs() << "Select() for MSCATTER: We are in the case "
                           "opIndexVecTy == TYPE_VECTOR_I32\n");

      typeVecNode = TYPE_VECTOR_I32;

      /* Very Important: we add opChain to chain this new node with the node
          the target-independent masked_gather node was chained with.
        If we do not do this then we will eventually have other useful
          chained nodes removed, resulting in a incorrect/partial program. */
      /* TODO: not sure if the chain is going to always be operand 0.
      However masked_gather has a chain following attribute SDNPHasChain,
        see include/llvm/Target/TargetSelectionDAG.td
        See also indirectly the other params (methods get*()) of
          MaskedGatherScatterSDNode at
      http://llvm.org/docs/doxygen/html/SelectionDAGNodes_8h_source.html
      */
      SDValue opChain = Node->getOperand(0);
      LLVM_DEBUG(dbgs() << "Select() for MSCATTER: opChain = ";
                 (opChain.getNode())->dump(); dbgs() << "\n");
#ifdef BITCAST_MAY2017_05_28
      SDNode *indexVec16 = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                                  // typeVecNode,
                                                  TYPE_VECTOR_I16, indexVec);
      SDNode *sourceVec16 =
          CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH, DL,
                                 // typeVecNode,
                                 TYPE_VECTOR_I16, sourceVec);
#endif
      SDNode *Res = CrtDAG->getMachineNode(Connex::ST_INDIRECT_H, DL,
                                           // typeVecNode,
                                           // voidEVT,
                                           MVT::Other,
#ifdef BITCAST_MAY2017_05_28
                                           SDValue(indexVec16, 0), // indexVec,
                                           // sourceVec
                                           SDValue(sourceVec16, 0)
#else
                                           indexVec, sourceVec
#endif
                                           /*
                                           // ,opChain
                                           TODO: figure out why can't I add a
                                           chain edge to scatter like I did for
                                           MGAHTER MAYBE use:
                                           CrtDAG->getVTList(MVT::Other,
                                                             MVT::Glue), */
      );

      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    } else if (opIndexVecTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for MSCATTER: We are in the case "
                           "opIndexVecTy == TYPE_VECTOR_I16\n");

      typeVecNode = TYPE_VECTOR_I16;

      SDNode *Res = CrtDAG->getMachineNode(Connex::ST_INDIRECT_H, DL,
                                           // typeVecNode,
                                           // voidEVT,
                                           MVT::Other, indexVec, sourceVec);

      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    }

    /*
    LLVMContext &theContext = *(CrtDAG->getContext());
    EVT voidEVT = EVT::getEVT(Type::getVoidTy(theContext));
    LLVM_DEBUG(dbgs() << "     voidEVT = "
                      << voidEVT.getEVTString() << "\n");
    */

    break;
  } // End ISD::MSCATTER
  case ISD::ConstantPool: {
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::ConstantPool.\n");
    LLVM_DEBUG(dbgs() << "  Select(): Node = "; Node->dump(); dbgs() << "\n");

    SDLoc DL(Node);

    // TODO: check for splat 0..CVL-1
    // TODO: I need to return TYPE_VECTOR_I16 (maybe create a virtreg
    //            also)
    SDNode *Res = CrtDAG->getMachineNode(Connex::LDIX_H, DL, MVT::i64
                                         // TYPE_VECTOR_I16,
                                         // We add a chain edge
                                         // CrtDAG->getEntryNode()
                                         // sourceVec,
                                         // offsetVec
                                         // MVT::Other
                                         // offset,
                                         // basePtr,
                                         // opChain
    );
    LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
    LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

    ReplaceNode(Node, Res);

    return;
  }
  // NEW_FP16: required for non-vector BBs like for.body
  case ISD::LOAD: {
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::LOAD.\n");
    LLVM_DEBUG(dbgs() << "  Select(): Node = "; Node->dump(); dbgs() << "\n");

    SDLoc DL(Node);
    EVT typeVecNode;
    EVT resTy = Node->getValueType(0);

    LoadSDNode *nodeLoad = dyn_cast<LoadSDNode>(Node);
    assert(nodeLoad != NULL);

    // See http://llvm.org/doxygen/SelectionDAGNodes_8h_source.html
    SDValue opChain = nodeLoad->getOperand(0);
    SDValue basePtr = nodeLoad->getBasePtr(); // Operand 1
    SDValue offset = nodeLoad->getOffset();   // Operand 2
    LLVM_DEBUG(
        dbgs() << "Select() for LOAD: basePtr = "; (basePtr.getNode())->dump();
        dbgs() << "Select() for LOAD: offset = "; (offset.getNode())->dump();
        dbgs() << "Select() for LOAD: opChain = "; (opChain.getNode())->dump();
        dbgs() << "\n");

    EVT offsetTy = offset.getValueType();

    LLVM_DEBUG(dbgs() << "Select() for LOAD: "
                      << "resTy = " << resTy.getEVTString()
                      << ", offsetTy = " << offsetTy.getEVTString() << "\n");
    LLVM_DEBUG(dbgs() << "Select() for LOAD: offset = ";
               (offset.getNode())->dump(); dbgs() << "  basePtr = ";
               (basePtr.getNode())->dump(); dbgs() << "  opChain = ";
               (opChain.getNode())->dump(); dbgs() << "\n");

    if (resTy == MVT::f16) {
      LLVM_DEBUG(dbgs() << "Select() for LOAD: We are in the case "
                           "resTy == MVT::f16\n");

      // small-TODO: although useless, normally we should emulate f16 on BPF
      SDNode *Res16 =
          CrtDAG->getMachineNode(Connex::LDH, DL, resTy, MVT::Other,
                                 // NOT useful: MVT::Other,
                                 ////offset,
                                 // Error: <<Assertion
                                 //  `Op.getValueType() !=
                                 //    MVT::Other &&
                                 //  Op.getValueType() !=
                                 //    MVT::Glue &&
                                 //  "Chain and glue operands
                                 //   should occur at end of
                                 //   operand list!"' failed.>>
                                 //    opChain,
                                 basePtr,
                                 //
                                 // Important: Unfortunately this
                                 //   operand becomes a register,
                                 //   not an immediate: offset,
                                 CrtDAG->getTargetConstant(0, DL, MVT::i64),
                                 // TODO: we should put probably
                                 //     a different value than 0
                                 //
                                 opChain
                                 // This gives <<LLVM ERROR:
                                 //   Cannot select: t60:
                                 //   i64 = ConstantPool<half
                                 //   0xH0000> 0>> , basePtr
          );
      SDNode *Res = Res16;

      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "  Select(): Res->getOpcode() = " << Res->getOpcode()
                        << "\n");

      ReplaceNode(Node, Res);

      return;
    } // End if (resTy == MVT::f16)
    else if (resTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for LOAD: We are in the case "
                           "resTy == TYPE_VECTOR_I16\n");

      SDNode *Res =
          CrtDAG->getMachineNode(Connex::LD_INDIRECT_H, DL, TYPE_VECTOR_I16,
                                 // We add a chain edge
                                 // CrtDAG->getEntryNode()
                                 // sourceVec,
                                 // offsetVec
                                 MVT::Other,
                                 // offset,
                                 basePtr, opChain);
      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    }

    break;
  } // End ISD::LOAD
  // NEW_FP16: normally required for non-vector BBs like for.body
  case ISD::STORE: {
    LLVM_DEBUG(dbgs() << "Entered Select() for ISD::STORE.\n");
    LLVM_DEBUG(dbgs() << "  Select(): Node = "; Node->dump(); dbgs() << "\n");

    SDLoc DL(Node);
    EVT typeNode;
    EVT resTy = Node->getValueType(0);

    StoreSDNode *nodeStore = dyn_cast<StoreSDNode>(Node);
    assert(nodeStore != NULL);

    // See http://llvm.org/doxygen/SelectionDAGNodes_8h_source.html#l02076
    SDValue opChain = nodeStore->getOperand(0);
    SDValue source = nodeStore->getValue();    // Operand 1
    SDValue basePtr = nodeStore->getBasePtr(); // Operand 2
    SDValue offset = nodeStore->getOffset();   // Operand 3
    LLVM_DEBUG(
        dbgs() << "Select() for STORE: offset = "; offset.getNode()->dump();
        dbgs() << "Select() for STORE: basePtr = "; basePtr.getNode()->dump();
        dbgs() << "Select() for STORE: source = "; source.getNode()->dump();
        dbgs() << "Select() for STORE: opChain = "; opChain.getNode()->dump();
        dbgs() << "\n");

    EVT offsetTy = offset.getValueType();
    EVT sourceTy = source.getValueType();

    LLVM_DEBUG(dbgs() << "Select() for STORE: "
                      << "sourceTy = " << sourceTy.getEVTString()
                      << ", offsetTy = " << offsetTy.getEVTString()
                      << ", resTy = " << resTy.getEVTString() << "\n");

    if (sourceTy == MVT::f16) {
      /* We need to treat this case because the BPF processor doesn't
           have any floating point support.
      */
      LLVM_DEBUG(dbgs() << "Select() for STORE: We are in the case "
                           "sourceTy == MVT::f16\n");

      /*
      // TODO: Use instead of Connex::NOP_BITCONVERT_WH a new node called
      //       Connex::NOP_BITCONVERT_F16H
      SDNode *Res = CrtDAG->getMachineNode(Connex::NOP_BITCONVERT_WH,
                                           DL,
                                           MVT::Other,
                                           sourceVec,
                                           offsetVec
                                          );
      */

      /* Crappy but it works: this is a scalar f16 STORE - we simply
           avoid generating a useful instruction - we just replace it
           with "pseudo"-instruction NOP_BOGUS, which doesn't have a
           useful assembly instruction.
            */
      SDNode *Res = CrtDAG->getMachineNode( // Connex::NOP_BPF,
                                            // This must take an immediate
                                            // operand
          // An unnecessary NOP: Connex::NOP,
          Connex::NOP_BOGUS, DL, MVT::Other,
          // We add a chain edge
          // CrtDAG->getEntryNode()
          // sourceVec,
          // offsetVec
          opChain);
      // assert(0 && "I don't think it's implemented - anyhow I don't think "
      //             "it's (much) used - we should try harder with "
      //             "NOP_BITCONVERT, etc...");

      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    } else if (sourceTy == TYPE_VECTOR_I16) {
      LLVM_DEBUG(dbgs() << "Select() for STORE: We are in the case "
                           "sourceTy == TYPE_VECTOR_I16\n");

      SDNode *Res = CrtDAG->getMachineNode(Connex::ST_INDIRECT_H, DL,
                                           // We add a chain edge
                                           // CrtDAG->getEntryNode()
                                           // sourceVec,
                                           // offsetVec
                                           MVT::Other, offset, source, opChain);
      LLVM_DEBUG(dbgs() << "Select(): Node = "; Node->dump(); dbgs() << "\n");
      LLVM_DEBUG(dbgs() << "Select(): Res = "; Res->dump(); dbgs() << "\n");

      ReplaceNode(Node, Res);

      return;
    }

    break;
  } // End ISD::STORE

  // Inspired from MipsSEISelDAGToDAG.cpp
  case ISD::BUILD_VECTOR: {
    selectBUILD_VECTOR(Node);
    return;
  } // End case ISD::BUILD_VECTOR
    /*
    // Very Important: In ISelLowering the DAG Combiner changes
    //   (I think in all cases) the vector_shuffle SDNode into a BUILD_VECTOR.
    case ISD::VECTOR_SHUFFLE: {
      selectVECTOR_SHUFFLE(Node);
      return;
    } // End case ISD::VECTOR_SHUFFLE
    */
  } // End switch (Opcode)

  /*
  // Select the default instruction
  SDNode *ResNode = SelectCode(Node);

  LLVM_DEBUG(dbgs() << "=> ";
        if (ResNode == nullptr || ResNode == Node)
          Node->dump(CrtDAG);
        else
          ResNode->dump(CrtDAG);
        dbgs() << '\n');

  LLVM_DEBUG(dbgs() << "Exiting Select()\n"); // also calling SelectCode()\n");
  ReplaceNode(Node, ResNode);
  return;
  */

  // Select the default instruction
  // SDNode *ResNode = SelectCode(Node);
  SelectCode(Node);
}

FunctionPass *llvm::createConnexISelDag(ConnexTargetMachine &TM) {
  // Inspired from BPFISelDAGToDAG.cpp (from Oct 2025)
  return new ConnexDAGToDAGISelLegacy(TM);
}

// Added from MipsSEISelDAGToDAG.cpp
/// Match frameindex
bool ConnexDAGToDAGISel::selectAddrFrameIndex(SDValue Addr, SDValue &Base,
                                              SDValue &Offset) const {
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    EVT ValTy = Addr.getValueType();

    Base = CrtDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
    Offset = CrtDAG->getTargetConstant(0, SDLoc(Addr), ValTy);
    return true;
  }
  return false;
}

// Added from MipsSEISelDAGToDAG.cpp
/// Match frameindex+offset and frameindex|offset
bool ConnexDAGToDAGISel::selectAddrFrameIndexOffset(SDValue Addr, SDValue &Base,
                                                    SDValue &Offset,
                                                    unsigned OffsetBits) const {
  if (CrtDAG->isBaseWithConstantOffset(Addr)) {
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    if (isIntN(OffsetBits, CN->getSExtValue())) {
      EVT ValTy = Addr.getValueType();

      // If the first operand is a FI, get the TargetFI Node
      if (FrameIndexSDNode *FIN =
              dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
        Base = CrtDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
      else
        Base = Addr.getOperand(0);

      Offset =
          CrtDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr), ValTy);
      return true;
    }
  }
  return false;
}

// Added from MipsSEISelDAGToDAG.cpp
bool ConnexDAGToDAGISel::selectAddrRegImm10(SDValue Addr, SDValue &Base,
                                            SDValue &Offset) const {
  if (selectAddrFrameIndex(Addr, Base, Offset))
    return true;

  if (selectAddrFrameIndexOffset(Addr, Base, Offset, 10))
    return true;

  return false;
}

// Added from MipsSEISelDAGToDAG.cpp
bool ConnexDAGToDAGISel::selectAddrDefault(SDValue Addr, SDValue &Base,
                                           SDValue &Offset) const {
  Base = Addr;
  Offset = CrtDAG->getTargetConstant(0, SDLoc(Addr), Addr.getValueType());
  return true;
}

// Added from MipsSEISelDAGToDAG.cpp
bool ConnexDAGToDAGISel::selectIntAddrMSA(SDValue Addr, SDValue &Base,
                                          SDValue &Offset) const {
  if (selectAddrRegImm10(Addr, Base, Offset))
    return true;

  if (selectAddrDefault(Addr, Base, Offset))
    return true;

  return false;
}

// Added from MipsSEISelDAGToDAG.cpp
// Select constant vector splats.
//
// Returns true and sets Imm if:
// * MSA is enabled
// * N is a ISD::BUILD_VECTOR representing a constant splat
bool ConnexDAGToDAGISel::selectVSplat(SDNode *N, APInt &Imm,
                                      unsigned MinSizeInBits) const {
  LLVM_DEBUG(dbgs() << "Entered ConnexDAGToDAGISel::selectVSplat()\n");

  /*
  if (!Subtarget->hasMSA())
    return false;
  */

  BuildVectorSDNode *Node = dyn_cast<BuildVectorSDNode>(N);

  if (!Node)
    return false;

  APInt SplatValue, SplatUndef;
  unsigned SplatBitSize;
  bool HasAnyUndefs;

  if (!Node->isConstantSplat(SplatValue, SplatUndef, SplatBitSize, HasAnyUndefs,
                             MinSizeInBits,
                             // !Subtarget->isLittle()
                             false))
    return false;

  Imm = SplatValue;

  LLVM_DEBUG(dbgs() << "ConnexDAGToDAGISel::selectVSplat(): returning true\n");
  return true;
}

// Select constant vector splats.
//
// In addition to the requirements of selectVSplat(), this function returns
// true and sets Imm if:
// * The splat value is the same width as the elements of the vector
// * The splat value fits in an integer with the specified signed-ness and
//   width.
//
// This function looks through ISD::BITCAST nodes.
// TODO: This might not be appropriate for big-endian MSA since BITCAST is
//       sometimes a shuffle in big-endian mode.
//
// It's worth noting that this function is not used as part of the selection
// of ldi.[bhwd] since it does not permit using the wrong-typed ldi.[bhwd]
// instruction to achieve the desired bit pattern. ldi.[bhwd] is selected in
// MipsSEDAGToDAGISel::selectNode.
bool ConnexDAGToDAGISel::selectVSplatCommon(SDValue N, SDValue &Imm,
                                            bool Signed,
                                            unsigned ImmBitSize) const {
  LLVM_DEBUG(dbgs() << "Entered ConnexDAGToDAGISel::selectVSplatCommon()\n");

  APInt ImmValue;
  EVT EltTy = N->getValueType(0).getVectorElementType();

  if (N->getOpcode() == ISD::BITCAST)
    N = N->getOperand(0);

  if (selectVSplat(N.getNode(), ImmValue, EltTy.getSizeInBits()) &&
      ImmValue.getBitWidth() == EltTy.getSizeInBits()) {

    if ((Signed && ImmValue.isSignedIntN(ImmBitSize)) ||
        (!Signed && ImmValue.isIntN(ImmBitSize))) {
      Imm = CrtDAG->getTargetConstant(ImmValue, SDLoc(N), EltTy);
      return true;
    }
  }

  return false;
}

// Select constant vector splats.
bool ConnexDAGToDAGISel::selectVSplatUimm1(SDValue N, SDValue &Imm) const {
  LLVM_DEBUG(dbgs() << "Entered selectVSplatUimm1()\n");
  return selectVSplatCommon(N, Imm, false, 1);
}

bool ConnexDAGToDAGISel::selectVSplatUimm2(SDValue N, SDValue &Imm) const {
  return selectVSplatCommon(N, Imm, false, 2);
}

bool ConnexDAGToDAGISel::selectVSplatUimm3(SDValue N, SDValue &Imm) const {
  return selectVSplatCommon(N, Imm, false, 3);
}

// Select constant vector splats.
bool ConnexDAGToDAGISel::selectVSplatUimm4(SDValue N, SDValue &Imm) const {
  return selectVSplatCommon(N, Imm, false, 4);
}

// Select constant vector splats.
bool ConnexDAGToDAGISel::selectVSplatUimm5(SDValue N, SDValue &Imm) const {
  return selectVSplatCommon(N, Imm, false, 5);
}

// Select constant vector splats.
bool ConnexDAGToDAGISel::selectVSplatUimm6(SDValue N, SDValue &Imm) const {
  return selectVSplatCommon(N, Imm, false, 6);
}

// Select constant vector splats.
bool ConnexDAGToDAGISel::selectVSplatUimm8(SDValue N, SDValue &Imm) const {
  return selectVSplatCommon(N, Imm, false, 8);
}

// Select constant vector splats.
bool ConnexDAGToDAGISel::selectVSplatSimm5(SDValue N, SDValue &Imm) const {
  return selectVSplatCommon(N, Imm, true, 5);
}

// Select constant vector splats whose value is a power of 2.
//
// In addition to the requirements of selectVSplat(), this function returns
// true and sets Imm if:
// * The splat value is the same width as the elements of the vector
// * The splat value is a power of two.
//
// This function looks through ISD::BITCAST nodes.
// TODO: This might not be appropriate for big-endian MSA since BITCAST is
//       sometimes a shuffle in big-endian mode.
bool ConnexDAGToDAGISel::selectVSplatUimmPow2(SDValue N, SDValue &Imm) const {
  APInt ImmValue;
  EVT EltTy = N->getValueType(0).getVectorElementType();

  if (N->getOpcode() == ISD::BITCAST)
    N = N->getOperand(0);

  if (selectVSplat(N.getNode(), ImmValue, EltTy.getSizeInBits()) &&
      ImmValue.getBitWidth() == EltTy.getSizeInBits()) {
    int32_t Log2 = ImmValue.exactLogBase2();

    if (Log2 != -1) {
      Imm = CrtDAG->getTargetConstant(Log2, SDLoc(N), EltTy);
      return true;
    }
  }

  return false;
}

// Select constant vector splats whose value only has a consecutive sequence
// of left-most bits set (e.g. 0b11...1100...00).
//
// In addition to the requirements of selectVSplat(), this function returns
// true and sets Imm if:
// * The splat value is the same width as the elements of the vector
// * The splat value is a consecutive sequence of left-most bits.
//
// This function looks through ISD::BITCAST nodes.
// TODO: This might not be appropriate for big-endian MSA since BITCAST is
//       sometimes a shuffle in big-endian mode.
bool ConnexDAGToDAGISel::selectVSplatMaskL(SDValue N, SDValue &Imm) const {
  APInt ImmValue;
  EVT EltTy = N->getValueType(0).getVectorElementType();

  if (N->getOpcode() == ISD::BITCAST)
    N = N->getOperand(0);

  if (selectVSplat(N.getNode(), ImmValue, EltTy.getSizeInBits()) &&
      ImmValue.getBitWidth() == EltTy.getSizeInBits()) {
    // Extract the run of set bits starting with bit zero from the bitwise
    // inverse of ImmValue, and test that the inverse of this is the same
    // as the original value.
    if (ImmValue == ~(~ImmValue & ~(~ImmValue + 1))) {

      Imm = CrtDAG->getTargetConstant(ImmValue.popcount(),
                                      SDLoc(N), EltTy);
      return true;
    }
  }

  return false;
}

// Select constant vector splats whose value only has a consecutive sequence
// of right-most bits set (e.g. 0b00...0011...11).
//
// In addition to the requirements of selectVSplat(), this function returns
// true and sets Imm if:
// * The splat value is the same width as the elements of the vector
// * The splat value is a consecutive sequence of right-most bits.
//
// This function looks through ISD::BITCAST nodes.
// TODO: This might not be appropriate for big-endian MSA since BITCAST is
//       sometimes a shuffle in big-endian mode.
bool ConnexDAGToDAGISel::selectVSplatMaskR(SDValue N, SDValue &Imm) const {
  APInt ImmValue;
  EVT EltTy = N->getValueType(0).getVectorElementType();

  if (N->getOpcode() == ISD::BITCAST)
    N = N->getOperand(0);

  if (selectVSplat(N.getNode(), ImmValue, EltTy.getSizeInBits()) &&
      ImmValue.getBitWidth() == EltTy.getSizeInBits()) {
    // Extract the run of set bits starting with bit zero, and test that the
    // result is the same as the original value
    if (ImmValue == (ImmValue & ~(ImmValue + 1))) {
      Imm = CrtDAG->getTargetConstant(ImmValue.popcount(),
                                      SDLoc(N), EltTy);
      return true;
    }
  }

  return false;
}

bool ConnexDAGToDAGISel::selectVSplatUimmInvPow2(SDValue N,
                                                 SDValue &Imm) const {
  APInt ImmValue;
  EVT EltTy = N->getValueType(0).getVectorElementType();

  if (N->getOpcode() == ISD::BITCAST)
    N = N->getOperand(0);

  if (selectVSplat(N.getNode(), ImmValue, EltTy.getSizeInBits()) &&
      ImmValue.getBitWidth() == EltTy.getSizeInBits()) {
    int32_t Log2 = (~ImmValue).exactLogBase2();

    if (Log2 != -1) {
      Imm = CrtDAG->getTargetConstant(Log2, SDLoc(N), EltTy);
      return true;
    }
  }

  return false;
}
