//===- WebAssemblyInstructionSelector.cpp ------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// WebAssembly.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "GISel/WebAssemblyRegisterBankInfo.h"
#include "MCTargetDesc/WebAssemblyMCTargetDesc.h"
#include "Utils/WasmAddressSpaces.h"
#include "Utils/WebAssemblyTypeUtilities.h"
#include "WebAssemblyRegisterInfo.h"
#include "WebAssemblySubtarget.h"
#include "WebAssemblyTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/CodeGen/MachineOperand.h"
#include "llvm/CodeGen/RegisterBank.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/IntrinsicsWebAssembly.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Support/ErrorHandling.h"

#define DEBUG_TYPE "wasm-isel"

using namespace llvm;

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class WebAssemblyInstructionSelector : public InstructionSelector {
public:
  WebAssemblyInstructionSelector(const WebAssemblyTargetMachine &TM,
                                 const WebAssemblySubtarget &STI,
                                 const WebAssemblyRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;

  InstructionSelector::ComplexRendererFns
  selectAddrOperands32(MachineOperand &Root) const;
  InstructionSelector::ComplexRendererFns
  selectAddrOperands64(MachineOperand &Root) const;

  static const char *getName() { return DEBUG_TYPE; }

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  bool selectCopy(MachineInstr &I, MachineRegisterInfo &MRI) const;

  InstructionSelector::ComplexRendererFns
  selectAddrOperands(LLT AddrType, unsigned int ConstOpc,
                     MachineOperand &Root) const;

  const WebAssemblyTargetMachine &TM;
  const WebAssemblySubtarget &STI;
  const WebAssemblyInstrInfo &TII;
  const WebAssemblyRegisterInfo &TRI;
  const WebAssemblyRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

WebAssemblyInstructionSelector::WebAssemblyInstructionSelector(
    const WebAssemblyTargetMachine &TM, const WebAssemblySubtarget &STI,
    const WebAssemblyRegisterBankInfo &RBI)
    : TM(TM), STI(STI), TII(*STI.getInstrInfo()), TRI(*STI.getRegisterInfo()),
      RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands(LLT AddrType,
                                                   unsigned int ConstOpc,
                                                   MachineOperand &Root) const {

  if (!Root.isReg())
    return std::nullopt;

  MachineRegisterInfo &MRI =
      Root.getParent()->getParent()->getParent()->getRegInfo();
  MachineInstr &RootDef = *MRI.getVRegDef(Root.getReg());

  if (RootDef.getOpcode() == TargetOpcode::G_PTR_ADD) {
    // RootDef will always be G_PTR_ADD
    MachineOperand &LHS = RootDef.getOperand(1);

    MachineOperand &RHS = RootDef.getOperand(2);
    MachineInstr &LHSDef = *MRI.getVRegDef(LHS.getReg());
    MachineInstr &RHSDef =
        *MRI.getVRegDef(RHS.getReg()); // Will always be G_CONSTANT

    // WebAssembly constant offsets are performed as unsigned with infinite
    // precision, so we need to check for NoUnsignedWrap so that we don't fold
    // and offset for an add that needs wrapping.
    if (RootDef.getFlag(MachineInstr::MIFlag::NoUWrap)) {
      for (size_t i = 0; i < 2; ++i) {
        // MachineOperand &Op = i == 0 ? LHS : RHS;
        MachineInstr &OpDef = i == 0 ? LHSDef : RHSDef;
        MachineOperand &OtherOp = i == 0 ? RHS : LHS;
        // MachineInstr &OtherOpDef = i == 0 ? RHSDef : LHSDef;

        if (OpDef.getOpcode() == TargetOpcode::G_CONSTANT) {
          auto Offset = OpDef.getOperand(1).getCImm()->getZExtValue();
          auto Addr = OtherOp;

          return {{
              [=](MachineInstrBuilder &MIB) { MIB.addImm(Offset); },
              [=](MachineInstrBuilder &MIB) { MIB.add(Addr); },
          }};
        }

        if (!TM.isPositionIndependent()) {
          if (OpDef.getOpcode() == TargetOpcode::G_GLOBAL_VALUE) {
            auto Offset = OpDef.getOperand(1).getGlobal();
            auto Addr = OtherOp;

            return {{
                [=](MachineInstrBuilder &MIB) { MIB.addGlobalAddress(Offset); },
                [=](MachineInstrBuilder &MIB) { MIB.add(Addr); },
            }};
          }
        }
      }
    }
  }

  if (RootDef.getOpcode() == TargetOpcode::G_CONSTANT) {
    auto Offset = RootDef.getOperand(1).getCImm()->getZExtValue();
    auto Addr = MRI.createGenericVirtualRegister(AddrType);

    MachineIRBuilder B(RootDef);

    auto MIB = B.buildInstr(ConstOpc).addDef(Addr).addImm(0);
    assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return {{
        [=](MachineInstrBuilder &MIB) { MIB.addImm(Offset); },
        [=](MachineInstrBuilder &MIB) { MIB.addReg(Addr); },
    }};
  }

  if (!TM.isPositionIndependent() &&
      RootDef.getOpcode() == TargetOpcode::G_GLOBAL_VALUE) {
    auto *Offset = RootDef.getOperand(1).getGlobal();
    auto Addr = MRI.createGenericVirtualRegister(AddrType);

    MachineIRBuilder B(RootDef);

    auto MIB = B.buildInstr(ConstOpc).addDef(Addr).addImm(0);
    assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return {{
        [=](MachineInstrBuilder &MIB) { MIB.addGlobalAddress(Offset); },
        [=](MachineInstrBuilder &MIB) { MIB.addReg(Addr); },
    }};
  }

  return {{
      [=](MachineInstrBuilder &MIB) { MIB.addImm(0); },
      [=](MachineInstrBuilder &MIB) { MIB.add(Root); },
  }};
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands32(
    MachineOperand &Root) const {
  return selectAddrOperands(LLT::scalar(32), WebAssembly::CONST_I32, Root);
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands64(
    MachineOperand &Root) const {
  return selectAddrOperands(LLT::scalar(64), WebAssembly::CONST_I64, Root);
}

bool WebAssemblyInstructionSelector::selectCopy(
    MachineInstr &I, MachineRegisterInfo &MRI) const {
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  const TargetRegisterClass *DstRC;
  if (DstReg.isPhysical()) {
    switch (DstReg.id()) {
    case WebAssembly::SP32:
      DstRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::SP64:
      DstRC = &WebAssembly::I64RegClass;
      break;
    default:
      llvm_unreachable("Copy to physical register other than SP32 or SP64?");
    }
  } else {
    DstRC = MRI.getRegClassOrNull(DstReg);
  }

  if (!DstRC) {
    const RegisterBank *DstBank = MRI.getRegBankOrNull(DstReg);
    if (!DstBank) {
      llvm_unreachable("Selecting copy with dst reg with no bank?");
    }

    switch (DstBank->getID()) {
    case WebAssembly::I32RegBankID:
      DstRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::I64RegBankID:
      DstRC = &WebAssembly::I64RegClass;
      break;
    case WebAssembly::F32RegBankID:
      DstRC = &WebAssembly::F32RegClass;
      break;
    case WebAssembly::F64RegBankID:
      DstRC = &WebAssembly::F64RegClass;
      break;
    default:
      llvm_unreachable("Unknown reg bank to reg class mapping?");
    }
    if (!constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, I, *DstRC,
                                  I.getOperand(0))) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }

  const TargetRegisterClass *SrcRC;
  if (SrcReg.isPhysical()) {
    switch (SrcReg.id()) {
    case WebAssembly::SP32:
      SrcRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::SP64:
      SrcRC = &WebAssembly::I64RegClass;
      break;
    default:
      llvm_unreachable("Copy to physical register other than SP32 or SP64?");
    }
  } else {
    SrcRC = MRI.getRegClassOrNull(SrcReg);
  }
  if (!SrcRC) {
    const RegisterBank *SrcBank = MRI.getRegBankOrNull(SrcReg);
    if (!SrcBank) {
      llvm_unreachable("Selecting copy with src reg with no bank?");
    }

    switch (SrcBank->getID()) {
    case WebAssembly::I32RegBankID:
      SrcRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::I64RegBankID:
      SrcRC = &WebAssembly::I64RegClass;
      break;
    case WebAssembly::F32RegBankID:
      SrcRC = &WebAssembly::F32RegClass;
      break;
    case WebAssembly::F64RegBankID:
      SrcRC = &WebAssembly::F64RegClass;
      break;
    default:
      llvm_unreachable("Unknown reg bank to reg class mapping?");
    }
    if (!constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, I, *SrcRC,
                                  I.getOperand(1))) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }

  assert(TRI.getRegSizeInBits(*DstRC) == TRI.getRegSizeInBits(*SrcRC) &&
         "Copy between mismatching register sizes?");

  if (DstRC != SrcRC) {
    if (DstRC == &WebAssembly::I32RegClass &&
        SrcRC == &WebAssembly::F32RegClass) {
      I.setDesc(TII.get(WebAssembly::I32_REINTERPRET_F32));
      return true;
    }

    if (DstRC == &WebAssembly::F32RegClass &&
        SrcRC == &WebAssembly::I32RegClass) {
      I.setDesc(TII.get(WebAssembly::F32_REINTERPRET_I32));
      return true;
    }

    if (DstRC == &WebAssembly::I64RegClass &&
        SrcRC == &WebAssembly::F64RegClass) {
      I.setDesc(TII.get(WebAssembly::I64_REINTERPRET_F64));
      return true;
    }

    if (DstRC == &WebAssembly::F64RegClass &&
        SrcRC == &WebAssembly::I64RegClass) {
      I.setDesc(TII.get(WebAssembly::F64_REINTERPRET_I64));
      return true;
    }

    llvm_unreachable("Found bitcast/copy edge case.");
  }

  return true;
}

static const TargetRegisterClass *
getRegClassForTypeOnBank(const RegisterBank &RB) {
  switch (RB.getID()) {
  case WebAssembly::I32RegBankID:
    return &WebAssembly::I32RegClass;
  case WebAssembly::I64RegBankID:
    return &WebAssembly::I64RegClass;
  case WebAssembly::F32RegBankID:
    return &WebAssembly::F32RegClass;
  case WebAssembly::F64RegBankID:
    return &WebAssembly::F64RegClass;
  case WebAssembly::EXNREFRegBankID:
    return &WebAssembly::EXNREFRegClass;
  case WebAssembly::EXTERNREFRegBankID:
    return &WebAssembly::EXTERNREFRegClass;
  case WebAssembly::FUNCREFRegBankID:
    return &WebAssembly::FUNCREFRegClass;
    // case WebAssembly::V128RegBankID:
    //   return &WebAssembly::V128RegClass;
  }

  return nullptr;
}

bool WebAssemblyInstructionSelector::select(MachineInstr &I) {
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();
  const TargetLowering &TLI = *STI.getTargetLowering();

  if (!I.isPreISelOpcode() || I.getOpcode() == TargetOpcode::G_PHI) {
    if (I.getOpcode() == TargetOpcode::PHI ||
        I.getOpcode() == TargetOpcode::G_PHI) {
      const Register DefReg = I.getOperand(0).getReg();
      const LLT DefTy = MRI.getType(DefReg);

      const RegClassOrRegBank &RegClassOrBank =
          MRI.getRegClassOrRegBank(DefReg);

      const TargetRegisterClass *DefRC =
          dyn_cast<const TargetRegisterClass *>(RegClassOrBank);

      if (!DefRC) {
        if (!DefTy.isValid()) {
          LLVM_DEBUG(dbgs() << "PHI operand has no type, not a gvreg?\n");
          return false;
        }
        const RegisterBank &RB = *cast<const RegisterBank *>(RegClassOrBank);
        DefRC = getRegClassForTypeOnBank(RB);
        if (!DefRC) {
          LLVM_DEBUG(dbgs() << "PHI operand has unexpected size/bank\n");
          return false;
        }
      }

      I.setDesc(TII.get(TargetOpcode::PHI));

      return RBI.constrainGenericRegister(DefReg, *DefRC, MRI) != nullptr;
    }
  }

  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCopy(I, MRI);

    return true;
  }

  if (selectImpl(I, *CoverageInfo))
    return true;

  using namespace TargetOpcode;

  auto PointerWidth = MF.getDataLayout().getPointerSizeInBits();
  auto PtrIsI64 = PointerWidth == 64;

  switch (I.getOpcode()) {
  case G_IMPLICIT_DEF: {
    const Register DefReg = I.getOperand(0).getReg();
    const LLT DefTy = MRI.getType(DefReg);

    const RegClassOrRegBank &RegClassOrBank = MRI.getRegClassOrRegBank(DefReg);

    const TargetRegisterClass *DefRC =
        dyn_cast<const TargetRegisterClass *>(RegClassOrBank);

    if (!DefRC) {
      if (!DefTy.isValid()) {
        LLVM_DEBUG(
            dbgs() << "IMPLICIT_DEF operand has no type, not a gvreg?\n");
        return false;
      }
      const RegisterBank &RB = *cast<const RegisterBank *>(RegClassOrBank);
      DefRC = getRegClassForTypeOnBank(RB);
      if (!DefRC) {
        LLVM_DEBUG(dbgs() << "IMPLICIT_DEF operand has unexpected size/bank\n");
        return false;
      }
    }

    I.setDesc(TII.get(TargetOpcode::IMPLICIT_DEF));

    return RBI.constrainGenericRegister(DefReg, *DefRC, MRI) != nullptr;
    return true;
  }
  case G_BRJT: {
    auto JT = I.getOperand(1);
    auto Index = I.getOperand(2);

    assert(JT.getTargetFlags() == 0 && "WebAssembly doesn't set target flags");

    MachineIRBuilder B(I);

    MachineJumpTableInfo *MJTI = MF.getJumpTableInfo();
    const auto &MBBs = MJTI->getJumpTables()[JT.getIndex()].MBBs;

    auto MIB = B.buildInstr(PtrIsI64 ? WebAssembly::BR_TABLE_I64
                                     : WebAssembly::BR_TABLE_I32)
                   .add(Index);

    for (auto *MBB : MBBs)
      MIB.addMBB(MBB);

    // Add the first MBB as a dummy default target for now. This will be
    // replaced with the proper default target (and the preceding range check
    // eliminated) if possible by WebAssemblyFixBrTableDefaults.
    MIB.addMBB(*MBBs.begin());

    assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    I.eraseFromParent();
    return true;
  }
  case G_PTR_ADD: {
    assert(MRI.getType(I.getOperand(0).getReg()).isPointer() &&
           "G_PTR_ADD selection fell-through with non-pointer?");

    auto PointerWidth = MF.getDataLayout().getPointerSizeInBits();
    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::ADD_I64
                                         : WebAssembly::ADD_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_PTRTOINT: {
    assert(MRI.getType(I.getOperand(1).getReg()).isPointer() &&
           "G_PTRTOINT selection fell-through with non-pointer?");

    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::COPY_I64
                                         : WebAssembly::COPY_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_INTTOPTR: {
    assert(MRI.getType(I.getOperand(0).getReg()).isPointer() &&
           "G_INTTOPTR selection fell-through with non-pointer?");

    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::COPY_I64
                                         : WebAssembly::COPY_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_FRAME_INDEX: {
    MachineIRBuilder B(I);

    I.setDesc(
        TII.get(PtrIsI64 ? WebAssembly::COPY_I64 : WebAssembly::COPY_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");
    return true;
  }
  case G_GLOBAL_VALUE:
    assert(I.getOperand(1).getTargetFlags() == 0 &&
           "Unexpected target flags on generic G_GLOBAL_VALUE instruction");
    assert(WebAssembly::isValidAddressSpace(
               MRI.getType(I.getOperand(0).getReg()).getAddressSpace()) &&
           "Invalid address space for WebAssembly target");

    unsigned OperandFlags = 0;
    const llvm::GlobalValue *GV = I.getOperand(1).getGlobal();
    // Since WebAssembly tables cannot yet be shared accross modules, we don't
    // need special treatment for tables in PIC mode.
    if (TLI.isPositionIndependent() &&
        !WebAssembly::isWebAssemblyTableType(GV->getValueType())) {
      if (TM.shouldAssumeDSOLocal(GV)) {
        const char *BaseName;
        if (GV->getValueType()->isFunctionTy()) {
          BaseName = MF.createExternalSymbolName("__table_base");
          OperandFlags = WebAssemblyII::MO_TABLE_BASE_REL;
        } else {
          BaseName = MF.createExternalSymbolName("__memory_base");
          OperandFlags = WebAssemblyII::MO_MEMORY_BASE_REL;
        }
        MachineIRBuilder B(I);

        auto MemBase =
            MRI.createGenericVirtualRegister(LLT::pointer(0, PointerWidth));
        MRI.setRegClass(MemBase, PtrIsI64 ? &WebAssembly::I64RegClass
                                          : &WebAssembly::I32RegClass);
        auto Offset =
            MRI.createGenericVirtualRegister(LLT::pointer(0, PointerWidth));
        MRI.setRegClass(Offset, PtrIsI64 ? &WebAssembly::I64RegClass
                                         : &WebAssembly::I32RegClass);

        B.buildInstr(PtrIsI64 ? WebAssembly::GLOBAL_GET_I64
                              : WebAssembly::GLOBAL_GET_I32)
            .addDef(MemBase)
            .addExternalSymbol(BaseName);

        B.buildInstr(PtrIsI64 ? WebAssembly::CONST_I64 : WebAssembly::CONST_I32)
            .addDef(Offset)
            .addGlobalAddress(GV, I.getOperand(1).getOffset(), OperandFlags);

        auto MIB =
            B.buildInstr(PtrIsI64 ? WebAssembly::ADD_I64 : WebAssembly::ADD_I32)
                .addDef(I.getOperand(0).getReg())
                .addReg(MemBase)
                .addReg(Offset);
        assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
               "Couldn't constrain registers for instruction");

        I.eraseFromParent();
        return true;
      }
      OperandFlags = WebAssemblyII::MO_GOT;
    }

    auto NewOpc = MF.getDataLayout().getPointerSizeInBits() == 64
                      ? WebAssembly::CONST_I64
                      : WebAssembly::CONST_I32;

    if (OperandFlags & WebAssemblyII::MO_GOT) {
      NewOpc = MF.getDataLayout().getPointerSizeInBits() == 64
                   ? WebAssembly::GLOBAL_GET_I64
                   : WebAssembly::GLOBAL_GET_I32;
    }

    I.setDesc(TII.get(NewOpc));
    I.getOperand(1).setTargetFlags(OperandFlags);
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }

  return false;
}

namespace llvm {
InstructionSelector *
createWebAssemblyInstructionSelector(const WebAssemblyTargetMachine &TM,
                                     const WebAssemblySubtarget &Subtarget,
                                     const WebAssemblyRegisterBankInfo &RBI) {
  return new WebAssemblyInstructionSelector(TM, Subtarget, RBI);
}
} // namespace llvm
