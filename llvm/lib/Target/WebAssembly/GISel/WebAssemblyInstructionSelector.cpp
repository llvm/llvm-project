//===- WebAssemblyInstructionSelector.cpp ------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// WebAssembly.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "GISel/WebAssemblyRegisterBankInfo.h"
#include "MCTargetDesc/WebAssemblyMCTargetDesc.h"
#include "Utils/WasmAddressSpaces.h"
#include "Utils/WebAssemblyTypeUtilities.h"
#include "WebAssemblyMachineFunctionInfo.h"
#include "WebAssemblyRegisterInfo.h"
#include "WebAssemblySubtarget.h"
#include "WebAssemblyTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/CodeGen/MachineMemOperand.h"
#include "llvm/CodeGen/MachineOperand.h"
#include "llvm/CodeGen/RegisterBank.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/IntrinsicsWebAssembly.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Support/ErrorHandling.h"

#define DEBUG_TYPE "wasm-isel"

using namespace llvm;

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class WebAssemblyInstructionSelector : public InstructionSelector {
public:
  // From FastISel
  // All possible address modes.
  class Address {
  public:
    enum BaseKind { RegBase, FrameIndexBase };

  private:
    BaseKind Kind = RegBase;
    union {
      unsigned Reg;
      int FI;
    } Base;

    // Whether the base has been determined yet
    bool IsBaseSet = false;

    int64_t Offset = 0;

    const GlobalValue *GV = nullptr;

  public:
    // Innocuous defaults for our address.
    Address() { Base.Reg = 0; }
    void setKind(BaseKind K) {
      assert(!isSet() && "Can't change kind with non-zero base");
      Kind = K;
    }
    BaseKind getKind() const { return Kind; }
    bool isRegBase() const { return Kind == RegBase; }
    bool isFIBase() const { return Kind == FrameIndexBase; }
    void setReg(unsigned Reg) {
      assert(isRegBase() && "Invalid base register access!");
      assert(!IsBaseSet && "Base cannot be reset");
      Base.Reg = Reg;
      IsBaseSet = true;
    }
    unsigned getReg() const {
      assert(isRegBase() && "Invalid base register access!");
      return Base.Reg;
    }
    void setFI(unsigned FI) {
      assert(isFIBase() && "Invalid base frame index access!");
      assert(!IsBaseSet && "Base cannot be reset");
      Base.FI = FI;
      IsBaseSet = true;
    }
    unsigned getFI() const {
      assert(isFIBase() && "Invalid base frame index access!");
      return Base.FI;
    }

    void setOffset(int64_t NewOffset) {
      assert(NewOffset >= 0 && "Offsets must be non-negative");
      Offset = NewOffset;
    }
    int64_t getOffset() const { return Offset; }
    void setGlobalValue(const GlobalValue *G) { GV = G; }
    const GlobalValue *getGlobalValue() const { return GV; }
    bool isSet() const { return IsBaseSet; }
  };

  WebAssemblyInstructionSelector(const WebAssemblyTargetMachine &TM,
                                 const WebAssemblySubtarget &STI,
                                 const WebAssemblyRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;

  InstructionSelector::ComplexRendererFns
  selectAddrOperands32(MachineOperand &Root) const;
  InstructionSelector::ComplexRendererFns
  selectAddrOperands64(MachineOperand &Root) const;

  static const char *getName() { return DEBUG_TYPE; }

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  bool selectCopy(MachineInstr &I, MachineRegisterInfo &MRI) const;

  bool computeAddress(const MachineInstr &MI, Address &Addr) const;

  InstructionSelector::ComplexRendererFns
  selectAddrOperands(LLT AddrType, unsigned int ConstOpc,
                     MachineOperand &Root) const;

  const WebAssemblyTargetMachine &TM;
  const WebAssemblySubtarget &STI;
  const WebAssemblyInstrInfo &TII;
  const WebAssemblyRegisterInfo &TRI;
  const WebAssemblyRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

WebAssemblyInstructionSelector::WebAssemblyInstructionSelector(
    const WebAssemblyTargetMachine &TM, const WebAssemblySubtarget &STI,
    const WebAssemblyRegisterBankInfo &RBI)
    : TM(TM), STI(STI), TII(*STI.getInstrInfo()), TRI(*STI.getRegisterInfo()),
      RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

bool WebAssemblyInstructionSelector::computeAddress(const MachineInstr &MI,
                                                    Address &Addr) const {
  unsigned Opcode = MI.getOpcode();
  auto &MRI = MI.getMF()->getRegInfo();

  if (MI.getNumDefs() == 0 || !MI.getOperand(0).isReg())
    return false;

  Register Def = MI.getOperand(0).getReg();

  if (!Def.isValid() || !MRI.getType(Def).isPointer() ||
      !(MRI.getType(Def).getAddressSpace() == 0))
    return false;

  switch (Opcode) {
  default:
    break;
  case TargetOpcode::G_GLOBAL_VALUE: {
    if (Addr.getGlobalValue())
      return false;

    if (TM.isPositionIndependent() ||
        MI.getOperand(1).getGlobal()->isThreadLocal()) {
      if (Addr.isSet())
        return false;

      Addr.setReg(Def);
      return true;
    }

    uint64_t TmpOffset = Addr.getOffset() + MI.getOperand(1).getOffset();
    if (int64_t(TmpOffset) < 0)
      return false;

    Addr.setGlobalValue(MI.getOperand(1).getGlobal());
    Addr.setOffset(TmpOffset);
    return true;
  }
  case TargetOpcode::G_FRAME_INDEX: {
    if (Addr.isSet()) {
      return false;
    }
    Addr.setKind(Address::FrameIndexBase);
    Addr.setFI(MI.getOperand(1).getIndex());
    return true;
  }
  case TargetOpcode::G_PTR_ADD: {
    // We should not fold operands into an offset when 'nuw' (no unsigned wrap)
    // is not present, because the address calculation does not wrap.
    if (!MI.getFlag(MachineInstr::MIFlag::NoUWrap))
      break;

    const MachineInstr *LHS = MRI.getVRegDef(MI.getOperand(1).getReg());
    const MachineInstr *RHS = MRI.getVRegDef(MI.getOperand(2).getReg());

    if (LHS->getOpcode() == TargetOpcode::G_CONSTANT)
      std::swap(LHS, RHS);

    if (RHS->getOpcode() == TargetOpcode::G_CONSTANT) {
      uint64_t TmpOffset =
          Addr.getOffset() + RHS->getOperand(1).getCImm()->getSExtValue();
      if (int64_t(TmpOffset) >= 0) {
        Addr.setOffset(TmpOffset);
        return computeAddress(*LHS, Addr);
      }
    }

    Address Backup = Addr;
    if (computeAddress(*LHS, Addr) && computeAddress(*RHS, Addr))
      return true;
    Addr = Backup;

    break;
  }
  }

  if (Addr.isSet())
    return false;
  Addr.setReg(Def);
  return Addr.getReg() != 0;
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands(LLT AddrType,
                                                   unsigned int ConstOpc,
                                                   MachineOperand &Root) const {

  if (!Root.isReg())
    return std::nullopt;

  MachineRegisterInfo &MRI =
      Root.getParent()->getParent()->getParent()->getRegInfo();
  MachineInstr &RootDef = *MRI.getVRegDef(Root.getReg());

  Address Addr = Address();

  if (!computeAddress(RootDef, Addr)) {
    // something inhibited the complex matching logic
    // just fall back to using the register as base, and 0 offset
    Addr = Address();
    Addr.setReg(Root.getReg());
  }

  if (Addr.isRegBase()) {
    unsigned Reg = Addr.getReg();
    if (Reg == 0) {
      Reg = MRI.createGenericVirtualRegister(AddrType);

      MachineIRBuilder B(RootDef);

      auto MIB = B.buildInstr(ConstOpc).addDef(Reg).addImm(0);
      assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
             "Couldn't constrain registers for instruction");
      Addr.setReg(Reg);
    }
  }

  return {{
      [=](MachineInstrBuilder &MIB) {
        Addr.getGlobalValue()
            ? MIB.addGlobalAddress(Addr.getGlobalValue(), Addr.getOffset())
            : MIB.addImm(Addr.getOffset());
      },
      [=](MachineInstrBuilder &MIB) {
        Addr.isFIBase() ? MIB.addFrameIndex(Addr.getFI())
                        : MIB.addReg(Addr.getReg());
      },
  }};
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands32(
    MachineOperand &Root) const {
  return selectAddrOperands(LLT::scalar(32), WebAssembly::CONST_I32, Root);
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands64(
    MachineOperand &Root) const {
  return selectAddrOperands(LLT::scalar(64), WebAssembly::CONST_I64, Root);
}

bool WebAssemblyInstructionSelector::selectCopy(
    MachineInstr &I, MachineRegisterInfo &MRI) const {
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  const TargetRegisterClass *DstRC;
  if (DstReg.isPhysical()) {
    switch (DstReg.id()) {
    case WebAssembly::SP32:
      DstRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::SP64:
      DstRC = &WebAssembly::I64RegClass;
      break;
    default:
      llvm_unreachable("Copy to physical register other than SP32 or SP64?");
    }
  } else {
    DstRC = MRI.getRegClassOrNull(DstReg);
  }

  if (!DstRC) {
    const RegisterBank *DstBank = MRI.getRegBankOrNull(DstReg);
    if (!DstBank) {
      llvm_unreachable("Selecting copy with dst reg with no bank?");
    }

    switch (DstBank->getID()) {
    case WebAssembly::I32RegBankID:
      DstRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::I64RegBankID:
      DstRC = &WebAssembly::I64RegClass;
      break;
    case WebAssembly::F32RegBankID:
      DstRC = &WebAssembly::F32RegClass;
      break;
    case WebAssembly::F64RegBankID:
      DstRC = &WebAssembly::F64RegClass;
      break;
    default:
      llvm_unreachable("Unknown reg bank to reg class mapping?");
    }
    if (!constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, I, *DstRC,
                                  I.getOperand(0))) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }

  const TargetRegisterClass *SrcRC;
  if (SrcReg.isPhysical()) {
    switch (SrcReg.id()) {
    case WebAssembly::SP32:
      SrcRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::SP64:
      SrcRC = &WebAssembly::I64RegClass;
      break;
    default:
      llvm_unreachable("Copy to physical register other than SP32 or SP64?");
    }
  } else {
    SrcRC = MRI.getRegClassOrNull(SrcReg);
  }
  if (!SrcRC) {
    const RegisterBank *SrcBank = MRI.getRegBankOrNull(SrcReg);
    if (!SrcBank) {
      llvm_unreachable("Selecting copy with src reg with no bank?");
    }

    switch (SrcBank->getID()) {
    case WebAssembly::I32RegBankID:
      SrcRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::I64RegBankID:
      SrcRC = &WebAssembly::I64RegClass;
      break;
    case WebAssembly::F32RegBankID:
      SrcRC = &WebAssembly::F32RegClass;
      break;
    case WebAssembly::F64RegBankID:
      SrcRC = &WebAssembly::F64RegClass;
      break;
    default:
      llvm_unreachable("Unknown reg bank to reg class mapping?");
    }
    if (!constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, I, *SrcRC,
                                  I.getOperand(1))) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }

  assert(TRI.getRegSizeInBits(*DstRC) == TRI.getRegSizeInBits(*SrcRC) &&
         "Copy between mismatching register sizes?");

  if (DstRC != SrcRC) {
    if (DstRC == &WebAssembly::I32RegClass &&
        SrcRC == &WebAssembly::F32RegClass) {
      I.setDesc(TII.get(WebAssembly::I32_REINTERPRET_F32));
      return true;
    }

    if (DstRC == &WebAssembly::F32RegClass &&
        SrcRC == &WebAssembly::I32RegClass) {
      I.setDesc(TII.get(WebAssembly::F32_REINTERPRET_I32));
      return true;
    }

    if (DstRC == &WebAssembly::I64RegClass &&
        SrcRC == &WebAssembly::F64RegClass) {
      I.setDesc(TII.get(WebAssembly::I64_REINTERPRET_F64));
      return true;
    }

    if (DstRC == &WebAssembly::F64RegClass &&
        SrcRC == &WebAssembly::I64RegClass) {
      I.setDesc(TII.get(WebAssembly::F64_REINTERPRET_I64));
      return true;
    }

    llvm_unreachable("Found bitcast/copy edge case.");
  }

  return true;
}

static const TargetRegisterClass *
getRegClassForTypeOnBank(const RegisterBank &RB) {
  switch (RB.getID()) {
  case WebAssembly::I32RegBankID:
    return &WebAssembly::I32RegClass;
  case WebAssembly::I64RegBankID:
    return &WebAssembly::I64RegClass;
  case WebAssembly::F32RegBankID:
    return &WebAssembly::F32RegClass;
  case WebAssembly::F64RegBankID:
    return &WebAssembly::F64RegClass;
  case WebAssembly::EXNREFRegBankID:
    return &WebAssembly::EXNREFRegClass;
  case WebAssembly::EXTERNREFRegBankID:
    return &WebAssembly::EXTERNREFRegClass;
  case WebAssembly::FUNCREFRegBankID:
    return &WebAssembly::FUNCREFRegClass;
    // case WebAssembly::V128RegBankID:
    //   return &WebAssembly::V128RegClass;
  }

  return nullptr;
}

bool WebAssemblyInstructionSelector::select(MachineInstr &I) {
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();
  const TargetLowering &TLI = *STI.getTargetLowering();

  if (!I.isPreISelOpcode() || I.getOpcode() == TargetOpcode::G_PHI) {
    if (I.getOpcode() == TargetOpcode::PHI ||
        I.getOpcode() == TargetOpcode::G_PHI) {
      const Register DefReg = I.getOperand(0).getReg();
      const LLT DefTy = MRI.getType(DefReg);

      const RegClassOrRegBank &RegClassOrBank =
          MRI.getRegClassOrRegBank(DefReg);

      const TargetRegisterClass *DefRC =
          dyn_cast<const TargetRegisterClass *>(RegClassOrBank);

      if (!DefRC) {
        if (!DefTy.isValid()) {
          LLVM_DEBUG(dbgs() << "PHI operand has no type, not a gvreg?\n");
          return false;
        }
        const RegisterBank &RB = *cast<const RegisterBank *>(RegClassOrBank);
        DefRC = getRegClassForTypeOnBank(RB);
        if (!DefRC) {
          LLVM_DEBUG(dbgs() << "PHI operand has unexpected size/bank\n");
          return false;
        }
      }

      I.setDesc(TII.get(TargetOpcode::PHI));

      return RBI.constrainGenericRegister(DefReg, *DefRC, MRI) != nullptr;
    }
  }

  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCopy(I, MRI);

    return true;
  }

  if (selectImpl(I, *CoverageInfo))
    return true;

  using namespace TargetOpcode;

  auto PointerWidth = MF.getDataLayout().getPointerSizeInBits();
  auto PtrIsI64 = PointerWidth == 64;

  switch (I.getOpcode()) {
  case G_IMPLICIT_DEF: {
    const Register DefReg = I.getOperand(0).getReg();
    const LLT DefTy = MRI.getType(DefReg);

    const RegClassOrRegBank &RegClassOrBank = MRI.getRegClassOrRegBank(DefReg);

    const TargetRegisterClass *DefRC =
        dyn_cast<const TargetRegisterClass *>(RegClassOrBank);

    if (!DefRC) {
      if (!DefTy.isValid()) {
        LLVM_DEBUG(
            dbgs() << "IMPLICIT_DEF operand has no type, not a gvreg?\n");
        return false;
      }
      const RegisterBank &RB = *cast<const RegisterBank *>(RegClassOrBank);
      DefRC = getRegClassForTypeOnBank(RB);
      if (!DefRC) {
        LLVM_DEBUG(dbgs() << "IMPLICIT_DEF operand has unexpected size/bank\n");
        return false;
      }
    }

    I.setDesc(TII.get(TargetOpcode::IMPLICIT_DEF));

    return RBI.constrainGenericRegister(DefReg, *DefRC, MRI) != nullptr;
    return true;
  }
  case G_BRJT: {
    auto JT = I.getOperand(1);
    auto Index = I.getOperand(2);

    assert(JT.getTargetFlags() == 0 && "WebAssembly doesn't set target flags");

    MachineIRBuilder B(I);

    MachineJumpTableInfo *MJTI = MF.getJumpTableInfo();
    const auto &MBBs = MJTI->getJumpTables()[JT.getIndex()].MBBs;

    auto MIB = B.buildInstr(PtrIsI64 ? WebAssembly::BR_TABLE_I64
                                     : WebAssembly::BR_TABLE_I32)
                   .add(Index);

    for (auto *MBB : MBBs)
      MIB.addMBB(MBB);

    // Add the first MBB as a dummy default target for now. This will be
    // replaced with the proper default target (and the preceding range check
    // eliminated) if possible by WebAssemblyFixBrTableDefaults.
    MIB.addMBB(*MBBs.begin());

    assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    I.eraseFromParent();
    return true;
  }
  case G_PTR_ADD: {
    assert(MRI.getType(I.getOperand(0).getReg()).isPointer() &&
           "G_PTR_ADD selection fell-through with non-pointer?");

    auto PointerWidth = MF.getDataLayout().getPointerSizeInBits();
    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::ADD_I64
                                         : WebAssembly::ADD_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_PTRTOINT: {
    assert(MRI.getType(I.getOperand(1).getReg()).isPointer() &&
           "G_PTRTOINT selection fell-through with non-pointer?");

    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::COPY_I64
                                         : WebAssembly::COPY_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_INTTOPTR: {
    assert(MRI.getType(I.getOperand(0).getReg()).isPointer() &&
           "G_INTTOPTR selection fell-through with non-pointer?");

    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::COPY_I64
                                         : WebAssembly::COPY_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_PTRMASK: {
    assert(MRI.getType(I.getOperand(0).getReg()).isPointer() &&
           "G_PTRMASK selection fell-through with non-pointer?");

    I.setDesc(TII.get(PtrIsI64 ? WebAssembly::AND_I64 : WebAssembly::AND_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_FRAME_INDEX: {
    MachineIRBuilder B(I);

    I.setDesc(
        TII.get(PtrIsI64 ? WebAssembly::COPY_I64 : WebAssembly::COPY_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");
    return true;
  }
  case G_GLOBAL_VALUE: {
    assert(I.getOperand(1).getTargetFlags() == 0 &&
           "Unexpected target flags on generic G_GLOBAL_VALUE instruction");
    assert(WebAssembly::isValidAddressSpace(
               MRI.getType(I.getOperand(0).getReg()).getAddressSpace()) &&
           "Invalid address space for WebAssembly target");

    unsigned OperandFlags = 0;
    const llvm::GlobalValue *GV = I.getOperand(1).getGlobal();
    // Since WebAssembly tables cannot yet be shared accross modules, we don't
    // need special treatment for tables in PIC mode.
    if (TLI.isPositionIndependent() &&
        !WebAssembly::isWebAssemblyTableType(GV->getValueType())) {
      if (TM.shouldAssumeDSOLocal(GV)) {
        const char *BaseName;
        if (GV->getValueType()->isFunctionTy()) {
          BaseName = MF.createExternalSymbolName("__table_base");
          OperandFlags = WebAssemblyII::MO_TABLE_BASE_REL;
        } else {
          BaseName = MF.createExternalSymbolName("__memory_base");
          OperandFlags = WebAssemblyII::MO_MEMORY_BASE_REL;
        }
        MachineIRBuilder B(I);

        auto MemBase =
            MRI.createGenericVirtualRegister(LLT::pointer(0, PointerWidth));
        MRI.setRegClass(MemBase, PtrIsI64 ? &WebAssembly::I64RegClass
                                          : &WebAssembly::I32RegClass);
        auto Offset =
            MRI.createGenericVirtualRegister(LLT::pointer(0, PointerWidth));
        MRI.setRegClass(Offset, PtrIsI64 ? &WebAssembly::I64RegClass
                                         : &WebAssembly::I32RegClass);

        B.buildInstr(PtrIsI64 ? WebAssembly::GLOBAL_GET_I64
                              : WebAssembly::GLOBAL_GET_I32)
            .addDef(MemBase)
            .addExternalSymbol(BaseName);

        B.buildInstr(PtrIsI64 ? WebAssembly::CONST_I64 : WebAssembly::CONST_I32)
            .addDef(Offset)
            .addGlobalAddress(GV, I.getOperand(1).getOffset(), OperandFlags);

        auto MIB =
            B.buildInstr(PtrIsI64 ? WebAssembly::ADD_I64 : WebAssembly::ADD_I32)
                .addDef(I.getOperand(0).getReg())
                .addReg(MemBase)
                .addReg(Offset);
        assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
               "Couldn't constrain registers for instruction");

        I.eraseFromParent();
        return true;
      }
      OperandFlags = WebAssemblyII::MO_GOT;
    }

    auto NewOpc = PtrIsI64 ? WebAssembly::CONST_I64 : WebAssembly::CONST_I32;

    if (OperandFlags & WebAssemblyII::MO_GOT) {
      NewOpc =
          PtrIsI64 ? WebAssembly::GLOBAL_GET_I64 : WebAssembly::GLOBAL_GET_I32;
    }

    I.setDesc(TII.get(NewOpc));
    I.getOperand(1).setTargetFlags(OperandFlags);
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_VASTART: {
    MachineIRBuilder B(I);

    auto *OldMMO = I.memoperands()[0];

    auto *NewMMO = MF.getMachineMemOperand(
        OldMMO->getPointerInfo(), MachineMemOperand::Flags::MOStore,
        OldMMO->getSize(), MF.getDataLayout().getPointerABIAlignment(0));

    auto MIB = B.buildInstr(PtrIsI64 ? WebAssembly::STORE_I64_A64
                                     : WebAssembly::STORE_I32_A32)
                   .addImm(0) // alignment; rewritten in later pass
                   .addImm(0) // offset
                   .addReg(I.getOperand(0).getReg()) // base
                   .addReg(MF.getInfo<WebAssemblyFunctionInfo>()
                               ->getVarargBufferVreg()) // value
                   .addMemOperand(NewMMO);

    assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    I.eraseFromParent();

    return true;
  }
  }

  return false;
}

namespace llvm {
InstructionSelector *
createWebAssemblyInstructionSelector(const WebAssemblyTargetMachine &TM,
                                     const WebAssemblySubtarget &Subtarget,
                                     const WebAssemblyRegisterBankInfo &RBI) {
  return new WebAssemblyInstructionSelector(TM, Subtarget, RBI);
}
} // namespace llvm
