//===- WebAssemblyInstructionSelector.cpp ------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// WebAssembly.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "GISel/WebAssemblyRegisterBankInfo.h"
#include "MCTargetDesc/WebAssemblyMCTargetDesc.h"
#include "Utils/WasmAddressSpaces.h"
#include "Utils/WebAssemblyTypeUtilities.h"
#include "WebAssemblyRegisterInfo.h"
#include "WebAssemblySubtarget.h"
#include "WebAssemblyTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineOperand.h"
#include "llvm/CodeGen/RegisterBank.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/IR/IntrinsicsWebAssembly.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Support/ErrorHandling.h"

#define DEBUG_TYPE "wasm-isel"

using namespace llvm;

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class WebAssemblyInstructionSelector : public InstructionSelector {
public:
  WebAssemblyInstructionSelector(const WebAssemblyTargetMachine &TM,
                                 const WebAssemblySubtarget &STI,
                                 const WebAssemblyRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;

  InstructionSelector::ComplexRendererFns
  selectAddrOperands32(MachineOperand &Root) const;
  InstructionSelector::ComplexRendererFns
  selectAddrOperands64(MachineOperand &Root) const;

  static const char *getName() { return DEBUG_TYPE; }

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  bool selectCopy(MachineInstr &I, MachineRegisterInfo &MRI) const;

  InstructionSelector::ComplexRendererFns
  selectAddrOperands(LLT AddrType, unsigned int ConstOpc,
                     MachineOperand &Root) const;

  const WebAssemblyTargetMachine &TM;
  const WebAssemblySubtarget &STI;
  const WebAssemblyInstrInfo &TII;
  const WebAssemblyRegisterInfo &TRI;
  const WebAssemblyRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

WebAssemblyInstructionSelector::WebAssemblyInstructionSelector(
    const WebAssemblyTargetMachine &TM, const WebAssemblySubtarget &STI,
    const WebAssemblyRegisterBankInfo &RBI)
    : TM(TM), STI(STI), TII(*STI.getInstrInfo()), TRI(*STI.getRegisterInfo()),
      RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "WebAssemblyGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands(LLT AddrType,
                                                   unsigned int ConstOpc,
                                                   MachineOperand &Root) const {

  if (!Root.isReg())
    return std::nullopt;

  MachineRegisterInfo &MRI =
      Root.getParent()->getParent()->getParent()->getRegInfo();
  MachineInstr &RootDef = *MRI.getVRegDef(Root.getReg());

  if (RootDef.getOpcode() == TargetOpcode::G_PTR_ADD) {
    // RootDef will always be G_PTR_ADD
    MachineOperand &LHS = RootDef.getOperand(1);

    MachineOperand &RHS = RootDef.getOperand(2);
    MachineInstr &LHSDef = *MRI.getVRegDef(LHS.getReg());
    MachineInstr &RHSDef =
        *MRI.getVRegDef(RHS.getReg()); // Will always be G_CONSTANT

    // WebAssembly constant offsets are performed as unsigned with infinite
    // precision, so we need to check for NoUnsignedWrap so that we don't fold
    // and offset for an add that needs wrapping.
    if (RootDef.getFlag(MachineInstr::MIFlag::NoUWrap)) {
      for (size_t i = 0; i < 2; ++i) {
        //MachineOperand &Op = i == 0 ? LHS : RHS;
        MachineInstr &OpDef = i == 0 ? LHSDef : RHSDef;
        MachineOperand &OtherOp = i == 0 ? RHS : LHS;
        //MachineInstr &OtherOpDef = i == 0 ? RHSDef : LHSDef;

        if (OpDef.getOpcode() == TargetOpcode::G_CONSTANT) {
          auto Offset = OpDef.getOperand(1).getCImm()->getZExtValue();
          auto Addr = OtherOp;

          return {{
              [=](MachineInstrBuilder &MIB) { MIB.addImm(Offset); },
              [=](MachineInstrBuilder &MIB) { MIB.add(Addr); },
          }};
        }

        if (!TM.isPositionIndependent()) {
          if (OpDef.getOpcode() == TargetOpcode::G_GLOBAL_VALUE) {
            auto Offset = OpDef.getOperand(1).getGlobal();
            auto Addr = OtherOp;

            return {{
                [=](MachineInstrBuilder &MIB) { MIB.addGlobalAddress(Offset); },
                [=](MachineInstrBuilder &MIB) { MIB.add(Addr); },
            }};
          }
        }
      }
    }
  }

  if (RootDef.getOpcode() == TargetOpcode::G_CONSTANT) {
    auto Offset = RootDef.getOperand(1).getCImm()->getZExtValue();
    auto Addr = MRI.createGenericVirtualRegister(AddrType);

    MachineIRBuilder B(RootDef);

    auto MIB = B.buildInstr(ConstOpc).addDef(Addr).addImm(0);
    assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return {{
        [=](MachineInstrBuilder &MIB) { MIB.addImm(Offset); },
        [=](MachineInstrBuilder &MIB) { MIB.addReg(Addr); },
    }};
  }

  return {{
      [=](MachineInstrBuilder &MIB) { MIB.addImm(0); },
      [=](MachineInstrBuilder &MIB) { MIB.add(Root); },
  }};
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands32(
    MachineOperand &Root) const {
  return selectAddrOperands(LLT::scalar(32), WebAssembly::CONST_I32, Root);
}

InstructionSelector::ComplexRendererFns
WebAssemblyInstructionSelector::selectAddrOperands64(
    MachineOperand &Root) const {
  return selectAddrOperands(LLT::scalar(64), WebAssembly::CONST_I64, Root);
}

bool WebAssemblyInstructionSelector::selectCopy(
    MachineInstr &I, MachineRegisterInfo &MRI) const {
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  if (DstReg.isPhysical()) {
    if (DstReg.id() == WebAssembly::SP32) {
      if (!RBI.constrainGenericRegister(DstReg, WebAssembly::I32RegClass,
                                        MRI)) {
        LLVM_DEBUG(dbgs() << "Failed to constrain "
                          << TII.getName(I.getOpcode()) << " operand\n");
        return false;
      }
      return true;
    }
    if (DstReg.id() == WebAssembly::SP64) {
      if (!RBI.constrainGenericRegister(DstReg, WebAssembly::I64RegClass,
                                        MRI)) {
        LLVM_DEBUG(dbgs() << "Failed to constrain "
                          << TII.getName(I.getOpcode()) << " operand\n");
        return false;
      }
      return true;
    }
    llvm_unreachable("Copy to physical register other than SP32 or SP64?");
  }

  const TargetRegisterClass *DstRC = MRI.getRegClassOrNull(DstReg);
  if (!DstRC) {
    const RegisterBank *DstBank = MRI.getRegBankOrNull(DstReg);
    if (!DstBank) {
      llvm_unreachable("Selecting copy with dst reg with no bank?");
    }

    switch (DstBank->getID()) {
    case WebAssembly::I32RegBankID:
      DstRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::I64RegBankID:
      DstRC = &WebAssembly::I64RegClass;
      break;
    case WebAssembly::F32RegBankID:
      DstRC = &WebAssembly::F32RegClass;
      break;
    case WebAssembly::F64RegBankID:
      DstRC = &WebAssembly::F64RegClass;
      break;
    default:
      llvm_unreachable("Unknown reg bank to reg class mapping?");
    }
    if (!RBI.constrainGenericRegister(DstReg, *DstRC, MRI)) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }

  const TargetRegisterClass *SrcRC = MRI.getRegClassOrNull(SrcReg);
  if (!SrcRC) {
    const RegisterBank *SrcBank = MRI.getRegBankOrNull(SrcReg);
    if (!SrcBank) {
      llvm_unreachable("Selecting copy with src reg with no bank?");
    }

    switch (SrcBank->getID()) {
    case WebAssembly::I32RegBankID:
      SrcRC = &WebAssembly::I32RegClass;
      break;
    case WebAssembly::I64RegBankID:
      SrcRC = &WebAssembly::I64RegClass;
      break;
    case WebAssembly::F32RegBankID:
      SrcRC = &WebAssembly::F32RegClass;
      break;
    case WebAssembly::F64RegBankID:
      SrcRC = &WebAssembly::F64RegClass;
      break;
    default:
      llvm_unreachable("Unknown reg bank to reg class mapping?");
    }
    if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI)) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }

  assert(TRI.getRegSizeInBits(*DstRC) == TRI.getRegSizeInBits(*SrcRC) &&
         "Copy between mismatching register sizes?");

  if (DstRC != SrcRC) {
    if (DstRC == &WebAssembly::I32RegClass &&
        SrcRC == &WebAssembly::F32RegClass) {
      I.setDesc(TII.get(WebAssembly::I32_REINTERPRET_F32));
      return true;
    }

    if (DstRC == &WebAssembly::F32RegClass &&
        SrcRC == &WebAssembly::I32RegClass) {
      I.setDesc(TII.get(WebAssembly::F32_REINTERPRET_I32));
      return true;
    }

    if (DstRC == &WebAssembly::I64RegClass &&
        SrcRC == &WebAssembly::F64RegClass) {
      I.setDesc(TII.get(WebAssembly::I64_REINTERPRET_F64));
      return true;
    }

    if (DstRC == &WebAssembly::F64RegClass &&
        SrcRC == &WebAssembly::I64RegClass) {
      I.setDesc(TII.get(WebAssembly::F64_REINTERPRET_I64));
      return true;
    }

    llvm_unreachable("Found bitcast/copy edge case.");
  }

  return true;
}

bool WebAssemblyInstructionSelector::select(MachineInstr &I) {
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();
  const TargetLowering &TLI = *STI.getTargetLowering();

  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCopy(I, MRI);

    return true;
  }

  if (selectImpl(I, *CoverageInfo))
    return true;

  using namespace TargetOpcode;

  auto PointerWidth = MF.getDataLayout().getPointerSizeInBits();
  auto PtrIsI64 = PointerWidth == 64;

  switch (I.getOpcode()) {
  case G_CONSTANT: {
    assert(MRI.getType(I.getOperand(0).getReg()).isPointer() &&
           "G_CONSTANT selection fell-through with non-pointer?");

    auto OrigImm = I.getOperand(1).getCImm()->getValue();

    auto MaskedVal = OrigImm.getLoBits(PointerWidth);
    assert(MaskedVal.eq(OrigImm) &&
           "Pointer immediate uses more bits than allowed");

    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::CONST_I64
                                         : WebAssembly::CONST_I32));
    I.removeOperand(1);
    I.addOperand(MachineOperand::CreateImm(MaskedVal.getZExtValue()));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");
    return true;
  }
  case G_PTR_ADD: {
    assert(MRI.getType(I.getOperand(0).getReg()).isPointer() &&
           "G_PTR_ADD selection fell-through with non-pointer?");

    auto PointerWidth = MF.getDataLayout().getPointerSizeInBits();
    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::ADD_I64
                                         : WebAssembly::ADD_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_PTRTOINT: {
    assert(MRI.getType(I.getOperand(1).getReg()).isPointer() &&
           "G_PTRTOINT selection fell-through with non-pointer?");

    auto PointerWidth = MF.getDataLayout().getPointerSizeInBits();
    I.setDesc(TII.get(PointerWidth == 64 ? WebAssembly::COPY_I64
                                         : WebAssembly::COPY_I32));
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_ICMP: {
    Register LHS = I.getOperand(2).getReg();
    Register RHS = I.getOperand(3).getReg();
    CmpInst::Predicate Cond =
        static_cast<CmpInst::Predicate>(I.getOperand(1).getPredicate());

    auto CmpWidth = MRI.getType(LHS).getSizeInBits();
    assert(CmpWidth == MRI.getType(RHS).getSizeInBits() &&
           "LHS and RHS for ICMP are diffrent lengths???");

    auto IsI64 = CmpWidth == 64;

    unsigned int CmpOpcode;
    switch (Cond) {
    case CmpInst::ICMP_EQ:
      CmpOpcode = IsI64 ? WebAssembly::EQ_I64 : WebAssembly::EQ_I32;
      break;
    case CmpInst::ICMP_NE:
      CmpOpcode = IsI64 ? WebAssembly::NE_I64 : WebAssembly::NE_I32;
      break;
    case CmpInst::ICMP_UGT:
      CmpOpcode = IsI64 ? WebAssembly::GT_U_I64 : WebAssembly::GT_U_I32;
      break;
    case CmpInst::ICMP_UGE:
      CmpOpcode = IsI64 ? WebAssembly::GE_U_I64 : WebAssembly::GE_U_I32;
      break;
    case CmpInst::ICMP_ULT:
      CmpOpcode = IsI64 ? WebAssembly::LT_U_I64 : WebAssembly::LT_U_I32;
      break;
    case CmpInst::ICMP_ULE:
      CmpOpcode = IsI64 ? WebAssembly::LE_U_I64 : WebAssembly::LE_U_I32;
      break;
    case CmpInst::ICMP_SGT:
      CmpOpcode = IsI64 ? WebAssembly::GT_S_I64 : WebAssembly::GT_S_I32;
      break;
    case CmpInst::ICMP_SGE:
      CmpOpcode = IsI64 ? WebAssembly::GE_S_I64 : WebAssembly::GE_S_I32;
      break;
    case CmpInst::ICMP_SLT:
      CmpOpcode = IsI64 ? WebAssembly::LT_S_I64 : WebAssembly::LT_S_I32;
      break;
    case CmpInst::ICMP_SLE:
      CmpOpcode = IsI64 ? WebAssembly::LE_S_I64 : WebAssembly::LE_S_I32;
      break;
    default:
      llvm_unreachable("Unknown ICMP predicate");
    }

    I.setDesc(TII.get(CmpOpcode));
    I.removeOperand(1);
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }
  case G_FRAME_INDEX: {
    MachineIRBuilder B(I);

    auto MIB = B.buildInstr(PtrIsI64 ? WebAssembly::ADD_I64 : WebAssembly::ADD_I32)
                   .addDef(I.getOperand(0).getReg())
                   .addReg(PtrIsI64 ? WebAssembly::SP64 : WebAssembly::SP32)
                   .addFrameIndex(I.getOperand(1).getIndex());
    assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    I.eraseFromParent();
    return true;
  }
  case G_GLOBAL_VALUE:
    assert(I.getOperand(1).getTargetFlags() == 0 &&
           "Unexpected target flags on generic G_GLOBAL_VALUE instruction");
    assert(WebAssembly::isValidAddressSpace(
               MRI.getType(I.getOperand(0).getReg()).getAddressSpace()) &&
           "Invalid address space for WebAssembly target");

    unsigned OperandFlags = 0;
    const llvm::GlobalValue *GV = I.getOperand(1).getGlobal();
    // Since WebAssembly tables cannot yet be shared accross modules, we don't
    // need special treatment for tables in PIC mode.
    if (TLI.isPositionIndependent() &&
        !WebAssembly::isWebAssemblyTableType(GV->getValueType())) {
      if (TM.shouldAssumeDSOLocal(GV)) {
        const char *BaseName;
        if (GV->getValueType()->isFunctionTy()) {
          BaseName = MF.createExternalSymbolName("__table_base");
          OperandFlags = WebAssemblyII::MO_TABLE_BASE_REL;
        } else {
          BaseName = MF.createExternalSymbolName("__memory_base");
          OperandFlags = WebAssemblyII::MO_MEMORY_BASE_REL;
        }
        MachineIRBuilder B(I);

        auto MemBase = MRI.createGenericVirtualRegister(LLT::pointer(0, PointerWidth));
        MRI.setRegClass(MemBase, PtrIsI64 ? &WebAssembly::I64RegClass : &WebAssembly::I32RegClass);
        auto Offset = MRI.createGenericVirtualRegister(LLT::pointer(0, PointerWidth));
        MRI.setRegClass(Offset, PtrIsI64 ? &WebAssembly::I64RegClass : &WebAssembly::I32RegClass);

        B.buildInstr(PtrIsI64 ? WebAssembly::GLOBAL_GET_I64
                           : WebAssembly::GLOBAL_GET_I32)
            .addDef(MemBase)
            .addExternalSymbol(BaseName);

        B.buildInstr(PtrIsI64 ? WebAssembly::CONST_I64 : WebAssembly::CONST_I32)
            .addDef(Offset)
            .addGlobalAddress(GV, I.getOperand(1).getOffset(), OperandFlags);

        auto MIB =
            B.buildInstr(PtrIsI64 ? WebAssembly::ADD_I64 : WebAssembly::ADD_I32)
                .addDef(I.getOperand(0).getReg())
                .addReg(MemBase)
                .addReg(Offset);
        assert(constrainSelectedInstRegOperands(*MIB, TII, TRI, RBI) &&
               "Couldn't constrain registers for instruction");

        I.eraseFromParent();
        return true;
      }
      OperandFlags = WebAssemblyII::MO_GOT;
    }

    auto NewOpc = MF.getDataLayout().getPointerSizeInBits() == 64
                      ? WebAssembly::CONST_I64
                      : WebAssembly::CONST_I32;

    if (OperandFlags & WebAssemblyII::MO_GOT) {
      NewOpc = MF.getDataLayout().getPointerSizeInBits() == 64
                   ? WebAssembly::GLOBAL_GET_I64
                   : WebAssembly::GLOBAL_GET_I32;
    }

    I.setDesc(TII.get(NewOpc));
    I.getOperand(1).setTargetFlags(OperandFlags);
    assert(constrainSelectedInstRegOperands(I, TII, TRI, RBI) &&
           "Couldn't constrain registers for instruction");

    return true;
  }

  return false;
}

namespace llvm {
InstructionSelector *
createWebAssemblyInstructionSelector(const WebAssemblyTargetMachine &TM,
                                     const WebAssemblySubtarget &Subtarget,
                                     const WebAssemblyRegisterBankInfo &RBI) {
  return new WebAssemblyInstructionSelector(TM, Subtarget, RBI);
}
} // namespace llvm
