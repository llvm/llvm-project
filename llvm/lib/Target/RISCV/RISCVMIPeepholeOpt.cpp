//===- RISCVMIPeepholeOpt.cpp - RISC-V MI peephole optimization pass ---===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This pass performs below peephole optimizations on MIR level.
//
// 1. Remove redundant branch instrunctions which may be generated by
// block-placement.
//
//    bne a1, a1, %bb.1
//    blt a1, a1, %bb.1
//    bltu a1, a1, %bb.1
//
//    These instruction is bound to fallthrough to next basic block, rather
//    than into the %bb.1, so it should be removed here.
//
// 2. beq a1, a1, %bb.1 -> br %bb.1
//    bge a1, a1, %bb.1 -> br %bb.1
//    bgeu a1, a1, %bb.1 -> br %bb.1
//
//    These instruction is bound to go into %bb.1, so it should be replaced by
//    br pseudo instruction.
//
//===----------------------------------------------------------------------===//

#include "RISCV.h"
#include "RISCVInstrInfo.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/CodeGen/LiveIntervals.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/Support/Debug.h"

using namespace llvm;

#define DEBUG_TYPE "riscv-mi-peephole-opt"

namespace {

class RISCVMIPeepholeOpt : public MachineFunctionPass {
public:
  static char ID;
  const TargetInstrInfo *TII;
  const MachineFunction *MFI;

  RISCVMIPeepholeOpt() : MachineFunctionPass(ID) {
    initializeRISCVMIPeepholeOptPass(*PassRegistry::getPassRegistry());
  }

  bool visitBranch(MachineInstr &MI, SmallVector<MachineInstr *> &DeadInstrs);
  bool runOnMachineFunction(MachineFunction &MF) override;

  StringRef getPassName() const override {
    return "RISC-V MI Peephole Optimization pass";
  }
};
} // end anonymous namespace

char RISCVMIPeepholeOpt::ID = 0;

INITIALIZE_PASS(RISCVMIPeepholeOpt, "riscv-mi-peephole-opt",
                "RISC-V MI Peephole Optimization", false, false)

bool RISCVMIPeepholeOpt::visitBranch(MachineInstr &MI,
                                     SmallVector<MachineInstr *> &DeadInstrs) {
  Register FirstReg = MI.getOperand(0).getReg();
  Register SecondReg = MI.getOperand(1).getReg();

  if (FirstReg != SecondReg)
    return false;

  MachineBasicBlock *MBB = MI.getParent();
  auto LastMI = MBB->rbegin();

  if (&MI != &*LastMI && (*LastMI).getOpcode() != RISCV::PseudoBR)
    return false;

  MachineFunction::iterator It = std::next(MachineFunction::iterator(MBB));

  switch (MI.getOpcode()) {
  default:
    break;
  case RISCV::BEQ:
  case RISCV::BGE:
  case RISCV::BGEU: {
    BuildMI(*MBB, &MI, MI.getDebugLoc(), TII->get(RISCV::PseudoBR))
        .add(MI.getOperand(2));

    MachineBasicBlock *CBTargetMBB = MI.getOperand(2).getMBB();

    if ((*LastMI).getOpcode() == RISCV::PseudoBR) {
      MachineBasicBlock *BRTargetMBB = (*LastMI).getOperand(0).getMBB();

      if (BRTargetMBB != CBTargetMBB)
        MBB->removeSuccessor(BRTargetMBB);
      DeadInstrs.push_back(&*LastMI);
    } else if (It != MFI->end() && CBTargetMBB != &*It)
      MBB->removeSuccessor(&*It);
    break;
  }
  case RISCV::BNE:
  case RISCV::BLT:
  case RISCV::BLTU: {
    MachineBasicBlock *CBTargetMBB = MI.getOperand(2).getMBB();

    if ((*LastMI).getOpcode() == RISCV::PseudoBR) {
      MachineBasicBlock *BRTargetMBB = (*LastMI).getOperand(0).getMBB();

      if (BRTargetMBB != CBTargetMBB)
        MBB->removeSuccessor(CBTargetMBB);
    } else if (It != MFI->end() && CBTargetMBB != &*It)
      MBB->removeSuccessor(CBTargetMBB);
    break;
  }
  }
  DeadInstrs.push_back(&MI);

  return true;
}

bool RISCVMIPeepholeOpt::runOnMachineFunction(MachineFunction &MF) {
  if (skipFunction(MF.getFunction()))
    return false;

  SmallVector<MachineInstr *> DeadInstrs;

  TII = MF.getSubtarget().getInstrInfo();
  MFI = &MF;

  bool Changed = false;

  for (MachineBasicBlock &MBB : MF) {
    for (MachineInstr &MI : make_early_inc_range(MBB)) {
      switch (MI.getOpcode()) {
      default:
        break;
      case RISCV::BNE:
      case RISCV::BEQ:
      case RISCV::BLT:
      case RISCV::BLTU:
      case RISCV::BGE:
      case RISCV::BGEU:
        Changed |= visitBranch(MI, DeadInstrs);
        break;
      }
    }
  }

  if (DeadInstrs.empty())
    return Changed;

  for (MachineInstr *Inst : DeadInstrs)
    Inst->eraseFromParent();

  return Changed;
}

FunctionPass *llvm::createRISCVMIPeepholeOptPass() {
  return new RISCVMIPeepholeOpt();
}
