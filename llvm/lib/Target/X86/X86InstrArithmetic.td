//===-- X86InstrArithmetic.td - Integer Arithmetic Instrs --*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file describes the integer arithmetic instructions in the X86
// architecture.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// LEA - Load Effective Address
let SchedRW = [WriteLEA] in {
let hasSideEffects = 0 in
def LEA16r   : I<0x8D, MRMSrcMem,
                 (outs GR16:$dst), (ins anymem:$src),
                 "lea{w}\t{$src|$dst}, {$dst|$src}", []>, OpSize16;
let isReMaterializable = 1 in
def LEA32r   : I<0x8D, MRMSrcMem,
                 (outs GR32:$dst), (ins anymem:$src),
                 "lea{l}\t{$src|$dst}, {$dst|$src}",
                 [(set GR32:$dst, lea32addr:$src)]>,
                 OpSize32, Requires<[Not64BitMode]>;

def LEA64_32r : I<0x8D, MRMSrcMem,
                  (outs GR32:$dst), (ins lea64_32mem:$src),
                  "lea{l}\t{$src|$dst}, {$dst|$src}",
                  [(set GR32:$dst, lea64_32addr:$src)]>,
                  OpSize32, Requires<[In64BitMode]>;

let isReMaterializable = 1 in
def LEA64r   : RI<0x8D, MRMSrcMem, (outs GR64:$dst), (ins lea64mem:$src),
                  "lea{q}\t{$src|$dst}, {$dst|$src}",
                  [(set GR64:$dst, lea64addr:$src)]>;
} // SchedRW

// Pseudo instruction for lea that prevent optimizer from eliminating
// the instruction.
let SchedRW = [WriteLEA], isPseudo = true, hasSideEffects = 1 in {
def PLEA32r   : PseudoI<(outs GR32:$dst), (ins anymem:$src), []>;
def PLEA64r   : PseudoI<(outs GR64:$dst), (ins anymem:$src), []>;
}

// BinOpRR - Instructions that read "reg, reg".
class BinOpRR<bits<8> o, string m, X86TypeInfo t, dag out, list<dag> p>
  : ITy<o, MRMDestReg, t, out, (ins t.RegClass:$src1, t.RegClass:$src2), m,
        binop_args, p>, Sched<[WriteALU]>;
// BinOpRR_F - Instructions that read "reg, reg" and write EFLAGS only.
class BinOpRR_F<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node>
  : BinOpRR<o, m, t, (outs),
            [(set EFLAGS, (node t.RegClass:$src1, t.RegClass:$src2))]>,
    DefEFLAGS;
// BinOpRR_F_Rev - Reversed encoding of BinOpRR_F
class BinOpRR_F_Rev<bits<8> o, string m, X86TypeInfo t>
  : BinOpRR_F<o, m, t, null_frag>, DisassembleOnly {
  let Form = MRMSrcReg;
}
// BinOpRR_RF - Instructions that read "reg, reg", and write "reg", EFLAGS.
class BinOpRR_RF<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node>
  : BinOpRR<o, m, t, (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS,
             (node t.RegClass:$src1, t.RegClass:$src2))]>, DefEFLAGS;
// BinOpRR_RF_Rev - Reversed encoding of BinOpRR_RF.
class BinOpRR_RF_Rev<bits<8> o, string m, X86TypeInfo t>
  : BinOpRR_RF<o, m, t, null_frag>, DisassembleOnly {
  let Form = MRMSrcReg;
}
// BinOpRRF_RF - Instructions that read "reg, reg", write "reg" and read/write
// EFLAGS.
class BinOpRRF_RF<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node>
  : BinOpRR<o, m, t, (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS,
             (node t.RegClass:$src1, t.RegClass:$src2,
             EFLAGS))]>, DefEFLAGS, UseEFLAGS {
  let SchedRW = [WriteADC];
}
// BinOpRRF_RF_Rev - Reversed encoding of BinOpRRF_RF
class BinOpRRF_RF_Rev<bits<8> o, string m, X86TypeInfo t>
  : BinOpRRF_RF<o, m, t, null_frag>, DisassembleOnly {
  let Form = MRMSrcReg;
}

// BinOpRM - Instructions that read "reg, [mem]".
class BinOpRM<bits<8> o, string m, X86TypeInfo t, dag out, list<dag> p>
  : ITy<o, MRMSrcMem, t, out, (ins t.RegClass:$src1, t.MemOperand:$src2), m,
        binop_args, p>,
    Sched<[WriteALU.Folded, WriteALU.ReadAfterFold]> {
  let mayLoad = 1;
}
// BinOpRM_F - Instructions that read "reg, [mem]" and write EFLAGS only.
class BinOpRM_F<bits<8> o, string m, X86TypeInfo t, SDNode node>
  : BinOpRM<o, m, t, (outs),
            [(set EFLAGS, (node t.RegClass:$src1,
             (t.LoadNode addr:$src2)))]>, DefEFLAGS;
// BinOpRM_RF - Instructions that read "reg, reg", and write "reg", EFLAGS.
class BinOpRM_RF<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node>
  : BinOpRM<o, m, t, (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS, (node t.RegClass:$src1,
             (t.LoadNode addr:$src2)))]>, DefEFLAGS;
// BinOpRMF_RF - Instructions that read "reg, [mem]", write "reg" and read/write
// EFLAGS.
class BinOpRMF_RF<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node>
  : BinOpRM<o, m, t, (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS,
             (node t.RegClass:$src1, (t.LoadNode addr:$src2), EFLAGS))]>,
    DefEFLAGS, UseEFLAGS {
  let SchedRW = [WriteADC.Folded, WriteADC.ReadAfterFold,
                 // base, scale, index, offset, segment.
                 ReadDefault, ReadDefault, ReadDefault, ReadDefault, ReadDefault,
                 // implicit register read.
                 WriteADC.ReadAfterFold];
}

// BinOpRI - Instructions that read "reg, imm".
class BinOpRI<bits<8> o, string m, string args, X86TypeInfo t, Format f, dag out, list<dag> p>
  : ITy<o, f, t, out, (ins t.RegClass:$src1, t.ImmOperand:$src2), m,
        args, p>, Sched<[WriteALU]> {
  let ImmT = t.ImmEncoding;
}
// BinOpRI_F - Instructions that read "reg, imm" and write EFLAGS only.
class BinOpRI_F<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node,
                Format f>
  : BinOpRI<o, m, binop_args, t, f, (outs),
            [(set EFLAGS, (node t.RegClass:$src1,
             t.ImmOperator:$src2))]>, DefEFLAGS;
// BinOpRI_RF - Instructions that read "reg, imm" and write "reg", EFLAGS.
class BinOpRI_RF<bits<8> o, string m, X86TypeInfo t, SDNode node, Format f>
  : BinOpRI<o, m, binop_args, t, f, (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS,
             (node t.RegClass:$src1, t.ImmOperator:$src2))]>, DefEFLAGS;
// BinOpRIF_RF - Instructions that read "reg, imm", write "reg" and read/write
// EFLAGS.
class BinOpRIF_RF<bits<8> o, string m, X86TypeInfo t, SDNode node, Format f>
  : BinOpRI<o, m, binop_args, t, f, (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS,
             (node t.RegClass:$src1, t.ImmOperator:$src2,
             EFLAGS))]>, DefEFLAGS, UseEFLAGS {
  let SchedRW = [WriteADC];
}
// BinOpRI8 - Instructions that read "reg, imm8".
class BinOpRI8<bits<8> o, string m, string args, X86TypeInfo t, Format f, dag out>
  : ITy<o, f, t, out, (ins t.RegClass:$src1, t.Imm8Operand:$src2), m,
        args, []>, Sched<[WriteALU]> {
  let ImmT = Imm8;
}
// BinOpRI8_F - Instructions that read "reg, imm8" and write EFLAGS only.
class BinOpRI8_F<bits<8> o, string m, X86TypeInfo t, Format f>
  : BinOpRI8<o, m, binop_args, t, f, (outs)>, DefEFLAGS;
// BinOpRI8_RF - Instructions that read "reg, imm8" and write "reg", EFLAGS.
class BinOpRI8_RF<bits<8> o, string m, X86TypeInfo t, Format f>
  : BinOpRI8<o, m, binop_args, t, f, (outs t.RegClass:$dst)>, DefEFLAGS;
// BinOpRI8F_RF - Instructions that read "reg, imm", write "reg" and read/write
// EFLAGS.
class BinOpRI8F_RF<bits<8> o, string m, X86TypeInfo t, Format f>
  : BinOpRI8<o, m, binop_args, t, f, (outs t.RegClass:$dst)>, DefEFLAGS, UseEFLAGS {
  let SchedRW = [WriteADC];
}

// BinOpMR - Instructions that read "[mem], reg".
class BinOpMR<bits<8> o, string m, X86TypeInfo t, list<dag> p>
  : ITy<o, MRMDestMem, t, (outs), (ins t.MemOperand:$src1, t.RegClass:$src2), m,
        binop_args, p> {
  let mayLoad = 1;
}
// BinOpMR_F - Instructions that read "[mem], imm8" and write EFLAGS only.
class BinOpMR_F<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node>
  : BinOpMR<o, m, t,
            [(set EFLAGS, (node (t.LoadNode addr:$src1), t.RegClass:$src2))]>,
    Sched<[WriteALU.Folded, ReadDefault, ReadDefault, ReadDefault,
            ReadDefault, ReadDefault, WriteALU.ReadAfterFold]>, DefEFLAGS;
// BinOpMR_MF - Instructions that read "[mem], reg" and write "[mem]", EFLAGS.
class BinOpMR_MF<bits<8> o, string m, X86TypeInfo t, SDNode node>
  : BinOpMR<o, m, t,
            [(store (node (load addr:$src1), t.RegClass:$src2), addr:$src1),
             (implicit EFLAGS)]>,
    Sched<[WriteALURMW,
           // base, scale, index, offset, segment
           ReadDefault, ReadDefault, ReadDefault, ReadDefault, ReadDefault,
           WriteALU.ReadAfterFold]>, // reg
    DefEFLAGS {
  let mayStore = 1;
}
// BinOpMRF_MF - Instructions that read "[mem], reg", write "[mem]" and
// read/write EFLAGS.
class BinOpMRF_MF<bits<8> o, string m, X86TypeInfo t, SDNode node>
  : BinOpMR<o, m, t,
            [(store (node (load addr:$src1), t.RegClass:$src2, EFLAGS),
             addr:$src1), (implicit EFLAGS)]>,
    Sched<[WriteADCRMW,
          // base, scale, index, offset, segment
          ReadDefault, ReadDefault, ReadDefault,
          ReadDefault, ReadDefault,
          WriteALU.ReadAfterFold,    // reg
          WriteALU.ReadAfterFold]>,  // EFLAGS
    DefEFLAGS, UseEFLAGS {
  let mayStore = 1;
}

// BinOpMI - Instructions that read "[mem], imm".
class BinOpMI<bits<8> o, string m, string args, X86TypeInfo t, Format f, dag out, list<dag> p>
  : ITy<o, f, t, out, (ins t.MemOperand:$src1, t.ImmOperand:$src2), m,
        args, p> {
  let ImmT = t.ImmEncoding;
  let mayLoad = 1;
}
// BinOpMI_F - Instructions that read "[mem], imm" and write EFLAGS only.
class BinOpMI_F<bits<8> o, string m, X86TypeInfo t, SDPatternOperator node,
                Format f>
  : BinOpMI<o, m, binop_args, t, f, (outs),
            [(set EFLAGS, (node (t.LoadNode addr:$src1), t.ImmOperator:$src2))]>,
    Sched<[WriteALU.Folded]>, DefEFLAGS;
// BinOpMI_MF - Instructions that read "[mem], imm" and write "[mem]", EFLAGS.
class BinOpMI_MF<bits<8> o, string m, X86TypeInfo t, SDNode node, Format f>
  : BinOpMI<o, m, binop_args, t, f, (outs),
            [(store (node (t.VT (load addr:$src1)),
             t.ImmOperator:$src2), addr:$src1), (implicit EFLAGS)]>,
    Sched<[WriteALURMW]>, DefEFLAGS {
  let mayStore = 1;
}
// BinOpMIF_MF - Instructions that read "[mem], imm", write "[mem]" and
// read/write EFLAGS.
class BinOpMIF_MF<bits<8> o, string m, X86TypeInfo t, SDNode node, Format f>
  : BinOpMI<o, m, binop_args, t, f, (outs),
            [(store (node (t.VT (load addr:$src1)),
             t.ImmOperator:$src2, EFLAGS), addr:$src1), (implicit EFLAGS)]>,
    Sched<[WriteADCRMW]>, DefEFLAGS, UseEFLAGS {
  let mayStore = 1;
}

// BinOpMI8 - Instructions that read "[mem], imm8".
class BinOpMI8<string m, string args, X86TypeInfo t, Format f, dag out>
  : ITy<0x83, f, t, out, (ins t.MemOperand:$src1, t.Imm8Operand:$src2), m,
        args, []> {
  let ImmT = Imm8;
  let mayLoad = 1;
}
// BinOpMI8_F - Instructions that read "[mem], imm8" and write EFLAGS only.
class BinOpMI8_F<string m, X86TypeInfo t, Format f>
  : BinOpMI8<m, binop_args, t, f, (outs)>, Sched<[WriteALU.Folded]>, DefEFLAGS;
// BinOpMI8_MF - Instructions that read "[mem], imm8" and write "[mem]", EFLAGS.
class BinOpMI8_MF<string m, X86TypeInfo t, Format f>
  : BinOpMI8<m, binop_args, t, f, (outs)>, Sched<[WriteALURMW]>, DefEFLAGS {
  let mayStore = 1;
}
// BinOpMI8F_MF - Instructions that read "[mem], imm8", write "[mem]" and
// read/write EFLAGS.
class BinOpMI8F_MF<string m, X86TypeInfo t, Format f>
  : BinOpMI8<m, binop_args, t, f, (outs)>, Sched<[WriteADCRMW]>, DefEFLAGS, UseEFLAGS {
  let mayStore = 1;
}

// BinOpAI - Instructions that read "a-reg imm" (Accumulator register).
class BinOpAI<bits<8> o, string m, X86TypeInfo t, Register areg, string args>
  : ITy<o, RawFrm, t, (outs), (ins t.ImmOperand:$src), m, args, []>,
    Sched<[WriteALU]> {
  let ImmT = t.ImmEncoding;
  let Uses = [areg];
}
// BinOpAI_F - Instructions that read "a-reg imm" and write EFLAGS only.
class BinOpAI_F<bits<8> o, string m, X86TypeInfo t, Register areg, string args>
  : BinOpAI<o, m, t, areg, args>, DefEFLAGS;

// BinOpAI_AF - Instructions that read "a-reg imm" and write a-reg/EFLAGS.
class BinOpAI_AF<bits<8> o, string m, X86TypeInfo t, Register areg,
                 string args> : BinOpAI<o, m, t, areg, args> {
  let Defs = [areg, EFLAGS];
}
// BinOpAIF_AF - Instructions that read "a-reg imm", write a-reg and read/write
// EFLAGS.
class BinOpAIF_AF<bits<8> o, string m, X86TypeInfo t, Register areg,
                  string args> : BinOpAI<o, m, t, areg, args> {
  let Uses = [areg, EFLAGS];
  let Defs = [areg, EFLAGS];
  let SchedRW = [WriteADC];
}

// UnaryOpR - Instructions that read "reg".
class UnaryOpR<bits<8> o, Format f, string m, string args, X86TypeInfo t,
               dag out, list<dag> p>
  : ITy<o, f, t, out, (ins t.RegClass:$src), m, args, p>, Sched<[WriteALU]>;
// UnaryOpR_R - Instructions that read "reg" and write "reg".
class UnaryOpR_R<bits<8> o, Format f, string m, X86TypeInfo t,
                  SDPatternOperator node>
  : UnaryOpR<o, f, m, unaryop_args, t, (outs t.RegClass:$dst),
             [(set t.RegClass:$dst, (node t.RegClass:$src))]>;
// UnaryOpR_RF - Instructions that read "reg" and write "reg"/EFLAGS.
class UnaryOpR_RF<bits<8> o, Format f, string m, X86TypeInfo t,
                  SDPatternOperator node>
  : UnaryOpR<o, f, m, unaryop_args, t, (outs t.RegClass:$dst),
             [(set t.RegClass:$dst, (node t.RegClass:$src)),
              (implicit EFLAGS)]>, DefEFLAGS;

// UnaryOpM - Instructions that read "[mem]".
class UnaryOpM<bits<8> o, Format f, string m, string args, X86TypeInfo t,
               dag out, list<dag> p>
  : ITy<o, f, t, out, (ins t.MemOperand:$src), m, args, p> {
  let mayLoad = 1;
}
// UnaryOpM_M - Instructions that read "[mem]" and writes "[mem]".
class UnaryOpM_M<bits<8> o, Format f, string m, X86TypeInfo t,
                  SDPatternOperator node>
  : UnaryOpM<o, f, m, unaryop_args, t, (outs),
             [(store (node (t.LoadNode addr:$src)), addr:$src)]>,
    Sched<[WriteALURMW]>{
  let mayStore = 1;
}
// UnaryOpM_MF - Instructions that read "[mem]" and writes "[mem]"/EFLAGS.
class UnaryOpM_MF<bits<8> o, Format f, string m, X86TypeInfo t,
                  SDPatternOperator node>
  : UnaryOpM<o, f, m, unaryop_args, t, (outs),
             [(store (node (t.LoadNode addr:$src)), addr:$src),
              (implicit EFLAGS)]>, Sched<[WriteALURMW]>, DefEFLAGS {
  let mayStore = 1;
}

//===----------------------------------------------------------------------===//
// MUL/IMUL and DIV/IDIV Instructions
//
class MulDivOpR<bits<8> o, Format f, string m, X86TypeInfo t,
             X86FoldableSchedWrite sched, list<dag> p>
  : UnaryOpR<o, f, m, "$src", t, (outs), p> {
  let SchedRW = [sched];
}

class MulDivOpM<bits<8> o, Format f, string m, X86TypeInfo t,
             X86FoldableSchedWrite sched, list<dag> p>
  : UnaryOpM<o, f, m, "$src", t, (outs), p> {
  let SchedRW =
    [sched.Folded,
     // Memory operand.
     ReadDefault, ReadDefault, ReadDefault, ReadDefault, ReadDefault,
     // Register reads (implicit or explicit).
     sched.ReadAfterFold, sched.ReadAfterFold];
}

multiclass Mul<bits<8> o, string m, Format RegMRM, Format MemMRM, SDPatternOperator node> {
  // AL is really implied by AX, but the registers in Defs must match the
  // SDNode results (i8, i32).
  //
  // FIXME: Used for 8-bit mul, ignore result upper 8 bits.
  // This probably ought to be moved to a def : Pat<> if the
  // syntax can be accepted.
  let Defs = [AL,EFLAGS,AX], Uses = [AL] in
  def 8r : MulDivOpR<o, RegMRM, m, Xi8, WriteIMul8,
                  [(set AL, (node AL, GR8:$src)), (implicit EFLAGS)]>;
  let Defs = [AX,DX,EFLAGS], Uses = [AX] in
  def 16r : MulDivOpR<o, RegMRM, m, Xi16, WriteIMul16, []>, OpSize16;
  let Defs = [EAX,EDX,EFLAGS], Uses = [EAX] in
  def 32r : MulDivOpR<o, RegMRM, m, Xi32, WriteIMul32, []>, OpSize32;
  let Defs = [RAX,RDX,EFLAGS], Uses = [RAX] in
  def 64r : MulDivOpR<o, RegMRM, m, Xi64, WriteIMul64, []>;
  let Defs = [AL,EFLAGS,AX], Uses = [AL] in
  def 8m : MulDivOpM<o, MemMRM, m, Xi8, WriteIMul8,
                  [(set AL, (node AL, (loadi8 addr:$src))), (implicit EFLAGS)]>;
  let Defs = [AX,DX,EFLAGS], Uses = [AX] in
  def 16m : MulDivOpM<o, MemMRM, m, Xi16, WriteIMul16, []>, OpSize16;
  let Defs = [EAX,EDX,EFLAGS], Uses = [EAX] in
  def 32m : MulDivOpM<o, MemMRM, m, Xi32, WriteIMul32, []>, OpSize32;
  let Defs = [RAX,RDX,EFLAGS], Uses = [RAX] in
  def 64m : MulDivOpM<o, MemMRM, m, Xi64, WriteIMul64, []>, Requires<[In64BitMode]>;
}

defm MUL : Mul<0xF7, "mul", MRM4r, MRM4m, mul>;
defm IMUL : Mul<0xF7, "imul", MRM5r, MRM5m, null_frag>;

multiclass Div<bits<8> o, string m, Format RegMRM, Format MemMRM> {
  defvar sched8 = !if(!eq(m, "div"), WriteDiv8, WriteIDiv8);
  defvar sched16 = !if(!eq(m, "div"), WriteDiv16, WriteIDiv16);
  defvar sched32 = !if(!eq(m, "div"), WriteDiv32, WriteIDiv32);
  defvar sched64 = !if(!eq(m, "div"), WriteDiv64, WriteIDiv64);
  let Defs = [AL,AH,EFLAGS], Uses = [AX] in
  def 8r  : MulDivOpR<o, RegMRM, m, Xi8, sched8, []>;
  let Defs = [AX,DX,EFLAGS], Uses = [AX,DX] in
  def 16r : MulDivOpR<o, RegMRM, m, Xi16, sched16, []>, OpSize16;
  let Defs = [EAX,EDX,EFLAGS], Uses = [EAX,EDX] in
  def 32r : MulDivOpR<o, RegMRM, m, Xi32, sched32, []>, OpSize32;
  let Defs = [RAX,RDX,EFLAGS], Uses = [RAX,RDX] in
  def 64r : MulDivOpR<o, RegMRM, m, Xi64, sched64, []>;
  let Defs = [AL,AH,EFLAGS], Uses = [AX] in
  def 8m  : MulDivOpM<o, MemMRM, m, Xi8, sched8, []>;
  let Defs = [AX,DX,EFLAGS], Uses = [AX,DX] in
  def 16m : MulDivOpM<o, MemMRM, m, Xi16, sched16, []>, OpSize16;
  let Defs = [EAX,EDX,EFLAGS], Uses = [EAX,EDX] in
  def 32m : MulDivOpM<o, MemMRM, m, Xi32, sched32, []>, OpSize32;
  let Defs = [RAX,RDX,EFLAGS], Uses = [RAX,RDX] in
  def 64m : MulDivOpM<o, MemMRM, m, Xi64, sched64, []>, Requires<[In64BitMode]>;
}
let hasSideEffects = 1 in { // so that we don't speculatively execute
defm DIV: Div<0xF7, "div", MRM6r, MRM6m>;
defm IDIV: Div<0xF7, "idiv", MRM7r, MRM7m>;
}

class IMulOpRR<X86TypeInfo t, X86FoldableSchedWrite sched>
  : BinOpRR_RF<0xAF, "imul", t, X86smul_flag>, TB {
  let Form = MRMSrcReg;
  let SchedRW = [sched];
  // X = IMUL Y, Z --> X = IMUL Z, Y
  let isCommutable = 1;
}
class IMulOpRM<X86TypeInfo t, X86FoldableSchedWrite sched>
  : BinOpRM_RF<0xAF, "imul", t, X86smul_flag>, TB {
let Form = MRMSrcMem;
let SchedRW = [sched.Folded, sched.ReadAfterFold];
}

let Constraints = "$src1 = $dst" in {
def IMUL16rr : IMulOpRR<Xi16, WriteIMul16Reg>, OpSize16;
def IMUL32rr : IMulOpRR<Xi32, WriteIMul32Reg>, OpSize32;
def IMUL64rr : IMulOpRR<Xi64, WriteIMul64Reg>;
def IMUL16rm : IMulOpRM<Xi16, WriteIMul16Reg>, OpSize16;
def IMUL32rm : IMulOpRM<Xi32, WriteIMul32Reg>, OpSize32;
def IMUL64rm : IMulOpRM<Xi64, WriteIMul64Reg>;
}

class IMulOpRI8_R<X86TypeInfo t, X86FoldableSchedWrite sched>
  : BinOpRI8<0x6B, "imul", binop_ndd_args, t, MRMSrcReg,
             (outs t.RegClass:$dst)>, DefEFLAGS {
  let SchedRW = [sched];
}
class IMulOpRI_R<X86TypeInfo t, X86FoldableSchedWrite sched>
  : BinOpRI<0x69, "imul", binop_ndd_args, t, MRMSrcReg,
            (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS, (X86smul_flag t.RegClass:$src1,
             t.ImmNoSuOperator:$src2))]>, DefEFLAGS {
  let SchedRW = [sched];
}
class IMulOpMI8_R<X86TypeInfo t, X86FoldableSchedWrite sched>
  : BinOpMI8<"imul", binop_ndd_args, t, MRMSrcMem, (outs t.RegClass:$dst)>,
    DefEFLAGS {
  let Opcode = 0x6B;
  let SchedRW = [sched.Folded];
}
class IMulOpMI_R<X86TypeInfo t, X86FoldableSchedWrite sched>
  : BinOpMI<0x69, "imul", binop_ndd_args, t, MRMSrcMem,
            (outs t.RegClass:$dst),
            [(set t.RegClass:$dst, EFLAGS, (X86smul_flag (t.LoadNode addr:$src1),
             t.ImmNoSuOperator:$src2))]>,
    DefEFLAGS {
  let SchedRW = [sched.Folded];
}
def IMUL16rri8 : IMulOpRI8_R<Xi16, WriteIMul16Imm>, OpSize16;
def IMUL32rri8 : IMulOpRI8_R<Xi32, WriteIMul32Imm>, OpSize32;
def IMUL64rri8 : IMulOpRI8_R<Xi64, WriteIMul64Imm>;
def IMUL16rri  : IMulOpRI_R<Xi16, WriteIMul16Imm>, OpSize16;
def IMUL32rri  : IMulOpRI_R<Xi32, WriteIMul32Imm>, OpSize32;
def IMUL64rri32 : IMulOpRI_R<Xi64, WriteIMul64Imm>;

def IMUL16rmi8 : IMulOpMI8_R<Xi16, WriteIMul16Imm>, OpSize16;
def IMUL32rmi8 : IMulOpMI8_R<Xi32, WriteIMul32Imm>, OpSize32;
def IMUL64rmi8 : IMulOpMI8_R<Xi64, WriteIMul64Imm>;
def IMUL16rmi  : IMulOpMI_R<Xi16, WriteIMul16Imm>, OpSize16;
def IMUL32rmi  : IMulOpMI_R<Xi32, WriteIMul32Imm>, OpSize32;
def IMUL64rmi32 : IMulOpMI_R<Xi64, WriteIMul64Imm>;

//===----------------------------------------------------------------------===//
// INC and DEC Instructions
//
class IncOpR_RF<X86TypeInfo t> : UnaryOpR_RF<0xFF, MRM0r, "inc", t, null_frag> {
  let Pattern = [(set t.RegClass:$dst, EFLAGS,
                 (X86add_flag_nocf t.RegClass:$src, 1))];
}
class DecOpR_RF<X86TypeInfo t> : UnaryOpR_RF<0xFF, MRM1r, "dec", t, null_frag> {
  let Pattern = [(set t.RegClass:$dst, EFLAGS,
                 (X86sub_flag_nocf t.RegClass:$src, 1))];
}
class IncOpM_M<X86TypeInfo t> : UnaryOpM_MF<0xFF, MRM0m, "inc", t, null_frag> {
  let Pattern = [(store (add (t.LoadNode addr:$src), 1), addr:$src),
                 (implicit EFLAGS)];
}
class DecOpM_M<X86TypeInfo t> : UnaryOpM_MF<0xFF, MRM1m, "dec", t, null_frag> {
  let Pattern = [(store (add (t.LoadNode addr:$src), -1), addr:$src),
                 (implicit EFLAGS)];
}
// IncDec_Alt - Instructions like "inc reg" short forms.
// Short forms only valid in 32-bit mode. Selected during MCInst lowering.
class IncDec_Alt<bits<8> o, string m, X86TypeInfo t>
  : UnaryOpR_RF<o, AddRegFrm, m, t, null_frag>, Requires<[Not64BitMode]>;

let Constraints = "$src = $dst", isConvertibleToThreeAddress = 1 in {
def INC16r_alt : IncDec_Alt<0x40, "inc", Xi16>, OpSize16;
def INC32r_alt : IncDec_Alt<0x40, "inc", Xi32>, OpSize32;
def DEC16r_alt : IncDec_Alt<0x48, "dec", Xi16>, OpSize16;
def DEC32r_alt : IncDec_Alt<0x48, "dec", Xi32>, OpSize32;
def INC8r  : IncOpR_RF<Xi8>;
def INC16r : IncOpR_RF<Xi16>, OpSize16;
def INC32r : IncOpR_RF<Xi32>, OpSize32;
def INC64r : IncOpR_RF<Xi64>;
def DEC8r  : DecOpR_RF<Xi8>;
def DEC16r : DecOpR_RF<Xi16>, OpSize16;
def DEC32r : DecOpR_RF<Xi32>, OpSize32;
def DEC64r : DecOpR_RF<Xi64>;
}
let Predicates = [UseIncDec] in {
def INC8m  : IncOpM_M<Xi8>;
def INC16m : IncOpM_M<Xi16>, OpSize16;
def INC32m : IncOpM_M<Xi32>, OpSize32;
def DEC8m  : DecOpM_M<Xi8>;
def DEC16m : DecOpM_M<Xi16>, OpSize16;
def DEC32m : DecOpM_M<Xi32>, OpSize32;
}
let Predicates = [UseIncDec, In64BitMode] in {
def INC64m : IncOpM_M<Xi64>;
def DEC64m : DecOpM_M<Xi64>;
}

//===----------------------------------------------------------------------===//
// NEG and NOT Instructions
//
class NegOpR_RF<X86TypeInfo t> : UnaryOpR_RF<0xF7, MRM3r, "neg", t, ineg>;
class NegOpM_MF<X86TypeInfo t> : UnaryOpM_MF<0xF7, MRM3m, "neg", t, ineg>;

class NotOpR_R<X86TypeInfo t> : UnaryOpR_R<0xF7, MRM2r, "not", t, not>;
class NotOpM_M<X86TypeInfo t> : UnaryOpM_M<0xF7, MRM2m, "not", t, not>;

let Constraints = "$src = $dst" in {
def NEG8r  : NegOpR_RF<Xi8>;
def NEG16r : NegOpR_RF<Xi16>, OpSize16;
def NEG32r : NegOpR_RF<Xi32>, OpSize32;
def NEG64r : NegOpR_RF<Xi64>;

def NOT8r  : NotOpR_R<Xi8>;
def NOT16r : NotOpR_R<Xi16>, OpSize16;
def NOT32r : NotOpR_R<Xi32>, OpSize32;
def NOT64r : NotOpR_R<Xi64>;
}

def NEG8m  : NegOpM_MF<Xi8>;
def NEG16m : NegOpM_MF<Xi16>, OpSize16;
def NEG32m : NegOpM_MF<Xi32>, OpSize32;
def NEG64m : NegOpM_MF<Xi64>, Requires<[In64BitMode]>;

def NOT8m  : NotOpM_M<Xi8>;
def NOT16m : NotOpM_M<Xi16>, OpSize16;
def NOT32m : NotOpM_M<Xi32>, OpSize32;
def NOT64m : NotOpM_M<Xi64>, Requires<[In64BitMode]>;

/// ArithBinOp_RF - This is an arithmetic binary operator where the pattern is
/// defined with "(set GPR:$dst, EFLAGS, (...".
///
/// It would be nice to get rid of the second and third argument here, but
/// tblgen can't handle dependent type references aggressively enough: PR8330
multiclass ArithBinOp_RF<bits<8> BaseOpc, bits<8> BaseOpc2, bits<8> BaseOpc4,
                         string mnemonic, Format RegMRM, Format MemMRM,
                         SDNode opnodeflag, SDNode opnode,
                         bit CommutableRR, bit ConvertibleToThreeAddress,
                         bit ConvertibleToThreeAddressRR> {
  let Constraints = "$src1 = $dst" in {
    let isCommutable = CommutableRR,
        isConvertibleToThreeAddress = ConvertibleToThreeAddressRR in {
    def NAME#8rr  : BinOpRR_RF<BaseOpc, mnemonic, Xi8 , opnodeflag>;
    def NAME#16rr : BinOpRR_RF<BaseOpc, mnemonic, Xi16, opnodeflag>, OpSize16;
    def NAME#32rr : BinOpRR_RF<BaseOpc, mnemonic, Xi32, opnodeflag>, OpSize32;
    def NAME#64rr : BinOpRR_RF<BaseOpc, mnemonic, Xi64, opnodeflag>;
    }

  def NAME#8rr_REV  : BinOpRR_RF_Rev<BaseOpc2, mnemonic, Xi8>;
  def NAME#16rr_REV : BinOpRR_RF_Rev<BaseOpc2, mnemonic, Xi16>, OpSize16;
  def NAME#32rr_REV : BinOpRR_RF_Rev<BaseOpc2, mnemonic, Xi32>, OpSize32;
  def NAME#64rr_REV : BinOpRR_RF_Rev<BaseOpc2, mnemonic, Xi64>;

  def NAME#8rm   : BinOpRM_RF<BaseOpc2, mnemonic, Xi8 , opnodeflag>;
  def NAME#16rm  : BinOpRM_RF<BaseOpc2, mnemonic, Xi16, opnodeflag>, OpSize16;
  def NAME#32rm  : BinOpRM_RF<BaseOpc2, mnemonic, Xi32, opnodeflag>, OpSize32;
  def NAME#64rm  : BinOpRM_RF<BaseOpc2, mnemonic, Xi64, opnodeflag>;

    let isConvertibleToThreeAddress = ConvertibleToThreeAddress in {
    def NAME#8ri   : BinOpRI_RF<0x80, mnemonic, Xi8 , opnodeflag, RegMRM>;
    // NOTE: These are order specific, we want the ri8 forms to be listed
    // first so that they are slightly preferred to the ri forms.
    def NAME#16ri8 : BinOpRI8_RF<0x83, mnemonic, Xi16, RegMRM>, OpSize16;
    def NAME#32ri8 : BinOpRI8_RF<0x83, mnemonic, Xi32, RegMRM>, OpSize32;
    def NAME#64ri8 : BinOpRI8_RF<0x83, mnemonic, Xi64, RegMRM>;

    def NAME#16ri  : BinOpRI_RF<0x81, mnemonic, Xi16, opnodeflag, RegMRM>, OpSize16;
    def NAME#32ri  : BinOpRI_RF<0x81, mnemonic, Xi32, opnodeflag, RegMRM>, OpSize32;
    def NAME#64ri32: BinOpRI_RF<0x81, mnemonic, Xi64, opnodeflag, RegMRM>;
    }
  } // Constraints = "$src1 = $dst"

  def NAME#8mr    : BinOpMR_MF<BaseOpc, mnemonic, Xi8 , opnode>;
  def NAME#16mr   : BinOpMR_MF<BaseOpc, mnemonic, Xi16, opnode>, OpSize16;
  def NAME#32mr   : BinOpMR_MF<BaseOpc, mnemonic, Xi32, opnode>, OpSize32;
  def NAME#64mr   : BinOpMR_MF<BaseOpc, mnemonic, Xi64, opnode>;

  // NOTE: These are order specific, we want the mi8 forms to be listed
  // first so that they are slightly preferred to the mi forms.
  def NAME#16mi8  : BinOpMI8_MF<mnemonic, Xi16, MemMRM>, OpSize16;
  def NAME#32mi8  : BinOpMI8_MF<mnemonic, Xi32, MemMRM>, OpSize32;
  let Predicates = [In64BitMode] in
  def NAME#64mi8  : BinOpMI8_MF<mnemonic, Xi64, MemMRM>;

  def NAME#8mi    : BinOpMI_MF<0x80, mnemonic, Xi8 , opnode, MemMRM>;
  def NAME#16mi   : BinOpMI_MF<0x81, mnemonic, Xi16, opnode, MemMRM>, OpSize16;
  def NAME#32mi   : BinOpMI_MF<0x81, mnemonic, Xi32, opnode, MemMRM>, OpSize32;
  let Predicates = [In64BitMode] in
  def NAME#64mi32 : BinOpMI_MF<0x81, mnemonic, Xi64, opnode, MemMRM>;

  // These are for the disassembler since 0x82 opcode behaves like 0x80, but
  // not in 64-bit mode.
  let Predicates = [Not64BitMode] in {
  let Constraints = "$src1 = $dst" in
  def NAME#8ri8 : BinOpRI8_RF<0x82, mnemonic, Xi8, RegMRM>, DisassembleOnly;
  def NAME#8mi8 : BinOpMI8_MF<mnemonic, Xi8, MemMRM>, DisassembleOnly;
  }

  def NAME#8i8 : BinOpAI_AF<BaseOpc4, mnemonic, Xi8 , AL,
                            "{$src, %al|al, $src}">;
  def NAME#16i16 : BinOpAI_AF<BaseOpc4, mnemonic, Xi16, AX,
                              "{$src, %ax|ax, $src}">, OpSize16;
  def NAME#32i32 : BinOpAI_AF<BaseOpc4, mnemonic, Xi32, EAX,
                              "{$src, %eax|eax, $src}">, OpSize32;
  def NAME#64i32 : BinOpAI_AF<BaseOpc4, mnemonic, Xi64, RAX,
                              "{$src, %rax|rax, $src}">;
}

/// ArithBinOp_RFF - This is an arithmetic binary operator where the pattern is
/// defined with "(set GPR:$dst, EFLAGS, (node LHS, RHS, EFLAGS))" like ADC and
/// SBB.
///
/// It would be nice to get rid of the second and third argument here, but
/// tblgen can't handle dependent type references aggressively enough: PR8330
multiclass ArithBinOp_RFF<bits<8> BaseOpc, bits<8> BaseOpc2, bits<8> BaseOpc4,
                          string mnemonic, Format RegMRM, Format MemMRM,
                          SDNode opnode, bit CommutableRR,
                           bit ConvertibleToThreeAddress> {
  let Constraints = "$src1 = $dst" in {
    let isCommutable = CommutableRR in {
    def NAME#8rr  : BinOpRRF_RF<BaseOpc, mnemonic, Xi8 , opnode>;
      let isConvertibleToThreeAddress = ConvertibleToThreeAddress in {
      def NAME#16rr : BinOpRRF_RF<BaseOpc, mnemonic, Xi16, opnode>, OpSize16;
      def NAME#32rr : BinOpRRF_RF<BaseOpc, mnemonic, Xi32, opnode>, OpSize32;
      def NAME#64rr : BinOpRRF_RF<BaseOpc, mnemonic, Xi64, opnode>;
    } // isConvertibleToThreeAddress
  } // isCommutable

  def NAME#8rr_REV  : BinOpRRF_RF_Rev<BaseOpc2, mnemonic, Xi8>;
  def NAME#16rr_REV : BinOpRRF_RF_Rev<BaseOpc2, mnemonic, Xi16>, OpSize16;
  def NAME#32rr_REV : BinOpRRF_RF_Rev<BaseOpc2, mnemonic, Xi32>, OpSize32;
  def NAME#64rr_REV : BinOpRRF_RF_Rev<BaseOpc2, mnemonic, Xi64>;

  def NAME#8rm   : BinOpRMF_RF<BaseOpc2, mnemonic, Xi8 , opnode>;
  def NAME#16rm  : BinOpRMF_RF<BaseOpc2, mnemonic, Xi16, opnode>, OpSize16;
  def NAME#32rm  : BinOpRMF_RF<BaseOpc2, mnemonic, Xi32, opnode>, OpSize32;
  def NAME#64rm  : BinOpRMF_RF<BaseOpc2, mnemonic, Xi64, opnode>;

  def NAME#8ri   : BinOpRIF_RF<0x80, mnemonic, Xi8 , opnode, RegMRM>;
    let isConvertibleToThreeAddress = ConvertibleToThreeAddress in {
    // NOTE: These are order specific, we want the ri8 forms to be listed
    // first so that they are slightly preferred to the ri forms.
    def NAME#16ri8 : BinOpRI8F_RF<0x83, mnemonic, Xi16, RegMRM>, OpSize16;
    def NAME#32ri8 : BinOpRI8F_RF<0x83, mnemonic, Xi32, RegMRM>, OpSize32;
    def NAME#64ri8 : BinOpRI8F_RF<0x83, mnemonic, Xi64, RegMRM>;

    def NAME#16ri  : BinOpRIF_RF<0x81, mnemonic, Xi16, opnode, RegMRM>, OpSize16;
    def NAME#32ri  : BinOpRIF_RF<0x81, mnemonic, Xi32, opnode, RegMRM>, OpSize32;
    def NAME#64ri32: BinOpRIF_RF<0x81, mnemonic, Xi64, opnode, RegMRM>;
    }
  } // Constraints = "$src1 = $dst"

  def NAME#8mr    : BinOpMRF_MF<BaseOpc, mnemonic, Xi8 , opnode>;
  def NAME#16mr   : BinOpMRF_MF<BaseOpc, mnemonic, Xi16, opnode>, OpSize16;
  def NAME#32mr   : BinOpMRF_MF<BaseOpc, mnemonic, Xi32, opnode>, OpSize32;
  def NAME#64mr   : BinOpMRF_MF<BaseOpc, mnemonic, Xi64, opnode>;

  // NOTE: These are order specific, we want the mi8 forms to be listed
  // first so that they are slightly preferred to the mi forms.
  def NAME#16mi8  : BinOpMI8F_MF<mnemonic, Xi16, MemMRM>, OpSize16;
  def NAME#32mi8  : BinOpMI8F_MF<mnemonic, Xi32, MemMRM>, OpSize32;
  let Predicates = [In64BitMode] in
  def NAME#64mi8  : BinOpMI8F_MF<mnemonic, Xi64, MemMRM>;

  def NAME#8mi    : BinOpMIF_MF<0x80, mnemonic, Xi8 , opnode, MemMRM>;
  def NAME#16mi   : BinOpMIF_MF<0x81, mnemonic, Xi16, opnode, MemMRM>, OpSize16;
  def NAME#32mi   : BinOpMIF_MF<0x81, mnemonic, Xi32, opnode, MemMRM>, OpSize32;
  let Predicates = [In64BitMode] in
  def NAME#64mi32 : BinOpMIF_MF<0x81, mnemonic, Xi64, opnode, MemMRM>;

  // These are for the disassembler since 0x82 opcode behaves like 0x80, but
  // not in 64-bit mode.
  let Predicates = [Not64BitMode]  in {
    let Constraints = "$src1 = $dst" in
    def NAME#8ri8 : BinOpRI8F_RF<0x82, mnemonic, Xi8, RegMRM>, DisassembleOnly;
  def NAME#8mi8 : BinOpMI8F_MF<mnemonic, Xi8, MemMRM>, DisassembleOnly;
  }

  def NAME#8i8 : BinOpAIF_AF<BaseOpc4, mnemonic, Xi8 , AL,
                             "{$src, %al|al, $src}">;
  def NAME#16i16 : BinOpAIF_AF<BaseOpc4, mnemonic, Xi16, AX,
                               "{$src, %ax|ax, $src}">, OpSize16;
  def NAME#32i32 : BinOpAIF_AF<BaseOpc4, mnemonic, Xi32, EAX,
                               "{$src, %eax|eax, $src}">, OpSize32;
  def NAME#64i32 : BinOpAIF_AF<BaseOpc4, mnemonic, Xi64, RAX,
                               "{$src, %rax|rax, $src}">;
}

/// ArithBinOp_F - This is an arithmetic binary operator where the pattern is
/// defined with "(set EFLAGS, (...".  It would be really nice to find a way
/// to factor this with the other ArithBinOp_*.
///
multiclass ArithBinOp_F<bits<8> BaseOpc, bits<8> BaseOpc2, bits<8> BaseOpc4,
                        string mnemonic, Format RegMRM, Format MemMRM,
                        SDNode opnode, bit CommutableRR,
                        bit ConvertibleToThreeAddress> {
  let isCommutable = CommutableRR in {
  def NAME#8rr  : BinOpRR_F<BaseOpc, mnemonic, Xi8 , opnode>;
    let isConvertibleToThreeAddress = ConvertibleToThreeAddress in {
    def NAME#16rr : BinOpRR_F<BaseOpc, mnemonic, Xi16, opnode>, OpSize16;
    def NAME#32rr : BinOpRR_F<BaseOpc, mnemonic, Xi32, opnode>, OpSize32;
    def NAME#64rr : BinOpRR_F<BaseOpc, mnemonic, Xi64, opnode>;
    } // isConvertibleToThreeAddress
  } // isCommutable

  def NAME#8rr_REV  : BinOpRR_F_Rev<BaseOpc2, mnemonic, Xi8>;
  def NAME#16rr_REV : BinOpRR_F_Rev<BaseOpc2, mnemonic, Xi16>, OpSize16;
  def NAME#32rr_REV : BinOpRR_F_Rev<BaseOpc2, mnemonic, Xi32>, OpSize32;
  def NAME#64rr_REV : BinOpRR_F_Rev<BaseOpc2, mnemonic, Xi64>;

  def NAME#8rm   : BinOpRM_F<BaseOpc2, mnemonic, Xi8 , opnode>;
  def NAME#16rm  : BinOpRM_F<BaseOpc2, mnemonic, Xi16, opnode>, OpSize16;
  def NAME#32rm  : BinOpRM_F<BaseOpc2, mnemonic, Xi32, opnode>, OpSize32;
  def NAME#64rm  : BinOpRM_F<BaseOpc2, mnemonic, Xi64, opnode>;

  def NAME#8ri   : BinOpRI_F<0x80, mnemonic, Xi8 , opnode, RegMRM>;

  let isConvertibleToThreeAddress = ConvertibleToThreeAddress in {
  // NOTE: These are order specific, we want the ri8 forms to be listed
  // first so that they are slightly preferred to the ri forms.
  def NAME#16ri8 : BinOpRI8_F<0x83, mnemonic, Xi16, RegMRM>, OpSize16;
  def NAME#32ri8 : BinOpRI8_F<0x83, mnemonic, Xi32, RegMRM>, OpSize32;
  def NAME#64ri8 : BinOpRI8_F<0x83, mnemonic, Xi64, RegMRM>;

  def NAME#16ri  : BinOpRI_F<0x81, mnemonic, Xi16, opnode, RegMRM>, OpSize16;
  def NAME#32ri  : BinOpRI_F<0x81, mnemonic, Xi32, opnode, RegMRM>, OpSize32;
  def NAME#64ri32: BinOpRI_F<0x81, mnemonic, Xi64, opnode, RegMRM>;
  }

  def NAME#8mr    : BinOpMR_F<BaseOpc, mnemonic, Xi8 , opnode>;
  def NAME#16mr   : BinOpMR_F<BaseOpc, mnemonic, Xi16, opnode>, OpSize16;
  def NAME#32mr   : BinOpMR_F<BaseOpc, mnemonic, Xi32, opnode>, OpSize32;
  def NAME#64mr   : BinOpMR_F<BaseOpc, mnemonic, Xi64, opnode>;

  // NOTE: These are order specific, we want the mi8 forms to be listed
  // first so that they are slightly preferred to the mi forms.
  def NAME#16mi8  : BinOpMI8_F<mnemonic, Xi16, MemMRM>, OpSize16;
  def NAME#32mi8  : BinOpMI8_F<mnemonic, Xi32, MemMRM>, OpSize32;
  let Predicates = [In64BitMode] in
  def NAME#64mi8  : BinOpMI8_F<mnemonic, Xi64, MemMRM>;

  def NAME#8mi    : BinOpMI_F<0x80, mnemonic, Xi8 , opnode, MemMRM>;
  def NAME#16mi   : BinOpMI_F<0x81, mnemonic, Xi16, opnode, MemMRM>, OpSize16;
  def NAME#32mi   : BinOpMI_F<0x81, mnemonic, Xi32, opnode, MemMRM>, OpSize32;
  let Predicates = [In64BitMode] in
  def NAME#64mi32 : BinOpMI_F<0x81, mnemonic, Xi64, opnode, MemMRM>;

  // These are for the disassembler since 0x82 opcode behaves like 0x80, but
  // not in 64-bit mode.
  let Predicates = [Not64BitMode] in {
  def NAME#8ri8 : BinOpRI8_F<0x82, mnemonic, Xi8, RegMRM>, DisassembleOnly;
    let mayLoad = 1 in
    def NAME#8mi8 : BinOpMI8_F<mnemonic, Xi8, MemMRM>;
  }

  def NAME#8i8 : BinOpAI_F<BaseOpc4, mnemonic, Xi8 , AL,
                           "{$src, %al|al, $src}">;
  def NAME#16i16 : BinOpAI_F<BaseOpc4, mnemonic, Xi16, AX,
                           "{$src, %ax|ax, $src}">, OpSize16;
  def NAME#32i32 : BinOpAI_F<BaseOpc4, mnemonic, Xi32, EAX,
                           "{$src, %eax|eax, $src}">, OpSize32;
  def NAME#64i32 : BinOpAI_F<BaseOpc4, mnemonic, Xi64, RAX,
                           "{$src, %rax|rax, $src}">;
}


defm AND : ArithBinOp_RF<0x21, 0x23, 0x25, "and", MRM4r, MRM4m,
                         X86and_flag, and, 1, 0, 0>;
defm OR  : ArithBinOp_RF<0x09, 0x0B, 0x0D, "or", MRM1r, MRM1m,
                         X86or_flag, or, 1, 0, 0>;
defm XOR : ArithBinOp_RF<0x31, 0x33, 0x35, "xor", MRM6r, MRM6m,
                         X86xor_flag, xor, 1, 0, 0>;
defm ADD : ArithBinOp_RF<0x01, 0x03, 0x05, "add", MRM0r, MRM0m,
                         X86add_flag, add, 1, 1, 1>;
let isCompare = 1 in {
defm SUB : ArithBinOp_RF<0x29, 0x2B, 0x2D, "sub", MRM5r, MRM5m,
                         X86sub_flag, sub, 0, 1, 0>;
}

// Version of XOR8rr_NOREX that use GR8_NOREX. This is used by the handling of
// __builtin_parity where the last step xors an h-register with an l-register.
let isCodeGenOnly = 1, hasSideEffects = 0, Constraints = "$src1 = $dst",
    Defs = [EFLAGS], isCommutable = 1 in
def XOR8rr_NOREX : I<0x30, MRMDestReg, (outs GR8_NOREX:$dst),
                     (ins GR8_NOREX:$src1, GR8_NOREX:$src2),
                     "xor{b}\t{$src2, $dst|$dst, $src2}", []>,
                     Sched<[WriteALU]>;

// Arithmetic.
defm ADC : ArithBinOp_RFF<0x11, 0x13, 0x15, "adc", MRM2r, MRM2m, X86adc_flag,
                          1, 0>;
defm SBB : ArithBinOp_RFF<0x19, 0x1B, 0x1D, "sbb", MRM3r, MRM3m, X86sbb_flag,
                          0, 0>;

let isCompare = 1 in {
defm CMP : ArithBinOp_F<0x39, 0x3B, 0x3D, "cmp", MRM7r, MRM7m, X86cmp, 0, 0>;
}

// Patterns to recognize loads on the LHS of an ADC. We can't make X86adc_flag
// commutable since it has EFLAGs as an input.
def : Pat<(X86adc_flag (loadi8 addr:$src2), GR8:$src1, EFLAGS),
          (ADC8rm GR8:$src1, addr:$src2)>;
def : Pat<(X86adc_flag (loadi16 addr:$src2), GR16:$src1, EFLAGS),
          (ADC16rm GR16:$src1, addr:$src2)>;
def : Pat<(X86adc_flag (loadi32 addr:$src2), GR32:$src1, EFLAGS),
          (ADC32rm GR32:$src1, addr:$src2)>;
def : Pat<(X86adc_flag (loadi64 addr:$src2), GR64:$src1, EFLAGS),
          (ADC64rm GR64:$src1, addr:$src2)>;

// Patterns to recognize RMW ADC with loads in operand 1.
def : Pat<(store (X86adc_flag GR8:$src, (loadi8 addr:$dst), EFLAGS),
                 addr:$dst),
          (ADC8mr addr:$dst, GR8:$src)>;
def : Pat<(store (X86adc_flag GR16:$src, (loadi16 addr:$dst), EFLAGS),
                 addr:$dst),
          (ADC16mr addr:$dst, GR16:$src)>;
def : Pat<(store (X86adc_flag GR32:$src, (loadi32 addr:$dst), EFLAGS),
                 addr:$dst),
          (ADC32mr addr:$dst, GR32:$src)>;
def : Pat<(store (X86adc_flag GR64:$src, (loadi64 addr:$dst), EFLAGS),
                 addr:$dst),
          (ADC64mr addr:$dst, GR64:$src)>;

// Patterns for basic arithmetic ops with relocImm for the immediate field.
multiclass ArithBinOp_RF_relocImm_Pats<SDNode OpNodeFlag, SDNode OpNode> {
  def : Pat<(OpNodeFlag GR8:$src1, relocImm8_su:$src2),
            (!cast<Instruction>(NAME#"8ri") GR8:$src1, relocImm8_su:$src2)>;
  def : Pat<(OpNodeFlag GR16:$src1, relocImm16_su:$src2),
            (!cast<Instruction>(NAME#"16ri") GR16:$src1, relocImm16_su:$src2)>;
  def : Pat<(OpNodeFlag GR32:$src1, relocImm32_su:$src2),
            (!cast<Instruction>(NAME#"32ri") GR32:$src1, relocImm32_su:$src2)>;
  def : Pat<(OpNodeFlag GR64:$src1, i64relocImmSExt32_su:$src2),
            (!cast<Instruction>(NAME#"64ri32") GR64:$src1, i64relocImmSExt32_su:$src2)>;

  def : Pat<(store (OpNode (load addr:$dst), relocImm8_su:$src), addr:$dst),
            (!cast<Instruction>(NAME#"8mi") addr:$dst, relocImm8_su:$src)>;
  def : Pat<(store (OpNode (load addr:$dst), relocImm16_su:$src), addr:$dst),
            (!cast<Instruction>(NAME#"16mi") addr:$dst, relocImm16_su:$src)>;
  def : Pat<(store (OpNode (load addr:$dst), relocImm32_su:$src), addr:$dst),
            (!cast<Instruction>(NAME#"32mi") addr:$dst, relocImm32_su:$src)>;
  def : Pat<(store (OpNode (load addr:$dst), i64relocImmSExt32_su:$src), addr:$dst),
            (!cast<Instruction>(NAME#"64mi32") addr:$dst, i64relocImmSExt32_su:$src)>;
}

multiclass ArithBinOp_RFF_relocImm_Pats<SDNode OpNodeFlag> {
  def : Pat<(OpNodeFlag GR8:$src1, relocImm8_su:$src2, EFLAGS),
            (!cast<Instruction>(NAME#"8ri") GR8:$src1, relocImm8_su:$src2)>;
  def : Pat<(OpNodeFlag GR16:$src1, relocImm16_su:$src2, EFLAGS),
            (!cast<Instruction>(NAME#"16ri") GR16:$src1, relocImm16_su:$src2)>;
  def : Pat<(OpNodeFlag GR32:$src1, relocImm32_su:$src2, EFLAGS),
            (!cast<Instruction>(NAME#"32ri") GR32:$src1, relocImm32_su:$src2)>;
  def : Pat<(OpNodeFlag GR64:$src1, i64relocImmSExt32_su:$src2, EFLAGS),
            (!cast<Instruction>(NAME#"64ri32") GR64:$src1, i64relocImmSExt32_su:$src2)>;

  def : Pat<(store (OpNodeFlag (load addr:$dst), relocImm8_su:$src, EFLAGS), addr:$dst),
            (!cast<Instruction>(NAME#"8mi") addr:$dst, relocImm8_su:$src)>;
  def : Pat<(store (OpNodeFlag (load addr:$dst), relocImm16_su:$src, EFLAGS), addr:$dst),
            (!cast<Instruction>(NAME#"16mi") addr:$dst, relocImm16_su:$src)>;
  def : Pat<(store (OpNodeFlag (load addr:$dst), relocImm32_su:$src, EFLAGS), addr:$dst),
            (!cast<Instruction>(NAME#"32mi") addr:$dst, relocImm32_su:$src)>;
  def : Pat<(store (OpNodeFlag (load addr:$dst), i64relocImmSExt32_su:$src, EFLAGS), addr:$dst),
            (!cast<Instruction>(NAME#"64mi32") addr:$dst, i64relocImmSExt32_su:$src)>;
}

multiclass ArithBinOp_F_relocImm_Pats<SDNode OpNodeFlag> {
  def : Pat<(OpNodeFlag GR8:$src1, relocImm8_su:$src2),
            (!cast<Instruction>(NAME#"8ri") GR8:$src1, relocImm8_su:$src2)>;
  def : Pat<(OpNodeFlag GR16:$src1, relocImm16_su:$src2),
            (!cast<Instruction>(NAME#"16ri") GR16:$src1, relocImm16_su:$src2)>;
  def : Pat<(OpNodeFlag GR32:$src1, relocImm32_su:$src2),
            (!cast<Instruction>(NAME#"32ri") GR32:$src1, relocImm32_su:$src2)>;
  def : Pat<(OpNodeFlag GR64:$src1, i64relocImmSExt32_su:$src2),
            (!cast<Instruction>(NAME#"64ri32") GR64:$src1, i64relocImmSExt32_su:$src2)>;

  def : Pat<(OpNodeFlag (loadi8 addr:$src1), relocImm8_su:$src2),
            (!cast<Instruction>(NAME#"8mi") addr:$src1, relocImm8_su:$src2)>;
  def : Pat<(OpNodeFlag (loadi16 addr:$src1), relocImm16_su:$src2),
            (!cast<Instruction>(NAME#"16mi") addr:$src1, relocImm16_su:$src2)>;
  def : Pat<(OpNodeFlag (loadi32 addr:$src1), relocImm32_su:$src2),
            (!cast<Instruction>(NAME#"32mi") addr:$src1, relocImm32_su:$src2)>;
  def : Pat<(OpNodeFlag (loadi64 addr:$src1), i64relocImmSExt32_su:$src2),
            (!cast<Instruction>(NAME#"64mi32") addr:$src1, i64relocImmSExt32_su:$src2)>;
}

defm AND : ArithBinOp_RF_relocImm_Pats<X86and_flag, and>;
defm OR  : ArithBinOp_RF_relocImm_Pats<X86or_flag, or>;
defm XOR : ArithBinOp_RF_relocImm_Pats<X86xor_flag, xor>;
defm ADD : ArithBinOp_RF_relocImm_Pats<X86add_flag, add>;
defm SUB : ArithBinOp_RF_relocImm_Pats<X86sub_flag, sub>;

defm ADC : ArithBinOp_RFF_relocImm_Pats<X86adc_flag>;
defm SBB : ArithBinOp_RFF_relocImm_Pats<X86sbb_flag>;

defm CMP : ArithBinOp_F_relocImm_Pats<X86cmp>;

// ADC is commutable, but we can't indicate that to tablegen. So manually
// reverse the operands.
def : Pat<(X86adc_flag GR8:$src1, relocImm8_su:$src2, EFLAGS),
          (ADC8ri relocImm8_su:$src2, GR8:$src1)>;
def : Pat<(X86adc_flag i16relocImmSExt8_su:$src2, GR16:$src1, EFLAGS),
          (ADC16ri8 GR16:$src1, i16relocImmSExt8_su:$src2)>;
def : Pat<(X86adc_flag relocImm16_su:$src2, GR16:$src1, EFLAGS),
          (ADC16ri GR16:$src1, relocImm16_su:$src2)>;
def : Pat<(X86adc_flag i32relocImmSExt8_su:$src2, GR32:$src1, EFLAGS),
          (ADC32ri8 GR32:$src1, i32relocImmSExt8_su:$src2)>;
def : Pat<(X86adc_flag relocImm32_su:$src2, GR32:$src1, EFLAGS),
          (ADC32ri GR32:$src1, relocImm32_su:$src2)>;
def : Pat<(X86adc_flag i64relocImmSExt8_su:$src2, GR64:$src1, EFLAGS),
          (ADC64ri8 GR64:$src1, i64relocImmSExt8_su:$src2)>;
def : Pat<(X86adc_flag i64relocImmSExt32_su:$src2, GR64:$src1, EFLAGS),
          (ADC64ri32 GR64:$src1, i64relocImmSExt32_su:$src2)>;

def : Pat<(store (X86adc_flag relocImm8_su:$src, (load addr:$dst), EFLAGS), addr:$dst),
          (ADC8mi addr:$dst, relocImm8_su:$src)>;
def : Pat<(store (X86adc_flag i16relocImmSExt8_su:$src, (load addr:$dst), EFLAGS), addr:$dst),
          (ADC16mi8 addr:$dst, i16relocImmSExt8_su:$src)>;
def : Pat<(store (X86adc_flag relocImm16_su:$src, (load addr:$dst), EFLAGS), addr:$dst),
          (ADC16mi addr:$dst, relocImm16_su:$src)>;
def : Pat<(store (X86adc_flag i32relocImmSExt8_su:$src, (load addr:$dst), EFLAGS), addr:$dst),
          (ADC32mi8 addr:$dst, i32relocImmSExt8_su:$src)>;
def : Pat<(store (X86adc_flag relocImm32_su:$src, (load addr:$dst), EFLAGS), addr:$dst),
          (ADC32mi addr:$dst, relocImm32_su:$src)>;
def : Pat<(store (X86adc_flag i64relocImmSExt8_su:$src, (load addr:$dst), EFLAGS), addr:$dst),
          (ADC64mi8 addr:$dst, i64relocImmSExt8_su:$src)>;
def : Pat<(store (X86adc_flag i64relocImmSExt32_su:$src, (load addr:$dst), EFLAGS), addr:$dst),
          (ADC64mi32 addr:$dst, i64relocImmSExt32_su:$src)>;

//===----------------------------------------------------------------------===//
// Semantically, test instructions are similar like AND, except they don't
// generate a result.  From an encoding perspective, they are very different:
// they don't have all the usual imm8 and REV forms, and are encoded into a
// different space.
let isCompare = 1 in {
  let isCommutable = 1 in {
  // Avoid selecting these and instead use a test+and. Post processing will
  // combine them. This gives bunch of other patterns that start with
  // and a chance to match.
  def TEST8rr  : BinOpRR_F<0x84, "test", Xi8 , null_frag>;
  def TEST16rr : BinOpRR_F<0x85, "test", Xi16, null_frag>, OpSize16;
  def TEST32rr : BinOpRR_F<0x85, "test", Xi32, null_frag>, OpSize32;
  def TEST64rr : BinOpRR_F<0x85, "test", Xi64, null_frag>;
  } // isCommutable

def TEST8mr    : BinOpMR_F<0x84, "test", Xi8 , null_frag>;
def TEST16mr   : BinOpMR_F<0x85, "test", Xi16, null_frag>, OpSize16;
def TEST32mr   : BinOpMR_F<0x85, "test", Xi32, null_frag>, OpSize32;
def TEST64mr   : BinOpMR_F<0x85, "test", Xi64, null_frag>;

def TEST8ri    : BinOpRI_F<0xF6, "test", Xi8 , X86testpat, MRM0r>;
def TEST16ri   : BinOpRI_F<0xF7, "test", Xi16, X86testpat, MRM0r>, OpSize16;
def TEST32ri   : BinOpRI_F<0xF7, "test", Xi32, X86testpat, MRM0r>, OpSize32;
def TEST64ri32 : BinOpRI_F<0xF7, "test", Xi64, X86testpat, MRM0r>;

def TEST8mi    : BinOpMI_F<0xF6, "test", Xi8 , X86testpat, MRM0m>;
def TEST16mi   : BinOpMI_F<0xF7, "test", Xi16, X86testpat, MRM0m>, OpSize16;
def TEST32mi   : BinOpMI_F<0xF7, "test", Xi32, X86testpat, MRM0m>, OpSize32;

  let Predicates = [In64BitMode] in
  def TEST64mi32 : BinOpMI_F<0xF7, "test", Xi64, X86testpat, MRM0m>;

def TEST8i8 : BinOpAI_F<0xA8, "test", Xi8 , AL, "{$src, %al|al, $src}">;
def TEST16i16 : BinOpAI_F<0xA9, "test", Xi16, AX, "{$src, %ax|ax, $src}">, OpSize16;
def TEST32i32 : BinOpAI_F<0xA9, "test", Xi32, EAX, "{$src, %eax|eax, $src}">, OpSize32;
def TEST64i32 : BinOpAI_F<0xA9, "test", Xi64, RAX, "{$src, %rax|rax, $src}">;
} // isCompare

// Patterns to match a relocImm into the immediate field.
def : Pat<(X86testpat GR8:$src1, relocImm8_su:$src2),
          (TEST8ri GR8:$src1, relocImm8_su:$src2)>;
def : Pat<(X86testpat GR16:$src1, relocImm16_su:$src2),
          (TEST16ri GR16:$src1, relocImm16_su:$src2)>;
def : Pat<(X86testpat GR32:$src1, relocImm32_su:$src2),
          (TEST32ri GR32:$src1, relocImm32_su:$src2)>;
def : Pat<(X86testpat GR64:$src1, i64relocImmSExt32_su:$src2),
          (TEST64ri32 GR64:$src1, i64relocImmSExt32_su:$src2)>;

def : Pat<(X86testpat (loadi8 addr:$src1), relocImm8_su:$src2),
          (TEST8mi addr:$src1, relocImm8_su:$src2)>;
def : Pat<(X86testpat (loadi16 addr:$src1), relocImm16_su:$src2),
          (TEST16mi addr:$src1, relocImm16_su:$src2)>;
def : Pat<(X86testpat (loadi32 addr:$src1), relocImm32_su:$src2),
          (TEST32mi addr:$src1, relocImm32_su:$src2)>;
def : Pat<(X86testpat (loadi64 addr:$src1), i64relocImmSExt32_su:$src2),
          (TEST64mi32 addr:$src1, i64relocImmSExt32_su:$src2)>;

//===----------------------------------------------------------------------===//
// ANDN Instruction
//
multiclass AndN<X86TypeInfo t, string suffix> {
  defvar andn_rr_p =
    [(set t.RegClass:$dst, EFLAGS, (X86and_flag (not t.RegClass:$src1),
     t.RegClass:$src2))];
  defvar andn_rm_p =
    [(set t.RegClass:$dst, EFLAGS, (X86and_flag (not t.RegClass:$src1),
     (t.LoadNode addr:$src2)))];
  def rr#suffix : ITy<0xF2, MRMSrcReg, t, (outs t.RegClass:$dst),
                      (ins t.RegClass:$src1, t.RegClass:$src2), "andn",
                      binop_ndd_args, andn_rr_p>, VVVV, Sched<[WriteALU]>,
                     T8, DefEFLAGS;
  def rm#suffix : ITy<0xF2, MRMSrcMem, t, (outs t.RegClass:$dst),
                       (ins t.RegClass:$src1, t.MemOperand:$src2), "andn",
                       binop_ndd_args, andn_rm_p>, VVVV,
                       Sched<[WriteALU.Folded, WriteALU.ReadAfterFold]>,
                       T8, DefEFLAGS;
}

// Complexity is reduced to give and with immediate a chance to match first.
let AddedComplexity = -6 in {
defm ANDN32 : AndN<Xi32, "">, VEX, Requires<[HasBMI, NoEGPR]>;
defm ANDN64 : AndN<Xi64, "">, VEX, REX_W, Requires<[HasBMI, NoEGPR]>;
defm ANDN32 : AndN<Xi32, "_EVEX">, EVEX, Requires<[HasBMI, HasEGPR, In64BitMode]>;
defm ANDN64 : AndN<Xi64, "_EVEX">, EVEX, REX_W, Requires<[HasBMI, HasEGPR, In64BitMode]>;
}

let Predicates = [HasBMI], AddedComplexity = -6 in {
  def : Pat<(and (not GR32:$src1), GR32:$src2),
            (ANDN32rr GR32:$src1, GR32:$src2)>;
  def : Pat<(and (not GR64:$src1), GR64:$src2),
            (ANDN64rr GR64:$src1, GR64:$src2)>;
  def : Pat<(and (not GR32:$src1), (loadi32 addr:$src2)),
            (ANDN32rm GR32:$src1, addr:$src2)>;
  def : Pat<(and (not GR64:$src1), (loadi64 addr:$src2)),
            (ANDN64rm GR64:$src1, addr:$src2)>;
}

//===----------------------------------------------------------------------===//
// MULX Instruction
//
multiclass MulX<X86TypeInfo t, X86FoldableSchedWrite sched> {
  defvar mulx_args = "{$src, $dst2, $dst1|$dst1, $dst2, $src}";
  defvar mulx_rm_sched =
    [WriteIMulHLd, sched.Folded,
     // Memory operand.
     ReadDefault, ReadDefault, ReadDefault, ReadDefault, ReadDefault,
     // Implicit read of EDX/RDX
     sched.ReadAfterFold];

  def rr : ITy<0xF6, MRMSrcReg, t, (outs t.RegClass:$dst1, t.RegClass:$dst2),
               (ins t.RegClass:$src), "mulx", mulx_args, []>, T8, XD, VEX,
           VVVV, Sched<[WriteIMulH, sched]>;
  let mayLoad = 1 in
  def rm : ITy<0xF6, MRMSrcMem, t, (outs t.RegClass:$dst1, t.RegClass:$dst2),
               (ins t.MemOperand:$src), "mulx", mulx_args, []>, T8, XD, VEX,
               VVVV, Sched<mulx_rm_sched>;

  let Predicates = [In64BitMode] in {
  def rr_EVEX : ITy<0xF6, MRMSrcReg, t,
                    (outs t.RegClass:$dst1, t.RegClass:$dst2),
                    (ins t.RegClass:$src), "mulx", mulx_args, []>, T8, XD,
                EVEX, VVVV, Sched<[WriteIMulH, sched]>;
    let mayLoad = 1 in
    def rm_EVEX : ITy<0xF6, MRMSrcMem, t,
                      (outs t.RegClass:$dst1, t.RegClass:$dst2),
                      (ins t.MemOperand:$src), "mulx", mulx_args, []>, T8, XD,
                  EVEX, VVVV, Sched<mulx_rm_sched>;
  }
  // Pseudo instructions to be used when the low result isn't used. The
  // instruction is defined to keep the high if both destinations are the same.
  def Hrr : PseudoI<(outs t.RegClass:$dst), (ins t.RegClass:$src), []>,
            Sched<[sched]>;
  let mayLoad = 1 in
  def Hrm : PseudoI<(outs t.RegClass:$dst), (ins t.MemOperand:$src), []>,
            Sched<[sched.Folded]>;
}

let Uses = [EDX] in
defm MULX32 : MulX<Xi32, WriteMULX32>;

let Uses = [RDX] in
defm MULX64 : MulX<Xi64, WriteMULX64>, REX_W;

//===----------------------------------------------------------------------===//
// ADCX and ADOX Instructions
//
// We don't have patterns for these as there is no advantage over ADC for
// most code.
let Constraints = "$src1 = $dst" in {
  let Form = MRMSrcReg in {
  def ADCX32rr : BinOpRRF_RF<0xF6, "adcx", Xi32, null_frag>, T8, PD;
  def ADCX64rr : BinOpRRF_RF<0xF6, "adcx", Xi64, null_frag>, T8, PD;
  def ADOX32rr : BinOpRRF_RF<0xF6, "adox", Xi32, null_frag>, T8, XS;
  def ADOX64rr : BinOpRRF_RF<0xF6, "adox", Xi64, null_frag>, T8, XS;
  }
  let Form = MRMSrcMem in {
  def ADCX32rm : BinOpRMF_RF<0xF6, "adcx", Xi32, null_frag>, T8, PD;
  def ADCX64rm : BinOpRMF_RF<0xF6, "adcx", Xi64, null_frag>, T8, PD;
  def ADOX32rm : BinOpRMF_RF<0xF6, "adox", Xi32, null_frag>, T8, XS;
  def ADOX64rm : BinOpRMF_RF<0xF6, "adox", Xi64, null_frag>, T8, XS;
  }
}
