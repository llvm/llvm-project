//===-- Next32ISelDAGToDAG.cpp - A dag to dag inst selector for Next32 ----===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines a DAG pattern matching instruction selector for Next32,
// converting from a legalized dag to a Next32 dag.
//
//===----------------------------------------------------------------------===//

#include "Next32.h"
#include "Next32RegisterInfo.h"
#include "Next32Subtarget.h"
#include "Next32TargetMachine.h"
#include "llvm/CodeGen/FunctionLoweringInfo.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/Endian.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetMachine.h"

using namespace llvm;

#define DEBUG_TYPE "next32-isel"

// Instruction Selector Implementation
namespace {

using TUpstreamSENodes = SmallVector<SmallVector<uint32_t, 4>, 16>;

// If set, UpstreamSENodeIds will traverse all dependencies, not only Chain
static cl::opt<bool> DataDepImpliesHappensBefore(
    "next32-infer-happens-before-from-dataflow", cl::init(false),
    cl::desc("Next32: Encode 'A happens-before B' into output, if A is "
             "upstream from B via data flow. "
             "This option adds ordering to 'happens-before' and is thus "
             "information-losing. "
             "We will need to use it if LLVM ever fails to accurately encode "
             "the happens-before relation using chain and instead relies on "
             "data flow to imply any needed scheduling restrictions"),
    cl::Hidden);

static cl::opt<bool> BarriersAwaitUpstreamBarriers(
    "next32-barriers-await-upstream-barriers", cl::init(true),
    cl::desc("Next32: Barriers take TID from the barriers directly upstream "
             "from them. "
             "This does not alter the happens-before relation, but is used as "
             "a working assumption by Codegraph optimizer."),
    cl::Hidden);

static cl::opt<bool> ForceChainNodesToEarliestMBB(
    "next32-force-chain-nodes-to-earliest-mbb", cl::init(true),
    cl::desc(
        "Next32: Chain-supporting nodes are always assigned to the earliest "
        "possible MBB. This avoids introduction of false dependencies "
        "via intake of $tid (e.g. conditions on likely flows in unrelated "
        "libcalls)"),
    cl::Hidden);

static cl::opt<bool>
    DebugISelSeqOrderAnalysis("debug-isel-seq-order-analysis", cl::init(false),
                              cl::desc("Next32: Plot ISel in several steps of "
                                       "the chain -> barrier conversion"),
                              cl::Hidden);

class Next32DAGToDAGISel : public SelectionDAGISel {
public:
  explicit Next32DAGToDAGISel(Next32TargetMachine &TM, CodeGenOptLevel OptLevel)
      : SelectionDAGISel(TM, OptLevel), Subtarget(nullptr) {}

  StringRef getPassName() const {
    return "Next32 DAG->DAG Pattern Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    // Reset the subtarget each time through.
    Subtarget = &MF.getSubtarget<Next32Subtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void PreprocessISelDAG() override;

private:
  // Keep a pointer to the Next32Subtarget around so that we can make the right
  // decision when generating code for different targets.
  const Next32Subtarget *Subtarget;

// Include the pieces autogenerated from the target description.
#include "Next32GenDAGISel.inc"

  void Select(SDNode *N) override;

  // Complex Pattern.
  bool selectRelocImm(SDValue N, SDValue &Op);
  SDValue PreprocessCall(SDNode *Call);
  void PreprocessResetFrame(SDNode *N);
  void PreprocessSetFrameAlloca(SDNode *N);
  void EnforceSequentialConsistency();
  void EncodeChainIntoDataflow();
  void EnforceSchedulingOrder(DenseMap<SDNode *, SDNode *> &CMUI,
                              SmallVectorImpl<SDNode *> &MBBRoot,
                              SmallVectorImpl<SDNode *> &MBBEntry,
                              unsigned NumNodes);
  void EnforceMBBSchedulingOrder(DenseMap<SDNode *, SDNode *> &CMUI,
                                 SmallVectorImpl<SDNode *> &MBBRoot,
                                 SmallVectorImpl<SDNode *> &MBBEntry);
  void SENodesAssignment(SmallVectorImpl<SDNode *> &SENodes,
                         DenseMap<uint32_t, uint32_t> &SENodeLookup);
  void CalcSENodeDeps(const DenseMap<uint32_t, uint32_t> &SENodeLookup,
                      const DenseMap<SDNode *, SDNode *> &CMUI,
                      TUpstreamSENodes &UpstreamSENodeIds);
  void CalcBBTermDeps(TUpstreamSENodes &UpstreamSENodeIds,
                      const SmallVector<SDNode *, 16> &SENodes, SDNode *BBTerm);
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  uint32_t DebugMBBSeqId;
  std::string DebugDotId;
  std::string DebugTmpPath;

  void dumpDotGraph(const Twine &BaseName, const Twine &Description) {
    CurDAG->dumpDotGraph(DebugTmpPath + Twine("/") + BaseName,
                         Twine("SelectionDAG of ") + DebugDotId + Twine(" ") +
                             Description);
  }
#endif
};

class Next32DAGToDAGISelLegacy : public SelectionDAGISelLegacy {
   public:
     static char ID;
     explicit Next32DAGToDAGISelLegacy(Next32TargetMachine &TM,
                                    CodeGenOptLevel OptLevel)
         : SelectionDAGISelLegacy(
               ID, std::make_unique<Next32DAGToDAGISel>(TM, OptLevel)) {}
   };

} // namespace

char Next32DAGToDAGISelLegacy::ID = 0;

// Check whether we're seeing as much CALL_TERMINATORs as the call instruction
// specifies. If not, add the missing ones.
// FIXME: Possible dead code. Try to find a reproducer for this.
SDValue Next32DAGToDAGISel::PreprocessCall(SDNode *Call) {
  if (!isa<ConstantSDNode>(Call->getOperand(1)))
    return SDValue();

  // Remove CT count operand (By creating a new sdnode without it)
  SmallVector<SDValue, 16> Operands{Call->getOperand(0)};

  // Skip over the CT count
  for (unsigned int OpIdx = 2; OpIdx < Call->getNumOperands(); ++OpIdx)
    Operands.push_back(Call->getOperand(OpIdx));

  unsigned int RequiredCTs =
      cast<ConstantSDNode>(Call->getOperand(1))->getLimitedValue();
  Call =
      CurDAG->MorphNodeTo(Call, Call->getOpcode(), Call->getVTList(), Operands);

  // Check whether we have less CTs than what the call instruction requires.
  SDNode *CTNode = *(Call->use_begin()->use_begin());
  unsigned int CTOpCnt = 0;
  while (RequiredCTs > 0) {
    bool FoundCT = false;
    for (auto Use : CTNode->uses()) {
      if (Use->getOpcode() == Next32ISD::CALL_TERMINATOR) {
        CTOpCnt = Use->getNumOperands() - 2;
        CTNode = Use;
        FoundCT = true;
        RequiredCTs -= CTOpCnt;
        break;
      }
    }
    if (!FoundCT)
      break;
  }

  if (RequiredCTs == 0)
    return SDValue();

  // Add missing CTs
  SDValue CT(CTNode, CTOpCnt);
  SDLoc DL(CT);
  SmallVector<EVT, 4> ValueTypes;

  for (unsigned int i = 0; i < RequiredCTs; ++i)
    ValueTypes.push_back(MVT::i32);
  ValueTypes.push_back(MVT::Other);
  ValueTypes.push_back(MVT::Glue);

  CT =
      CurDAG
          ->getNode(Next32ISD::CALL_TERMINATOR, DL,
                    CurDAG->getVTList(ValueTypes), CT, CT.getValue(CTOpCnt + 1))
          .getValue(CTOpCnt);
  return CT;
}

void Next32DAGToDAGISel::EnforceSequentialConsistency() {
  SmallVector<SDValue, 16> InjectedChains;

  for (SelectionDAG::allnodes_iterator I = CurDAG->allnodes_begin(),
                                       E = CurDAG->allnodes_end();
       I != E;) {
    SDNode *N = &*I++; // Preincrement iterator to avoid invalidation issues.

    if (N->getOpcode() == Next32ISD::CALL ||
        N->getOpcode() == Next32ISD::CALLPTR_WRAPPER) {
      if (SDValue CT = PreprocessCall(N))
        InjectedChains.push_back(CT);
      continue;
    }
  }

  if (InjectedChains.size() == 0) {
    LLVM_DEBUG(CurDAG->dump());
    return;
  }

  // Introduce new chain dependencies to the graph root (modulo glues) by
  // patching its current chain operand to a new TokenFactor node that has the
  // new dependencies and the root node's old chain as operands. The glue
  // traversal prevents instruction scheduling problems caused when injecting a
  // dependency into e.g. CALL_TERMINATOR->SYM_INSTR->CALL.
  SDNode *InjectionNode = CurDAG->getRoot().getNode();
  while (SDNode *GluedNode = InjectionNode->getGluedNode())
    InjectionNode = GluedNode;

  SDValue PreexistingChain = InjectionNode->getOperand(0);
  assert(PreexistingChain.getValueType() == MVT::Other &&
         "Unexpected non-chain value at injection node");
  InjectedChains.push_back(PreexistingChain);

  SmallVector<SDValue, 16> NewOperands;
  NewOperands.push_back(
      CurDAG->getNode(ISD::TokenFactor, SDLoc(), MVT::Other, InjectedChains));

  for (unsigned int i = 1; i < InjectionNode->getNumOperands(); ++i)
    NewOperands.push_back(InjectionNode->getOperand(i));

  CurDAG->UpdateNodeOperands(InjectionNode, NewOperands);
  CurDAG->RemoveDeadNodes();
  LLVM_DEBUG(CurDAG->dump());
}

static bool IsSENodeOpcode(unsigned Opcode) {
  return (Next32Helpers::IsPseudoMemOpcode(Opcode) ||
          Opcode == Next32ISD::CALL || Opcode == Next32ISD::CALLPTR_WRAPPER ||
          Opcode == Next32ISD::RESET_FRAME || Opcode == Next32ISD::SET_FRAME ||
          Opcode == Next32ISD::ALLOCA);
}

class PlaceholderBBTerminator {
  SelectionDAG *CurDAG;
  SDNode *N;

public:
  PlaceholderBBTerminator(SelectionDAG *CurDAG, unsigned &NumNodes,
                          bool InstallPlaceholder)
      : CurDAG(CurDAG), N(nullptr) {
    if (!InstallPlaceholder)
      return;
    auto TokenIdF = CurDAG->getNode(Next32ISD::TOKEN_ID_F, SDLoc(), MVT::Other,
                                    CurDAG->getRoot());
    CurDAG->setRoot(TokenIdF);
    N = TokenIdF.getNode();
    N->setNodeId(NumNodes++);
  }

  ~PlaceholderBBTerminator() {
    if (!N)
      return;
    SDValue ValidRoot = N->getOperand(0);
    CurDAG->setRoot(ValidRoot);
    CurDAG->DeleteNode(N);
  }

  SDNode *get() const { return N; }
};

// NOTE: This is intended as a general-purpose utility function. Convention
// is that Chain is the last value, with the sole exception of output Glue
// that is allowed to appear after it.
static SDValue GetChainValue(SDNode *N) {
  unsigned numVal = N->getNumValues();
  assert(numVal >= 1);
  size_t idx = numVal - 1;
  if (N->getValueType(idx) == MVT::Glue) {
    assert(numVal >= 2);
    --idx;
  }
  assert(N->getValueType(idx) == MVT::Other);
  return SDValue(N, idx);
}

static bool HasChainOperand(SDNode *N) {
  return N->getNumOperands() > 0 &&
         N->getOperand(0).getValueType() == MVT::Other;
}

// Create a scheduling dependency between the Dst node and all the Src nodes
// by merging their chains into a single TokenFactor node and making it the
// new chain of the Dst node.
static void ChainMergeWith(SelectionDAG *CurDAG,
                           DenseMap<SDNode *, SDNode *> &CMUI, SDNode *Dst,
                           ArrayRef<SDNode *> Srcs) {
  if (Srcs.empty())
    return;
  assert(HasChainOperand(Dst));

  // Save the original chain node of the Dst node.
  CMUI.try_emplace(Dst, Dst->getOperand(0).getNode());

  SmallVector<SDValue, 8> TFOperands;
  TFOperands.reserve(1 + Srcs.size());
  TFOperands.push_back(Dst->getOperand(0));
  for (SDNode *Src : Srcs)
    TFOperands.push_back(GetChainValue(Src));
  auto TF = CurDAG->getNode(ISD::TokenFactor, SDLoc(), MVT::Other, TFOperands);
  SmallVector<SDValue, 8> NewOperands;
  NewOperands.push_back(TF);
  for (unsigned int I = 1; I < Dst->getNumOperands(); ++I)
    NewOperands.push_back(Dst->getOperand(I));
  CurDAG->UpdateNodeOperands(Dst, NewOperands);
}

static void ChainMergeWith(SelectionDAG *CurDAG,
                           DenseMap<SDNode *, SDNode *> &CMUI, SDNode *Dst,
                           SDNode *Src) {
  ChainMergeWith(CurDAG, CMUI, Dst, ArrayRef<SDNode *>({Src}));
}

// Check whether a node which we've assigned to an MBB is actually reachable
// from that MBB's root. Performs a DFS from an MBB's root towards the operands.
static SmallVector<bool, 64>
CalcReachabilityByMBB(SelectionDAG *CurDAG, SmallVectorImpl<SDNode *> &MBBRoot,
                      DenseMap<SDNode *, uint32_t> &MBBSeqId) {
  SmallVector<bool, 64> IsReachable(CurDAG->allnodes_size(), false);
  SmallVector<SDNode *, 16> Q;

  for (const auto &RootIdx : enumerate(MBBRoot)) {
    uint32_t I = RootIdx.index();
    auto Origin = RootIdx.value();
    IsReachable[Origin->getNodeId()] = true;
    Q.push_back(Origin);
    while (!Q.empty()) {
      auto N = Q.back();
      Q.pop_back();
      for (auto &Op : N->ops()) {
        auto M = Op.getNode();
        if (MBBSeqId[M] != I)
          continue;
        auto &R = IsReachable[M->getNodeId()];
        if (!R) {
          R = true;
          Q.push_back(M);
        }
      }
    }
  }
  return IsReachable;
}

// Group all "unreachable" nodes by their MBB root.
static void FindUnreachableNodesByMBB(
    SelectionDAG *CurDAG, DenseMap<SDNode *, uint32_t> &MBBSeqId,
    SmallVector<bool, 64> &IsReachable, uint16_t NumMBBs,
    SmallVector<SmallVector<SDNode *, 4>, 16> &UnreachableNodesByMBB) {
  for (SDNode &NRef : CurDAG->allnodes()) {
    SDNode *N = &NRef;
    auto NId = N->getNodeId();
    // Last MBB has issues with multiple terminator nodes
    // It is likely the ISel isn't in any danger of breaking the basic block
    // without our chain merge procedure below, so we can save ourselves the
    // trouble of properly supporting it
    if (MBBSeqId[N] == NumMBBs) {
      continue;
    }
    if (HasChainOperand(N) && N->getOpcode() != ISD::TokenFactor &&
        !IsReachable[NId]) {
      UnreachableNodesByMBB[MBBSeqId[N]].push_back(N);
    }
  }
}

template <typename TRange> static std::string SerializeRange(TRange Range) {
  std::string Result;
  llvm::raw_string_ostream OS(Result);
  bool isFirst = true;
  for (const auto &Item : Range) {
    if (isFirst)
      isFirst = false;
    else
      OS << ", ";
    OS << Item;
  }
  return Result;
}

static void DebugUpstreamSENodes(SelectionDAG *CurDAG,
                                 const TUpstreamSENodes &UpstreamSENodeIds) {
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  if (DebugISelSeqOrderAnalysis) {
    for (auto &NRef : CurDAG->allnodes()) {
      auto N = &NRef;
      auto NId = N->getNodeId();
      const auto &u = UpstreamSENodeIds[NId];
      if (u.empty())
        continue;
      LLVM_DEBUG(dbgs() << SerializeRange(u) << " <-- "; N->dump(CurDAG));
    }
  }
#endif
}

template <typename V>
static void InsertToSortedVector(V &Vec, typename V::value_type Item) {
  auto It = std::lower_bound(Vec.begin(), Vec.end(), Item);
  if (It == Vec.end() || *It != Item)
    Vec.insert(It, Item);
}

static void
UpdateUpstreamSENodes(SmallVectorImpl<uint32_t> &Dst,
                      const DenseMap<uint32_t, uint32_t> &SENodeLookup,
                      const TUpstreamSENodes &UpstreamSENodeIds, SDNode *Src) {
  auto SrcSENodeIt = SENodeLookup.find(Src->getNodeId());
  if (SrcSENodeIt != SENodeLookup.end()) {
    // Operand is an SENode, take it and disregard its transitive deps
    InsertToSortedVector(Dst, SrcSENodeIt->second);
  } else {
    // Upstream SENodes from operand simply carry over here
    SmallVector<uint32_t, 4> Tmp(std::move(Dst));
    const SmallVector<uint32_t, 4> &SrcDeps =
        UpstreamSENodeIds[Src->getNodeId()];
    std::set_union(Tmp.begin(), Tmp.end(), SrcDeps.begin(), SrcDeps.end(),
                   std::back_inserter(Dst));
  }
}

static bool IsBasicBlockTerminator(SDNode *N) {
  switch (N->getOpcode()) {
  case ISD::BR:
  case Next32ISD::BR_CC:
  case Next32ISD::WRITER:
  case Next32ISD::RET_FLAG:
    return true;
  default:
    return false;
  }
}

static SDNode::op_iterator GetTIDOperand(SelectionDAG *CurDAG, SDNode *N) {
  if (IsBasicBlockTerminator(N)) {
    // These do not have TID operands
    return N->op_end();
  }
  switch (N->getOpcode()) {
  case Next32ISD::G_VMEM_WRITE:
  case Next32ISD::G_VMEM_READ_1:
  case Next32ISD::G_VMEM_READ_2:
  case Next32ISD::G_VMEM_READ_4:
  case Next32ISD::G_VMEM_READ_8:
  case Next32ISD::G_VMEM_READ_16:
  case Next32ISD::G_MEM_WRITE:
  case Next32ISD::G_MEM_READ_1:
  case Next32ISD::G_MEM_READ_2:
  case Next32ISD::G_MEM_READ_4:
  case Next32ISD::G_MEM_READ_8:
  case Next32ISD::G_MEM_READ_16:
  case Next32ISD::G_MEM_FAOP_S:
  case Next32ISD::G_MEM_FAOP_D:
  case Next32ISD::G_MEM_CAS_S:
  case Next32ISD::G_MEM_CAS_D:
    // memops have a common prefix and TID is always operand 4
    return N->op_begin() + 4;
  case Next32ISD::SET_FRAME:
  case Next32ISD::ALLOCA:
    return N->op_begin() + 2;
  case Next32ISD::RESET_FRAME:
    return N->op_begin() + 3;
  case Next32ISD::CALL:
  case Next32ISD::CALLPTR_WRAPPER:
  case Next32ISD::TOKEN_ID_F:
    // These do not have TID operands
    return N->op_end();
  default:
    LLVM_DEBUG(N->dump(CurDAG));
    report_fatal_error("Argument has unrecognized opcode");
  }
}

// Returns a Barrier-compatible data output from a Node as SDValue
static SDValue GetReturnIndication(SelectionDAG *CurDAG, SDNode *N) {
  if (IsBasicBlockTerminator(N)) {
    LLVM_DEBUG(N->dump(CurDAG));
    report_fatal_error("Argument is a basic block terminator");
  }
  switch (N->getOpcode()) {
  case Next32ISD::G_VMEM_WRITE:
  case Next32ISD::G_VMEM_READ_1:
  case Next32ISD::G_VMEM_READ_2:
  case Next32ISD::G_VMEM_READ_4:
  case Next32ISD::G_VMEM_READ_8:
  case Next32ISD::G_VMEM_READ_16:
  case Next32ISD::G_MEM_WRITE:
  case Next32ISD::G_MEM_READ_1:
  case Next32ISD::G_MEM_READ_2:
  case Next32ISD::G_MEM_READ_4:
  case Next32ISD::G_MEM_READ_8:
  case Next32ISD::G_MEM_READ_16:
  case Next32ISD::G_MEM_FAOP_S:
  case Next32ISD::G_MEM_FAOP_D:
  case Next32ISD::G_MEM_CAS_S:
  case Next32ISD::G_MEM_CAS_D:
  case Next32ISD::RESET_FRAME:
  case Next32ISD::BARRIER:
    assert(N->getValueType(0) == MVT::i32);
    return SDValue(N, 0);
  case Next32ISD::SET_FRAME:
  case Next32ISD::ALLOCA:
    assert(N->getValueType(2) == MVT::i32);
    return SDValue(N, 2);
  case Next32ISD::CALL:
  case Next32ISD::CALLPTR_WRAPPER:
    LLVM_DEBUG(N->dump(CurDAG));
    report_fatal_error("Argument is an MBB terminator");
  default:
    LLVM_DEBUG(N->dump(CurDAG));
    report_fatal_error("Argument has unrecognized opcode");
  }
}

// Handles the introduction of BARRIER chains into the DAG.
class DataDependencyInjector {
  SelectionDAG *CurDAG;
  SDNode *Dst;
  SDNode::op_iterator DstTIDOperand;

  SDValue Value;
  SDValue Chain;
  SmallVector<SDNode *, 16> Srcs;
  SmallVector<SDNode *, 16> Barriers;

  void Fold(SDNode *Src) {
    SDValue Rhs = GetReturnIndication(CurDAG, Src);
    SDVTList VTList = CurDAG->getVTList(MVT::i32, MVT::Other);
    Value = CurDAG->getNode(Next32ISD::BARRIER, SDLoc(Src), VTList, Chain,
                            Value, Rhs);
    Chain = Value.getValue(1);
  }

public:
  DataDependencyInjector(SelectionDAG *CurDAG, SDNode *Dst)
      : CurDAG(CurDAG), Dst(Dst) {
    DstTIDOperand = GetTIDOperand(CurDAG, Dst);
#if !defined(NDEBUG)
    // If Dst has an explicit TID operand, check it is actually taking $tid
    if (DstTIDOperand != Dst->op_end()) {
      RegisterSDNode *RN = cast<RegisterSDNode>(DstTIDOperand->getNode());
      assert(RN->getReg() == Next32::TID);
    }
#endif
  }

  void MergeWith(SDNode *Src) {
    unsigned Opcode = Src->getOpcode();
    if (Opcode == Next32ISD::CALL || Opcode == Next32ISD::CALLPTR_WRAPPER) {
      // Ignore calls here. We'll get scheduled after the call which means
      // we consume its TID, which waits for anything the call itself
      // chain-depends on, so we are OK.
      // NOTE: there is no loss of "happens-before" information; we can treat
      // any call with nonzero chains deps on SENodes (except other calls) as a
      // full barrier. Chain deps between other SENodes disregards libcalls so
      // they would not bother us, and "real" calls act as a barrier in terms
      // of chain connectivity anyway.
      return;
    }
    Srcs.push_back(Src);
    if (BarriersAwaitUpstreamBarriers) {
      SDValue ExistingChainOperand = Src->getOperand(0);
      if (ExistingChainOperand->getOpcode() == Next32ISD::BARRIER)
        InsertToSortedVector(Barriers, ExistingChainOperand.getNode());
    }
  }

  void Attach() {
    if (Srcs.empty())
      return;
    Chain = Dst->getOperand(0);
    if (BarriersAwaitUpstreamBarriers && !Barriers.empty()) {
      bool IsFirst = true;
      for (auto Src : Barriers) {
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
        if (DebugISelSeqOrderAnalysis)
          LLVM_DEBUG(dbgs() << "Awaiting TID from BARRIER node: ";
                     Src->dump(CurDAG));
#endif
        if (IsFirst) {
          IsFirst = false;
          Value = SDValue(Src, 0);
        } else
          Fold(Src);
      }
    } else {
      // Not connecting to upstream barriers, copy TID from MBB start
      Value = CurDAG->getCopyFromReg(Chain, SDLoc(), Next32::TID, MVT::i32);
      Chain = Value.getValue(1);
    }
    for (auto Src : Srcs)
      Fold(Src);

    std::vector<SDValue> Operands(Dst->op_begin(), Dst->op_end());
    if (DstTIDOperand != Dst->op_end()) {
      Operands[DstTIDOperand - Dst->op_begin()] = Value;
    } else {
      // Write accumulator's result back to $tid. This is done with a dedicated
      // Pseudo-instruction to avoid problems with early use of physical
      // registers
      Chain = CurDAG->getNode(Next32ISD::SET_TID, SDLoc(Value), MVT::Other,
                              Chain, Value);
    }
    Operands[0] = Chain;
    CurDAG->UpdateNodeOperands(Dst, ArrayRef(Operands));
  }
};

static void InjectDataDependencies(SelectionDAG *CurDAG,
                                   const SmallVectorImpl<SDNode *> &SENodes,
                                   const SmallVectorImpl<SDNode *> &MBBRoot,
                                   const TUpstreamSENodes &UpstreamSENodeIds) {
  auto RangeA = llvm::make_range(SENodes.begin(), SENodes.end());
  // Only the block terminator has to be processed here, the other terminators
  // are themselves SENodes
  auto RangeB = llvm::make_range(MBBRoot.end() - 1, MBBRoot.end());
  auto Range = llvm::concat<SDNode *const>(RangeA, RangeB);

  for (auto N : Range) {
    auto &Upstream = UpstreamSENodeIds[N->getNodeId()];
    if (Upstream.empty())
      continue;

#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
    if (DebugISelSeqOrderAnalysis)
      LLVM_DEBUG(dbgs() << "Inject data deps to node: "; N->dump(CurDAG));
#endif
    DataDependencyInjector Injector(CurDAG, N);
    // Traverse the dependecies of an SENode, and inject BARRIERs between them.
    for (auto SENodeId : Upstream) {
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
      if (DebugISelSeqOrderAnalysis)
        LLVM_DEBUG(dbgs() << "...Injecting dependency on SENode " << SENodeId
                          << '\n');
#endif
      Injector.MergeWith(SENodes[SENodeId]);
    }
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
    if (DebugISelSeqOrderAnalysis)
      LLVM_DEBUG(dbgs() << "...Attaching the chain\n");
#endif
    Injector.Attach();
  }
}

void Next32DAGToDAGISel::EnforceMBBSchedulingOrder(
    DenseMap<SDNode *, SDNode *> &CMUI, SmallVectorImpl<SDNode *> &MBBRoot,
    SmallVectorImpl<SDNode *> &MBBEntry) {
  // Chain all MBBEntry nodes to their preceding MBBRoot
  // This is for scheduling purposes only, it does not influence dependency
  // analysis.
  for (unsigned I = 0; I != MBBEntry.size(); ++I) {
    if (I != 0)
      ChainMergeWith(CurDAG, CMUI, MBBEntry[I], MBBRoot[I - 1]);
    ChainMergeWith(CurDAG, CMUI, MBBRoot[I], MBBEntry[I]);
  }
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  if (DebugISelSeqOrderAnalysis)
    dumpDotGraph("250.after-seq-calls.dot",
                 "after forcing calls to be sequential");
#endif
}

void Next32DAGToDAGISel::EnforceSchedulingOrder(
    DenseMap<SDNode *, SDNode *> &CMUI, SmallVectorImpl<SDNode *> &MBBRoot,
    SmallVectorImpl<SDNode *> &MBBEntry, unsigned NumNodes) {
  if (!ForceChainNodesToEarliestMBB) {
    EnforceMBBSchedulingOrder(CMUI, MBBRoot, MBBEntry);
    return;
  }
  // Map each node to the earliest MBB it can belong to. Entries and roots
  // delineate the MBBs, while for other nodes, MBB ID is calculated as the
  // maximum of MBB IDs of their operands.
  DenseMap<SDNode *, uint32_t> MBBSeqId(NumNodes);
  // Assign sequential MBB IDs to MBB entries and roots.
  for (uint32_t I = 0; I != MBBEntry.size(); ++I) {
    MBBSeqId[MBBEntry[I]] = I;
    MBBSeqId[MBBRoot[I]] = I;
  }
  for (SDNode &NRef : CurDAG->allnodes()) {
    SDNode *N = &NRef;
    if (MBBSeqId.count(N) != 0)
      continue;
    // Non-assigned nodes take the max of their operands
    uint32_t MaxSeqId = 0;
    for (const auto &Op : N->ops()) {
      auto OpSeqId = MBBSeqId.find(Op.getNode());
      if (OpSeqId != MBBSeqId.end())
        MaxSeqId = std::max(MaxSeqId, OpSeqId->second);
    }
    MBBSeqId[N] = MaxSeqId;
  }

#if !defined(NDEBUG)
  if (DebugISelSeqOrderAnalysis) {
    for (SDNode &NRef : CurDAG->allnodes()) {
      SDNode *N = &NRef;
      LLVM_DEBUG(dbgs() << "MBBSeqId " << MBBSeqId[N] << " for node: ";
                 N->dump(CurDAG));
    }
  }
#endif

  /*
   * We've assigned all nodes to the earliest possible MBB, based on their
   * operands, but it's possible that some of them are "unreachable" from their
   * designated MBB's root. (e.g. as a consequence of libcall lowering - see
   * llvm/test/CodeGen/Next32/libcall.ll). Unreachable nodes are ops, assigned
   * to an MBB, that have a chain output that the MBB root is not waiting on.
   * Find these unreachable nodes and chain them to the MMB root - making it
   * wait for them. This is to ensure each "MBB" can become a legal BBG in
   * codegraph.
   *
   * Example IR:
   * define dso_local i64 @shr4c(i64 noundef %0) {
   *   %2 = call i32 @foo(i64 %0)
   *   %3 = lshr i64 %0, 3  <- lowered to "_lshrdi3" libcall
   *   ret i64 %3
   * }
   *
   * The following diagram represents the DAG after libcall lowering. Arrows
   * represent chain dependencies. Libcall node is assigned to entry MBB, but
   * it's not properly chained to the MBB root (Call foo).
   *             +-------+
   *             | Entry |
   *       +-----+-------+----+
   *       |                  |
   *  +----v---+           +--v--+
   *  |  Call  |           |Call |
   *  |_lshrdi3|           |foo  |
   *  +--------+           +--+--+
   *             +------+     |
   *             |Return|<----+
   *             +------+
   *
   * The following diagram represents the DAG after we've chained the libcall:
   *    +-------+
   *    | Entry |
   *    +---+---+
   *        |
   *  +-----v----+
   *  |   Call   |
   *  | _lshrdi3 |
   *  +-----+----+
   *        |
   *    +---v--+
   *    | Call |
   *    | foo  |
   *    +---+--+
   *        |
   *    +---v--+
   *    |Return|
   *    +------+
   */
  auto IsReachableFromRoot = CalcReachabilityByMBB(CurDAG, MBBRoot, MBBSeqId);
  SmallVector<SmallVector<SDNode *, 4>, 16> UnreachableNodesByMBB(
      MBBRoot.size());
  FindUnreachableNodesByMBB(CurDAG, MBBSeqId, IsReachableFromRoot,
                            MBBRoot.size() - 1, UnreachableNodesByMBB);
  EnforceMBBSchedulingOrder(CMUI, MBBRoot, MBBEntry);
  for (uint32_t I = 0; I != MBBRoot.size(); ++I) {
    ChainMergeWith(CurDAG, CMUI, MBBRoot[I], UnreachableNodesByMBB[I]);
  }
  // Also merge memory access nodes with their MBBEntry. This affects
  // scheduling of BARRIER chains later on. It's just a matter of
  // making the output consistent so we can write tests for it.
  for (SDNode &NRef : CurDAG->allnodes()) {
    SDNode *N = &NRef;
    if (Next32Helpers::IsPseudoMemOpcode(N->getOpcode()))
      ChainMergeWith(CurDAG, CMUI, N, MBBEntry[MBBSeqId[N]]);
  }
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  if (DebugISelSeqOrderAnalysis)
    dumpDotGraph("275.after-chain-earliest-mbb.dot",
                 "after forcing chain nodes to earliest possible MBB");
#endif
}

// Find all SENodes in the DAG. We use two separate data structures
// for easier bookkeeping.
void Next32DAGToDAGISel::SENodesAssignment(
    SmallVectorImpl<SDNode *> &SENodes,
    DenseMap<uint32_t, uint32_t> &SENodeLookup) {
  for (SDNode &NRef : CurDAG->allnodes()) {
    SDNode *N = &NRef;
    if (IsSENodeOpcode(N->getOpcode())) {
      SENodeLookup[N->getNodeId()] = SENodes.size();
      SENodes.push_back(N);
    }
  }

#if !defined(NDEBUG)
  if (DebugISelSeqOrderAnalysis) {
    for (uint32_t I = 0; I != SENodes.size(); ++I) {
      auto N = SENodes[I];
      LLVM_DEBUG(dbgs() << "SENode #" << I << ": "; N->dump(CurDAG));
    }
  }
#endif
}

// Calculate dependencies between SENodes. This is done by traversing the DAG
// and collecting all SENodes which "happen-before" a given node.
void Next32DAGToDAGISel::CalcSENodeDeps(
    const DenseMap<uint32_t, uint32_t> &SENodeLookup,
    const DenseMap<SDNode *, SDNode *> &CMUI,
    TUpstreamSENodes &UpstreamSENodeIds) {
  for (SDNode &NRef : CurDAG->allnodes()) {
    SDNode *N = &NRef;
    auto &Dst = UpstreamSENodeIds[N->getNodeId()];
    if (!DataDepImpliesHappensBefore && !HasChainOperand(N)) {
      continue;
    }
    auto ChainMergeOriginalSrc = CMUI.find(N);
    if (ChainMergeOriginalSrc != CMUI.end()) {
      UpdateUpstreamSENodes(Dst, SENodeLookup, UpstreamSENodeIds,
                            ChainMergeOriginalSrc->second);
      continue;
    }
    uint32_t NumOperands =
        (DataDepImpliesHappensBefore || N->getOpcode() == ISD::TokenFactor)
            ? N->getNumOperands()
            : 1;
    for (uint32_t I = 0; I != NumOperands; ++I) {
      SDNode *Operand = N->getOperand(I).getNode();
      UpdateUpstreamSENodes(Dst, SENodeLookup, UpstreamSENodeIds, Operand);
    }
  }
}

// If there are any SENodes which are not "upstream" from any other SENode,
// connect them to the last basic block terminator.
void Next32DAGToDAGISel::CalcBBTermDeps(
    TUpstreamSENodes &UpstreamSENodeIds,
    const SmallVector<SDNode *, 16> &SENodes, SDNode *BBTerm) {
  BitVector IsDownstreamSENode(SENodes.size(), true);
  for (auto SENode : SENodes) {
    for (uint32_t SENodeId : UpstreamSENodeIds[SENode->getNodeId()]) {
      IsDownstreamSENode[SENodeId] = false;
    }
  }
  // Connect "downstream" SENodes to the last terminator
  // Note that the ordering we've introduced via ISelConstraints is
  // intentionally being ignored, so it is possible for such SENodes to exist
  auto &BBTermUpstreamIds = UpstreamSENodeIds[BBTerm->getNodeId()];
  for (size_t I = 0, N = IsDownstreamSENode.size(); I != N; ++I) {
    if (IsDownstreamSENode[I])
      InsertToSortedVector(BBTermUpstreamIds, I);
  }
}

void Next32DAGToDAGISel::EncodeChainIntoDataflow() {
  unsigned NumNodes = CurDAG->AssignTopologicalOrder();
  bool FoundBBTerminator = false;

  // We're going to split BB's at every function call later in the optimization
  // pipeline. Find the root and the entry node of each of these split BB's. All
  // CALL/CALLPTR_WRAPPER nodes and basic block terminators are considered
  // roots. All SYM nodes are considered entry nodes.
  SmallVector<SDNode *, 16> MBBRoot;
  // All MBB roots except the last one must have a valid resumption point (SYM).
  SmallVector<SDNode *, 16> ResumptionPoint(NumNodes, nullptr);
  for (SDNode &NRef : CurDAG->allnodes()) {
    SDNode *N = &NRef;
    auto Opcode = N->getOpcode();

    switch (Opcode) {
    case Next32ISD::CALL:
    case Next32ISD::CALLPTR_WRAPPER:
      MBBRoot.push_back(N);
      break;
    case Next32ISD::SYM: {
      SDNode *GlueEnd = N;
      while (SDNode *M = GlueEnd->getGluedNode())
        GlueEnd = M;
      ResumptionPoint[GlueEnd->getNodeId()] = N;
      break;
    }
    default:
      if (IsBasicBlockTerminator(N)) {
        MBBRoot.push_back(N);
        FoundBBTerminator = true;
      }
      break;
    }
    if (FoundBBTerminator)
      break;
  }
  // Artificially create a BB terminator if none was found.
  PlaceholderBBTerminator PBBT(CurDAG, NumNodes, !FoundBBTerminator);
  if (SDNode *N = PBBT.get())
    MBBRoot.push_back(N);

#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  if (DebugISelSeqOrderAnalysis) {
    DebugMBBSeqId += MBBRoot.size();
  }
#endif
  // Each MBBRoot (except the last one) must have a corresponding MBBEntry,
  // which is essentially its resumption point.
  SmallVector<SDNode *, 16> MBBEntry(MBBRoot.size(), nullptr);
  MBBEntry[0] = CurDAG->getEntryNode().getNode();
  std::transform(MBBRoot.begin(), MBBRoot.end() - 1, MBBEntry.begin() + 1,
                 [&ResumptionPoint](SDNode *N) {
                   return ResumptionPoint[N->getNodeId()];
                 });
#if !defined(NDEBUG)
  for (auto N : MBBEntry) {
    assert(N && "Unable to determine MBB Entry Node");
  }
#endif

  // We're going to modify chains of some nodes when enforcing a scheduling
  // order. Keep track of the original chain nodes, because we need them for the
  // following barrier analysis.
  DenseMap<SDNode *, SDNode *> CMUI;
  EnforceSchedulingOrder(CMUI, MBBRoot, MBBEntry, NumNodes);
  NumNodes = CurDAG->AssignTopologicalOrder();

  // Calculate the happens-before relations between nodes with side-effects
  // (hereinafter "SENodes"). SENode is a node that has side effects, or implies
  // a control flow transition (memory ops, stack ops, function calls, MBB
  // entries/roots). We will use this information to inject BARRIERs at each
  // dependency edge.
  SmallVector<SDNode *, 16> SENodes;
  DenseMap<uint32_t, uint32_t> SENodeLookup;
  SENodesAssignment(SENodes, SENodeLookup);
  // UpstreamSENodeIds holds a list of all SENodes which "happen-before" a given
  // node (via chain dependency).
  TUpstreamSENodes UpstreamSENodeIds(NumNodes);
  CalcSENodeDeps(SENodeLookup, CMUI, UpstreamSENodeIds);
  CalcBBTermDeps(UpstreamSENodeIds, SENodes, MBBRoot.back());
  DebugUpstreamSENodes(CurDAG, UpstreamSENodeIds);
  // Implement the "happens-before" requirements by re-routing TID values
  // through BARRIERs.
  InjectDataDependencies(CurDAG, SENodes, MBBRoot, UpstreamSENodeIds);
}

void Next32DAGToDAGISel::PreprocessISelDAG() {
  // Ignore empty basic blocks
  if (CurDAG->getRoot() == CurDAG->getEntryNode())
    return;

#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  if (DebugISelSeqOrderAnalysis) {
    if (FuncInfo->MBB->getNumber() == 0) {
      DebugMBBSeqId = 0;
    }
    DebugDotId = (Twine(CurDAG->getMachineFunction().getName()) + Twine(".") +
                  Twine(DebugMBBSeqId))
                     .str();
    DebugTmpPath = (Twine("/tmp/selection-dag-") + DebugDotId).str();
    sys::fs::create_directories(DebugTmpPath);
    dumpDotGraph("100.before-seq-cns.dot",
                 "before EnforceSequentialConsistency()");
  }
#endif
  EnforceSequentialConsistency();
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  if (DebugISelSeqOrderAnalysis)
    dumpDotGraph("200.after-seq-cns.dot",
                 "after EnforceSequentialConsistency()");
#endif
  EncodeChainIntoDataflow();
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
  if (DebugISelSeqOrderAnalysis)
    dumpDotGraph("300.after-chain-dataflow.dot",
                 "after EncodeChainIntoDataflow()");
#endif
}

bool Next32DAGToDAGISel::selectRelocImm(SDValue N, SDValue &Op) {
  if (auto *CN = dyn_cast<ConstantSDNode>(N)) {
    Op = CurDAG->getTargetConstant(CN->getAPIntValue(), SDLoc(CN),
                                   N.getValueType());
    return true;
  }

  SDValue N0 = N.getOperand(0);
  switch (N0.getOpcode()) {
  case ISD::TargetGlobalAddress:
  case ISD::TargetGlobalTLSAddress:
  case ISD::TargetFrameIndex:
    Op = N0;
    return true;
  default:
    llvm_unreachable("Invalid MOV Instruction wrapper operand");
    return false;
  }
}
void Next32DAGToDAGISel::Select(SDNode *Node) {
  // Dump information about the Node being selected
  LLVM_DEBUG(dbgs() << "Selecting: "; Node->dump(CurDAG); dbgs() << '\n');
  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << '\n');
    return;
  }

  SDLoc DL(Node);
  switch (Node->getOpcode()) {
  // We translate chain (enforced scheduling order) into BARRIER (dataflow
  // dependency) and a fence always implies scheduling order between memory
  // operations on different sides of the fence, regardless of the type of
  // fence. This means, within the thread we will have ordering that's at least
  // as strong as the intended semantics. Next32 has a sequentially consistent
  // memory model between threads, so they are not required to communicate
  // anything related to atomic ops or memory fences. So for instance, we lower
  // an atomic store to an ordinary G_MEM_WRITE, and we can lower a fence to
  // "nothing".
  case ISD::ATOMIC_FENCE:
    Node->setNodeId(-1); // Mark selected.
    ReplaceUses(SDValue(Node, 0), Node->getOperand(0));
    CurDAG->RemoveDeadNode(Node);
    return;

  // CALL_TERMINATOR has both variable operands and variable results, but ISel
  // only supports one or the other. Split it into two glued nodes, one for the
  // operands and one for the results. These two nodes will be recombined in a
  // custom inserter hook into a single MachineInstr.
  case Next32ISD::CALL_TERMINATOR: {
    Node->setNodeId(-1); // Mark selected.
    SmallVector<SDValue, 6> CTOps;
    // Move the chain and the glue to the end of the operand list of the
    // new MachineInstr.
    for (size_t i = 1; i < Node->getNumOperands() - 1; ++i)
      CTOps.push_back(Node->getOperand(i));
    CTOps.push_back(Node->getOperand(0));
    CTOps.push_back(Node->getOperand(Node->getNumOperands() - 1));

    MachineSDNode *CTParams = CurDAG->getMachineNode(
        Next32::CALL_TERMINATOR_PARAMS, DL, {MVT::Other, MVT::Glue}, CTOps);
    MachineSDNode *CTResults = CurDAG->getMachineNode(
        Next32::CALL_TERMINATOR_RESULTS, DL, Node->getVTList(),
        {SDValue(CTParams, 0), SDValue(CTParams, 1)});

    ReplaceNode(Node, CTResults);

    return;
  }

  default:
    break;
  }

  // Select the default instruction
  SelectCode(Node);
}

FunctionPass *llvm::createNext32ISelDag(Next32TargetMachine &TM,
                                        CodeGenOptLevel OptLevel) {
  return new Next32DAGToDAGISelLegacy(TM, OptLevel);
}
