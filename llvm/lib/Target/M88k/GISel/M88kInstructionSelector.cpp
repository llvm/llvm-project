//===- M88kInstructionSelector.cpp ------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kGlobalISelUtils.h"
#include "M88kRegisterBankInfo.h"
#include "M88kSubtarget.h"
#include "M88kTargetMachine.h"
#include "MCTargetDesc/M88kBaseInfo.h"
#include "llvm/CodeGen/GlobalISel/GenericMachineInstrs.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/CodeGen/Register.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MathExtras.h"

#define DEBUG_TYPE "M88k-isel"

using namespace llvm;
using namespace M88kGISelUtils;
using namespace MIPatternMatch;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

namespace {

class M88kInstructionSelector : public InstructionSelector {
public:
  M88kInstructionSelector(const M88kTargetMachine &TM, const M88kSubtarget &STI,
                          const M88kRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  void setupMF(MachineFunction &MF, GISelKnownBits *KB,
               CodeGenCoverage &CoverageInfo, ProfileSummaryInfo *PSI,
               BlockFrequencyInfo *BFI) override;
  static const char *getName() { return DEBUG_TYPE; }

private:
  // An early selection function that runs before the selectImpl() call.
  bool earlySelect(MachineInstr &I);

  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  void renderLO16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;
  void renderHI16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;

  bool selectFrameIndex(MachineInstr &I, MachineBasicBlock &MBB,
                        MachineRegisterInfo &MRI) const;
  bool selectGlobalValue(MachineInstr &I, MachineBasicBlock &MBB,
                         MachineRegisterInfo &MRI) const;
  bool selectFPtoSI(MachineInstr &I, MachineBasicBlock &MBB,
                    MachineRegisterInfo &MRI) const;
  bool selectUbfx(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectICmp(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectBrCond(MachineInstr &I, MachineBasicBlock &MBB,
                    MachineRegisterInfo &MRI) const;
  bool selectJumpTable(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI) const;
  bool selectBrJT(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectBrIndirect(MachineInstr &I, MachineBasicBlock &MBB,
                        MachineRegisterInfo &MRI) const;
  bool selectPtrAdd(MachineInstr &I, MachineBasicBlock &MBB,
                    MachineRegisterInfo &MRI) const;
  bool selectMul(MachineInstr &I, MachineBasicBlock &MBB,
                 MachineRegisterInfo &MRI) const;
  bool selectUDiv(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectExt(MachineInstr &I, MachineBasicBlock &MBB,
                 MachineRegisterInfo &MRI) const;
  bool selectLoadStore(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI) const;
  bool selectMergeUnmerge(MachineInstr &I, MachineBasicBlock &MBB,
                          MachineRegisterInfo &MRI) const;
  bool selectIntrinsic(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI);

  bool isMC88110() const {
    return TII.getSubtarget().isMC88110();
  }

  bool useDivInstr() const {
    return TM.useDivInstr();
  }

  bool noZeroDivCheck() const {
    return TM.noZeroDivCheck();
  }

  const M88kTargetMachine &TM;
  const M88kInstrInfo &TII;
  const M88kRegisterInfo &TRI;
  const M88kRegisterBankInfo &RBI;

  // Some cached values used during selection.
  // We use R1 as a live-in register, and we keep track of it here as it can be
  // clobbered by calls.
  Register MFReturnAddr;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

M88kInstructionSelector::M88kInstructionSelector(
    const M88kTargetMachine &TM, const M88kSubtarget &STI,
    const M88kRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

// Like llvm::getSrcRegIgnoringCopies() but returns the register from argument
// list instead of None.
static Register getRegIgnoringCopies(Register Reg,
                                     const MachineRegisterInfo &MRI) {
  Optional<DefinitionAndSourceRegister> DefSrcReg =
      getDefSrcRegIgnoringCopies(Reg, MRI);
  return DefSrcReg ? DefSrcReg->Reg : Reg;
}

static const TargetRegisterClass *guessRegClass(unsigned Reg,
                                                MachineRegisterInfo &MRI,
                                                const TargetRegisterInfo &TRI,
                                                const RegisterBankInfo &RBI) {
  const RegisterBank *RegBank = RBI.getRegBank(Reg, MRI, TRI);
  assert(RegBank && "Can't get reg bank for virtual register");

  const unsigned Size = MRI.getType(Reg).getSizeInBits();
  assert((RegBank->getID() == M88k::GRRegBankID ||
          RegBank->getID() == M88k::XRRegBankID) &&
         "Unsupported reg bank");

  if (RegBank->getID() == M88k::XRRegBankID)
    return &M88k::XRRCRegClass;

  if (Size == 64)
    return &M88k::GPR64RCRegClass;
  return &M88k::GPRRCRegClass;
}

static bool selectCopy(MachineInstr &I, const TargetInstrInfo &TII,
                       MachineRegisterInfo &MRI, const TargetRegisterInfo &TRI,
                       const RegisterBankInfo &RBI) {
  Register DstReg = I.getOperand(0).getReg();
  if (Register::isPhysicalRegister(DstReg))
    return true;

  const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its uses or its defs.
  // Copies do not have constraints.
  if (!RBI.constrainGenericRegister(DstReg, *RC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }
  return true;
}

void M88kInstructionSelector::renderLO16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val &= 0x000000000000FFFFULL;
  MIB.addImm(Val);
}

void M88kInstructionSelector::renderHI16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val = (Val & 0x00000000FFFF0000ULL) >> 16;
  MIB.addImm(Val);
}

bool M88kInstructionSelector::selectFrameIndex(MachineInstr &I,
                                               MachineBasicBlock &MBB,
                                               MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_FRAME_INDEX && "Unexpected G code");

  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ADDri))
                         .add(I.getOperand(0))
                         .add(I.getOperand(1))
                         .addImm(0);
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  return false;
}

bool M88kInstructionSelector::selectGlobalValue(
    MachineInstr &I, MachineBasicBlock &MBB, MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_GLOBAL_VALUE && "Unexpected G code");

  const GlobalValue *GV = I.getOperand(1).getGlobal();

  Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
                         .addReg(Temp, RegState::Define)
                         .addReg(M88k::R0)
                         .addGlobalAddress(GV, 0, M88kII::MO_ABS_HI);
  if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORri))
           .add(I.getOperand(0))
           .addReg(Temp, RegState::Kill)
           .addGlobalAddress(GV, 0, M88kII::MO_ABS_LO);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectFPtoSI(MachineInstr &I,
                                           MachineBasicBlock &MBB,
                                           MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_FPTOSI ||
         I.getOpcode() == TargetOpcode::G_SITOFP && "Unexpected G code");

  static unsigned Opx[2][2] = {
      {M88k::FLTgss, M88k::FLTgds},
      {M88k::TRNCgss, M88k::TRNCgsd},
  };

  bool ToInt = I.getOpcode() == TargetOpcode::G_FPTOSI;
  bool IsDblType =
      MRI.getType(I.getOperand(ToInt ? 1 : 0).getReg()).getSizeInBits() == 64;
  const unsigned NewOpc = Opx[ToInt][IsDblType];

  MachineInstr *MI;
  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc),
               I.getOperand(0).getReg())
           .addReg(I.getOperand(1).getReg());
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectUbfx(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_UBFX ||
         I.getOpcode() == TargetOpcode::G_SBFX ||
         I.getOpcode() == TargetOpcode::G_SEXT_INREG && "Unexpected G code");

  const unsigned NewOpc =
      I.getOpcode() == TargetOpcode::G_UBFX ? M88k::EXTUrwo : M88k::EXTrwo;
  uint64_t Width, Offset;
  if (I.getOpcode() == TargetOpcode::G_SEXT_INREG) {
    // For G_SEXT_INREG, the width is the immediate in operand 2. The offset is
    // always 0.
    Width = I.getOperand(2).getImm() + 1;
    assert(Width < 32 && "Can't sign-extend 32bit value");
    Offset = 0;
  } else {
    auto OffsetCst =
        getIConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI, true);
    if (!OffsetCst)
      return false;
    Offset = OffsetCst->Value.getZExtValue();

    auto WidthCst =
        getIConstantVRegValWithLookThrough(I.getOperand(3).getReg(), MRI, true);
    if (!WidthCst)
      return false;

    Width = WidthCst->Value.getZExtValue();
  }

  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
                         .add(I.getOperand(0))
                         .add(I.getOperand(1))
                         .addImm(Width)
                         .addImm(Offset);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

enum class ICC : unsigned {
  EQ = 2,  // equal
  NE = 3,  // not equal
  GT = 4,  // signed greater than
  LE = 5,  // signed less than or equal
  LT = 6,  // signed less than
  GE = 7,  // signed greater than or equal
  HI = 8,  // unsigned greater than
  LS = 9,  // unsigned less than or equal
  LO = 10, // unsigned less than
  HS = 11, // unsigned greater than or equal
  BE = 12, // any byte equal
  NB = 13, // no byte equal
  HE = 14, // any half-word equal
  NH = 15  // no half-word equal
};

static ICC getCCforICMP(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return ICC::EQ;
  case CmpInst::ICMP_NE:
    return ICC::NE;
  case CmpInst::ICMP_UGT:
    return ICC::HI;
  case CmpInst::ICMP_UGE:
    return ICC::HS;
  case CmpInst::ICMP_ULT:
    return ICC::LO;
  case CmpInst::ICMP_ULE:
    return ICC::LS;
  case CmpInst::ICMP_SGT:
    return ICC::GT;
  case CmpInst::ICMP_SGE:
    return ICC::GE;
  case CmpInst::ICMP_SLT:
    return ICC::LT;
  case CmpInst::ICMP_SLE:
    return ICC::LE;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

enum class CC0 : unsigned {
  EQ0 = 0x2,
  NE0 = 0xd,
  GT0 = 0x1,
  LT0 = 0xc,
  GE0 = 0x3,
  LE0 = 0xe
};

static CC0 getCCforBCOND(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return CC0::EQ0;
  case CmpInst::ICMP_NE:
    return CC0::NE0;
  case CmpInst::ICMP_SGT:
    return CC0::GT0;
  case CmpInst::ICMP_SGE:
    return CC0::GE0;
  case CmpInst::ICMP_SLT:
    return CC0::LT0;
  case CmpInst::ICMP_SLE:
    return CC0::LE0;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

bool M88kInstructionSelector::selectICmp(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_ICMP && "Unexpected G code");

  MachineInstr *MI = nullptr;
  CmpInst::Predicate Pred =
      static_cast<CmpInst::Predicate>(I.getOperand(1).getPredicate());
  ICC CCCode = getCCforICMP(Pred);
  Register LHS = I.getOperand(2).getReg();
  Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);

  auto Cst =
      getIConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI, true);
  if (Cst && isInt<16>(Cst->Value.getZExtValue())) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addImm(Cst->Value.getZExtValue());
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .add(I.getOperand(3));
  }
  if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::EXTUrwo))
           .add(I.getOperand(0))
           .addReg(Temp, RegState::Kill)
           .addImm(1)
           .addImm(int64_t(CCCode));

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectBrCond(MachineInstr &I,
                                           MachineBasicBlock &MBB,
                                           MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRCOND && "Unexpected G code");
  // Match combinations of G_BRCND and G_ICMP/G_FCMP or
  // combinations of G_BRCOND and G_TRUNC of G_AND/G_XOR.

  // G_ICMP: $tst, $src1, $src2
  // G_BRCOND: $tst, $truebb
  MachineInstr *MI = nullptr;
  Register CC = I.getOperand(0).getReg();
  MachineBasicBlock *BB = I.getOperand(1).getMBB();
  CmpInst::Predicate Pred;
  Register LHS, RHS, Reg;
  int64_t UImm16;
  if (mi_match(CC, MRI, m_GICmp(m_Pred(Pred), m_Reg(LHS), m_ICst(UImm16))) &&
      isUInt<16>(UImm16)) {
    if (UImm16 == 0) {
      CC0 CCCode = getCCforBCOND(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BCND))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(LHS)
               .addMBB(BB);
    } else {
      Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
      ICC CCCode = getCCforICMP(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
               .addReg(Temp, RegState::Define)
               .addReg(LHS)
               .addImm(UImm16);
      if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
        return false;
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(Temp, RegState::Kill)
               .addMBB(BB);
    }
  } else if (mi_match(CC, MRI, m_GICmp(m_Pred(Pred), m_Reg(LHS), m_Reg(RHS)))) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addReg(RHS);
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(static_cast<int64_t>(CCCode))
             .addReg(Temp, RegState::Kill)
             .addMBB(BB);
  } else if (mi_match(
                 CC, MRI,
                 m_GTrunc(m_any_of(m_GAnd(m_Reg(Reg), m_SpecificICst(1)),
                                   m_GXor(m_GXor(m_Reg(Reg), m_SpecificICst(1)),
                                          m_SpecificICst(1)))))) {
    // TODO The xor(xor %r, 1), 1) pattern should be handled by a combiner.
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(0)
             .addReg(Reg)
             .addMBB(BB);
  } else if (mi_match(CC, MRI,
                      m_GTrunc(m_GXor(m_Reg(Reg), m_SpecificICst(1))))) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB0))
             .addImm(0)
             .addReg(Reg)
             .addMBB(BB);
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(0)
             .addReg(CC)
             .addMBB(BB);
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectJumpTable(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_JUMP_TABLE && "Unexpected G code");

  MachineInstr *MI = nullptr;
  Register Reg = I.getOperand(0).getReg();
  int JTIndex = I.getOperand(1).getIndex();

  Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
           .addReg(Temp, RegState::Define)
           .addReg(M88k::R0)
           .addJumpTableIndex(JTIndex, M88kII::MO_ABS_HI);
  if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORri))
           .addReg(Reg, RegState::Define)
           .addReg(Temp, RegState::Kill)
           .addJumpTableIndex(JTIndex, M88kII::MO_ABS_LO);
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectBrJT(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRJT && "Unexpected G code");

  MachineInstr *MI = nullptr;
  MachineFunction &MF = *I.getParent()->getParent();
  unsigned EntrySize = MF.getJumpTableInfo()->getEntrySize(MF.getDataLayout());
  assert((EntrySize == 0 || EntrySize == 4) &&
         "Unsupported size of jump-table entry.");

  Register JTPtrReg = I.getOperand(0).getReg();
  Register JTIndexReg = I.getOperand(2).getReg();

  Register DstReg = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
  if (EntrySize == 4) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDrrsw))
             .addReg(DstReg, RegState::Define)
             .addReg(JTPtrReg)
             .addReg(JTIndexReg);
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDrruw))
             .addReg(DstReg, RegState::Define)
             .addReg(JTPtrReg)
             .addReg(JTIndexReg);
  }
  if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::JMP)).addReg(DstReg);
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectBrIndirect(MachineInstr &I,
                                               MachineBasicBlock &MBB,
                                               MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRINDIRECT && "Unexpected G code");

  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::JMP))
                         .addReg(I.getOperand(0).getReg());
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectPtrAdd(MachineInstr &I,
                                           MachineBasicBlock &MBB,
                                           MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_PTR_ADD && "Unexpected G code");

  MachineInstr *MI = nullptr;
  Register PtrReg = I.getOperand(1).getReg();
  Register AddendReg = I.getOperand(2).getReg();

  int64_t Offset;
  if (mi_match(AddendReg, MRI, m_ICst(Offset)) && isUInt<16>(Offset)) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ADDUri),
                 I.getOperand(0).getReg())
             .addReg(PtrReg)
             .addImm(Offset);
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ADDrr),
                 I.getOperand(0).getReg())
             .addReg(PtrReg)
             .addReg(AddendReg);
  }
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectMul(MachineInstr &I, MachineBasicBlock &MBB,
                                        MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_MUL && "Unexpected G code");

  // Only selects special mulu.d instruction, the other mul instructions are
  // matched by the patterns from the target description.
  if (!isMC88110())
    return false;

  MachineInstr *MI = nullptr;
  Register DstReg = I.getOperand(0).getReg();
  Register Src1Reg = I.getOperand(1).getReg();
  Register Src2Reg = I.getOperand(2).getReg();

  MachineInstr *Merge1MI =
      getOpcodeDef(TargetOpcode::G_MERGE_VALUES, Src1Reg, MRI);
  MachineInstr *Merge2MI =
      getOpcodeDef(TargetOpcode::G_MERGE_VALUES, Src2Reg, MRI);
  if (Merge1MI &&
      mi_match(Merge1MI->getOperand(1).getReg(), MRI, m_ZeroInt()) &&
      Merge2MI &&
      mi_match(Merge2MI->getOperand(1).getReg(), MRI, m_ZeroInt())) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::MULUrrd), DstReg)
             .addReg(Merge1MI->getOperand(2).getReg())
             .addReg(Merge2MI->getOperand(2).getReg());
  } else
    return false;

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectUDiv(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_UDIV && "Unexpected G code");

  // Only selects special divu.d instruction, the other div instructions are
  // matched by the patterns from the target description.
  if (!isMC88110())
    return false;

  MachineInstr *MI = nullptr;
  Register DstReg = I.getOperand(0).getReg();
  Register Src1Reg = I.getOperand(1).getReg();
  Register Src2Reg = I.getOperand(2).getReg();

  MachineInstr *MergeMI =
      getOpcodeDef(TargetOpcode::G_MERGE_VALUES, Src2Reg, MRI);
  if (MergeMI && mi_match(MergeMI->getOperand(1).getReg(), MRI, m_ZeroInt())) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::DIVUrrd), DstReg)
             .addReg(Src1Reg)
             .addReg(MergeMI->getOperand(2).getReg());
  } else
    return false;

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectExt(MachineInstr &I, MachineBasicBlock &MBB,
                                        MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_ZEXT ||
         I.getOpcode() == TargetOpcode::G_ANYEXT ||
         I.getOpcode() == TargetOpcode::G_SEXT && "Unexpected G code");

  // Matches xEXT of ICMP.
  MachineInstr *MI = nullptr;
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();
  const unsigned NewOpc =
      I.getOpcode() == TargetOpcode::G_SEXT ? M88k::EXTrwo : M88k::EXTUrwo;
  CmpInst::Predicate Pred;
  Register LHS, RHS;
  int64_t SImm16;
  if (mi_match(SrcReg, MRI,
               m_GICmp(m_Pred(Pred), m_Reg(LHS), m_ICst(SImm16))) &&
      isInt<16>(SImm16)) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addImm(SImm16);
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc), DstReg)
             .addReg(Temp, RegState::Kill)
             .addImm(1)
             .addImm(int64_t(CCCode));
  } else if (mi_match(SrcReg, MRI,
                      m_GICmp(m_Pred(Pred), m_Reg(LHS), m_Reg(RHS)))) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addReg(RHS);
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc), DstReg)
             .addReg(Temp, RegState::Kill)
             .addImm(1)
             .addImm(int64_t(CCCode));
  } else
    return false;

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

enum class LoadStore : unsigned {
  Imm = 0,
  RegUnscaled,
  RegScaled,
};

static unsigned getLoadStoreOp(unsigned GenericOpc, unsigned Size, LoadStore Variant, bool IsUnsigned = false) {
  static unsigned LoadOpx[28] = {
    M88k::LDrib, M88k::LDrih, M88k::LDriw, M88k::LDrid,     // Size, Imm, signed
    M88k::LDrrub, M88k::LDrruh, M88k::LDrruw, M88k::LDrrud, // Size, RegUnscaled, signed
    M88k::LDrrsb, M88k::LDrrsh, M88k::LDrrsw, M88k::LDrrsd, // Size, RegScaled, signed
    0, 0, 0, 0,                                             //
    M88k::LDurib, M88k::LDurih, 0, 0,                       // Size, Imm, unsigned
    M88k::LDurrub, M88k::LDurruh, 0, 0,                     // Size, RegUnscaled, unsigned
    M88k::LDurrsb, M88k::LDurrsh, 0, 0,                     // Size, RegScaled, unsigned
  };
  static unsigned StoreOpx[12] = {
    M88k::STrib, M88k::STrih, M88k::STriw, M88k::STrid,     // Size, Imm, no write-through
    M88k::STrrub, M88k::STrruh, M88k::STrruw, M88k::STrrud, // Size, RegUnscaled, no write-through
    M88k::STrrsb, M88k::STrrsh, M88k::STrrsw, M88k::STrrsd, // Size, RegScaled, no write-through
  };
  bool IsLoad = (GenericOpc == TargetOpcode::G_LOAD ||
                 GenericOpc == TargetOpcode::G_ZEXTLOAD ||
                 GenericOpc == TargetOpcode::G_SEXTLOAD);
  assert(IsLoad || !IsUnsigned && "Only load has unsigned feature");
  unsigned Idx =
      Log2_32(Size) | (static_cast<unsigned>(Variant) << 2) | (IsUnsigned << 4);
  unsigned Opc = IsLoad ? LoadOpx[Idx] : StoreOpx[Idx];
  assert(Opc != 0 && "Non-existant combination of Load/Store requested");
  return Opc;
}

bool M88kInstructionSelector::selectLoadStore(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) const {
  auto MMO = *I.memoperands_begin();

  // No unaligned memory access.
  if (MMO->getAlign() < MMO->getSize())
    return false;

  GLoadStore &LdSt = cast<GLoadStore>(I);
  uint64_t MemSizeInBytes = LdSt.getMemSize();
  bool IsLoad = I.getOpcode() != TargetOpcode::G_STORE;
  bool IsZExtLoad = I.getOpcode() == TargetOpcode::G_ZEXTLOAD;

  MachineInstr *MI = nullptr;

  // PtrReg contains the memory address.
  Register PtrReg = I.getOperand(1).getReg();

  // ValReg is either the destination register of a load, or the source register
  // of a store. In case of a truncating store, match the G_TRUNC instruction
  // and use the source operand of that instruction.
  Register ValReg = I.getOperand(0).getReg();
  MachineInstr *TruncMI = nullptr;
  if (!IsLoad && ((TruncMI = getOpcodeDef(TargetOpcode::G_TRUNC, ValReg, MRI))))
    ValReg = TruncMI->getOperand(1).getReg();

  Register Base, Addend;
  if (MachineInstr *FrameIdxMI =
          getOpcodeDef(TargetOpcode::G_FRAME_INDEX, PtrReg, MRI)) {
    // Matches load/store + G_FRAME_INDEX.
    const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                           LoadStore::Imm, IsZExtLoad);
    int FrameIdx = FrameIdxMI->getOperand(1).getIndex();

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .addReg(ValReg, getDefRegState(IsLoad))
             .addFrameIndex(FrameIdx)
             .addImm(0)
             .addMemOperand(MMO);
  } else if (MachineInstr *GlobalValMI =
                 getOpcodeDef(TargetOpcode::G_GLOBAL_VALUE, PtrReg, MRI)) {
    // Matches load/store + G_GLOBAL_VALUE.
    const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                           LoadStore::Imm, IsZExtLoad);
    const GlobalValue *GV = GlobalValMI->getOperand(1).getGlobal();

    Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
             .addReg(Temp, RegState::Define)
             .addReg(M88k::R0)
             .addGlobalAddress(GV, 0, M88kII::MO_ABS_HI);
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
      return false;

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .addReg(ValReg, getDefRegState(IsLoad))
             .addReg(Temp, RegState::Kill)
             .addGlobalAddress(GV, 0, M88kII::MO_ABS_LO)
             .addMemOperand(MMO);
  } else if (mi_match(PtrReg, MRI, m_GPtrAdd(m_Reg(Base), m_Reg(Addend)))) {
    // Matches load/store + G_PTRADD.
    Register AddrReg = getRegIgnoringCopies(Base, MRI);
    Register IndexReg = getRegIgnoringCopies(Addend, MRI);

    int64_t Offset;
    int64_t Shift;
    Register ShiftReg;
    if (mi_match(IndexReg, MRI, m_ICst(Offset)) && isUInt<16>(Offset)) {
      const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                             LoadStore::Imm, IsZExtLoad);

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .addReg(ValReg, getDefRegState(IsLoad))
               .addReg(AddrReg)
               .addImm(Offset)
               .addMemOperand(MMO);
    } else if (mi_match(IndexReg, MRI,
                        m_GShl(m_Reg(ShiftReg), m_ICst(Shift))) &&
               Shift == Log2_32(MemSizeInBytes)) {
      const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                             LoadStore::RegScaled, IsZExtLoad);

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .addReg(ValReg, getDefRegState(IsLoad))
               .addReg(AddrReg)
               .addReg(ShiftReg)
               .addMemOperand(MMO);
    } else {
      const unsigned NewOpc = getLoadStoreOp(
          I.getOpcode(), MemSizeInBytes, LoadStore::RegUnscaled, IsZExtLoad);

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .addReg(ValReg, getDefRegState(IsLoad))
               .addReg(AddrReg)
               .addReg(IndexReg)
               .addMemOperand(MMO);
    }
  } else {
    // Simple load/store.
    const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                           LoadStore::Imm, IsZExtLoad);

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .addReg(ValReg, getDefRegState(IsLoad))
             .addReg(PtrReg)
             .addImm(0)
             .addMemOperand(MMO);
  }

  if (TruncMI)
    TruncMI->eraseFromParent();

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectMergeUnmerge(
    MachineInstr &I, MachineBasicBlock &MBB, MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_MERGE_VALUES ||
         I.getOpcode() == TargetOpcode::G_UNMERGE_VALUES &&
             "Unexpected G code");

  MachineInstr *MI = nullptr;
  if (I.getOpcode() == TargetOpcode::G_MERGE_VALUES) {
    Register DstReg = I.getOperand(0).getReg();
    Register LoReg = I.getOperand(1).getReg();
    Register HiReg = I.getOperand(2).getReg();
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::REG_SEQUENCE),
            DstReg)
        .addUse(LoReg)
        .addImm(M88k::sub_lo)
        .addUse(HiReg)
        .addImm(M88k::sub_hi);
    RBI.constrainGenericRegister(DstReg, M88k::GPR64RCRegClass, MRI);
  } else {
    Register SrcReg = I.getOperand(2).getReg();

    // Copy to dst.
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
                 I.getOperand(0).getReg())
             .addReg(SrcReg, 0, M88k::sub_lo);
    RBI.constrainGenericRegister(I.getOperand(0).getReg(), M88k::GPRRCRegClass,
                                 MRI);
    constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
                 I.getOperand(1).getReg())
             .addReg(SrcReg, 0, M88k::sub_hi);
    RBI.constrainGenericRegister(I.getOperand(1).getReg(), M88k::GPRRCRegClass,
                                 MRI);
  }
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectIntrinsic(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) {
  unsigned IntrinID = I.getIntrinsicID();
  MachineInstr *MI = nullptr;

  switch (IntrinID) {
  default:
    break;
  case Intrinsic::frameaddress:
  case Intrinsic::returnaddress: {
    MachineFunction &MF = *I.getParent()->getParent();
    MachineFrameInfo &MFI = MF.getFrameInfo();

    unsigned Depth = I.getOperand(2).getImm();
    Register DstReg = I.getOperand(0).getReg();
    RBI.constrainGenericRegister(DstReg, M88k::GPRRCRegClass, MRI);

    if (Depth == 0 && IntrinID == Intrinsic::returnaddress) {
      if (!MFReturnAddr) {
        // Insert the copy from R1 into the entry block, before it can be
        // clobbered by anything.
        MFI.setReturnAddressIsTaken(true);
        MFReturnAddr = getFunctionLiveInPhysReg(
            MF, TII, M88k::R1, M88k::GPRRCRegClass, I.getDebugLoc());
      }

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY), DstReg)
               .addReg(MFReturnAddr);

      I.eraseFromParent();
      return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
    }

    MFI.setFrameAddressIsTaken(true);
    Register FrameAddr(M88k::R30);
    while (Depth--) {
      Register NextFrame = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDriw), NextFrame)
               .addUse(FrameAddr)
               .addImm(0);

      constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
      FrameAddr = NextFrame;
    }

    if (IntrinID == Intrinsic::frameaddress)
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY), DstReg)
               .addReg(FrameAddr);
    else {
      MFI.setReturnAddressIsTaken(true);

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDriw), DstReg)
               .addUse(FrameAddr)
               .addImm(4);
    }

    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
  }
  return false;
}

bool M88kInstructionSelector::earlySelect(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  switch (I.getOpcode()) {
  case TargetOpcode::G_CONSTANT: {
    // Only handle negative 32bit values between -1 and -65536.
    // Other constants are handled by TableGen.
    APInt ConstValue = I.getOperand(1).getCImm()->getValue();
    if (ConstValue.isSignedIntN(32)) {
      int64_t Cst = ConstValue.getSExtValue();
      if (Cst < 0 && Cst >= -65536) {
        MachineInstr *MI;
        if (Cst == -65536)
          MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::SETrwo),
                       I.getOperand(0).getReg())
                   .addReg(M88k::R0)
                   .addImm(16)
                   .addImm(16);
        else
          MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::SUBUri),
                       I.getOperand(0).getReg())
                   .addReg(M88k::R0)
                   .addImm(-Cst);
        I.eraseFromParent();
        return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
      }
    }
    return false;
  }
  case TargetOpcode::G_AND:
  case TargetOpcode::G_OR: {
    // Lower
    //   G_AND $dst, $src, ~((2**width - 1) << offset)
    // to
    //   CLRrwo $dst, $src, width<offset>
    // and
    //   G_OR $dst, $src, ((2**width - 1) << offset
    // to
    //   SETrwo $dst, $src, width<offset>
    //
    // The special cases
    //   G_AND $dst, $src, 0
    // and
    //   G_OR $dst, $src, -1
    // are lowered to
    //   G_COPY $msk
    bool IsAnd = I.getOpcode() == TargetOpcode::G_AND;
    Register DstReg = I.getOperand(0).getReg();
    if (!MRI.getType(DstReg).isScalar())
      return false;

    Register SrcReg = I.getOperand(1).getReg();
    Register MskReg = I.getOperand(2).getReg();
    int64_t Mask;
    if (!mi_match(MskReg, MRI, m_ICst(Mask))) {
      std::swap(MskReg, SrcReg);
      if (!mi_match(MskReg, MRI, m_ICst(Mask)))
        return false;
    }

    // Check that the mask is a (negated) shifted mask.
    Mask &= 0xFFFFFFFF;
    if (IsAnd)
      Mask = ~static_cast<uint64_t>(Mask) & 0xFFFFFFFF;
    uint64_t MaskWidth, MaskOffset;
    if (!isShiftedMask(Mask, MaskWidth, MaskOffset))
      return false;

    assert(MaskWidth > 0 && MaskWidth <= 32 && "Width out of range");
    assert(MaskOffset >= 0 && MaskOffset < 32 && "Offset out of range");

    MachineInstr *MI;
    if (MaskWidth == 32 && MaskOffset == 0) {
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
                   I.getOperand(0).getReg())
               .addReg(MskReg);
      RBI.constrainGenericRegister(I.getOperand(0).getReg(),
                                   M88k::GPRRCRegClass, MRI);
    } else {
      unsigned NewOpc = IsAnd ? M88k::CLRrwo : M88k::SETrwo;
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .add(I.getOperand(0))
               .addReg(SrcReg)
               .addImm(MaskWidth & 0x1f)
               .addImm(MaskOffset);
    }
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
  default:
    return false;
  }
}

void M88kInstructionSelector::setupMF(MachineFunction &MF, GISelKnownBits *KB,
                                      CodeGenCoverage &CoverageInfo,
                                      ProfileSummaryInfo *PSI,
                                      BlockFrequencyInfo *BFI) {
  InstructionSelector::setupMF(MF, KB, CoverageInfo, PSI, BFI);
  MFReturnAddr = Register();
}

bool M88kInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  // Certain non-generic instructions also need some special handling.
  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCopy(I, TII, MRI, TRI, RBI);

    return true;
  }

  if (earlySelect(I))
    return true;

  if (selectImpl(I, *CoverageInfo))
    return true;

  switch (I.getOpcode()) {
  case TargetOpcode::G_INTRINSIC:
    return selectIntrinsic(I, MBB, MRI);
  case TargetOpcode::G_GLOBAL_VALUE:
    return selectGlobalValue(I, MBB, MRI);
  case TargetOpcode::G_PTR_ADD:
    return selectPtrAdd(I, MBB, MRI);
  case TargetOpcode::G_FRAME_INDEX:
    return selectFrameIndex(I, MBB, MRI);
  case TargetOpcode::G_SITOFP:
  case TargetOpcode::G_FPTOSI:
    return selectFPtoSI(I, MBB, MRI);
  case TargetOpcode::G_UBFX:
  case TargetOpcode::G_SBFX:
  case TargetOpcode::G_SEXT_INREG:
    return selectUbfx(I, MBB, MRI);
  case TargetOpcode::G_ICMP:
    return selectICmp(I, MBB, MRI);
  case TargetOpcode::G_BRCOND:
    return selectBrCond(I, MBB, MRI);
  case TargetOpcode::G_JUMP_TABLE:
    return selectJumpTable(I, MBB, MRI);
  case TargetOpcode::G_BRJT:
    return selectBrJT(I, MBB, MRI);
  case TargetOpcode::G_BRINDIRECT:
    return selectBrIndirect(I, MBB, MRI);
  case TargetOpcode::G_MUL:
    return selectMul(I, MBB, MRI);
  case TargetOpcode::G_UDIV:
    return selectUDiv(I, MBB, MRI);
  case TargetOpcode::G_ZEXT:
  case TargetOpcode::G_SEXT:
  case TargetOpcode::G_ANYEXT: // TODO Can G_ANYEXT end up here?
    return selectExt(I, MBB, MRI);
  case TargetOpcode::G_SEXTLOAD:
  case TargetOpcode::G_ZEXTLOAD:
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE:
    return selectLoadStore(I, MBB, MRI);
  case TargetOpcode::G_MERGE_VALUES:
  case TargetOpcode::G_UNMERGE_VALUES:
    return selectMergeUnmerge(I, MBB, MRI);
  case TargetOpcode::G_PHI: {
    I.setDesc(TII.get(TargetOpcode::PHI));

    Register DstReg = I.getOperand(0).getReg();
    const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);
    return RBI.constrainGenericRegister(DstReg, *RC, MRI);
  }
  default:
    return false;
  }
}

namespace llvm {
InstructionSelector *
createM88kInstructionSelector(const M88kTargetMachine &TM,
                              const M88kSubtarget &Subtarget,
                              const M88kRegisterBankInfo &RBI) {
  return new M88kInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
