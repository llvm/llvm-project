//===- M88kInstructionSelector.cpp ------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kGlobalISelUtils.h"
#include "M88kRegisterBankInfo.h"
#include "M88kSubtarget.h"
#include "M88kTargetMachine.h"
#include "MCTargetDesc/M88kBaseInfo.h"
#include "llvm/CodeGen/GlobalISel/GenericMachineInstrs.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/CodeGen/GlobalISel/Utils.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/Register.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MathExtras.h"

#define DEBUG_TYPE "M88k-isel"

using namespace llvm;
using namespace M88kGISelUtils;
using namespace MIPatternMatch;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

namespace {

class M88kInstructionSelector : public InstructionSelector {
public:
  M88kInstructionSelector(const M88kTargetMachine &TM, const M88kSubtarget &STI,
                          const M88kRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  void setupMF(MachineFunction &MF, GISelKnownBits *KB,
               CodeGenCoverage &CoverageInfo, ProfileSummaryInfo *PSI,
               BlockFrequencyInfo *BFI) override;
  static const char *getName() { return DEBUG_TYPE; }

private:
  // An early selection function that runs before the selectImpl() call.
  bool earlySelect(MachineInstr &I);

  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  void renderLO16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;
  void renderHI16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;

  bool selectGlobalValue(MachineInstr &I, MachineBasicBlock &MBB,
                         MachineRegisterInfo &MRI) const;
  bool selectUbfx(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectICmp(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectCondBr(MachineInstr &I, MachineBasicBlock &MBB,
                    MachineRegisterInfo &MRI) const;
  bool selectLoadStore(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI) const;
  bool selectMergeUnmerge(MachineInstr &I, MachineBasicBlock &MBB,
                          MachineRegisterInfo &MRI) const;
  bool selectIntrinsic(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI);

  const M88kTargetMachine &TM;
  const M88kInstrInfo &TII;
  const M88kRegisterInfo &TRI;
  const M88kRegisterBankInfo &RBI;

  // Some cached values used during selection.
  // We use R1 as a live-in register, and we keep track of it here as it can be
  // clobbered by calls.
  Register MFReturnAddr;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

M88kInstructionSelector::M88kInstructionSelector(
    const M88kTargetMachine &TM, const M88kSubtarget &STI,
    const M88kRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

static const TargetRegisterClass *guessRegClass(unsigned Reg,
                                                MachineRegisterInfo &MRI,
                                                const TargetRegisterInfo &TRI,
                                                const RegisterBankInfo &RBI) {
  const RegisterBank *RegBank = RBI.getRegBank(Reg, MRI, TRI);
  assert(RegBank && "Can't get reg bank for virtual register");

  const unsigned Size = MRI.getType(Reg).getSizeInBits();
  assert((RegBank->getID() == M88k::GRRegBankID ||
          RegBank->getID() == M88k::XRRegBankID) &&
         "Unsupported reg bank");

  if (RegBank->getID() == M88k::XRRegBankID)
    return &M88k::XRRCRegClass;

  if (Size == 64)
    return &M88k::GPR64RCRegClass;
  return &M88k::GPRRCRegClass;
}

static bool selectCopy(MachineInstr &I, const TargetInstrInfo &TII,
                       MachineRegisterInfo &MRI, const TargetRegisterInfo &TRI,
                       const RegisterBankInfo &RBI) {
  Register DstReg = I.getOperand(0).getReg();
  if (Register::isPhysicalRegister(DstReg))
    return true;

  const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its uses or its defs.
  // Copies do not have constraints.
  if (!RBI.constrainGenericRegister(DstReg, *RC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }
  return true;
}

void M88kInstructionSelector::renderLO16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val &= 0x000000000000FFFFULL;
  MIB.addImm(Val);
}

void M88kInstructionSelector::renderHI16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val = (Val & 0x00000000FFFF0000ULL) >> 16;
  MIB.addImm(Val);
}

bool M88kInstructionSelector::selectGlobalValue(
    MachineInstr &I, MachineBasicBlock &MBB, MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_GLOBAL_VALUE && "Unexpected G code");

  const GlobalValue *GV = I.getOperand(1).getGlobal();

  Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
                         .addReg(Temp, RegState::Define)
                         .addReg(M88k::R0)
                         .addGlobalAddress(GV, 0, M88kII::MO_ABS_HI);
  if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
    return false;

  MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORri))
           .add(I.getOperand(0))
           .addReg(Temp, RegState::Kill)
           .addGlobalAddress(GV, 0, M88kII::MO_ABS_LO);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectUbfx(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_UBFX ||
         I.getOpcode() == TargetOpcode::G_SBFX ||
         I.getOpcode() == TargetOpcode::G_SEXT_INREG && "Unexpected G code");

  const unsigned NewOpc =
      I.getOpcode() == TargetOpcode::G_UBFX ? M88k::EXTUrwo : M88k::EXTrwo;
  int64_t WO;
  if (I.getOpcode() == TargetOpcode::G_SEXT_INREG) {
    // For G_SEXT_INREG, the width is the immediate in operand 2. The offset is
    // always 0.
    int64_t Width = I.getOperand(2).getImm() + 1;
    assert(Width < 32 && "Can't sign-extend 32bit value");
    WO = Width << 5;
  } else {
    auto Offset =
        getIConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI, true);
    if (!Offset)
      return false;

    auto Width =
        getIConstantVRegValWithLookThrough(I.getOperand(3).getReg(), MRI, true);
    if (!Width)
      return false;

    WO = Width->Value.getZExtValue() << 5 | Offset->Value.getZExtValue();
  }

  MachineInstr *MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
                         .add(I.getOperand(0))
                         .add(I.getOperand(1))
                         .addImm(WO);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

enum class ICC : unsigned {
  EQ = 2,  // equal
  NE = 3,  // not equal
  GT = 4,  // signed greater than
  LE = 5,  // signed less than or equal
  LT = 6,  // signed less than
  GE = 7,  // signed greater than or equal
  HI = 8,  // unsigned greater than
  LS = 9,  // unsigned less than or equal
  LO = 10, // unsigned less than
  HS = 11, // unsigned greater than or equal
  BE = 12, // any byte equal
  NB = 13, // no byte equal
  HE = 14, // any half-word equal
  NH = 15  // no half-word equal
};

static ICC getCCforICMP(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return ICC::EQ;
  case CmpInst::ICMP_NE:
    return ICC::NE;
  case CmpInst::ICMP_UGT:
    return ICC::HI;
  case CmpInst::ICMP_UGE:
    return ICC::HS;
  case CmpInst::ICMP_ULT:
    return ICC::LO;
  case CmpInst::ICMP_ULE:
    return ICC::LS;
  case CmpInst::ICMP_SGT:
    return ICC::GT;
  case CmpInst::ICMP_SGE:
    return ICC::GE;
  case CmpInst::ICMP_SLT:
    return ICC::LT;
  case CmpInst::ICMP_SLE:
    return ICC::LE;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

enum class CC0 : unsigned {
  EQ0 = 0x2,
  NE0 = 0xd,
  GT0 = 0x1,
  LT0 = 0xc,
  GE0 = 0x3,
  LE0 = 0xe
};

static CC0 getCCforBCOND(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return CC0::EQ0;
  case CmpInst::ICMP_NE:
    return CC0::NE0;
  case CmpInst::ICMP_SGT:
    return CC0::GT0;
  case CmpInst::ICMP_SGE:
    return CC0::GE0;
  case CmpInst::ICMP_SLT:
    return CC0::LT0;
  case CmpInst::ICMP_SLE:
    return CC0::LE0;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

bool M88kInstructionSelector::selectICmp(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_ICMP && "Unexpected G code");

  MachineInstr *MI = nullptr;
  CmpInst::Predicate Pred =
      static_cast<CmpInst::Predicate>(I.getOperand(1).getPredicate());
  ICC CCCode = getCCforICMP(Pred);
  Register LHS = I.getOperand(2).getReg();
  Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);

  auto Cst =
      getIConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI, true);
  if (Cst && isInt<16>(Cst->Value.getZExtValue())) {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addImm(Cst->Value.getZExtValue());
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .add(I.getOperand(3));
  }
  if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
    return false;

    int64_t WO = 1 << 5 | int64_t(CCCode);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::EXTUrwo))
             .add(I.getOperand(0))
             .addReg(Temp, RegState::Kill)
             .addImm(WO);

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectCondBr(MachineInstr &I,
                                           MachineBasicBlock &MBB,
                                           MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRCOND && "Unexpected G code");
  // Match combinations of G_BRCND and G_ICMP/G_FCMP

  // G_ICMP: $tst, $src1, $src2
  // G_BRCOND: $tst, $truebb
  MachineInstr *MI = nullptr;
  MachineOperand CC = I.getOperand(0);
  MachineOperand BB = I.getOperand(1);
  CmpInst::Predicate Pred;
  Register LHS, RHS;
  int64_t SImm16;
  if (mi_match(CC.getReg(), MRI,
               m_GICmp(m_Pred(Pred), m_Reg(LHS), m_ICst(SImm16))) &&
      isInt<16>(SImm16)) {
    if (SImm16 == 0) {
      CC0 CCCode = getCCforBCOND(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BCND))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(LHS)
               .add(BB);
    } else {
      Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
      ICC CCCode = getCCforICMP(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
               .addReg(Temp, RegState::Define)
               .addReg(LHS)
               .addImm(SImm16);
      if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
        return false;
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(Temp, RegState::Kill)
               .add(BB);
    }
  } else if (mi_match(CC.getReg(), MRI,
                      m_GICmp(m_Pred(Pred), m_Reg(LHS), m_Reg(RHS)))) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addReg(RHS);
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(static_cast<int64_t>(CCCode))
             .addReg(Temp, RegState::Kill)
             .add(BB);
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .add(I.getOperand(0))
             .addImm(0)
             .add(I.getOperand(1));
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

enum class LoadStore : unsigned {
  Imm = 0,
  RegUnscaled,
  RegScaled,
};

static unsigned getLoadStoreOp(unsigned GenericOpc, unsigned Size, LoadStore Variant, bool IsUnsigned = false) {
  static unsigned LoadOpx[28] = {
    M88k::LDrib, M88k::LDrih, M88k::LDriw, M88k::LDrid,     // Size, Imm, signed
    M88k::LDrrub, M88k::LDrruh, M88k::LDrruw, M88k::LDrrud, // Size, RegUnscaled, signed
    M88k::LDrrsb, M88k::LDrrsh, M88k::LDrrsw, M88k::LDrrsd, // Size, RegScaled, signed
    0, 0, 0, 0,                                             //
    M88k::LDurib, M88k::LDurih, 0, 0,                       // Size, Imm, unsigned
    M88k::LDurrub, M88k::LDurruh, 0, 0,                     // Size, RegUnscaled, unsigned
    M88k::LDurrsb, M88k::LDurrsh, 0, 0,                     // Size, RegScaled, unsigned
  };
  static unsigned StoreOpx[12] = {
    M88k::STrib, M88k::STrih, M88k::STriw, M88k::STrid,     // Size, Imm, no write-through
    M88k::STrrub, M88k::STrruh, M88k::STrruw, M88k::STrrud, // Size, RegUnscaled, no write-through
    M88k::STrrsb, M88k::STrrsh, M88k::STrrsw, M88k::STrrsd, // Size, RegScaled, no write-through
  };
  bool IsLoad = (GenericOpc == TargetOpcode::G_LOAD ||
                 GenericOpc == TargetOpcode::G_ZEXTLOAD ||
                 GenericOpc == TargetOpcode::G_SEXTLOAD);
  assert(IsLoad || !IsUnsigned && "Only load has unsigned feature");
  unsigned Idx =
      Log2_32(Size) | (static_cast<unsigned>(Variant) << 2) | (IsUnsigned << 4);
  unsigned Opc = IsLoad ? LoadOpx[Idx] : StoreOpx[Idx];
  assert(Opc != 0 && "Non-existant combination of Load/Store requested");
  return Opc;
}

bool M88kInstructionSelector::selectLoadStore(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) const {
  auto MMO = *I.memoperands_begin();

  // No unaligned memory access.
  if (MMO->getAlign() < MMO->getSize()) {
    return false;
  }

  GLoadStore &LdSt = cast<GLoadStore>(I);
  uint64_t MemSizeInBytes = LdSt.getMemSize();
  bool IsLoad = I.getOpcode() != TargetOpcode::G_STORE;
  bool IsZExtLoad = I.getOpcode() == TargetOpcode::G_ZEXTLOAD;

  MachineInstr *MI = nullptr;
  MachineOperand Ptr = I.getOperand(1);

  // ValReg is either the destination register of a load, or the source register
  // of a store. In case of a truncating store, match the G_TRUNC instruction
  // and use the source operand of that instruction.
  Register ValReg = I.getOperand(0).getReg();
  MachineInstr *TruncMI = nullptr;
  if (!IsLoad &&
      ((TruncMI = getOpcodeDef(TargetOpcode::G_TRUNC, ValReg, MRI))))
    ValReg = TruncMI->getOperand(1).getReg();

  int64_t Offset;
  MachineInstr *Base, *Addend;
  if (MachineInstr *FrameIdxMI =
          getOpcodeDef(TargetOpcode::G_FRAME_INDEX, Ptr.getReg(), MRI)) {
    // Matches load/store + G_FRAME_INDEX.
    const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                           LoadStore::Imm, IsZExtLoad);
    int FrameIdx = FrameIdxMI->getOperand(1).getIndex();

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .addReg(ValReg, getDefRegState(IsLoad))
             .addFrameIndex(FrameIdx)
             .addImm(0)
             .addMemOperand(MMO);
  } else if (MachineInstr *GlobalValMI = getOpcodeDef(
                 TargetOpcode::G_GLOBAL_VALUE, Ptr.getReg(), MRI)) {
    // Matches load/store + G_GLOBAL_VALUE.
    const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                           LoadStore::Imm, IsZExtLoad);
    const GlobalValue *GV = GlobalValMI->getOperand(1).getGlobal();

    Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::ORriu))
             .addReg(Temp, RegState::Define)
             .addReg(M88k::R0)
             .addGlobalAddress(GV);
    MI->getOperand(2).setTargetFlags(M88kII::MO_ABS_HI);
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
      return false;

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .addReg(ValReg, getDefRegState(IsLoad))
             .addReg(Temp, RegState::Kill)
             .addGlobalAddress(GV)
             .addMemOperand(MMO);
    MI->getOperand(2).setTargetFlags(M88kII::MO_ABS_LO);
  } else if (mi_match(Ptr.getReg(), MRI,
                      m_GPtrAdd(m_MInstr(Base), m_ICst(Offset))) &&
             isUInt<16>(Offset)) {
    // Matches load/store + G_PTRADD + 16bit imm.
    Register AddrReg =
        Base->getOperand(Base->getOpcode() == TargetOpcode::COPY ? 1 : 0)
            .getReg();

    const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                           LoadStore::Imm, IsZExtLoad);

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .addReg(ValReg, getDefRegState(IsLoad))
             .addReg(AddrReg)
             .addImm(Offset)
             .addMemOperand(MMO);
  } else if (mi_match(Ptr.getReg(), MRI,
                      m_GPtrAdd(m_MInstr(Base), m_MInstr(Addend)))) {
    // Matches load/store + G_PTRADD.
    Register AddrReg =
        Base->getOperand(Base->getOpcode() == TargetOpcode::COPY ? 1 : 0)
            .getReg();
    Register IndexReg =
        Base->getOperand(Addend->getOpcode() == TargetOpcode::COPY ? 1 : 0)
            .getReg();

    const unsigned NewOpc = getLoadStoreOp(I.getOpcode(), MemSizeInBytes,
                                           LoadStore::RegUnscaled, IsZExtLoad);

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .addReg(ValReg, getDefRegState(IsLoad))
             .addReg(AddrReg)
             .addReg(IndexReg)
             .addMemOperand(MMO);
  } else
    return false;

  if (TruncMI)
    TruncMI->eraseFromParent();

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectMergeUnmerge(
    MachineInstr &I, MachineBasicBlock &MBB, MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_MERGE_VALUES ||
         I.getOpcode() == TargetOpcode::G_UNMERGE_VALUES &&
             "Unexpected G code");

  MachineInstr *MI = nullptr;
  if (I.getOpcode() == TargetOpcode::G_MERGE_VALUES) {
    Register ImpDefReg = MRI.createVirtualRegister(&M88k::GPR64RCRegClass);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::IMPLICIT_DEF),
                 ImpDefReg);
    constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);

    Register HiReg = MRI.createVirtualRegister(&M88k::GPR64RCRegClass);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::INSERT_SUBREG),
                 HiReg)
             .addUse(ImpDefReg)
             .addUse(I.getOperand(1).getReg())
             .addImm(M88k::sub_hi);
    constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);

    Register HiLoReg = MRI.createVirtualRegister(&M88k::GPR64RCRegClass);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::INSERT_SUBREG),
                 HiLoReg)
             .addUse(HiReg)
             .addUse(I.getOperand(2).getReg())
             .addImm(M88k::sub_lo);
    constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
                 I.getOperand(0).getReg())
             .addUse(HiLoReg);
  } else {
    Register SrcReg = I.getOperand(2).getReg();

    // Copy to dst.
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
                 I.getOperand(0).getReg())
             .addReg(SrcReg, 0, M88k::sub_hi);
    RBI.constrainGenericRegister(I.getOperand(0).getReg(), M88k::GPRRCRegClass,
                                 MRI);
    constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
                 I.getOperand(1).getReg())
             .addReg(SrcReg, 0, M88k::sub_lo);
    RBI.constrainGenericRegister(I.getOperand(1).getReg(), M88k::GPRRCRegClass,
                                 MRI);
  }
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectIntrinsic(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) {
  unsigned IntrinID = I.getIntrinsicID();
  MachineInstr *MI = nullptr;

  switch (IntrinID) {
  default:
    break;
  case Intrinsic::frameaddress:
  case Intrinsic::returnaddress: {
    MachineFunction &MF = *I.getParent()->getParent();
    MachineFrameInfo &MFI = MF.getFrameInfo();

    unsigned Depth = I.getOperand(2).getImm();
    Register DstReg = I.getOperand(0).getReg();
    RBI.constrainGenericRegister(DstReg, M88k::GPRRCRegClass, MRI);

    if (Depth == 0 && IntrinID == Intrinsic::returnaddress) {
      if (!MFReturnAddr) {
        // Insert the copy from R1 into the entry block, before it can be
        // clobbered by anything.
        MFI.setReturnAddressIsTaken(true);
        MFReturnAddr = getFunctionLiveInPhysReg(
            MF, TII, M88k::R1, M88k::GPRRCRegClass, I.getDebugLoc());
      }

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY), DstReg)
               .addReg(MFReturnAddr);

      I.eraseFromParent();
      return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
    }

    MFI.setFrameAddressIsTaken(true);
    Register FrameAddr(M88k::R30);
    while (Depth--) {
      Register NextFrame = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDriw), NextFrame)
               .addUse(FrameAddr)
               .addImm(0);

      constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
      FrameAddr = NextFrame;
    }

    if (IntrinID == Intrinsic::frameaddress)
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY), DstReg)
               .addReg(FrameAddr);
    else {
      MFI.setReturnAddressIsTaken(true);

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::LDriw), DstReg)
               .addUse(FrameAddr)
               .addImm(4);
    }

    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
  }
  return false;
}

bool M88kInstructionSelector::earlySelect(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  switch (I.getOpcode()) {
  case TargetOpcode::G_AND:
  case TargetOpcode::G_OR: {
    // Lower
    //   G_AND $dst, $src, ~((2**width - 1) << offset)
    // to
    //   CLRrwo $dst, $src, width<offset>
    // and
    //   G_OR $dst, $src, ((2**width - 1) << offset
    // to
    //   SETrwo $dst, $src, width<offset>
    //
    // The special cases
    //   G_AND $dst, $src, 0
    // and
    //   G_OR $dst, $src, -1
    // are lowered to
    //   G_COPY $msk
    bool IsAnd = I.getOpcode() == TargetOpcode::G_AND;
    Register DstReg = I.getOperand(0).getReg();
    if (!MRI.getType(DstReg).isScalar())
      return false;

    Register SrcReg = I.getOperand(1).getReg();
    Register MskReg = I.getOperand(2).getReg();
    int64_t Mask;
    if (!mi_match(MskReg, MRI, m_ICst(Mask))) {
      std::swap(MskReg, SrcReg);
      if (!mi_match(MskReg, MRI, m_ICst(Mask)))
        return false;
    }

    // Check that the mask is a (negated) shifted mask.
    Mask &= 0xFFFFFFFF;
    if (IsAnd)
      Mask = ~static_cast<uint64_t>(Mask) & 0xFFFFFFFF;
    uint64_t MaskWidth, MaskOffset;
    if (!isShiftedMask(Mask, MaskWidth, MaskOffset))
      return false;

    assert(MaskWidth > 0 && MaskWidth <= 32 && "Width out of range");
    assert(MaskOffset >= 0 && MaskOffset < 32 && "Offset out of range");

    MachineInstr *MI;
    if (MaskWidth == 32 && MaskOffset == 0) {
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(TargetOpcode::COPY),
                   I.getOperand(0).getReg())
               .addReg(MskReg);
      RBI.constrainGenericRegister(I.getOperand(0).getReg(),
                                   M88k::GPRRCRegClass, MRI);
    } else {
      unsigned NewOpc = IsAnd ? M88k::CLRrwo : M88k::SETrwo;
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .add(I.getOperand(0))
               .addReg(SrcReg)
               .addImm(((MaskWidth << 5) | MaskOffset) & 0x3ff);
    }
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
  }
  default:
    return false;
  }
}

void M88kInstructionSelector::setupMF(MachineFunction &MF, GISelKnownBits *KB,
                                      CodeGenCoverage &CoverageInfo,
                                      ProfileSummaryInfo *PSI,
                                      BlockFrequencyInfo *BFI) {
  InstructionSelector::setupMF(MF, KB, CoverageInfo, PSI, BFI);
  MFReturnAddr = Register();
}

bool M88kInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  // Certain non-generic instructions also need some special handling.
  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCopy(I, TII, MRI, TRI, RBI);

    return true;
  }

  if (earlySelect(I))
    return true;

  if (selectImpl(I, *CoverageInfo))
    return true;

  switch (I.getOpcode()) {
  case TargetOpcode::G_INTRINSIC:
    return selectIntrinsic(I, MBB, MRI);
  case TargetOpcode::G_GLOBAL_VALUE:
    return selectGlobalValue(I, MBB, MRI);
  case TargetOpcode::G_UBFX:
  case TargetOpcode::G_SBFX:
  case TargetOpcode::G_SEXT_INREG:
    return selectUbfx(I, MBB, MRI);
  case TargetOpcode::G_ICMP:
    return selectICmp(I, MBB, MRI);
  case TargetOpcode::G_BRCOND:
    return selectCondBr(I, MBB, MRI);
  case TargetOpcode::G_SEXTLOAD:
  case TargetOpcode::G_ZEXTLOAD:
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE:
    return selectLoadStore(I, MBB, MRI);
  case TargetOpcode::G_MERGE_VALUES:
  case TargetOpcode::G_UNMERGE_VALUES:
    return selectMergeUnmerge(I, MBB, MRI);
  case TargetOpcode::G_PHI: {
    I.setDesc(TII.get(TargetOpcode::PHI));

    Register DstReg = I.getOperand(0).getReg();
    const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);
    return RBI.constrainGenericRegister(DstReg, *RC, MRI);
  }
  default:
    return false;
  }
}

namespace llvm {
InstructionSelector *
createM88kInstructionSelector(const M88kTargetMachine &TM,
                              const M88kSubtarget &Subtarget,
                              const M88kRegisterBankInfo &RBI) {
  return new M88kInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
