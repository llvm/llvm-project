//===- M88kInstructionSelector.cpp ------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kRegisterBankInfo.h"
#include "M88kSubtarget.h"
#include "M88kTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/Support/Debug.h"

#define DEBUG_TYPE "M88k-isel"

using namespace llvm;
using namespace MIPatternMatch;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

namespace {

class M88kInstructionSelector : public InstructionSelector {
public:
  M88kInstructionSelector(const M88kTargetMachine &TM, const M88kSubtarget &STI,
                          const M88kRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  static const char *getName() { return DEBUG_TYPE; }

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  void renderLO16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;
  void renderHI16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;

  bool selectICmp(MachineInstr &I, MachineBasicBlock &MBB,
                  MachineRegisterInfo &MRI) const;
  bool selectCondBr(MachineInstr &I, MachineBasicBlock &MBB,
                    MachineRegisterInfo &MRI) const;
  bool selectLoadStore(MachineInstr &I, MachineBasicBlock &MBB,
                       MachineRegisterInfo &MRI) const;

  const M88kTargetMachine &TM;
  const M88kInstrInfo &TII;
  const M88kRegisterInfo &TRI;
  const M88kRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

M88kInstructionSelector::M88kInstructionSelector(
    const M88kTargetMachine &TM, const M88kSubtarget &STI,
    const M88kRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

static const TargetRegisterClass *guessRegClass(unsigned Reg,
                                                MachineRegisterInfo &MRI,
                                                const TargetRegisterInfo &TRI,
                                                const RegisterBankInfo &RBI) {
  const RegisterBank *RegBank = RBI.getRegBank(Reg, MRI, TRI);
  assert(RegBank && "Can't get reg bank for virtual register");

  const unsigned Size = MRI.getType(Reg).getSizeInBits();
  assert((RegBank->getID() == M88k::GRRegBankID ||
          RegBank->getID() == M88k::XRRegBankID) &&
         "Unsupported reg bank");

  if (RegBank->getID() == M88k::XRRegBankID)
    return &M88k::XRRCRegClass;

  if (Size == 64)
    return &M88k::GPR64RCRegClass;
  return &M88k::GPRRCRegClass;
}

static bool selectCopy(MachineInstr &I, const TargetInstrInfo &TII,
                       MachineRegisterInfo &MRI, const TargetRegisterInfo &TRI,
                       const RegisterBankInfo &RBI) {
  Register DstReg = I.getOperand(0).getReg();
  if (Register::isPhysicalRegister(DstReg))
    return true;

  const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its uses or its defs.
  // Copies do not have constraints.
  if (!RBI.constrainGenericRegister(DstReg, *RC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }
  return true;
}

void M88kInstructionSelector::renderLO16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val &= 0x000000000000FFFFULL;
  MIB.addImm(Val);
}

void M88kInstructionSelector::renderHI16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val = (Val & 0x00000000FFFF0000ULL) >> 16;
  MIB.addImm(Val);
}

bool M88kInstructionSelector::selectICmp(MachineInstr &I,
                                         MachineBasicBlock &MBB,
                                         MachineRegisterInfo &MRI) const {
  // cmp + extu
  llvm_unreachable("Not yet implemented");
  return false;
}

enum class ICC : unsigned {
  EQ = 2,  // equal
  NE = 3,  // not equal
  GT = 4,  // signed greater than
  LE = 5,  // signed less than or equal
  LT = 6,  // signed less than
  GE = 7,  // signed greater than or equal
  HI = 8,  // unsigned greater than
  LS = 9,  // unsigned less than or equal
  LO = 10, // unsigned less than
  HS = 11, // unsigned greater than or equal
  BE = 12, // any byte equal
  NB = 13, // no byte equal
  HE = 14, // any half-word equal
  NH = 15  // no half-word equal
};

static ICC getCCforICMP(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return ICC::EQ;
  case CmpInst::ICMP_NE:
    return ICC::NE;
  case CmpInst::ICMP_UGT:
    return ICC::HI;
  case CmpInst::ICMP_UGE:
    return ICC::HS;
  case CmpInst::ICMP_ULT:
    return ICC::LO;
  case CmpInst::ICMP_ULE:
    return ICC::LS;
  case CmpInst::ICMP_SGT:
    return ICC::GT;
  case CmpInst::ICMP_SGE:
    return ICC::GE;
  case CmpInst::ICMP_SLT:
    return ICC::LT;
  case CmpInst::ICMP_SLE:
    return ICC::LE;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

enum class CC0 : unsigned {
  EQ0 = 0x2,
  NE0 = 0xd,
  GT0 = 0x1,
  LT0 = 0xc,
  GE0 = 0x3,
  LE0 = 0xe
};

static CC0 getCCforBCOND(CmpInst::Predicate Pred) {
  switch (Pred) {
  case CmpInst::ICMP_EQ:
    return CC0::EQ0;
  case CmpInst::ICMP_NE:
    return CC0::NE0;
  case CmpInst::ICMP_SGT:
    return CC0::GT0;
  case CmpInst::ICMP_SGE:
    return CC0::GE0;
  case CmpInst::ICMP_SLT:
    return CC0::LT0;
  case CmpInst::ICMP_SLE:
    return CC0::LE0;
  default:
    llvm_unreachable("Unexpected predicate");
  }
}

bool M88kInstructionSelector::selectCondBr(MachineInstr &I,
                                           MachineBasicBlock &MBB,
                                           MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRCOND && "Unexpected G code");
  // Match combinations of G_BRCND and G_ICMP/G_FCMP

  // G_ICMP: $tst, $src1, $src2
  // G_BRCOND: $tst, $truebb
  MachineInstr *MI = nullptr;
  MachineOperand CC = I.getOperand(0);
  MachineOperand BB = I.getOperand(1);
  CmpInst::Predicate Pred;
  Register LHS, RHS;
  int64_t SImm16;
  if (mi_match(CC.getReg(), MRI,
               m_GICmp(m_Pred(Pred), m_Reg(LHS), m_ICst(SImm16))) &&
      isInt<16>(SImm16)) {
    if (SImm16 == 0) {
      CC0 CCCode = getCCforBCOND(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BCND))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(LHS)
               .add(BB);
    } else {
      Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
      ICC CCCode = getCCforICMP(Pred);
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPri))
               .addReg(Temp, RegState::Define)
               .addReg(LHS)
               .addImm(SImm16);
      if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
        return false;
      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
               .addImm(static_cast<int64_t>(CCCode))
               .addReg(Temp, RegState::Kill)
               .add(BB);
    }
  } else if (mi_match(CC.getReg(), MRI,
                      m_GICmp(m_Pred(Pred), m_Reg(LHS), m_Reg(RHS)))) {
    Register Temp = MRI.createVirtualRegister(&M88k::GPRRCRegClass);
    ICC CCCode = getCCforICMP(Pred);
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::CMPrr))
             .addReg(Temp, RegState::Define)
             .addReg(LHS)
             .addReg(RHS);
    if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))
      return false;
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .addImm(static_cast<int64_t>(CCCode))
             .addReg(Temp, RegState::Kill)
             .add(BB);
  } else {
    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(M88k::BB1))
             .add(I.getOperand(0))
             .addImm(0)
             .add(I.getOperand(1));
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::selectLoadStore(MachineInstr &I,
                                              MachineBasicBlock &MBB,
                                              MachineRegisterInfo &MRI) const {
  auto MMO = *I.memoperands_begin();

  // No unaligned memory access.
  if (MMO->getAlign() < MMO->getSize()) {
    return false;
  }

  // Matches:
  // - Load/Store + G_FRAME_INDEX
  // - Load/Store + G_PTRADD + constant
  // - Load/Store + G_PTRADD
  // TODO Add Load/Store + G_PTRADD + 4*value
  MachineInstr *MI = nullptr;
  MachineOperand Ptr = I.getOperand(1);
  int64_t Offset;
  MachineInstr *Base, *Addend;
  if (MachineInstr *FrameIdxMI =
          getOpcodeDef(TargetOpcode::G_FRAME_INDEX, Ptr.getReg(), MRI)) {
    const unsigned NewOpc =
        (I.getOpcode() == TargetOpcode::G_LOAD) ? M88k::LDriw : M88k::STriw;
    int FrameIdx = FrameIdxMI->getOperand(1).getIndex();

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .add(I.getOperand(0))
             .addFrameIndex(FrameIdx)
             .addImm(0)
             .addMemOperand(MMO);
  } else if (mi_match(Ptr.getReg(), MRI,
                      m_GPtrAdd(m_MInstr(Base), m_ICst(Offset))) &&
             isUInt<16>(Offset)) {

    Register AddrReg =
        Base->getOperand(Base->getOpcode() == TargetOpcode::COPY ? 1 : 0)
            .getReg();

    const unsigned NewOpc =
        (I.getOpcode() == TargetOpcode::G_LOAD) ? M88k::LDriw : M88k::STriw;

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .add(I.getOperand(0))
             .addReg(AddrReg)
             .addImm(Offset)
             .addMemOperand(MMO);
  } else if (mi_match(Ptr.getReg(), MRI,
                      m_GPtrAdd(m_MInstr(Base), m_MInstr(Addend)))) {
    Register AddrReg =
        Base->getOperand(Base->getOpcode() == TargetOpcode::COPY ? 1 : 0)
            .getReg();
    Register IndexReg =
        Base->getOperand(Addend->getOpcode() == TargetOpcode::COPY ? 1 : 0)
            .getReg();

    const unsigned NewOpc =
        (I.getOpcode() == TargetOpcode::G_LOAD) ? M88k::LDrruw : M88k::STrruw;

    MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
             .add(I.getOperand(0))
             .addReg(AddrReg)
             .addReg(IndexReg)
             .addMemOperand(MMO);
  } else
    return false;

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

bool M88kInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  // Certain non-generic instructions also need some special handling.
  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCopy(I, TII, MRI, TRI, RBI);

    return true;
  }

  if (selectImpl(I, *CoverageInfo))
    return true;

  switch (I.getOpcode()) {
  case TargetOpcode::G_BRCOND:
    return selectCondBr(I, MBB, MRI);
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE:
    return selectLoadStore(I, MBB, MRI);
  default:
    return false;
  }
}

namespace llvm {
InstructionSelector *
createM88kInstructionSelector(const M88kTargetMachine &TM,
                              const M88kSubtarget &Subtarget,
                              const M88kRegisterBankInfo &RBI) {
  return new M88kInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
