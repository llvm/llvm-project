//===- M88kInstructionSelector.cpp ------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kRegisterBankInfo.h"
#include "M88kSubtarget.h"
#include "M88kTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/Support/Debug.h"

#define DEBUG_TYPE "M88k-isel"

using namespace llvm;
using namespace MIPatternMatch;

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

namespace {

class M88kInstructionSelector : public InstructionSelector {
public:
  M88kInstructionSelector(const M88kTargetMachine &TM, const M88kSubtarget &STI,
                          const M88kRegisterBankInfo &RBI);

  bool select(MachineInstr &I) override;
  static const char *getName() { return DEBUG_TYPE; }

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  void renderLO16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;
  void renderHI16(MachineInstrBuilder &MIB, const MachineInstr &I,
                  int OpIdx = -1) const;

  const M88kTargetMachine &TM;
  const M88kInstrInfo &TII;
  const M88kRegisterInfo &TRI;
  const M88kRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

M88kInstructionSelector::M88kInstructionSelector(
    const M88kTargetMachine &TM, const M88kSubtarget &STI,
    const M88kRegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "M88kGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

static const TargetRegisterClass *guessRegClass(unsigned Reg,
                                                MachineRegisterInfo &MRI,
                                                const TargetRegisterInfo &TRI,
                                                const RegisterBankInfo &RBI) {
  const RegisterBank *RegBank = RBI.getRegBank(Reg, MRI, TRI);
  assert(RegBank && "Can't get reg bank for virtual register");

  const unsigned Size = MRI.getType(Reg).getSizeInBits();
  assert((RegBank->getID() == M88k::GRRegBankID ||
          RegBank->getID() == M88k::XRRegBankID) &&
         "Unsupported reg bank");

  if (RegBank->getID() == M88k::XRRegBankID)
    return &M88k::XRRCRegClass;

  if (Size == 64)
    return &M88k::GPR64RCRegClass;
  return &M88k::GPRRCRegClass;
}

static bool selectCopy(MachineInstr &I, const TargetInstrInfo &TII,
                       MachineRegisterInfo &MRI, const TargetRegisterInfo &TRI,
                       const RegisterBankInfo &RBI) {
  Register DstReg = I.getOperand(0).getReg();
  if (Register::isPhysicalRegister(DstReg))
    return true;

  const TargetRegisterClass *RC = guessRegClass(DstReg, MRI, TRI, RBI);

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its uses or its defs.
  // Copies do not have constraints.
  if (!RBI.constrainGenericRegister(DstReg, *RC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }
  return true;
}

void M88kInstructionSelector::renderLO16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val &= 0x000000000000FFFFULL;
  MIB.addImm(Val);
}

void M88kInstructionSelector::renderHI16(MachineInstrBuilder &MIB,
                                         const MachineInstr &I,
                                         int OpIdx) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && OpIdx == -1 &&
         "Expected G_CONSTANT");
  uint64_t Val = I.getOperand(1).getCImm()->getZExtValue();
  Val = (Val & 0x00000000FFFF0000ULL) >> 16;
  MIB.addImm(Val);
}

bool M88kInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  auto &MBB = *I.getParent();
  auto &MF = *MBB.getParent();
  auto &MRI = MF.getRegInfo();

  // Certain non-generic instructions also need some special handling.
  if (!isPreISelGenericOpcode(I.getOpcode())) {
    if (I.isCopy())
      return selectCopy(I, TII, MRI, TRI, RBI);

    return true;
  }

  if (selectImpl(I, *CoverageInfo))
    return true;

  MachineInstr *MI = nullptr;
  switch (I.getOpcode()) {
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE: {
    auto MMO = *I.memoperands_begin();

    // No unaligned memory access.
    if (MMO->getAlign() < MMO->getSize()) {
      return false;
    }

    // Try to fold load/store + G_PTR_ADD.

    MachineOperand Ptr = I.getOperand(1);
    int64_t Offset;
    MachineInstr *Base, *Addend;
    if (MachineInstr *FrameIdxMI =
            getOpcodeDef(TargetOpcode::G_FRAME_INDEX, Ptr.getReg(), MRI)) {
      const unsigned NewOpc =
          (I.getOpcode() == TargetOpcode::G_LOAD) ? M88k::LDriw : M88k::STriw;
      int FrameIdx = FrameIdxMI->getOperand(1).getIndex();

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .add(I.getOperand(0))
               .addFrameIndex(FrameIdx)
               .addImm(0)
               .addMemOperand(MMO);
    } else if (mi_match(Ptr.getReg(), MRI,
                        m_GPtrAdd(m_MInstr(Base), m_ICst(Offset))) &&
               isUInt<16>(Offset)) {

      Register AddrReg =
          Base->getOperand(Base->getOpcode() == TargetOpcode::COPY ? 1 : 0)
              .getReg();

      // TODO Need to consider memory size.
      const unsigned NewOpc =
          (I.getOpcode() == TargetOpcode::G_LOAD) ? M88k::LDriw : M88k::STriw;

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .add(I.getOperand(0))
               .addReg(AddrReg)
               .addImm(Offset)
               .addMemOperand(MMO);
    } else if (mi_match(Ptr.getReg(), MRI,
                        m_GPtrAdd(m_MInstr(Base), m_MInstr(Addend)))) {
      Register AddrReg =
          Base->getOperand(Base->getOpcode() == TargetOpcode::COPY ? 1 : 0)
              .getReg();
      Register IndexReg =
          Base->getOperand(Addend->getOpcode() == TargetOpcode::COPY ? 1 : 0)
              .getReg();

      // TODO Need to consider memory size.
      const unsigned NewOpc =
          (I.getOpcode() == TargetOpcode::G_LOAD) ? M88k::LDrruw : M88k::STrruw;

      MI = BuildMI(MBB, I, I.getDebugLoc(), TII.get(NewOpc))
               .add(I.getOperand(0))
               .addReg(AddrReg)
               .addReg(IndexReg)
               .addMemOperand(MMO);
    } else {
      // TODO Should we match a load/store with immediate 0 here?
      return false;
    }
    break;
  }
  default:
    return false;
  }

  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*MI, TII, TRI, RBI);
}

namespace llvm {
InstructionSelector *
createM88kInstructionSelector(const M88kTargetMachine &TM,
                              const M88kSubtarget &Subtarget,
                              const M88kRegisterBankInfo &RBI) {
  return new M88kInstructionSelector(TM, Subtarget, RBI);
}
} // end namespace llvm
