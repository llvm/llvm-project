//===-- M88kAsmParser.cpp - Parse M88k assembly to MCInst instructions ----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/M88kInstPrinter.h"
#include "MCTargetDesc/M88kMCTargetDesc.h"
#include "MCTargetDesc/M88kTargetStreamer.h"
#include "TargetInfo/M88kTargetInfo.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/StringSwitch.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCParser/MCAsmLexer.h"
#include "llvm/MC/MCParser/MCAsmParser.h"
#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
#include "llvm/MC/MCParser/MCTargetAsmParser.h"
#include "llvm/MC/MCStreamer.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/MC/MCSymbol.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/SMLoc.h"
#include "llvm/Support/TargetRegistry.h"
#include "llvm/Support/raw_ostream.h"
#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <memory>

using namespace llvm;

// Auto-generated by TableGen
static unsigned MatchRegisterName(StringRef Name);

namespace {

// Return true if Expr is in the range [MinValue, MaxValue].
bool inRange(const MCExpr *Expr, int64_t MinValue, int64_t MaxValue) {
  if (auto *CE = dyn_cast<MCConstantExpr>(Expr)) {
    int64_t Value = CE->getValue();
    return Value >= MinValue && Value <= MaxValue;
  }
  return false;
}

// Instances of this class represented a parsed machine instruction
class M88kOperand : public MCParsedAsmOperand {
  enum OperandKind {
    // KindInvalid,
    OpKind_Token,
    OpKind_Reg,
    OpKind_Imm,
    OpKind_Mem // Reg+Imm, Reg+Reg, Reg+(Reg<<(1,2,4,8))
  };

  OperandKind Kind;
  SMLoc StartLoc, EndLoc;

  // A string of length Length, starting at Data.
  struct TokenOp {
    const char *Data;
    unsigned Length;
  };

  struct RegOp {
    unsigned RegNo;
  };

  union {
    TokenOp Token;
    RegOp Reg;
    const MCExpr *Imm;
  };

  void addExpr(MCInst &Inst, const MCExpr *Expr) const {
    // Add as immediates when possible.  Null MCExpr = 0.
    if (!Expr)
      Inst.addOperand(MCOperand::createImm(0));
    else if (auto *CE = dyn_cast<MCConstantExpr>(Expr))
      Inst.addOperand(MCOperand::createImm(CE->getValue()));
    else
      Inst.addOperand(MCOperand::createExpr(Expr));
  }

public:
  M88kOperand(OperandKind kind, SMLoc startLoc, SMLoc endLoc)
      : Kind(kind), StartLoc(startLoc), EndLoc(endLoc) {}

  // getStartLoc - Gets location of the first token of this operand
  SMLoc getStartLoc() const override { return StartLoc; }

  // getEndLoc - Gets location of the last token of this operand
  SMLoc getEndLoc() const override { return EndLoc; }

  bool isReg() const override { return Kind == OpKind_Reg; }

  unsigned getReg() const override {
    assert(isReg() && "Invalid type access!");
    return Reg.RegNo;
  }

  bool isImm() const override { return Kind == OpKind_Imm; }

  bool isImm(int64_t MinValue, int64_t MaxValue) const {
    return Kind == OpKind_Imm && inRange(Imm, MinValue, MaxValue);
  }

  const MCExpr *getImm() const {
    assert(isImm() && "Invalid type access!");
    return Imm;
  }

  bool isMem() const override { return Kind == OpKind_Mem; }

  bool isToken() const override { return Kind == OpKind_Token; }

  StringRef getToken() const {
    assert(isToken() && "Not a token");
    return StringRef(Token.Data, Token.Length);
  }

  static std::unique_ptr<M88kOperand> createToken(StringRef Str, SMLoc Loc) {
    auto Op = std::make_unique<M88kOperand>(OpKind_Token, Loc, Loc);
    Op->Token.Data = Str.data();
    Op->Token.Length = Str.size();
    return Op;
  }

  static std::unique_ptr<M88kOperand> createReg(unsigned Num, SMLoc StartLoc,
                                                SMLoc EndLoc) {
    auto Op = std::make_unique<M88kOperand>(OpKind_Reg, StartLoc, EndLoc);
    Op->Reg.RegNo = Num;
    return Op;
  }

  static std::unique_ptr<M88kOperand> createImm(const MCExpr *Expr,
                                                SMLoc StartLoc, SMLoc EndLoc) {
    auto Op = std::make_unique<M88kOperand>(OpKind_Imm, StartLoc, EndLoc);
    Op->Imm = Expr;
    return Op;
  }

  // Used by the TableGen code to add particular types of operand
  // to an instruction.
  void addRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands");
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

  void addImmOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands");
    addExpr(Inst, getImm());
  }

  bool isU5Imm() const { return isImm(0, 31); }
  // TODO
  bool isU5ImmO() const { return isImm(0, 31); }
  bool isU10ImmWO() const { return isImm(0, 1023); }
  bool isU16Imm() const { return isImm(0, 65535); }
  bool isS16Imm() const { return isImm(-32768, 32767); }

  void print(raw_ostream &OS) const override {
    switch (Kind) {
    case OpKind_Imm:
      OS << "Imm: " << getImm() << "\n";
      break;
    case OpKind_Token:
      OS << "Token: " << getToken() << "\n";
      break;
    case OpKind_Reg:
      OS << "Reg: %r" << /*getReg() <<*/ "\n";
      break;
    case OpKind_Mem:
      OS << "MemImm: " << /* *getMemOffset() <<*/ "\n";
      break;
    }
  }
};

class M88kAsmParser : public MCTargetAsmParser {
// Auto-generated instruction matching functions
#define GET_ASSEMBLER_HEADER
#include "M88kGenAsmMatcher.inc"

  M88kTargetStreamer &getTargetStreamer() {
    assert(getParser().getStreamer().getTargetStreamer() &&
           "m88k - asm parser does not have a target streamer");
    MCTargetStreamer &TS = *getParser().getStreamer().getTargetStreamer();
    return static_cast<M88kTargetStreamer &>(TS);
  }

  bool ParseDirective(AsmToken DirectiveID) override;
  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                        SMLoc NameLoc, OperandVector &Operands) override;
  bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) override;
  OperandMatchResultTy tryParseRegister(unsigned &RegNo, SMLoc &StartLoc,
                                        SMLoc &EndLoc) override;
  unsigned validateTargetOperandClass(MCParsedAsmOperand &Op,
                                      unsigned Kind) override;

  bool parseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc,
                     bool RestoreOnFailure);
  bool parseOperand(OperandVector &Operands, StringRef Mnemonic);

  OperandMatchResultTy parseImmWO(OperandVector &Operands);
  OperandMatchResultTy parsePCRel16(OperandVector &Operands) {
    // return parsePCRel(Operands, -(1LL << 16), (1LL << 16) - 1, false);
    return MatchOperand_ParseFail;
  }

  OperandMatchResultTy parsePCRel26(OperandVector &Operands) {
    return MatchOperand_ParseFail;
  }

  bool MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                               OperandVector &Operands, MCStreamer &Out,
                               uint64_t &ErrorInfo,
                               bool MatchingInlineAsm) override;

public:
  M88kAsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
                const MCInstrInfo &MII, const MCTargetOptions &Options)
      : MCTargetAsmParser(Options, STI, MII), Parser(Parser),
        Lexer(Parser.getLexer()), SubtargetInfo(STI) {
    setAvailableFeatures(
        ComputeAvailableFeatures(SubtargetInfo.getFeatureBits()));
  }

private:
  MCAsmParser &Parser;
  MCAsmLexer &Lexer;

  const MCSubtargetInfo &SubtargetInfo;
};

} // end anonymous namespace

#define GET_REGISTER_MATCHER
#define GET_SUBTARGET_FEATURE_NAME
#define GET_MATCHER_IMPLEMENTATION
#define GET_MNEMONIC_SPELL_CHECKER
#include "M88kGenAsmMatcher.inc"

unsigned M88kAsmParser::validateTargetOperandClass(MCParsedAsmOperand &AsmOp,
                                                   unsigned Kind) {
  if (Kind == MCK_GPR64RC && AsmOp.isReg()) {
    switch (AsmOp.getReg()) {
    case M88k::R0:
    case M88k::R2:
    case M88k::R4:
    case M88k::R6:
    case M88k::R8:
    case M88k::R10:
    case M88k::R12:
    case M88k::R14:
    case M88k::R16:
    case M88k::R18:
    case M88k::R20:
    case M88k::R22:
    case M88k::R24:
    case M88k::R26:
    case M88k::R28:
    case M88k::R30:
      return Match_Success;
    case M88k::R1:
    case M88k::R3:
    case M88k::R5:
    case M88k::R7:
    case M88k::R9:
    case M88k::R11:
    case M88k::R13:
    case M88k::R15:
    case M88k::R17:
    case M88k::R19:
    case M88k::R21:
    case M88k::R23:
    case M88k::R25:
    case M88k::R27:
    case M88k::R29:
    case M88k::R31:
      // TODO Add option to flag odd registers.
      return Match_Success;
    default:
      return Match_InvalidOperand;
    }
  }

  return Match_InvalidOperand;
}

bool M88kAsmParser::ParseDirective(AsmToken DirectiveID) {
  StringRef IDVal = DirectiveID.getIdentifier();

  if (IDVal == ".requires_88110") {
    MCSubtargetInfo &STI = copySTI();
    STI.setDefaultFeatures(/*CPU*/ "m88110", /*TuneCPU*/ "m88110", "");
    setAvailableFeatures(ComputeAvailableFeatures(STI.getFeatureBits()));
    getTargetStreamer().emitDirectiveRequires881100();
    return false;
  }

  return true;
}

bool M88kAsmParser::ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                                     SMLoc NameLoc, OperandVector &Operands) {
  // First operand in MCInst is instruction mnemonic.
  Operands.push_back(M88kOperand::createToken(Name, NameLoc));

  // Read the remaining operands.
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    // Read the first operand.
    if (parseOperand(Operands, Name)) {
      return true;
    }

    // Read any subsequent operands.
    while (getLexer().is(AsmToken::Comma)) {
      Parser.Lex();
      if (parseOperand(Operands, Name)) {
        return true;
      }
    }
    if (getLexer().isNot(AsmToken::EndOfStatement)) {
      SMLoc Loc = getLexer().getLoc();
      return Error(Loc, "unexpected token in argument list");
    }
  }

  // Consume the EndOfStatement.
  Parser.Lex();
  return false;
}

bool M88kAsmParser::parseOperand(OperandVector &Operands, StringRef Mnemonic) {
  // Invoke a custom associated parser.
  OperandMatchResultTy Result = MatchOperandParserImpl(Operands, Mnemonic);

  if (Result == MatchOperand_Success)
    return Result;
  if (Result == MatchOperand_ParseFail) {
    Parser.eatToEndOfStatement();
    return Result;
  }
  assert(Result == MatchOperand_NoMatch && "Unexpected match result");

  // Check if it is a register.
  if (Lexer.is(AsmToken::Percent)) {
    unsigned RegNo;
    SMLoc StartLoc, EndLoc;
    if (parseRegister(RegNo, StartLoc, EndLoc, false))
      return true;
    Operands.push_back(M88kOperand::createReg(RegNo, StartLoc, EndLoc));
    return false;
  }

  // Could be immediate or address.
  if (Lexer.is(AsmToken::Integer)) {
    SMLoc StartLoc = Parser.getTok().getLoc();
    const MCExpr *Expr;
    if (Parser.parseExpression(Expr))
      return true;
    SMLoc EndLoc = Parser.getTok().getLoc();
    Operands.push_back(M88kOperand::createImm(Expr, StartLoc, EndLoc));
    return false;
  }
  // Failure
  return true;
}

OperandMatchResultTy M88kAsmParser::parseImmWO(OperandVector &Operands) {
  // Parses operands like 5<6> and <7>.
  MCContext &Ctx = getContext();
  SMLoc StartLoc = Parser.getTok().getLoc();
  Optional<AsmToken> WidthTok;
  int64_t Width = 0, Offset;
  if (Lexer.is(AsmToken::Integer)) {
    WidthTok = Parser.getTok();
    Width = Parser.getTok().getIntVal();
    Parser.Lex();
  }
  if (Lexer.isNot(AsmToken::Less)) {
    if (WidthTok)
      Lexer.UnLex(WidthTok.getValue());
    return MatchOperand_NoMatch;
  }
  Parser.Lex();
  if (Lexer.isNot(AsmToken::Integer))
    return MatchOperand_ParseFail;
  Offset = Parser.getTok().getIntVal();
  Parser.Lex();
  if (Lexer.isNot(AsmToken::Greater))
    return MatchOperand_ParseFail;
  Parser.Lex();

  // TODO Check values.
  int64_t Val = Width << 5 | Offset;
  const MCExpr *Expr = MCConstantExpr::create(Val, Ctx);
  SMLoc EndLoc = Parser.getTok().getLoc();
  Operands.push_back(M88kOperand::createImm(Expr, StartLoc, EndLoc));

  // Announce no match.
  return MatchOperand_Success;
}

// Parses register of form %(r|x|cr|fcr)<No>.
bool M88kAsmParser::parseRegister(unsigned &RegNo, SMLoc &StartLoc,
                                  SMLoc &EndLoc, bool RestoreOnFailure) {
  StartLoc = Parser.getTok().getLoc();

  // Eat the '%' prefix.
  if (Parser.getTok().isNot(AsmToken::Percent))
    return true;
  // return Error(Parser.getTok().getLoc(), "register expected");
  const AsmToken &PercentTok = Parser.getTok();
  Parser.Lex();

  // Match the register
  if (Lexer.getKind() != AsmToken::Identifier ||
      (RegNo = MatchRegisterName(Lexer.getTok().getIdentifier())) == 0) {
    if (RestoreOnFailure)
      Lexer.UnLex(PercentTok);
    return Error(StartLoc, "invalid register");
  }

  Parser.Lex(); // Eat identifier token
  EndLoc = Parser.getTok().getLoc();
  return false;
}

bool M88kAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc,
                                  SMLoc &EndLoc) {
  return parseRegister(RegNo, StartLoc, EndLoc,
                       /*RestoreOnFailure=*/false);
}

OperandMatchResultTy M88kAsmParser::tryParseRegister(unsigned &RegNo,
                                                     SMLoc &StartLoc,
                                                     SMLoc &EndLoc) {
  bool Result = parseRegister(RegNo, StartLoc, EndLoc,
                              /*RestoreOnFailure=*/true);
  bool PendingErrors = getParser().hasPendingError();
  getParser().clearPendingErrors();
  if (PendingErrors)
    return MatchOperand_ParseFail;
  if (Result)
    return MatchOperand_NoMatch;
  return MatchOperand_Success;
}

bool M88kAsmParser::MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                                            OperandVector &Operands,
                                            MCStreamer &Out,
                                            uint64_t &ErrorInfo,
                                            bool MatchingInlineAsm) {
  MCInst Inst;
  unsigned MatchResult;
  FeatureBitset MissingFeatures;
  MatchResult = MatchInstructionImpl(Operands, Inst, ErrorInfo, MissingFeatures,
                                     MatchingInlineAsm);
  switch (MatchResult) {
  case Match_Success:
    Inst.setLoc(IdLoc);
    Out.emitInstruction(Inst, getSTI());
    return false;
  case Match_MissingFeature:
    // Currently no features are implemented.
    return Error(IdLoc, "Instruction use requires option to be enabled");
  case Match_InvalidOperand: {
    SMLoc ErrorLoc = IdLoc;
    if (ErrorInfo != ~0U) {
      if (ErrorInfo >= Operands.size())
        return Error(IdLoc, "Too few operands for instruction");

      // TODO
      // ErrorLoc = ((M88kOperand &)*Operands[ErrorInfo]).getStartLoc();
      if (ErrorLoc == SMLoc())
        ErrorLoc = IdLoc;
    }
    return Error(ErrorLoc, "Invalid operand for instruction");
  }
  case Match_MnemonicFail: {
    FeatureBitset FBS = ComputeAvailableFeatures(getSTI().getFeatureBits());
    M88kOperand &Op = static_cast<M88kOperand &>(*Operands[0]);
    std::string Suggestion = M88kMnemonicSpellCheck(Op.getToken(), FBS, 0);
    return Error(IdLoc, "invalid instruction" + Suggestion/*,
                 Op.getLocRange()*/);
  }
  }
  llvm_unreachable("Unexpected match type");
}

extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kAsmParser() {
  RegisterMCAsmParser<M88kAsmParser> x(getTheM88kTarget());
}
