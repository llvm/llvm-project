//===- NextSiliconIRFixup.cpp - IR Manipulation For NextSilicon Pass --===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===------------------------------------------------------------------===//
//
// NextSiliconIRFixup pass fixes the caller/callee ABI discrepancies
// generated by the Fortran front-end, fixes TLS variable access, and
// adds XRay instrumentation attributes to functions (if not already added).
//
//===------------------------------------------------------------------===//

#include "llvm/Transforms/Utils/NextSiliconIRFixup.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/Transforms/Utils/Cloning.h"

using namespace llvm;

#define DEBUG_TYPE "ir-fixup"

static cl::opt<bool> AddXRayAttributes(
    "nextsilicon-ir-fixup-add-xray-attrs",
    cl::desc("Add XRay instrumentation attributes if not already set"),
    cl::init(false));

static const char *TlsVarLocationPrefix = "__next_tls_var_location_";

/// Describe the action to be taken in order to fix ABI discrepancies between
/// the callee and the callsite.
struct AbiAction {
  enum class ArgIndex : int32_t { RET_VAL = -1 };

  enum class Action {
    ADD_SEXT,
    TRUNC,
    PROMOTE_SEXT,
    ADD_ZERO_PLACEHOLDER_ARG,
  };

  int32_t ArgIdx;
  Action Action;
};

/// Mapping function name to the list of actions needed to be taken in order to
/// fix the ABI mismatch between the function's signature and the (potentially)
/// offending callsite. The list is compiled by observing the output of the
/// "ns-abi-check" tool, reponsible for reporting the ABI discrepancies.
static const StringMap<SmallVector<AbiAction, 1>> AbiActionsMap = {
    {"__fenv_fegetenv", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_fesetround", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_feenableexcept", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_fesetenv", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_feraiseexcept", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_fedisableexcept", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"ieee_arithmetic_ieee_is_nanr4_", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"ieee_arithmetic_ieee_is_nanr8_", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"ieee_arithmetic_la_ieee_is_nanr8_", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"ieee_arithmetic_la_ieee_is_nanr4_", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_fesetexceptflag", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_feclearexcept", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__fenv_fesetzerodenorm", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"omp_get_team_size", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"omp_get_ancestor_thread_num", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"ieee_arithmetic_ieee_is_finiter8_", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__kmpc_global_thread_num", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__norm2_use_precise_method_", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"__norm2_i8_use_precise_method_", {{-1, AbiAction::Action::ADD_SEXT}}},
    {"f90_str_index_klen", {{-1, AbiAction::Action::TRUNC}}},
    {"f90_is_contiguous_i8", {{-1, AbiAction::Action::TRUNC}}},
    {"sbrk", {{0, AbiAction::Action::TRUNC}}},
    {"f90io_sc_ch_ldw", {{2, AbiAction::Action::TRUNC}}},
    {"f90io_ldra", {{4, AbiAction::Action::ADD_ZERO_PLACEHOLDER_ARG}}},
    {"__fort_time", {{-1, AbiAction::Action::PROMOTE_SEXT}}},
    {"f90_set_intrin_type_i8", {{1, AbiAction::Action::PROMOTE_SEXT}}},
    {"get_vlist_desc_i8", {{1, AbiAction::Action::PROMOTE_SEXT}}},
    {"__fortio_errinit03",
     {{0, AbiAction::Action::TRUNC}, {1, AbiAction::Action::TRUNC}}},
    {"local_gather_WRAPPER", {{4, AbiAction::Action::TRUNC}}},
    {"local_scatter_WRAPPER", {{4, AbiAction::Action::TRUNC}}},
    {"local_gathscat_WRAPPER", {{5, AbiAction::Action::TRUNC}}},
};

/// The address of a thread local global is not a constant, since it depends on
/// the calling thread. The llvm.threadlocal.address intrinsic returns the
/// address of the given thread local global in the calling thread. Generates a
/// wrapper function for a llvm.threadlocal.address intrinsic in order to make
/// accesses to thread_local globals work properly in the NS architecture.
/// Creates one function definition per global, as each usage of a thread_local
/// global variable needs to go through a  llvm.threadlocal.address intrinsic.
/// This function outlining is required because codegraph can otherwise not
/// properly thread local variables.
static FunctionCallee createTlsVarLocationFunction(GlobalValue &GV) {
  assert(GV.isThreadLocal());

  FunctionType *FTy = FunctionType::get(GV.getType(),
                                        /*isVarArg=*/false);
  Module *M = GV.getParent();
  LLVMContext &Ctx = M->getContext();
  /// Adding no-inline to ensure subsequent passes do not inline this function
  /// again.
  AttributeList Attrs =
      AttributeList().addFnAttribute(Ctx, Attribute::NoInline);
  FunctionCallee F = M->getOrInsertFunction(
      llvm::formatv("{0}{1}", TlsVarLocationPrefix, GV.getName()).str(), FTy,
      Attrs);

  BasicBlock *BB =
      BasicBlock::Create(Ctx, "entry", dyn_cast<Function>(F.getCallee()));
  IRBuilder<> Builder(BB);
  CallInst *TLSIntr = Builder.CreateIntrinsic(
      GV.getType(), Intrinsic::threadlocal_address, &GV);
  Builder.CreateRet(TLSIntr);
  return F;
}

static bool processGlobalValue(GlobalValue &GV) {
  if (!GV.isThreadLocal())
    return false;

  if (GV.use_empty())
    return false;

  /// Detect all users of GV to be able to detect llvm.threadlocal.address
  /// intrinsics. All accesses to thread local global variables need to go
  /// through such an intrinsic, thus it is enough to only work with these.

  FunctionCallee F;
  for (User *U : llvm::make_early_inc_range(GV.users())) {
    /// We want to detect only llvm.threadlocal.address intrinsic and replace
    /// it with wrapper function call.
    if (IntrinsicInst *I = dyn_cast<IntrinsicInst>(U)) {
      assert(I->getIntrinsicID() == Intrinsic::threadlocal_address);
      /// Make sure we generate wrapper function body only once.
      if (!F)
        F = createTlsVarLocationFunction(GV);
      CallInst *TlsVarAddr = CallInst::Create(F, "", I);
      I->replaceAllUsesWith(TlsVarAddr);
      I->eraseFromParent();
    }
  }

  return true;
}

static bool tryAddXRayAttributes(Module &M) {
  if (!AddXRayAttributes)
    return false;

  bool Changed = false;

  for (Function &F : M.functions()) {
    if (F.hasFnAttribute("function-instrument"))
      continue;
    F.addFnAttr("function-instrument", "xray-always");
    Changed = true;
  }

  return Changed;
}

/// Append an extra "zero" argument to the list of the callsite arguments.
static bool addZeroPlaceholderArg(CallBase *&CB, const AbiAction &Action,
                                  Function *Callee) {
  LLVMContext &Context = CB->getContext();
  auto *Int64Ty = Type::getInt64Ty(Context);
  auto *CSFTy = CB->getFunctionType();

  // If the callsite already has an argument at the particular index, do
  // nothing.
  if (Action.ArgIdx + 1 == static_cast<int32_t>(CSFTy->getNumParams()) &&
      CSFTy->getParamType(Action.ArgIdx) == Int64Ty)
    return false;
  assert(Action.ArgIdx == static_cast<int32_t>(CSFTy->getNumParams()));

  // Extend the callsite function type.
  std::vector<Type *> Params;
  for (uint32_t ParamIdx = 0; ParamIdx < CSFTy->getNumParams(); ++ParamIdx) {
    Params.push_back(CSFTy->getParamType(ParamIdx));
  }
  Params.push_back(Int64Ty);
  auto *NewCSFTy = FunctionType::get(CSFTy->getReturnType(), Params, false);

  // Extend the callsite argument list.
  SmallVector<Value *> Args;
  for (uint32_t ArgIdx = 0; ArgIdx < CB->arg_size(); ++ArgIdx) {
    Args.push_back(CB->getArgOperand(ArgIdx));
  }
  Args.push_back(ConstantInt::get(Int64Ty, 0));

  // Create a new call with an additional argument and replace the old one.
  auto *NewCall = CallInst::Create(
      NewCSFTy, ConstantExpr::getBitCast(Callee, NewCSFTy->getPointerTo()),
      Args);
  NewCall->setAttributes(CB->getAttributes());
  ReplaceInstWithInst(CB, NewCall);
  CB = NewCall;

  return true;
}

/// Add sign/zero extend attribute to a particular callsite argument.
static bool addExtAttr(CallBase *&CB, const AbiAction &Action,
                       Attribute::AttrKind Ext) {
  uint32_t ArgIdx =
      static_cast<AbiAction::ArgIndex>(Action.ArgIdx) ==
              AbiAction::ArgIndex::RET_VAL
          ? AttributeList::AttrIndex::ReturnIndex
          : AttributeList::AttrIndex::FirstArgIndex + Action.ArgIdx;

  if (CB->getAttributes().hasAttributeAtIndex(ArgIdx, Ext))
    return false;

  auto NewAttrs =
      CB->getAttributes().addAttributeAtIndex(CB->getContext(), ArgIdx, Ext);
  CB->setAttributes(NewAttrs);

  return true;
}

/// Promote (using sign/zero extend) or truncate a callsite argument or return
/// value.
static bool modifyArgType(CallBase *&CB, const AbiAction &Action,
                          Function *Callee) {
  auto *Int64Ty = Type::getInt64Ty(CB->getContext());
  auto *Int32Ty = Type::getInt32Ty(CB->getContext());
  auto *CSFTy = CB->getFunctionType();

  // Modify the return value of the callsite to have the correct type, and
  // extend or truncate it to match the original return value type.
  if (static_cast<AbiAction::ArgIndex>(Action.ArgIdx) ==
      AbiAction::ArgIndex::RET_VAL) {
    auto *OrigType =
        Action.Action == AbiAction::Action::PROMOTE_SEXT ? Int64Ty : Int32Ty;
    auto *NewType =
        Action.Action == AbiAction::Action::PROMOTE_SEXT ? Int32Ty : Int64Ty;

    // If the return value type is correct, do nothing.
    if (CSFTy->getReturnType() == NewType)
      return false;

    // Modify the callsite function type.
    auto *NewCSFTy = FunctionType::get(NewType, CSFTy->params(), false);
    IRBuilder<> Builder(CB);

    // Create a new call with the correct return value type.
    SmallVector<Value *> Args;
    for (uint32_t ArgIdx = 0; ArgIdx < CB->arg_size(); ++ArgIdx) {
      Args.push_back(CB->getArgOperand(ArgIdx));
    }
    auto *NewCall = Builder.CreateCall(
        NewCSFTy, ConstantExpr::getBitCast(Callee, NewCSFTy->getPointerTo()),
        Args);
    NewCall->setAttributes(CB->getAttributes());

    // Extend or truncate the new return value and replace the old call
    // instruction with the newly created ones.
    Value *NewRetVal = nullptr;
    if (Action.Action == AbiAction::Action::PROMOTE_SEXT) {
      NewRetVal = Builder.CreateSExt(NewCall, OrigType);
    } else {
      assert(Action.Action == AbiAction::Action::TRUNC);
      NewRetVal = Builder.CreateTrunc(NewCall, OrigType);
    }

    CB->replaceAllUsesWith(NewRetVal);
    CB->eraseFromParent();
    CB = NewCall;

    return true;
  }

  // Extend or truncate the callsite argument to match the callee's signature.
  assert(Action.ArgIdx < static_cast<int32_t>(CSFTy->getNumParams()));
  auto *NewTy =
      Action.Action == AbiAction::Action::PROMOTE_SEXT ? Int64Ty : Int32Ty;

  // If the argument already has the correct type, do nothing.
  if (CSFTy->getParamType(Action.ArgIdx) == NewTy)
    return false;

  // Modify the callsite function type.
  std::vector<Type *> Params;
  int32_t ParamIdx = 0;
  for (; ParamIdx < Action.ArgIdx; ++ParamIdx) {
    Params.push_back(CSFTy->getParamType(ParamIdx));
  }
  Params.push_back(NewTy);
  for (ParamIdx = ParamIdx + 1;
       ParamIdx < static_cast<int32_t>(CSFTy->getNumParams()); ++ParamIdx) {
    Params.push_back(CSFTy->getParamType(ParamIdx));
  }

  auto *NewCSFTy = FunctionType::get(CSFTy->getReturnType(), Params, false);
  CB->mutateFunctionType(NewCSFTy);
  CB->setCalledOperand(
      ConstantExpr::getBitCast(Callee, NewCSFTy->getPointerTo()));

  // Extend or truncate the callsite argument.
  IRBuilder<> Builder(CB);
  Value *NewArgValue = nullptr;
  if (Action.Action == AbiAction::Action::PROMOTE_SEXT) {
    NewArgValue = Builder.CreateSExt(CB->getArgOperand(Action.ArgIdx), NewTy);
  } else {
    assert(Action.Action == AbiAction::Action::TRUNC);
    NewArgValue = Builder.CreateTrunc(CB->getArgOperand(Action.ArgIdx), NewTy);
  }
  CB->setArgOperand(Action.ArgIdx, NewArgValue);

  return true;
}

static bool fixCallSiteAbi(CallBase *&CB) {
  Function *Callee = dyn_cast_or_null<Function>(CB->getCalledOperand());
  if (!Callee)
    return false;

  if (AbiActionsMap.count(Callee->getName()) == 0)
    return false;

  const auto &ActionsIt = AbiActionsMap.find(Callee->getName());
  assert(ActionsIt != AbiActionsMap.end());
  const auto &Actions = ActionsIt->getValue();

  bool Changed = false;
  for (const auto &Action : Actions) {
    switch (Action.Action) {
    case AbiAction::Action::ADD_ZERO_PLACEHOLDER_ARG:
      Changed |= addZeroPlaceholderArg(CB, Action, Callee);
      break;
    case AbiAction::Action::ADD_SEXT:
      Changed |= addExtAttr(CB, Action, Attribute::AttrKind::SExt);
      break;
    case AbiAction::Action::TRUNC:
    case AbiAction::Action::PROMOTE_SEXT:
      Changed |= modifyArgType(CB, Action, Callee);
      break;
    }
  }

  return Changed;
}

static bool processCallSites(Function &F) {
  bool Changed = false;

  for (auto II = inst_begin(&F), IE = inst_end(&F); II != IE;) {
    CallBase *CB = dyn_cast<CallInst>(&*II++);
    // No support for InvokeInst nor CallBrInst yet
    if (!CB)
      continue;

    Changed |= fixCallSiteAbi(CB);
  }

  return Changed;
}

static bool runImpl(Module &M) {
  bool Changed = false;

  for (Function &F : M.functions())
    Changed |= processCallSites(F);
  for (GlobalValue &GV : concat<GlobalValue>(M.globals(), M.aliases()))
    Changed |= processGlobalValue(GV);
  Changed |= tryAddXRayAttributes(M);

  return Changed;
}

PreservedAnalyses NextSiliconIRFixupPass::run(Module &M,
                                              ModuleAnalysisManager &AM) {
  if (!runImpl(M))
    return PreservedAnalyses::all();

  // Be conservative for now, optimize later if necessary
  return PreservedAnalyses::none();
}