#include "llvm/Transforms/Utils/NextSiliconSplitCallSites.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/Module.h"
#include "llvm/Pass.h"

using namespace llvm;

constexpr StringRef NextSiliconMDKind = "nextsilicon";
constexpr StringRef BranchCountKey = "branch_count";

/// Inspects the NextSilicon metadata attached to `OldTerm` and constructs an
/// updated version for `NewTerm`.
/// So far, this function only expects to see branch counts, thus it reports
/// errors for all other kinds of NextSilicon metadata it finds.
static void propagateNextSiliconMetadata(Instruction *OldTerm,
                                         Instruction *NewTerm) {
  assert(OldTerm && NewTerm && isa<BranchInst>(NewTerm) &&
         NewTerm->getNumSuccessors() == 1);
  MDNode *OldMD = OldTerm->getMetadata(NextSiliconMDKind);
  if (!OldMD)
    return;

  // Asserts and prints an error if the NextSilicon metadata contains anything
  // else than branch counts. Only branch count metadata is expected at this
  // stage.
  auto AssertAndReportError = [&]() {
    llvm::errs() << "Encountered invalid NextSilicon metadata on ";
    OldTerm->print(llvm::errs());
    llvm::errs() << "\n";
    assert(false);
  };

  auto *Name = llvm::dyn_cast<llvm::MDString>(OldMD->getOperand(0));
  if (!Name || Name->getString() == BranchCountKey ||
      OldMD->getNumOperands() < 2) {
    AssertAndReportError();
    return;
  }

  // Sum up counts.
  int64_t Sum = 0;
  for (const MDOperand &Operand : OldMD->operands().drop_front()) {
    // Skip branch count accumulation when not all of them are present.
    if (!Operand.get())
      return;
    auto *Count = mdconst::dyn_extract<ConstantInt>(Operand);
    if (!Count || Count->getBitWidth() != 64) {
      AssertAndReportError();
      return;
    }
    Sum += Count->getSExtValue();
  }
  // Build a new branch count with the summed up counts and attach it to the
  // new terminator.
  LLVMContext &Context = OldMD->getContext();
  SmallVector<llvm::Metadata *> BranchCounts;
  BranchCounts.push_back(OldMD->getOperand(0).get());
  BranchCounts.push_back(ConstantAsMetadata::get(
      ConstantInt::get(llvm::IntegerType::get(Context, /*NumBits=*/64), Sum)));
  auto *NewMD = MDNode::get(Context, BranchCounts);
  NewTerm->setMetadata(NextSiliconMDKind, NewMD);
}

/// Create synthetic basic blocks by splitting between IR callsites, before the
/// latter. Note that some direct call sites can be generated by the backend
/// (e.g. libcalls), so this doesn't fully guarantee BB-head-uniqueness.
static bool splitFunctionBasicBlocksBetweenCallSites(Function &F) {
  bool Changes = false;
  for (auto &BB : F) {
    bool CallSiteEncountered = false;
    for (Instruction &I : BB) {
      if (!isa<CallBase>(I) || isa<IntrinsicInst>(I))
        continue;

      if (CallSiteEncountered) {
        Instruction *OldTerm = BB.getTerminator();
        BB.splitBasicBlock(&I);
        Instruction *NewTerm = BB.getTerminator();
        propagateNextSiliconMetadata(OldTerm, NewTerm);
        Changes = true;
        break;
      }

      CallSiteEncountered = true;
    }
  }
  return Changes;
}

PreservedAnalyses
NextSiliconSplitCallSitesPass::run(Module &M, ModuleAnalysisManager &AM) {
  // TODO change this back to a function pass, once optnone is removed.
  bool Changes = false;
  for (Function &F : M.functions())
    Changes |= splitFunctionBasicBlocksBetweenCallSites(F);
  if (Changes)
    return PreservedAnalyses::none();
  return PreservedAnalyses::all();
}
