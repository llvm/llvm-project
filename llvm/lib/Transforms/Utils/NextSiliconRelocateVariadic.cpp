//===- NextSiliconRelocateVariadic.cpp -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===---------------------------------------------------------------------===//
//
// NextSiliconRelocateVariadic is an LLVM pass that relocates variadic
// call-sites from functions into thunks, thus making the variadic call an
// indirect call. The original call is replaces with a call to the thunk which
// has a non-variadic function signature.
//
//===---------------------------------------------------------------------===//

#include "llvm/Transforms/Utils/NextSiliconRelocateVariadic.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DIBuilder.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Value.h"
#include "llvm/InitializePasses.h"
#include "llvm/Pass.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"

using namespace llvm;

#define DEBUG_TYPE "relocate-variadic-callsites"

using ThunksMap =
    DenseMap<std::pair<FunctionType *, AttributeList>, Function *>;

// Mapping from the microtask to its boundary thunk
using BoundariesMap = DenseMap<Function *, Function *>;

static constexpr StringLiteral ThunkPrefix = "__next_variadic_callsite_thunk";
static constexpr StringLiteral BoundaryThunkPrefix = "__next_boundary_thunk";
static constexpr StringLiteral OMPInternalForkName =
    "kmp_hidden_helper_wrapper_fn";
/// Fork function names recognized for boundary wrapper.
static constexpr StringLiteral OpenMPForkPointName = "__kmpc_fork_call";
static constexpr StringLiteral OpenMPForkTeamsName = "__kmpc_fork_teams";

/// Attribute that identifies boundary functions for nextutils.
static constexpr StringLiteral BoundaryAttribute = "ns-boundary-function";

/// Mapping of function names to their index of the parallel region target
/// ('microtask') argument. The microtask argument is omitted from the boundary
/// function call and instead generated directly from the original argument.
static const StringMap<unsigned> BoundaryFunctionMap = {
    {OpenMPForkPointName, 2},
    {OpenMPForkTeamsName, 2},
};

static const StringLiteral FortranNonVariadicWhiteList[] = {
// The following file is generated by
// ./nextsilicon/scripts/gen_fortran_builtins_list.sh
#include "llvm/Transforms/Utils/FortranBuiltinsStrList.inc"
};

/// Construct non-variadic function type 'ReturnType (Args..., ReturnType
/// (*)(ArgTypes...))' So from 'printf("%d", 5)' we get 'int (const char *, int,
/// int(*)(const char *, ...)) The function pointer is placed last for better
/// code generation (avoiding extraneous argument shifting which is dictated by
/// the calling convention)
static FunctionType *getThunkFunctionTypeFromCall(CallBase &CB) {
  std::vector<Type *> ThunkParameters;
  for (auto &Arg : CB.args()) {
    ThunkParameters.push_back(Arg->getType());
  }
  ThunkParameters.push_back(CB.getFunctionType()->getPointerTo());
  return FunctionType::get(CB.getType(), ThunkParameters, /* isVarArg */ false);
}

static Function *createNonVariadicThunk(CallBase &CB, const Twine &ThunkName) {
  FunctionType *ThunkFunctionType = getThunkFunctionTypeFromCall(CB);
  Function *Thunk =
      Function::Create(ThunkFunctionType, GlobalValue::InternalLinkage,
                       ThunkName.str(), CB.getModule());
  Thunk->addFnAttr(llvm::Attribute::NoInline);

  BasicBlock *BB = BasicBlock::Create(Thunk->getContext(), "entry", Thunk);
  IRBuilder<> Builder(BB);

  Argument *LastArgument = Thunk->arg_end() - 1;
  FunctionCallee CalleeFunctionPointer =
      FunctionCallee(CB.getFunctionType(), LastArgument);
  std::vector<Value *> CalleeArguments;
  // Ignore the last argument which is the function pointer and not an actual
  // argument for the original function
  for (auto Arg = Thunk->arg_begin(); Arg != LastArgument; Arg++) {
    CalleeArguments.push_back(Arg);
  }
  CallInst *VariadicCall =
      Builder.CreateCall(CalleeFunctionPointer, CalleeArguments);
  VariadicCall->setAttributes(CB.getAttributes());

  if (VariadicCall->getType()->isVoidTy())
    Builder.CreateRetVoid();
  else
    Builder.CreateRet(VariadicCall);

  return Thunk;
}

/// Construct (non-variadic) boundary wrapper for variadic thunk of parallel
/// region creation calls (e.g. __kmpc_fork_call of OpenMP) Function return type
/// and arguments are the same as the original call, except the parallel region
/// target function pointer ('microtask' in OpenMP) which is omitted from the
/// boundary function call and taken directly from the original parallel call
/// argument (otherwise our argument handling of changing the microtask pointer
/// to function index fails)
static Function *getOrCreateBoundaryWrapper(CallBase &ThunkCall,
                                            Function *CallerFunction,
                                            Function *CalledFunction,
                                            unsigned MicrotaskIndex,
                                            FunctionType *BoundaryFunctionType,
                                            BoundariesMap &Boundaries) {
  // Prepare changed argument from the matching argument to the thunk
  Value *MicrotaskArg = ThunkCall.getArgOperand(MicrotaskIndex);
  // Strip from any cast or local-var sets (e.g. Fortran passes the
  // __kmpc_fork_call microtask argument via a local variable - we want the
  // original function ptr so we strip all of those)
  Function *Stripped = dyn_cast<Function>(MicrotaskArg->stripPointerCasts());
  if (!Stripped) {
    // For now (for __kmpc_fork_call) we expect a function pointer
    errs() << "WARNING: Microtask argument to boundary thunk call is not a "
              "function pointer. Skipping boundary thunk creation in `"
           << CallerFunction->getName() << "`\n";
    return nullptr;
  }

  auto [BoundaryIt, emplaced] = Boundaries.try_emplace(Stripped, nullptr);
  if (!emplaced)
    return BoundaryIt->second;

  Function *ThunkFn = ThunkCall.getCalledFunction();

  // bit-cast the argument back to the expected type (e.g. for __kmpc_fork_call
  // in flang-classic, it's actually i64*)
  auto *Casted = ConstantExpr::getBitCast(
      Stripped, ThunkFn->getFunctionType()->param_begin()[MicrotaskIndex]);

  Module *StrippedModule = Stripped->getParent();

  // Don't pass parent module since we want to insert the function manually;
  // however we'd like to pass the correct address space
  auto BoundaryName =
      llvm::formatv("{0}{1}", BoundaryThunkPrefix, Boundaries.size());
  Function *Boundary =
      Function::Create(BoundaryFunctionType, GlobalValue::InternalLinkage,
                       StrippedModule->getDataLayout().getProgramAddressSpace(),
                       BoundaryName.str());

  // Insert directly after the microtask to comply with debug data verifier
  StrippedModule->getFunctionList().insertAfter(Stripped->getIterator(),
                                                Boundary);

  // Boundary thunks should not be inlined.
  Boundary->addFnAttr(llvm::Attribute::NoInline);
  Boundary->addFnAttr(BoundaryAttribute);

  // Copy the parameter attributes of the variadic microtask function arguments
  // to the corresponding boundary function arguments. The variadic arguments
  // are the ones after the microtask argument of the variadic thunk function
  // except for the last argument, which is used to pass the fork function
  // pointer to the thunk function.
  FunctionType *MicrotaskFunctionType = Stripped->getFunctionType();
  unsigned NumVariadicArgs =
      ThunkFn->getFunctionType()->getNumParams() - MicrotaskIndex - 2;
  assert(MicrotaskFunctionType->getNumParams() >= NumVariadicArgs &&
         BoundaryFunctionType->getNumParams() >= NumVariadicArgs);
  for (unsigned ArgNo = 0; ArgNo < NumVariadicArgs; ++ArgNo) {
    unsigned MicrotaskArgNo =
        MicrotaskFunctionType->getNumParams() - NumVariadicArgs + ArgNo;
    unsigned BoundaryArgNo =
        BoundaryFunctionType->getNumParams() - NumVariadicArgs + ArgNo;
    assert(MicrotaskFunctionType->getParamType(MicrotaskArgNo) ==
           BoundaryFunctionType->getParamType(BoundaryArgNo));

    for (Attribute Attr :
         Stripped->getAttributes().getParamAttrs(MicrotaskArgNo))
      Boundary->addParamAttr(BoundaryArgNo, Attr);
  }

  // Propagate ns-mark function attribute from caller to microtask
  Attribute CallerMarkAttr = CallerFunction->getFnAttribute("ns-mark");
  if (CallerMarkAttr.isValid()) {
    StringRef MicrotaskMarkValue = CallerMarkAttr.getValueAsString();

    if (!MicrotaskMarkValue.empty())
      Stripped->addFnAttr("ns-mark", MicrotaskMarkValue);
  }

  // Add debug info by 'stealing' part of it from the microtask
  // The optimizer can use it to 'mask' the boundary functions behind the
  // microtask's source info, etc.
  if (DISubprogram *MicrotaskSP = Stripped->getSubprogram()) {
    DIBuilder DiBuilder(*ThunkCall.getModule(), true, MicrotaskSP->getUnit());
    std::string DebugName =
        formatv("{0}:{1}_parallel", MicrotaskSP->getFile()->getFilename(),
                MicrotaskSP->getLine());

    auto NewType = DiBuilder.createSubroutineType(
        DiBuilder.getOrCreateTypeArray(std::nullopt));

    // Changes from original (microtask) function:
    // Name - use our user-friendly "[source]:[line]_parallel" format
    // LinkageName - use original function name
    // Type - default to None since we don't use it
    // Flags: Use only FlagArtificial to pass verification, as it's a manually
    // generated function SPFlags: Use Definition flag to add a Compile Unit
    // node (to pass verification)
    DISubprogram *BoundarySP = DiBuilder.createFunction(
        MicrotaskSP->getScope(), DebugName, BoundaryName.str(),
        MicrotaskSP->getFile(), MicrotaskSP->getLine(), NewType,
        MicrotaskSP->getScopeLine(), DINode::FlagArtificial,
        DISubprogram::DISPFlags::SPFlagDefinition);
    DiBuilder.finalizeSubprogram(BoundarySP);
    Boundary->setSubprogram(BoundarySP);
    DiBuilder.finalize();
  }

  std::vector<Value *> CalleeArguments;
  BasicBlock *BB =
      BasicBlock::Create(Boundary->getContext(), "entry", Boundary);
  IRBuilder<> Builder(BB);

  for (const auto &Arg : llvm::enumerate(Boundary->args()))
    CalleeArguments.push_back(&Arg.value());

  // If the function was called with the minimal number of arguments we might
  // 'miss' this index in the above loop, so just insert it here
  CalleeArguments.insert(CalleeArguments.begin() + MicrotaskIndex, Casted);

  // Add last argument for the thunk (callee ptr) explicitly
  CalleeArguments.push_back(CalledFunction);

  CallInst *InnerThunkCall = Builder.CreateCall(ThunkFn, CalleeArguments);
  InnerThunkCall->setAttributes(ThunkCall.getAttributes());
  if (DISubprogram *BoundarySP = Boundary->getSubprogram()) {
    if (DebugLoc Loc = ThunkCall.getDebugLoc())
      InnerThunkCall->setDebugLoc(DILocation::get(
          BoundarySP->getContext(), Loc.getLine(), Loc.getCol(), BoundarySP));
  }

  if (InnerThunkCall->getType()->isVoidTy())
    Builder.CreateRetVoid();
  else
    Builder.CreateRet(InnerThunkCall);

  BoundaryIt->second = Boundary;
  return Boundary;
}

/// Outline a variadic thunk call to a separate 'boundary' wrapper function.
/// The resulting boundary function will only contain the original variadic
/// thunk call.
static void wrapInBoundaryThunk(CallBase *&ThunkCall, Function *CallerFunction,
                                Function *CalledFunction,
                                unsigned MicrotaskIndex,
                                BoundariesMap &Boundaries) {
  std::vector<Type *> BoundaryArgTypes;
  std::vector<Value *> BoundaryArguments;

  // Omit the variadic target pointer in the last argument
  User::op_range BoundaryArgRange(ThunkCall->arg_begin(),
                                  ThunkCall->arg_end() - 1);

  for (const auto &Arg : llvm::enumerate(BoundaryArgRange)) {
    // Omit the microtask argument when calling boundary wrapper
    if (Arg.index() == MicrotaskIndex)
      continue;

    BoundaryArgTypes.push_back(Arg.value()->getType());
    BoundaryArguments.push_back(Arg.value());
  }

  FunctionType *BoundaryFunctionType = FunctionType::get(
      ThunkCall->getType(), BoundaryArgTypes, /* isVarArg */ false);

  // If we don't have enough args to add our microtask the function is invalid
  if (BoundaryFunctionType->getNumParams() < MicrotaskIndex)
    return;

  // Wrap the thunk call with a boundary function
  // NOTE: It is assumed that a boundary wrapper is on a variadic thunk
  // function (i.e. the original callbase target is passed as the last
  // argument to the inner call to ThunkFn) NOTE: Boundary functions should
  // be created per-callsite, even if the signatures are the same, so unlike
  // variadic thunks they are not cached
  Function *BoundaryFn = getOrCreateBoundaryWrapper(
      *ThunkCall, CallerFunction, CalledFunction, MicrotaskIndex,
      BoundaryFunctionType, Boundaries);

  if (BoundaryFn) {
    CallInst *BoundaryCall = CallInst::Create(BoundaryFn, BoundaryArguments);
    ReplaceInstWithInst(ThunkCall, BoundaryCall);
    ThunkCall = BoundaryCall;
  }
}

/// Check if the function call needs a boundary function wrapper, and wrap the
/// function if it does. If the call is an OpenMP fork point, additional
/// OpenMP-specific handling is performed
static void handleBoundaryIfNeeded(CallBase *&ThunkCall,
                                   Function *CallerFunction,
                                   Function *CalledFunction,
                                   BoundariesMap &Boundaries) {
  if (!CalledFunction)
    return;

  // Check if boundary wrapper is required
  auto IndexIt = BoundaryFunctionMap.find(CalledFunction->getName());
  if (IndexIt == BoundaryFunctionMap.end())
    return;

  // Take the microtask argument from the call instruction
  unsigned MicrotaskIndex = IndexIt->getValue();
  Value *MicrotaskArg = ThunkCall->arg_begin()[MicrotaskIndex].get();

  // Strip from any cast or local-var sets (e.g. Fortran passes the
  // __kmpc_fork_call microtask argument via a local variable - we want the
  // original function ptr so we strip all of those)
  Function *Microtask = dyn_cast<Function>(MicrotaskArg->stripPointerCasts());
  if (!Microtask)
    return;

  // Skip internal OpenMP helper function (don't even create a boundary thunk)
  if (Microtask->getName().contains(OMPInternalForkName))
    return;

  wrapInBoundaryThunk(ThunkCall, CallerFunction, CalledFunction, MicrotaskIndex,
                      Boundaries);
}

/// Create or get a unique non-variadic thunk for that specific FunctionType
/// If it's a parallel region creation call, wrap the thunk in a boundary
/// function
static bool relocateVariadicCallSiteToThunk(CallBase *&CB, ThunksMap &Thunks,
                                            BoundariesMap &Boundaries) {

  auto ThunkKey =
      std::make_pair(getThunkFunctionTypeFromCall(*CB), CB->getAttributes());
  auto ThunkItPair = Thunks.try_emplace(ThunkKey, nullptr);

  if (ThunkItPair.second)
    ThunkItPair.first->second =
        createNonVariadicThunk(*CB, Twine(ThunkPrefix) + Twine(Thunks.size()));

  std::vector<Value *> ThunkArguments;
  ThunkArguments.insert(ThunkArguments.end(), CB->arg_begin(), CB->arg_end());
  ThunkArguments.push_back(CB->getCalledOperand());

  CallBase *ThunkCall =
      CallInst::Create(ThunkItPair.first->second, ThunkArguments);
  Function *CallerFunction = CB->getFunction();
  Function *CalledFunction = CB->getCalledFunction();

  ReplaceInstWithInst(CB, ThunkCall);
  CB = ThunkCall;

  handleBoundaryIfNeeded(ThunkCall, CallerFunction, CalledFunction, Boundaries);

  return true;
}

static bool isNonVariadicFortranBuiltin(StringRef Name) {
  return std::binary_search(std::begin(FortranNonVariadicWhiteList),
                            std::end(FortranNonVariadicWhiteList), Name);
}

/// Check if a variadic callsite doesn't actually call a variadic function
/// (either the callee isn't of variadic type, or it's a white-listed Fortran
/// function).
static bool isRedundantlyVariadicCallsite(CallBase &CB, Function *&Callee,
                                          FunctionType *&NVFTy) {
  Value *Stripped = CB.getCalledOperand()->stripPointerCastsForAliasAnalysis();
  Callee = dyn_cast<Function>(Stripped);
  if (!Callee)
    return false;

  FunctionType *CSFTy = CB.getFunctionType();
  NVFTy = FunctionType::get(CSFTy->getReturnType(), CSFTy->params(), false);

  if (!Callee->getFunctionType()->isVarArg())
    return true;

  if (isNonVariadicFortranBuiltin(Callee->getName())) {
    if (CSFTy->getNumParams() < CB.arg_size()) {
      std::string ErrMsg =
          formatv(
              "A call to a white-listed non-variadic Fortran built-in is "
              "passed too many arguments ({0} parameters vs {1} arguments). "
              "Please verify whether '{2}' is truly non-variadic and update "
              "the white-list.",
              CSFTy->getNumParams(), CB.arg_size(), Callee->getName())
              .str();
      report_fatal_error(StringRef(ErrMsg));
    }

    return true;
  }

  return false;
}

/// In case the callsite isn't actually variadic, convert it to a non-variadic
/// type.
static bool fixRedundantlyVariadicCallsite(CallBase &CB) {
  Function *Callee = nullptr;
  FunctionType *NVFTy = nullptr;
  if (!isRedundantlyVariadicCallsite(CB, Callee, NVFTy))
    return false;

  // Convert call to non-variadic
  CB.mutateFunctionType(NVFTy);
  // Cast the built-in to non-variadic and set as callee
  CB.setCalledOperand(ConstantExpr::getBitCast(Callee, NVFTy->getPointerTo()));

  return true;
}

/// Check if a variadic callsite is truly variadic, and wrap it
/// in a thunk if it is.
static bool processVariadicCallSite(CallBase *&CB, ThunksMap &Thunks,
                                    BoundariesMap &Boundaries) {
  if (fixRedundantlyVariadicCallsite(*CB))
    return true;
  if (relocateVariadicCallSiteToThunk(CB, Thunks, Boundaries))
    return true;
  return false;
}

static bool processCallSites(Function &F, ThunksMap &Thunks,
                             BoundariesMap &Boundaries) {
  bool Changed = false;

  // Do not replace variadic calls in thunks created by this function
  if (F.getName().starts_with(ThunkPrefix))
    return false;

  // Iterate variadic call-sites
  for (auto II = inst_begin(&F), IE = inst_end(&F); II != IE;) {
    CallBase *CB = dyn_cast<CallInst>(&*II++);
    // No support for InvokeInst nor CallBrInst yet
    if (!CB)
      continue;

    if (CB->getFunctionType()->isVarArg())
      Changed |= processVariadicCallSite(CB, Thunks, Boundaries);
  }

  return Changed;
}

static bool runImpl(Module &M) {
  bool Changed = false;
  // Keep a unique set of thunks per module to prevent code duplication
  ThunksMap Thunks;
  // Keep a unique mapping of boundary function to its microtask
  BoundariesMap Boundaries;
  for (Function &F : M.functions())
    Changed |= processCallSites(F, Thunks, Boundaries);

  return Changed;
}

PreservedAnalyses
NextSiliconRelocateVariadicPass::run(Module &M, ModuleAnalysisManager &AM) {
  if (!runImpl(M))
    return PreservedAnalyses::all();

  // Be conservative for now, optimize later if necessary
  return PreservedAnalyses::none();
}
