; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt --passes=loop-rotate %s -S -o - | FileCheck %s

;; Check the duplicated store and br get remapped atoms.

@glob = global i32 0

define void @test1() #0 !dbg !5 {
; CHECK-LABEL: define void @test1(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] !dbg [[DBG5:![0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [20 x i32], align 16
; CHECK-NEXT:    store i32 0, ptr @glob, align 16, !dbg [[DBG8:![0-9]+]]
; CHECK-NEXT:    br label %[[FOR_BODY:.*]], !dbg [[DBG9:![0-9]+]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_01:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[INC]] = add nsw i32 [[I_01]], 1
; CHECK-NEXT:    store i32 0, ptr [[ARRAY]], align 16
; CHECK-NEXT:    store i32 [[INC]], ptr @glob, align 16, !dbg [[DBG10:![0-9]+]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[INC]], 100, !dbg [[DBG11:![0-9]+]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY]], label %[[FOR_END:.*]], !dbg [[DBG12:![0-9]+]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    [[ARRAYIDX_LCSSA:%.*]] = phi ptr [ [[ARRAY]], %[[FOR_BODY]] ]
; CHECK-NEXT:    call void @g(ptr [[ARRAYIDX_LCSSA]])
; CHECK-NEXT:    ret void
;
entry:
  %array = alloca [20 x i32], align 16
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  store i32 %i.0, ptr @glob, align 16, !dbg !11
  %cmp = icmp slt i32 %i.0, 100, !dbg !12
  br i1 %cmp, label %for.body, label %for.end, !dbg !13

for.body:                                         ; preds = %for.cond
  %inc = add nsw i32 %i.0, 1
  store i32 0, ptr %array, align 16
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arrayidx.lcssa = phi ptr [ %array, %for.cond ]
  call void @g(ptr %arrayidx.lcssa)
  ret void
}

declare void @g(ptr)

attributes #0 = { nounwind ssp }
attributes #1 = { noduplicate }

!llvm.dbg.cu = !{!0}
!llvm.debugify = !{!2, !3}
!llvm.module.flags = !{!4}

!0 = distinct !DICompileUnit(language: DW_LANG_C, file: !1, producer: "debugify", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug)
!1 = !DIFile(filename: "test.ll", directory: "/")
!2 = !{i32 12}
!3 = !{i32 0}
!4 = !{i32 2, !"Debug Info Version", i32 3}
!5 = distinct !DISubprogram(name: "test1", linkageName: "test1", scope: null, file: !1, line: 1, type: !6, scopeLine: 1, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)
!6 = !DISubroutineType(types: !7)
!7 = !{}
!11 = !DILocation(line: 4, column: 1, scope: !5, atomGroup: 1, atomRank: 1)
!12 = !DILocation(line: 5, column: 1, scope: !5, atomGroup: 2, atomRank: 2)
!13 = !DILocation(line: 6, column: 1, scope: !5, atomGroup: 2, atomRank: 1)
;.
; CHECK: [[META0:![0-9]+]] = distinct !DICompileUnit(language: DW_LANG_C, file: [[META1:![0-9]+]], producer: "debugify", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug)
; CHECK: [[META1]] = !DIFile(filename: "test.ll", directory: {{.*}})
; CHECK: [[DBG5]] = distinct !DISubprogram(name: "test1", linkageName: "test1", scope: null, file: [[META1]], line: 1, type: [[META6:![0-9]+]], scopeLine: 1, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: [[META0]])
; CHECK: [[META6]] = !DISubroutineType(types: [[META7:![0-9]+]])
; CHECK: [[META7]] = !{}
; CHECK: [[DBG8]] = !DILocation(line: 4, column: 1, scope: [[DBG5]], atomGroup: 3, atomRank: 1)
; CHECK: [[DBG9]] = !DILocation(line: 6, column: 1, scope: [[DBG5]], atomGroup: 4, atomRank: 1)
; CHECK: [[DBG10]] = !DILocation(line: 4, column: 1, scope: [[DBG5]], atomGroup: 1, atomRank: 1)
; CHECK: [[DBG11]] = !DILocation(line: 5, column: 1, scope: [[DBG5]], atomGroup: 2, atomRank: 2)
; CHECK: [[DBG12]] = !DILocation(line: 6, column: 1, scope: [[DBG5]], atomGroup: 2, atomRank: 1)
;.
