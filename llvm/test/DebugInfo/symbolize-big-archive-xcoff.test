// Test big archive recognition and error handling in llvm-symbolizer

// Generate object files
// RUN: yaml2obj -o %t-32.o %S/Inputs/big-archive-32.yaml
// RUN: yaml2obj -o %t-64.o %S/Inputs/big-archive-64.yaml

// Create archive with same-named members using different modes
// RUN: rm -f %t.a
// RUN: cp %t-32.o %t.o
// RUN: if [ "$(uname)" = "AIX" ]; then \
          llvm-ar -X32 crv %t.a %t.o; \
        else \
          llvm-ar crv %t.a %t.o; \
        fi
// RUN: cp %t-64.o %t.o
// RUN: if [ "$(uname)" = "AIX" ]; then \
          llvm-ar -X64 rv %t.a %t.o; \
        else \
          llvm-ar qv %t.a %t.o; \
        fi


// Verify archive contains two members with same name
// RUN: if [ "$(uname)" = "AIX" ]; then \
          llvm-ar tv -X32_64 %t.a | FileCheck %s --check-prefix=CHECK-ARCHIVE; \
        else \
          llvm-ar tv %t.a | FileCheck %s --check-prefix=CHECK-ARCHIVE; \
        fi
// CHECK-ARCHIVE: {{.*}}symbolize-big-archive-xcoff.test.tmp.o{{$}}
// CHECK-ARCHIVE: {{.*}}symbolize-big-archive-xcoff.test.tmp.o{{$}}

// Test successful symbolization
// RUN: MEMBER=$(basename %t.o)
// RUN: llvm-symbolizer --default-arch=ppc --obj="%t.a($MEMBER)" 0x0 | FileCheck %s --check-prefix=CHECK-32
// RUN: llvm-symbolizer --default-arch=ppc64 --obj="%t.a($MEMBER)" 0x0 | FileCheck %s --check-prefix=CHECK-64
// RUN: llvm-symbolizer --obj="%t.a($MEMBER):ppc" 0x0 | FileCheck %s --check-prefix=CHECK-32
// RUN: llvm-symbolizer --obj="%t.a($MEMBER):ppc64" 0x0 | FileCheck %s --check-prefix=CHECK-64
// CHECK-32: foo
// CHECK-64: foo

// Test error cases
// RUN: not llvm-symbolizer --obj="%t.a(nonexistent.o)" 0x1000 2>&1 | FileCheck %s --check-prefix=CHECK-ERROR
// CHECK-ERROR: error: {{.*}}No object file for requested architecture
