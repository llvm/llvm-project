; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=dfsan -dfsan-track-origins=1 -dfsan-add-global-name-suffix=0 -S | FileCheck %s
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define float @unop(float %f) {
; CHECK-LABEL: define float @unop(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[R:%.*]] = fneg float [[F]]
; CHECK-NEXT:    store i8 [[TMP2]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP1]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret float [[R]]
;
  %r = fneg float %f
  ret float %r
}

define i1 @binop(i1 %a, i1 %b) {
; CHECK-LABEL: define i1 @binop(
; CHECK-SAME: i1 [[A:%.*]], i1 [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 1), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 2) to ptr), align 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP5:%.*]] = or i8 [[TMP4]], [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i8 [[TMP3]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 [[TMP1]], i32 [[TMP2]]
; CHECK-NEXT:    [[R:%.*]] = add i1 [[A]], [[B]]
; CHECK-NEXT:    store i8 [[TMP5]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP7]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret i1 [[R]]
;
  %r = add i1 %a, %b
  ret i1 %r
}

define i8 @castop(ptr %p) {
; CHECK-LABEL: define i8 @castop(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[R:%.*]] = ptrtoint ptr [[P]] to i8
; CHECK-NEXT:    store i8 [[TMP2]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP1]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret i8 [[R]]
;
  %r = ptrtoint ptr %p to i8
  ret i8 %r
}

define i1 @cmpop(i1 %a, i1 %b) {
; CHECK-LABEL: define i1 @cmpop(
; CHECK-SAME: i1 [[A:%.*]], i1 [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 1), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 2) to ptr), align 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP5:%.*]] = or i8 [[TMP4]], [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i8 [[TMP3]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 [[TMP1]], i32 [[TMP2]]
; CHECK-NEXT:    [[R:%.*]] = icmp eq i1 [[A]], [[B]]
; CHECK-NEXT:    store i8 [[TMP5]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP7]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret i1 [[R]]
;
  %r = icmp eq i1 %a, %b
  ret i1 %r
}

define ptr @gepop(ptr %p, i32 %a, i32 %b, i32 %c) {
; CHECK-LABEL: define ptr @gepop(
; CHECK-SAME: ptr [[P:%.*]], i32 [[A:%.*]], i32 [[B:%.*]], i32 [[C:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 3), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 2), align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 1), align 4
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP5:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 6) to ptr), align 2
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 4) to ptr), align 2
; CHECK-NEXT:    [[TMP7:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 2) to ptr), align 2
; CHECK-NEXT:    [[TMP8:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP9:%.*]] = or i8 [[TMP8]], [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = or i8 [[TMP9]], [[TMP6]]
; CHECK-NEXT:    [[TMP11:%.*]] = or i8 [[TMP10]], [[TMP5]]
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i8 [[TMP7]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = select i1 [[TMP12]], i32 [[TMP3]], i32 [[TMP4]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i8 [[TMP6]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = select i1 [[TMP14]], i32 [[TMP2]], i32 [[TMP13]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp ne i8 [[TMP5]], 0
; CHECK-NEXT:    [[TMP17:%.*]] = select i1 [[TMP16]], i32 [[TMP1]], i32 [[TMP15]]
; CHECK-NEXT:    [[E:%.*]] = getelementptr [10 x [20 x i32]], ptr [[P]], i32 [[A]], i32 [[B]], i32 [[C]]
; CHECK-NEXT:    store i8 [[TMP11]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP17]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret ptr [[E]]
;
  %e = getelementptr [10 x [20 x i32]], ptr %p, i32 %a, i32 %b, i32 %c
  ret ptr %e
}

define i32 @eeop(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: define i32 @eeop(
; CHECK-SAME: <4 x i32> [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 1), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 2) to ptr), align 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP5:%.*]] = or i8 [[TMP4]], [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i8 [[TMP3]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 [[TMP1]], i32 [[TMP2]]
; CHECK-NEXT:    [[E:%.*]] = extractelement <4 x i32> [[A]], i32 [[B]]
; CHECK-NEXT:    store i8 [[TMP5]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP7]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret i32 [[E]]
;
  %e = extractelement <4 x i32> %a, i32 %b
  ret i32 %e
}

define <4 x i32> @ieop(<4 x i32> %p, i32 %a, i32 %b) {
; CHECK-LABEL: define <4 x i32> @ieop(
; CHECK-SAME: <4 x i32> [[P:%.*]], i32 [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 2), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 1), align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 4) to ptr), align 2
; CHECK-NEXT:    [[TMP5:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 2) to ptr), align 2
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP7:%.*]] = or i8 [[TMP6]], [[TMP5]]
; CHECK-NEXT:    [[TMP8:%.*]] = or i8 [[TMP7]], [[TMP4]]
; CHECK-NEXT:    [[TMP9:%.*]] = icmp ne i8 [[TMP5]], 0
; CHECK-NEXT:    [[TMP10:%.*]] = select i1 [[TMP9]], i32 [[TMP2]], i32 [[TMP3]]
; CHECK-NEXT:    [[TMP11:%.*]] = icmp ne i8 [[TMP4]], 0
; CHECK-NEXT:    [[TMP12:%.*]] = select i1 [[TMP11]], i32 [[TMP1]], i32 [[TMP10]]
; CHECK-NEXT:    [[E:%.*]] = insertelement <4 x i32> [[P]], i32 [[A]], i32 [[B]]
; CHECK-NEXT:    store i8 [[TMP8]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP12]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret <4 x i32> [[E]]
;
  %e = insertelement <4 x i32> %p, i32 %a, i32 %b
  ret <4 x i32> %e
}

define <4 x i32> @svop(<4 x i32> %a, <4 x i32> %b) {
; CHECK-LABEL: define <4 x i32> @svop(
; CHECK-SAME: <4 x i32> [[A:%.*]], <4 x i32> [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 1), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 2) to ptr), align 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP5:%.*]] = or i8 [[TMP4]], [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i8 [[TMP3]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 [[TMP1]], i32 [[TMP2]]
; CHECK-NEXT:    [[E:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> [[B]], <4 x i32> <i32 0, i32 4, i32 1, i32 5>
; CHECK-NEXT:    store i8 [[TMP5]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP7]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret <4 x i32> [[E]]
;
  %e = shufflevector <4 x i32> %a, <4 x i32> %b, <4 x i32> <i32 0, i32 4, i32 1, i32 5>
  ret <4 x i32> %e
}

define i32 @evop({i32, float} %a) {
; CHECK-LABEL: define i32 @evop(
; CHECK-SAME: { i32, float } [[A:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load { i8, i8 }, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { i8, i8 } [[TMP2]], 0
; CHECK-NEXT:    [[E:%.*]] = extractvalue { i32, float } [[A]], 0
; CHECK-NEXT:    store i8 [[TMP3]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP1]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret i32 [[E]]
;
  %e = extractvalue {i32, float} %a, 0
  ret i32 %e
}

; COMM: TODO simplify the expression 4 to
; COMM: 6, if shadow-tls-alignment is updated to match shadow
define {i32, {float, float}} @ivop({i32, {float, float}} %a, {float, float} %b) {
; CHECK-LABEL: define { i32, { float, float } } @ivop(
; CHECK-SAME: { i32, { float, float } } [[A:%.*]], { float, float } [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([200 x i32], ptr @__dfsan_arg_origin_tls, i64 0, i64 1), align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr @__dfsan_arg_origin_tls, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load { i8, i8 }, ptr inttoptr (i64 add (i64 ptrtoint (ptr @__dfsan_arg_tls to i64), i64 4) to ptr), align 2
; CHECK-NEXT:    [[TMP4:%.*]] = load { i8, { i8, i8 } }, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP5:%.*]] = insertvalue { i8, { i8, i8 } } [[TMP4]], { i8, i8 } [[TMP3]], 1
; CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { i8, i8 } [[TMP3]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { i8, i8 } [[TMP3]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = or i8 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = icmp ne i8 [[TMP8]], 0
; CHECK-NEXT:    [[TMP10:%.*]] = select i1 [[TMP9]], i32 [[TMP1]], i32 [[TMP2]]
; CHECK-NEXT:    [[E:%.*]] = insertvalue { i32, { float, float } } [[A]], { float, float } [[B]], 1
; CHECK-NEXT:    store { i8, { i8, i8 } } [[TMP5]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i32 [[TMP10]], ptr @__dfsan_retval_origin_tls, align 4
; CHECK-NEXT:    ret { i32, { float, float } } [[E]]
;
  %e = insertvalue {i32, {float, float}} %a, {float, float} %b, 1
  ret {i32, {float, float}} %e
}
