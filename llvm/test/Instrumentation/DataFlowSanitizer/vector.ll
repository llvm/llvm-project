; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=dfsan -dfsan-add-global-name-suffix=0 -S | FileCheck %s
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define <4 x i4> @pass_vector(<4 x i4> %v) {
; CHECK-LABEL: define <4 x i4> @pass_vector(
; CHECK-SAME: <4 x i4> [[V:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    store i8 [[TMP1]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    ret <4 x i4> [[V]]
;
  ret <4 x i4> %v
}

define void @load_update_store_vector(ptr %p) {
; CHECK-LABEL: define void @load_update_store_vector(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = xor i64 [[TMP2]], 87960930222080
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i8, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP8:%.*]] = or i8 [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = or i8 [[TMP8]], [[TMP1]]
; CHECK-NEXT:    [[V:%.*]] = load <4 x i4>, ptr [[P]], align 2
; CHECK-NEXT:    [[E2:%.*]] = extractelement <4 x i4> [[V]], i32 2
; CHECK-NEXT:    [[V1:%.*]] = insertelement <4 x i4> [[V]], i4 [[E2]], i32 0
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 87960930222080
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, ptr [[TMP12]], i32 0
; CHECK-NEXT:    store i8 [[TMP9]], ptr [[TMP13]], align 1
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[TMP12]], i32 1
; CHECK-NEXT:    store i8 [[TMP9]], ptr [[TMP14]], align 1
; CHECK-NEXT:    store <4 x i4> [[V1]], ptr [[P]], align 2
; CHECK-NEXT:    ret void
;
  %v = load <4 x i4>, ptr %p
  %e2 = extractelement <4 x i4> %v, i32 2
  %v1 = insertelement <4 x i4> %v, i4 %e2, i32 0
  store <4 x i4> %v1, ptr %p
  ret void
}

define <4 x i1> @icmp_vector(<4 x i8> %a, <4 x i8> %b) {
; CHECK-LABEL: define <4 x i1> @icmp_vector(
; CHECK-SAME: <4 x i8> [[A:%.*]], <4 x i8> [[B:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr getelementptr (i8, ptr @__dfsan_arg_tls, i64 2), align 2
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[TMP3:%.*]] = or i8 [[TMP2]], [[TMP1]]
; CHECK-NEXT:    [[R:%.*]] = icmp eq <4 x i8> [[A]], [[B]]
; CHECK-NEXT:    store i8 [[TMP3]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    ret <4 x i1> [[R]]
;
  %r = icmp eq <4 x i8> %a, %b
  ret <4 x i1> %r
}

define <2 x i32> @const_vector() {
; CHECK-LABEL: define <2 x i32> @const_vector() {
; CHECK-NEXT:    store i8 0, ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    ret <2 x i32> <i32 42, i32 11>
;
  ret <2 x i32> < i32 42, i32 11 >
}

define <4 x i4> @call_vector(<4 x i4> %v) {
; CHECK-LABEL: define <4 x i4> @call_vector(
; CHECK-SAME: <4 x i4> [[V:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    store i8 [[TMP1]], ptr @__dfsan_arg_tls, align 2
; CHECK-NEXT:    [[R:%.*]] = call <4 x i4> @pass_vector(<4 x i4> [[V]])
; CHECK-NEXT:    [[_DFSRET:%.*]] = load i8, ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    store i8 [[_DFSRET]], ptr @__dfsan_retval_tls, align 2
; CHECK-NEXT:    ret <4 x i4> [[R]]
;
  %r = call <4 x i4> @pass_vector(<4 x i4> %v)
  ret <4 x i4> %r
}
