; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=msan -S | FileCheck %s
;
; Handled strictly (suboptimal): (none)
;
; Handled heuristically: (none)
;
; Forked from llvm/test/CodeGen/AArch64/arm64-vcmp.ll

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64--linux-android9001"

define void @fcmltz_4s(<4 x float> %a, ptr %p) nounwind sanitize_memory {
; CHECK-LABEL: define void @fcmltz_4s(
; CHECK-SAME: <4 x float> [[A:%.*]], ptr [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 16), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSPROP:%.*]] = or <4 x i32> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = trunc <4 x i32> [[_MSPROP]] to <4 x i1>
; CHECK-NEXT:    [[TEMP:%.*]] = fcmp olt <4 x float> [[A]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP1:%.*]] = sext <4 x i1> [[TMP3]] to <4 x i16>
; CHECK-NEXT:    [[TEMP2:%.*]] = sext <4 x i1> [[TEMP]] to <4 x i16>
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB4:.*]], label %[[BB5:.*]], !prof [[PROF1:![0-9]+]]
; CHECK:       [[BB4]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3:[0-9]+]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB5]]:
; CHECK-NEXT:    [[TMP6:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP7:%.*]] = xor i64 [[TMP6]], 193514046488576
; CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
; CHECK-NEXT:    store <4 x i16> [[_MSPROP1]], ptr [[TMP8]], align 8
; CHECK-NEXT:    store <4 x i16> [[TEMP2]], ptr [[P]], align 8
; CHECK-NEXT:    ret void
;
  %temp = fcmp olt <4 x float> %a, zeroinitializer
  %temp2 = sext <4 x i1> %temp to <4 x i16>
  store <4 x i16> %temp2, ptr %p, align 8
  ret void
}

define <2 x i32> @facge_2s(<2 x float> %A, <2 x float> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <2 x i32> @facge_2s(
; CHECK-SAME: <2 x float> [[A:%.*]], <2 x float> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[_MSLD:%.*]] = load <2 x i32>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <2 x i32>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or <2 x i32> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne <2 x i32> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = sext <2 x i1> [[TMP4]] to <2 x i32>
; CHECK-NEXT:    [[TEMP3:%.*]] = call <2 x i32> @llvm.aarch64.neon.facge.v2i32.v2f32(<2 x float> [[A]], <2 x float> [[B]])
; CHECK-NEXT:    store <2 x i32> [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <2 x i32> [[TEMP3]]
;
  %temp3 = call <2 x i32> @llvm.aarch64.neon.facge.v2i32.v2f32(<2 x float> %A, <2 x float> %B)
  ret <2 x i32> %temp3
}

define <4 x i32> @facge_4s(<4 x float> %A, <4 x float> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <4 x i32> @facge_4s(
; CHECK-SAME: <4 x float> [[A:%.*]], <4 x float> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[_MSLD:%.*]] = load <4 x i32>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <4 x i32>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 16), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or <4 x i32> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne <4 x i32> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = sext <4 x i1> [[TMP4]] to <4 x i32>
; CHECK-NEXT:    [[TEMP3:%.*]] = call <4 x i32> @llvm.aarch64.neon.facge.v4i32.v4f32(<4 x float> [[A]], <4 x float> [[B]])
; CHECK-NEXT:    store <4 x i32> [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <4 x i32> [[TEMP3]]
;
  %temp3 = call <4 x i32> @llvm.aarch64.neon.facge.v4i32.v4f32(<4 x float> %A, <4 x float> %B)
  ret <4 x i32> %temp3
}

define <2 x i64> @facge_2d(<2 x double> %A, <2 x double> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <2 x i64> @facge_2d(
; CHECK-SAME: <2 x double> [[A:%.*]], <2 x double> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[_MSLD:%.*]] = load <2 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <2 x i64>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 16), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or <2 x i64> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne <2 x i64> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = sext <2 x i1> [[TMP4]] to <2 x i64>
; CHECK-NEXT:    [[TEMP3:%.*]] = call <2 x i64> @llvm.aarch64.neon.facge.v2i64.v2f64(<2 x double> [[A]], <2 x double> [[B]])
; CHECK-NEXT:    store <2 x i64> [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <2 x i64> [[TEMP3]]
;
  %temp3 = call <2 x i64> @llvm.aarch64.neon.facge.v2i64.v2f64(<2 x double> %A, <2 x double> %B)
  ret <2 x i64> %temp3
}

declare <2 x i32> @llvm.aarch64.neon.facge.v2i32.v2f32(<2 x float>, <2 x float>) nounwind readnone
declare <4 x i32> @llvm.aarch64.neon.facge.v4i32.v4f32(<4 x float>, <4 x float>) nounwind readnone
declare <2 x i64> @llvm.aarch64.neon.facge.v2i64.v2f64(<2 x double>, <2 x double>) nounwind readnone

define <2 x i32> @facgt_2s(<2 x float> %A, <2 x float> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <2 x i32> @facgt_2s(
; CHECK-SAME: <2 x float> [[A:%.*]], <2 x float> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[_MSLD:%.*]] = load <2 x i32>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <2 x i32>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or <2 x i32> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne <2 x i32> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = sext <2 x i1> [[TMP4]] to <2 x i32>
; CHECK-NEXT:    [[TEMP3:%.*]] = call <2 x i32> @llvm.aarch64.neon.facgt.v2i32.v2f32(<2 x float> [[A]], <2 x float> [[B]])
; CHECK-NEXT:    store <2 x i32> [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <2 x i32> [[TEMP3]]
;
  %temp3 = call <2 x i32> @llvm.aarch64.neon.facgt.v2i32.v2f32(<2 x float> %A, <2 x float> %B)
  ret <2 x i32> %temp3
}

define <4 x i32> @facgt_4s(<4 x float> %A, <4 x float> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <4 x i32> @facgt_4s(
; CHECK-SAME: <4 x float> [[A:%.*]], <4 x float> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[_MSLD:%.*]] = load <4 x i32>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <4 x i32>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 16), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or <4 x i32> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne <4 x i32> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = sext <4 x i1> [[TMP4]] to <4 x i32>
; CHECK-NEXT:    [[TEMP3:%.*]] = call <4 x i32> @llvm.aarch64.neon.facgt.v4i32.v4f32(<4 x float> [[A]], <4 x float> [[B]])
; CHECK-NEXT:    store <4 x i32> [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <4 x i32> [[TEMP3]]
;
  %temp3 = call <4 x i32> @llvm.aarch64.neon.facgt.v4i32.v4f32(<4 x float> %A, <4 x float> %B)
  ret <4 x i32> %temp3
}

define <2 x i64> @facgt_2d(<2 x double> %A, <2 x double> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <2 x i64> @facgt_2d(
; CHECK-SAME: <2 x double> [[A:%.*]], <2 x double> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[_MSLD:%.*]] = load <2 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <2 x i64>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 16), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or <2 x i64> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne <2 x i64> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = sext <2 x i1> [[TMP4]] to <2 x i64>
; CHECK-NEXT:    [[TEMP3:%.*]] = call <2 x i64> @llvm.aarch64.neon.facgt.v2i64.v2f64(<2 x double> [[A]], <2 x double> [[B]])
; CHECK-NEXT:    store <2 x i64> [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <2 x i64> [[TEMP3]]
;
  %temp3 = call <2 x i64> @llvm.aarch64.neon.facgt.v2i64.v2f64(<2 x double> %A, <2 x double> %B)
  ret <2 x i64> %temp3
}

declare <2 x i32> @llvm.aarch64.neon.facgt.v2i32.v2f32(<2 x float>, <2 x float>) nounwind readnone
declare <4 x i32> @llvm.aarch64.neon.facgt.v4i32.v4f32(<4 x float>, <4 x float>) nounwind readnone
declare <2 x i64> @llvm.aarch64.neon.facgt.v2i64.v2f64(<2 x double>, <2 x double>) nounwind readnone

define i32 @facge_s(float %A, float %B) nounwind sanitize_memory {
; CHECK-LABEL: define i32 @facge_s(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne i32 [[TMP3]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = sext i1 [[TMP4]] to i32
; CHECK-NEXT:    [[MASK:%.*]] = call i32 @llvm.aarch64.neon.facge.i32.f32(float [[A]], float [[B]])
; CHECK-NEXT:    store i32 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i32 [[MASK]]
;
  %mask = call i32 @llvm.aarch64.neon.facge.i32.f32(float %A, float %B)
  ret i32 %mask
}

define i64 @facge_d(double %A, double %B) nounwind sanitize_memory {
; CHECK-LABEL: define i64 @facge_d(
; CHECK-SAME: double [[A:%.*]], double [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne i64 [[TMP3]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = sext i1 [[TMP4]] to i64
; CHECK-NEXT:    [[MASK:%.*]] = call i64 @llvm.aarch64.neon.facge.i64.f64(double [[A]], double [[B]])
; CHECK-NEXT:    store i64 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 [[MASK]]
;
  %mask = call i64 @llvm.aarch64.neon.facge.i64.f64(double %A, double %B)
  ret i64 %mask
}

declare i64 @llvm.aarch64.neon.facge.i64.f64(double, double)
declare i32 @llvm.aarch64.neon.facge.i32.f32(float, float)

define i32 @facgt_s(float %A, float %B) nounwind sanitize_memory {
; CHECK-LABEL: define i32 @facgt_s(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne i32 [[TMP3]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = sext i1 [[TMP4]] to i32
; CHECK-NEXT:    [[MASK:%.*]] = call i32 @llvm.aarch64.neon.facgt.i32.f32(float [[A]], float [[B]])
; CHECK-NEXT:    store i32 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i32 [[MASK]]
;
  %mask = call i32 @llvm.aarch64.neon.facgt.i32.f32(float %A, float %B)
  ret i32 %mask
}

define i64 @facgt_d(double %A, double %B) nounwind sanitize_memory {
; CHECK-LABEL: define i64 @facgt_d(
; CHECK-SAME: double [[A:%.*]], double [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = or i64 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne i64 [[TMP3]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = sext i1 [[TMP4]] to i64
; CHECK-NEXT:    [[MASK:%.*]] = call i64 @llvm.aarch64.neon.facgt.i64.f64(double [[A]], double [[B]])
; CHECK-NEXT:    store i64 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 [[MASK]]
;
  %mask = call i64 @llvm.aarch64.neon.facgt.i64.f64(double %A, double %B)
  ret i64 %mask
}

declare i64 @llvm.aarch64.neon.facgt.i64.f64(double, double)
declare i32 @llvm.aarch64.neon.facgt.i32.f32(float, float)

define <8 x i8> @cmtst_8b(ptr %A, ptr %B) nounwind sanitize_memory {
; CHECK-LABEL: define <8 x i8> @cmtst_8b(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB3:.*]], label %[[BB4:.*]], !prof [[PROF1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TEMP1:%.*]] = load <8 x i8>, ptr [[A]], align 8
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 193514046488576
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[_MSLD:%.*]] = load <8 x i8>, ptr [[TMP7]], align 8
; CHECK-NEXT:    [[_MSCMP2:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP2]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[TEMP2:%.*]] = load <8 x i8>, ptr [[B]], align 8
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 193514046488576
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <8 x i8>, ptr [[TMP12]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = and <8 x i8> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP14:%.*]] = and <8 x i8> [[TEMP1]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP15:%.*]] = and <8 x i8> [[_MSLD]], [[TEMP2]]
; CHECK-NEXT:    [[TMP16:%.*]] = or <8 x i8> [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP17:%.*]] = or <8 x i8> [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[COMMONBITS:%.*]] = and <8 x i8> [[TEMP1]], [[TEMP2]]
; CHECK-NEXT:    [[TMP18:%.*]] = xor <8 x i8> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[TMP19:%.*]] = or <8 x i8> [[TMP17]], zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = icmp ne <8 x i8> [[TMP19]], zeroinitializer
; CHECK-NEXT:    [[TMP21:%.*]] = xor <8 x i8> [[TMP19]], splat (i8 -1)
; CHECK-NEXT:    [[TMP22:%.*]] = and <8 x i8> [[TMP21]], [[TMP18]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp eq <8 x i8> [[TMP22]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <8 x i1> [[TMP20]], [[TMP23]]
; CHECK-NEXT:    [[MASK:%.*]] = icmp ne <8 x i8> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <8 x i1> [[_MSPROP_ICMP]] to <8 x i8>
; CHECK-NEXT:    [[RES:%.*]] = sext <8 x i1> [[MASK]] to <8 x i8>
; CHECK-NEXT:    store <8 x i8> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <8 x i8> [[RES]]
;
  %temp1 = load <8 x i8>, ptr %A
  %temp2 = load <8 x i8>, ptr %B
  %commonbits = and <8 x i8> %temp1, %temp2
  %mask = icmp ne <8 x i8> %commonbits, zeroinitializer
  %res = sext <8 x i1> %mask to <8 x i8>
  ret <8 x i8> %res
}

define <16 x i8> @cmtst_16b(ptr %A, ptr %B) nounwind sanitize_memory {
; CHECK-LABEL: define <16 x i8> @cmtst_16b(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB3:.*]], label %[[BB4:.*]], !prof [[PROF1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TEMP1:%.*]] = load <16 x i8>, ptr [[A]], align 16
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 193514046488576
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[_MSLD:%.*]] = load <16 x i8>, ptr [[TMP7]], align 16
; CHECK-NEXT:    [[_MSCMP2:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP2]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[TEMP2:%.*]] = load <16 x i8>, ptr [[B]], align 16
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 193514046488576
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <16 x i8>, ptr [[TMP12]], align 16
; CHECK-NEXT:    [[TMP13:%.*]] = and <16 x i8> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP14:%.*]] = and <16 x i8> [[TEMP1]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP15:%.*]] = and <16 x i8> [[_MSLD]], [[TEMP2]]
; CHECK-NEXT:    [[TMP16:%.*]] = or <16 x i8> [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP17:%.*]] = or <16 x i8> [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[COMMONBITS:%.*]] = and <16 x i8> [[TEMP1]], [[TEMP2]]
; CHECK-NEXT:    [[TMP18:%.*]] = xor <16 x i8> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[TMP19:%.*]] = or <16 x i8> [[TMP17]], zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = icmp ne <16 x i8> [[TMP19]], zeroinitializer
; CHECK-NEXT:    [[TMP21:%.*]] = xor <16 x i8> [[TMP19]], splat (i8 -1)
; CHECK-NEXT:    [[TMP22:%.*]] = and <16 x i8> [[TMP21]], [[TMP18]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp eq <16 x i8> [[TMP22]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <16 x i1> [[TMP20]], [[TMP23]]
; CHECK-NEXT:    [[MASK:%.*]] = icmp ne <16 x i8> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <16 x i1> [[_MSPROP_ICMP]] to <16 x i8>
; CHECK-NEXT:    [[RES:%.*]] = sext <16 x i1> [[MASK]] to <16 x i8>
; CHECK-NEXT:    store <16 x i8> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <16 x i8> [[RES]]
;
  %temp1 = load <16 x i8>, ptr %A
  %temp2 = load <16 x i8>, ptr %B
  %commonbits = and <16 x i8> %temp1, %temp2
  %mask = icmp ne <16 x i8> %commonbits, zeroinitializer
  %res = sext <16 x i1> %mask to <16 x i8>
  ret <16 x i8> %res
}

define <4 x i16> @cmtst_4h(ptr %A, ptr %B) nounwind sanitize_memory {
; CHECK-LABEL: define <4 x i16> @cmtst_4h(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB3:.*]], label %[[BB4:.*]], !prof [[PROF1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TEMP1:%.*]] = load <4 x i16>, ptr [[A]], align 8
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 193514046488576
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[_MSLD:%.*]] = load <4 x i16>, ptr [[TMP7]], align 8
; CHECK-NEXT:    [[_MSCMP2:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP2]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[TEMP2:%.*]] = load <4 x i16>, ptr [[B]], align 8
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 193514046488576
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <4 x i16>, ptr [[TMP12]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = and <4 x i16> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP14:%.*]] = and <4 x i16> [[TEMP1]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP15:%.*]] = and <4 x i16> [[_MSLD]], [[TEMP2]]
; CHECK-NEXT:    [[TMP16:%.*]] = or <4 x i16> [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP17:%.*]] = or <4 x i16> [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[COMMONBITS:%.*]] = and <4 x i16> [[TEMP1]], [[TEMP2]]
; CHECK-NEXT:    [[TMP18:%.*]] = xor <4 x i16> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[TMP19:%.*]] = or <4 x i16> [[TMP17]], zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = icmp ne <4 x i16> [[TMP19]], zeroinitializer
; CHECK-NEXT:    [[TMP21:%.*]] = xor <4 x i16> [[TMP19]], splat (i16 -1)
; CHECK-NEXT:    [[TMP22:%.*]] = and <4 x i16> [[TMP21]], [[TMP18]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp eq <4 x i16> [[TMP22]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <4 x i1> [[TMP20]], [[TMP23]]
; CHECK-NEXT:    [[MASK:%.*]] = icmp ne <4 x i16> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <4 x i1> [[_MSPROP_ICMP]] to <4 x i16>
; CHECK-NEXT:    [[RES:%.*]] = sext <4 x i1> [[MASK]] to <4 x i16>
; CHECK-NEXT:    store <4 x i16> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <4 x i16> [[RES]]
;
  %temp1 = load <4 x i16>, ptr %A
  %temp2 = load <4 x i16>, ptr %B
  %commonbits = and <4 x i16> %temp1, %temp2
  %mask = icmp ne <4 x i16> %commonbits, zeroinitializer
  %res = sext <4 x i1> %mask to <4 x i16>
  ret <4 x i16> %res
}

define <8 x i16> @cmtst_8h(ptr %A, ptr %B) nounwind sanitize_memory {
; CHECK-LABEL: define <8 x i16> @cmtst_8h(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB3:.*]], label %[[BB4:.*]], !prof [[PROF1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TEMP1:%.*]] = load <8 x i16>, ptr [[A]], align 16
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 193514046488576
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[_MSLD:%.*]] = load <8 x i16>, ptr [[TMP7]], align 16
; CHECK-NEXT:    [[_MSCMP2:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP2]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[TEMP2:%.*]] = load <8 x i16>, ptr [[B]], align 16
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 193514046488576
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <8 x i16>, ptr [[TMP12]], align 16
; CHECK-NEXT:    [[TMP13:%.*]] = and <8 x i16> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP14:%.*]] = and <8 x i16> [[TEMP1]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP15:%.*]] = and <8 x i16> [[_MSLD]], [[TEMP2]]
; CHECK-NEXT:    [[TMP16:%.*]] = or <8 x i16> [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP17:%.*]] = or <8 x i16> [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[COMMONBITS:%.*]] = and <8 x i16> [[TEMP1]], [[TEMP2]]
; CHECK-NEXT:    [[TMP18:%.*]] = xor <8 x i16> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[TMP19:%.*]] = or <8 x i16> [[TMP17]], zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = icmp ne <8 x i16> [[TMP19]], zeroinitializer
; CHECK-NEXT:    [[TMP21:%.*]] = xor <8 x i16> [[TMP19]], splat (i16 -1)
; CHECK-NEXT:    [[TMP22:%.*]] = and <8 x i16> [[TMP21]], [[TMP18]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp eq <8 x i16> [[TMP22]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <8 x i1> [[TMP20]], [[TMP23]]
; CHECK-NEXT:    [[MASK:%.*]] = icmp ne <8 x i16> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <8 x i1> [[_MSPROP_ICMP]] to <8 x i16>
; CHECK-NEXT:    [[RES:%.*]] = sext <8 x i1> [[MASK]] to <8 x i16>
; CHECK-NEXT:    store <8 x i16> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <8 x i16> [[RES]]
;
  %temp1 = load <8 x i16>, ptr %A
  %temp2 = load <8 x i16>, ptr %B
  %commonbits = and <8 x i16> %temp1, %temp2
  %mask = icmp ne <8 x i16> %commonbits, zeroinitializer
  %res = sext <8 x i1> %mask to <8 x i16>
  ret <8 x i16> %res
}

define <2 x i32> @cmtst_2s(ptr %A, ptr %B) nounwind sanitize_memory {
; CHECK-LABEL: define <2 x i32> @cmtst_2s(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB3:.*]], label %[[BB4:.*]], !prof [[PROF1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TEMP1:%.*]] = load <2 x i32>, ptr [[A]], align 8
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 193514046488576
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[_MSLD:%.*]] = load <2 x i32>, ptr [[TMP7]], align 8
; CHECK-NEXT:    [[_MSCMP2:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP2]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[TEMP2:%.*]] = load <2 x i32>, ptr [[B]], align 8
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 193514046488576
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <2 x i32>, ptr [[TMP12]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = and <2 x i32> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP14:%.*]] = and <2 x i32> [[TEMP1]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP15:%.*]] = and <2 x i32> [[_MSLD]], [[TEMP2]]
; CHECK-NEXT:    [[TMP16:%.*]] = or <2 x i32> [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP17:%.*]] = or <2 x i32> [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[COMMONBITS:%.*]] = and <2 x i32> [[TEMP1]], [[TEMP2]]
; CHECK-NEXT:    [[TMP18:%.*]] = xor <2 x i32> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[TMP19:%.*]] = or <2 x i32> [[TMP17]], zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = icmp ne <2 x i32> [[TMP19]], zeroinitializer
; CHECK-NEXT:    [[TMP21:%.*]] = xor <2 x i32> [[TMP19]], splat (i32 -1)
; CHECK-NEXT:    [[TMP22:%.*]] = and <2 x i32> [[TMP21]], [[TMP18]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp eq <2 x i32> [[TMP22]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <2 x i1> [[TMP20]], [[TMP23]]
; CHECK-NEXT:    [[MASK:%.*]] = icmp ne <2 x i32> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <2 x i1> [[_MSPROP_ICMP]] to <2 x i32>
; CHECK-NEXT:    [[RES:%.*]] = sext <2 x i1> [[MASK]] to <2 x i32>
; CHECK-NEXT:    store <2 x i32> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <2 x i32> [[RES]]
;
  %temp1 = load <2 x i32>, ptr %A
  %temp2 = load <2 x i32>, ptr %B
  %commonbits = and <2 x i32> %temp1, %temp2
  %mask = icmp ne <2 x i32> %commonbits, zeroinitializer
  %res = sext <2 x i1> %mask to <2 x i32>
  ret <2 x i32> %res
}

define <4 x i32> @cmtst_4s(ptr %A, ptr %B) nounwind sanitize_memory {
; CHECK-LABEL: define <4 x i32> @cmtst_4s(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB3:.*]], label %[[BB4:.*]], !prof [[PROF1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TEMP1:%.*]] = load <4 x i32>, ptr [[A]], align 16
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 193514046488576
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[_MSLD:%.*]] = load <4 x i32>, ptr [[TMP7]], align 16
; CHECK-NEXT:    [[_MSCMP2:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP2]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[TEMP2:%.*]] = load <4 x i32>, ptr [[B]], align 16
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 193514046488576
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <4 x i32>, ptr [[TMP12]], align 16
; CHECK-NEXT:    [[TMP13:%.*]] = and <4 x i32> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP14:%.*]] = and <4 x i32> [[TEMP1]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP15:%.*]] = and <4 x i32> [[_MSLD]], [[TEMP2]]
; CHECK-NEXT:    [[TMP16:%.*]] = or <4 x i32> [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP17:%.*]] = or <4 x i32> [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[COMMONBITS:%.*]] = and <4 x i32> [[TEMP1]], [[TEMP2]]
; CHECK-NEXT:    [[TMP18:%.*]] = xor <4 x i32> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[TMP19:%.*]] = or <4 x i32> [[TMP17]], zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = icmp ne <4 x i32> [[TMP19]], zeroinitializer
; CHECK-NEXT:    [[TMP21:%.*]] = xor <4 x i32> [[TMP19]], splat (i32 -1)
; CHECK-NEXT:    [[TMP22:%.*]] = and <4 x i32> [[TMP21]], [[TMP18]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp eq <4 x i32> [[TMP22]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <4 x i1> [[TMP20]], [[TMP23]]
; CHECK-NEXT:    [[MASK:%.*]] = icmp ne <4 x i32> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <4 x i1> [[_MSPROP_ICMP]] to <4 x i32>
; CHECK-NEXT:    [[RES:%.*]] = sext <4 x i1> [[MASK]] to <4 x i32>
; CHECK-NEXT:    store <4 x i32> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %temp1 = load <4 x i32>, ptr %A
  %temp2 = load <4 x i32>, ptr %B
  %commonbits = and <4 x i32> %temp1, %temp2
  %mask = icmp ne <4 x i32> %commonbits, zeroinitializer
  %res = sext <4 x i1> %mask to <4 x i32>
  ret <4 x i32> %res
}

define <2 x i64> @cmtst_2d(ptr %A, ptr %B) nounwind sanitize_memory {
; CHECK-LABEL: define <2 x i64> @cmtst_2d(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSCMP:%.*]] = icmp ne i64 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[_MSCMP]], label %[[BB3:.*]], label %[[BB4:.*]], !prof [[PROF1]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TEMP1:%.*]] = load <2 x i64>, ptr [[A]], align 16
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = xor i64 [[TMP5]], 193514046488576
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[_MSLD:%.*]] = load <2 x i64>, ptr [[TMP7]], align 16
; CHECK-NEXT:    [[_MSCMP2:%.*]] = icmp ne i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[_MSCMP2]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[TEMP2:%.*]] = load <2 x i64>, ptr [[B]], align 16
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = xor i64 [[TMP10]], 193514046488576
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[TMP11]] to ptr
; CHECK-NEXT:    [[_MSLD1:%.*]] = load <2 x i64>, ptr [[TMP12]], align 16
; CHECK-NEXT:    [[TMP13:%.*]] = and <2 x i64> [[_MSLD]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP14:%.*]] = and <2 x i64> [[TEMP1]], [[_MSLD1]]
; CHECK-NEXT:    [[TMP15:%.*]] = and <2 x i64> [[_MSLD]], [[TEMP2]]
; CHECK-NEXT:    [[TMP16:%.*]] = or <2 x i64> [[TMP13]], [[TMP14]]
; CHECK-NEXT:    [[TMP17:%.*]] = or <2 x i64> [[TMP16]], [[TMP15]]
; CHECK-NEXT:    [[COMMONBITS:%.*]] = and <2 x i64> [[TEMP1]], [[TEMP2]]
; CHECK-NEXT:    [[TMP18:%.*]] = xor <2 x i64> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[TMP19:%.*]] = or <2 x i64> [[TMP17]], zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = icmp ne <2 x i64> [[TMP19]], zeroinitializer
; CHECK-NEXT:    [[TMP21:%.*]] = xor <2 x i64> [[TMP19]], splat (i64 -1)
; CHECK-NEXT:    [[TMP22:%.*]] = and <2 x i64> [[TMP21]], [[TMP18]]
; CHECK-NEXT:    [[TMP23:%.*]] = icmp eq <2 x i64> [[TMP22]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <2 x i1> [[TMP20]], [[TMP23]]
; CHECK-NEXT:    [[MASK:%.*]] = icmp ne <2 x i64> [[COMMONBITS]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <2 x i1> [[_MSPROP_ICMP]] to <2 x i64>
; CHECK-NEXT:    [[RES:%.*]] = sext <2 x i1> [[MASK]] to <2 x i64>
; CHECK-NEXT:    store <2 x i64> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <2 x i64> [[RES]]
;
  %temp1 = load <2 x i64>, ptr %A
  %temp2 = load <2 x i64>, ptr %B
  %commonbits = and <2 x i64> %temp1, %temp2
  %mask = icmp ne <2 x i64> %commonbits, zeroinitializer
  %res = sext <2 x i1> %mask to <2 x i64>
  ret <2 x i64> %res
}

define <1 x i64> @fcmeq_d(<1 x double> %A, <1 x double> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <1 x i64> @fcmeq_d(
; CHECK-SAME: <1 x double> [[A:%.*]], <1 x double> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <1 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load <1 x i64>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSPROP:%.*]] = or <1 x i64> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <1 x i64> [[_MSPROP]], zeroinitializer
; CHECK-NEXT:    [[TST:%.*]] = fcmp oeq <1 x double> [[A]], [[B]]
; CHECK-NEXT:    [[_MSPROP1:%.*]] = sext <1 x i1> [[TMP3]] to <1 x i64>
; CHECK-NEXT:    [[MASK:%.*]] = sext <1 x i1> [[TST]] to <1 x i64>
; CHECK-NEXT:    store <1 x i64> [[_MSPROP1]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <1 x i64> [[MASK]]
;
  %tst = fcmp oeq <1 x double> %A, %B
  %mask = sext <1 x i1> %tst to <1 x i64>
  ret <1 x i64> %mask
}

define <1 x i64> @fcmge_d(<1 x double> %A, <1 x double> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <1 x i64> @fcmge_d(
; CHECK-SAME: <1 x double> [[A:%.*]], <1 x double> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <1 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load <1 x i64>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSPROP:%.*]] = or <1 x i64> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <1 x i64> [[_MSPROP]], zeroinitializer
; CHECK-NEXT:    [[TST:%.*]] = fcmp oge <1 x double> [[A]], [[B]]
; CHECK-NEXT:    [[_MSPROP1:%.*]] = sext <1 x i1> [[TMP3]] to <1 x i64>
; CHECK-NEXT:    [[MASK:%.*]] = sext <1 x i1> [[TST]] to <1 x i64>
; CHECK-NEXT:    store <1 x i64> [[_MSPROP1]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <1 x i64> [[MASK]]
;
  %tst = fcmp oge <1 x double> %A, %B
  %mask = sext <1 x i1> %tst to <1 x i64>
  ret <1 x i64> %mask
}

define <1 x i64> @fcmle_d(<1 x double> %A, <1 x double> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <1 x i64> @fcmle_d(
; CHECK-SAME: <1 x double> [[A:%.*]], <1 x double> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <1 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load <1 x i64>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSPROP:%.*]] = or <1 x i64> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <1 x i64> [[_MSPROP]], zeroinitializer
; CHECK-NEXT:    [[TST:%.*]] = fcmp ole <1 x double> [[A]], [[B]]
; CHECK-NEXT:    [[_MSPROP1:%.*]] = sext <1 x i1> [[TMP3]] to <1 x i64>
; CHECK-NEXT:    [[MASK:%.*]] = sext <1 x i1> [[TST]] to <1 x i64>
; CHECK-NEXT:    store <1 x i64> [[_MSPROP1]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <1 x i64> [[MASK]]
;
  %tst = fcmp ole <1 x double> %A, %B
  %mask = sext <1 x i1> %tst to <1 x i64>
  ret <1 x i64> %mask
}

define <1 x i64> @fcmgt_d(<1 x double> %A, <1 x double> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <1 x i64> @fcmgt_d(
; CHECK-SAME: <1 x double> [[A:%.*]], <1 x double> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <1 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load <1 x i64>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSPROP:%.*]] = or <1 x i64> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <1 x i64> [[_MSPROP]], zeroinitializer
; CHECK-NEXT:    [[TST:%.*]] = fcmp ogt <1 x double> [[A]], [[B]]
; CHECK-NEXT:    [[_MSPROP1:%.*]] = sext <1 x i1> [[TMP3]] to <1 x i64>
; CHECK-NEXT:    [[MASK:%.*]] = sext <1 x i1> [[TST]] to <1 x i64>
; CHECK-NEXT:    store <1 x i64> [[_MSPROP1]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <1 x i64> [[MASK]]
;
  %tst = fcmp ogt <1 x double> %A, %B
  %mask = sext <1 x i1> %tst to <1 x i64>
  ret <1 x i64> %mask
}

define <1 x i64> @fcmlt_d(<1 x double> %A, <1 x double> %B) nounwind sanitize_memory {
; CHECK-LABEL: define <1 x i64> @fcmlt_d(
; CHECK-SAME: <1 x double> [[A:%.*]], <1 x double> [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <1 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load <1 x i64>, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[_MSPROP:%.*]] = or <1 x i64> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <1 x i64> [[_MSPROP]], zeroinitializer
; CHECK-NEXT:    [[TST:%.*]] = fcmp olt <1 x double> [[A]], [[B]]
; CHECK-NEXT:    [[_MSPROP1:%.*]] = sext <1 x i1> [[TMP3]] to <1 x i64>
; CHECK-NEXT:    [[MASK:%.*]] = sext <1 x i1> [[TST]] to <1 x i64>
; CHECK-NEXT:    store <1 x i64> [[_MSPROP1]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <1 x i64> [[MASK]]
;
  %tst = fcmp olt <1 x double> %A, %B
  %mask = sext <1 x i1> %tst to <1 x i64>
  ret <1 x i64> %mask
}

define <1 x i64> @cmnez_d(<1 x i64> %A) nounwind sanitize_memory {
; CHECK-LABEL: define <1 x i64> @cmnez_d(
; CHECK-SAME: <1 x i64> [[A:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <1 x i64>, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = xor <1 x i64> [[A]], zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = or <1 x i64> [[TMP1]], zeroinitializer
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne <1 x i64> [[TMP3]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = xor <1 x i64> [[TMP3]], splat (i64 -1)
; CHECK-NEXT:    [[TMP6:%.*]] = and <1 x i64> [[TMP5]], [[TMP2]]
; CHECK-NEXT:    [[TMP7:%.*]] = icmp eq <1 x i64> [[TMP6]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and <1 x i1> [[TMP4]], [[TMP7]]
; CHECK-NEXT:    [[TST:%.*]] = icmp ne <1 x i64> [[A]], zeroinitializer
; CHECK-NEXT:    [[_MSPROP:%.*]] = sext <1 x i1> [[_MSPROP_ICMP]] to <1 x i64>
; CHECK-NEXT:    [[MASK:%.*]] = sext <1 x i1> [[TST]] to <1 x i64>
; CHECK-NEXT:    store <1 x i64> [[_MSPROP]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret <1 x i64> [[MASK]]
;
  %tst = icmp ne <1 x i64> %A, zeroinitializer
  %mask = sext <1 x i1> %tst to <1 x i64>
  ret <1 x i64> %mask
}
;.
; CHECK: [[PROF1]] = !{!"branch_weights", i32 1, i32 1048575}
;.
