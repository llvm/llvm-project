; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -S -passes=msan 2>&1 | FileCheck %s

; This test compares the instrumentation for two loosely-equivalent patterns:
; (icmp eq + br) vs. switch.
;
; (icmp eq) can have an initialized output even if the inputs are partly
; uninitialized, if a bit is initialized in both inputs but has a different
; value.
;
; If switch has a partly uninitialized input, but it is possible to rule out
; matching any of the cases, it will use the default case instead of reporting
; use-of-uninitialized memory. This is equivalent to if the switch was replaced
; by a series of (icmp eq + br).

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define i64 @switch_test(i32 %wii) sanitize_memory {
; CHECK-LABEL: define i64 @switch_test(
; CHECK-SAME: i32 [[WII:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP3:%.*]] = xor i32 [[WII]], 42
; CHECK-NEXT:    [[TMP4:%.*]] = or i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i32 [[TMP4]], 0
; CHECK-NEXT:    [[TMP6:%.*]] = xor i32 [[TMP4]], -1
; CHECK-NEXT:    [[TMP7:%.*]] = and i32 [[TMP6]], [[TMP3]]
; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[TMP7]], 0
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and i1 [[TMP5]], [[TMP8]]
; CHECK-NEXT:    [[TMP9:%.*]] = xor i32 [[WII]], 43
; CHECK-NEXT:    [[TMP10:%.*]] = or i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = icmp ne i32 [[TMP10]], 0
; CHECK-NEXT:    [[TMP12:%.*]] = xor i32 [[TMP10]], -1
; CHECK-NEXT:    [[TMP13:%.*]] = and i32 [[TMP12]], [[TMP9]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[TMP13]], 0
; CHECK-NEXT:    [[_MSPROP_ICMP1:%.*]] = and i1 [[TMP11]], [[TMP14]]
; CHECK-NEXT:    [[TMP15:%.*]] = or i1 [[_MSPROP_ICMP]], [[_MSPROP_ICMP1]]
; CHECK-NEXT:    br i1 [[TMP15]], label %[[BB2:.*]], label %[[BB3:.*]], !prof [[PROF1:![0-9]+]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3:[0-9]+]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB3]]:
; CHECK-NEXT:    switch i32 [[WII]], label %[[U:.*]] [
; CHECK-NEXT:      i32 42, label %[[SNES:.*]]
; CHECK-NEXT:      i32 43, label %[[NES:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[SNES]]:
; CHECK-NEXT:    store i64 0, ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 420
; CHECK:       [[NES]]:
; CHECK-NEXT:    store i64 0, ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 430
; CHECK:       [[U]]:
; CHECK-NEXT:    store i64 0, ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 0
;
  switch i32 %wii, label %u [
  i32 42, label %snes
  i32 43, label %nes
  ]

snes:
  ret i64 420

nes:
  ret i64 430

u:
  ret i64 0
}

define i64 @icmp_test(i32 %wii) sanitize_memory {
; CHECK-LABEL: define i64 @icmp_test(
; CHECK-SAME: i32 [[WII:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[WII]], 42
; CHECK-NEXT:    [[TMP3:%.*]] = or i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne i32 [[TMP3]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = xor i32 [[TMP3]], -1
; CHECK-NEXT:    [[TMP6:%.*]] = and i32 [[TMP5]], [[TMP2]]
; CHECK-NEXT:    [[TMP7:%.*]] = icmp eq i32 [[TMP6]], 0
; CHECK-NEXT:    [[_MSPROP_ICMP:%.*]] = and i1 [[TMP4]], [[TMP7]]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[WII]], 42
; CHECK-NEXT:    br i1 [[_MSPROP_ICMP]], label %[[BB8:.*]], label %[[BB9:.*]], !prof [[PROF1]]
; CHECK:       [[BB8]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB9]]:
; CHECK-NEXT:    br i1 [[CMP1]], label %[[SNES:.*]], label %[[ELSE:.*]]
; CHECK:       [[SNES]]:
; CHECK-NEXT:    store i64 0, ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 420
; CHECK:       [[ELSE]]:
; CHECK-NEXT:    [[TMP10:%.*]] = xor i32 [[WII]], 43
; CHECK-NEXT:    [[TMP11:%.*]] = or i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ne i32 [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = xor i32 [[TMP11]], -1
; CHECK-NEXT:    [[TMP14:%.*]] = and i32 [[TMP13]], [[TMP10]]
; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[TMP14]], 0
; CHECK-NEXT:    [[_MSPROP_ICMP1:%.*]] = and i1 [[TMP12]], [[TMP15]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[WII]], 43
; CHECK-NEXT:    br i1 [[_MSPROP_ICMP1]], label %[[BB16:.*]], label %[[BB17:.*]], !prof [[PROF1]]
; CHECK:       [[BB16]]:
; CHECK-NEXT:    call void @__msan_warning_noreturn() #[[ATTR3]]
; CHECK-NEXT:    unreachable
; CHECK:       [[BB17]]:
; CHECK-NEXT:    br i1 [[CMP2]], label %[[NES:.*]], label %[[U:.*]]
; CHECK:       [[NES]]:
; CHECK-NEXT:    store i64 0, ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 430
; CHECK:       [[U]]:
; CHECK-NEXT:    store i64 0, ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 0
;
  %cmp1 = icmp eq i32 %wii, 42
  br i1 %cmp1, label %snes, label %else

snes:
  ret i64 420

else:
  %cmp2 = icmp eq i32 %wii, 43
  br i1 %cmp2, label %nes, label %u

nes:
  ret i64 430

u:
  ret i64 0
}
;.
; CHECK: [[PROF1]] = !{!"branch_weights", i32 1, i32 1048575}
;.
