; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -msan-check-access-address=0 -S -passes=msan 2>&1 | FileCheck %s
; REQUIRES: x86-registered-target

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare i32 @llvm.x86.bmi.bzhi.32(i32, i32)
declare i32 @llvm.x86.bmi.bextr.32(i32, i32)
declare i32 @llvm.x86.bmi.pdep.32(i32, i32)
declare i32 @llvm.x86.bmi.pext.32(i32, i32)

declare i64 @llvm.x86.bmi.bzhi.64(i64, i64)
declare i64 @llvm.x86.bmi.bextr.64(i64, i64)
declare i64 @llvm.x86.bmi.pdep.64(i64, i64)
declare i64 @llvm.x86.bmi.pext.64(i64, i64)

define i32 @Test_bzhi_32(i32 %a, i32 %b) sanitize_memory {
; CHECK-LABEL: define i32 @Test_bzhi_32(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i32
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @llvm.x86.bmi.bzhi.32(i32 [[TMP1]], i32 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i32 @llvm.x86.bmi.bzhi.32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    store i32 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i32 [[C]]
;
entry:
  %c = tail call i32 @llvm.x86.bmi.bzhi.32(i32 %a, i32 %b)
  ret i32 %c
}


define i64 @Test_bzhi_64(i64 %a, i64 %b) sanitize_memory {
; CHECK-LABEL: define i64 @Test_bzhi_64(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = call i64 @llvm.x86.bmi.bzhi.64(i64 [[TMP1]], i64 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i64 @llvm.x86.bmi.bzhi.64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    store i64 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 [[C]]
;
entry:
  %c = tail call i64 @llvm.x86.bmi.bzhi.64(i64 %a, i64 %b)
  ret i64 %c
}



define i32 @Test_bextr_32(i32 %a, i32 %b) sanitize_memory {
; CHECK-LABEL: define i32 @Test_bextr_32(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i32
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @llvm.x86.bmi.bextr.32(i32 [[TMP1]], i32 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i32 @llvm.x86.bmi.bextr.32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    store i32 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i32 [[C]]
;
entry:
  %c = tail call i32 @llvm.x86.bmi.bextr.32(i32 %a, i32 %b)
  ret i32 %c
}


define i64 @Test_bextr_64(i64 %a, i64 %b) sanitize_memory {
; CHECK-LABEL: define i64 @Test_bextr_64(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = call i64 @llvm.x86.bmi.bextr.64(i64 [[TMP1]], i64 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i64 @llvm.x86.bmi.bextr.64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    store i64 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 [[C]]
;
entry:
  %c = tail call i64 @llvm.x86.bmi.bextr.64(i64 %a, i64 %b)
  ret i64 %c
}



define i32 @Test_pdep_32(i32 %a, i32 %b) sanitize_memory {
; CHECK-LABEL: define i32 @Test_pdep_32(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i32
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @llvm.x86.bmi.pdep.32(i32 [[TMP1]], i32 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i32 @llvm.x86.bmi.pdep.32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    store i32 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i32 [[C]]
;
entry:
  %c = tail call i32 @llvm.x86.bmi.pdep.32(i32 %a, i32 %b)
  ret i32 %c
}


define i64 @Test_pdep_64(i64 %a, i64 %b) sanitize_memory {
; CHECK-LABEL: define i64 @Test_pdep_64(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = call i64 @llvm.x86.bmi.pdep.64(i64 [[TMP1]], i64 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i64 @llvm.x86.bmi.pdep.64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    store i64 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 [[C]]
;
entry:
  %c = tail call i64 @llvm.x86.bmi.pdep.64(i64 %a, i64 %b)
  ret i64 %c
}


define i32 @Test_pext_32(i32 %a, i32 %b) sanitize_memory {
; CHECK-LABEL: define i32 @Test_pext_32(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i32
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @llvm.x86.bmi.pext.32(i32 [[TMP1]], i32 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i32 @llvm.x86.bmi.pext.32(i32 [[A]], i32 [[B]])
; CHECK-NEXT:    store i32 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i32 [[C]]
;
entry:
  %c = tail call i32 @llvm.x86.bmi.pext.32(i32 %a, i32 %b)
  ret i32 %c
}


define i64 @Test_pext_64(i64 %a, i64 %b) sanitize_memory {
; CHECK-LABEL: define i64 @Test_pext_64(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr getelementptr (i8, ptr @__msan_param_tls, i64 8), align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr @__msan_param_tls, align 8
; CHECK-NEXT:    call void @llvm.donothing()
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP0]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = call i64 @llvm.x86.bmi.pext.64(i64 [[TMP1]], i64 [[B]])
; CHECK-NEXT:    [[TMP5:%.*]] = or i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[C:%.*]] = tail call i64 @llvm.x86.bmi.pext.64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    store i64 [[TMP5]], ptr @__msan_retval_tls, align 8
; CHECK-NEXT:    ret i64 [[C]]
;
entry:
  %c = tail call i64 @llvm.x86.bmi.pext.64(i64 %a, i64 %b)
  ret i64 %c
}

