; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=inferattrs,alloc-token -alloc-token-mode=increment -S | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

declare ptr @malloc(i64)
declare ptr @calloc(i64, i64)
declare ptr @realloc(ptr, i64)
declare ptr @_Znwm(i64)
declare ptr @_Znam(i64)
declare void @free(ptr)
declare void @_ZdlPv(ptr)
declare i32 @foobar(i64)

; Test basic allocation call rewriting
define ptr @test_basic_rewriting() sanitize_alloc_token {
; CHECK-LABEL: define ptr @test_basic_rewriting(
; CHECK-SAME: ) #[[ATTR5:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr @__alloc_token_malloc(i64 64, i64 0)
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @__alloc_token_calloc(i64 8, i64 8, i64 1)
; CHECK-NEXT:    [[TMP2:%.*]] = call ptr @__alloc_token_realloc(ptr [[TMP0]], i64 128, i64 2)
; CHECK-NEXT:    ret ptr [[TMP2]]
;
entry:
  %ptr1 = call ptr @malloc(i64 64)
  %ptr2 = call ptr @calloc(i64 8, i64 8)
  %ptr3 = call ptr @realloc(ptr %ptr1, i64 128)
  ret ptr %ptr3
}

; Test C++ operator rewriting
define ptr @test_cpp_operators() sanitize_alloc_token {
; CHECK-LABEL: define ptr @test_cpp_operators(
; CHECK-SAME: ) #[[ATTR5]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr @__alloc_token__Znwm(i64 32, i64 3)
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @__alloc_token__Znam(i64 64, i64 4)
; CHECK-NEXT:    ret ptr [[TMP0]]
;
entry:
  %ptr1 = call ptr @_Znwm(i64 32)
  %ptr2 = call ptr @_Znam(i64 64)
  ret ptr %ptr1
}

; Functions without sanitize_alloc_token do not get instrumented
define ptr @without_attribute() {
; CHECK-LABEL: define ptr @without_attribute() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[PTR:%.*]] = call ptr @malloc(i64 16)
; CHECK-NEXT:    ret ptr [[PTR]]
;
entry:
  %ptr = call ptr @malloc(i64 16)
  ret ptr %ptr
}

; Test that free/delete are untouched
define void @test_free_untouched(ptr %ptr) sanitize_alloc_token {
; CHECK-LABEL: define void @test_free_untouched(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR5]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @free(ptr [[PTR]])
; CHECK-NEXT:    call void @_ZdlPv(ptr [[PTR]])
; CHECK-NEXT:    ret void
;
entry:
  call void @free(ptr %ptr)
  call void @_ZdlPv(ptr %ptr)
  ret void
}

; Non-allocation functions are untouched
define i32 @no_allocations(i32 %x) sanitize_alloc_token {
; CHECK-LABEL: define i32 @no_allocations(
; CHECK-SAME: i32 [[X:%.*]]) #[[ATTR5]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RESULT:%.*]] = call i32 @foobar(i64 42)
; CHECK-NEXT:    ret i32 [[RESULT]]
;
entry:
  %result = call i32 @foobar(i64 42)
  ret i32 %result
}

; Test that tail calls are preserved
define ptr @test_tail_call_preserved() sanitize_alloc_token {
; CHECK-LABEL: define ptr @test_tail_call_preserved(
; CHECK-SAME: ) #[[ATTR5]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @__alloc_token_malloc(i64 42, i64 5)
; CHECK-NEXT:    ret ptr [[TMP0]]
;
entry:
  %result = tail call ptr @malloc(i64 42)
  ret ptr %result
}
