; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; Test that CHR does not transform regions containing convergent or
; noduplicate calls.
;
; CHR (Control Height Reduction) merges multiple biased branches into a
; single speculative check, cloning the region into hot/cold paths.
; A convergent call requires a specific set of threads to be active;
; cloning the region can change which threads reach the call, breaking
; cross-thread operations. Similarly, noduplicate calls must not be
; duplicated by definition.
;
; RUN: opt < %s -passes='require<profile-summary>,function(chr)' -S | FileCheck %s

declare i32 @convergent_callee(i32, i32) #0
declare void @noduplicate_callee() #1

; Two biased branches where the first region contains a convergent call.
; CHR must not clone this region.
define void @test_chr_convergent(ptr %input, ptr %output, i32 %tid) !prof !14 {
; CHECK-LABEL: define void @test_chr_convergent(
; CHECK-SAME: ptr [[INPUT:%.*]], ptr [[OUTPUT:%.*]], i32 [[TID:%.*]]) !prof [[PROF14:![0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[GEP_IN:%.*]] = getelementptr inbounds i32, ptr [[INPUT]], i32 [[TID]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP_IN]], align 4
; CHECK-NEXT:    [[COND1:%.*]] = icmp sgt i32 [[VAL]], 0
; CHECK-NEXT:    br i1 [[COND1]], label %[[BB1:.*]], label %[[MERGE1:.*]], !prof [[PROF15:![0-9]+]]
; CHECK:       [[BB1]]:
; CHECK-NEXT:    [[LANE_IDX:%.*]] = shl i32 [[TID]], 2
; CHECK-NEXT:    [[PERM:%.*]] = call i32 @convergent_callee(i32 [[LANE_IDX]], i32 [[VAL]])
; CHECK-NEXT:    br label %[[MERGE1]]
; CHECK:       [[MERGE1]]:
; CHECK-NEXT:    [[RESULT:%.*]] = phi i32 [ [[PERM]], %[[BB1]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[COND2:%.*]] = icmp slt i32 [[VAL]], 100
; CHECK-NEXT:    br i1 [[COND2]], label %[[BB2:.*]], label %[[MERGE2:.*]], !prof [[PROF15]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    [[GEP_OUT:%.*]] = getelementptr inbounds i32, ptr [[OUTPUT]], i32 [[TID]]
; CHECK-NEXT:    store i32 [[RESULT]], ptr [[GEP_OUT]], align 4
; CHECK-NEXT:    br label %[[MERGE2]]
; CHECK:       [[MERGE2]]:
; CHECK-NEXT:    ret void
;
entry:
  %gep_in = getelementptr inbounds i32, ptr %input, i32 %tid
  %val = load i32, ptr %gep_in, align 4
  %cond1 = icmp sgt i32 %val, 0
  br i1 %cond1, label %bb1, label %merge1, !prof !15

bb1:
  %lane_idx = shl i32 %tid, 2
  %perm = call i32 @convergent_callee(i32 %lane_idx, i32 %val)
  br label %merge1

merge1:
  %result = phi i32 [ %perm, %bb1 ], [ 0, %entry ]
  %cond2 = icmp slt i32 %val, 100
  br i1 %cond2, label %bb2, label %merge2, !prof !15

bb2:
  %gep_out = getelementptr inbounds i32, ptr %output, i32 %tid
  store i32 %result, ptr %gep_out, align 4
  br label %merge2

merge2:
  ret void
}

; Same pattern but with a noduplicate call instead of convergent.
; CHR must also skip this region.
define void @test_chr_noduplicate(ptr %input, ptr %output, i32 %tid) !prof !14 {
; CHECK-LABEL: define void @test_chr_noduplicate(
; CHECK-SAME: ptr [[INPUT:%.*]], ptr [[OUTPUT:%.*]], i32 [[TID:%.*]]) !prof [[PROF14]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_IN:%.*]] = getelementptr inbounds i32, ptr [[INPUT]], i32 [[TID]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP_IN]], align 4
; CHECK-NEXT:    [[COND1:%.*]] = icmp sgt i32 [[VAL]], 0
; CHECK-NEXT:    br i1 [[COND1]], label %[[BB1:.*]], label %[[MERGE1:.*]], !prof [[PROF15]]
; CHECK:       [[BB1]]:
; CHECK-NEXT:    call void @noduplicate_callee()
; CHECK-NEXT:    br label %[[MERGE1]]
; CHECK:       [[MERGE1]]:
; CHECK-NEXT:    [[COND2:%.*]] = icmp slt i32 [[VAL]], 100
; CHECK-NEXT:    br i1 [[COND2]], label %[[BB2:.*]], label %[[MERGE2:.*]], !prof [[PROF15]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    [[GEP_OUT:%.*]] = getelementptr inbounds i32, ptr [[OUTPUT]], i32 [[TID]]
; CHECK-NEXT:    store i32 [[VAL]], ptr [[GEP_OUT]], align 4
; CHECK-NEXT:    br label %[[MERGE2]]
; CHECK:       [[MERGE2]]:
; CHECK-NEXT:    ret void
;
entry:
  %gep_in = getelementptr inbounds i32, ptr %input, i32 %tid
  %val = load i32, ptr %gep_in, align 4
  %cond1 = icmp sgt i32 %val, 0
  br i1 %cond1, label %bb1, label %merge1, !prof !15

bb1:
  call void @noduplicate_callee()
  br label %merge1

merge1:
  %cond2 = icmp slt i32 %val, 100
  br i1 %cond2, label %bb2, label %merge2, !prof !15

bb2:
  %gep_out = getelementptr inbounds i32, ptr %output, i32 %tid
  store i32 %val, ptr %gep_out, align 4
  br label %merge2

merge2:
  ret void
}

attributes #0 = { convergent nounwind willreturn memory(none) }
attributes #1 = { noduplicate nounwind }

!llvm.module.flags = !{!0}
!0 = !{i32 1, !"ProfileSummary", !1}
!1 = !{!2, !3, !4, !5, !6, !7, !8, !9}
!2 = !{!"ProfileFormat", !"InstrProf"}
!3 = !{!"TotalCount", i64 10000}
!4 = !{!"MaxCount", i64 10}
!5 = !{!"MaxInternalCount", i64 1}
!6 = !{!"MaxFunctionCount", i64 1000}
!7 = !{!"NumCounts", i64 3}
!8 = !{!"NumFunctions", i64 2}
!9 = !{!"DetailedSummary", !10}
!10 = !{!11, !12, !13}
!11 = !{i32 10000, i64 100, i32 1}
!12 = !{i32 999000, i64 100, i32 1}
!13 = !{i32 999999, i64 1, i32 2}

!14 = !{!"function_entry_count", i64 100}
!15 = !{!"branch_weights", i32 999, i32 1}
;.
; CHECK: [[PROF14]] = !{!"function_entry_count", i64 100}
; CHECK: [[PROF15]] = !{!"branch_weights", i32 999, i32 1}
;.
