; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=memcpyopt -verify-memoryssa -S | FileCheck %s

; Test that stack-move optimization works when src/dest are GEPs into allocas.

declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg)
declare void @llvm.lifetime.start.p0(ptr nocapture)
declare void @llvm.lifetime.end.p0(ptr nocapture)

declare void @use_nocapture(ptr nocapture)

; Basic test: memcpy from GEP(src) to dest alloca
; src = [16 x i8], dest = [8 x i8] align 8, copy 8 bytes
; SrcOffset(8) is a multiple of DestAlign(8), so optimization applies.
; After optimization: dest uses become src+8
define void @memcpy_src_gep_to_dest_alloca() {
; CHECK-LABEL: define void @memcpy_src_gep_to_dest_alloca() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca [16 x i8], align 8
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 8
; CHECK-NEXT:    [[SRC_GEP1:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 8
; CHECK-NEXT:    store i64 42, ptr [[SRC_GEP1]], align 4
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP1]])
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP]])
; CHECK-NEXT:    ret void
;
  %src = alloca [16 x i8], align 4
  %dest = alloca [8 x i8], align 8
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %src.gep = getelementptr inbounds i8, ptr %src, i64 8
  store i64 42, ptr %src.gep
  call void @use_nocapture(ptr nocapture %src.gep)

  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dest, ptr align 8 %src.gep, i64 8, i1 false)

  call void @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: memcpy from GEP(src) to dest alloca with different offset
; src = [12 x i8], dest = [8 x i8] align 4, copy 8 bytes from src+4
; SrcOffset(4) is a multiple of DestAlign(4), so optimization applies.
; After optimization: dest uses become src+4
define void @memcpy_src_gep_offset4_to_dest_alloca() {
; CHECK-LABEL: define void @memcpy_src_gep_offset4_to_dest_alloca() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca [12 x i8], align 4
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    [[SRC_GEP1:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    store i64 42, ptr [[SRC_GEP1]], align 4
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP1]])
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP]])
; CHECK-NEXT:    ret void
;
  %src = alloca [12 x i8], align 4
  %dest = alloca [8 x i8], align 4
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %src.gep = getelementptr inbounds i8, ptr %src, i64 4
  store i64 42, ptr %src.gep
  call void @use_nocapture(ptr nocapture %src.gep)

  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dest, ptr align 4 %src.gep, i64 8, i1 false)

  call void @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: load/store from GEP(src) to dest alloca
; src = [8 x i8], dest = [4 x i8] align 4, load/store 4 bytes from src+4
; SrcOffset(4) is a multiple of DestAlign(4), so optimization applies.
define void @load_store_src_gep_to_dest_alloca() {
; CHECK-LABEL: define void @load_store_src_gep_to_dest_alloca() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca [8 x i8], align 4
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    [[SRC_GEP1:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    store i32 42, ptr [[SRC_GEP1]], align 4
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP1]])
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP]])
; CHECK-NEXT:    ret void
;
  %src = alloca [8 x i8], align 4
  %dest = alloca [4 x i8], align 4
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %src.gep = getelementptr inbounds i8, ptr %src, i64 4
  store i32 42, ptr %src.gep
  call void @use_nocapture(ptr nocapture %src.gep)

  %val = load i32, ptr %src.gep
  store i32 %val, ptr %dest

  call void @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: both src and dest are direct allocas (no offset), same size
; This is the basic stack-move case, included here for completeness.
define void @memcpy_both_direct_allocas() {
; CHECK-LABEL: define void @memcpy_both_direct_allocas() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca [8 x i8], align 8
; CHECK-NEXT:    store i64 42, ptr [[SRC]], align 4
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC]])
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC]])
; CHECK-NEXT:    ret void
;
  %src = alloca [8 x i8], align 4
  %dest = alloca [8 x i8], align 8
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  store i64 42, ptr %src
  call void @use_nocapture(ptr nocapture %src)

  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dest, ptr align 4 %src, i64 8, i1 false)

  call void @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: both src and dest have same offset (GEP into allocas)
; src = [16 x i8] offset 8, dest = [16 x i8] offset 8, copy 8 bytes
; Copy covers offset to end for both, offsets equal so alignment preserved.
; After optimization: src alloca removed, src uses become dest+8
define void @memcpy_both_have_same_offset() {
; CHECK-LABEL: define void @memcpy_both_have_same_offset() {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [16 x i8], align 8
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds i8, ptr [[DEST]], i64 8
; CHECK-NEXT:    [[DEST_GEP:%.*]] = getelementptr inbounds i8, ptr [[DEST]], i64 8
; CHECK-NEXT:    store i64 42, ptr [[SRC_GEP]], align 4
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP]])
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[DEST_GEP]])
; CHECK-NEXT:    ret void
;
  %src = alloca [16 x i8], align 4
  %dest = alloca [16 x i8], align 8
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %src.gep = getelementptr inbounds i8, ptr %src, i64 8
  %dest.gep = getelementptr inbounds i8, ptr %dest, i64 8
  store i64 42, ptr %src.gep
  call void @use_nocapture(ptr nocapture %src.gep)

  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dest.gep, ptr align 4 %src.gep, i64 8, i1 false)

  call void @use_nocapture(ptr nocapture %dest.gep)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: copy doesn't cover entire dest alloca, but overread is undef
; src = [12 x i8] offset 4, dest = [16 x i8], copy 8 bytes
; Size(8) + SrcOffset(4) = 12 = SrcSize, so src is fully covered.
; Size(8) + DestOffset(0) = 8 != 16 = DestSize, but remaining bytes are undef.
; After optimization: src alloca removed, src uses become dest+4
define void @memcpy_partial_dest_overread_undef() {
; CHECK-LABEL: define void @memcpy_partial_dest_overread_undef() {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [16 x i8], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[DEST]], i64 4
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds i8, ptr [[DEST]], i64 4
; CHECK-NEXT:    store i64 42, ptr [[SRC_GEP]], align 4
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP]])
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[TMP1]])
; CHECK-NEXT:    ret void
;
  %src = alloca [12 x i8], align 4
  %dest = alloca [16 x i8], align 4
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %src.gep = getelementptr inbounds i8, ptr %src, i64 4
  store i64 42, ptr %src.gep
  call void @use_nocapture(ptr nocapture %src.gep)

  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dest, ptr align 4 %src.gep, i64 8, i1 false)

  call void @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Negative test: SrcOffset not a multiple of DestAlign
; src = [12 x i8] with offset 4, dest = [8 x i8] align 8
; SrcOffset(4) % DestAlign(8) = 4 != 0 -> rejected
define void @no_optimize_alignment_mismatch() {
; CHECK-LABEL: define void @no_optimize_alignment_mismatch() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca [12 x i8], align 4
; CHECK-NEXT:    [[DEST:%.*]] = alloca [8 x i8], align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[SRC]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[DEST]])
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    store i64 42, ptr [[SRC_GEP]], align 4
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[SRC_GEP]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[DEST]], ptr align 4 [[SRC_GEP]], i64 8, i1 false)
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[DEST]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[SRC]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[DEST]])
; CHECK-NEXT:    ret void
;
  %src = alloca [12 x i8], align 4
  %dest = alloca [8 x i8], align 8
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %src.gep = getelementptr inbounds i8, ptr %src, i64 4
  store i64 42, ptr %src.gep
  call void @use_nocapture(ptr nocapture %src.gep)

  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dest, ptr align 4 %src.gep, i64 8, i1 false)

  call void @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: dest is larger
define void @memcpy_dest_larger() {
; CHECK-LABEL: define void @memcpy_dest_larger() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca [16 x i8], align 4
; CHECK-NEXT:    store i64 42, ptr [[SRC]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @use_nocapture(ptr captures(none) [[SRC]])
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @use_nocapture(ptr captures(none) [[SRC]])
; CHECK-NEXT:    ret void
;
  %src = alloca i32, i64 2, align 4
  %dest = alloca [16 x i8], align 4
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  store i64 42, ptr %src
  %1 = call i32 @use_nocapture(ptr nocapture %src)

  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dest, ptr align 4 %src, i64 8, i1 false)

  %2 = call i32 @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: src needs trailing padding due to offset difference
define void @memcpy_trailing_padding_from_offset() {
; CHECK-LABEL: define void @memcpy_trailing_padding_from_offset() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca i64, align 4
; CHECK-NEXT:    [[SRC_GEP1:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    [[SRC_GEP:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 4
; CHECK-NEXT:    store i64 42, ptr [[SRC]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @use_nocapture(ptr captures(none) [[SRC_GEP]])
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @use_nocapture(ptr captures(none) [[SRC_GEP1]])
; CHECK-NEXT:    ret void
;
  %src = alloca i64, align 4
  %dest = alloca i64, align 4
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %src.gep = getelementptr inbounds i8, ptr %src, i64 4
  store i64 42, ptr %src
  %1 = call i32 @use_nocapture(ptr nocapture %src.gep)

  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dest, ptr align 4 %src.gep, i64 4, i1 false)

  %2 = call i32 @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}

; Test: src is array but dest is offset
define void @memcpy_dest_larger_with_initial_padding() {
; CHECK-LABEL: define void @memcpy_dest_larger_with_initial_padding() {
; CHECK-NEXT:    [[SRC:%.*]] = alloca i32, i64 2, align 4
; CHECK-NEXT:    [[DEST:%.*]] = alloca i64, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[SRC]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[DEST]])
; CHECK-NEXT:    [[DEST_GEP:%.*]] = getelementptr inbounds i8, ptr [[DEST]], i64 4
; CHECK-NEXT:    store i64 42, ptr [[SRC]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @use_nocapture(ptr captures(none) [[SRC]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[DEST_GEP]], ptr align 4 [[SRC]], i64 4, i1 false)
; CHECK-NEXT:    call void @use_nocapture(ptr captures(none) [[DEST]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[SRC]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[DEST]])
; CHECK-NEXT:    ret void
;
  %src = alloca i32, i64 2, align 4
  %dest = alloca i64, align 4
  call void @llvm.lifetime.start.p0(ptr %src)
  call void @llvm.lifetime.start.p0(ptr %dest)
  %dest.gep = getelementptr inbounds i8, ptr %dest, i64 4
  store i64 42, ptr %src
  %1 = call i32 @use_nocapture(ptr nocapture %src)

  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %dest.gep, ptr align 4 %src, i64 4, i1 false)

  call void @use_nocapture(ptr nocapture %dest)

  call void @llvm.lifetime.end.p0(ptr %src)
  call void @llvm.lifetime.end.p0(ptr %dest)
  ret void
}
