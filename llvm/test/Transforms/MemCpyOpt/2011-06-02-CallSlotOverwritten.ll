; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -memcpyopt -S -verify-memoryssa | FileCheck %s
; PR10067
; Make sure the call+copy isn't optimized in such a way that
; %ret ends up with the wrong value.

target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32"
target triple = "i386-apple-darwin10"

%struct1 = type { i32, i32 }
%struct2 = type { %struct1, ptr }

declare void @bar(ptr nocapture sret(%struct1) %agg.result) nounwind

define i32 @foo() nounwind {
; CHECK-LABEL: @foo(
; CHECK-NEXT:    [[X:%.*]] = alloca [[STRUCT1:%.*]], align 8
; CHECK-NEXT:    [[Y:%.*]] = alloca [[STRUCT2:%.*]], align 8
; CHECK-NEXT:    call void @bar(ptr sret(%struct1) [[X]]) [[ATTR0:#.*]]
; CHECK-NEXT:    store i32 0, ptr [[Y]], align 8
; CHECK-NEXT:    [[GEPN2:%.*]] = getelementptr inbounds [[STRUCT2]], ptr [[Y]], i32 0, i32 0, i32 1
; CHECK-NEXT:    store i32 0, ptr [[GEPN2]], align 4
; CHECK-NEXT:    [[LOAD:%.*]] = load i64, ptr [[X]], align 8
; CHECK-NEXT:    store i64 [[LOAD]], ptr [[Y]], align 8
; CHECK-NEXT:    [[RET:%.*]] = load i32, ptr [[Y]], align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
  %x = alloca %struct1, align 8
  %y = alloca %struct2, align 8
  call void @bar(ptr sret(%struct1) %x) nounwind

  store i32 0, ptr %y, align 8
  %gepn2 = getelementptr inbounds %struct2, ptr %y, i32 0, i32 0, i32 1
  store i32 0, ptr %gepn2, align 4

  %load = load i64, ptr %x, align 8
  store i64 %load, ptr %y, align 8


  %ret = load i32, ptr %y
  ret i32 %ret
}
