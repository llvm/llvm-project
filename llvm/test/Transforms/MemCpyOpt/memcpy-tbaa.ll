; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=memcpyopt,dse -S -verify-memoryssa | FileCheck %s

define void @test() local_unnamed_addr {
; CHECK-LABEL: define void @test() local_unnamed_addr {
; CHECK-NEXT:    [[TEST_ARRAY_B:%.*]] = alloca [31 x float], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr float, ptr [[TEST_ARRAY_B]], i64 1
; CHECK-NEXT:    store float 0x3E6AA51880000000, ptr [[TMP1]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr float, ptr [[TEST_ARRAY_B]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr [[TMP2]], align 4
; CHECK-NEXT:    ret void
;
  %test_array_a = alloca [31 x float], align 4
  %test_array_b = alloca [31 x float], align 4
  %1 = getelementptr float, ptr %test_array_b, i64 1
  store float 0x3E6AA51880000000, ptr %1, align 4, !tbaa !4
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 4 dereferenceable(124) %test_array_a, ptr noundef nonnull align 4 dereferenceable(124) %test_array_b, i64 124, i1 false)
  %2 = getelementptr float, ptr %test_array_a, i64 1
  %3 = load float, ptr %2, align 4, !tbaa !7
  ret void
}

%struct.Outer = type { float, double, %struct.Inner }
%struct.Inner = type { i32, float }

; Function Attrs: nounwind uwtable
define dso_local float @f() {
; CHECK-LABEL: define dso_local float @f() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TEST1:%.*]] = alloca [[STRUCT_OUTER:%.*]], align 8
; CHECK-NEXT:    [[F:%.*]] = getelementptr inbounds nuw [[STRUCT_OUTER]], ptr [[TEST1]], i32 0, i32 0
; CHECK-NEXT:    store float 0.000000e+00, ptr [[F]], align 8
; CHECK-NEXT:    [[F1:%.*]] = getelementptr inbounds nuw [[STRUCT_OUTER]], ptr [[TEST1]], i32 0, i32 0
; CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[F1]], align 8
; CHECK-NEXT:    [[ADD:%.*]] = fadd float [[TMP0]], 2.000000e+00
; CHECK-NEXT:    store float [[ADD]], ptr [[F1]], align 8
; CHECK-NEXT:    [[F2:%.*]] = getelementptr inbounds nuw [[STRUCT_OUTER]], ptr [[TEST1]], i32 0, i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[F2]], align 8
; CHECK-NEXT:    ret float [[TMP1]]
;
entry:
  %test = alloca %struct.Outer, align 8
  %test1 = alloca %struct.Outer, align 8
  %f = getelementptr inbounds nuw %struct.Outer, ptr %test1, i32 0, i32 0
  store float 0.000000e+00, ptr %f, align 8, !tbaa !9
  %inner_a = getelementptr inbounds nuw %struct.Outer, ptr %test1, i32 0, i32 2
  %i = getelementptr inbounds nuw %struct.Inner, ptr %inner_a, i32 0, i32 0
  store i32 0, ptr %i, align 8, !tbaa !17
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %test, ptr align 8 %test1, i64 24, i1 false)
  %f1 = getelementptr inbounds nuw %struct.Outer, ptr %test, i32 0, i32 0
  %0 = load float, ptr %f1, align 8, !tbaa !9
  %add = fadd float %0, 2.000000e+00
  store float %add, ptr %f1, align 8, !tbaa !9
  %f2 = getelementptr inbounds nuw %struct.Outer, ptr %test, i32 0, i32 0
  %1 = load float, ptr %f2, align 8, !tbaa !9
  ret float %1
}

!1 = !{!"any data access", !2, i64 0}
!2 = !{!"any access", !3, i64 0}
!3 = !{!"Flang function root test"}
!4 = !{!5, !5, i64 0}
!5 = !{!"allocated data/test_array_a", !6, i64 0}
!6 = !{!"allocated data", !1, i64 0}
!7 = !{!8, !8, i64 0}
!8 = !{!"allocated data/test_array_b", !6, i64 0}
!9 = !{!10, !11, i64 0}
!10 = !{!"Outer", !11, i64 0, !14, i64 8, !15, i64 16}
!11 = !{!"float", !12, i64 0}
!12 = !{!"omnipotent char", !13, i64 0}
!13 = !{!"Simple C/C++ TBAA"}
!14 = !{!"double", !12, i64 0}
!15 = !{!"Inner", !16, i64 0, !11, i64 4}
!16 = !{!"int", !12, i64 0}
!17 = !{!10, !16, i64 16}


