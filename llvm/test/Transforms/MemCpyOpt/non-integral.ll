; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -memcpyopt -S < %s -verify-memoryssa | FileCheck %s

target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128-ni:1"

define void @illegal_memset(ptr %p) {
; CHECK-LABEL: @illegal_memset(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr [[P:%.*]], i8 0, i64 8, i1 false)
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr ptr addrspace(1), ptr [[P]], i64 1
; CHECK-NEXT:    store ptr addrspace(1) null, ptr [[GEP]], align 8
; CHECK-NEXT:    ret void
;
entry:
  call void @llvm.memset.p0.i64(ptr %p, i8 0, i64 8, i32 0, i1 false)
  %gep = getelementptr ptr addrspace(1), ptr %p, i64 1
  store ptr addrspace(1) null, ptr %gep
  ret void
}

define void @illegal_memcpy(ptr noalias align 16 %a,
; CHECK-LABEL: @illegal_memcpy(
; CHECK-NEXT:    [[VAL:%.*]] = load <2 x ptr addrspace(1)>, ptr [[A:%.*]], align 16
; CHECK-NEXT:    store <2 x ptr addrspace(1)> [[VAL]], ptr [[B:%.*]], align 16
; CHECK-NEXT:    ret void
;
  ptr noalias align 16 %b) {
  %val = load <2 x ptr addrspace(1)>, ptr %a, align 16
  store <2 x ptr addrspace(1)> %val, ptr %b, align 16
  ret void
}

declare void @llvm.memset.p1.i64(ptr addrspace(1), i8, i64, i32, i1)
declare void @llvm.memset.p0.i64(ptr, i8, i64, i32, i1)
