; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --include-generated-funcs
; RUN: opt -S -verify -iroutliner -ir-outlining-no-cost < %s | FileCheck %s

; Here we have multiple exits, but we can't actually outline anything but
; single entry and single exits yet, we check to make sure it doesn't happen.

define void @outline_outputs1() #0 {
entry:
  %output = alloca i32, align 4
  %result = alloca i32, align 4
  %output2 = alloca i32, align 4
  %result2 = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  br label %block_2
block_1:
  %a2 = alloca i32, align 4
  %b2 = alloca i32, align 4
  br label %block_2
block_2:
  %a2val = load i32, i32* %a
  %b2val = load i32, i32* %b
  %add2 = add i32 2, %a2val
  %mul2 = mul i32 2, %b2val
  br label %block_5
block_3:
  %aval = load i32, i32* %a
  %bval = load i32, i32* %b
  %add = add i32 2, %aval
  %mul = mul i32 2, %bval
  br label %block_4
block_4:
  store i32 %add, i32* %output, align 4
  store i32 %mul, i32* %result, align 4
  br label %block_6
block_5:
  store i32 %add2, i32* %output, align 4
  store i32 %mul2, i32* %result, align 4
  br label %block_7
block_6:
  %div = udiv i32 %aval, %bval
  ret void
block_7:
  %sub = sub i32 %a2val, %b2val
  ret void
}

define void @outline_outputs2() #0 {
entry:
  %output = alloca i32, align 4
  %result = alloca i32, align 4
  %output2 = alloca i32, align 4
  %result2 = alloca i32, align 4
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  br label %block_2
block_1:
  %a2 = alloca i32, align 4
  %b2 = alloca i32, align 4
  br label %block_2
block_2:
  %a2val = load i32, i32* %a
  %b2val = load i32, i32* %b
  %add2 = add i32 2, %a2val
  %mul2 = mul i32 2, %b2val
  br label %block_5
block_3:
  %aval = load i32, i32* %a
  %bval = load i32, i32* %b
  %add = add i32 2, %aval
  %mul = mul i32 2, %bval
  br label %block_4
block_4:
  store i32 %add, i32* %output, align 4
  store i32 %mul, i32* %result, align 4
  br label %block_7
block_5:
  store i32 %add2, i32* %output, align 4
  store i32 %mul2, i32* %result, align 4
  br label %block_6
block_6:
  %diff = sub i32 %a2val, %b2val
  ret void
block_7:
  %quot = udiv i32 %aval, %bval
  ret void
}
; CHECK-LABEL: @outline_outputs1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTPUT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[RESULT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[OUTPUT2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[RESULT2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br label [[BLOCK_2:%.*]]
; CHECK:       block_1:
; CHECK-NEXT:    [[A2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br label [[BLOCK_2]]
; CHECK:       block_2:
; CHECK-NEXT:    [[A2VAL:%.*]] = load i32, i32* [[A]], align 4
; CHECK-NEXT:    [[B2VAL:%.*]] = load i32, i32* [[B]], align 4
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 2, [[A2VAL]]
; CHECK-NEXT:    [[MUL2:%.*]] = mul i32 2, [[B2VAL]]
; CHECK-NEXT:    br label [[BLOCK_5:%.*]]
; CHECK:       block_3:
; CHECK-NEXT:    [[AVAL:%.*]] = load i32, i32* [[A]], align 4
; CHECK-NEXT:    [[BVAL:%.*]] = load i32, i32* [[B]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 2, [[AVAL]]
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 2, [[BVAL]]
; CHECK-NEXT:    br label [[BLOCK_4:%.*]]
; CHECK:       block_4:
; CHECK-NEXT:    store i32 [[ADD]], i32* [[OUTPUT]], align 4
; CHECK-NEXT:    store i32 [[MUL]], i32* [[RESULT]], align 4
; CHECK-NEXT:    br label [[BLOCK_6:%.*]]
; CHECK:       block_5:
; CHECK-NEXT:    call void @outlined_ir_func_0(i32 [[ADD2]], i32* [[OUTPUT]], i32 [[MUL2]], i32* [[RESULT]])
; CHECK-NEXT:    br label [[BLOCK_7:%.*]]
; CHECK:       block_6:
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 [[AVAL]], [[BVAL]]
; CHECK-NEXT:    ret void
; CHECK:       block_7:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[A2VAL]], [[B2VAL]]
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: @outline_outputs2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTPUT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[RESULT:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[OUTPUT2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[RESULT2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br label [[BLOCK_2:%.*]]
; CHECK:       block_1:
; CHECK-NEXT:    [[A2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br label [[BLOCK_2]]
; CHECK:       block_2:
; CHECK-NEXT:    [[A2VAL:%.*]] = load i32, i32* [[A]], align 4
; CHECK-NEXT:    [[B2VAL:%.*]] = load i32, i32* [[B]], align 4
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 2, [[A2VAL]]
; CHECK-NEXT:    [[MUL2:%.*]] = mul i32 2, [[B2VAL]]
; CHECK-NEXT:    br label [[BLOCK_5:%.*]]
; CHECK:       block_3:
; CHECK-NEXT:    [[AVAL:%.*]] = load i32, i32* [[A]], align 4
; CHECK-NEXT:    [[BVAL:%.*]] = load i32, i32* [[B]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 2, [[AVAL]]
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 2, [[BVAL]]
; CHECK-NEXT:    br label [[BLOCK_4:%.*]]
; CHECK:       block_4:
; CHECK-NEXT:    store i32 [[ADD]], i32* [[OUTPUT]], align 4
; CHECK-NEXT:    store i32 [[MUL]], i32* [[RESULT]], align 4
; CHECK-NEXT:    br label [[BLOCK_7:%.*]]
; CHECK:       block_5:
; CHECK-NEXT:    call void @outlined_ir_func_0(i32 [[ADD2]], i32* [[OUTPUT]], i32 [[MUL2]], i32* [[RESULT]])
; CHECK-NEXT:    br label [[BLOCK_6:%.*]]
; CHECK:       block_6:
; CHECK-NEXT:    [[DIFF:%.*]] = sub i32 [[A2VAL]], [[B2VAL]]
; CHECK-NEXT:    ret void
; CHECK:       block_7:
; CHECK-NEXT:    [[QUOT:%.*]] = udiv i32 [[AVAL]], [[BVAL]]
; CHECK-NEXT:    ret void
;
;
; CHECK: define internal void @outlined_ir_func_0(
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[BLOCK_5_TO_OUTLINE:%.*]]
; CHECK:       block_5_to_outline:
; CHECK-NEXT:    store i32 [[TMP0:%.*]], i32* [[TMP1:%.*]], align 4
; CHECK-NEXT:    store i32 [[TMP2:%.*]], i32* [[TMP3:%.*]], align 4
; CHECK-NEXT:    br label [[BLOCK_7_EXITSTUB:%.*]]
; CHECK:       block_7.exitStub:
; CHECK-NEXT:    ret void
;
