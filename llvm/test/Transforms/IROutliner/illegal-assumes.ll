; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -p iroutliner,verify -ir-outlining-no-cost < %s | FileCheck %s

; This test ensures that we do not include llvm.assumes.  There are exceptions
; in the CodeExtractor's algorithm for llvm.assumes, so we ignore it for now.

define void @outline_assumes() {
; CHECK-LABEL: @outline_assumes(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DL_LOC:%.*]] = alloca i1, align 1
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[C:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[D:%.*]] = alloca i1, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    call void @outlined_ir_func_4(i1 true, ptr [[D]], ptr [[DL_LOC]])
; CHECK-NEXT:    [[DL_RELOAD:%.*]] = load i1, ptr [[DL_LOC]], align 1
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    [[SPLIT_INST:%.*]] = sub i1 [[DL_RELOAD]], [[DL_RELOAD]]
; CHECK-NEXT:    call void @outlined_ir_func_1(ptr [[A]], ptr [[B]], ptr [[C]])
; CHECK-NEXT:    call void @llvm.assume(i1 [[DL_RELOAD]])
; CHECK-NEXT:    call void @outlined_ir_func_2(ptr [[A]], ptr [[B]], ptr [[C]])
; CHECK-NEXT:    ret void
;
entry:
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i1, align 4
  store i1 1, ptr %d, align 4
  %dl = load i1, ptr %d
  %split_inst = sub i1 %dl, %dl
  store i32 2, ptr %a, align 4
  store i32 3, ptr %b, align 4
  store i32 4, ptr %c, align 4
  call void @llvm.assume(i1 %dl)
  %al = load i32, ptr %a
  %bl = load i32, ptr %b
  %cl = load i32, ptr %c
  ret void
}

define void @outline_assumes2() {
; CHECK-LABEL: @outline_assumes2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DL_LOC:%.*]] = alloca i1, align 1
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[C:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[D:%.*]] = alloca i1, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    call void @outlined_ir_func_4(i1 false, ptr [[D]], ptr [[DL_LOC]])
; CHECK-NEXT:    [[DL_RELOAD:%.*]] = load i1, ptr [[DL_LOC]], align 1
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    call void @outlined_ir_func_1(ptr [[A]], ptr [[B]], ptr [[C]])
; CHECK-NEXT:    call void @llvm.assume(i1 [[DL_RELOAD]])
; CHECK-NEXT:    call void @outlined_ir_func_2(ptr [[A]], ptr [[B]], ptr [[C]])
; CHECK-NEXT:    ret void
;
entry:
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i1, align 4
  store i1 0, ptr %d, align 4
  %dl = load i1, ptr %d
  store i32 2, ptr %a, align 4
  store i32 3, ptr %b, align 4
  store i32 4, ptr %c, align 4
  call void @llvm.assume(i1 %dl)
  %al = load i32, ptr %a
  %bl = load i32, ptr %b
  %cl = load i32, ptr %c
  ret void
}

define void @outline_assumes3() {
; CHECK-LABEL: @outline_assumes3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DL_LOC:%.*]] = alloca i1, align 1
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[C:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[D:%.*]] = alloca i1, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    call void @outlined_ir_func_0(i1 true, ptr [[D]], ptr [[A]], ptr [[B]], ptr [[C]], ptr [[DL_LOC]])
; CHECK-NEXT:    [[DL_RELOAD:%.*]] = load i1, ptr [[DL_LOC]], align 1
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    call void @llvm.assume(i1 [[DL_RELOAD]])
; CHECK-NEXT:    call void @outlined_ir_func_3(ptr [[A]])
; CHECK-NEXT:    ret void
;
entry:
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i1, align 4
  store i1 1, ptr %d, align 4
  %dl = load i1, ptr %d
  %split_inst = add i1 %dl, %dl
  store i32 2, ptr %a, align 4
  store i32 3, ptr %b, align 4
  store i32 4, ptr %c, align 4
  call void @llvm.assume(i1 %dl)
  %al = load i32, ptr %a
  %bl = add i32 %al, %al
  ret void
}

define void @outline_assumes4() {
; CHECK-LABEL: @outline_assumes4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DL_LOC:%.*]] = alloca i1, align 1
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[C:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[D:%.*]] = alloca i1, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    call void @outlined_ir_func_0(i1 false, ptr [[D]], ptr [[A]], ptr [[B]], ptr [[C]], ptr [[DL_LOC]])
; CHECK-NEXT:    [[DL_RELOAD:%.*]] = load i1, ptr [[DL_LOC]], align 1
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[DL_LOC]])
; CHECK-NEXT:    call void @llvm.assume(i1 [[DL_RELOAD]])
; CHECK-NEXT:    call void @outlined_ir_func_3(ptr [[A]])
; CHECK-NEXT:    ret void
;
entry:
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i1, align 4
  store i1 0, ptr %d, align 4
  %dl = load i1, ptr %d
  %split_inst = add i1 %dl, %dl
  store i32 2, ptr %a, align 4
  store i32 3, ptr %b, align 4
  store i32 4, ptr %c, align 4
  call void @llvm.assume(i1 %dl)
  %al = load i32, ptr %a
  %bl = add i32 %al, %al
  ret void
}

declare void @llvm.assume(i1)
