; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=vector-combine -mtriple=arm64-apple-darwinos -S %s | FileCheck %s

define i32 @load_v4i8_bitcast_to_i32(ptr %x) {
; CHECK-LABEL: define i32 @load_v4i8_bitcast_to_i32(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[R_SCALAR:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    ret i32 [[R_SCALAR]]
;
  %lv = load <4 x i8>, ptr %x
  %r = bitcast <4 x i8> %lv to i32
  ret i32 %r
}

define i64 @load_v2i32_bitcast_to_i64(ptr %x) {
; CHECK-LABEL: define i64 @load_v2i32_bitcast_to_i64(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[R_SCALAR:%.*]] = load i64, ptr [[X]], align 8
; CHECK-NEXT:    ret i64 [[R_SCALAR]]
;
  %lv = load <2 x i32>, ptr %x
  %r = bitcast <2 x i32> %lv to i64
  ret i64 %r
}

define float @load_v4i8_bitcast_to_float(ptr %x) {
; CHECK-LABEL: define float @load_v4i8_bitcast_to_float(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[R_SCALAR:%.*]] = load float, ptr [[X]], align 4
; CHECK-NEXT:    ret float [[R_SCALAR]]
;
  %lv = load <4 x i8>, ptr %x
  %r = bitcast <4 x i8> %lv to float
  ret float %r
}

define float @load_v2i16_bitcast_to_float(ptr %x) {
; CHECK-LABEL: define float @load_v2i16_bitcast_to_float(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[R_SCALAR:%.*]] = load float, ptr [[X]], align 4
; CHECK-NEXT:    ret float [[R_SCALAR]]
;
  %lv = load <2 x i16>, ptr %x
  %r = bitcast <2 x i16> %lv to float
  ret float %r
}

define double @load_v4i16_bitcast_to_double(ptr %x) {
; CHECK-LABEL: define double @load_v4i16_bitcast_to_double(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[LV:%.*]] = load <4 x i16>, ptr [[X]], align 8
; CHECK-NEXT:    [[R_SCALAR:%.*]] = bitcast <4 x i16> [[LV]] to double
; CHECK-NEXT:    ret double [[R_SCALAR]]
;
  %lv = load <4 x i16>, ptr %x
  %r = bitcast <4 x i16> %lv to double
  ret double %r
}

define double @load_v2i32_bitcast_to_double(ptr %x) {
; CHECK-LABEL: define double @load_v2i32_bitcast_to_double(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[LV:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    [[R_SCALAR:%.*]] = bitcast <2 x i32> [[LV]] to double
; CHECK-NEXT:    ret double [[R_SCALAR]]
;
  %lv = load <2 x i32>, ptr %x
  %r = bitcast <2 x i32> %lv to double
  ret double %r
}

; Multiple users with the same bitcast type should be scalarized.
define i32 @load_v4i8_bitcast_multiple_users_same_type(ptr %x) {
; CHECK-LABEL: define i32 @load_v4i8_bitcast_multiple_users_same_type(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[LV_SCALAR:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[LV_SCALAR]], [[LV_SCALAR]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
  %lv = load <4 x i8>, ptr %x
  %r1 = bitcast <4 x i8> %lv to i32
  %r2 = bitcast <4 x i8> %lv to i32
  %add = add i32 %r1, %r2
  ret i32 %add
}

; Different bitcast types should not be scalarized.
define i32 @load_v4i8_bitcast_multiple_users_different_types(ptr %x) {
; CHECK-LABEL: define i32 @load_v4i8_bitcast_multiple_users_different_types(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[LV:%.*]] = load <4 x i8>, ptr [[X]], align 4
; CHECK-NEXT:    [[R1:%.*]] = bitcast <4 x i8> [[LV]] to i32
; CHECK-NEXT:    [[R2:%.*]] = bitcast <4 x i8> [[LV]] to float
; CHECK-NEXT:    [[R2_INT:%.*]] = bitcast float [[R2]] to i32
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[R1]], [[R2_INT]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
  %lv = load <4 x i8>, ptr %x
  %r1 = bitcast <4 x i8> %lv to i32
  %r2 = bitcast <4 x i8> %lv to float
  %r2.int = bitcast float %r2 to i32
  %add = add i32 %r1, %r2.int
  ret i32 %add
}

; Bitcast to vector should not be scalarized.
define <2 x i16> @load_v4i8_bitcast_to_vector(ptr %x) {
; CHECK-LABEL: define <2 x i16> @load_v4i8_bitcast_to_vector(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[LV:%.*]] = load <4 x i8>, ptr [[X]], align 4
; CHECK-NEXT:    [[R:%.*]] = bitcast <4 x i8> [[LV]] to <2 x i16>
; CHECK-NEXT:    ret <2 x i16> [[R]]
;
  %lv = load <4 x i8>, ptr %x
  %r = bitcast <4 x i8> %lv to <2 x i16>
  ret <2 x i16> %r
}

; Load with both bitcast users and other users should not be scalarized.
define i32 @load_v4i8_mixed_users(ptr %x) {
; CHECK-LABEL: define i32 @load_v4i8_mixed_users(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[LV:%.*]] = load <4 x i8>, ptr [[X]], align 4
; CHECK-NEXT:    [[R1:%.*]] = bitcast <4 x i8> [[LV]] to i32
; CHECK-NEXT:    [[R2:%.*]] = extractelement <4 x i8> [[LV]], i32 0
; CHECK-NEXT:    [[R2_EXT:%.*]] = zext i8 [[R2]] to i32
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[R1]], [[R2_EXT]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
  %lv = load <4 x i8>, ptr %x
  %r1 = bitcast <4 x i8> %lv to i32
  %r2 = extractelement <4 x i8> %lv, i32 0
  %r2.ext = zext i8 %r2 to i32
  %add = add i32 %r1, %r2.ext
  ret i32 %add
}
