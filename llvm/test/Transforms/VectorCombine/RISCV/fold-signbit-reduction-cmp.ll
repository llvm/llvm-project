; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=vector-combine -mtriple=riscv64 -mattr=+v < %s | FileCheck %s

define i1 @or_eq_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @or_eq_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @or_ne_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @or_ne_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 0
  ret i1 %cmp
}

define i1 @or_eq_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @or_eq_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 1
  ret i1 %cmp
}

define i1 @or_ne_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @or_ne_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 1
  ret i1 %cmp
}

define i1 @umax_eq_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umax_eq_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @umax_ne_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umax_ne_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 0
  ret i1 %cmp
}

define i1 @umax_eq_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umax_eq_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 1
  ret i1 %cmp
}

define i1 @umax_ne_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umax_ne_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umax.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 1
  ret i1 %cmp
}

define i1 @and_eq_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @and_eq_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @and_ne_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @and_ne_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 0
  ret i1 %cmp
}

define i1 @and_eq_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @and_eq_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 1
  ret i1 %cmp
}

define i1 @and_ne_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @and_ne_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 1
  ret i1 %cmp
}

define i1 @umin_eq_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umin_eq_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @umin_ne_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umin_ne_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 0
  ret i1 %cmp
}

define i1 @umin_eq_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umin_eq_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 1
  ret i1 %cmp
}

define i1 @umin_ne_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @umin_ne_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.umin.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 1
  ret i1 %cmp
}

define i1 @add_eq_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @add_eq_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @add_ne_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @add_ne_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 0
  ret i1 %cmp
}

define i1 @add_eq_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @add_eq_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 4
  ret i1 %cmp
}

define i1 @add_ne_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @add_ne_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, 4
  ret i1 %cmp
}

define i1 @add_ult_max(<4 x i32> %x) {
; CHECK-LABEL: define i1 @add_ult_max(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ult i32 %red, 4
  ret i1 %cmp
}

define i1 @add_ugt_max_minus_1(<4 x i32> %x) {
; CHECK-LABEL: define i1 @add_ugt_max_minus_1(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ugt i32 %red, 3
  ret i1 %cmp
}

define i1 @ashr_add_eq_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @ashr_add_eq_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @or_eq_0_v8i16(<8 x i16> %x) {
; CHECK-LABEL: define i1 @or_eq_0_v8i16(
; CHECK-SAME: <8 x i16> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i16 @llvm.vector.reduce.or.v8i16(<8 x i16> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i16 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <8 x i16> %x, splat (i16 15)
  %red = call i16 @llvm.vector.reduce.or.v8i16(<8 x i16> %shr)
  %cmp = icmp eq i16 %red, 0
  ret i1 %cmp
}

define i1 @and_eq_max_v2i64(<2 x i64> %x) {
; CHECK-LABEL: define i1 @and_eq_max_v2i64(
; CHECK-SAME: <2 x i64> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.vector.reduce.and.v2i64(<2 x i64> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i64 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <2 x i64> %x, splat (i64 63)
  %red = call i64 @llvm.vector.reduce.and.v2i64(<2 x i64> %shr)
  %cmp = icmp eq i64 %red, 1
  ret i1 %cmp
}

define i1 @negative_wrong_shift(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_wrong_shift(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i32> [[X]], splat (i32 30)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[RED]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 30)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @negative_wrong_cmp_const(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_wrong_cmp_const(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[RED]], 2
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 2
  ret i1 %cmp
}

define i1 @negative_multi_use_shift(<4 x i32> %x, ptr %p) {
; CHECK-LABEL: define i1 @negative_multi_use_shift(
; CHECK-SAME: <4 x i32> [[X:%.*]], ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    store <4 x i32> [[SHR]], ptr [[P]], align 16
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[RED]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  store <4 x i32> %shr, ptr %p
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, 0
  ret i1 %cmp
}

define i1 @negative_sgt_wrong_const(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_sgt_wrong_const(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[RED]], 1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp sgt i32 %red, 1
  ret i1 %cmp
}

define i1 @negative_slt_wrong_const(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_slt_wrong_const(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[RED]], 2
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp slt i32 %red, 2
  ret i1 %cmp
}

define i1 @negative_add_numelts_overflow(<8 x i2> %x) {
; CHECK-LABEL: define i1 @negative_add_numelts_overflow(
; CHECK-SAME: <8 x i2> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <8 x i2> [[X]], splat (i2 1)
; CHECK-NEXT:    [[RED:%.*]] = call i2 @llvm.vector.reduce.add.v8i2(<8 x i2> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i2 [[RED]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <8 x i2> %x, splat (i2 1)
  %red = call i2 @llvm.vector.reduce.add.v8i2(<8 x i2> %shr)
  %cmp = icmp eq i2 %red, 0
  ret i1 %cmp
}

define i1 @ashr_add_eq_allneg(<4 x i32> %x) {
; CHECK-LABEL: define i1 @ashr_add_eq_allneg(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp eq i32 %red, -4
  ret i1 %cmp
}

define i1 @ashr_add_ne_allneg(<4 x i32> %x) {
; CHECK-LABEL: define i1 @ashr_add_ne_allneg(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ne i32 %red, -4
  ret i1 %cmp
}

define i1 @ashr_add_sgt_minus1(<4 x i32> %x) {
; CHECK-LABEL: define i1 @ashr_add_sgt_minus1(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp sgt i32 %red, -1
  ret i1 %cmp
}

define i1 @ashr_add_slt_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @ashr_add_slt_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp slt i32 %red, 0
  ret i1 %cmp
}

define i1 @ashr_add_slt_minus3(<4 x i32> %x) {
; CHECK-LABEL: define i1 @ashr_add_slt_minus3(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp slt i32 %red, -3
  ret i1 %cmp
}

define i1 @ashr_add_sgt_minus4(<4 x i32> %x) {
; CHECK-LABEL: define i1 @ashr_add_sgt_minus4(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp sgt i32 %red, -4
  ret i1 %cmp
}

define i1 @ashr_add_eq_allneg_v8i16(<8 x i16> %x) {
; CHECK-LABEL: define i1 @ashr_add_eq_allneg_v8i16(
; CHECK-SAME: <8 x i16> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i16 @llvm.vector.reduce.and.v8i16(<8 x i16> [[X]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i16 [[TMP1]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <8 x i16> %x, splat (i16 15)
  %red = call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %shr)
  %cmp = icmp eq i16 %red, -8
  ret i1 %cmp
}

; negative: NumElts=2 doesn't fit as signed in i2
define i1 @add_eq_0_v2i2(<2 x i2> %x) {
; CHECK-LABEL: define i1 @add_eq_0_v2i2(
; CHECK-SAME: <2 x i2> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <2 x i2> [[X]], splat (i2 1)
; CHECK-NEXT:    [[RED:%.*]] = call i2 @llvm.vector.reduce.add.v2i2(<2 x i2> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i2 [[RED]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <2 x i2> %x, splat (i2 1)
  %red = call i2 @llvm.vector.reduce.add.v2i2(<2 x i2> %shr)
  %cmp = icmp eq i2 %red, 0
  ret i1 %cmp
}

; negative: NumElts=3 doesn't fit as signed in i2
define i1 @add_eq_max_v3i2(<3 x i2> %x) {
; CHECK-LABEL: define i1 @add_eq_max_v3i2(
; CHECK-SAME: <3 x i2> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <3 x i2> [[X]], splat (i2 1)
; CHECK-NEXT:    [[RED:%.*]] = call i2 @llvm.vector.reduce.add.v3i2(<3 x i2> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i2 [[RED]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <3 x i2> %x, splat (i2 1)
  %red = call i2 @llvm.vector.reduce.add.v3i2(<3 x i2> %shr)
  %cmp = icmp eq i2 %red, 3
  ret i1 %cmp
}

define i1 @negative_add_v4i2(<4 x i2> %x) {
; CHECK-LABEL: define i1 @negative_add_v4i2(
; CHECK-SAME: <4 x i2> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i2> [[X]], splat (i2 1)
; CHECK-NEXT:    [[RED:%.*]] = call i2 @llvm.vector.reduce.add.v4i2(<4 x i2> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i2 [[RED]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i2> %x, splat (i2 1)
  %red = call i2 @llvm.vector.reduce.add.v4i2(<4 x i2> %shr)
  %cmp = icmp eq i2 %red, 0
  ret i1 %cmp
}

define i1 @i1_or_eq_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_or_eq_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> %shr)
  %cmp = icmp eq i1 %red, 0
  ret i1 %cmp
}

define i1 @i1_or_ne_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_or_ne_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> %shr)
  %cmp = icmp ne i1 %red, 0
  ret i1 %cmp
}

define i1 @i1_and_eq_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_and_eq_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> %shr)
  %cmp = icmp eq i1 %red, 0
  ret i1 %cmp
}

define i1 @i1_and_ne_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_and_ne_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> %shr)
  %cmp = icmp ne i1 %red, 0
  ret i1 %cmp
}

define i1 @i1_umax_eq_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_umax_eq_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.umax.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.umax.v4i1(<4 x i1> %shr)
  %cmp = icmp eq i1 %red, 0
  ret i1 %cmp
}

define i1 @i1_umin_ne_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_umin_ne_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = lshr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.umin.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = lshr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.umin.v4i1(<4 x i1> %shr)
  %cmp = icmp ne i1 %red, 0
  ret i1 %cmp
}

define i1 @i1_ashr_or_eq_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_ashr_or_eq_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = ashr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> %shr)
  %cmp = icmp eq i1 %red, 0
  ret i1 %cmp
}

define i1 @i1_ashr_and_ne_0(<4 x i1> %x) {
; CHECK-LABEL: define i1 @i1_ashr_and_ne_0(
; CHECK-SAME: <4 x i1> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = ashr <4 x i1> [[X]], zeroinitializer
; CHECK-NEXT:    [[RED:%.*]] = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i1 [[RED]], false
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i1> %x, splat (i1 0)
  %red = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> %shr)
  %cmp = icmp ne i1 %red, 0
  ret i1 %cmp
}

define i1 @negative_ashr_add_ult_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_ashr_add_ult_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = ashr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[RED]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ult i32 %red, 0
  ret i1 %cmp
}

define i1 @negative_ashr_add_ugt_minus1(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_ashr_add_ugt_minus1(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = ashr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[RED]], -1
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ugt i32 %red, -1
  ret i1 %cmp
}

define i1 @negative_ashr_add_ult_minus3(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_ashr_add_ult_minus3(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = ashr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[RED]], -3
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %shr)
  %cmp = icmp ult i32 %red, -3
  ret i1 %cmp
}

define i1 @negative_ashr_or_ult_0(<4 x i32> %x) {
; CHECK-LABEL: define i1 @negative_ashr_or_ult_0(
; CHECK-SAME: <4 x i32> [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SHR:%.*]] = ashr <4 x i32> [[X]], splat (i32 31)
; CHECK-NEXT:    [[RED:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[SHR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[RED]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %shr = ashr <4 x i32> %x, splat (i32 31)
  %red = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %shr)
  %cmp = icmp ult i32 %red, 0
  ret i1 %cmp
}
