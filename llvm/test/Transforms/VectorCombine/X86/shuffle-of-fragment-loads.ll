; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2 | FileCheck %s --check-prefixes=CHECK,SSE
; RUN: opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=avx2 | FileCheck %s --check-prefixes=CHECK,AVX

declare void @use(<2 x i32>)

; ============================================================================
; Basic functionality (Type Match, Widen)
; ============================================================================

define <8 x float> @test_basic_group_float(ptr %p) {
; CHECK-LABEL: define <8 x float> @test_basic_group_float(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[L1:%.*]] = load <4 x float>, ptr [[P]], align 16
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 32
; CHECK-NEXT:    [[L2:%.*]] = load <4 x float>, ptr [[GEP]], align 16
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x float> [[L1]], <4 x float> [[L2]], <8 x i32> <i32 0, i32 1, i32 4, i32 5, i32 2, i32 3, i32 6, i32 7>
; CHECK-NEXT:    ret <8 x float> [[RES]]
;
  %l1 = load <4 x float>, ptr %p, align 16
  %gep = getelementptr inbounds i8, ptr %p, i64 32
  %l2 = load <4 x float>, ptr %gep, align 16
  %shuf1 = shufflevector <4 x float> %l1, <4 x float> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
  %shuf2 = shufflevector <4 x float> %l2, <4 x float> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
  %res = shufflevector <8 x float> %shuf1, <8 x float> %shuf2, <8 x i32> <i32 0, i32 1, i32 8, i32 9, i32 2, i32 3, i32 10, i32 11>
  ret <8 x float> %res
}

define <8 x i32> @test_reordered_load(ptr %p) {
; CHECK-LABEL: define <8 x i32> @test_reordered_load(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L1:%.*]] = load <4 x i32>, ptr [[P]], align 16
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 16
; CHECK-NEXT:    [[L2:%.*]] = load <4 x i32>, ptr [[GEP]], align 16
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[L2]], <4 x i32> [[L1]], <8 x i32> <i32 0, i32 1, i32 4, i32 5, i32 2, i32 3, i32 6, i32 7>
; CHECK-NEXT:    ret <8 x i32> [[RES]]
;
  %l1 = load <4 x i32>, ptr %p, align 16
  %gep = getelementptr inbounds i8, ptr %p, i64 16
  %l2 = load <4 x i32>, ptr %gep, align 16
  %res = shufflevector <4 x i32> %l2, <4 x i32> %l1, <8 x i32> <i32 0, i32 1, i32 4, i32 5, i32 2, i32 3, i32 6, i32 7>
  ret <8 x i32> %res
}

define <4 x float> @test_poison_pad(ptr %p) {
; CHECK-LABEL: define <4 x float> @test_poison_pad(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L1:%.*]] = load <2 x float>, ptr [[P]], align 8
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 16
; CHECK-NEXT:    [[L2:%.*]] = load <2 x float>, ptr [[GEP]], align 8
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x float> [[L1]], <2 x float> [[L2]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x float> [[RES]]
;
  %l1 = load <2 x float>, ptr %p, align 8
  %gep = getelementptr inbounds i8, ptr %p, i64 16
  %l2 = load <2 x float>, ptr %gep, align 8
  %l1_pad = shufflevector <2 x float> %l1, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %l2_pad = shufflevector <2 x float> %l2, <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %res = shufflevector <4 x float> %l1_pad, <4 x float> %l2_pad, <4 x i32> <i32 0, i32 1, i32 4, i32 5>
  ret <4 x float> %res
}

define <4 x float> @test_single_load(ptr %p) {
; CHECK-LABEL: define <4 x float> @test_single_load(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L1:%.*]] = load <4 x float>, ptr [[P]], align 16
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x float> [[L1]], <4 x float> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
; CHECK-NEXT:    ret <4 x float> [[RES]]
;
  %l1 = load <4 x float>, ptr %p
  %tmp = shufflevector <4 x float> %l1, <4 x float> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %res = shufflevector <4 x float> %tmp, <4 x float> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  ret <4 x float> %res
}

; ====================================================================================
; Positive : Consolidate multiple fragmented memory loads and subsequent shuffles into
; one or two wide loads and a single shuffle operation.
; ====================================================================================

define <4 x double> @test_double_4_to_2(ptr %x, ptr %y) {
; SSE-LABEL: define <4 x double> @test_double_4_to_2(
; SSE-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[X0:%.*]] = load <2 x double>, ptr [[X]], align 16
; SSE-NEXT:    [[X_OFF:%.*]] = getelementptr i8, ptr [[X]], i64 16
; SSE-NEXT:    [[X1:%.*]] = load <2 x double>, ptr [[X_OFF]], align 16
; SSE-NEXT:    [[Y0:%.*]] = load <2 x double>, ptr [[Y]], align 16
; SSE-NEXT:    [[Y_OFF:%.*]] = getelementptr i8, ptr [[Y]], i64 16
; SSE-NEXT:    [[Y1:%.*]] = load <2 x double>, ptr [[Y_OFF]], align 16
; SSE-NEXT:    [[V1:%.*]] = shufflevector <2 x double> [[X0]], <2 x double> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[V2:%.*]] = shufflevector <2 x double> [[Y0]], <2 x double> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[RES:%.*]] = shufflevector <4 x double> [[V1]], <4 x double> [[V2]], <4 x i32> <i32 0, i32 2, i32 4, i32 6>
; SSE-NEXT:    ret <4 x double> [[RES]]
;
; AVX-LABEL: define <4 x double> @test_double_4_to_2(
; AVX-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[X0:%.*]] = load <2 x double>, ptr [[X]], align 16
; AVX-NEXT:    [[X_OFF:%.*]] = getelementptr i8, ptr [[X]], i64 16
; AVX-NEXT:    [[X1:%.*]] = load <2 x double>, ptr [[X_OFF]], align 16
; AVX-NEXT:    [[Y0:%.*]] = load <2 x double>, ptr [[Y]], align 16
; AVX-NEXT:    [[Y_OFF:%.*]] = getelementptr i8, ptr [[Y]], i64 16
; AVX-NEXT:    [[Y1:%.*]] = load <2 x double>, ptr [[Y_OFF]], align 16
; AVX-NEXT:    [[TMP1:%.*]] = shufflevector <2 x double> [[X0]], <2 x double> [[X1]], <4 x i32> <i32 0, i32 2, i32 poison, i32 poison>
; AVX-NEXT:    [[TMP2:%.*]] = shufflevector <2 x double> [[Y0]], <2 x double> [[Y1]], <4 x i32> <i32 poison, i32 poison, i32 0, i32 2>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <4 x double> [[TMP1]], <4 x double> [[TMP2]], <4 x i32> <i32 0, i32 1, i32 6, i32 7>
; AVX-NEXT:    ret <4 x double> [[RES]]
;
  %x0 = load <2 x double>, ptr %x
  %x_off = getelementptr i8, ptr %x, i64 16
  %x1 = load <2 x double>, ptr %x_off
  %y0 = load <2 x double>, ptr %y
  %y_off = getelementptr i8, ptr %y, i64 16
  %y1 = load <2 x double>, ptr %y_off
  %v1 = shufflevector <2 x double> %x0, <2 x double> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v2 = shufflevector <2 x double> %y0, <2 x double> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %res = shufflevector <4 x double> %v1, <4 x double> %v2, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  ret <4 x double> %res
}

define <4 x double> @test_double_3_to_1(ptr %p) {
; CHECK-LABEL: define <4 x double> @test_double_3_to_1(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L1:%.*]] = load <2 x double>, ptr [[P]], align 16
; CHECK-NEXT:    [[P_PLUS_8:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[L2:%.*]] = load <2 x double>, ptr [[P_PLUS_8]], align 8
; CHECK-NEXT:    [[P_PLUS_16:%.*]] = getelementptr i8, ptr [[P]], i64 16
; CHECK-NEXT:    [[L3:%.*]] = load <2 x double>, ptr [[P_PLUS_16]], align 16
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x double> [[L1]], <2 x double> [[L2]], <2 x i32> <i32 0, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x double> [[V1]], <2 x double> [[L3]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x double> [[RES]]
;
  %L1 = load <2 x double>, ptr %p, align 16
  %p_plus_8 = getelementptr i8, ptr %p, i64 8
  %L2 = load <2 x double>, ptr %p_plus_8, align 8
  %p_plus_16 = getelementptr i8, ptr %p, i64 16
  %L3 = load <2 x double>, ptr %p_plus_16, align 16
  %v1 = shufflevector <2 x double> %L1, <2 x double> %L2, <2 x i32> <i32 0, i32 3>
  %res = shufflevector <2 x double> %v1, <2 x double> %L3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %res
}

; Float
define <8 x float> @test_float_4_to_2(ptr %x, ptr %y) {
; CHECK-LABEL: define <8 x float> @test_float_4_to_2(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x float>, ptr [[X]], align 8
; CHECK-NEXT:    [[X_OFF:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[X1:%.*]] = load <2 x float>, ptr [[X_OFF]], align 8
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x float>, ptr [[Y]], align 8
; CHECK-NEXT:    [[Y_OFF:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x float>, ptr [[Y_OFF]], align 8
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x float> [[X0]], <2 x float> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[V2:%.*]] = shufflevector <2 x float> [[Y0]], <2 x float> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x float> [[V1]], <4 x float> [[V2]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    ret <8 x float> [[RES]]
;
  %x0 = load <2 x float>, ptr %x
  %x_off = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x float>, ptr %x_off
  %y0 = load <2 x float>, ptr %y
  %y_off = getelementptr i8, ptr %y, i64 8
  %y1 = load <2 x float>, ptr %y_off
  %v1 = shufflevector <2 x float> %x0, <2 x float> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v2 = shufflevector <2 x float> %y0, <2 x float> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v1w = shufflevector <4 x float> %v1, <4 x float> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
  %v2w = shufflevector <4 x float> %v2, <4 x float> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
  %res = shufflevector <8 x float> %v1w, <8 x float> %v2w, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>
  ret <8 x float> %res
}

define <4 x float> @test_float_3_to_1(ptr %p) {
; SSE-LABEL: define <4 x float> @test_float_3_to_1(
; SSE-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[L0:%.*]] = load <2 x float>, ptr [[P]], align 8
; SSE-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; SSE-NEXT:    [[L2:%.*]] = load <2 x float>, ptr [[P2]], align 4
; SSE-NEXT:    [[RES:%.*]] = shufflevector <2 x float> [[L0]], <2 x float> [[L2]], <4 x i32> <i32 0, i32 2, i32 2, i32 3>
; SSE-NEXT:    ret <4 x float> [[RES]]
;
; AVX-LABEL: define <4 x float> @test_float_3_to_1(
; AVX-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[L0:%.*]] = load <2 x float>, ptr [[P]], align 8
; AVX-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 4
; AVX-NEXT:    [[L1:%.*]] = load <2 x float>, ptr [[P1]], align 4
; AVX-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; AVX-NEXT:    [[L2:%.*]] = load <2 x float>, ptr [[P2]], align 4
; AVX-NEXT:    [[V1:%.*]] = shufflevector <2 x float> [[L0]], <2 x float> [[L1]], <2 x i32> <i32 0, i32 3>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <2 x float> [[V1]], <2 x float> [[L2]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; AVX-NEXT:    ret <4 x float> [[RES]]
;
  %L0 = load <2 x float>, ptr %p, align 8
  %p1 = getelementptr i8, ptr %p, i64 4
  %L1 = load <2 x float>, ptr %p1, align 4
  %p2 = getelementptr i8, ptr %p, i64 8
  %L2 = load <2 x float>, ptr %p2, align 4
  %v1 = shufflevector <2 x float> %L0, <2 x float> %L1, <2 x i32> <i32 0, i32 3>
  %res = shufflevector <2 x float> %v1, <2 x float> %L2, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %res
}

; i64
define <4 x i64> @test_i64_4_to_2(ptr %x, ptr %y) {
; CHECK-LABEL: define <4 x i64> @test_i64_4_to_2(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i64>, ptr [[X]], align 16
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 16
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i64>, ptr [[XA]], align 16
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x i64>, ptr [[Y]], align 16
; CHECK-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 16
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x i64>, ptr [[YA]], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <2 x i64> [[X0]], <2 x i64> [[X1]], <4 x i32> <i32 0, i32 2, i32 poison, i32 poison>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <2 x i64> [[Y0]], <2 x i64> [[Y1]], <4 x i32> <i32 poison, i32 poison, i32 0, i32 2>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> [[TMP2]], <4 x i32> <i32 0, i32 1, i32 6, i32 7>
; CHECK-NEXT:    ret <4 x i64> [[RES]]
;
  %x0 = load <2 x i64>, ptr %x, align 16
  %xa = getelementptr i8, ptr %x, i64 16
  %x1 = load <2 x i64>, ptr %xa, align 16
  %y0 = load <2 x i64>, ptr %y, align 16
  %ya = getelementptr i8, ptr %y, i64 16
  %y1 = load <2 x i64>, ptr %ya, align 16
  %vx = shufflevector <2 x i64> %x0, <2 x i64> %x1, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  %vy = shufflevector <2 x i64> %y0, <2 x i64> %y1, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  %res = shufflevector <4 x i64> %vx, <4 x i64> %vy, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  ret <4 x i64> %res
}

define <4 x i64> @test_i64_3_to_1_success(ptr %p) {
; SSE-LABEL: define <4 x i64> @test_i64_3_to_1_success(
; SSE-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[PA:%.*]] = getelementptr i8, ptr [[P]], i64 8
; SSE-NEXT:    [[L1:%.*]] = load <2 x i64>, ptr [[PA]], align 8
; SSE-NEXT:    [[PB:%.*]] = getelementptr i8, ptr [[P]], i64 16
; SSE-NEXT:    [[L2:%.*]] = load <2 x i64>, ptr [[PB]], align 16
; SSE-NEXT:    [[RES:%.*]] = shufflevector <2 x i64> [[L1]], <2 x i64> [[L2]], <4 x i32> <i32 0, i32 0, i32 3, i32 1>
; SSE-NEXT:    ret <4 x i64> [[RES]]
;
; AVX-LABEL: define <4 x i64> @test_i64_3_to_1_success(
; AVX-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[L0:%.*]] = load <2 x i64>, ptr [[P]], align 16
; AVX-NEXT:    [[PA:%.*]] = getelementptr i8, ptr [[P]], i64 8
; AVX-NEXT:    [[L1:%.*]] = load <2 x i64>, ptr [[PA]], align 8
; AVX-NEXT:    [[PB:%.*]] = getelementptr i8, ptr [[P]], i64 16
; AVX-NEXT:    [[L2:%.*]] = load <2 x i64>, ptr [[PB]], align 16
; AVX-NEXT:    [[V1:%.*]] = shufflevector <2 x i64> [[L0]], <2 x i64> [[L1]], <2 x i32> <i32 1, i32 2>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <2 x i64> [[V1]], <2 x i64> [[L2]], <4 x i32> <i32 1, i32 0, i32 3, i32 2>
; AVX-NEXT:    ret <4 x i64> [[RES]]
;
  %L0 = load <2 x i64>, ptr %p, align 16
  %pa = getelementptr i8, ptr %p, i64 8
  %L1 = load <2 x i64>, ptr %pa, align 8
  %pb = getelementptr i8, ptr %p, i64 16
  %L2 = load <2 x i64>, ptr %pb, align 16
  %v1 = shufflevector <2 x i64> %L0, <2 x i64> %L1, <2 x i32> <i32 1, i32 2>
  %res = shufflevector <2 x i64> %v1, <2 x i64> %L2, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  ret <4 x i64> %res
}

; i32
define <4 x i32> @test_i32_4_to_2_success(ptr %x, ptr %y) {
; SSE-LABEL: define <4 x i32> @test_i32_4_to_2_success(
; SSE-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; SSE-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; SSE-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 8
; SSE-NEXT:    [[Y0:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; SSE-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; SSE-NEXT:    [[Y1:%.*]] = load <2 x i32>, ptr [[YA]], align 8
; SSE-NEXT:    [[VX:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[VY:%.*]] = shufflevector <2 x i32> [[Y0]], <2 x i32> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[VX]], <4 x i32> [[VY]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>
; SSE-NEXT:    ret <4 x i32> [[RES]]
;
; AVX-LABEL: define <4 x i32> @test_i32_4_to_2_success(
; AVX-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; AVX-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; AVX-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 8
; AVX-NEXT:    [[Y0:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; AVX-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; AVX-NEXT:    [[Y1:%.*]] = load <2 x i32>, ptr [[YA]], align 8
; AVX-NEXT:    [[TMP1:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 1, i32 3, i32 poison, i32 poison>
; AVX-NEXT:    [[TMP2:%.*]] = shufflevector <2 x i32> [[Y0]], <2 x i32> [[Y1]], <4 x i32> <i32 poison, i32 poison, i32 1, i32 3>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[TMP1]], <4 x i32> [[TMP2]], <4 x i32> <i32 0, i32 1, i32 6, i32 7>
; AVX-NEXT:    ret <4 x i32> [[RES]]
;
  %x0 = load <2 x i32>, ptr %x, align 8
  %xa = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x i32>, ptr %xa, align 8
  %y0 = load <2 x i32>, ptr %y, align 8
  %ya = getelementptr i8, ptr %y, i64 8
  %y1 = load <2 x i32>, ptr %ya, align 8
  %vx = shufflevector <2 x i32> %x0, <2 x i32> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %vy = shufflevector <2 x i32> %y0, <2 x i32> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %res = shufflevector <4 x i32> %vx, <4 x i32> %vy, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  ret <4 x i32> %res
}

define <4 x i32> @test_i32_3_to_1(ptr %p) {
; SSE-LABEL: define <4 x i32> @test_i32_3_to_1(
; SSE-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[L0:%.*]] = load <2 x i32>, ptr [[P]], align 8
; SSE-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; SSE-NEXT:    [[L2:%.*]] = load <2 x i32>, ptr [[P2]], align 8
; SSE-NEXT:    [[RES:%.*]] = shufflevector <2 x i32> [[L0]], <2 x i32> [[L2]], <4 x i32> <i32 0, i32 2, i32 2, i32 3>
; SSE-NEXT:    ret <4 x i32> [[RES]]
;
; AVX-LABEL: define <4 x i32> @test_i32_3_to_1(
; AVX-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[L0:%.*]] = load <2 x i32>, ptr [[P]], align 8
; AVX-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 4
; AVX-NEXT:    [[L1:%.*]] = load <2 x i32>, ptr [[P1]], align 4
; AVX-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; AVX-NEXT:    [[L2:%.*]] = load <2 x i32>, ptr [[P2]], align 8
; AVX-NEXT:    [[V1:%.*]] = shufflevector <2 x i32> [[L0]], <2 x i32> [[L1]], <2 x i32> <i32 0, i32 3>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <2 x i32> [[V1]], <2 x i32> [[L2]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; AVX-NEXT:    ret <4 x i32> [[RES]]
;
  %L0 = load <2 x i32>, ptr %p, align 8
  %p1 = getelementptr i8, ptr %p, i64 4
  %L1 = load <2 x i32>, ptr %p1, align 4
  %p2 = getelementptr i8, ptr %p, i64 8
  %L2 = load <2 x i32>, ptr %p2, align 8
  %v1 = shufflevector <2 x i32> %L0, <2 x i32> %L1, <2 x i32> <i32 0, i32 3>
  %res = shufflevector <2 x i32> %v1, <2 x i32> %L2, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %res
}

; i16
define <8 x i16> @test_i16_4_to_2(ptr %x, ptr %y) {
; SSE-LABEL: define <8 x i16> @test_i16_4_to_2(
; SSE-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[X0:%.*]] = load <2 x i16>, ptr [[X]], align 4
; SSE-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 4
; SSE-NEXT:    [[X1:%.*]] = load <2 x i16>, ptr [[XA]], align 4
; SSE-NEXT:    [[Y0:%.*]] = load <2 x i16>, ptr [[Y]], align 4
; SSE-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 4
; SSE-NEXT:    [[Y1:%.*]] = load <2 x i16>, ptr [[YA]], align 4
; SSE-NEXT:    [[VX:%.*]] = shufflevector <2 x i16> [[X0]], <2 x i16> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[VY:%.*]] = shufflevector <2 x i16> [[Y0]], <2 x i16> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[RES:%.*]] = shufflevector <4 x i16> [[VX]], <4 x i16> [[VY]], <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>
; SSE-NEXT:    ret <8 x i16> [[RES]]
;
; AVX-LABEL: define <8 x i16> @test_i16_4_to_2(
; AVX-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[X0:%.*]] = load <2 x i16>, ptr [[X]], align 4
; AVX-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 4
; AVX-NEXT:    [[X1:%.*]] = load <2 x i16>, ptr [[XA]], align 4
; AVX-NEXT:    [[Y0:%.*]] = load <2 x i16>, ptr [[Y]], align 4
; AVX-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 4
; AVX-NEXT:    [[Y1:%.*]] = load <2 x i16>, ptr [[YA]], align 4
; AVX-NEXT:    [[TMP1:%.*]] = shufflevector <2 x i16> [[X0]], <2 x i16> [[X1]], <8 x i32> <i32 0, i32 poison, i32 1, i32 poison, i32 2, i32 poison, i32 3, i32 poison>
; AVX-NEXT:    [[TMP2:%.*]] = shufflevector <2 x i16> [[Y0]], <2 x i16> [[Y1]], <8 x i32> <i32 poison, i32 0, i32 poison, i32 1, i32 poison, i32 2, i32 poison, i32 3>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> [[TMP2]], <8 x i32> <i32 0, i32 9, i32 2, i32 11, i32 4, i32 13, i32 6, i32 15>
; AVX-NEXT:    ret <8 x i16> [[RES]]
;
  %x0 = load <2 x i16>, ptr %x, align 4
  %xa = getelementptr i8, ptr %x, i64 4
  %x1 = load <2 x i16>, ptr %xa, align 4
  %y0 = load <2 x i16>, ptr %y, align 4
  %ya = getelementptr i8, ptr %y, i64 4
  %y1 = load <2 x i16>, ptr %ya, align 4
  %vx = shufflevector <2 x i16> %x0, <2 x i16> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %vy = shufflevector <2 x i16> %y0, <2 x i16> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %res = shufflevector <4 x i16> %vx, <4 x i16> %vy, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>
  ret <8 x i16> %res
}

define <8 x i16> @test_i16_3_to_1(ptr %p) {
; CHECK-LABEL: define <8 x i16> @test_i16_3_to_1(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i16>, ptr [[P]], align 4
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[L1:%.*]] = load <2 x i16>, ptr [[P1]], align 4
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[L2:%.*]] = load <4 x i16>, ptr [[P2]], align 8
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x i16> [[L0]], <2 x i16> [[L1]], <4 x i32> <i32 1, i32 0, i32 3, i32 2>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i16> [[V1]], <4 x i16> [[L2]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 5, i32 4, i32 7, i32 6>
; CHECK-NEXT:    ret <8 x i16> [[RES]]
;
  %L0 = load <2 x i16>, ptr %p, align 4
  %p1 = getelementptr i8, ptr %p, i64 4
  %L1 = load <2 x i16>, ptr %p1, align 4
  %p2 = getelementptr i8, ptr %p, i64 8
  %L2 = load <4 x i16>, ptr %p2, align 8
  %v1 = shufflevector <2 x i16> %L0, <2 x i16> %L1, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  %res = shufflevector <4 x i16> %v1, <4 x i16> %L2, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 5, i32 4, i32 7, i32 6>
  ret <8 x i16> %res
}

; ============================================================================
; Edge Cases & Safety
; ============================================================================

define <8 x float> @test_19_dead_lanes(ptr %p) {
; CHECK-LABEL: define <8 x float> @test_19_dead_lanes(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L1:%.*]] = load <4 x float>, ptr [[P]], align 16
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 32
; CHECK-NEXT:    [[L2:%.*]] = load <4 x float>, ptr [[GEP]], align 16
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x float> [[L1]], <4 x float> [[L2]], <8 x i32> <i32 0, i32 1, i32 4, i32 5, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    ret <8 x float> [[RES]]
;
  %l1 = load <4 x float>, ptr %p
  %gep = getelementptr inbounds i8, ptr %p, i64 32
  %l2 = load <4 x float>, ptr %gep
  %res = shufflevector <4 x float> %l1, <4 x float> %l2, <8 x i32> <i32 0, i32 1, i32 4, i32 5, i32 poison, i32 poison, i32 poison, i32 poison>
  ret <8 x float> %res
}

; ====================================================================================
; Negative
; ====================================================================================

; Scalar Type Mismatch
define <4 x i32> @test_neg_trunc_mismatch(ptr %p) {
; CHECK-LABEL: define <4 x i32> @test_neg_trunc_mismatch(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i64>, ptr [[P]], align 16
; CHECK-NEXT:    [[T0:%.*]] = trunc <2 x i64> [[L0]] to <2 x i32>
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 16
; CHECK-NEXT:    [[L1:%.*]] = load <2 x i32>, ptr [[P1]], align 8
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x i32> [[T0]], <2 x i32> [[L1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x i32> [[V1]]
;
  %L0 = load <2 x i64>, ptr %p, align 16
  %T0 = trunc <2 x i64> %L0 to <2 x i32>
  %p1 = getelementptr i8, ptr %p, i64 16
  %L1 = load <2 x i32>, ptr %p1, align 8
  %v1 = shufflevector <2 x i32> %T0, <2 x i32> %L1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %v1
}

; Multi-use (hasOneUse() == false)
define <4 x i32> @test_neg_multi_use(ptr %x, ptr %y) {
; SSE-LABEL: define <4 x i32> @test_neg_multi_use(
; SSE-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; SSE-NEXT:    call void @use(<2 x i32> [[X0]])
; SSE-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; SSE-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 8
; SSE-NEXT:    [[Y0:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; SSE-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; SSE-NEXT:    [[Y1:%.*]] = load <2 x i32>, ptr [[YA]], align 8
; SSE-NEXT:    [[VX:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 0, i32 2, i32 1, i32 3>
; SSE-NEXT:    [[VY:%.*]] = shufflevector <2 x i32> [[Y0]], <2 x i32> [[Y1]], <4 x i32> <i32 0, i32 2, i32 1, i32 3>
; SSE-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[VX]], <4 x i32> [[VY]], <4 x i32> <i32 0, i32 1, i32 4, i32 5>
; SSE-NEXT:    ret <4 x i32> [[RES]]
;
; AVX-LABEL: define <4 x i32> @test_neg_multi_use(
; AVX-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; AVX-NEXT:    call void @use(<2 x i32> [[X0]])
; AVX-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; AVX-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 8
; AVX-NEXT:    [[Y0:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; AVX-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; AVX-NEXT:    [[Y1:%.*]] = load <2 x i32>, ptr [[YA]], align 8
; AVX-NEXT:    [[TMP1:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 0, i32 2, i32 poison, i32 poison>
; AVX-NEXT:    [[TMP2:%.*]] = shufflevector <2 x i32> [[Y0]], <2 x i32> [[Y1]], <4 x i32> <i32 poison, i32 poison, i32 0, i32 2>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[TMP1]], <4 x i32> [[TMP2]], <4 x i32> <i32 0, i32 1, i32 6, i32 7>
; AVX-NEXT:    ret <4 x i32> [[RES]]
;
  %x0 = load <2 x i32>, ptr %x, align 8
  call void @use(<2 x i32> %x0)
  %xa = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x i32>, ptr %xa, align 8
  %y0 = load <2 x i32>, ptr %y, align 8
  %ya = getelementptr i8, ptr %y, i64 8
  %y1 = load <2 x i32>, ptr %ya, align 8
  %vx = shufflevector <2 x i32> %x0, <2 x i32> %x1, <4 x i32> <i32 0, i32 2, i32 1, i32 3>
  %vy = shufflevector <2 x i32> %y0, <2 x i32> %y1, <4 x i32> <i32 0, i32 2, i32 1, i32 3>
  %res = shufflevector <4 x i32> %vx, <4 x i32> %vy, <4 x i32> <i32 0, i32 1, i32 4, i32 5>
  ret <4 x i32> %res
}

; Misaligned (Offset % EltSize != 0)
define <4 x i32> @test_neg_misaligned(ptr %x) {
; CHECK-LABEL: define <4 x i32> @test_neg_misaligned(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 2
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 1
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 1, i32 0, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %x0 = load <2 x i32>, ptr %x, align 8
  %xa = getelementptr i8, ptr %x, i64 2
  %x1 = load <2 x i32>, ptr %xa, align 1
  %res = shufflevector <2 x i32> %x0, <2 x i32> %x1, <4 x i32> <i32 1, i32 0, i32 2, i32 3>
  ret <4 x i32> %res
}

; Not a Load (Source is Arithmetic)
define <4 x float> @test_neg_not_a_load(ptr %x) {
; CHECK-LABEL: define <4 x float> @test_neg_not_a_load(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x float>, ptr [[X]], align 8
; CHECK-NEXT:    [[V_ADD:%.*]] = fadd <2 x float> [[X0]], splat (float 1.000000e+00)
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[X1:%.*]] = load <2 x float>, ptr [[XA]], align 8
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x float> [[V_ADD]], <2 x float> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x float> [[RES]]
;
  %x0 = load <2 x float>, ptr %x, align 8
  %v_add = fadd <2 x float> %x0, <float 1.0, float 1.0>
  %xa = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x float>, ptr %xa, align 8
  %res = shufflevector <2 x float> %v_add, <2 x float> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %res
}

; Too Many Bases (Bases > 2)
define <4 x i32> @test_neg_too_many_bases(ptr %x, ptr %y, ptr %z) {
; CHECK-LABEL: define <4 x i32> @test_neg_too_many_bases(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]], ptr [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[LX:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    [[LY:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; CHECK-NEXT:    [[LZ:%.*]] = load <2 x i32>, ptr [[Z]], align 8
; CHECK-NEXT:    [[V_XY:%.*]] = shufflevector <2 x i32> [[LX]], <2 x i32> [[LY]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[V_Z:%.*]] = shufflevector <2 x i32> [[LZ]], <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[V_XY]], <4 x i32> [[V_Z]], <4 x i32> <i32 0, i32 2, i32 4, i32 1>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %lx = load <2 x i32>, ptr %x, align 8
  %ly = load <2 x i32>, ptr %y, align 8
  %lz = load <2 x i32>, ptr %z, align 8
  %v_xy = shufflevector <2 x i32> %lx, <2 x i32> %ly, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v_z = shufflevector <2 x i32> %lz, <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %res = shufflevector <4 x i32> %v_xy, <4 x i32> %v_z, <4 x i32> <i32 0, i32 2, i32 4, i32 1>
  ret <4 x i32> %res
}

define <8 x double> @test_widen_2xf64_with_poison(ptr %p) {
; CHECK-LABEL: define <8 x double> @test_widen_2xf64_with_poison(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L_BIG:%.*]] = load <4 x double>, ptr [[P]], align 32
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 64
; CHECK-NEXT:    [[L_SMALL:%.*]] = load <2 x double>, ptr [[GEP]], align 16
; CHECK-NEXT:    [[L_SMALL_PAD:%.*]] = shufflevector <2 x double> [[L_SMALL]], <2 x double> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x double> [[L_BIG]], <4 x double> [[L_SMALL_PAD]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    ret <8 x double> [[RES]]
;
  %l_big = load <4 x double>, ptr %p, align 32
  %gep = getelementptr inbounds i8, ptr %p, i64 64
  %l_small = load <2 x double>, ptr %gep, align 16
  %l_small_pad = shufflevector <2 x double> %l_small, <2 x double> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %res = shufflevector <4 x double> %l_big, <4 x double> %l_small_pad, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x double> %res
}

define <32 x i8> @test_widen_8xi8_with_poison(ptr %p) {
; SSE-LABEL: define <32 x i8> @test_widen_8xi8_with_poison(
; SSE-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 16
; SSE-NEXT:    [[L_BIG:%.*]] = load <16 x i8>, ptr [[GEP]], align 16
; SSE-NEXT:    [[L_SMALL:%.*]] = load <16 x i8>, ptr [[P]], align 8
; SSE-NEXT:    [[RES:%.*]] = shufflevector <16 x i8> [[L_SMALL]], <16 x i8> [[L_BIG]], <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; SSE-NEXT:    ret <32 x i8> [[RES]]
;
; AVX-LABEL: define <32 x i8> @test_widen_8xi8_with_poison(
; AVX-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[L_SMALL:%.*]] = load <8 x i8>, ptr [[P]], align 8
; AVX-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 16
; AVX-NEXT:    [[L_BIG:%.*]] = load <16 x i8>, ptr [[GEP]], align 16
; AVX-NEXT:    [[L_SMALL_PAD:%.*]] = shufflevector <8 x i8> [[L_SMALL]], <8 x i8> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; AVX-NEXT:    [[RES:%.*]] = shufflevector <16 x i8> [[L_SMALL_PAD]], <16 x i8> [[L_BIG]], <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; AVX-NEXT:    ret <32 x i8> [[RES]]
;
  %l_small = load <8 x i8>, ptr %p, align 8
  %gep = getelementptr inbounds i8, ptr %p, i64 16
  %l_big = load <16 x i8>, ptr %gep, align 16
  %l_small_pad = shufflevector <8 x i8> %l_small, <8 x i8> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
  %res = shufflevector <16 x i8> %l_small_pad, <16 x i8> %l_big, <32 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
  ret <32 x i8> %res
}

