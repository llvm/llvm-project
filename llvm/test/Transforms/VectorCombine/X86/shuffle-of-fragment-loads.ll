; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=sse2 | FileCheck %s --check-prefixes=CHECK,SSE
; RUN: opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=avx2 | FileCheck %s --check-prefixes=CHECK,AVX

declare void @use(<2 x i32>)

; ====================================================================================
; Positive : Consolidate multiple fragmented memory loads and subsequent shuffles into
; one or two wide loads and a single shuffle operation.
; ====================================================================================

define <4 x double> @test_double_4_to_2(ptr %x, ptr %y) {
; CHECK-LABEL: define <4 x double> @test_double_4_to_2(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x double>, ptr [[X]], align 16
; CHECK-NEXT:    [[X_OFF:%.*]] = getelementptr i8, ptr [[X]], i64 16
; CHECK-NEXT:    [[X1:%.*]] = load <2 x double>, ptr [[X_OFF]], align 16
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x double>, ptr [[Y]], align 16
; CHECK-NEXT:    [[Y_OFF:%.*]] = getelementptr i8, ptr [[Y]], i64 16
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x double>, ptr [[Y_OFF]], align 16
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x double> [[X0]], <2 x double> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[V2:%.*]] = shufflevector <2 x double> [[Y0]], <2 x double> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x double> [[V1]], <4 x double> [[V2]], <4 x i32> <i32 0, i32 2, i32 4, i32 6>
; CHECK-NEXT:    ret <4 x double> [[RES]]
;
  %x0 = load <2 x double>, ptr %x
  %x_off = getelementptr i8, ptr %x, i64 16
  %x1 = load <2 x double>, ptr %x_off
  %y0 = load <2 x double>, ptr %y
  %y_off = getelementptr i8, ptr %y, i64 16
  %y1 = load <2 x double>, ptr %y_off
  %v1 = shufflevector <2 x double> %x0, <2 x double> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v2 = shufflevector <2 x double> %y0, <2 x double> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %res = shufflevector <4 x double> %v1, <4 x double> %v2, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  ret <4 x double> %res
}

define <4 x double> @test_double_3_to_1(ptr %p) {
; CHECK-LABEL: define <4 x double> @test_double_3_to_1(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L1:%.*]] = load <2 x double>, ptr [[P]], align 16
; CHECK-NEXT:    [[P_PLUS_8:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[L2:%.*]] = load <2 x double>, ptr [[P_PLUS_8]], align 8
; CHECK-NEXT:    [[P_PLUS_16:%.*]] = getelementptr i8, ptr [[P]], i64 16
; CHECK-NEXT:    [[L3:%.*]] = load <2 x double>, ptr [[P_PLUS_16]], align 16
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x double> [[L1]], <2 x double> [[L2]], <2 x i32> <i32 0, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x double> [[V1]], <2 x double> [[L3]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x double> [[RES]]
;
  %L1 = load <2 x double>, ptr %p, align 16
  %p_plus_8 = getelementptr i8, ptr %p, i64 8
  %L2 = load <2 x double>, ptr %p_plus_8, align 8
  %p_plus_16 = getelementptr i8, ptr %p, i64 16
  %L3 = load <2 x double>, ptr %p_plus_16, align 16
  %v1 = shufflevector <2 x double> %L1, <2 x double> %L2, <2 x i32> <i32 0, i32 3>
  %res = shufflevector <2 x double> %v1, <2 x double> %L3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %res
}

; Float
define <8 x float> @test_float_4_to_2(ptr %x, ptr %y) {
; CHECK-LABEL: define <8 x float> @test_float_4_to_2(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x float>, ptr [[X]], align 8
; CHECK-NEXT:    [[X_OFF:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[X1:%.*]] = load <2 x float>, ptr [[X_OFF]], align 8
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x float>, ptr [[Y]], align 8
; CHECK-NEXT:    [[Y_OFF:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x float>, ptr [[Y_OFF]], align 8
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x float> [[X0]], <2 x float> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[V2:%.*]] = shufflevector <2 x float> [[Y0]], <2 x float> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x float> [[V1]], <4 x float> [[V2]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    ret <8 x float> [[RES]]
;
  %x0 = load <2 x float>, ptr %x
  %x_off = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x float>, ptr %x_off
  %y0 = load <2 x float>, ptr %y
  %y_off = getelementptr i8, ptr %y, i64 8
  %y1 = load <2 x float>, ptr %y_off
  %v1 = shufflevector <2 x float> %x0, <2 x float> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v2 = shufflevector <2 x float> %y0, <2 x float> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v1w = shufflevector <4 x float> %v1, <4 x float> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
  %v2w = shufflevector <4 x float> %v2, <4 x float> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 poison, i32 poison, i32 poison, i32 poison>
  %res = shufflevector <8 x float> %v1w, <8 x float> %v2w, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 10, i32 11>
  ret <8 x float> %res
}

define <4 x float> @test_float_3_to_1(ptr %p) {
; CHECK-LABEL: define <4 x float> @test_float_3_to_1(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L0:%.*]] = load <2 x float>, ptr [[P]], align 8
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[L1:%.*]] = load <2 x float>, ptr [[P1]], align 4
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[L2:%.*]] = load <2 x float>, ptr [[P2]], align 4
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x float> [[L0]], <2 x float> [[L1]], <2 x i32> <i32 0, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x float> [[V1]], <2 x float> [[L2]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x float> [[RES]]
;
  %L0 = load <2 x float>, ptr %p, align 8
  %p1 = getelementptr i8, ptr %p, i64 4
  %L1 = load <2 x float>, ptr %p1, align 4
  %p2 = getelementptr i8, ptr %p, i64 8
  %L2 = load <2 x float>, ptr %p2, align 4
  %v1 = shufflevector <2 x float> %L0, <2 x float> %L1, <2 x i32> <i32 0, i32 3>
  %res = shufflevector <2 x float> %v1, <2 x float> %L2, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %res
}

; i64
define <4 x i64> @test_i64_4_to_2(ptr %x, ptr %y) {
; CHECK-LABEL: define <4 x i64> @test_i64_4_to_2(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i64>, ptr [[X]], align 16
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 16
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i64>, ptr [[XA]], align 16
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x i64>, ptr [[Y]], align 16
; CHECK-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 16
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x i64>, ptr [[YA]], align 16
; CHECK-NEXT:    [[VX:%.*]] = shufflevector <2 x i64> [[X0]], <2 x i64> [[X1]], <4 x i32> <i32 1, i32 0, i32 3, i32 2>
; CHECK-NEXT:    [[VY:%.*]] = shufflevector <2 x i64> [[Y0]], <2 x i64> [[Y1]], <4 x i32> <i32 1, i32 0, i32 3, i32 2>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i64> [[VX]], <4 x i64> [[VY]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>
; CHECK-NEXT:    ret <4 x i64> [[RES]]
;
  %x0 = load <2 x i64>, ptr %x, align 16
  %xa = getelementptr i8, ptr %x, i64 16
  %x1 = load <2 x i64>, ptr %xa, align 16
  %y0 = load <2 x i64>, ptr %y, align 16
  %ya = getelementptr i8, ptr %y, i64 16
  %y1 = load <2 x i64>, ptr %ya, align 16
  %vx = shufflevector <2 x i64> %x0, <2 x i64> %x1, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  %vy = shufflevector <2 x i64> %y0, <2 x i64> %y1, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  %res = shufflevector <4 x i64> %vx, <4 x i64> %vy, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  ret <4 x i64> %res
}

define <4 x i64> @test_i64_3_to_1_success(ptr %p) {
; CHECK-LABEL: define <4 x i64> @test_i64_3_to_1_success(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i64>, ptr [[P]], align 16
; CHECK-NEXT:    [[PA:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[L1:%.*]] = load <2 x i64>, ptr [[PA]], align 8
; CHECK-NEXT:    [[PB:%.*]] = getelementptr i8, ptr [[P]], i64 16
; CHECK-NEXT:    [[L2:%.*]] = load <2 x i64>, ptr [[PB]], align 16
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x i64> [[L0]], <2 x i64> [[L1]], <2 x i32> <i32 1, i32 2>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x i64> [[V1]], <2 x i64> [[L2]], <4 x i32> <i32 1, i32 0, i32 3, i32 2>
; CHECK-NEXT:    ret <4 x i64> [[RES]]
;
  %L0 = load <2 x i64>, ptr %p, align 16
  %pa = getelementptr i8, ptr %p, i64 8
  %L1 = load <2 x i64>, ptr %pa, align 8
  %pb = getelementptr i8, ptr %p, i64 16
  %L2 = load <2 x i64>, ptr %pb, align 16
  %v1 = shufflevector <2 x i64> %L0, <2 x i64> %L1, <2 x i32> <i32 1, i32 2>
  %res = shufflevector <2 x i64> %v1, <2 x i64> %L2, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  ret <4 x i64> %res
}

; i32
define <4 x i32> @test_i32_4_to_2_success(ptr %x, ptr %y) {
; CHECK-LABEL: define <4 x i32> @test_i32_4_to_2_success(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 8
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; CHECK-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x i32>, ptr [[YA]], align 8
; CHECK-NEXT:    [[VX:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[VY:%.*]] = shufflevector <2 x i32> [[Y0]], <2 x i32> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[VX]], <4 x i32> [[VY]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %x0 = load <2 x i32>, ptr %x, align 8
  %xa = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x i32>, ptr %xa, align 8
  %y0 = load <2 x i32>, ptr %y, align 8
  %ya = getelementptr i8, ptr %y, i64 8
  %y1 = load <2 x i32>, ptr %ya, align 8
  %vx = shufflevector <2 x i32> %x0, <2 x i32> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %vy = shufflevector <2 x i32> %y0, <2 x i32> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %res = shufflevector <4 x i32> %vx, <4 x i32> %vy, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  ret <4 x i32> %res
}

define <4 x i32> @test_i32_3_to_1(ptr %p) {
; CHECK-LABEL: define <4 x i32> @test_i32_3_to_1(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i32>, ptr [[P]], align 8
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[L1:%.*]] = load <2 x i32>, ptr [[P1]], align 4
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[L2:%.*]] = load <2 x i32>, ptr [[P2]], align 8
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x i32> [[L0]], <2 x i32> [[L1]], <2 x i32> <i32 0, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x i32> [[V1]], <2 x i32> [[L2]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %L0 = load <2 x i32>, ptr %p, align 8
  %p1 = getelementptr i8, ptr %p, i64 4
  %L1 = load <2 x i32>, ptr %p1, align 4
  %p2 = getelementptr i8, ptr %p, i64 8
  %L2 = load <2 x i32>, ptr %p2, align 8
  %v1 = shufflevector <2 x i32> %L0, <2 x i32> %L1, <2 x i32> <i32 0, i32 3>
  %res = shufflevector <2 x i32> %v1, <2 x i32> %L2, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %res
}

; i16
define <8 x i16> @test_i16_4_to_2(ptr %x, ptr %y) {
; CHECK-LABEL: define <8 x i16> @test_i16_4_to_2(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i16>, ptr [[X]], align 4
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 4
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i16>, ptr [[XA]], align 4
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x i16>, ptr [[Y]], align 4
; CHECK-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 4
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x i16>, ptr [[YA]], align 4
; CHECK-NEXT:    [[VX:%.*]] = shufflevector <2 x i16> [[X0]], <2 x i16> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[VY:%.*]] = shufflevector <2 x i16> [[Y0]], <2 x i16> [[Y1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i16> [[VX]], <4 x i16> [[VY]], <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>
; CHECK-NEXT:    ret <8 x i16> [[RES]]
;
  %x0 = load <2 x i16>, ptr %x, align 4
  %xa = getelementptr i8, ptr %x, i64 4
  %x1 = load <2 x i16>, ptr %xa, align 4
  %y0 = load <2 x i16>, ptr %y, align 4
  %ya = getelementptr i8, ptr %y, i64 4
  %y1 = load <2 x i16>, ptr %ya, align 4
  %vx = shufflevector <2 x i16> %x0, <2 x i16> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %vy = shufflevector <2 x i16> %y0, <2 x i16> %y1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %res = shufflevector <4 x i16> %vx, <4 x i16> %vy, <8 x i32> <i32 0, i32 4, i32 1, i32 5, i32 2, i32 6, i32 3, i32 7>
  ret <8 x i16> %res
}

define <8 x i16> @test_i16_3_to_1(ptr %p) {
; CHECK-LABEL: define <8 x i16> @test_i16_3_to_1(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i16>, ptr [[P]], align 4
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[L1:%.*]] = load <2 x i16>, ptr [[P1]], align 4
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[L2:%.*]] = load <4 x i16>, ptr [[P2]], align 8
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x i16> [[L0]], <2 x i16> [[L1]], <4 x i32> <i32 1, i32 0, i32 3, i32 2>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i16> [[V1]], <4 x i16> [[L2]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 5, i32 4, i32 7, i32 6>
; CHECK-NEXT:    ret <8 x i16> [[RES]]
;
  %L0 = load <2 x i16>, ptr %p, align 4
  %p1 = getelementptr i8, ptr %p, i64 4
  %L1 = load <2 x i16>, ptr %p1, align 4
  %p2 = getelementptr i8, ptr %p, i64 8
  %L2 = load <4 x i16>, ptr %p2, align 8
  %v1 = shufflevector <2 x i16> %L0, <2 x i16> %L1, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  %res = shufflevector <4 x i16> %v1, <4 x i16> %L2, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 5, i32 4, i32 7, i32 6>
  ret <8 x i16> %res
}

; ====================================================================================
; Negative
; ====================================================================================

; Negative Case 1: Scalar Type Mismatch
define <4 x i32> @test_neg_trunc_mismatch(ptr %p) {
; CHECK-LABEL: define <4 x i32> @test_neg_trunc_mismatch(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i64>, ptr [[P]], align 16
; CHECK-NEXT:    [[T0:%.*]] = trunc <2 x i64> [[L0]] to <2 x i32>
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 16
; CHECK-NEXT:    [[L1:%.*]] = load <2 x i32>, ptr [[P1]], align 8
; CHECK-NEXT:    [[V1:%.*]] = shufflevector <2 x i32> [[T0]], <2 x i32> [[L1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x i32> [[V1]]
;
  %L0 = load <2 x i64>, ptr %p, align 16
  %T0 = trunc <2 x i64> %L0 to <2 x i32>
  %p1 = getelementptr i8, ptr %p, i64 16
  %L1 = load <2 x i32>, ptr %p1, align 8
  %v1 = shufflevector <2 x i32> %T0, <2 x i32> %L1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %v1
}

; Negative Case 2: Multi-use (hasOneUse() == false)
define <4 x i32> @test_neg_multi_use(ptr %x, ptr %y) {
; CHECK-LABEL: define <4 x i32> @test_neg_multi_use(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    call void @use(<2 x i32> [[X0]])
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 8
; CHECK-NEXT:    [[Y0:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; CHECK-NEXT:    [[YA:%.*]] = getelementptr i8, ptr [[Y]], i64 8
; CHECK-NEXT:    [[Y1:%.*]] = load <2 x i32>, ptr [[YA]], align 8
; CHECK-NEXT:    [[VX:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 0, i32 2, i32 1, i32 3>
; CHECK-NEXT:    [[VY:%.*]] = shufflevector <2 x i32> [[Y0]], <2 x i32> [[Y1]], <4 x i32> <i32 0, i32 2, i32 1, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[VX]], <4 x i32> [[VY]], <4 x i32> <i32 0, i32 1, i32 4, i32 5>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %x0 = load <2 x i32>, ptr %x, align 8
  call void @use(<2 x i32> %x0)
  %xa = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x i32>, ptr %xa, align 8
  %y0 = load <2 x i32>, ptr %y, align 8
  %ya = getelementptr i8, ptr %y, i64 8
  %y1 = load <2 x i32>, ptr %ya, align 8
  %vx = shufflevector <2 x i32> %x0, <2 x i32> %x1, <4 x i32> <i32 0, i32 2, i32 1, i32 3>
  %vy = shufflevector <2 x i32> %y0, <2 x i32> %y1, <4 x i32> <i32 0, i32 2, i32 1, i32 3>
  %res = shufflevector <4 x i32> %vx, <4 x i32> %vy, <4 x i32> <i32 0, i32 1, i32 4, i32 5>
  ret <4 x i32> %res
}

; Negative Case 3: Offset (16) is out of target vector range (16 bytes)
define <4 x i32> @test_neg_out_of_range(ptr %x) {
; CHECK-LABEL: define <4 x i32> @test_neg_out_of_range(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 16
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 8
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 1, i32 0, i32 3, i32 2>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %x0 = load <2 x i32>, ptr %x, align 8
  %xa = getelementptr i8, ptr %x, i64 16
  %x1 = load <2 x i32>, ptr %xa, align 8
  %res = shufflevector <2 x i32> %x0, <2 x i32> %x1, <4 x i32> <i32 1, i32 0, i32 3, i32 2>
  ret <4 x i32> %res
}

; Negative Case 4: Misaligned (Offset % EltSize != 0)
define <4 x i32> @test_neg_misaligned(ptr %x) {
; CHECK-LABEL: define <4 x i32> @test_neg_misaligned(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 2
; CHECK-NEXT:    [[X1:%.*]] = load <2 x i32>, ptr [[XA]], align 1
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x i32> [[X0]], <2 x i32> [[X1]], <4 x i32> <i32 1, i32 0, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %x0 = load <2 x i32>, ptr %x, align 8
  %xa = getelementptr i8, ptr %x, i64 2
  %x1 = load <2 x i32>, ptr %xa, align 1
  %res = shufflevector <2 x i32> %x0, <2 x i32> %x1, <4 x i32> <i32 1, i32 0, i32 2, i32 3>
  ret <4 x i32> %res
}

; Negative Case 5: Not a Load (Source is Arithmetic)
define <4 x float> @test_neg_not_a_load(ptr %x) {
; CHECK-LABEL: define <4 x float> @test_neg_not_a_load(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X0:%.*]] = load <2 x float>, ptr [[X]], align 8
; CHECK-NEXT:    [[V_ADD:%.*]] = fadd <2 x float> [[X0]], splat (float 1.000000e+00)
; CHECK-NEXT:    [[XA:%.*]] = getelementptr i8, ptr [[X]], i64 8
; CHECK-NEXT:    [[X1:%.*]] = load <2 x float>, ptr [[XA]], align 8
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <2 x float> [[V_ADD]], <2 x float> [[X1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    ret <4 x float> [[RES]]
;
  %x0 = load <2 x float>, ptr %x, align 8
  %v_add = fadd <2 x float> %x0, <float 1.0, float 1.0>
  %xa = getelementptr i8, ptr %x, i64 8
  %x1 = load <2 x float>, ptr %xa, align 8
  %res = shufflevector <2 x float> %v_add, <2 x float> %x1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %res
}

; Negative Case 6: Too Many Bases (Bases > 2)
define <4 x i32> @test_neg_too_many_bases(ptr %x, ptr %y, ptr %z) {
; CHECK-LABEL: define <4 x i32> @test_neg_too_many_bases(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Y:%.*]], ptr [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[LX:%.*]] = load <2 x i32>, ptr [[X]], align 8
; CHECK-NEXT:    [[LY:%.*]] = load <2 x i32>, ptr [[Y]], align 8
; CHECK-NEXT:    [[LZ:%.*]] = load <2 x i32>, ptr [[Z]], align 8
; CHECK-NEXT:    [[V_XY:%.*]] = shufflevector <2 x i32> [[LX]], <2 x i32> [[LY]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[V_Z:%.*]] = shufflevector <2 x i32> [[LZ]], <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
; CHECK-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[V_XY]], <4 x i32> [[V_Z]], <4 x i32> <i32 0, i32 2, i32 4, i32 1>
; CHECK-NEXT:    ret <4 x i32> [[RES]]
;
  %lx = load <2 x i32>, ptr %x, align 8
  %ly = load <2 x i32>, ptr %y, align 8
  %lz = load <2 x i32>, ptr %z, align 8
  %v_xy = shufflevector <2 x i32> %lx, <2 x i32> %ly, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %v_z = shufflevector <2 x i32> %lz, <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %res = shufflevector <4 x i32> %v_xy, <4 x i32> %v_z, <4 x i32> <i32 0, i32 2, i32 4, i32 1>
  ret <4 x i32> %res
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; AVX: {{.*}}
; SSE: {{.*}}
