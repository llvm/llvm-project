; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=SSE2 | FileCheck %s --check-prefixes=CHECK,SSE
; RUN: opt < %s -passes=vector-combine -S -mtriple=x86_64-- -mattr=AVX2 | FileCheck %s --check-prefixes=CHECK,AVX

declare void @use(<4 x i32>)

; Shuffle is much cheaper than fdiv. FMF are intersected.

define <4 x float> @shuf_fdiv_v4f32_yy(<4 x float> %x, <4 x float> %y, <4 x float> %z) {
; CHECK-LABEL: define <4 x float> @shuf_fdiv_v4f32_yy(
; CHECK-SAME: <4 x float> [[X:%.*]], <4 x float> [[Y:%.*]], <4 x float> [[Z:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> poison, <4 x i32> <i32 1, i32 3, i32 1, i32 3>
; CHECK-NEXT:    [[R:%.*]] = fdiv arcp <4 x float> [[TMP2]], [[TMP3]]
; CHECK-NEXT:    ret <4 x float> [[R]]
;
  %b0 = fdiv fast <4 x float> %x, %y
  %b1 = fdiv arcp <4 x float> %z, %y
  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  ret <4 x float> %r
}

; Common operand is op0 of the binops.

define <4 x i32> @shuf_add_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: define <4 x i32> @shuf_add_v4i32_xx(
; CHECK-SAME: <4 x i32> [[X:%.*]], <4 x i32> [[Y:%.*]], <4 x i32> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[B0:%.*]] = add <4 x i32> [[X]], [[Y]]
; CHECK-NEXT:    [[B1:%.*]] = add <4 x i32> [[X]], [[Z]]
; CHECK-NEXT:    [[R2:%.*]] = shufflevector <4 x i32> [[B0]], <4 x i32> [[B1]], <4 x i32> <i32 poison, i32 poison, i32 6, i32 0>
; CHECK-NEXT:    ret <4 x i32> [[R2]]
;
  %b0 = add <4 x i32> %x, %y
  %b1 = add <4 x i32> %x, %z
  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 poison, i32 poison, i32 6, i32 0>
  ret <4 x i32> %r
}

; For commutative instructions, common operand may be swapped (SSE - expensive fmul vs AVX - cheap fmul)

define <4 x float> @shuf_fmul_v4f32_xx_swap(<4 x float> %x, <4 x float> %y, <4 x float> %z) {
; SSE-LABEL: define <4 x float> @shuf_fmul_v4f32_xx_swap(
; SSE-SAME: <4 x float> [[X:%.*]], <4 x float> [[Y:%.*]], <4 x float> [[Z:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[TMP1:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[Z]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>
; SSE-NEXT:    [[TMP2:%.*]] = shufflevector <4 x float> [[X]], <4 x float> poison, <4 x i32> <i32 0, i32 3, i32 0, i32 3>
; SSE-NEXT:    [[R:%.*]] = fmul <4 x float> [[TMP1]], [[TMP2]]
; SSE-NEXT:    ret <4 x float> [[R]]
;
; AVX-LABEL: define <4 x float> @shuf_fmul_v4f32_xx_swap(
; AVX-SAME: <4 x float> [[X:%.*]], <4 x float> [[Y:%.*]], <4 x float> [[Z:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[B0:%.*]] = fmul <4 x float> [[X]], [[Y]]
; AVX-NEXT:    [[B1:%.*]] = fmul <4 x float> [[Z]], [[X]]
; AVX-NEXT:    [[R:%.*]] = shufflevector <4 x float> [[B0]], <4 x float> [[B1]], <4 x i32> <i32 0, i32 3, i32 4, i32 7>
; AVX-NEXT:    ret <4 x float> [[R]]
;
  %b0 = fmul <4 x float> %x, %y
  %b1 = fmul <4 x float> %z, %x
  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 0, i32 3, i32 4, i32 7>
  ret <4 x float> %r
}

; For repeated ops, don't repeat the shuffle cost.

define <8 x float> @shuf_fmul_v4f32_self_mul(<4 x float> %a0, <4 x float> %a1) {
; CHECK-LABEL: define <8 x float> @shuf_fmul_v4f32_self_mul(
; CHECK-SAME: <4 x float> [[A0:%.*]], <4 x float> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x float> [[A0]], <4 x float> [[A1]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    [[R:%.*]] = fmul <8 x float> [[TMP1]], [[TMP1]]
; CHECK-NEXT:    ret <8 x float> [[R]]
;
  %m0 = fmul <4 x float> %a0, %a0
  %m1 = fmul <4 x float> %a1, %a1
  %r = shufflevector <4 x float> %m0, <4 x float> %m1, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %r
}

; For commutative instructions, common operand may be swapped.

define <2 x i64> @shuf_and_v2i64_yy_swap(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) {
; CHECK-LABEL: define <2 x i64> @shuf_and_v2i64_yy_swap(
; CHECK-SAME: <2 x i64> [[X:%.*]], <2 x i64> [[Y:%.*]], <2 x i64> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[B0:%.*]] = and <2 x i64> [[X]], [[Y]]
; CHECK-NEXT:    [[B1:%.*]] = and <2 x i64> [[Y]], [[Z]]
; CHECK-NEXT:    [[R:%.*]] = shufflevector <2 x i64> [[B0]], <2 x i64> [[B1]], <2 x i32> <i32 3, i32 0>
; CHECK-NEXT:    ret <2 x i64> [[R]]
;
  %b0 = and <2 x i64> %x, %y
  %b1 = and <2 x i64> %y, %z
  %r = shufflevector <2 x i64> %b0, <2 x i64> %b1, <2 x i32> <i32 3, i32 0>
  ret <2 x i64> %r
}

; non-commutative binop, but common op0

define <4 x i32> @shuf_shl_v4i32_xx(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: define <4 x i32> @shuf_shl_v4i32_xx(
; CHECK-SAME: <4 x i32> [[X:%.*]], <4 x i32> [[Y:%.*]], <4 x i32> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> poison, <4 x i32> <i32 3, i32 1, i32 1, i32 2>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[Y]], <4 x i32> [[Z]], <4 x i32> <i32 3, i32 1, i32 1, i32 6>
; CHECK-NEXT:    [[R:%.*]] = shl <4 x i32> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    ret <4 x i32> [[R]]
;
  %b0 = shl <4 x i32> %x, %y
  %b1 = shl <4 x i32> %x, %z
  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 1, i32 1, i32 6>
  ret <4 x i32> %r
}

; common operand, but not commutable (SSE - expensive vector shift vs AVX2 - cheap vector shift)

define <4 x i32> @shuf_shl_v4i32_xx_swap(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; SSE-LABEL: define <4 x i32> @shuf_shl_v4i32_xx_swap(
; SSE-SAME: <4 x i32> [[X:%.*]], <4 x i32> [[Y:%.*]], <4 x i32> [[Z:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[X]], <4 x i32> [[Z]], <4 x i32> <i32 3, i32 2, i32 2, i32 5>
; SSE-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[Y]], <4 x i32> [[X]], <4 x i32> <i32 3, i32 2, i32 2, i32 5>
; SSE-NEXT:    [[R:%.*]] = shl <4 x i32> [[TMP1]], [[TMP2]]
; SSE-NEXT:    ret <4 x i32> [[R]]
;
; AVX-LABEL: define <4 x i32> @shuf_shl_v4i32_xx_swap(
; AVX-SAME: <4 x i32> [[X:%.*]], <4 x i32> [[Y:%.*]], <4 x i32> [[Z:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[B0:%.*]] = shl <4 x i32> [[X]], [[Y]]
; AVX-NEXT:    [[B1:%.*]] = shl <4 x i32> [[Z]], [[X]]
; AVX-NEXT:    [[R:%.*]] = shufflevector <4 x i32> [[B0]], <4 x i32> [[B1]], <4 x i32> <i32 3, i32 2, i32 2, i32 5>
; AVX-NEXT:    ret <4 x i32> [[R]]
;
  %b0 = shl <4 x i32> %x, %y
  %b1 = shl <4 x i32> %z, %x
  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 3, i32 2, i32 2, i32 5>
  ret <4 x i32> %r
}

; negative test - mismatched opcodes

define <2 x i64> @shuf_sub_add_v2i64_yy(<2 x i64> %x, <2 x i64> %y, <2 x i64> %z) {
; CHECK-LABEL: define <2 x i64> @shuf_sub_add_v2i64_yy(
; CHECK-SAME: <2 x i64> [[X:%.*]], <2 x i64> [[Y:%.*]], <2 x i64> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[B0:%.*]] = sub <2 x i64> [[X]], [[Y]]
; CHECK-NEXT:    [[B1:%.*]] = add <2 x i64> [[Z]], [[Y]]
; CHECK-NEXT:    [[R:%.*]] = shufflevector <2 x i64> [[B0]], <2 x i64> [[B1]], <2 x i32> <i32 3, i32 0>
; CHECK-NEXT:    ret <2 x i64> [[R]]
;
  %b0 = sub <2 x i64> %x, %y
  %b1 = add <2 x i64> %z, %y
  %r = shufflevector <2 x i64> %b0, <2 x i64> %b1, <2 x i32> <i32 3, i32 0>
  ret <2 x i64> %r
}

; type change via shuffle

define <8 x float> @shuf_fmul_v4f32_xx_type(<4 x float> %x, <4 x float> %y, <4 x float> %z) {
; CHECK-LABEL: define <8 x float> @shuf_fmul_v4f32_xx_type(
; CHECK-SAME: <4 x float> [[X:%.*]], <4 x float> [[Y:%.*]], <4 x float> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[B0:%.*]] = fmul <4 x float> [[X]], [[Y]]
; CHECK-NEXT:    [[B1:%.*]] = fmul <4 x float> [[Z]], [[X]]
; CHECK-NEXT:    [[R:%.*]] = shufflevector <4 x float> [[B0]], <4 x float> [[B1]], <8 x i32> <i32 0, i32 3, i32 4, i32 7, i32 0, i32 1, i32 1, i32 6>
; CHECK-NEXT:    ret <8 x float> [[R]]
;
  %b0 = fmul <4 x float> %x, %y
  %b1 = fmul <4 x float> %z, %x
  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <8 x i32> <i32 0, i32 3, i32 4, i32 7, i32 0, i32 1, i32 1, i32 6>
  ret <8 x float> %r
}

; negative test - uses

define <4 x i32> @shuf_lshr_v4i32_yy_use1(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: define <4 x i32> @shuf_lshr_v4i32_yy_use1(
; CHECK-SAME: <4 x i32> [[X:%.*]], <4 x i32> [[Y:%.*]], <4 x i32> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[B0:%.*]] = lshr <4 x i32> [[X]], [[Y]]
; CHECK-NEXT:    call void @use(<4 x i32> [[B0]])
; CHECK-NEXT:    [[B1:%.*]] = lshr <4 x i32> [[Z]], [[Y]]
; CHECK-NEXT:    [[R:%.*]] = shufflevector <4 x i32> [[B0]], <4 x i32> [[B1]], <4 x i32> <i32 0, i32 2, i32 4, i32 6>
; CHECK-NEXT:    ret <4 x i32> [[R]]
;
  %b0 = lshr <4 x i32> %x, %y
  call void @use(<4 x i32> %b0)
  %b1 = lshr <4 x i32> %z, %y
  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  ret <4 x i32> %r
}

; negative test - uses

define <4 x i32> @shuf_mul_v4i32_yy_use2(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: define <4 x i32> @shuf_mul_v4i32_yy_use2(
; CHECK-SAME: <4 x i32> [[X:%.*]], <4 x i32> [[Y:%.*]], <4 x i32> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[B0:%.*]] = mul <4 x i32> [[X]], [[Y]]
; CHECK-NEXT:    [[B1:%.*]] = mul <4 x i32> [[Z]], [[Y]]
; CHECK-NEXT:    call void @use(<4 x i32> [[B1]])
; CHECK-NEXT:    [[R:%.*]] = shufflevector <4 x i32> [[B0]], <4 x i32> [[B1]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>
; CHECK-NEXT:    ret <4 x i32> [[R]]
;
  %b0 = mul <4 x i32> %x, %y
  %b1 = mul <4 x i32> %z, %y
  call void @use(<4 x i32> %b1)
  %r = shufflevector <4 x i32> %b0, <4 x i32> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  ret <4 x i32> %r
}

; non-matching operands (not commutable)

define <4 x float> @shuf_fdiv_v4f32_no_common_op(<4 x float> %x, <4 x float> %y, <4 x float> %z, <4 x float> %w) {
; CHECK-LABEL: define <4 x float> @shuf_fdiv_v4f32_no_common_op(
; CHECK-SAME: <4 x float> [[X:%.*]], <4 x float> [[Y:%.*]], <4 x float> [[Z:%.*]], <4 x float> [[W:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x float> [[X]], <4 x float> [[Z]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x float> [[Y]], <4 x float> [[W]], <4 x i32> <i32 1, i32 3, i32 5, i32 7>
; CHECK-NEXT:    [[R:%.*]] = fdiv <4 x float> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    ret <4 x float> [[R]]
;
  %b0 = fdiv <4 x float> %x, %y
  %b1 = fdiv <4 x float> %z, %w
  %r = shufflevector <4 x float> %b0, <4 x float> %b1, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  ret <4 x float> %r
}

; negative test - binops may be relatively cheap

define <16 x i16> @shuf_and_v16i16_yy_expensive_shuf(<16 x i16> %x, <16 x i16> %y, <16 x i16> %z) {
; CHECK-LABEL: define <16 x i16> @shuf_and_v16i16_yy_expensive_shuf(
; CHECK-SAME: <16 x i16> [[X:%.*]], <16 x i16> [[Y:%.*]], <16 x i16> [[Z:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[B0:%.*]] = and <16 x i16> [[X]], [[Y]]
; CHECK-NEXT:    [[B1:%.*]] = and <16 x i16> [[Y]], [[Z]]
; CHECK-NEXT:    [[R:%.*]] = shufflevector <16 x i16> [[B0]], <16 x i16> [[B1]], <16 x i32> <i32 15, i32 22, i32 25, i32 13, i32 28, i32 0, i32 poison, i32 3, i32 0, i32 30, i32 3, i32 7, i32 9, i32 19, i32 2, i32 22>
; CHECK-NEXT:    ret <16 x i16> [[R]]
;
  %b0 = and <16 x i16> %x, %y
  %b1 = and <16 x i16> %y, %z
  %r = shufflevector <16 x i16> %b0, <16 x i16> %b1, <16 x i32> <i32 15, i32 22, i32 25, i32 13, i32 28, i32 0, i32 poison, i32 3, i32 0, i32 30, i32 3, i32 7, i32 9, i32 19, i32 2, i32 22>
  ret <16 x i16> %r
}

; negative test - don't fold shuffle(divrem(x,y),divrem(z,w)) if mask contains poison (PR89390)

define <4 x i32> @shuf_srem_v4i32_poison(<4 x i32> %a0, <4 x i32> %a1) {
; CHECK-LABEL: define <4 x i32> @shuf_srem_v4i32_poison(
; CHECK-SAME: <4 x i32> [[A0:%.*]], <4 x i32> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SREM0:%.*]] = srem <4 x i32> [[A1]], [[A0]]
; CHECK-NEXT:    [[SREM1:%.*]] = srem <4 x i32> splat (i32 1), [[A0]]
; CHECK-NEXT:    [[R:%.*]] = shufflevector <4 x i32> [[SREM0]], <4 x i32> [[SREM1]], <4 x i32> <i32 0, i32 poison, i32 6, i32 3>
; CHECK-NEXT:    ret <4 x i32> [[R]]
;
  %srem0 = srem <4 x i32> %a1, %a0
  %srem1 = srem <4 x i32> <i32 1, i32 1, i32 1, i32 1>, %a0
  %r = shufflevector <4 x i32> %srem0, <4 x i32> %srem1, <4 x i32> <i32 0, i32 poison, i32 6, i32 3>
  ret <4 x i32> %r
}

; Uniform constant shift v16i16

define <16 x i16> @shuf_uniform_shift_v16i16_v8i16(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: define <16 x i16> @shuf_uniform_shift_v16i16_v8i16(
; CHECK-SAME: <8 x i16> [[A0:%.*]], <8 x i16> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x i16> [[A0]], <8 x i16> [[A1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[RES:%.*]] = shl <16 x i16> [[TMP1]], splat (i16 7)
; CHECK-NEXT:    ret <16 x i16> [[RES]]
;
  %v0 = shl <8 x i16> %a0, splat (i16 7)
  %v1 = shl <8 x i16> %a1, splat (i16 7)
  %res  = shufflevector <8 x i16> %v0, <8 x i16> %v1, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i16> %res
}

; Nonuniform constant shift v16i16

define <16 x i16> @shuf_nonuniform_shift_v16i16_v8i16(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: define <16 x i16> @shuf_nonuniform_shift_v16i16_v8i16(
; CHECK-SAME: <8 x i16> [[A0:%.*]], <8 x i16> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x i16> [[A0]], <8 x i16> [[A1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[RES:%.*]] = shl <16 x i16> [[TMP1]], <i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2>
; CHECK-NEXT:    ret <16 x i16> [[RES]]
;
  %v0 = shl <8 x i16> %a0, <i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2>
  %v1 = shl <8 x i16> %a1, <i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2>
  %res  = shufflevector <8 x i16> %v0, <8 x i16> %v1, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i16> %res
}

; Variable shift (Non-uniform & Non-constant) v8i32

define <8 x i32> @shuf_variable_shl_v8i32_v4i32(<4 x i32> %a0, <4 x i32> %a1, <4 x i32> %sh0, <4 x i32> %sh1) {
; SSE-LABEL: define <8 x i32> @shuf_variable_shl_v8i32_v4i32(
; SSE-SAME: <4 x i32> [[A0:%.*]], <4 x i32> [[A1:%.*]], <4 x i32> [[SH0:%.*]], <4 x i32> [[SH1:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[A0]], <4 x i32> [[A1]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; SSE-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[SH0]], <4 x i32> [[SH1]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; SSE-NEXT:    [[RES:%.*]] = shl <8 x i32> [[TMP1]], [[TMP2]]
; SSE-NEXT:    ret <8 x i32> [[RES]]
;
; AVX-LABEL: define <8 x i32> @shuf_variable_shl_v8i32_v4i32(
; AVX-SAME: <4 x i32> [[A0:%.*]], <4 x i32> [[A1:%.*]], <4 x i32> [[SH0:%.*]], <4 x i32> [[SH1:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[V0:%.*]] = shl <4 x i32> [[A0]], [[SH0]]
; AVX-NEXT:    [[V1:%.*]] = shl <4 x i32> [[A1]], [[SH1]]
; AVX-NEXT:    [[RES:%.*]] = shufflevector <4 x i32> [[V0]], <4 x i32> [[V1]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; AVX-NEXT:    ret <8 x i32> [[RES]]
;
  %v0 = shl <4 x i32> %a0, %sh0
  %v1 = shl <4 x i32> %a1, %sh1
  %res = shufflevector <4 x i32> %v0, <4 x i32> %v1, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x i32> %res
}

; Variable shift v4i64

define <4 x i64> @shuf_variable_shl_v4i64_v2i64(<2 x i64> %a0, <2 x i64> %a1, <2 x i64> %sh0, <2 x i64> %sh1) {
; SSE-LABEL: define <4 x i64> @shuf_variable_shl_v4i64_v2i64(
; SSE-SAME: <2 x i64> [[A0:%.*]], <2 x i64> [[A1:%.*]], <2 x i64> [[SH0:%.*]], <2 x i64> [[SH1:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[TMP1:%.*]] = shufflevector <2 x i64> [[A0]], <2 x i64> [[A1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[TMP2:%.*]] = shufflevector <2 x i64> [[SH0]], <2 x i64> [[SH1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; SSE-NEXT:    [[RES:%.*]] = shl <4 x i64> [[TMP1]], [[TMP2]]
; SSE-NEXT:    ret <4 x i64> [[RES]]
;
; AVX-LABEL: define <4 x i64> @shuf_variable_shl_v4i64_v2i64(
; AVX-SAME: <2 x i64> [[A0:%.*]], <2 x i64> [[A1:%.*]], <2 x i64> [[SH0:%.*]], <2 x i64> [[SH1:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[V0:%.*]] = shl <2 x i64> [[A0]], [[SH0]]
; AVX-NEXT:    [[V1:%.*]] = shl <2 x i64> [[A1]], [[SH1]]
; AVX-NEXT:    [[RES:%.*]] = shufflevector <2 x i64> [[V0]], <2 x i64> [[V1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; AVX-NEXT:    ret <4 x i64> [[RES]]
;
  %v0 = shl <2 x i64> %a0, %sh0
  %v1 = shl <2 x i64> %a1, %sh1
  %res = shufflevector <2 x i64> %v0, <2 x i64> %v1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i64> %res
}

; Uniform constant shift right v16i8

define <16 x i8> @shuf_uniform_ashr_v16i8_v8i8(<8 x i8> %a0, <8 x i8> %a1) {
; CHECK-LABEL: define <16 x i8> @shuf_uniform_ashr_v16i8_v8i8(
; CHECK-SAME: <8 x i8> [[A0:%.*]], <8 x i8> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x i8> [[A0]], <8 x i8> [[A1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[RES:%.*]] = ashr <16 x i8> [[TMP1]], splat (i8 7)
; CHECK-NEXT:    ret <16 x i8> [[RES]]
;
  %v0 = ashr <8 x i8> %a0, splat (i8 7)
  %v1 = ashr <8 x i8> %a1, splat (i8 7)
  %res = shufflevector <8 x i8> %v0, <8 x i8> %v1, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i8> %res
}

; Uniform constant shift right v4i64

define <4 x i64> @shuf_uniform_ashr_v4i64_v2i64(<2 x i64> %a0, <2 x i64> %a1) {
; CHECK-LABEL: define <4 x i64> @shuf_uniform_ashr_v4i64_v2i64(
; CHECK-SAME: <2 x i64> [[A0:%.*]], <2 x i64> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <2 x i64> [[A0]], <2 x i64> [[A1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[RES:%.*]] = ashr <4 x i64> [[TMP1]], splat (i64 7)
; CHECK-NEXT:    ret <4 x i64> [[RES]]
;
  %v0 = ashr <2 x i64> %a0, <i64 7, i64 7>
  %v1 = ashr <2 x i64> %a1, <i64 7, i64 7>
  %res = shufflevector <2 x i64> %v0, <2 x i64> %v1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i64> %res
}

; Uniform constant & pow2 mul v16i16

define <16 x i16> @shuf_uniform_mul_v16i16_v8i16(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: define <16 x i16> @shuf_uniform_mul_v16i16_v8i16(
; CHECK-SAME: <8 x i16> [[A0:%.*]], <8 x i16> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x i16> [[A0]], <8 x i16> [[A1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[RES:%.*]] = mul <16 x i16> [[TMP1]], <i16 4, i16 4, i16 4, i16 4, i16 4, i16 4, i16 4, i16 4, i16 8, i16 8, i16 8, i16 8, i16 8, i16 8, i16 8, i16 8>
; CHECK-NEXT:    ret <16 x i16> [[RES]]
;
  %v0 = mul <8 x i16> %a0, splat(i16 4)
  %v1 = mul <8 x i16> %a1, splat(i16 8)
  %res  = shufflevector <8 x i16> %v0, <8 x i16> %v1, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i16> %res
}

; Nonuniform constant mul

define <16 x i16> @shuf_nonuniform_const_mul_v16i16_v8i16(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: define <16 x i16> @shuf_nonuniform_const_mul_v16i16_v8i16(
; CHECK-SAME: <8 x i16> [[A0:%.*]], <8 x i16> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x i16> [[A0]], <8 x i16> [[A1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[RES:%.*]] = mul <16 x i16> [[TMP1]], <i16 1, i16 2, i16 3, i16 4, i16 5, i16 6, i16 7, i16 8, i16 1, i16 2, i16 3, i16 4, i16 5, i16 6, i16 7, i16 8>
; CHECK-NEXT:    ret <16 x i16> [[RES]]
;
  %v0 = mul <8 x i16> %a0, <i16 1, i16 2, i16 3, i16 4, i16 5, i16 6, i16 7, i16 8>
  %v1 = mul <8 x i16> %a1, <i16 1, i16 2, i16 3, i16 4, i16 5, i16 6, i16 7, i16 8>
  %res = shufflevector <8 x i16> %v0, <8 x i16> %v1, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i16> %res
}

; Uniform constant & non-pow2 mul v16i16

define <16 x i16> @shuf_uniform_mul_non_pow2_v16i16_v8i16(<8 x i16> %a0, <8 x i16> %a1) {
; CHECK-LABEL: define <16 x i16> @shuf_uniform_mul_non_pow2_v16i16_v8i16(
; CHECK-SAME: <8 x i16> [[A0:%.*]], <8 x i16> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x i16> [[A0]], <8 x i16> [[A1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[RES:%.*]] = mul <16 x i16> [[TMP1]], splat (i16 3)
; CHECK-NEXT:    ret <16 x i16> [[RES]]
;
  %v0 = mul <8 x i16> %a0, splat(i16 3)
  %v1 = mul <8 x i16> %a1, splat(i16 3)
  %res  = shufflevector <8 x i16> %v0, <8 x i16> %v1, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i16> %res
}

; Uniform non-constant mul

define <16 x i16> @shuf_uniform_runtime_mul_v16i16_v8i16(<8 x i16> %a0, <8 x i16> %a1, i16 %x) {
; SSE-LABEL: define <16 x i16> @shuf_uniform_runtime_mul_v16i16_v8i16(
; SSE-SAME: <8 x i16> [[A0:%.*]], <8 x i16> [[A1:%.*]], i16 [[X:%.*]]) #[[ATTR0]] {
; SSE-NEXT:    [[SPLAT_SPLATINSERT:%.*]] = insertelement <8 x i16> poison, i16 [[X]], i64 0
; SSE-NEXT:    [[TMP1:%.*]] = shufflevector <8 x i16> [[A0]], <8 x i16> [[A1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; SSE-NEXT:    [[TMP2:%.*]] = shufflevector <8 x i16> [[SPLAT_SPLATINSERT]], <8 x i16> poison, <16 x i32> zeroinitializer
; SSE-NEXT:    [[RES:%.*]] = mul <16 x i16> [[TMP1]], [[TMP2]]
; SSE-NEXT:    ret <16 x i16> [[RES]]
;
; AVX-LABEL: define <16 x i16> @shuf_uniform_runtime_mul_v16i16_v8i16(
; AVX-SAME: <8 x i16> [[A0:%.*]], <8 x i16> [[A1:%.*]], i16 [[X:%.*]]) #[[ATTR0]] {
; AVX-NEXT:    [[SPLAT_SPLATINSERT:%.*]] = insertelement <8 x i16> poison, i16 [[X]], i64 0
; AVX-NEXT:    [[SPLAT_SPLAT:%.*]] = shufflevector <8 x i16> [[SPLAT_SPLATINSERT]], <8 x i16> poison, <8 x i32> zeroinitializer
; AVX-NEXT:    [[V0:%.*]] = mul <8 x i16> [[A0]], [[SPLAT_SPLAT]]
; AVX-NEXT:    [[V1:%.*]] = mul <8 x i16> [[A1]], [[SPLAT_SPLAT]]
; AVX-NEXT:    [[RES:%.*]] = shufflevector <8 x i16> [[V0]], <8 x i16> [[V1]], <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; AVX-NEXT:    ret <16 x i16> [[RES]]
;
  %splat.splatinsert = insertelement <8 x i16> poison, i16 %x, i64 0
  %splat.splat = shufflevector <8 x i16> %splat.splatinsert, <8 x i16> poison, <8 x i32> zeroinitializer
  %v0 = mul <8 x i16> %a0, %splat.splat
  %v1 = mul <8 x i16> %a1, %splat.splat
  %res = shufflevector <8 x i16> %v0, <8 x i16> %v1, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  ret <16 x i16> %res
}

; Uniform constant mul v4i32

define <8 x i32> @shuf_uniform_const_mul_v8i32_v4i32(<4 x i32> %a0, <4 x i32> %a1) {
; CHECK-LABEL: define <8 x i32> @shuf_uniform_const_mul_v8i32_v4i32(
; CHECK-SAME: <4 x i32> [[A0:%.*]], <4 x i32> [[A1:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[A0]], <4 x i32> [[A1]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    [[RES:%.*]] = mul <8 x i32> [[TMP1]], splat (i32 7)
; CHECK-NEXT:    ret <8 x i32> [[RES]]
;
  %v0 = mul <4 x i32> %a0, splat(i32 7)
  %v1 = mul <4 x i32> %a1, splat(i32 7)
  %res = shufflevector <4 x i32> %v0, <4 x i32> %v1, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x i32> %res
}
