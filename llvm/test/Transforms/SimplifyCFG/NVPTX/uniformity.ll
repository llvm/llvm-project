; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=simplifycfg -S | FileCheck %s

target triple = "nvptx64-nvidia-cuda"

;; Branch threading in cases where the condition is divergent is bad because the
;; divergent code that is duplicated will be executed serially by the diverged
;; threads essentially doubling execution time.
define ptx_kernel void @test_01(ptr %ptr) {
; CHECK-LABEL: @test_01(
; CHECK-NEXT:    [[ID:%.*]] = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[ID]], 0
; CHECK-NEXT:    br i1 [[C]], label [[TRUE2_CRITEDGE:%.*]], label [[FALSE1:%.*]]
; CHECK:       true1:
; CHECK-NEXT:    store volatile i64 0, ptr [[PTR:%.*]], align 8
; CHECK-NEXT:    store volatile i64 -1, ptr [[PTR]], align 8
; CHECK-NEXT:    store volatile i64 -1, ptr [[PTR]], align 8
; CHECK-NEXT:    store volatile i64 -1, ptr [[PTR]], align 8
; CHECK-NEXT:    store volatile i64 -1, ptr [[PTR]], align 8
; CHECK-NEXT:    store volatile i64 -1, ptr [[PTR]], align 8
; CHECK-NEXT:    br i1 [[C]], label [[TRUE2:%.*]], label [[FALSE2:%.*]]
; CHECK:       false1:
; CHECK-NEXT:    store volatile i64 1, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[TRUE2_CRITEDGE]]
; CHECK:       true2:
; CHECK-NEXT:    store volatile i64 2, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[JOIN2:%.*]]
; CHECK:       false2:
; CHECK-NEXT:    store volatile i64 3, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[JOIN2]]
; CHECK:       join2:
; CHECK-NEXT:    ret void
;
  %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
  %c = icmp eq i32 %id, 0
  br i1 %c, label %true1, label %false1

true1:
  store volatile i64 0, ptr %ptr
  store volatile i64 -1, ptr %ptr
  store volatile i64 -1, ptr %ptr
  store volatile i64 -1, ptr %ptr
  store volatile i64 -1, ptr %ptr
  store volatile i64 -1, ptr %ptr
  br i1 %c, label %true2, label %false2

false1:
  store volatile i64 1, ptr %ptr
  br label %true1

true2:
  store volatile i64 2, ptr %ptr
  br label %join2

false2:
  store volatile i64 3, ptr %ptr
  br label %join2

join2:
  ret void
}

;; This case isn't as bad but still costly enough that we should avoid threading
;; through the divergent edge.
define ptx_kernel void @test_02(ptr %ptr) {
; CHECK-LABEL: @test_02(
; CHECK-NEXT:    [[ID:%.*]] = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[ID]], 0
; CHECK-NEXT:    br i1 [[C]], label [[TRUE2_CRITEDGE:%.*]], label [[FALSE1:%.*]]
; CHECK:       true1:
; CHECK-NEXT:    store volatile i64 0, ptr [[PTR:%.*]], align 8
; CHECK-NEXT:    br i1 [[C]], label [[TRUE2:%.*]], label [[FALSE2:%.*]]
; CHECK:       false1:
; CHECK-NEXT:    store volatile i64 1, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[TRUE2_CRITEDGE]]
; CHECK:       true2:
; CHECK-NEXT:    store volatile i64 2, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[JOIN2:%.*]]
; CHECK:       false2:
; CHECK-NEXT:    store volatile i64 3, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[JOIN2]]
; CHECK:       join2:
; CHECK-NEXT:    ret void
;
  %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
  %c = icmp eq i32 %id, 0
  br i1 %c, label %true1, label %false1

true1:
  store volatile i64 0, ptr %ptr
  br i1 %c, label %true2, label %false2

false1:
  store volatile i64 1, ptr %ptr
  br label %true1

true2:
  store volatile i64 2, ptr %ptr
  br label %join2

false2:
  store volatile i64 3, ptr %ptr
  br label %join2

join2:
  ret void
}

;; This case is simple enough that branch threading is still a good idea.
define ptx_kernel void @test_03(ptr %ptr) {
; CHECK-LABEL: @test_03(
; CHECK-NEXT:    [[ID:%.*]] = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
; CHECK-NEXT:    [[C:%.*]] = icmp eq i32 [[ID]], 0
; CHECK-NEXT:    br i1 [[C]], label [[TRUE1:%.*]], label [[FALSE2:%.*]]
; CHECK:       true1:
; CHECK-NEXT:    store volatile i64 1, ptr [[PTR:%.*]], align 8
; CHECK-NEXT:    store volatile i64 2, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[JOIN2:%.*]]
; CHECK:       false2:
; CHECK-NEXT:    store volatile i64 3, ptr [[PTR]], align 8
; CHECK-NEXT:    br label [[JOIN2]]
; CHECK:       join2:
; CHECK-NEXT:    ret void
;
  %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
  %c = icmp eq i32 %id, 0
  br i1 %c, label %true1, label %join1

true1:
  store volatile i64 1, ptr %ptr
  br label %join1

join1:
  br i1 %c, label %true2, label %false2

true2:
  store volatile i64 2, ptr %ptr
  br label %join2

false2:
  store volatile i64 3, ptr %ptr
  br label %join2

join2:
  ret void
}

declare i32 @llvm.nvvm.read.ptx.sreg.tid.x()
