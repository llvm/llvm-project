; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=simplifycfg -S < %s | FileCheck %s

target datalayout = "pu1:64:64-pe2:64:64:64:32"

;; TODO: it would probably be better to just emit a pointer compare against null.
define void @test_default_null_base(ptr addrspace(0) align 8 %ptr) {
; CHECK-LABEL: define void @test_default_null_base(
; CHECK-SAME: ptr align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[MAGICPTR:%.*]] = ptrtoint ptr [[PTR]] to i64
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[MAGICPTR]], 0
; CHECK-NEXT:    br i1 [[COND]], label %[[TRUE2:.*]], label %[[FALSE1:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr [[PTR]], align 8
; CHECK-NEXT:    store i64 3, ptr [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET:.*]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(0) %ptr, null
  %cond2 = icmp eq ptr addrspace(0) %ptr, null
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(0) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(0) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(0) %ptr, align 8
  ret void
}

;; We should not introduce ptrtoint instructions with unstable pointers
define void @test_default_inttoptr_base(ptr addrspace(0) align 8 %ptr) {
; CHECK-LABEL: define void @test_default_inttoptr_base(
; CHECK-SAME: ptr align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[MAGICPTR:%.*]] = ptrtoint ptr [[PTR]] to i64
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[MAGICPTR]], 4
; CHECK-NEXT:    br i1 [[COND]], label %[[TRUE2:.*]], label %[[FALSE1:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr [[PTR]], align 8
; CHECK-NEXT:    store i64 3, ptr [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET:.*]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(0) %ptr, inttoptr (i32 4 to ptr addrspace(0))
  %cond2 = icmp eq ptr addrspace(0) %ptr, inttoptr (i32 4 to ptr addrspace(0))
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(0) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(0) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(0) %ptr, align 8
  ret void
}

;; We should not introduce ptrtoint instructions with unstable pointers
define void @test_default_mixed_base(ptr addrspace(0) align 8 %ptr) {
; CHECK-LABEL: define void @test_default_mixed_base(
; CHECK-SAME: ptr align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq ptr [[PTR]], null
; CHECK-NEXT:    [[MAGICPTR:%.*]] = ptrtoint ptr [[PTR]] to i64
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[MAGICPTR]], 4
; CHECK-NEXT:    br i1 [[COND]], label %[[FALSE2:.*]], label %[[FALSE1:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr [[PTR]], align 8
; CHECK-NEXT:    br i1 [[COND2]], label %[[TRUE2:.*]], label %[[FALSE2]]
; CHECK:       [[COMMON_RET:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
; CHECK:       [[FALSE2]]:
; CHECK-NEXT:    store i64 3, ptr [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(0) %ptr, inttoptr (i32 4 to ptr addrspace(0))
  %cond2 = icmp eq ptr addrspace(0) %ptr, null
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(0) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(0) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(0) %ptr, align 8
  ret void
}

;; We should not introduce ptrtoint instructions with unstable pointers
define void @test_unstable_null_base(ptr addrspace(1) align 8 %ptr) {
; CHECK-LABEL: define void @test_unstable_null_base(
; CHECK-SAME: ptr addrspace(1) align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[COND1:%.*]] = icmp eq ptr addrspace(1) [[PTR]], null
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq ptr addrspace(1) [[PTR]], null
; CHECK-NEXT:    br i1 [[COND1]], label %[[TRUE1:.*]], label %[[FALSE1:.*]]
; CHECK:       [[TRUE1]]:
; CHECK-NEXT:    br i1 [[COND2]], label %[[TRUE2:.*]], label %[[FALSE2:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[TRUE1]]
; CHECK:       [[COMMON_RET:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
; CHECK:       [[FALSE2]]:
; CHECK-NEXT:    store i64 3, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(1) %ptr, null
  %cond2 = icmp eq ptr addrspace(1) %ptr, null
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(1) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(1) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(1) %ptr, align 8
  ret void
}

;; We should not introduce ptrtoint instructions with unstable pointers
define void @test_unstable_inttoptr_base(ptr addrspace(1) align 8 %ptr) {
; CHECK-LABEL: define void @test_unstable_inttoptr_base(
; CHECK-SAME: ptr addrspace(1) align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[COND1:%.*]] = icmp eq ptr addrspace(1) [[PTR]], inttoptr (i32 4 to ptr addrspace(1))
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq ptr addrspace(1) [[PTR]], inttoptr (i32 4 to ptr addrspace(1))
; CHECK-NEXT:    br i1 [[COND1]], label %[[TRUE1:.*]], label %[[FALSE1:.*]]
; CHECK:       [[TRUE1]]:
; CHECK-NEXT:    br i1 [[COND2]], label %[[TRUE2:.*]], label %[[FALSE2:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[TRUE1]]
; CHECK:       [[COMMON_RET:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
; CHECK:       [[FALSE2]]:
; CHECK-NEXT:    store i64 3, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(1) %ptr, inttoptr (i32 4 to ptr addrspace(1))
  %cond2 = icmp eq ptr addrspace(1) %ptr, inttoptr (i32 4 to ptr addrspace(1))
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(1) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(1) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(1) %ptr, align 8
  ret void
}

;; We should not introduce ptrtoint instructions with unstable pointers
define void @test_unstable_mixed_base(ptr addrspace(1) align 8 %ptr) {
; CHECK-LABEL: define void @test_unstable_mixed_base(
; CHECK-SAME: ptr addrspace(1) align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[COND1:%.*]] = icmp eq ptr addrspace(1) [[PTR]], inttoptr (i32 4 to ptr addrspace(1))
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq ptr addrspace(1) [[PTR]], null
; CHECK-NEXT:    br i1 [[COND1]], label %[[TRUE1:.*]], label %[[FALSE1:.*]]
; CHECK:       [[TRUE1]]:
; CHECK-NEXT:    br i1 [[COND2]], label %[[TRUE2:.*]], label %[[FALSE2:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[TRUE1]]
; CHECK:       [[COMMON_RET:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
; CHECK:       [[FALSE2]]:
; CHECK-NEXT:    store i64 3, ptr addrspace(1) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(1) %ptr, inttoptr (i32 4 to ptr addrspace(1))
  %cond2 = icmp eq ptr addrspace(1) %ptr, null
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(1) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(1) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(1) %ptr, align 8
  ret void
}

;; This transformation is fine for pointers with external state.
;; TODO: it would probably be better to just emit a pointer compare against null.
define void @test_external_null_base(ptr addrspace(2) align 8 %ptr) {
; CHECK-LABEL: define void @test_external_null_base(
; CHECK-SAME: ptr addrspace(2) align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[MAGICPTR:%.*]] = ptrtoint ptr addrspace(2) [[PTR]] to i64
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[MAGICPTR]], 0
; CHECK-NEXT:    br i1 [[COND]], label %[[TRUE2:.*]], label %[[FALSE1:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    store i64 3, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET:.*]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(2) %ptr, null
  %cond2 = icmp eq ptr addrspace(2) %ptr, null
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(2) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(2) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(2) %ptr, align 8
  ret void
}

;; This transformation is fine for pointers with external state (even with inttoptr).
define void @test_external_inttoptr_base(ptr addrspace(2) align 8 %ptr) {
; CHECK-LABEL: define void @test_external_inttoptr_base(
; CHECK-SAME: ptr addrspace(2) align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[MAGICPTR:%.*]] = ptrtoint ptr addrspace(2) [[PTR]] to i64
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[MAGICPTR]], 4
; CHECK-NEXT:    br i1 [[COND]], label %[[TRUE2:.*]], label %[[FALSE1:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    store i64 3, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET:.*]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(2) %ptr, inttoptr (i32 4 to ptr addrspace(2))
  %cond2 = icmp eq ptr addrspace(2) %ptr, inttoptr (i32 4 to ptr addrspace(2))
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(2) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(2) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(2) %ptr, align 8
  ret void
}

;; This transformation is fine for pointers with external state (even with inttoptr).
define void @test_external_mixed_base(ptr addrspace(2) align 8 %ptr) {
; CHECK-LABEL: define void @test_external_mixed_base(
; CHECK-SAME: ptr addrspace(2) align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq ptr addrspace(2) [[PTR]], null
; CHECK-NEXT:    [[MAGICPTR:%.*]] = ptrtoint ptr addrspace(2) [[PTR]] to i64
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[MAGICPTR]], 4
; CHECK-NEXT:    br i1 [[COND]], label %[[FALSE2:.*]], label %[[FALSE1:.*]]
; CHECK:       [[FALSE1]]:
; CHECK-NEXT:    store i64 1, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    br i1 [[COND2]], label %[[TRUE2:.*]], label %[[FALSE2]]
; CHECK:       [[COMMON_RET:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[TRUE2]]:
; CHECK-NEXT:    store i64 2, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
; CHECK:       [[FALSE2]]:
; CHECK-NEXT:    store i64 3, ptr addrspace(2) [[PTR]], align 8
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  %cond1 = icmp eq ptr addrspace(2) %ptr, inttoptr (i32 4 to ptr addrspace(2))
  %cond2 = icmp eq ptr addrspace(2) %ptr, null
  br i1 %cond1, label %true1, label %false1

true1:
  br i1 %cond2, label %true2, label %false2

false1:
  store i64 1, ptr addrspace(2) %ptr, align 8
  br label %true1

true2:
  store i64 2, ptr addrspace(2) %ptr, align 8
  ret void

false2:
  store i64 3, ptr addrspace(2) %ptr, align 8
  ret void
}
