; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -sink-common-insts -S | FileCheck %s
; RUN: opt < %s -passes='simplifycfg<sink-common-insts>' -S | FileCheck %s


; Simplified from node/libnode.crypto_context.ll
define i32 @foo(ptr %ssl, ptr %name, ptr %iv, ptr %ectx, ptr %hctx, i32 %enc) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @fn1(ptr [[SSL:%.*]])
; CHECK-NEXT:    [[CALL1:%.*]] = call ptr @fn2(ptr [[CALL]], i32 0)
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[ENC:%.*]], 0
; CHECK-NEXT:    [[TICKET_KEY_NAME_13:%.*]] = getelementptr i8, ptr [[CALL1]], i64 80
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[NAME:%.*]], ptr [[TICKET_KEY_NAME_13]], i64 16, i1 false)
; CHECK-NEXT:    [[CALL2:%.*]] = call i8 @fn3(ptr [[IV:%.*]], i64 16)
; CHECK-NEXT:    [[TOBOOL_I:%.*]] = trunc i8 [[CALL2]] to i1
; CHECK-NEXT:    br i1 [[TOBOOL_I]], label [[COND_PRED1:%.*]], label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[BCMP:%.*]] = call i32 @bcmp(ptr [[NAME]], ptr [[TICKET_KEY_NAME_13]], i64 16)
; CHECK-NEXT:    [[CMP16_NOT:%.*]] = icmp eq i32 [[BCMP]], 0
; CHECK-NEXT:    br i1 [[CMP16_NOT]], label [[COND_PRED2:%.*]], label [[RETURN]]
; CHECK:       cond_pred1:
; CHECK-NEXT:    [[CALL4:%.*]] = call ptr @fn4()
; CHECK-NEXT:    [[TICKET_KEY_AES_:%.*]] = getelementptr i8, ptr [[CALL1]], i64 96
; CHECK-NEXT:    [[CALL6:%.*]] = call i32 @fn5(ptr [[ECTX:%.*]], ptr [[CALL4]], ptr null, ptr [[TICKET_KEY_AES_]], ptr [[IV]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[CALL6]], 1
; CHECK-NEXT:    br i1 [[CMP]], label [[RETURN]], label [[COMMON:%.*]]
; CHECK:       cond_pred2:
; CHECK-NEXT:    [[CALL19:%.*]] = call ptr @fn4()
; CHECK-NEXT:    [[TICKET_KEY_AES_20:%.*]] = getelementptr i8, ptr [[CALL1]], i64 96
; CHECK-NEXT:    [[CALL22:%.*]] = call i32 @fn5(ptr [[ECTX]], ptr [[CALL19]], ptr null, ptr [[TICKET_KEY_AES_20]], ptr [[IV]])
; CHECK-NEXT:    [[CMP23:%.*]] = icmp slt i32 [[CALL22]], 1
; CHECK-NEXT:    br i1 [[CMP23]], label [[RETURN]], label [[COMMON]]
; CHECK:       common:
; CHECK-NEXT:    [[TICKET_KEY_HMAC_25:%.*]] = getelementptr i8, ptr [[CALL1]], i64 112
; CHECK-NEXT:    [[CALL27:%.*]] = call ptr @fn6()
; CHECK-NEXT:    [[CALL28:%.*]] = call i32 @fn7(ptr [[HCTX:%.*]], ptr [[TICKET_KEY_HMAC_25]], i32 16, ptr [[CALL27]], ptr null)
; CHECK-NEXT:    [[CMP29:%.*]] = icmp slt i32 [[CALL28]], 1
; CHECK-NEXT:    [[SPEC_SELECT11:%.*]] = select i1 [[CMP29]], i32 -1, i32 1
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ -1, [[COND_PRED1]] ], [ -1, [[COND_PRED2]] ], [ -1, [[IF_THEN]] ], [ 0, [[IF_END]] ], [ [[SPEC_SELECT11]], [[COMMON]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %call = call ptr @fn1(ptr %ssl)
  %call1 = call ptr @fn2(ptr %call, i32 0)
  %tobool.not = icmp eq i32 %enc, 0
  %ticket_key_name_13 = getelementptr i8, ptr %call1, i64 80
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr %name, ptr %ticket_key_name_13, i64 16, i1 false)
  %call2 = call i8 @fn3(ptr %iv, i64 16)
  %tobool.i = trunc i8 %call2 to i1
  br i1 %tobool.i, label %cond_pred1, label %return

if.end:                                           ; preds = %entry
  %bcmp = call i32 @bcmp(ptr %name, ptr %ticket_key_name_13, i64 16)
  %cmp16.not = icmp eq i32 %bcmp, 0
  br i1 %cmp16.not, label %cond_pred2, label %return

cond_pred1:                                       ; preds = %if.then
  %call4 = call ptr @fn4()
  %ticket_key_aes_ = getelementptr i8, ptr %call1, i64 96
  %call6 = call i32 @fn5(ptr %ectx, ptr %call4, ptr null, ptr %ticket_key_aes_, ptr %iv)
  %cmp = icmp slt i32 %call6, 1
  br i1 %cmp, label %return, label %common

cond_pred2:                                       ; preds = %if.end
  %call19 = call ptr @fn4()
  %ticket_key_aes_20 = getelementptr i8, ptr %call1, i64 96
  %call22 = call i32 @fn5(ptr %ectx, ptr %call19, ptr null, ptr %ticket_key_aes_20, ptr %iv)
  %cmp23 = icmp slt i32 %call22, 1
  br i1 %cmp23, label %return, label %common

common:                                           ; preds = %cond_pred2, %cond_pred1
  %ticket_key_hmac_25 = getelementptr i8, ptr %call1, i64 112
  %call27 = call ptr @fn6()
  %call28 = call i32 @fn7(ptr %hctx, ptr %ticket_key_hmac_25, i32 16, ptr %call27, ptr null)
  %cmp29 = icmp slt i32 %call28, 1
  %spec.select11 = select i1 %cmp29, i32 -1, i32 1
  br label %return

return:                                           ; preds = %common, %cond_pred2, %cond_pred1, %if.end, %if.then
  %retval.0 = phi i32 [ -1, %cond_pred1 ], [ -1, %cond_pred2 ], [ -1, %if.then ], [ 0, %if.end ], [ %spec.select11, %common ]
  ret i32 %retval.0
}

; Simplified from compiler-rt/x86.c.ll
define ptr @getAMDProcessorTypeAndSubtype(i32 %Family, ptr %CpuModel, i1 %cmp35) {
; CHECK-LABEL: @getAMDProcessorTypeAndSubtype(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i32 [[FAMILY:%.*]], label [[END:%.*]] [
; CHECK-NEXT:      i32 26, label [[COND_PRED1:%.*]]
; CHECK-NEXT:      i32 21, label [[COND_PRED2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       cond_pred1:
; CHECK-NEXT:    store i32 0, ptr [[CPUMODEL:%.*]], align 4
; CHECK-NEXT:    br i1 [[CMP35:%.*]], label [[END]], label [[COMMON:%.*]]
; CHECK:       cond_pred2:
; CHECK-NEXT:    store i32 0, ptr [[CPUMODEL]], align 4
; CHECK-NEXT:    br i1 [[CMP35]], label [[END]], label [[COMMON]]
; CHECK:       end:
; CHECK-NEXT:    ret ptr null
; CHECK:       common:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[COND_PRED1]] ], [ 0, [[COND_PRED2]] ]
; CHECK-NEXT:    [[PHI2:%.*]] = phi i32 [ 1, [[COND_PRED1]] ], [ 2, [[COND_PRED2]] ]
; CHECK-NEXT:    call void @use(i32 [[PHI1]])
; CHECK-NEXT:    call void @use(i32 [[PHI2]])
; CHECK-NEXT:    br label [[END]]
;
entry:
  switch i32 %Family, label %end [
  i32 26, label %cond_pred1
  i32 21, label %cond_pred2
  ]

cond_pred1:                                       ; preds = %entry
  store i32 0, ptr %CpuModel, align 4
  br i1 %cmp35, label %end, label %common

cond_pred2:                                       ; preds = %entry
  store i32 0, ptr %CpuModel, align 4
  br i1 %cmp35, label %end, label %common

end:                                              ; preds = %common, %cond_pred2, %cond_pred1, %entry
  ret ptr null

common:                                           ; preds = %cond_pred2, %cond_pred1
  %phi1 = phi i32 [ 0, %cond_pred1 ], [ 0, %cond_pred2 ]
  %phi2 = phi i32 [ 1, %cond_pred1 ], [ 2, %cond_pred2 ]
  call void @use(i32 %phi1)
  call void @use(i32 %phi2)
  br label %end
}


declare void @use(i32)

declare ptr @fn1(ptr)
declare ptr @fn2(ptr, i32)
declare i8 @fn3(ptr, i64)
declare ptr @fn4()
declare i32 @fn5(ptr, ptr, ptr, ptr, ptr)
declare ptr @fn6()
declare i32 @fn7(ptr, ptr, i32, ptr, ptr)

declare i32 @bcmp(ptr, ptr, i64)

declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)
