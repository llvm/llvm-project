; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; Test that simplifycfg can create switch instructions from constant pointers.
;
; RUN: opt < %s -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S | FileCheck %s

target datalayout = "e-p:64:64:64-p1:16:16:16-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
target triple = "x86_64-apple-darwin10.0.0"

@.str = private constant [5 x i8] c"null\00"      ; <ptr> [#uses=2]
@.str1 = private constant [4 x i8] c"one\00"      ; <ptr> [#uses=2]
@.str2 = private constant [4 x i8] c"two\00"      ; <ptr> [#uses=2]
@.str3 = private constant [5 x i8] c"four\00"     ; <ptr> [#uses=2]

@.str_as1 = private addrspace(1) constant [5 x i8] c"null\00"      ; <ptr> [#uses=2]
@.str1_as1 = private addrspace(1) constant [4 x i8] c"one\00"      ; <ptr> [#uses=2]
@.str2_as1 = private addrspace(1) constant [4 x i8] c"two\00"      ; <ptr> [#uses=2]
@.str3_as1 = private addrspace(1) constant [5 x i8] c"four\00"     ; <ptr> [#uses=2]

declare i32 @puts(ptr)
declare i32 @puts_as1(ptr addrspace(1))

define void @f(ptr %x) nounwind ssp {
; CHECK-LABEL: define void @f(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq ptr [[X]], null
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[IF_THEN:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @puts(ptr @.str) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    br label %[[IF_END21:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[X]], inttoptr (i64 1 to ptr)
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN2:.*]], label %[[IF_ELSE4:.*]]
; CHECK:       [[IF_THEN2]]:
; CHECK-NEXT:    [[CALL3:%.*]] = call i32 @puts(ptr @.str1) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_ELSE4]]:
; CHECK-NEXT:    [[CMP6:%.*]] = icmp eq ptr [[X]], inttoptr (i64 2 to ptr)
; CHECK-NEXT:    [[CMP8:%.*]] = icmp eq ptr [[X]], inttoptr (i64 3 to ptr)
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP6]], [[CMP8]]
; CHECK-NEXT:    br i1 [[OR_COND]], label %[[IF_THEN9:.*]], label %[[IF_ELSE11:.*]]
; CHECK:       [[IF_THEN9]]:
; CHECK-NEXT:    [[CALL10:%.*]] = call i32 @puts(ptr @.str2) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_ELSE11]]:
; CHECK-NEXT:    [[CMP13:%.*]] = icmp eq ptr [[X]], inttoptr (i64 4 to ptr)
; CHECK-NEXT:    br i1 [[CMP13]], label %[[IF_THEN14:.*]], label %[[IF_ELSE16:.*]]
; CHECK:       [[IF_THEN14]]:
; CHECK-NEXT:    [[CALL15:%.*]] = call i32 @puts(ptr @.str3) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_ELSE16]]:
; CHECK-NEXT:    [[CALL18:%.*]] = call i32 @puts(ptr [[X]]) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_END21]]:
; CHECK-NEXT:    ret void
;

entry:
  %tobool = icmp eq ptr %x, null                  ; <i1> [#uses=1]
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @puts(ptr @.str) nounwind ; <i32> [#uses=0]
  br label %if.end21

if.else:                                          ; preds = %entry
  %cmp = icmp eq ptr %x, inttoptr (i64 1 to ptr)  ; <i1> [#uses=1]
  br i1 %cmp, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  %call3 = call i32 @puts(ptr @.str1) nounwind ; <i32> [#uses=0]
  br label %if.end20

if.else4:                                         ; preds = %if.else
  %cmp6 = icmp eq ptr %x, inttoptr (i64 2 to ptr) ; <i1> [#uses=1]
  br i1 %cmp6, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else4
  %cmp8 = icmp eq ptr %x, inttoptr (i64 3 to ptr) ; <i1> [#uses=1]
  br i1 %cmp8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %lor.lhs.false, %if.else4
  %call10 = call i32 @puts(ptr @.str2) nounwind ; <i32> [#uses=0]
  br label %if.end19

if.else11:                                        ; preds = %lor.lhs.false
  %cmp13 = icmp eq ptr %x, inttoptr (i64 4 to ptr) ; <i1> [#uses=1]
  br i1 %cmp13, label %if.then14, label %if.else16

if.then14:                                        ; preds = %if.else11
  %call15 = call i32 @puts(ptr @.str3) nounwind ; <i32> [#uses=0]
  br label %if.end

if.else16:                                        ; preds = %if.else11
  %call18 = call i32 @puts(ptr %x) nounwind       ; <i32> [#uses=0]
  br label %if.end

if.end:                                           ; preds = %if.else16, %if.then14
  br label %if.end19

if.end19:                                         ; preds = %if.end, %if.then9
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then2
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then
  ret void
}

; Is it useful to test a version where the ptrtoints are to the same
; size?
define void @f_as1(ptr addrspace(1) %x) nounwind ssp {
; CHECK-LABEL: define void @f_as1(
; CHECK-SAME: ptr addrspace(1) [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq ptr addrspace(1) [[X]], null
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[IF_THEN:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @puts_as1(ptr addrspace(1) @.str_as1) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr addrspace(1) [[X]], inttoptr (i64 1 to ptr addrspace(1))
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN2:.*]], label %[[IF_ELSE4:.*]]
; CHECK:       [[IF_THEN2]]:
; CHECK-NEXT:    [[CALL3:%.*]] = call i32 @puts_as1(ptr addrspace(1) @.str1_as1) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_ELSE4]]:
; CHECK-NEXT:    [[CMP6:%.*]] = icmp eq ptr addrspace(1) [[X]], inttoptr (i64 2 to ptr addrspace(1))
; CHECK-NEXT:    [[CMP8:%.*]] = icmp eq ptr addrspace(1) [[X]], inttoptr (i64 3 to ptr addrspace(1))
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP6]], [[CMP8]]
; CHECK-NEXT:    br i1 [[OR_COND]], label %[[IF_THEN9:.*]], label %[[IF_ELSE11:.*]]
; CHECK:       [[IF_THEN9]]:
; CHECK-NEXT:    [[CALL10:%.*]] = call i32 @puts_as1(ptr addrspace(1) @.str2_as1) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_ELSE11]]:
; CHECK-NEXT:    [[CMP13:%.*]] = icmp eq ptr addrspace(1) [[X]], inttoptr (i64 4 to ptr addrspace(1))
; CHECK-NEXT:    br i1 [[CMP13]], label %[[IF_THEN14:.*]], label %[[IF_ELSE16:.*]]
; CHECK:       [[IF_THEN14]]:
; CHECK-NEXT:    [[CALL15:%.*]] = call i32 @puts_as1(ptr addrspace(1) @.str3_as1) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_ELSE16]]:
; CHECK-NEXT:    [[CALL18:%.*]] = call i32 @puts_as1(ptr addrspace(1) [[X]]) #[[ATTR1]]
; CHECK-NEXT:    br label %[[IF_END21]]
; CHECK:       [[IF_END21]]:
; CHECK-NEXT:    ret void
;

entry:
  %tobool = icmp eq ptr addrspace(1) %x, null                  ; <i1> [#uses=1]
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @puts_as1(ptr addrspace(1) @.str_as1) nounwind ; <i32> [#uses=0]
  br label %if.end21

if.else:                                          ; preds = %entry
  %cmp = icmp eq ptr addrspace(1) %x, inttoptr (i64 1 to ptr addrspace(1))  ; <i1> [#uses=1]
  br i1 %cmp, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  %call3 = call i32 @puts_as1(ptr addrspace(1) @.str1_as1) nounwind ; <i32> [#uses=0]
  br label %if.end20

if.else4:                                         ; preds = %if.else
  %cmp6 = icmp eq ptr addrspace(1) %x, inttoptr (i64 2 to ptr addrspace(1)) ; <i1> [#uses=1]
  br i1 %cmp6, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else4
  %cmp8 = icmp eq ptr addrspace(1) %x, inttoptr (i64 3 to ptr addrspace(1)) ; <i1> [#uses=1]
  br i1 %cmp8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %lor.lhs.false, %if.else4
  %call10 = call i32 @puts_as1(ptr addrspace(1) @.str2_as1) nounwind ; <i32> [#uses=0]
  br label %if.end19

if.else11:                                        ; preds = %lor.lhs.false
  %cmp13 = icmp eq ptr addrspace(1) %x, inttoptr (i64 4 to ptr addrspace(1)) ; <i1> [#uses=1]
  br i1 %cmp13, label %if.then14, label %if.else16

if.then14:                                        ; preds = %if.else11
  %call15 = call i32 @puts_as1(ptr addrspace(1) @.str3_as1) nounwind ; <i32> [#uses=0]
  br label %if.end

if.else16:                                        ; preds = %if.else11
  %call18 = call i32 @puts_as1(ptr addrspace(1) %x) nounwind       ; <i32> [#uses=0]
  br label %if.end

if.end:                                           ; preds = %if.else16, %if.then14
  br label %if.end19

if.end19:                                         ; preds = %if.end, %if.then9
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then2
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then
  ret void
}

