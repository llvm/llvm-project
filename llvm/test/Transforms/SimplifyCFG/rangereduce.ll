; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -switch-to-lookup -S | FileCheck %s
; RUN: opt < %s -passes='simplifycfg<switch-to-lookup>' -S | FileCheck %s

target datalayout = "e-n32"

define i32 @test1(i32 %a) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[A:%.*]], 97
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.fshl.i32(i32 [[TMP1]], i32 [[TMP1]], i32 30)
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ult i32 [[TMP2]], 4
; CHECK-NEXT:    br i1 [[TMP3]], label [[SWITCH_LOOKUP:%.*]], label [[COMMON_RET:%.*]]
; CHECK:       switch.lookup:
; CHECK-NEXT:    [[TMP4:%.*]] = zext nneg i32 [[TMP2]] to i64
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [4 x i32], ptr @switch.table.test1, i64 0, i64 [[TMP4]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
;
  switch i32 %a, label %def [
  i32 97, label %one
  i32 101, label %two
  i32 105, label %three
  i32 109, label %three
  ]

def:
  ret i32 8867

one:
  ret i32 11984
two:
  ret i32 1143
three:
  ret i32 99783
}

; Optimization shouldn't trigger; bitwidth > 64
define i128 @test2(i128 %a) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:    switch i128 [[A:%.*]], label [[COMMON_RET:%.*]] [
; CHECK-NEXT:      i128 97, label [[ONE:%.*]]
; CHECK-NEXT:      i128 101, label [[TWO:%.*]]
; CHECK-NEXT:      i128 105, label [[THREE:%.*]]
; CHECK-NEXT:      i128 109, label [[THREE]]
; CHECK-NEXT:    ]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i128 [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 99783, [[THREE]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i128 [[COMMON_RET_OP]]
; CHECK:       one:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       two:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       three:
; CHECK-NEXT:    br label [[COMMON_RET]]
;
  switch i128 %a, label %def [
  i128 97, label %one
  i128 101, label %two
  i128 105, label %three
  i128 109, label %three
  ]

def:
  ret i128 8867

one:
  ret i128 11984
two:
  ret i128 1143
three:
  ret i128 99783
}

; Optimization shouldn't trigger; no holes present
define i32 @test3(i32 %a) {
; CHECK-LABEL: @test3(
; CHECK-NEXT:    [[SWITCH_TABLEIDX:%.*]] = sub i32 [[A:%.*]], 97
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[SWITCH_TABLEIDX]], 3
; CHECK-NEXT:    br i1 [[TMP1]], label [[SWITCH_LOOKUP:%.*]], label [[COMMON_RET:%.*]]
; CHECK:       switch.lookup:
; CHECK-NEXT:    [[TMP2:%.*]] = zext nneg i32 [[SWITCH_TABLEIDX]] to i64
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [3 x i32], ptr @switch.table.test3, i64 0, i64 [[TMP2]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
;
  switch i32 %a, label %def [
  i32 97, label %one
  i32 98, label %two
  i32 99, label %three
  ]

def:
  ret i32 8867

one:
  ret i32 11984
two:
  ret i32 1143
three:
  ret i32 99783
}

; Optimization shouldn't trigger; not an arithmetic progression
define i32 @test4(i32 %a) {
; CHECK-LABEL: @test4(
; CHECK-NEXT:    switch i32 [[A:%.*]], label [[COMMON_RET:%.*]] [
; CHECK-NEXT:      i32 97, label [[ONE:%.*]]
; CHECK-NEXT:      i32 102, label [[TWO:%.*]]
; CHECK-NEXT:      i32 105, label [[THREE:%.*]]
; CHECK-NEXT:      i32 109, label [[THREE]]
; CHECK-NEXT:    ]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 99783, [[THREE]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
; CHECK:       one:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       two:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       three:
; CHECK-NEXT:    br label [[COMMON_RET]]
;
  switch i32 %a, label %def [
  i32 97, label %one
  i32 102, label %two
  i32 105, label %three
  i32 109, label %three
  ]

def:
  ret i32 8867

one:
  ret i32 11984
two:
  ret i32 1143
three:
  ret i32 99783
}

; Optimization shouldn't trigger; not a power of two
define i32 @test5(i32 %a) {
; CHECK-LABEL: @test5(
; CHECK-NEXT:    switch i32 [[A:%.*]], label [[COMMON_RET:%.*]] [
; CHECK-NEXT:      i32 97, label [[ONE:%.*]]
; CHECK-NEXT:      i32 102, label [[TWO:%.*]]
; CHECK-NEXT:      i32 107, label [[THREE:%.*]]
; CHECK-NEXT:      i32 112, label [[THREE]]
; CHECK-NEXT:    ]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 11984, [[ONE]] ], [ 1143, [[TWO]] ], [ 99783, [[THREE]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
; CHECK:       one:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       two:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       three:
; CHECK-NEXT:    br label [[COMMON_RET]]
;
  switch i32 %a, label %def [
  i32 97, label %one
  i32 102, label %two
  i32 107, label %three
  i32 112, label %three
  ]

def:
  ret i32 8867

one:
  ret i32 11984
two:
  ret i32 1143
three:
  ret i32 99783
}

define i32 @test6(i32 %a) optsize {
; CHECK-LABEL: @test6(
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[A:%.*]], -109
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.fshl.i32(i32 [[TMP1]], i32 [[TMP1]], i32 30)
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ult i32 [[TMP2]], 4
; CHECK-NEXT:    br i1 [[TMP3]], label [[SWITCH_LOOKUP:%.*]], label [[COMMON_RET:%.*]]
; CHECK:       switch.lookup:
; CHECK-NEXT:    [[TMP4:%.*]] = zext nneg i32 [[TMP2]] to i64
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [4 x i32], ptr @switch.table.test6, i64 0, i64 [[TMP4]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
;
  switch i32 %a, label %def [
  i32 -97, label %one
  i32 -101, label %two
  i32 -105, label %three
  i32 -109, label %three
  ]

def:
  ret i32 8867

one:
  ret i32 11984
two:
  ret i32 1143
three:
  ret i32 99783
}

define i8 @test7(i8 %a) optsize {
; CHECK-LABEL: @test7(
; CHECK-NEXT:  common.ret:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i8 [[A:%.*]], -36
; CHECK-NEXT:    [[TMP1:%.*]] = call i8 @llvm.fshl.i8(i8 [[TMP0]], i8 [[TMP0]], i8 6)
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i8 [[TMP1]], 4
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = zext i8 [[TMP1]] to i32
; CHECK-NEXT:    [[SWITCH_SHIFTAMT:%.*]] = mul nuw nsw i32 [[SWITCH_CAST]], 8
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i32 -943228976, [[SWITCH_SHIFTAMT]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i32 [[SWITCH_DOWNSHIFT]] to i8
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = select i1 [[TMP2]], i8 [[SWITCH_MASKED]], i8 -93
; CHECK-NEXT:    ret i8 [[COMMON_RET_OP]]
;
  switch i8 %a, label %def [
  i8 220, label %one
  i8 224, label %two
  i8 228, label %three
  i8 232, label %three
  ]

def:
  ret i8 8867

one:
  ret i8 11984
two:
  ret i8 1143
three:
  ret i8 99783
}

define i32 @test8(i32 %a) optsize {
; CHECK-LABEL: @test8(
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[A:%.*]], 97
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.fshl.i32(i32 [[TMP1]], i32 [[TMP1]], i32 30)
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ult i32 [[TMP2]], 5
; CHECK-NEXT:    br i1 [[TMP3]], label [[SWITCH_LOOKUP:%.*]], label [[COMMON_RET:%.*]]
; CHECK:       switch.lookup:
; CHECK-NEXT:    [[TMP4:%.*]] = zext nneg i32 [[TMP2]] to i64
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [5 x i32], ptr @switch.table.test8, i64 0, i64 [[TMP4]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
;
  switch i32 %a, label %def [
  i32 97, label %one
  i32 101, label %two
  i32 105, label %three
  i32 113, label %three
  ]

def:
  ret i32 8867

one:
  ret i32 11984
two:
  ret i32 1143
three:
  ret i32 99783
}

define i32 @test9(i32 %a) {
; CHECK-LABEL: @test9(
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[A:%.*]], 6
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.fshl.i32(i32 [[TMP1]], i32 [[TMP1]], i32 31)
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ult i32 [[TMP2]], 8
; CHECK-NEXT:    br i1 [[TMP3]], label [[SWITCH_LOOKUP:%.*]], label [[COMMON_RET:%.*]]
; CHECK:       switch.lookup:
; CHECK-NEXT:    [[TMP4:%.*]] = zext nneg i32 [[TMP2]] to i64
; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [8 x i32], ptr @switch.table.test9, i64 0, i64 [[TMP4]]
; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load i32, ptr [[SWITCH_GEP]], align 4
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ [[SWITCH_LOAD]], [[SWITCH_LOOKUP]] ], [ 8867, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
;
  switch i32 %a, label %def [
  i32 18, label %one
  i32 20, label %two
  i32 6, label %three
  i32 10, label %three
  ]

def:
  ret i32 8867

one:
  ret i32 11984
two:
  ret i32 1143
three:
  ret i32 99783
}

define i8 @pr67842(i32 %0) {
; CHECK-LABEL: @pr67842(
; CHECK-NEXT:  start:
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[TMP0:%.*]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = and i32 [[TMP1]], 255
; CHECK-NEXT:    [[SWITCH_IDX_CAST:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[SWITCH_OFFSET:%.*]] = add nsw i8 [[SWITCH_IDX_CAST]], -1
; CHECK-NEXT:    ret i8 [[SWITCH_OFFSET]]
;
start:
  switch i32 %0, label %bb2 [
  i32 0, label %bb5
  i32 1, label %bb4
  i32 255, label %bb1
  ]

bb2:                                              ; preds = %start
  unreachable

bb4:                                              ; preds = %start
  br label %bb5

bb1:                                              ; preds = %start
  br label %bb5

bb5:                                              ; preds = %start, %bb1, %bb4
  %.0 = phi i8 [ -1, %bb1 ], [ 1, %bb4 ], [ 0, %start ]
  ret i8 %.0
}

define i8 @reduce_masked_common_high_bits(i32 %0) {
; CHECK-LABEL: @reduce_masked_common_high_bits(
; CHECK-NEXT:  start:
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[TMP0:%.*]], -127
; CHECK-NEXT:    [[TMP2:%.*]] = and i32 [[TMP1]], 127
; CHECK-NEXT:    [[SWITCH_IDX_CAST:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[SWITCH_OFFSET:%.*]] = add nsw i8 [[SWITCH_IDX_CAST]], -1
; CHECK-NEXT:    ret i8 [[SWITCH_OFFSET]]
;
start:
  switch i32 %0, label %bb2 [
  i32 128, label %bb5
  i32 129, label %bb4
  i32 255, label %bb1
  ]

bb2:                                              ; preds = %start
  unreachable

bb4:                                              ; preds = %start
  br label %bb5

bb1:                                              ; preds = %start
  br label %bb5

bb5:                                              ; preds = %start, %bb1, %bb4
  %.0 = phi i8 [ -1, %bb1 ], [ 1, %bb4 ], [ 0, %start ]
  ret i8 %.0
}

define i8 @reduce_masked_common_high_bits_fail(i32 %0) {
; CHECK-LABEL: @reduce_masked_common_high_bits_fail(
; CHECK-NEXT:  start:
; CHECK-NEXT:    switch i32 [[TMP0:%.*]], label [[BB2:%.*]] [
; CHECK-NEXT:      i32 128, label [[BB5:%.*]]
; CHECK-NEXT:      i32 129, label [[BB4:%.*]]
; CHECK-NEXT:      i32 511, label [[BB1:%.*]]
; CHECK-NEXT:    ]
; CHECK:       bb2:
; CHECK-NEXT:    unreachable
; CHECK:       bb4:
; CHECK-NEXT:    br label [[BB5]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[BB5]]
; CHECK:       bb5:
; CHECK-NEXT:    [[DOT0:%.*]] = phi i8 [ -1, [[BB1]] ], [ 1, [[BB4]] ], [ 0, [[START:%.*]] ]
; CHECK-NEXT:    ret i8 [[DOT0]]
;
start:
  switch i32 %0, label %bb2 [
  i32 128, label %bb5
  i32 129, label %bb4
  i32 511, label %bb1
  ]

bb2:                                              ; preds = %start
  unreachable

bb4:                                              ; preds = %start
  br label %bb5

bb1:                                              ; preds = %start
  br label %bb5

bb5:                                              ; preds = %start, %bb1, %bb4
  %.0 = phi i8 [ -1, %bb1 ], [ 1, %bb4 ], [ 0, %start ]
  ret i8 %.0
}

; Optimization shouldn't trigger; The default block is reachable.
define i8 @reduce_masked_default_reachable(i32 %0) {
; CHECK-LABEL: @reduce_masked_default_reachable(
; CHECK-NEXT:  start:
; CHECK-NEXT:    switch i32 [[TMP0:%.*]], label [[COMMON_RET:%.*]] [
; CHECK-NEXT:      i32 0, label [[BB5:%.*]]
; CHECK-NEXT:      i32 1, label [[BB4:%.*]]
; CHECK-NEXT:      i32 255, label [[BB1:%.*]]
; CHECK-NEXT:    ]
; CHECK:       common.ret:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i8 [ 24, [[START:%.*]] ], [ -1, [[BB1]] ], [ 1, [[BB4]] ], [ 0, [[BB5]] ]
; CHECK-NEXT:    ret i8 [[COMMON_RET_OP]]
; CHECK:       bb4:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[COMMON_RET]]
; CHECK:       bb5:
; CHECK-NEXT:    br label [[COMMON_RET]]
;
start:
  switch i32 %0, label %bb2 [
  i32 0, label %bb5
  i32 1, label %bb4
  i32 255, label %bb1
  ]

bb2:                                              ; preds = %start
  ret i8 24

bb4:                                              ; preds = %start
  br label %bb5

bb1:                                              ; preds = %start
  br label %bb5

bb5:                                              ; preds = %start, %bb1, %bb4
  %.0 = phi i8 [ -1, %bb1 ], [ 1, %bb4 ], [ 0, %start ]
  ret i8 %.0
}
