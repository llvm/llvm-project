; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S | FileCheck %s

; Test a bunch of cases where the other phi values (i.e., comes from non-common predecessors)
; should be merged into phi of the successor if there are >1 common predecessors.

declare void @use(i8)

define i8 @phis_of_switch(i8 noundef %arg, i1 %cond) {
; CHECK-LABEL: define i8 @phis_of_switch(
; CHECK-SAME: i8 noundef [[ARG:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[START:.*]]:
; CHECK-NEXT:    switch i8 [[ARG]], label %[[UNREACHABLE:.*]] [
; CHECK-NEXT:      i8 0, label %[[CASE0:.*]]
; CHECK-NEXT:      i8 1, label %[[CASE1:.*]]
; CHECK-NEXT:      i8 2, label %[[CASE2:.*]]
; CHECK-NEXT:      i8 3, label %[[END:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[UNREACHABLE]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    br label %[[END]]
; CHECK:       [[CASE2]]:
; CHECK-NEXT:    br i1 [[COND]], label %[[CASE0]], label %[[END]]
; CHECK:       [[CASE0]]:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i8 [ 1, %[[START]] ], [ 3, %[[CASE2]] ]
; CHECK-NEXT:    br label %[[END]]
; CHECK:       [[END]]:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 3, %[[START]] ], [ 4, %[[CASE2]] ], [ 2, %[[CASE1]] ], [ [[PHI1]], %[[CASE0]] ]
; CHECK-NEXT:    ret i8 [[PHI2]]
;
start:
  switch i8 %arg, label %unreachable [
  i8 0, label %case0
  i8 1, label %case1
  i8 2, label %case2
  i8 3, label %end
  ]

unreachable:                                      ; preds = %start
  unreachable

case1:                                            ; preds = %start
  br label %case0

case2:                                            ; preds = %start
  br i1 %cond, label %case0, label %end

case0:                                            ; preds = %case2, %case1, %start
  ; %case2 and %start are common predecessors, but we can redirect %case1 to %end
  %phi1 = phi i8 [ 1, %start ], [ 2, %case1 ], [ 3, %case2 ]
  br label %end

end:                                              ; preds = %case0, %case2, %start
  %phi2 = phi i8 [ %phi1, %case0 ], [ 3, %start ], [ 4, %case2 ]
  ret i8 %phi2
}

define i8 @phis_of_if(i8 noundef %arg, i1 %cond) {
; CHECK-LABEL: define i8 @phis_of_if(
; CHECK-SAME: i8 noundef [[ARG:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[START:.*]]:
; CHECK-NEXT:    br i1 [[COND]], label %[[BRANCH:.*]], label %[[END:.*]]
; CHECK:       [[BRANCH]]:
; CHECK-NEXT:    [[COND0:%.*]] = icmp sgt i8 [[ARG]], 0
; CHECK-NEXT:    call void @use(i8 1)
; CHECK-NEXT:    br i1 [[COND0]], label %[[CASE0:.*]], label %[[CASE1:.*]]
; CHECK:       [[CASE0]]:
; CHECK-NEXT:    call void @use(i8 1)
; CHECK-NEXT:    [[COND1:%.*]] = icmp eq i8 [[ARG]], 1
; CHECK-NEXT:    br i1 [[COND1]], label %[[SINK:.*]], label %[[END]]
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    call void @use(i8 1)
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq i8 [[ARG]], -1
; CHECK-NEXT:    br i1 [[COND2]], label %[[SINK]], label %[[END]]
; CHECK:       [[SINK]]:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i8 [ 1, %[[CASE0]] ], [ 2, %[[CASE1]] ]
; CHECK-NEXT:    br label %[[END]]
; CHECK:       [[END]]:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 3, %[[CASE0]] ], [ 4, %[[CASE1]] ], [ 0, %[[START]] ], [ [[PHI1]], %[[SINK]] ]
; CHECK-NEXT:    ret i8 [[PHI2]]
;
start:
  br i1 %cond, label %branch, label %sink

branch:                                           ; preds = %start
  %cond0 = icmp sgt i8 %arg, 0
  call void @use(i8 1)
  br i1 %cond0, label %case0, label %case1

case0:                                            ; preds = %branch
  call void @use(i8 1)
  %cond1 = icmp eq i8 %arg, 1
  br i1 %cond1, label %sink, label %end

case1:                                            ; preds = %branch
  call void @use(i8 1)
  %cond2 = icmp eq i8 %arg, -1
  br i1 %cond2, label %sink, label %end

sink:                                             ; preds = %case1, %case0, %start
  ; %case0 and %case1 are common predecessors, but we can redirect %start to %end
  %phi1 = phi i8 [ 0, %start ], [ 1, %case0 ], [ 2, %case1 ]
  br label %end

end:                                              ; preds = %sink, %case1, %case0
  %phi2 = phi i8 [ 3, %case0 ], [ 4, %case1 ], [ %phi1, %sink ]
  ret i8 %phi2
}

define i64 @from_jump_threading(i64 %0, i1 %1, i64 %num) {
; CHECK-LABEL: define i64 @from_jump_threading(
; CHECK-SAME: i64 [[TMP0:%.*]], i1 [[TMP1:%.*]], i64 [[NUM:%.*]]) {
; CHECK-NEXT:    switch i64 [[TMP0]], label %[[COMMON_RET:.*]] [
; CHECK-NEXT:      i64 0, label %[[CASE0:.*]]
; CHECK-NEXT:      i64 1, label %[[CASE1:.*]]
; CHECK-NEXT:      i64 2, label %[[CASE2:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE0]]:
; CHECK-NEXT:    br i1 [[TMP1]], label %[[SUCC:.*]], label %[[FOO_THREAD:.*]]
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    br i1 [[TMP1]], label %[[SUCC]], label %[[FOO_THREAD]]
; CHECK:       [[CASE2]]:
; CHECK-NEXT:    br i1 [[TMP1]], label %[[COMMON_RET]], label %[[SUCC]]
; CHECK:       [[FOO_THREAD]]:
; CHECK-NEXT:    [[PHI1_PH:%.*]] = phi i64 [ 0, %[[CASE1]] ], [ 0, %[[CASE0]] ]
; CHECK-NEXT:    br label %[[SUCC]]
; CHECK:       [[SUCC]]:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i64 [ [[NUM]], %[[CASE1]] ], [ [[NUM]], %[[CASE0]] ], [ 1, %[[CASE2]] ], [ [[PHI1_PH]], %[[FOO_THREAD]] ]
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq i64 [[PHI2]], 0
; CHECK-NEXT:    br i1 [[COND2]], label %[[EXIT:.*]], label %[[COMMON_RET]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i64 [ [[PHI2]], %[[EXIT]] ], [ 0, %[[SUCC]] ], [ 0, %[[CASE2]] ], [ 0, [[TMP2:%.*]] ]
; CHECK-NEXT:    ret i64 [[COMMON_RET_OP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    call void @use(i8 0)
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
  switch i64 %0, label %exit2 [
  i64 0, label %case0
  i64 1, label %case1
  i64 2, label %case2
  ]

case0:                                            ; preds = %2
  br i1 %1, label %succ, label %foo.thread

case1:                                            ; preds = %2
  br i1 %1, label %succ, label %foo.thread

case2:                                            ; preds = %2
  br i1 %1, label %exit2, label %foo.thread

foo.thread:                                       ; preds = %case2, %case1, %case0
  ; %case0 and %case1 are common predecessors, but we can redirect %case2 to %succ
  %phi1.ph = phi i64 [ 1, %case2 ], [ 0, %case1 ], [ 0, %case0 ]
  br label %succ

succ:                                             ; preds = %foo.thread, %case1, %case0
  %phi2 = phi i64 [ %num, %case1 ], [ %num, %case0 ], [ %phi1.ph, %foo.thread ]
  %cond2 = icmp eq i64 %phi2, 0
  br i1 %cond2, label %exit, label %exit2

exit:                                             ; preds = %succ
  call void @use(i8 0)
  ret i64 %phi2

exit2:                                            ; preds = %succ, %case2, %2
  ret i64 0
}

define i8 @multicase_dest(i8 noundef %arg) {
; CHECK-LABEL: define i8 @multicase_dest(
; CHECK-SAME: i8 noundef [[ARG:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[SWITCH_AND:%.*]] = and i8 [[ARG]], -2
; CHECK-NEXT:    [[SWITCH_SELECTCMP:%.*]] = icmp eq i8 [[SWITCH_AND]], 0
; CHECK-NEXT:    [[PHI2:%.*]] = select i1 [[SWITCH_SELECTCMP]], i8 1, i8 3
; CHECK-NEXT:    ret i8 [[PHI2]]
;
start:
  switch i8 %arg, label %default [
  i8 0, label %block
  i8 1, label %block
  i8 2, label %succ
  i8 3, label %succ
  ]

default:                                          ; preds = %start
  br label %block

block:                                            ; preds = %default, %start, %start
  %phi1 = phi i8 [ 1, %start ], [ 1, %start ], [ 3, %default ]
  br label %succ

succ:                                             ; preds = %block, %start, %start
  %phi2 = phi i8 [ %phi1, %block ], [ 3, %start ], [ 3, %start ]
  ret i8 %phi2
}

define i8 @multicase_dest2(i8 noundef %arg, i1 %cond) {
; CHECK-LABEL: define i8 @multicase_dest2(
; CHECK-SAME: i8 noundef [[ARG:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[START:.*]]:
; CHECK-NEXT:    switch i8 [[ARG]], label %[[SUCC:.*]] [
; CHECK-NEXT:      i8 0, label %[[BLOCK:.*]]
; CHECK-NEXT:      i8 1, label %[[BLOCK]]
; CHECK-NEXT:      i8 4, label %[[CASE:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE]]:
; CHECK-NEXT:    br i1 [[COND]], label %[[BLOCK]], label %[[SUCC]]
; CHECK:       [[BLOCK]]:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i8 [ 1, %[[START]] ], [ 1, %[[START]] ], [ 4, %[[CASE]] ]
; CHECK-NEXT:    br label %[[SUCC]]
; CHECK:       [[SUCC]]:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i8 [ 4, %[[CASE]] ], [ [[PHI1]], %[[BLOCK]] ], [ 3, %[[START]] ]
; CHECK-NEXT:    ret i8 [[PHI2]]
;
start:
  switch i8 %arg, label %default [
  i8 0, label %block
  i8 1, label %block
  i8 2, label %succ
  i8 3, label %succ
  i8 4, label %case
  ]

default:                                          ; preds = %start
  br label %block

case:                                             ; preds = %start
  br i1 %cond, label %block, label %succ

block:                                            ; preds = %case, %default, %start, %start
  %phi1 = phi i8 [ 1, %start ], [ 1, %start ], [ 3, %default ], [ 4, %case ]
  br label %succ

succ:                                             ; preds = %block, %case, %start, %start
  %phi2 = phi i8 [ %phi1, %block ], [ 3, %start ], [ 3, %start ], [ 4, %case ]
  ret i8 %phi2
}
