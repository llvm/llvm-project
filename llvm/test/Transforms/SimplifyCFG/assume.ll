; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S < %s | FileCheck %s

define void @assume_false_to_unreachable1() {
; CHECK-LABEL: @assume_false_to_unreachable1(
; CHECK-NEXT:    unreachable
;
  call void @llvm.assume(i1 0)
  ret void

}

define void @assume_undef_to_unreachable() {
; CHECK-LABEL: @assume_undef_to_unreachable(
; CHECK-NEXT:    unreachable
;
  call void @llvm.assume(i1 undef)
  ret void

}

define i32 @speculate_block_with_assume_basic(i1 %c, i32 %x) {
; CHECK-LABEL: @speculate_block_with_assume_basic(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF:%.*]], label [[JOIN:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[X:%.*]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    br label [[JOIN]]
; CHECK:       join:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ 1, [[IF]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
entry:
  br i1 %c, label %if, label %join

if:
  %cmp = icmp ne i32 %x, 0
  call void @llvm.assume(i1 %cmp)
  br label %join

join:
  %phi = phi i32 [ 0, %entry ], [ 1, %if ]
  ret i32 %phi
}

define i32 @speculate_block_with_assume_extra_instr(i1 %c, i32 %x) {
; CHECK-LABEL: @speculate_block_with_assume_extra_instr(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF:%.*]], label [[JOIN:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[ADD]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    br label [[JOIN]]
; CHECK:       join:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD]], [[IF]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
entry:
  br i1 %c, label %if, label %join

if:
  %add = add i32 %x, 1
  %cmp = icmp ne i32 %add, 0
  call void @llvm.assume(i1 %cmp)
  br label %join

join:
  %phi = phi i32 [ 0, %entry ], [ %add, %if ]
  ret i32 %phi
}

define i32 @speculate_block_with_assume_extra_instrs_too_many(i1 %c, i32 %x) {
; CHECK-LABEL: @speculate_block_with_assume_extra_instrs_too_many(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF:%.*]], label [[JOIN:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[ADD]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[ADD2]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    br label [[JOIN]]
; CHECK:       join:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD2]], [[IF]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
entry:
  br i1 %c, label %if, label %join

if:
  %add = add i32 %x, 1
  %add2 = add i32 %add, 1
  %cmp = icmp ne i32 %add2, 0
  call void @llvm.assume(i1 %cmp)
  br label %join

join:
  %phi = phi i32 [ 0, %entry ], [ %add2, %if ]
  ret i32 %phi
}

define i32 @speculate_block_with_assume_extra_instrs_okay(i1 %c, i32 %x) {
; CHECK-LABEL: @speculate_block_with_assume_extra_instrs_okay(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF:%.*]], label [[JOIN:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[ADD]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[ADD2]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    br label [[JOIN]]
; CHECK:       join:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD]], [[IF]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
entry:
  br i1 %c, label %if, label %join

if:
  %add = add i32 %x, 1
  %add2 = add i32 %add, 1
  %cmp = icmp ne i32 %add2, 0
  call void @llvm.assume(i1 %cmp)
  br label %join

join:
  %phi = phi i32 [ 0, %entry ], [ %add, %if ]
  ret i32 %phi
}

define i32 @speculate_block_with_assume_operand_bundle(i1 %c, ptr %p) {
; CHECK-LABEL: @speculate_block_with_assume_operand_bundle(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF:%.*]], label [[JOIN:%.*]]
; CHECK:       if:
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(ptr [[P:%.*]]) ]
; CHECK-NEXT:    br label [[JOIN]]
; CHECK:       join:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ 1, [[IF]] ]
; CHECK-NEXT:    ret i32 [[PHI]]
;
entry:
  br i1 %c, label %if, label %join

if:
  call void @llvm.assume(i1 true) ["nonnull"(ptr %p)]
  br label %join

join:
  %phi = phi i32 [ 0, %entry ], [ 1, %if ]
  ret i32 %phi
}

declare void @llvm.assume(i1) nounwind

