; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=simplifycfg < %s | FileCheck %s

; Test the optimization that transforms select-over-pointers followed by
; GEP, load/store where one case is a no-op (load and store to same address).
;
; Pattern: A[i] = P[i] ? B[i] : A[i]
; When P[i] is false, we load from A[i] and store to A[i] - a no-op.
; The optimization creates a branch to skip the load/store in that case.
;
; Requires GEPs for both load and store with matching indices, as this is
; required for the vectorizer to convert conditional load/stores to masked
; store.

;----------------------------------------------------------------------------
; POSITIVE CASES - should be transformed
;----------------------------------------------------------------------------

; Basic case: noop when condition is true (TrueValue matches store base)
define void @noop_on_true(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @noop_on_true(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_CONT:.*]], label %[[ENTRY_DO_LDST:.*]]
; CHECK:       [[ENTRY_CONT]]:
; CHECK-NEXT:    ret void
; CHECK:       [[ENTRY_DO_LDST]]:
; CHECK-NEXT:    [[GEP_EFF:%.*]] = getelementptr float, ptr [[B]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL_EFF:%.*]] = load float, ptr [[GEP_EFF]], align 4
; CHECK-NEXT:    [[STORE_GEP_EFF:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL_EFF]], ptr [[STORE_GEP_EFF]], align 4
; CHECK-NEXT:    br label %[[ENTRY_CONT]]
;
entry:
  ; When cond is true: sel = %a, load from a[i], store to a[i] -> noop
  ; When cond is false: sel = %b, load from b[i], store to a[i] -> effective
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store float %val, ptr %store_gep
  ret void
}

; Basic case: noop when condition is false (FalseValue matches store base)
define void @noop_on_false(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @noop_on_false(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_DO_LDST:.*]], label %[[ENTRY_CONT:.*]]
; CHECK:       [[ENTRY_CONT]]:
; CHECK-NEXT:    ret void
; CHECK:       [[ENTRY_DO_LDST]]:
; CHECK-NEXT:    [[GEP_EFF:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL_EFF:%.*]] = load float, ptr [[GEP_EFF]], align 4
; CHECK-NEXT:    [[STORE_GEP_EFF:%.*]] = getelementptr float, ptr [[B]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL_EFF]], ptr [[STORE_GEP_EFF]], align 4
; CHECK-NEXT:    br label %[[ENTRY_CONT]]
;
entry:
  ; When cond is true: sel = %a, load from a[i], store to b[i] -> effective
  ; When cond is false: sel = %b, load from b[i], store to b[i] -> noop
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %b, i64 %idx
  store float %val, ptr %store_gep
  ret void
}

; With inbounds GEPs - should preserve inbounds attribute
define void @with_inbounds(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @with_inbounds(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_CONT:.*]], label %[[ENTRY_DO_LDST:.*]]
; CHECK:       [[ENTRY_CONT]]:
; CHECK-NEXT:    ret void
; CHECK:       [[ENTRY_DO_LDST]]:
; CHECK-NEXT:    [[GEP_EFF:%.*]] = getelementptr inbounds float, ptr [[B]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL_EFF:%.*]] = load float, ptr [[GEP_EFF]], align 4
; CHECK-NEXT:    [[STORE_GEP_EFF:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL_EFF]], ptr [[STORE_GEP_EFF]], align 4
; CHECK-NEXT:    br label %[[ENTRY_CONT]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr inbounds float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr inbounds float, ptr %a, i64 %idx
  store float %val, ptr %store_gep
  ret void
}

; With multiple indices in GEP
define void @multi_index_gep(ptr %a, ptr %b, i1 %cond, i64 %idx1, i64 %idx2) {
; CHECK-LABEL: define void @multi_index_gep(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX1:%.*]], i64 [[IDX2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_CONT:.*]], label %[[ENTRY_DO_LDST:.*]]
; CHECK:       [[ENTRY_CONT]]:
; CHECK-NEXT:    ret void
; CHECK:       [[ENTRY_DO_LDST]]:
; CHECK-NEXT:    [[GEP_EFF:%.*]] = getelementptr [10 x float], ptr [[B]], i64 [[IDX1]], i64 [[IDX2]]
; CHECK-NEXT:    [[VAL_EFF:%.*]] = load float, ptr [[GEP_EFF]], align 4
; CHECK-NEXT:    [[STORE_GEP_EFF:%.*]] = getelementptr [10 x float], ptr [[A]], i64 [[IDX1]], i64 [[IDX2]]
; CHECK-NEXT:    store float [[VAL_EFF]], ptr [[STORE_GEP_EFF]], align 4
; CHECK-NEXT:    br label %[[ENTRY_CONT]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr [10 x float], ptr %sel, i64 %idx1, i64 %idx2
  %val = load float, ptr %gep
  %store_gep = getelementptr [10 x float], ptr %a, i64 %idx1, i64 %idx2
  store float %val, ptr %store_gep
  ret void
}

; With integer type instead of float
define void @integer_type(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @integer_type(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_CONT:.*]], label %[[ENTRY_DO_LDST:.*]]
; CHECK:       [[ENTRY_CONT]]:
; CHECK-NEXT:    ret void
; CHECK:       [[ENTRY_DO_LDST]]:
; CHECK-NEXT:    [[GEP_EFF:%.*]] = getelementptr i32, ptr [[B]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL_EFF:%.*]] = load i32, ptr [[GEP_EFF]], align 4
; CHECK-NEXT:    [[STORE_GEP_EFF:%.*]] = getelementptr i32, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store i32 [[VAL_EFF]], ptr [[STORE_GEP_EFF]], align 4
; CHECK-NEXT:    br label %[[ENTRY_CONT]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr i32, ptr %sel, i64 %idx
  %val = load i32, ptr %gep
  %store_gep = getelementptr i32, ptr %a, i64 %idx
  store i32 %val, ptr %store_gep
  ret void
}

; With double type and alignment
define void @double_type_aligned(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @double_type_aligned(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_CONT:.*]], label %[[ENTRY_DO_LDST:.*]]
; CHECK:       [[ENTRY_CONT]]:
; CHECK-NEXT:    ret void
; CHECK:       [[ENTRY_DO_LDST]]:
; CHECK-NEXT:    [[GEP_EFF:%.*]] = getelementptr double, ptr [[B]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL_EFF:%.*]] = load double, ptr [[GEP_EFF]], align 8
; CHECK-NEXT:    [[STORE_GEP_EFF:%.*]] = getelementptr double, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store double [[VAL_EFF]], ptr [[STORE_GEP_EFF]], align 8
; CHECK-NEXT:    br label %[[ENTRY_CONT]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr double, ptr %sel, i64 %idx
  %val = load double, ptr %gep, align 8
  %store_gep = getelementptr double, ptr %a, i64 %idx
  store double %val, ptr %store_gep, align 8
  ret void
}

;----------------------------------------------------------------------------
; NEGATIVE CASES - should NOT be transformed
;----------------------------------------------------------------------------

; Store base doesn't match either select operand
define void @no_match_store_base(ptr %a, ptr %b, ptr %c, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @no_match_store_base(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], ptr [[C:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[C]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %c, i64 %idx
  store float %val, ptr %store_gep
  ret void
}

; Different indices between load GEP and store GEP
define void @different_indices(ptr %a, ptr %b, i1 %cond, i64 %idx1, i64 %idx2) {
; CHECK-LABEL: define void @different_indices(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX1:%.*]], i64 [[IDX2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX1]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX2]]
; CHECK-NEXT:    store float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx1
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx2
  store float %val, ptr %store_gep
  ret void
}

; Volatile load - don't transform
define void @volatile_load(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @volatile_load(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load volatile float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load volatile float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store float %val, ptr %store_gep
  ret void
}

; Volatile store - don't transform
define void @volatile_store(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define void @volatile_store(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store volatile float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store volatile float %val, ptr %store_gep
  ret void
}

; Select has multiple uses - don't transform
define ptr @select_multi_use(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define ptr @select_multi_use(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret ptr [[SEL]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store float %val, ptr %store_gep
  ret ptr %sel
}

; LoadGEP has multiple uses - don't transform
define ptr @load_gep_multi_use(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define ptr @load_gep_multi_use(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret ptr [[GEP]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store float %val, ptr %store_gep
  ret ptr %gep
}

; StoreGEP has multiple uses - don't transform
define ptr @store_gep_multi_use(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define ptr @store_gep_multi_use(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret ptr [[STORE_GEP]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store float %val, ptr %store_gep
  ret ptr %store_gep
}

; Load has multiple uses - don't transform
define float @load_multi_use(ptr %a, ptr %b, i1 %cond, i64 %idx) {
; CHECK-LABEL: define float @load_multi_use(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[VAL]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret float [[VAL]]
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store float %val, ptr %store_gep
  ret float %val
}

; Direct pointer (no GEP) - don't transform
define void @direct_ptr_no_gep(ptr %a, ptr %b, i1 %cond) {
; CHECK-LABEL: define void @direct_ptr_no_gep(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[SEL]], align 4
; CHECK-NEXT:    store float [[VAL]], ptr [[A]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %val = load float, ptr %sel
  store float %val, ptr %a
  ret void
}

; Store doesn't use loaded value - don't transform
define void @store_different_value(ptr %a, ptr %b, i1 %cond, i64 %idx, float %other) {
; CHECK-LABEL: define void @store_different_value(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]], i1 [[COND:%.*]], i64 [[IDX:%.*]], float [[OTHER:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr float, ptr [[SEL]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[GEP]], align 4
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[IDX]]
; CHECK-NEXT:    store float [[OTHER]], ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %sel = select i1 %cond, ptr %a, ptr %b
  %gep = getelementptr float, ptr %sel, i64 %idx
  %val = load float, ptr %gep
  %store_gep = getelementptr float, ptr %a, i64 %idx
  store float %other, ptr %store_gep
  ret void
}
