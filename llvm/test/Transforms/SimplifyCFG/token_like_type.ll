; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=simplifycfg %s | FileCheck %s

; NOTE: The Check lines should exactly match the IR.

%"$Globals" = type { i32 }
@CBV = external constant %"$Globals"
@.str = internal unnamed_addr constant [2 x i8] c"a\00", align 1

define half @CSMain() local_unnamed_addr {
; CHECK-LABEL: define half @CSMain() local_unnamed_addr {
; CHECK-NEXT:    [[LOADGLOBAL:%.*]] = load i32, ptr @CBV, align 4
; CHECK-NEXT:    [[TOBOOL_NOT_I:%.*]] = icmp eq i32 [[LOADGLOBAL]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT_I]], label %[[IF_ELSE_I:.*]], label %[[IF_THEN_I:.*]]
; CHECK:       [[IF_THEN_I]]:
; CHECK-NEXT:    [[IFSTMTCALLRAWBUFFERBINDING:%.*]] = tail call target("dx.RawBuffer", half, 1, 0) @llvm.dx.resource.handlefromimplicitbinding.tdx.RawBuffer_f16_1_0t(i32 1, i32 0, i32 1, i32 0, ptr nonnull @.str)
; CHECK-NEXT:    [[IFSTMTCALLRESOURCEGEP:%.*]] = tail call noundef nonnull align 2 dereferenceable(2) ptr @llvm.dx.resource.getpointer.p0.tdx.RawBuffer_f16_1_0t(target("dx.RawBuffer", half, 1, 0) [[IFSTMTCALLRAWBUFFERBINDING]], i32 [[LOADGLOBAL]])
; CHECK-NEXT:    br label %[[_Z6CSMAINV_EXIT:.*]]
; CHECK:       [[IF_ELSE_I]]:
; CHECK-NEXT:    [[CALL2NDRAWBUFFERBINDING:%.*]] = tail call target("dx.RawBuffer", half, 1, 0) @llvm.dx.resource.handlefromimplicitbinding.tdx.RawBuffer_f16_1_0t(i32 0, i32 0, i32 1, i32 0, ptr nonnull @.str)
; CHECK-NEXT:    [[ELSESTMTCALLRESOURCEGEP:%.*]] = tail call noundef nonnull align 2 dereferenceable(2) ptr @llvm.dx.resource.getpointer.p0.tdx.RawBuffer_f16_1_0t(target("dx.RawBuffer", half, 1, 0) [[CALL2NDRAWBUFFERBINDING]], i32 [[LOADGLOBAL]])
; CHECK-NEXT:    br label %[[_Z6CSMAINV_EXIT]]
; CHECK:       [[_Z6CSMAINV_EXIT]]:
; CHECK-NEXT:    [[DOTSINK1:%.*]] = phi ptr [ [[IFSTMTCALLRESOURCEGEP]], %[[IF_THEN_I]] ], [ [[ELSESTMTCALLRESOURCEGEP]], %[[IF_ELSE_I]] ]
; CHECK-NEXT:    [[LOADSINK:%.*]] = load half, ptr [[DOTSINK1]], align 2
; CHECK-NEXT:    ret half [[LOADSINK]]
;
  %loadGlobal = load i32, ptr @CBV, align 4
  %tobool.not.i = icmp eq i32 %loadGlobal, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

  if.then.i:                                        ; preds = %entry
  %ifStmtcallRawBufferBinding = tail call target("dx.RawBuffer", half, 1, 0) @llvm.dx.resource.handlefromimplicitbinding.tdx.RawBuffer_f16_1_0t(i32 1, i32 0, i32 1, i32 0, ptr nonnull @.str)
  %ifStmtCallResourceGEP = tail call noundef nonnull align 2 dereferenceable(2) ptr @llvm.dx.resource.getpointer.p0.tdx.RawBuffer_f16_1_0t(target("dx.RawBuffer", half, 1, 0) %ifStmtcallRawBufferBinding, i32 %loadGlobal)
  br label %_Z6CSMainv.exit

  if.else.i:                                        ; preds = %entry
  %call2ndRawBufferBinding = tail call target("dx.RawBuffer", half, 1, 0) @llvm.dx.resource.handlefromimplicitbinding.tdx.RawBuffer_f16_1_0t(i32 0, i32 0, i32 1, i32 0, ptr nonnull @.str)
  %elseStmtCallResourceGEP = tail call noundef nonnull align 2 dereferenceable(2) ptr @llvm.dx.resource.getpointer.p0.tdx.RawBuffer_f16_1_0t(target("dx.RawBuffer", half, 1, 0) %call2ndRawBufferBinding, i32 %loadGlobal)
  br label %_Z6CSMainv.exit

  _Z6CSMainv.exit:                                  ; preds = %if.else.i, %if.then.i
  %.sink1 = phi ptr [ %ifStmtCallResourceGEP, %if.then.i ], [ %elseStmtCallResourceGEP, %if.else.i ]
  %loadSink = load half, ptr %.sink1, align 2
  ret half %loadSink
}
