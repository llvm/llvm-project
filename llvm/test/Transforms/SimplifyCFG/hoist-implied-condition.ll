; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=simplifycfg -S | FileCheck %s

define i32 @src(ptr %contents.0, i64 %contents.1) {
; CHECK-LABEL: define i32 @src(
; CHECK-SAME: ptr [[CONTENTS_0:%.*]], i64 [[CONTENTS_1:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i64 [[CONTENTS_1]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF:.*]], label %[[EXIT:.*]]
; CHECK:       [[IF]]:
; CHECK-NEXT:    [[LOAD:%.*]] = load i64, ptr [[CONTENTS_0]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i64 [[LOAD]], 123
; CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i64 [[CONTENTS_1]], 16
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[CMP2]], true
; CHECK-NEXT:    br i1 [[AND]], label %[[COMMON_RET:.*]], label %[[EXIT]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, %[[EXIT]] ], [ 1, %[[IF]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
start:
  %cmp1 = icmp ugt i64 %contents.1, 7
  br i1 %cmp1, label %if, label %exit

if:
  %load = load i64, ptr %contents.0
  %cmp2 = icmp eq i64 %load, 123
  %cmp3 = icmp eq i64 %contents.1, 16
  %and = and i1 %cmp2, %cmp3
  br i1 %and, label %if2, label %exit

if2:
  ret i32 1

exit:
  ret i32 0
}

define i32 @src-and(ptr %contents.0, i64 %contents.1) {
; CHECK-LABEL: define i32 @src-and(
; CHECK-SAME: ptr [[CONTENTS_0:%.*]], i64 [[CONTENTS_1:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i64 [[CONTENTS_1]], 16
; CHECK-NEXT:    br i1 [[TMP0]], label %[[IF:.*]], label %[[EXIT:.*]]
; CHECK:       [[IF]]:
; CHECK-NEXT:    [[LOAD:%.*]] = load i64, ptr [[CONTENTS_0]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i64 [[LOAD]], 123
; CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i64 [[CONTENTS_1]], 16
; CHECK-NEXT:    [[AND:%.*]] = or i1 [[CMP2]], true
; CHECK-NEXT:    br i1 [[AND]], label %[[COMMON_RET:.*]], label %[[EXIT]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, %[[EXIT]] ], [ 1, %[[IF]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
start:
  %cmp1 = icmp ugt i64 %contents.1, 7
  br i1 %cmp1, label %if, label %exit

if:
  %load = load i64, ptr %contents.0
  %cmp2 = icmp eq i64 %load, 123
  %cmp3 = icmp eq i64 %contents.1, 16
  %and = or i1 %cmp2, %cmp3
  br i1 %and, label %if2, label %exit

if2:
  ret i32 1

exit:
  ret i32 0
}

define i32 @src-sideeffects(ptr %contents.0, i64 %contents.1) {
; CHECK-LABEL: define i32 @src-sideeffects(
; CHECK-SAME: ptr [[CONTENTS_0:%.*]], i64 [[CONTENTS_1:%.*]]) {
; CHECK-NEXT:  [[START:.*:]]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ugt i64 [[CONTENTS_1]], 7
; CHECK-NEXT:    br i1 [[CMP1]], label %[[IF:.*]], label %[[EXIT:.*]]
; CHECK:       [[IF]]:
; CHECK-NEXT:    [[LOAD:%.*]] = load i64, ptr [[CONTENTS_0]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i64 [[LOAD]], 123
; CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i64 [[CONTENTS_1]], 16
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[CMP2]], [[CMP3]]
; CHECK-NEXT:    [[ADD:%.*]] = add i64 [[LOAD]], [[CONTENTS_1]]
; CHECK-NEXT:    store i64 [[ADD]], ptr [[CONTENTS_0]], align 4
; CHECK-NEXT:    br i1 [[AND]], label %[[COMMON_RET:.*]], label %[[EXIT]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    [[COMMON_RET_OP:%.*]] = phi i32 [ 0, %[[EXIT]] ], [ 1, %[[IF]] ]
; CHECK-NEXT:    ret i32 [[COMMON_RET_OP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    br label %[[COMMON_RET]]
;
start:
  %cmp1 = icmp ugt i64 %contents.1, 7
  br i1 %cmp1, label %if, label %exit

if:
  %load = load i64, ptr %contents.0
  %cmp2 = icmp eq i64 %load, 123
  %cmp3 = icmp eq i64 %contents.1, 16
  %and = and i1 %cmp2, %cmp3
  %add = add i64 %load, %contents.1
  store i64 %add, ptr %contents.0
  br i1 %and, label %if2, label %exit

if2:
  ret i32 1

exit:
  ret i32 0
}
