; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --check-globals --version 2
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -S < %s | FileCheck %s --check-prefixes=CHECK
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S < %s | FileCheck %s --check-prefixes=CHECK-DL
;
; Test cases specifically designed for the "no-capture" argument attribute.
; We use FIXME's to indicate problems and missing attributes.
;

declare ptr @unknown()

; TEST comparison against NULL
;
; int is_null_return(int *p) {
;   return p == 0;
; }
;
; no-capture is missing on %p because it is not dereferenceable
define i32 @is_null_return(ptr %p) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define i32 @is_null_return
; CHECK-SAME: (ptr nofree readnone [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[P]], null
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define noundef i32 @is_null_return
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret i32 0
;
entry:
  %cmp = icmp eq ptr %p, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; TEST comparison against NULL in control flow
;
; int is_null_control(int *p) {
;   if (p == 0)
;     return 1;
;   if (0 == p)
;     return 1;
;   return 0;
; }
;
; no-capture is missing on %p because it is not dereferenceable
define i32 @is_null_control(ptr %p) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define i32 @is_null_control
; CHECK-SAME: (ptr nofree [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[P]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store i32 1, ptr [[RETVAL]], align 4
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    br label [[IF_END3:%.*]]
; CHECK:       if.then2:
; CHECK-NEXT:    unreachable
; CHECK:       if.end3:
; CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[RETVAL]], align 4
; CHECK-NEXT:    ret i32 [[TMP0]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define i32 @is_null_control
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[P:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
; CHECK-DL-NEXT:    br label [[IF_END:%.*]]
; CHECK-DL:       if.then:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    br label [[IF_END3:%.*]]
; CHECK-DL:       if.then2:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end3:
; CHECK-DL-NEXT:    br label [[RETURN:%.*]]
; CHECK-DL:       return:
; CHECK-DL-NEXT:    ret i32 0
;
entry:
  %retval = alloca i32, align 4
  %cmp = icmp eq ptr %p, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq ptr null, %p
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %0 = load i32, ptr %retval, align 4
  ret i32 %0
}

; TEST SCC with various calls, casts, and comparisons agains NULL
;
; float *scc_A(int *a) {
;   return (float*)(a ? (int*)scc_A((int*)scc_B((double*)scc_C((short*)a))) : a);
; }
;
; long *scc_B(double *a) {
;   return (long*)(a ? scc_C((short*)scc_B((double*)scc_A((int*)a))) : a);
; }
;
; void *scc_C(short *a) {
;   return scc_A((int*)(scc_A(a) ? scc_B((double*)a) : scc_C(a)));
; }
define ptr @scc_A(ptr dereferenceable_or_null(4) %a) {
; CHECK: Function Attrs: nofree nosync nounwind memory(none)
; CHECK-LABEL: define noundef dereferenceable_or_null(4) ptr @scc_A
; CHECK-SAME: (ptr nofree noundef readnone returned dereferenceable_or_null(4) "no-capture-maybe-returned" [[A:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne ptr [[A]], null
; CHECK-NEXT:    br i1 [[TOBOOL]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[CALL:%.*]] = call dereferenceable_or_null(4) ptr @scc_C(ptr noalias nofree noundef nonnull readnone dereferenceable(4) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    [[CALL1:%.*]] = call dereferenceable_or_null(8) ptr @scc_B(ptr noalias nofree noundef readnone dereferenceable_or_null(8) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    [[CALL2:%.*]] = call ptr @scc_A(ptr noalias nofree noundef readnone dereferenceable_or_null(8) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       cond.false:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi ptr [ [[A]], [[COND_TRUE]] ], [ [[A]], [[COND_FALSE]] ]
; CHECK-NEXT:    ret ptr [[A]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noreturn nosync nounwind willreturn memory(none)
; CHECK-DL-LABEL: define noalias nonnull align 4294967296 dereferenceable(4294967295) ptr @scc_A
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone dereferenceable(4) [[A:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[COND_TRUE:%.*]]
; CHECK-DL:       cond.true:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       cond.false:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       cond.end:
; CHECK-DL-NEXT:    unreachable
;
entry:
  %tobool = icmp ne ptr %a, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call = call ptr @scc_C(ptr %a)
  %call1 = call ptr @scc_B(ptr %call)
  %call2 = call ptr @scc_A(ptr %call1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ %a, %cond.false ]
  ret ptr %cond
}

; FIXME: the call1 below to scc_B should return dereferenceable_or_null(8) (as the callee does). Something prevented that deduction and needs to be investigated.
define ptr @scc_B(ptr dereferenceable_or_null(8) %a) {
; CHECK: Function Attrs: nofree nosync nounwind memory(none)
; CHECK-LABEL: define noundef dereferenceable_or_null(8) ptr @scc_B
; CHECK-SAME: (ptr nofree noundef readnone returned dereferenceable_or_null(8) "no-capture-maybe-returned" [[A:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne ptr [[A]], null
; CHECK-NEXT:    br i1 [[TOBOOL]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[CALL:%.*]] = call dereferenceable_or_null(4) ptr @scc_A(ptr noalias nofree noundef nonnull readnone dereferenceable(8) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    [[CALL1:%.*]] = call dereferenceable_or_null(8) ptr @scc_B(ptr noalias nofree noundef readnone dereferenceable_or_null(8) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    [[CALL2:%.*]] = call ptr @scc_C(ptr noalias nofree noundef readnone dereferenceable_or_null(8) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       cond.false:
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi ptr [ [[A]], [[COND_TRUE]] ], [ [[A]], [[COND_FALSE]] ]
; CHECK-NEXT:    ret ptr [[A]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noreturn nosync nounwind willreturn memory(none)
; CHECK-DL-LABEL: define noalias nonnull align 4294967296 dereferenceable(4294967295) ptr @scc_B
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone dereferenceable(8) [[A:%.*]]) #[[ATTR1]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[COND_TRUE:%.*]]
; CHECK-DL:       cond.true:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       cond.false:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       cond.end:
; CHECK-DL-NEXT:    unreachable
;
entry:
  %tobool = icmp ne ptr %a, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call = call ptr @scc_A(ptr %a)
  %call1 = call ptr @scc_B(ptr %call)
  %call2 = call ptr @scc_C(ptr %call1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ %a, %cond.false ]
  ret ptr %cond
}

define ptr @scc_C(ptr dereferenceable_or_null(2) %a) {
; CHECK: Function Attrs: nofree nosync nounwind memory(none)
; CHECK-LABEL: define noundef dereferenceable_or_null(4) ptr @scc_C
; CHECK-SAME: (ptr nofree noundef readnone returned dereferenceable_or_null(4) "no-capture-maybe-returned" [[A:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call dereferenceable_or_null(4) ptr @scc_A(ptr noalias nofree noundef readnone dereferenceable_or_null(4) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne ptr [[A]], null
; CHECK-NEXT:    br i1 [[TOBOOL]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[CALL1:%.*]] = call ptr @scc_B(ptr noalias nofree noundef readnone dereferenceable_or_null(8) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       cond.false:
; CHECK-NEXT:    [[CALL2:%.*]] = call ptr @scc_C(ptr noalias nofree noundef readnone dereferenceable_or_null(4) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi ptr [ [[A]], [[COND_TRUE]] ], [ [[A]], [[COND_FALSE]] ]
; CHECK-NEXT:    [[CALL3:%.*]] = call ptr @scc_A(ptr noalias nofree noundef readnone dereferenceable_or_null(4) "no-capture-maybe-returned" [[A]]) #[[ATTR1]]
; CHECK-NEXT:    ret ptr [[A]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noreturn nosync nounwind willreturn memory(none)
; CHECK-DL-LABEL: define noalias nonnull align 4294967296 dereferenceable(4294967295) ptr @scc_C
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone dereferenceable(4) [[A:%.*]]) #[[ATTR1]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       cond.true:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       cond.false:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       cond.end:
; CHECK-DL-NEXT:    unreachable
;
entry:
  %call = call ptr @scc_A(ptr %a)
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call ptr @scc_B(ptr %a)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = call ptr @scc_C(ptr %a)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call1, %cond.true ], [ %call2, %cond.false ]
  %call3 = call ptr @scc_A(ptr %cond)
  ret ptr %call3
}

; TEST return argument or unknown call result
;
; int* ret_arg_or_unknown(int* b) {
;   if (b == 0)
;     return b;
;   return unknown();
; }
;
; Verify we do *not* assume b is returned or not captured.
;

define ptr @ret_arg_or_unknown(ptr %b) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define ptr @ret_arg_or_unknown
; CHECK-SAME: (ptr [[B:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG:%.*]], label [[RET_UNKNOWN:%.*]]
; CHECK:       ret_arg:
; CHECK-NEXT:    ret ptr [[B]]
; CHECK:       ret_unknown:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @unknown()
; CHECK-NEXT:    ret ptr [[CALL]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define nonnull ptr @ret_arg_or_unknown
; CHECK-DL-SAME: (ptr nofree nonnull readnone "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[RET_UNKNOWN:%.*]]
; CHECK-DL:       ret_arg:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       ret_unknown:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call nonnull ptr @unknown()
; CHECK-DL-NEXT:    ret ptr [[CALL]]
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %ret_arg, label %ret_unknown

ret_arg:
  ret ptr %b

ret_unknown:
  %call = call ptr @unknown()
  ret ptr %call
}

define ptr @ret_arg_or_unknown_through_phi(ptr %b) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define ptr @ret_arg_or_unknown_through_phi
; CHECK-SAME: (ptr [[B:%.*]]) #[[ATTR2]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG:%.*]], label [[RET_UNKNOWN:%.*]]
; CHECK:       ret_arg:
; CHECK-NEXT:    br label [[R:%.*]]
; CHECK:       ret_unknown:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @unknown()
; CHECK-NEXT:    br label [[R]]
; CHECK:       r:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[B]], [[RET_ARG]] ], [ [[CALL]], [[RET_UNKNOWN]] ]
; CHECK-NEXT:    ret ptr [[PHI]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define nonnull ptr @ret_arg_or_unknown_through_phi
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[B:%.*]]) #[[ATTR2]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[RET_UNKNOWN:%.*]]
; CHECK-DL:       ret_arg:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       ret_unknown:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call nonnull ptr @unknown()
; CHECK-DL-NEXT:    br label [[R:%.*]]
; CHECK-DL:       r:
; CHECK-DL-NEXT:    ret ptr [[CALL]]
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %ret_arg, label %ret_unknown

ret_arg:
  br label %r

ret_unknown:
  %call = call ptr @unknown()
  br label %r

r:
  %phi = phi ptr [ %b, %ret_arg ], [ %call, %ret_unknown ]
  ret ptr %phi
}

attributes #0 = { noinline nounwind uwtable }
;.
; CHECK: attributes #[[ATTR0]] = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable }
; CHECK: attributes #[[ATTR1]] = { nofree nosync nounwind memory(none) }
; CHECK: attributes #[[ATTR2]] = { noinline nounwind uwtable }
;.
; CHECK-DL: attributes #[[ATTR0]] = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable }
; CHECK-DL: attributes #[[ATTR1]] = { mustprogress nofree noreturn nosync nounwind willreturn memory(none) }
; CHECK-DL: attributes #[[ATTR2]] = { noinline nounwind uwtable }
;.
