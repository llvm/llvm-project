; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=amdgcn-amd-amdhsa -passes=attributor %s -S | FileCheck %s --check-prefix=AMDGCN

@G = addrspace(1) global i32 zeroinitializer, align 4
declare void @clobber(i32) #0
declare ptr addrspace(1) @get_ptr() #0
attributes #0 = { nofree norecurse nosync nounwind willreturn }

define void @test_nonkernel(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define void @test_nonkernel(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR1:[0-9]+]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4:[0-9]+]]
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; may not be !invariant.load, as the caller may modify %ptr
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_plain(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_plain(
; AMDGCN-SAME: ptr addrspace(1) nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; may not be !invariant.load, as %ptr may alias a pointer in @clobber
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_noalias_ptr(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_noalias_ptr(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0:![0-9]+]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_swap(ptr addrspace(1) noalias %ptr, i32 inreg %swap) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_swap(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]], i32 inreg [[SWAP:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    store i32 [[SWAP]], ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; cannot be !invariant.load due to the write to %ptr
  store i32 %swap, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_volatile(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_volatile(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef align 4 [[PTR:%.*]]) #[[ATTR2:[0-9]+]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load volatile i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = load volatile i32, ptr addrspace(1) %ptr, align 4
  ;; volatiles loads cannot be !invariant.load
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_unordered(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_unordered(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load atomic i32, ptr addrspace(1) [[PTR]] unordered, align 4, !invariant.load [[META0]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = load atomic i32, ptr addrspace(1) %ptr unordered, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_monotonic(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_monotonic(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load atomic i32, ptr addrspace(1) [[PTR]] monotonic, align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = load atomic i32, ptr addrspace(1) %ptr monotonic, align 4
  ;; atomic loads with ordering guarantees may have side effects
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_global() {
; AMDGCN-LABEL: define amdgpu_kernel void @test_global(
; AMDGCN-SAME: ) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) @G, align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) @G, align 4
  ;; is not an !invariant.load as global variables may change
  call void @clobber(i32 %val)
  ret void
}

define internal i32 @test_internal_noalias_load(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define internal i32 @test_internal_noalias_load(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR3:[0-9]+]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0]]
; AMDGCN-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; is an !invariant.load due to its only caller @test_call_internal_noalias
  ret i32 %val
}

define amdgpu_kernel void @test_call_internal_noalias(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_internal_noalias(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree readonly captures(none) [[PTR:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = call i32 @test_internal_noalias_load(ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) [[PTR]]) #[[ATTR5:[0-9]+]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = call i32 @test_internal_noalias_load(ptr addrspace(1) %ptr)
  call void @clobber(i32 %val)
  ret void
}

define internal i32 @test_internal_load(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define internal i32 @test_internal_load(
; AMDGCN-SAME: ptr addrspace(1) nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR3]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; may not be an !invariant.load since the pointer in @test_call_internal may alias
  ret i32 %val
}

define amdgpu_kernel void @test_call_internal(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_internal(
; AMDGCN-SAME: ptr addrspace(1) nofree readonly captures(none) [[PTR:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = call i32 @test_internal_load(ptr addrspace(1) nofree noundef readonly align 4 captures(none) [[PTR]]) #[[ATTR5]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %val = call i32 @test_internal_load(ptr addrspace(1) %ptr)
  call void @clobber(i32 %val)
  ret void
}

define internal i32 @test_internal_written(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define internal i32 @test_internal_written(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR3]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; cannot be an !invariant.load because of the write in caller @test_call_internal_written
  ret i32 %val
}

define amdgpu_kernel void @test_call_internal_written(ptr addrspace(1) noalias %ptr, i32 inreg %x) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_internal_written(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]], i32 inreg [[X:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    store i32 [[X]], ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    [[VAL:%.*]] = call i32 @test_internal_written(ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR]]) #[[ATTR5]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  store i32 %x, ptr addrspace(1) %ptr
  %val = call i32 @test_internal_written(ptr addrspace(1) %ptr)
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_call_ptr() {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_ptr(
; AMDGCN-SAME: ) #[[ATTR1]] {
; AMDGCN-NEXT:    [[PTR:%.*]] = call align 4 ptr addrspace(1) @get_ptr() #[[ATTR4]]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %ptr = call ptr addrspace(1) @get_ptr()
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; may not be an !invariant.load since %ptr may alias
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_selected_load(i1 inreg %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) noalias %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_selected_load(
; AMDGCN-SAME: i1 inreg [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[PTR:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PTR_TRUE]], ptr addrspace(1) [[PTR_FALSE]]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %ptr = select i1 %cond, ptr addrspace(1) %ptr.true, ptr addrspace(1) %ptr.false
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; either pointer yields an !invariant.load
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_selected_load_partial_noalias(i1 inreg %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_selected_load_partial_noalias(
; AMDGCN-SAME: i1 inreg [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:    [[PTR:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PTR_TRUE]], ptr addrspace(1) [[PTR_FALSE]]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
  %ptr = select i1 %cond, ptr addrspace(1) %ptr.true, ptr addrspace(1) %ptr.false
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; %ptr.false may alias, so no !invariant.load
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_branch_load(i1 %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) noalias %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_branch_load(
; AMDGCN-SAME: i1 noundef [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:  [[ENTRY:.*:]]
; AMDGCN-NEXT:    br i1 [[COND]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; AMDGCN:       [[TRUE]]:
; AMDGCN-NEXT:    call void @clobber(i32 noundef 1) #[[ATTR4]]
; AMDGCN-NEXT:    br label %[[FINISH:.*]]
; AMDGCN:       [[FALSE]]:
; AMDGCN-NEXT:    br label %[[FINISH]]
; AMDGCN:       [[FINISH]]:
; AMDGCN-NEXT:    [[PTR:%.*]] = phi ptr addrspace(1) [ [[PTR_TRUE]], %[[TRUE]] ], [ [[PTR_FALSE]], %[[FALSE]] ]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
entry:
  br i1 %cond, label %true, label %false
true:
  call void @clobber(i32 1)
  br label %finish
false:
  br label %finish
finish:
  %ptr = phi ptr addrspace(1) [ %ptr.true, %true ], [ %ptr.false, %false ]
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; either pointer yields an !invariant.load
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_branch_load_partial_noalias(i1 %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_branch_load_partial_noalias(
; AMDGCN-SAME: i1 noundef [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR1]] {
; AMDGCN-NEXT:  [[ENTRY:.*:]]
; AMDGCN-NEXT:    br i1 [[COND]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; AMDGCN:       [[TRUE]]:
; AMDGCN-NEXT:    call void @clobber(i32 noundef 1) #[[ATTR4]]
; AMDGCN-NEXT:    br label %[[FINISH:.*]]
; AMDGCN:       [[FALSE]]:
; AMDGCN-NEXT:    br label %[[FINISH]]
; AMDGCN:       [[FINISH]]:
; AMDGCN-NEXT:    [[PTR:%.*]] = phi ptr addrspace(1) [ [[PTR_TRUE]], %[[TRUE]] ], [ [[PTR_FALSE]], %[[FALSE]] ]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]]) #[[ATTR4]]
; AMDGCN-NEXT:    ret void
;
entry:
  br i1 %cond, label %true, label %false
true:
  call void @clobber(i32 1)
  br label %finish
false:
  br label %finish
finish:
  %ptr = phi ptr addrspace(1) [ %ptr.true, %true ], [ %ptr.false, %false ]
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ;; ptr.false may alias, so no !invariant.load
  call void @clobber(i32 %val)
  ret void
}
;.
; AMDGCN: [[META0]] = !{}
;.
