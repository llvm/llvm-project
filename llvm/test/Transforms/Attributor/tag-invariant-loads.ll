; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=attributor %s -S | FileCheck %s

@G = global i32 zeroinitializer, align 4

declare ptr @get_ptr()
declare noalias ptr @get_noalias_ptr()

define i32 @test_plain(ptr %ptr) {
; CHECK-LABEL: define i32 @test_plain(
; CHECK-SAME: ptr nofree noundef nonnull readonly align 4 captures(none) dereferenceable(4) [[PTR:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_noalias_ptr(ptr noalias %ptr) {
; CHECK-LABEL: define i32 @test_noalias_ptr(
; CHECK-SAME: ptr noalias nofree noundef nonnull readonly align 4 captures(none) dereferenceable(4) [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4, !invariant.load [[META0:![0-9]+]]
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_swap(ptr noalias %ptr, i32 %write) {
; CHECK-LABEL: define i32 @test_swap(
; CHECK-SAME: ptr noalias nofree noundef nonnull align 4 captures(none) dereferenceable(4) [[PTR:%.*]], i32 [[WRITE:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    store i32 [[WRITE]], ptr [[PTR]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr %ptr, align 4
  store i32 %write, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_volatile_load(ptr noalias %ptr) {
; CHECK-LABEL: define i32 @test_volatile_load(
; CHECK-SAME: ptr noalias nofree noundef align 4 [[PTR:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:    [[VAL:%.*]] = load volatile i32, ptr [[PTR]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load volatile i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_atomic_load(ptr noalias %ptr) {
; CHECK-LABEL: define i32 @test_atomic_load(
; CHECK-SAME: ptr noalias nofree noundef nonnull readonly align 4 captures(none) dereferenceable(4) [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = load atomic i32, ptr [[PTR]] unordered, align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load atomic i32, ptr %ptr unordered, align 4
  ret i32 %val
}

define i32 @test_atomic_volatile_load(ptr noalias %ptr) {
; CHECK-LABEL: define i32 @test_atomic_volatile_load(
; CHECK-SAME: ptr noalias nofree noundef align 4 [[PTR:%.*]]) #[[ATTR2]] {
; CHECK-NEXT:    [[VAL:%.*]] = load atomic volatile i32, ptr [[PTR]] unordered, align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load atomic volatile i32, ptr %ptr unordered, align 4
  ret i32 %val
}

define i32 @test_global() {
; CHECK-LABEL: define i32 @test_global(
; CHECK-SAME: ) #[[ATTR3:[0-9]+]] {
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr @G, align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr @G, align 4
  ret i32 %val
}

define internal i32 @test_internal_noalias_load(ptr %ptr) {
; CHECK-LABEL: define internal i32 @test_internal_noalias_load(
; CHECK-SAME: ptr noalias nofree noundef nonnull readonly align 4 captures(none) dereferenceable(4) [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4, !invariant.load [[META0]]
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_call_internal_noalias(ptr noalias %ptr) {
; CHECK-LABEL: define i32 @test_call_internal_noalias(
; CHECK-SAME: ptr noalias nofree readonly captures(none) [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = call i32 @test_internal_noalias_load(ptr noalias nofree noundef readonly align 4 captures(none) [[PTR]]) #[[ATTR4:[0-9]+]]
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = call i32 @test_internal_noalias_load(ptr %ptr)
  ret i32 %val
}

define internal i32 @test_internal_load(ptr %ptr) {
; CHECK-LABEL: define internal i32 @test_internal_load(
; CHECK-SAME: ptr nofree noundef nonnull readonly align 4 captures(none) dereferenceable(4) [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_call_internal(ptr %ptr) {
; CHECK-LABEL: define i32 @test_call_internal(
; CHECK-SAME: ptr nofree readonly captures(none) [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = call i32 @test_internal_load(ptr nofree noundef readonly align 4 captures(none) [[PTR]]) #[[ATTR4]]
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %val = call i32 @test_internal_load(ptr %ptr)
  ret i32 %val
}

define i32 @test_call_ptr() {
; CHECK-LABEL: define i32 @test_call_ptr() {
; CHECK-NEXT:    [[PTR:%.*]] = call ptr @get_ptr()
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %ptr = call ptr @get_ptr()
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_call_noalias_ptr() {
; CHECK-LABEL: define i32 @test_call_noalias_ptr() {
; CHECK-NEXT:    [[PTR:%.*]] = call noalias ptr @get_noalias_ptr()
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4, !invariant.load [[META0]]
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %ptr = call ptr @get_noalias_ptr()
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_selected_load(i1 %cond, ptr noalias %ptr.true, ptr noalias %ptr.false) {
; CHECK-LABEL: define i32 @test_selected_load(
; CHECK-SAME: i1 [[COND:%.*]], ptr noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr noalias nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR:%.*]] = select i1 [[COND]], ptr [[PTR_TRUE]], ptr [[PTR_FALSE]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4, !invariant.load [[META0]]
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %ptr = select i1 %cond, ptr %ptr.true, ptr %ptr.false
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_selected_load_partial_noalias(i1 %cond, ptr noalias %ptr.true, ptr %ptr.false) {
; CHECK-LABEL: define i32 @test_selected_load_partial_noalias(
; CHECK-SAME: i1 [[COND:%.*]], ptr noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR:%.*]] = select i1 [[COND]], ptr [[PTR_TRUE]], ptr [[PTR_FALSE]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %ptr = select i1 %cond, ptr %ptr.true, ptr %ptr.false
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_branch_load(i1 %cond, ptr noalias %ptr.true, ptr noalias %ptr.false) {
; CHECK-LABEL: define i32 @test_branch_load(
; CHECK-SAME: i1 noundef [[COND:%.*]], ptr noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr noalias nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    br label %[[FINISH:.*]]
; CHECK:       [[FALSE]]:
; CHECK-NEXT:    br label %[[FINISH]]
; CHECK:       [[FINISH]]:
; CHECK-NEXT:    [[PTR:%.*]] = phi ptr [ [[PTR_TRUE]], %[[TRUE]] ], [ [[PTR_FALSE]], %[[FALSE]] ]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4, !invariant.load [[META0]]
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  br i1 %cond, label %true, label %false
true:
  br label %finish
false:
  br label %finish
finish:
  %ptr = phi ptr [ %ptr.true, %true ], [ %ptr.false, %false ]
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}

define i32 @test_branch_load_partial_noalias(i1 %cond, ptr noalias %ptr.true, ptr %ptr.false) {
; CHECK-LABEL: define i32 @test_branch_load_partial_noalias(
; CHECK-SAME: i1 noundef [[COND:%.*]], ptr noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr nofree readonly captures(none) [[PTR_FALSE:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    br label %[[FINISH:.*]]
; CHECK:       [[FALSE]]:
; CHECK-NEXT:    br label %[[FINISH]]
; CHECK:       [[FINISH]]:
; CHECK-NEXT:    [[PTR:%.*]] = phi ptr [ [[PTR_TRUE]], %[[TRUE]] ], [ [[PTR_FALSE]], %[[FALSE]] ]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  br i1 %cond, label %true, label %false
true:
  br label %finish
false:
  br label %finish
finish:
  %ptr = phi ptr [ %ptr.true, %true ], [ %ptr.false, %false ]
  %val = load i32, ptr %ptr, align 4
  ret i32 %val
}
;.
; CHECK: [[META0]] = !{}
;.
