; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=amdgcn-amd-hsa -passes=attributor %s -S | FileCheck %s --check-prefix=AMDGCN

@G = addrspace(1) global i32 zeroinitializer, align 4
declare void @clobber(i32)
declare ptr addrspace(1) @get_ptr()
declare noalias ptr addrspace(1) @get_noalias_ptr()

define void @test_nonkernel(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define void @test_nonkernel(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_plain(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_plain(
; AMDGCN-SAME: ptr addrspace(1) nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_noalias_ptr(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_noalias_ptr(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0:![0-9]+]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_swap(ptr addrspace(1) noalias %ptr, i32 inreg %swap) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_swap(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]], i32 inreg [[SWAP:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    store i32 [[SWAP]], ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  store i32 %swap, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_volatile(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_volatile(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef align 4 [[PTR:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = load volatile i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = load volatile i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_atomic(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_atomic(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = load atomic i32, ptr addrspace(1) [[PTR]] unordered, align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = load atomic i32, ptr addrspace(1) %ptr unordered, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_global() {
; AMDGCN-LABEL: define amdgpu_kernel void @test_global() {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) @G, align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = load i32, ptr addrspace(1) @G, align 4
  call void @clobber(i32 %val)
  ret void
}

define internal i32 @test_internal_noalias_load(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define internal i32 @test_internal_noalias_load(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR0:[0-9]+]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0]]
; AMDGCN-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ret i32 %val
}

define amdgpu_kernel void @test_call_internal_noalias(ptr addrspace(1) noalias %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_internal_noalias(
; AMDGCN-SAME: ptr addrspace(1) noalias nofree readonly captures(none) [[PTR:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = call i32 @test_internal_noalias_load(ptr addrspace(1) noalias nofree noundef readonly align 4 captures(none) [[PTR]]) #[[ATTR1:[0-9]+]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = call i32 @test_internal_noalias_load(ptr addrspace(1) %ptr)
  call void @clobber(i32 %val)
  ret void
}

define internal i32 @test_internal_load(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define internal i32 @test_internal_load(
; AMDGCN-SAME: ptr addrspace(1) nofree noundef readonly align 4 captures(none) dereferenceable_or_null(4) [[PTR:%.*]]) #[[ATTR0]] {
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    ret i32 [[VAL]]
;
  %val = load i32, ptr addrspace(1) %ptr, align 4
  ret i32 %val
}

define amdgpu_kernel void @test_call_internal(ptr addrspace(1) %ptr) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_internal(
; AMDGCN-SAME: ptr addrspace(1) nofree readonly captures(none) [[PTR:%.*]]) {
; AMDGCN-NEXT:    [[VAL:%.*]] = call i32 @test_internal_load(ptr addrspace(1) nofree noundef readonly align 4 captures(none) [[PTR]]) #[[ATTR1]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %val = call i32 @test_internal_load(ptr addrspace(1) %ptr)
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_call_ptr() {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_ptr() {
; AMDGCN-NEXT:    [[PTR:%.*]] = call ptr addrspace(1) @get_ptr()
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %ptr = call ptr addrspace(1) @get_ptr()
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_call_noalias_ptr() {
; AMDGCN-LABEL: define amdgpu_kernel void @test_call_noalias_ptr() {
; AMDGCN-NEXT:    [[PTR:%.*]] = call ptr addrspace(1) @get_noalias_ptr()
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %ptr = call ptr addrspace(1) @get_noalias_ptr()
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_selected_load(i1 inreg %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) noalias %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_selected_load(
; AMDGCN-SAME: i1 inreg [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_FALSE:%.*]]) {
; AMDGCN-NEXT:    [[PTR:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PTR_TRUE]], ptr addrspace(1) [[PTR_FALSE]]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %ptr = select i1 %cond, ptr addrspace(1) %ptr.true, ptr addrspace(1) %ptr.false
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_selected_load_partial_noalias(i1 inreg %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_selected_load_partial_noalias(
; AMDGCN-SAME: i1 inreg [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) nofree readonly captures(none) [[PTR_FALSE:%.*]]) {
; AMDGCN-NEXT:    [[PTR:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PTR_TRUE]], ptr addrspace(1) [[PTR_FALSE]]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
  %ptr = select i1 %cond, ptr addrspace(1) %ptr.true, ptr addrspace(1) %ptr.false
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_branch_load(i1 %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) noalias %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_branch_load(
; AMDGCN-SAME: i1 noundef [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_FALSE:%.*]]) {
; AMDGCN-NEXT:  [[ENTRY:.*:]]
; AMDGCN-NEXT:    br i1 [[COND]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; AMDGCN:       [[TRUE]]:
; AMDGCN-NEXT:    call void @clobber(i32 noundef 1)
; AMDGCN-NEXT:    br label %[[FINISH:.*]]
; AMDGCN:       [[FALSE]]:
; AMDGCN-NEXT:    br label %[[FINISH]]
; AMDGCN:       [[FINISH]]:
; AMDGCN-NEXT:    [[PTR:%.*]] = phi ptr addrspace(1) [ [[PTR_TRUE]], %[[TRUE]] ], [ [[PTR_FALSE]], %[[FALSE]] ]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4, !invariant.load [[META0]]
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
entry:
  br i1 %cond, label %true, label %false
true:
  call void @clobber(i32 1)
  br label %finish
false:
  br label %finish
finish:
  %ptr = phi ptr addrspace(1) [ %ptr.true, %true ], [ %ptr.false, %false ]
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}

define amdgpu_kernel void @test_branch_load_partial_noalias(i1 %cond, ptr addrspace(1) noalias %ptr.true, ptr addrspace(1) %ptr.false) {
; AMDGCN-LABEL: define amdgpu_kernel void @test_branch_load_partial_noalias(
; AMDGCN-SAME: i1 noundef [[COND:%.*]], ptr addrspace(1) noalias nofree readonly captures(none) [[PTR_TRUE:%.*]], ptr addrspace(1) nofree readonly captures(none) [[PTR_FALSE:%.*]]) {
; AMDGCN-NEXT:  [[ENTRY:.*:]]
; AMDGCN-NEXT:    br i1 [[COND]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; AMDGCN:       [[TRUE]]:
; AMDGCN-NEXT:    call void @clobber(i32 noundef 1)
; AMDGCN-NEXT:    br label %[[FINISH:.*]]
; AMDGCN:       [[FALSE]]:
; AMDGCN-NEXT:    br label %[[FINISH]]
; AMDGCN:       [[FINISH]]:
; AMDGCN-NEXT:    [[PTR:%.*]] = phi ptr addrspace(1) [ [[PTR_TRUE]], %[[TRUE]] ], [ [[PTR_FALSE]], %[[FALSE]] ]
; AMDGCN-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR]], align 4
; AMDGCN-NEXT:    call void @clobber(i32 [[VAL]])
; AMDGCN-NEXT:    ret void
;
entry:
  br i1 %cond, label %true, label %false
true:
  call void @clobber(i32 1)
  br label %finish
false:
  br label %finish
finish:
  %ptr = phi ptr addrspace(1) [ %ptr.true, %true ], [ %ptr.false, %false ]
  %val = load i32, ptr addrspace(1) %ptr, align 4
  call void @clobber(i32 %val)
  ret void
}
;.
; AMDGCN: [[META0]] = !{}
;.
