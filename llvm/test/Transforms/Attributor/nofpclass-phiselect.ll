; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal -S < %s | FileCheck %s

define float @phi_select(i1 %c, float nofpclass(inf) %base, float nofpclass(inf) %arg) {
; CHECK-LABEL: define nofpclass(inf) float @phi_select
; CHECK-SAME: (i1 [[C:%.*]], float nofpclass(inf) [[BASE:%.*]], float nofpclass(inf) [[ARG:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi float [ [[BASE]], [[ENTRY:%.*]] ], [ [[SELECT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SELECT]] = select i1 [[C]], float [[PHI]], float [[ARG]]
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret float [[SELECT]]
;
entry:
  br label %loop

loop:
  %phi = phi float [ %base, %entry ], [ %select, %loop ]
  %select = select i1 %c, float %phi, float %arg
  br i1 %c, label %loop, label %exit

exit:
  ret float %select
}

define float @phi_select_c(i1 %c, float nofpclass(inf) %base, float nofpclass(inf) %arg) {
; CHECK-LABEL: define nofpclass(inf) float @phi_select_c
; CHECK-SAME: (i1 [[C:%.*]], float nofpclass(inf) [[BASE:%.*]], float nofpclass(inf) [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi float [ [[BASE]], [[ENTRY:%.*]] ], [ [[SELECT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SELECT]] = select i1 [[C]], float [[ARG]], float [[PHI]]
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret float [[SELECT]]
;
entry:
  br label %loop

loop:
  %phi = phi float [ %base, %entry ], [ %select, %loop ]
  %select = select i1 %c, float %arg, float %phi
  br i1 %c, label %loop, label %exit

exit:
  ret float %select
}

define float @phi_select_onlybase(i1 %c, float nofpclass(inf) %base, float %arg) {
; CHECK-LABEL: define float @phi_select_onlybase
; CHECK-SAME: (i1 [[C:%.*]], float nofpclass(inf) [[BASE:%.*]], float [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi float [ [[BASE]], [[ENTRY:%.*]] ], [ [[SELECT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SELECT]] = select i1 [[C]], float [[PHI]], float [[ARG]]
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret float [[SELECT]]
;
entry:
  br label %loop

loop:
  %phi = phi float [ %base, %entry ], [ %select, %loop ]
  %select = select i1 %c, float %phi, float %arg
  br i1 %c, label %loop, label %exit

exit:
  ret float %select
}

define float @phi_select_onlyarg(i1 %c, float %base, float nofpclass(inf) %arg) {
; CHECK-LABEL: define float @phi_select_onlyarg
; CHECK-SAME: (i1 [[C:%.*]], float [[BASE:%.*]], float nofpclass(inf) [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi float [ [[BASE]], [[ENTRY:%.*]] ], [ [[SELECT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[SELECT]] = select i1 [[C]], float [[PHI]], float [[ARG]]
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret float [[SELECT]]
;
entry:
  br label %loop

loop:
  %phi = phi float [ %base, %entry ], [ %select, %loop ]
  %select = select i1 %c, float %phi, float %arg
  br i1 %c, label %loop, label %exit

exit:
  ret float %select
}

define float @phi_phi(i1 %c, float nofpclass(inf) %base, float nofpclass(inf) %arg) {
; CHECK-LABEL: define nofpclass(inf) float @phi_phi
; CHECK-SAME: (i1 [[C:%.*]], float nofpclass(inf) [[BASE:%.*]], float nofpclass(inf) [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi float [ [[BASE]], [[ENTRY:%.*]] ], [ [[PHI2:%.*]], [[EXIT1:%.*]] ]
; CHECK-NEXT:    br label [[INNER:%.*]]
; CHECK:       inner:
; CHECK-NEXT:    [[PHI2]] = phi float [ [[PHI]], [[LOOP]] ], [ [[ARG]], [[INNER]] ]
; CHECK-NEXT:    br i1 [[C]], label [[INNER]], label [[EXIT1]]
; CHECK:       exit1:
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret float [[PHI2]]
;
entry:
  br label %loop

loop:
  %phi = phi float [ %base, %entry ], [ %phi2, %exit1 ]
  br label %inner

inner:
  %phi2 = phi float [ %phi, %loop ], [ %arg, %inner ]
  br i1 %c, label %inner, label %exit1

exit1:
  br i1 %c, label %loop, label %exit

exit:
  ret float %phi2
}

define float @phi_phi_onlybase(i1 %c, float nofpclass(inf) %base, float %arg) {
; CHECK-LABEL: define float @phi_phi_onlybase
; CHECK-SAME: (i1 [[C:%.*]], float nofpclass(inf) [[BASE:%.*]], float [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi float [ [[BASE]], [[ENTRY:%.*]] ], [ [[PHI2:%.*]], [[EXIT1:%.*]] ]
; CHECK-NEXT:    br label [[INNER:%.*]]
; CHECK:       inner:
; CHECK-NEXT:    [[PHI2]] = phi float [ [[PHI]], [[LOOP]] ], [ [[ARG]], [[INNER]] ]
; CHECK-NEXT:    br i1 [[C]], label [[INNER]], label [[EXIT1]]
; CHECK:       exit1:
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret float [[PHI2]]
;
entry:
  br label %loop

loop:
  %phi = phi float [ %base, %entry ], [ %phi2, %exit1 ]
  br label %inner

inner:
  %phi2 = phi float [ %phi, %loop ], [ %arg, %inner ]
  br i1 %c, label %inner, label %exit1

exit1:
  br i1 %c, label %loop, label %exit

exit:
  ret float %phi2
}

define float @phi_phi_onlyarg(i1 %c, float %base, float nofpclass(inf) %arg) {
; CHECK-LABEL: define float @phi_phi_onlyarg
; CHECK-SAME: (i1 [[C:%.*]], float [[BASE:%.*]], float nofpclass(inf) [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi float [ [[BASE]], [[ENTRY:%.*]] ], [ [[PHI2:%.*]], [[EXIT1:%.*]] ]
; CHECK-NEXT:    br label [[INNER:%.*]]
; CHECK:       inner:
; CHECK-NEXT:    [[PHI2]] = phi float [ [[PHI]], [[LOOP]] ], [ [[ARG]], [[INNER]] ]
; CHECK-NEXT:    br i1 [[C]], label [[INNER]], label [[EXIT1]]
; CHECK:       exit1:
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret float [[PHI2]]
;
entry:
  br label %loop

loop:
  %phi = phi float [ %base, %entry ], [ %phi2, %exit1 ]
  br label %inner

inner:
  %phi2 = phi float [ %phi, %loop ], [ %arg, %inner ]
  br i1 %c, label %inner, label %exit1

exit1:
  br i1 %c, label %loop, label %exit

exit:
  ret float %phi2
}
