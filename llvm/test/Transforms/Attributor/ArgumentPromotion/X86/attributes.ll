; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,CGSCC
; Test that we only promote arguments when the caller/callee have compatible
; function attrubtes.

target triple = "x86_64-unknown-linux-gnu"

define internal fastcc void @no_promote_avx2(ptr %arg, ptr readonly %arg1) #0 {
; CHECK: Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
; CHECK-LABEL: define {{[^@]+}}@no_promote_avx2
; CHECK-SAME: (ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[ARG:%.*]], ptr noalias nofree noundef nonnull readonly align 32 captures(none) dereferenceable(32) [[ARG1:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = load <4 x i64>, ptr [[ARG1]], align 32
; CHECK-NEXT:    store <4 x i64> [[TMP]], ptr [[ARG]], align 32
; CHECK-NEXT:    ret void
;
bb:
  %tmp = load <4 x i64>, ptr %arg1
  store <4 x i64> %tmp, ptr %arg
  ret void
}

define void @no_promote(ptr %arg) #1 {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
; TUNIT-LABEL: define {{[^@]+}}@no_promote
; TUNIT-SAME: (ptr nofree writeonly captures(none) [[ARG:%.*]]) #[[ATTR1:[0-9]+]] {
; TUNIT-NEXT:  bb:
; TUNIT-NEXT:    [[TMP:%.*]] = alloca <4 x i64>, align 32
; TUNIT-NEXT:    [[TMP2:%.*]] = alloca <4 x i64>, align 32
; TUNIT-NEXT:    call void @llvm.memset.p0.i64(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP]], i8 noundef 0, i64 noundef 32, i1 noundef false) #[[ATTR3:[0-9]+]]
; TUNIT-NEXT:    call fastcc void @no_promote_avx2(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP2]], ptr noalias nofree noundef nonnull readonly align 32 captures(none) dereferenceable(32) [[TMP]]) #[[ATTR4:[0-9]+]]
; TUNIT-NEXT:    [[TMP4:%.*]] = load <4 x i64>, ptr [[TMP2]], align 32
; TUNIT-NEXT:    store <4 x i64> [[TMP4]], ptr [[ARG]], align 2
; TUNIT-NEXT:    ret void
;
; CGSCC: Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) uwtable
; CGSCC-LABEL: define {{[^@]+}}@no_promote
; CGSCC-SAME: (ptr nofree noundef nonnull writeonly align 2 captures(none) dereferenceable(32) [[ARG:%.*]]) #[[ATTR1:[0-9]+]] {
; CGSCC-NEXT:  bb:
; CGSCC-NEXT:    [[TMP:%.*]] = alloca <4 x i64>, align 32
; CGSCC-NEXT:    [[TMP2:%.*]] = alloca <4 x i64>, align 32
; CGSCC-NEXT:    call void @llvm.memset.p0.i64(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP]], i8 noundef 0, i64 noundef 32, i1 noundef false) #[[ATTR3:[0-9]+]]
; CGSCC-NEXT:    call fastcc void @no_promote_avx2(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP2]], ptr noalias nofree noundef nonnull readonly align 32 captures(none) dereferenceable(32) [[TMP]]) #[[ATTR4:[0-9]+]]
; CGSCC-NEXT:    [[TMP4:%.*]] = load <4 x i64>, ptr [[TMP2]], align 32
; CGSCC-NEXT:    store <4 x i64> [[TMP4]], ptr [[ARG]], align 2
; CGSCC-NEXT:    ret void
;
bb:
  %tmp = alloca <4 x i64>, align 32
  %tmp2 = alloca <4 x i64>, align 32
  call void @llvm.memset.p0.i64(ptr align 32 %tmp, i8 0, i64 32, i1 false)
  call fastcc void @no_promote_avx2(ptr %tmp2, ptr %tmp)
  %tmp4 = load <4 x i64>, ptr %tmp2, align 32
  store <4 x i64> %tmp4, ptr %arg, align 2
  ret void
}

define internal fastcc void @promote_avx2(ptr %arg, ptr readonly %arg1) #0 {
; CHECK: Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
; CHECK-LABEL: define {{[^@]+}}@promote_avx2
; CHECK-SAME: (ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[ARG:%.*]], <4 x i64> [[TMP0:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[ARG1_PRIV:%.*]] = alloca <4 x i64>, align 32
; CHECK-NEXT:    store <4 x i64> [[TMP0]], ptr [[ARG1_PRIV]], align 32
; CHECK-NEXT:    [[TMP:%.*]] = load <4 x i64>, ptr [[ARG1_PRIV]], align 32
; CHECK-NEXT:    store <4 x i64> [[TMP]], ptr [[ARG]], align 32
; CHECK-NEXT:    ret void
;
bb:
  %tmp = load <4 x i64>, ptr %arg1
  store <4 x i64> %tmp, ptr %arg
  ret void
}

define void @promote(ptr %arg) #0 {
; TUNIT: Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
; TUNIT-LABEL: define {{[^@]+}}@promote
; TUNIT-SAME: (ptr nofree writeonly captures(none) [[ARG:%.*]]) #[[ATTR0]] {
; TUNIT-NEXT:  bb:
; TUNIT-NEXT:    [[TMP:%.*]] = alloca <4 x i64>, align 32
; TUNIT-NEXT:    [[TMP2:%.*]] = alloca <4 x i64>, align 32
; TUNIT-NEXT:    call void @llvm.memset.p0.i64(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP]], i8 noundef 0, i64 noundef 32, i1 noundef false) #[[ATTR3]]
; TUNIT-NEXT:    [[TMP0:%.*]] = load <4 x i64>, ptr [[TMP]], align 32
; TUNIT-NEXT:    call fastcc void @promote_avx2(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP2]], <4 x i64> [[TMP0]]) #[[ATTR4]]
; TUNIT-NEXT:    [[TMP4:%.*]] = load <4 x i64>, ptr [[TMP2]], align 32
; TUNIT-NEXT:    store <4 x i64> [[TMP4]], ptr [[ARG]], align 2
; TUNIT-NEXT:    ret void
;
; CGSCC: Function Attrs: inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
; CGSCC-LABEL: define {{[^@]+}}@promote
; CGSCC-SAME: (ptr nofree noundef nonnull writeonly align 2 captures(none) dereferenceable(32) [[ARG:%.*]]) #[[ATTR0]] {
; CGSCC-NEXT:  bb:
; CGSCC-NEXT:    [[TMP:%.*]] = alloca <4 x i64>, align 32
; CGSCC-NEXT:    [[TMP2:%.*]] = alloca <4 x i64>, align 32
; CGSCC-NEXT:    call void @llvm.memset.p0.i64(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP]], i8 noundef 0, i64 noundef 32, i1 noundef false) #[[ATTR3]]
; CGSCC-NEXT:    [[TMP0:%.*]] = load <4 x i64>, ptr [[TMP]], align 32
; CGSCC-NEXT:    call fastcc void @promote_avx2(ptr noalias nofree noundef nonnull writeonly align 32 captures(none) dereferenceable(32) [[TMP2]], <4 x i64> [[TMP0]]) #[[ATTR4]]
; CGSCC-NEXT:    [[TMP4:%.*]] = load <4 x i64>, ptr [[TMP2]], align 32
; CGSCC-NEXT:    store <4 x i64> [[TMP4]], ptr [[ARG]], align 2
; CGSCC-NEXT:    ret void
;
bb:
  %tmp = alloca <4 x i64>, align 32
  %tmp2 = alloca <4 x i64>, align 32
  call void @llvm.memset.p0.i64(ptr align 32 %tmp, i8 0, i64 32, i1 false)
  call fastcc void @promote_avx2(ptr %tmp2, ptr %tmp)
  %tmp4 = load <4 x i64>, ptr %tmp2, align 32
  store <4 x i64> %tmp4, ptr %arg, align 2
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1) #2

attributes #0 = { inlinehint norecurse nounwind uwtable "target-features"="+avx2" }
attributes #1 = { nounwind uwtable }
attributes #2 = { argmemonly nounwind }
;.
; TUNIT: attributes #[[ATTR0]] = { inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable "target-features"="+avx2" }
; TUNIT: attributes #[[ATTR1]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable }
; TUNIT: attributes #[[ATTR2:[0-9]+]] = { nocallback nofree nounwind willreturn memory(argmem: write) }
; TUNIT: attributes #[[ATTR3]] = { nofree willreturn memory(write) }
; TUNIT: attributes #[[ATTR4]] = { nofree nosync nounwind willreturn }
;.
; CGSCC: attributes #[[ATTR0]] = { inlinehint mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable "target-features"="+avx2" }
; CGSCC: attributes #[[ATTR1]] = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) uwtable }
; CGSCC: attributes #[[ATTR2:[0-9]+]] = { nocallback nofree nounwind willreturn memory(argmem: write) }
; CGSCC: attributes #[[ATTR3]] = { nofree willreturn memory(write) }
; CGSCC: attributes #[[ATTR4]] = { nofree nounwind willreturn }
;.
