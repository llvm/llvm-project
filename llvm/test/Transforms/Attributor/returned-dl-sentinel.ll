; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S < %s | FileCheck %s --check-prefixes=CHECK-DL,TUNIT-DL
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,CGSCC
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs  -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S < %s | FileCheck %s --check-prefixes=CHECK-DL,CGSCC-DL
;
; Test cases specifically designed for the "returned" argument attribute.
; We use FIXME's to indicate problems and missing attributes.
;

define ptr @ptr_sink_r0(ptr %r) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@ptr_sink_r0
; CHECK-SAME: (ptr nofree readnone returned "no-capture-maybe-returned" [[R:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret ptr [[R]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@ptr_sink_r0
; CHECK-DL-SAME: (ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[R:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret ptr [[R]]
;
entry:
  ret ptr %r
}

define ptr @ptr_scc_r1(ptr %a, ptr %r, ptr %b) #0 {
; TUNIT: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; TUNIT-LABEL: define {{[^@]+}}@ptr_scc_r1
; TUNIT-SAME: (ptr nocapture nofree readnone [[A:%.*]], ptr nofree readnone returned "no-capture-maybe-returned" [[R:%.*]], ptr nocapture nofree readnone [[B:%.*]]) #[[ATTR1:[0-9]+]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[R]], ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5:[0-9]+]]
; TUNIT-NEXT:    ret ptr [[R]]
;
; TUNIT-DL: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; TUNIT-DL-LABEL: define {{[^@]+}}@ptr_scc_r1
; TUNIT-DL-SAME: (ptr nocapture nofree nonnull readnone [[A:%.*]], ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[R:%.*]], ptr nocapture nofree nonnull readnone [[B:%.*]]) #[[ATTR1:[0-9]+]] {
; TUNIT-DL-NEXT:  entry:
; TUNIT-DL-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5:[0-9]+]]
; TUNIT-DL-NEXT:    ret ptr [[R]]
;
; CGSCC: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CGSCC-LABEL: define {{[^@]+}}@ptr_scc_r1
; CGSCC-SAME: (ptr nocapture nofree readnone [[A:%.*]], ptr nofree readnone returned [[R:%.*]], ptr nocapture nofree readnone [[B:%.*]]) #[[ATTR1:[0-9]+]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[R]], ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree readnone [[R]]) #[[ATTR5:[0-9]+]]
; CGSCC-NEXT:    ret ptr [[R]]
;
; CGSCC-DL: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CGSCC-DL-LABEL: define {{[^@]+}}@ptr_scc_r1
; CGSCC-DL-SAME: (ptr nocapture nofree nonnull readnone [[A:%.*]], ptr nofree nonnull readnone returned [[R:%.*]], ptr nocapture nofree nonnull readnone [[B:%.*]]) #[[ATTR1:[0-9]+]] {
; CGSCC-DL-NEXT:  entry:
; CGSCC-DL-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone [[R]]) #[[ATTR5:[0-9]+]]
; CGSCC-DL-NEXT:    ret ptr [[R]]
;
entry:
  %call = call ptr @ptr_sink_r0(ptr %r)
  %call1 = call ptr @ptr_scc_r2(ptr %r, ptr %a, ptr %call)
  ret ptr %call1
}

define ptr @ptr_scc_r2(ptr %a, ptr %b, ptr %r) #0 {
; TUNIT: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; TUNIT-LABEL: define {{[^@]+}}@ptr_scc_r2
; TUNIT-SAME: (ptr nocapture nofree readnone [[A:%.*]], ptr nocapture nofree readnone [[B:%.*]], ptr nofree readnone returned "no-capture-maybe-returned" [[R:%.*]]) #[[ATTR1]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    [[CMP:%.*]] = icmp ugt ptr [[A]], [[B]]
; TUNIT-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; TUNIT:       if.then:
; TUNIT-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[B]], ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-NEXT:    br label [[RETURN:%.*]]
; TUNIT:       if.end:
; TUNIT-NEXT:    [[CMP2:%.*]] = icmp ult ptr [[A]], [[B]]
; TUNIT-NEXT:    br i1 [[CMP2]], label [[IF_THEN3:%.*]], label [[IF_END12:%.*]]
; TUNIT:       if.then3:
; TUNIT-NEXT:    [[CALL5:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[B]], ptr noalias nocapture nofree readnone undef) #[[ATTR5]]
; TUNIT-NEXT:    [[CALL6:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[R]], ptr noalias nocapture nofree readnone [[R]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-NEXT:    [[CALL7:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]], ptr noalias nocapture nofree readnone undef) #[[ATTR5]]
; TUNIT-NEXT:    [[CALL8:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[A]], ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-NEXT:    [[CALL9:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[B]], ptr noalias nocapture nofree readnone [[R]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-NEXT:    [[CALL11:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree readnone [[B]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]], ptr noalias nocapture nofree readnone undef) #[[ATTR5]]
; TUNIT-NEXT:    br label [[RETURN]]
; TUNIT:       if.end12:
; TUNIT-NEXT:    [[CMP13:%.*]] = icmp eq ptr [[A]], [[B]]
; TUNIT-NEXT:    br i1 [[CMP13]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; TUNIT:       cond.true:
; TUNIT-NEXT:    br label [[COND_END:%.*]]
; TUNIT:       cond.false:
; TUNIT-NEXT:    [[CALL14:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[A]], ptr noalias nocapture nofree readnone [[B]], ptr noalias nofree readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-NEXT:    br label [[COND_END]]
; TUNIT:       cond.end:
; TUNIT-NEXT:    [[COND:%.*]] = phi ptr [ [[R]], [[COND_TRUE]] ], [ [[R]], [[COND_FALSE]] ]
; TUNIT-NEXT:    br label [[RETURN]]
; TUNIT:       return:
; TUNIT-NEXT:    [[RETVAL_0:%.*]] = phi ptr [ [[R]], [[IF_THEN]] ], [ [[R]], [[IF_THEN3]] ], [ [[R]], [[COND_END]] ]
; TUNIT-NEXT:    ret ptr [[R]]
;
; TUNIT-DL: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; TUNIT-DL-LABEL: define {{[^@]+}}@ptr_scc_r2
; TUNIT-DL-SAME: (ptr nocapture nofree nonnull readnone [[A:%.*]], ptr nocapture nofree nonnull readnone [[B:%.*]], ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[R:%.*]]) #[[ATTR1]] {
; TUNIT-DL-NEXT:  entry:
; TUNIT-DL-NEXT:    [[CMP:%.*]] = icmp ugt ptr [[A]], [[B]]
; TUNIT-DL-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; TUNIT-DL:       if.then:
; TUNIT-DL-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-DL-NEXT:    br label [[RETURN:%.*]]
; TUNIT-DL:       if.end:
; TUNIT-DL-NEXT:    [[CMP2:%.*]] = icmp ult ptr [[A]], [[B]]
; TUNIT-DL-NEXT:    br i1 [[CMP2]], label [[IF_THEN3:%.*]], label [[IF_END12:%.*]]
; TUNIT-DL:       if.then3:
; TUNIT-DL-NEXT:    [[CALL5:%.*]] = call nonnull ptr @ptr_scc_r1(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[B]], ptr noalias nocapture nofree nonnull readnone undef) #[[ATTR5]]
; TUNIT-DL-NEXT:    [[CALL6:%.*]] = call nonnull ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-DL-NEXT:    [[CALL7:%.*]] = call nonnull ptr @ptr_scc_r1(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]], ptr noalias nocapture nofree nonnull readnone undef) #[[ATTR5]]
; TUNIT-DL-NEXT:    [[CALL8:%.*]] = call nonnull ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-DL-NEXT:    [[CALL9:%.*]] = call nonnull ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-DL-NEXT:    [[CALL11:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]], ptr noalias nocapture nofree nonnull readnone undef) #[[ATTR5]]
; TUNIT-DL-NEXT:    br label [[RETURN]]
; TUNIT-DL:       if.end12:
; TUNIT-DL-NEXT:    [[CMP13:%.*]] = icmp eq ptr [[A]], [[B]]
; TUNIT-DL-NEXT:    br i1 [[CMP13]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; TUNIT-DL:       cond.true:
; TUNIT-DL-NEXT:    br label [[COND_END:%.*]]
; TUNIT-DL:       cond.false:
; TUNIT-DL-NEXT:    [[CALL14:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree nonnull readnone "no-capture-maybe-returned" [[R]]) #[[ATTR5]]
; TUNIT-DL-NEXT:    br label [[COND_END]]
; TUNIT-DL:       cond.end:
; TUNIT-DL-NEXT:    [[COND:%.*]] = phi ptr [ [[R]], [[COND_TRUE]] ], [ [[R]], [[COND_FALSE]] ]
; TUNIT-DL-NEXT:    br label [[RETURN]]
; TUNIT-DL:       return:
; TUNIT-DL-NEXT:    [[RETVAL_0:%.*]] = phi ptr [ [[R]], [[IF_THEN]] ], [ [[R]], [[IF_THEN3]] ], [ [[R]], [[COND_END]] ]
; TUNIT-DL-NEXT:    ret ptr [[R]]
;
; CGSCC: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CGSCC-LABEL: define {{[^@]+}}@ptr_scc_r2
; CGSCC-SAME: (ptr nocapture nofree readnone [[A:%.*]], ptr nocapture nofree readnone [[B:%.*]], ptr nofree readnone returned [[R:%.*]]) #[[ATTR1]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    [[CMP:%.*]] = icmp ugt ptr [[A]], [[B]]
; CGSCC-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CGSCC:       if.then:
; CGSCC-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[B]], ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree readnone [[R]]) #[[ATTR5]]
; CGSCC-NEXT:    br label [[RETURN:%.*]]
; CGSCC:       if.end:
; CGSCC-NEXT:    [[CMP2:%.*]] = icmp ult ptr [[A]], [[B]]
; CGSCC-NEXT:    br i1 [[CMP2]], label [[IF_THEN3:%.*]], label [[IF_END12:%.*]]
; CGSCC:       if.then3:
; CGSCC-NEXT:    [[CALL5:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree nonnull readnone [[B]], ptr noalias nocapture nofree readnone undef) #[[ATTR5]]
; CGSCC-NEXT:    [[CALL6:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[R]], ptr noalias nocapture nofree readnone [[R]], ptr noalias nofree readnone [[R]]) #[[ATTR5]]
; CGSCC-NEXT:    [[CALL7:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree readnone [[R]], ptr noalias nocapture nofree readnone undef) #[[ATTR5]]
; CGSCC-NEXT:    [[CALL8:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[A]], ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree readnone [[R]]) #[[ATTR5]]
; CGSCC-NEXT:    [[CALL9:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[B]], ptr noalias nocapture nofree readnone [[R]], ptr noalias nofree readnone [[R]]) #[[ATTR5]]
; CGSCC-NEXT:    [[CALL11:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree readnone [[R]], ptr noalias nocapture nofree readnone undef) #[[ATTR5]]
; CGSCC-NEXT:    br label [[RETURN]]
; CGSCC:       if.end12:
; CGSCC-NEXT:    [[CMP13:%.*]] = icmp eq ptr [[A]], [[B]]
; CGSCC-NEXT:    br i1 [[CMP13]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CGSCC:       cond.true:
; CGSCC-NEXT:    br label [[COND_END:%.*]]
; CGSCC:       cond.false:
; CGSCC-NEXT:    [[CALL14:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree readnone [[A]], ptr noalias nocapture nofree readnone [[B]], ptr noalias nofree readnone [[R]]) #[[ATTR5]]
; CGSCC-NEXT:    br label [[COND_END]]
; CGSCC:       cond.end:
; CGSCC-NEXT:    [[COND:%.*]] = phi ptr [ [[R]], [[COND_TRUE]] ], [ [[R]], [[COND_FALSE]] ]
; CGSCC-NEXT:    br label [[RETURN]]
; CGSCC:       return:
; CGSCC-NEXT:    [[RETVAL_0:%.*]] = phi ptr [ [[R]], [[IF_THEN]] ], [ [[R]], [[IF_THEN3]] ], [ [[R]], [[COND_END]] ]
; CGSCC-NEXT:    ret ptr [[R]]
;
; CGSCC-DL: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CGSCC-DL-LABEL: define {{[^@]+}}@ptr_scc_r2
; CGSCC-DL-SAME: (ptr nocapture nofree nonnull readnone [[A:%.*]], ptr nocapture nofree nonnull readnone [[B:%.*]], ptr nofree nonnull readnone returned [[R:%.*]]) #[[ATTR1]] {
; CGSCC-DL-NEXT:  entry:
; CGSCC-DL-NEXT:    [[CMP:%.*]] = icmp ugt ptr [[A]], [[B]]
; CGSCC-DL-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CGSCC-DL:       if.then:
; CGSCC-DL-NEXT:    [[CALL1:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone [[R]]) #[[ATTR5]]
; CGSCC-DL-NEXT:    br label [[RETURN:%.*]]
; CGSCC-DL:       if.end:
; CGSCC-DL-NEXT:    [[CMP2:%.*]] = icmp ult ptr [[A]], [[B]]
; CGSCC-DL-NEXT:    br i1 [[CMP2]], label [[IF_THEN3:%.*]], label [[IF_END12:%.*]]
; CGSCC-DL:       if.then3:
; CGSCC-DL-NEXT:    [[CALL5:%.*]] = call nonnull ptr @ptr_scc_r1(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone [[B]], ptr noalias nocapture nofree nonnull readnone undef) #[[ATTR5]]
; CGSCC-DL-NEXT:    [[CALL6:%.*]] = call nonnull ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nofree nonnull readnone [[R]]) #[[ATTR5]]
; CGSCC-DL-NEXT:    [[CALL7:%.*]] = call nonnull ptr @ptr_scc_r1(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nofree nonnull readnone [[R]], ptr noalias nocapture nofree nonnull readnone undef) #[[ATTR5]]
; CGSCC-DL-NEXT:    [[CALL8:%.*]] = call nonnull ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree nonnull readnone [[R]]) #[[ATTR5]]
; CGSCC-DL-NEXT:    [[CALL9:%.*]] = call nonnull ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nocapture nofree nonnull readnone [[R]], ptr noalias nofree nonnull readnone [[R]]) #[[ATTR5]]
; CGSCC-DL-NEXT:    [[CALL11:%.*]] = call ptr @ptr_scc_r1(ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree nonnull readnone [[R]], ptr noalias nocapture nofree nonnull readnone undef) #[[ATTR5]]
; CGSCC-DL-NEXT:    br label [[RETURN]]
; CGSCC-DL:       if.end12:
; CGSCC-DL-NEXT:    [[CMP13:%.*]] = icmp eq ptr [[A]], [[B]]
; CGSCC-DL-NEXT:    br i1 [[CMP13]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
; CGSCC-DL:       cond.true:
; CGSCC-DL-NEXT:    br label [[COND_END:%.*]]
; CGSCC-DL:       cond.false:
; CGSCC-DL-NEXT:    [[CALL14:%.*]] = call ptr @ptr_scc_r2(ptr noalias nocapture nofree nonnull readnone [[A]], ptr noalias nocapture nofree nonnull readnone [[B]], ptr noalias nofree nonnull readnone [[R]]) #[[ATTR5]]
; CGSCC-DL-NEXT:    br label [[COND_END]]
; CGSCC-DL:       cond.end:
; CGSCC-DL-NEXT:    [[COND:%.*]] = phi ptr [ [[R]], [[COND_TRUE]] ], [ [[R]], [[COND_FALSE]] ]
; CGSCC-DL-NEXT:    br label [[RETURN]]
; CGSCC-DL:       return:
; CGSCC-DL-NEXT:    [[RETVAL_0:%.*]] = phi ptr [ [[R]], [[IF_THEN]] ], [ [[R]], [[IF_THEN3]] ], [ [[R]], [[COND_END]] ]
; CGSCC-DL-NEXT:    ret ptr [[R]]
;
entry:
  %cmp = icmp ugt ptr %a, %b
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @ptr_sink_r0(ptr %r)
  %call1 = call ptr @ptr_scc_r2(ptr %b, ptr %a, ptr %call)
  br label %return

if.end:                                           ; preds = %entry
  %cmp2 = icmp ult ptr %a, %b
  br i1 %cmp2, label %if.then3, label %if.end12

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @ptr_sink_r0(ptr %b)
  %call5 = call ptr @ptr_scc_r1(ptr %a, ptr %b, ptr %r)
  %call6 = call ptr @ptr_scc_r2(ptr %r, ptr %r, ptr %r)
  %call7 = call ptr @ptr_scc_r1(ptr %a, ptr %call6, ptr %r)
  %call8 = call ptr @ptr_scc_r2(ptr %a, ptr %b, ptr %r)
  %call9 = call ptr @ptr_scc_r2(ptr %call5, ptr %call7, ptr %call8)
  %call10 = call ptr @ptr_scc_r1(ptr %a, ptr %b, ptr %r)
  %call11 = call ptr @ptr_scc_r1(ptr %call4, ptr %call9, ptr %call10)
  br label %return

if.end12:                                         ; preds = %if.end
  %cmp13 = icmp eq ptr %a, %b
  br i1 %cmp13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  %call14 = call ptr @ptr_scc_r2(ptr %a, ptr %b, ptr %r)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %r, %cond.true ], [ %call14, %cond.false ]
  br label %return

return:                                           ; preds = %cond.end, %if.then3, %if.then
  %retval.0 = phi ptr [ %call1, %if.then ], [ %call11, %if.then3 ], [ %cond, %cond.end ]
  ret ptr %retval.0
}


; TEST a no-return singleton SCC
;
; int* rt0(int *a) {
;   return *a ? a : rt0(a);
; }
;
define ptr @rt0(ptr %a) #0 {
; CHECK: Function Attrs: nofree noinline nosync nounwind memory(argmem: read) uwtable
; CHECK-LABEL: define {{[^@]+}}@rt0
; CHECK-SAME: (ptr nofree noundef nonnull readonly returned align 4 dereferenceable(4) "no-capture-maybe-returned" [[A:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @rt0(ptr nofree noundef nonnull readonly align 4 dereferenceable(4) "no-capture-maybe-returned" [[A]]) #[[ATTR6:[0-9]+]]
; CHECK-NEXT:    ret ptr [[A]]
;
; CHECK-DL: Function Attrs: nofree noinline nosync nounwind memory(argmem: read) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@rt0
; CHECK-DL-SAME: (ptr nofree noundef nonnull readonly returned align 4 dereferenceable(4) "no-capture-maybe-returned" [[A:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call ptr @rt0(ptr nofree noundef nonnull readonly align 4 dereferenceable(4) "no-capture-maybe-returned" [[A]]) #[[ATTR6:[0-9]+]]
; CHECK-DL-NEXT:    ret ptr [[A]]
;
entry:
  %v = load i32, ptr %a, align 4
  %tobool = icmp ne i32 %v, 0
  %call = call ptr @rt0(ptr %a)
  %sel = select i1 %tobool, ptr %a, ptr %call
  ret ptr %sel
}

; TEST a no-return singleton SCC
;
; int* rt1(int *a) {
;   return *a ? undef : rt1(a);
; }
;
define ptr @rt1(ptr %a) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@rt1
; CHECK-SAME: (ptr nocapture nofree nonnull readnone align 4 dereferenceable(4) [[A:%.*]]) #[[ATTR3:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret ptr undef
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@rt1
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone align 4 dereferenceable(4) [[A:%.*]]) #[[ATTR3:[0-9]+]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret ptr undef
;
entry:
  %v = load i32, ptr %a, align 4
  %tobool = icmp ne i32 %v, 0
  %call = call ptr @rt1(ptr %a)
  %sel = select i1 %tobool, ptr undef, ptr %call
  ret ptr %sel
}

; TEST another SCC test
;
define ptr @rt2_helper(ptr %a) #0 {
; CHECK: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@rt2_helper
; CHECK-SAME: (ptr nofree readnone returned [[A:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @rt2(ptr noalias nofree readnone [[A]], ptr noalias nofree readnone "no-capture-maybe-returned" [[A]]) #[[ATTR5:[0-9]+]]
; CHECK-NEXT:    ret ptr [[A]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@rt2_helper
; CHECK-DL-SAME: (ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[A:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret ptr [[A]]
;
entry:
  %call = call ptr @rt2(ptr %a, ptr %a)
  ret ptr %call
}

define ptr @rt2(ptr %a, ptr %b) #0 {
; CHECK: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@rt2
; CHECK-SAME: (ptr nofree readnone [[A:%.*]], ptr nofree readnone "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @rt2_helper(ptr noalias nofree readnone [[A]]) #[[ATTR5]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SEL:%.*]] = phi ptr [ [[B]], [[ENTRY:%.*]] ], [ [[A]], [[IF_THEN]] ]
; CHECK-NEXT:    ret ptr [[SEL]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@rt2
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[A:%.*]], ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[IF_END:%.*]]
; CHECK-DL:       if.then:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    ret ptr [[B]]
;
entry:
  %cmp = icmp eq ptr %a, null
  br i1 %cmp, label %if.then, label %if.end

if.then:
  %call = call ptr @rt2_helper(ptr %a)
  br label %if.end

if.end:
  %sel = phi ptr [ %b, %entry], [%call, %if.then]
  ret ptr %sel
}

; TEST another SCC test
;
define ptr @rt3_helper(ptr %a, ptr %b) #0 {
; CHECK: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@rt3_helper
; CHECK-SAME: (ptr nocapture nofree readnone [[A:%.*]], ptr nofree readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @rt3(ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree readnone "no-capture-maybe-returned" [[B]]) #[[ATTR5]]
; CHECK-NEXT:    ret ptr [[B]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@rt3_helper
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[A:%.*]], ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret ptr [[B]]
;
entry:
  %call = call ptr @rt3(ptr %a, ptr %b)
  ret ptr %call
}

define ptr @rt3(ptr %a, ptr %b) #0 {
; CHECK: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@rt3
; CHECK-SAME: (ptr nocapture nofree readnone [[A:%.*]], ptr nofree readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @rt3_helper(ptr noalias nocapture nofree readnone [[A]], ptr noalias nofree readnone "no-capture-maybe-returned" [[B]]) #[[ATTR5]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SEL:%.*]] = phi ptr [ [[B]], [[ENTRY:%.*]] ], [ [[B]], [[IF_THEN]] ]
; CHECK-NEXT:    ret ptr [[B]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@rt3
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[A:%.*]], ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[IF_END:%.*]]
; CHECK-DL:       if.then:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    ret ptr [[B]]
;
entry:
  %cmp = icmp eq ptr %a, null
  br i1 %cmp, label %if.then, label %if.end

if.then:
  %call = call ptr @rt3_helper(ptr %a, ptr %b)
  br label %if.end

if.end:
  %sel = phi ptr [ %b, %entry], [%call, %if.then]
  ret ptr %sel
}

; TEST address taken function with call to an external functions
;
;  void unknown_fn(void *);
;
;  int* calls_unknown_fn(int *r) {
;    unknown_fn(&calls_unknown_fn);
;    return r;
;  }
;
declare void @unknown_fn(ptr) #0

define ptr @calls_unknown_fn(ptr %r) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@calls_unknown_fn
; CHECK-SAME: (ptr nofree readnone returned "no-capture-maybe-returned" [[R:%.*]]) #[[ATTR4:[0-9]+]] {
; CHECK-NEXT:    tail call void @unknown_fn(ptr noundef nonnull @calls_unknown_fn) #[[ATTR7:[0-9]+]]
; CHECK-NEXT:    ret ptr [[R]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@calls_unknown_fn
; CHECK-DL-SAME: (ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[R:%.*]]) #[[ATTR4:[0-9]+]] {
; CHECK-DL-NEXT:    tail call void @unknown_fn(ptr noundef nonnull @calls_unknown_fn) #[[ATTR7:[0-9]+]]
; CHECK-DL-NEXT:    ret ptr [[R]]
;
  tail call void @unknown_fn(ptr nonnull @calls_unknown_fn)
  ret ptr %r
}


; TEST call to a function that might be redifined at link time
;
;  int *maybe_redefined_fn(int *r) {
;    return r;
;  }
;
;  int *calls_maybe_redefined_fn(int *r) {
;    maybe_redefined_fn(r);
;    return r;
;  }
;
; Verify the maybe-redefined function is not annotated:
;
define linkonce_odr ptr @maybe_redefined_fn(ptr %r) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@maybe_redefined_fn
; CHECK-SAME: (ptr [[R:%.*]]) #[[ATTR4]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret ptr [[R]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@maybe_redefined_fn
; CHECK-DL-SAME: (ptr [[R:%.*]]) #[[ATTR4]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret ptr [[R]]
;
entry:
  ret ptr %r
}

define ptr @calls_maybe_redefined_fn(ptr %r) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@calls_maybe_redefined_fn
; CHECK-SAME: (ptr returned [[R:%.*]]) #[[ATTR4]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @maybe_redefined_fn(ptr [[R]]) #[[ATTR7]]
; CHECK-NEXT:    ret ptr [[R]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@calls_maybe_redefined_fn
; CHECK-DL-SAME: (ptr nonnull returned [[R:%.*]]) #[[ATTR4]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call ptr @maybe_redefined_fn(ptr nonnull [[R]]) #[[ATTR7]]
; CHECK-DL-NEXT:    ret ptr [[R]]
;
entry:
  %call = call ptr @maybe_redefined_fn(ptr %r)
  ret ptr %r
}

; TEST return call to a function that might be redifined at link time
;
;  int *maybe_redefined_fn2(int *r) {
;    return r;
;  }
;
;  int *calls_maybe_redefined_fn2(int *r) {
;    return maybe_redefined_fn2(r);
;  }
;
; Verify the maybe-redefined function is not annotated:
;
define linkonce_odr ptr @maybe_redefined_fn2(ptr %r) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@maybe_redefined_fn2
; CHECK-SAME: (ptr [[R:%.*]]) #[[ATTR4]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret ptr [[R]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@maybe_redefined_fn2
; CHECK-DL-SAME: (ptr [[R:%.*]]) #[[ATTR4]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret ptr [[R]]
;
entry:
  ret ptr %r
}

define ptr @calls_maybe_redefined_fn2(ptr %r) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@calls_maybe_redefined_fn2
; CHECK-SAME: (ptr [[R:%.*]]) #[[ATTR4]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @maybe_redefined_fn2(ptr [[R]]) #[[ATTR7]]
; CHECK-NEXT:    ret ptr [[CALL]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@calls_maybe_redefined_fn2
; CHECK-DL-SAME: (ptr nonnull [[R:%.*]]) #[[ATTR4]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call nonnull ptr @maybe_redefined_fn2(ptr nonnull [[R]]) #[[ATTR7]]
; CHECK-DL-NEXT:    ret ptr [[CALL]]
;
entry:
  %call = call ptr @maybe_redefined_fn2(ptr %r)
  ret ptr %call
}


; TEST returned argument goes through select and phi
;
; double select_and_phi(double b) {
;   double x = b;
;   if (b > 0)
;     x = b;
;   return b == 0? b : x;
; }
;
define double @select_and_phi(double %b) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@select_and_phi
; CHECK-SAME: (double returned [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = fcmp ogt double [[B]], 0.000000e+00
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[PHI:%.*]] = phi double [ [[B]], [[IF_THEN]] ], [ [[B]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret double [[B]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@select_and_phi
; CHECK-DL-SAME: (double returned [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[CMP:%.*]] = fcmp ogt double [[B]], 0.000000e+00
; CHECK-DL-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK-DL:       if.then:
; CHECK-DL-NEXT:    br label [[IF_END]]
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    [[PHI:%.*]] = phi double [ [[B]], [[IF_THEN]] ], [ [[B]], [[ENTRY:%.*]] ]
; CHECK-DL-NEXT:    ret double [[B]]
;
entry:
  %cmp = fcmp ogt double %b, 0.000000e+00
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %phi = phi double [ %b, %if.then ], [ %b, %entry ]
  %cmp1 = fcmp oeq double %b, 0.000000e+00
  %sel = select i1 %cmp1, double %b, double %phi
  ret double %sel
}


; TEST returned argument goes through recursion, select, and phi
;
; double recursion_select_and_phi(int a, double b) {
;   double x = b;
;   if (a-- > 0)
;     x = recursion_select_and_phi(a, b);
;   return b == 0? b : x;
; }
;
define double @recursion_select_and_phi(i32 %a, double %b) #0 {
; CHECK: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@recursion_select_and_phi
; CHECK-SAME: (i32 [[A:%.*]], double returned [[B:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DEC:%.*]] = add nsw i32 [[A]], -1
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[A]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CALL:%.*]] = call double @recursion_select_and_phi(i32 [[DEC]], double [[B]]) #[[ATTR5]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[PHI:%.*]] = phi double [ [[B]], [[IF_THEN]] ], [ [[B]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret double [[B]]
;
; CHECK-DL: Function Attrs: nofree noinline nosync nounwind memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@recursion_select_and_phi
; CHECK-DL-SAME: (i32 [[A:%.*]], double returned [[B:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[DEC:%.*]] = add nsw i32 [[A]], -1
; CHECK-DL-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[A]], 0
; CHECK-DL-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK-DL:       if.then:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call double @recursion_select_and_phi(i32 [[DEC]], double [[B]]) #[[ATTR5:[0-9]+]]
; CHECK-DL-NEXT:    br label [[IF_END]]
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    [[PHI:%.*]] = phi double [ [[B]], [[IF_THEN]] ], [ [[B]], [[ENTRY:%.*]] ]
; CHECK-DL-NEXT:    ret double [[B]]
;
entry:
  %dec = add nsw i32 %a, -1
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call double @recursion_select_and_phi(i32 %dec, double %b)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %phi = phi double [ %call, %if.then ], [ %b, %entry ]
  %cmp1 = fcmp oeq double %b, 0.000000e+00
  %sel = select i1 %cmp1, double %b, double %phi
  ret double %sel
}


; TEST returned argument goes through bitcasts
;
; double* bitcast(int* b) {
;   return (double*)b;
; }
;
define ptr @bitcast(ptr %b) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@bitcast
; CHECK-SAME: (ptr nofree readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret ptr [[B]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@bitcast
; CHECK-DL-SAME: (ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    ret ptr [[B]]
;
entry:
  ret ptr %b
}


; TEST returned argument goes through select and phi interleaved with bitcasts
;
; double* bitcasts_select_and_phi(int* b) {
;   double* x = b;
;   if (b == 0)
;     x = b;
;   return b != 0 ? b : x;
; }
;
define ptr @bitcasts_select_and_phi(ptr %b) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@bitcasts_select_and_phi
; CHECK-SAME: (ptr nofree readnone returned [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[B]], [[IF_THEN]] ], [ [[B]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret ptr [[B]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@bitcasts_select_and_phi
; CHECK-DL-SAME: (ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[IF_END:%.*]]
; CHECK-DL:       if.then:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    ret ptr [[B]]
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %phi = phi ptr [ %b, %if.then ], [ %b, %entry ]
  %cmp2 = icmp ne ptr %b, null
  %sel = select i1 %cmp2, ptr %phi, ptr %b
  ret ptr %sel
}


; TEST return argument or argument or undef
;
; double* ret_arg_arg_undef(int* b) {
;   if (b == 0)
;     return (double*)b;
;   if (b == 0)
;     return (double*)b;
;   /* return undef */
; }
;
define ptr @ret_arg_arg_undef(ptr %b) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@ret_arg_arg_undef
; CHECK-SAME: (ptr nofree readnone returned [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG0:%.*]], label [[IF_END:%.*]]
; CHECK:       ret_arg0:
; CHECK-NEXT:    ret ptr [[B]]
; CHECK:       if.end:
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG1:%.*]], label [[RET_UNDEF:%.*]]
; CHECK:       ret_arg1:
; CHECK-NEXT:    ret ptr [[B]]
; CHECK:       ret_undef:
; CHECK-NEXT:    ret ptr undef
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@ret_arg_arg_undef
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[IF_END:%.*]]
; CHECK-DL:       ret_arg0:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    br label [[RET_UNDEF:%.*]]
; CHECK-DL:       ret_arg1:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       ret_undef:
; CHECK-DL-NEXT:    ret ptr undef
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %ret_arg0, label %if.end

ret_arg0:
  ret ptr %b

if.end:
  br i1 %cmp, label %ret_arg1, label %ret_undef

ret_arg1:
  ret ptr %b

ret_undef:
  ret ptr undef
}


; TEST return undef or argument or argument
;
; double* ret_undef_arg_arg(int* b) {
;   if (b == 0)
;     return (double*)b;
;   if (b == 0)
;     return (double*)b;
;   /* return undef */
; }
;
define ptr @ret_undef_arg_arg(ptr %b) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@ret_undef_arg_arg
; CHECK-SAME: (ptr nofree readnone returned [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_UNDEF:%.*]], label [[IF_END:%.*]]
; CHECK:       ret_undef:
; CHECK-NEXT:    ret ptr undef
; CHECK:       if.end:
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG0:%.*]], label [[RET_ARG1:%.*]]
; CHECK:       ret_arg0:
; CHECK-NEXT:    ret ptr [[B]]
; CHECK:       ret_arg1:
; CHECK-NEXT:    ret ptr [[B]]
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@ret_undef_arg_arg
; CHECK-DL-SAME: (ptr nofree nonnull readnone returned "no-capture-maybe-returned" [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[IF_END:%.*]]
; CHECK-DL:       ret_undef:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    br label [[RET_ARG1:%.*]]
; CHECK-DL:       ret_arg0:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       ret_arg1:
; CHECK-DL-NEXT:    ret ptr [[B]]
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %ret_undef, label %if.end

ret_undef:
  ret ptr undef

if.end:
  br i1 %cmp, label %ret_arg0, label %ret_arg1

ret_arg0:
  ret ptr %b

ret_arg1:
  ret ptr %b
}


; TEST return undef or argument or undef
;
; double* ret_undef_arg_undef(int* b) {
;   if (b == 0)
;     /* return undef */
;   if (b == 0)
;     return (double*)b;
;   /* return undef */
; }
;
define ptr @ret_undef_arg_undef(ptr %b) #0 {
; CHECK: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-LABEL: define {{[^@]+}}@ret_undef_arg_undef
; CHECK-SAME: (ptr nofree readnone returned [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_UNDEF0:%.*]], label [[IF_END:%.*]]
; CHECK:       ret_undef0:
; CHECK-NEXT:    ret ptr undef
; CHECK:       if.end:
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG:%.*]], label [[RET_UNDEF1:%.*]]
; CHECK:       ret_arg:
; CHECK-NEXT:    ret ptr [[B]]
; CHECK:       ret_undef1:
; CHECK-NEXT:    ret ptr undef
;
; CHECK-DL: Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@ret_undef_arg_undef
; CHECK-DL-SAME: (ptr nocapture nofree nonnull readnone [[B:%.*]]) #[[ATTR0]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[IF_END:%.*]]
; CHECK-DL:       ret_undef0:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       if.end:
; CHECK-DL-NEXT:    br label [[RET_UNDEF1:%.*]]
; CHECK-DL:       ret_arg:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       ret_undef1:
; CHECK-DL-NEXT:    ret ptr undef
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %ret_undef0, label %if.end

ret_undef0:
  ret ptr undef

if.end:
  br i1 %cmp, label %ret_arg, label %ret_undef1

ret_arg:
  ret ptr %b

ret_undef1:
  ret ptr undef
}

; TEST return argument or unknown call result
;
; int* ret_arg_or_unknown(int* b) {
;   if (b == 0)
;     return b;
;   return unknown();
; }
;
; Verify we do not assume b is returned
;
declare ptr @unknown(ptr)


define ptr @ret_arg_or_unknown(ptr %b) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@ret_arg_or_unknown
; CHECK-SAME: (ptr [[B:%.*]]) #[[ATTR4]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG:%.*]], label [[RET_UNKNOWN:%.*]]
; CHECK:       ret_arg:
; CHECK-NEXT:    ret ptr [[B]]
; CHECK:       ret_unknown:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @unknown(ptr nonnull [[B]])
; CHECK-NEXT:    ret ptr [[CALL]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@ret_arg_or_unknown
; CHECK-DL-SAME: (ptr nonnull [[B:%.*]]) #[[ATTR4]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[RET_UNKNOWN:%.*]]
; CHECK-DL:       ret_arg:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       ret_unknown:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call nonnull ptr @unknown(ptr nonnull [[B]])
; CHECK-DL-NEXT:    ret ptr [[CALL]]
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %ret_arg, label %ret_unknown

ret_arg:
  ret ptr %b

ret_unknown:
  %call = call ptr @unknown(ptr %b)
  ret ptr %call
}

define ptr @ret_arg_or_unknown_through_phi(ptr %b) #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@ret_arg_or_unknown_through_phi
; CHECK-SAME: (ptr [[B:%.*]]) #[[ATTR4]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[RET_ARG:%.*]], label [[RET_UNKNOWN:%.*]]
; CHECK:       ret_arg:
; CHECK-NEXT:    br label [[R:%.*]]
; CHECK:       ret_unknown:
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @unknown(ptr nonnull [[B]])
; CHECK-NEXT:    br label [[R]]
; CHECK:       r:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[B]], [[RET_ARG]] ], [ [[CALL]], [[RET_UNKNOWN]] ]
; CHECK-NEXT:    ret ptr [[PHI]]
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@ret_arg_or_unknown_through_phi
; CHECK-DL-SAME: (ptr nonnull [[B:%.*]]) #[[ATTR4]] {
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br label [[RET_UNKNOWN:%.*]]
; CHECK-DL:       ret_arg:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       ret_unknown:
; CHECK-DL-NEXT:    [[CALL:%.*]] = call nonnull ptr @unknown(ptr nonnull [[B]])
; CHECK-DL-NEXT:    br label [[R:%.*]]
; CHECK-DL:       r:
; CHECK-DL-NEXT:    ret ptr [[CALL]]
;
entry:
  %cmp = icmp eq ptr %b, null
  br i1 %cmp, label %ret_arg, label %ret_unknown

ret_arg:
  br label %r

ret_unknown:
  %call = call ptr @unknown(ptr %b)
  br label %r

r:
  %phi = phi ptr [ %b, %ret_arg ], [ %call, %ret_unknown ]
  ret ptr %phi
}

define weak_odr i32 @non_exact_0() {
; CHECK-LABEL: define {{[^@]+}}@non_exact_0() {
; CHECK-NEXT:    ret i32 0
;
; CHECK-DL-LABEL: define {{[^@]+}}@non_exact_0() {
; CHECK-DL-NEXT:    ret i32 0
;
  ret i32 0
}
define weak_odr i32 @non_exact_1(i32 %a) {
; CHECK-LABEL: define {{[^@]+}}@non_exact_1
; CHECK-SAME: (i32 [[A:%.*]]) {
; CHECK-NEXT:    ret i32 [[A]]
;
; CHECK-DL-LABEL: define {{[^@]+}}@non_exact_1
; CHECK-DL-SAME: (i32 [[A:%.*]]) {
; CHECK-DL-NEXT:    ret i32 [[A]]
;
  ret i32 %a
}
define weak_odr i32 @non_exact_2(i32 returned %a) {
; CHECK-LABEL: define {{[^@]+}}@non_exact_2
; CHECK-SAME: (i32 returned [[A:%.*]]) {
; CHECK-NEXT:    ret i32 [[A]]
;
; CHECK-DL-LABEL: define {{[^@]+}}@non_exact_2
; CHECK-DL-SAME: (i32 returned [[A:%.*]]) {
; CHECK-DL-NEXT:    ret i32 [[A]]
;
  ret i32 %a
}
define weak_odr align 16 ptr @non_exact_3(ptr align 32 returned %a) {
; CHECK-LABEL: define {{[^@]+}}@non_exact_3
; CHECK-SAME: (ptr returned align 32 [[A:%.*]]) {
; CHECK-NEXT:    ret ptr [[A]]
;
; CHECK-DL-LABEL: define {{[^@]+}}@non_exact_3
; CHECK-DL-SAME: (ptr returned align 32 [[A:%.*]]) {
; CHECK-DL-NEXT:    ret ptr [[A]]
;
  ret ptr %a
}
define weak_odr align 16 ptr @non_exact_4(ptr align 32 %a) {
; CHECK-LABEL: define {{[^@]+}}@non_exact_4
; CHECK-SAME: (ptr align 32 [[A:%.*]]) {
; CHECK-NEXT:    ret ptr [[A]]
;
; CHECK-DL-LABEL: define {{[^@]+}}@non_exact_4
; CHECK-DL-SAME: (ptr align 32 [[A:%.*]]) {
; CHECK-DL-NEXT:    ret ptr [[A]]
;
  ret ptr %a
}
; We can use the alignment information of the weak function non_exact_3 argument
; because it was given to us and not derived.
; We can use the return information of the weak function non_exact_4.
; %c2 and %c3 should be replaced but not %c0 or %c1!
define i32 @exact(ptr align 8 %a, ptr align 8 %b) {
; CHECK-LABEL: define {{[^@]+}}@exact
; CHECK-SAME: (ptr align 8 [[A:%.*]], ptr align 8 [[B:%.*]]) {
; CHECK-NEXT:    [[C0:%.*]] = call i32 @non_exact_0()
; CHECK-NEXT:    [[C1:%.*]] = call i32 @non_exact_1(i32 noundef 1)
; CHECK-NEXT:    [[C2:%.*]] = call i32 @non_exact_2(i32 noundef 2)
; CHECK-NEXT:    [[C3:%.*]] = call align 32 ptr @non_exact_3(ptr align 32 [[A]])
; CHECK-NEXT:    [[C4:%.*]] = call align 16 ptr @non_exact_4(ptr align 32 [[B]])
; CHECK-NEXT:    [[C3L:%.*]] = load i32, ptr [[A]], align 32
; CHECK-NEXT:    [[C4L:%.*]] = load i32, ptr [[C4]], align 16
; CHECK-NEXT:    [[ADD1:%.*]] = add i32 [[C0]], [[C1]]
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[ADD1]], 2
; CHECK-NEXT:    [[ADD3:%.*]] = add i32 [[ADD2]], [[C3L]]
; CHECK-NEXT:    [[ADD4:%.*]] = add i32 [[ADD3]], [[C4L]]
; CHECK-NEXT:    ret i32 [[ADD4]]
;
; CHECK-DL-LABEL: define {{[^@]+}}@exact
; CHECK-DL-SAME: (ptr nonnull align 8 [[A:%.*]], ptr nonnull align 8 [[B:%.*]]) {
; CHECK-DL-NEXT:    [[C0:%.*]] = call i32 @non_exact_0()
; CHECK-DL-NEXT:    [[C1:%.*]] = call i32 @non_exact_1(i32 noundef 1)
; CHECK-DL-NEXT:    [[C2:%.*]] = call i32 @non_exact_2(i32 noundef 2)
; CHECK-DL-NEXT:    [[C3:%.*]] = call align 32 ptr @non_exact_3(ptr nonnull align 32 [[A]])
; CHECK-DL-NEXT:    [[C4:%.*]] = call align 16 ptr @non_exact_4(ptr nonnull align 32 [[B]])
; CHECK-DL-NEXT:    [[C3L:%.*]] = load i32, ptr [[A]], align 32
; CHECK-DL-NEXT:    [[C4L:%.*]] = load i32, ptr [[C4]], align 16
; CHECK-DL-NEXT:    [[ADD1:%.*]] = add i32 [[C0]], [[C1]]
; CHECK-DL-NEXT:    [[ADD2:%.*]] = add i32 [[ADD1]], 2
; CHECK-DL-NEXT:    [[ADD3:%.*]] = add i32 [[ADD2]], [[C3L]]
; CHECK-DL-NEXT:    [[ADD4:%.*]] = add i32 [[ADD3]], [[C4L]]
; CHECK-DL-NEXT:    ret i32 [[ADD4]]
;
  %c0 = call i32 @non_exact_0()
  %c1 = call i32 @non_exact_1(i32 1)
  %c2 = call i32 @non_exact_2(i32 2)
  %c3 = call ptr @non_exact_3(ptr %a)
  %c4 = call ptr @non_exact_4(ptr %b)
  %c3l = load i32, ptr %c3
  %c4l = load i32, ptr %c4
  %add1 = add i32 %c0, %c1
  %add2 = add i32 %add1, %c2
  %add3 = add i32 %add2, %c3l
  %add4 = add i32 %add3, %c4l
  ret i32 %add4
}

declare dso_local ptr @__dynamic_cast(ptr, ptr, ptr, i64)

; UTC_ARGS: --enable

attributes #0 = { noinline nounwind uwtable }
;.
; TUNIT: attributes #[[ATTR0]] = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable }
; TUNIT: attributes #[[ATTR1]] = { nofree noinline nosync nounwind memory(none) uwtable }
; TUNIT: attributes #[[ATTR2]] = { nofree noinline nosync nounwind memory(argmem: read) uwtable }
; TUNIT: attributes #[[ATTR3]] = { mustprogress nofree noinline nosync nounwind willreturn memory(none) uwtable }
; TUNIT: attributes #[[ATTR4]] = { noinline nounwind uwtable }
; TUNIT: attributes #[[ATTR5]] = { nofree nosync nounwind memory(none) }
; TUNIT: attributes #[[ATTR6]] = { nofree nosync nounwind memory(read) }
; TUNIT: attributes #[[ATTR7]] = { nounwind }
;.
; TUNIT-DL: attributes #[[ATTR0]] = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable }
; TUNIT-DL: attributes #[[ATTR1]] = { nofree noinline nosync nounwind memory(none) uwtable }
; TUNIT-DL: attributes #[[ATTR2]] = { nofree noinline nosync nounwind memory(argmem: read) uwtable }
; TUNIT-DL: attributes #[[ATTR3]] = { mustprogress nofree noinline nosync nounwind willreturn memory(none) uwtable }
; TUNIT-DL: attributes #[[ATTR4]] = { noinline nounwind uwtable }
; TUNIT-DL: attributes #[[ATTR5]] = { nofree nosync nounwind memory(none) }
; TUNIT-DL: attributes #[[ATTR6]] = { nofree nosync nounwind memory(read) }
; TUNIT-DL: attributes #[[ATTR7]] = { nounwind }
;.
; CGSCC: attributes #[[ATTR0]] = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable }
; CGSCC: attributes #[[ATTR1]] = { nofree noinline nosync nounwind memory(none) uwtable }
; CGSCC: attributes #[[ATTR2]] = { nofree noinline nosync nounwind memory(argmem: read) uwtable }
; CGSCC: attributes #[[ATTR3]] = { mustprogress nofree noinline nosync nounwind willreturn memory(none) uwtable }
; CGSCC: attributes #[[ATTR4]] = { noinline nounwind uwtable }
; CGSCC: attributes #[[ATTR5]] = { nofree nosync nounwind memory(none) }
; CGSCC: attributes #[[ATTR6]] = { nofree nosync nounwind memory(read) }
; CGSCC: attributes #[[ATTR7]] = { nounwind }
;.
; CGSCC-DL: attributes #[[ATTR0]] = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable }
; CGSCC-DL: attributes #[[ATTR1]] = { nofree noinline nosync nounwind memory(none) uwtable }
; CGSCC-DL: attributes #[[ATTR2]] = { nofree noinline nosync nounwind memory(argmem: read) uwtable }
; CGSCC-DL: attributes #[[ATTR3]] = { mustprogress nofree noinline nosync nounwind willreturn memory(none) uwtable }
; CGSCC-DL: attributes #[[ATTR4]] = { noinline nounwind uwtable }
; CGSCC-DL: attributes #[[ATTR5]] = { nofree nosync nounwind memory(none) }
; CGSCC-DL: attributes #[[ATTR6]] = { nofree nosync nounwind memory(read) }
; CGSCC-DL: attributes #[[ATTR7]] = { nounwind }
;.
