; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT

declare float @llvm.fma.f32(float, float, float)
declare float @llvm.fmuladd.f32(float, float, float)

declare nofpclass(ninf nzero nsub nnorm) half @returns_positive_or_nan()

define float @ret_fma_same_mul_arg(float noundef %arg0, float %arg1) {
; CHECK-LABEL: define nofpclass(nzero) float @ret_fma_same_mul_arg
; CHECK-SAME: (float noundef [[ARG0:%.*]], float [[ARG1:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[CALL:%.*]] = call nofpclass(nzero) float @llvm.fma.f32(float noundef [[ARG0]], float noundef [[ARG0]], float [[ARG1]]) #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = call float @llvm.fma.f32(float %arg0, float %arg0, float %arg1)
  ret float %call
}

define float @ret_fma_same_mul_arg_maybe_undef(float %arg0, float %arg1) {
; CHECK-LABEL: define nofpclass(nzero) float @ret_fma_same_mul_arg_maybe_undef
; CHECK-SAME: (float [[ARG0:%.*]], float [[ARG1:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[CALL:%.*]] = call nofpclass(nzero) float @llvm.fma.f32(float [[ARG0]], float [[ARG0]], float [[ARG1]]) #[[ATTR2]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = call float @llvm.fma.f32(float %arg0, float %arg0, float %arg1)
  ret float %call
}

define float @ret_fma_same_mul_arg_positive_addend(float noundef %arg0, float nofpclass(ninf nsub nnorm) %arg1) {
; CHECK-LABEL: define nofpclass(ninf nzero nsub nnorm) float @ret_fma_same_mul_arg_positive_addend
; CHECK-SAME: (float noundef [[ARG0:%.*]], float nofpclass(ninf nsub nnorm) [[ARG1:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[CALL:%.*]] = call nofpclass(ninf nzero nsub nnorm) float @llvm.fma.f32(float noundef [[ARG0]], float noundef [[ARG0]], float nofpclass(ninf nsub nnorm) [[ARG1]]) #[[ATTR2]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = call float @llvm.fma.f32(float %arg0, float %arg0, float %arg1)
  ret float %call
}

define float @ret_fma_different_mul_arg_positive_addend(float noundef %arg0, float %arg1, float nofpclass(ninf nsub nnorm) %arg2) {
; CHECK-LABEL: define float @ret_fma_different_mul_arg_positive_addend
; CHECK-SAME: (float noundef [[ARG0:%.*]], float [[ARG1:%.*]], float nofpclass(ninf nsub nnorm) [[ARG2:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[CALL:%.*]] = call float @llvm.fma.f32(float noundef [[ARG0]], float [[ARG1]], float nofpclass(ninf nsub nnorm) [[ARG2]]) #[[ATTR2]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = call float @llvm.fma.f32(float %arg0, float %arg1, float %arg2)
  ret float %call
}

define float @ret_fmuladd_same_mul_arg(float noundef %arg0, float %arg1) {
; CHECK-LABEL: define nofpclass(nzero) float @ret_fmuladd_same_mul_arg
; CHECK-SAME: (float noundef [[ARG0:%.*]], float [[ARG1:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[CALL:%.*]] = call nofpclass(nzero) float @llvm.fmuladd.f32(float noundef [[ARG0]], float noundef [[ARG0]], float [[ARG1]]) #[[ATTR2]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = call float @llvm.fmuladd.f32(float %arg0, float %arg0, float %arg1)
  ret float %call
}

define float @ret_fmuladd_same_mul_arg_maybe_undef(float %arg0, float %arg1) {
; CHECK-LABEL: define nofpclass(nzero) float @ret_fmuladd_same_mul_arg_maybe_undef
; CHECK-SAME: (float [[ARG0:%.*]], float [[ARG1:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[CALL:%.*]] = call nofpclass(nzero) float @llvm.fmuladd.f32(float [[ARG0]], float [[ARG0]], float [[ARG1]]) #[[ATTR2]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = call float @llvm.fmuladd.f32(float %arg0, float %arg0, float %arg1)
  ret float %call
}

define float @ret_fmuladd_different_same_arg_positive_addend(float noundef %arg0, float nofpclass(ninf nsub nnorm) %arg1) {
; CHECK-LABEL: define nofpclass(ninf nzero nsub nnorm) float @ret_fmuladd_different_same_arg_positive_addend
; CHECK-SAME: (float noundef [[ARG0:%.*]], float nofpclass(ninf nsub nnorm) [[ARG1:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[CALL:%.*]] = call nofpclass(ninf nzero nsub nnorm) float @llvm.fmuladd.f32(float noundef [[ARG0]], float noundef [[ARG0]], float nofpclass(ninf nsub nnorm) [[ARG1]]) #[[ATTR2]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = call float @llvm.fmuladd.f32(float %arg0, float %arg0, float %arg1)
  ret float %call
}

define half @ret_fma__square_maybe_undef__pos2(half %unknown) {
; CHECK-LABEL: define nofpclass(ninf nzero nsub nnorm) half @ret_fma__square_maybe_undef__pos2
; CHECK-SAME: (half [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[POS2:%.*]] = call half @returns_positive_or_nan()
; CHECK-NEXT:    [[RESULT:%.*]] = call nofpclass(ninf nzero nsub nnorm) half @llvm.fma.f16(half [[UNKNOWN]], half [[UNKNOWN]], half [[POS2]])
; CHECK-NEXT:    ret half [[RESULT]]
;
  %pos2 = call half @returns_positive_or_nan()
  %result = call half @llvm.fma.f16(half %unknown, half %unknown, half %pos2)
  ret half %result
}

define half @ret_fma__square__pos2(half noundef %unknown) {
; CHECK-LABEL: define nofpclass(ninf nzero nsub nnorm) half @ret_fma__square__pos2
; CHECK-SAME: (half noundef [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[POS2:%.*]] = call half @returns_positive_or_nan()
; CHECK-NEXT:    [[RESULT:%.*]] = call nofpclass(ninf nzero nsub nnorm) half @llvm.fma.f16(half noundef [[UNKNOWN]], half noundef [[UNKNOWN]], half [[POS2]])
; CHECK-NEXT:    ret half [[RESULT]]
;
  %pos2 = call half @returns_positive_or_nan()
  %result = call half @llvm.fma.f16(half %unknown, half %unknown, half %pos2)
  ret half %result
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; TUNIT: {{.*}}
