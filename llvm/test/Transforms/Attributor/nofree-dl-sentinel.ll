; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -S < %s | FileCheck %s --check-prefixes=CHECK
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S < %s | FileCheck %s --check-prefixes=CHECK-DL

; Test cases specifically designed for the "nofree" function attribute.
; We use FIXME's to indicate problems and missing attributes.

; Free functions
declare void @free(ptr nocapture) local_unnamed_addr #1
declare noalias ptr @realloc(ptr nocapture, i64) local_unnamed_addr #0
declare void @_ZdaPv(ptr) local_unnamed_addr #2

; TEST 3 (negative case)
; Free occurs in same scc.
; void free_in_scc1(char*p){
;    free_in_scc2(p);
; }
; void free_in_scc2(char*p){
;    free_in_scc1(p);
;    free(p);
; }


define void @free_in_scc1(ptr nocapture %0) local_unnamed_addr #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@free_in_scc1
; CHECK-SAME: (ptr nocapture [[TMP0:%.*]]) local_unnamed_addr #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    tail call void @free_in_scc2(ptr nocapture [[TMP0]]) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    ret void
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@free_in_scc1
; CHECK-DL-SAME: (ptr nocapture nonnull [[TMP0:%.*]]) local_unnamed_addr #[[ATTR1:[0-9]+]] {
; CHECK-DL-NEXT:    tail call void @free_in_scc2(ptr nocapture nonnull [[TMP0]]) #[[ATTR0:[0-9]+]]
; CHECK-DL-NEXT:    ret void
;
  tail call void @free_in_scc2(ptr %0) #1
  ret void
}
define void @free_in_scc2(ptr nocapture %0) local_unnamed_addr #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@free_in_scc2
; CHECK-SAME: (ptr nocapture [[TMP0:%.*]]) local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[TMP0]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[REC:%.*]], label [[CALL:%.*]]
; CHECK:       call:
; CHECK-NEXT:    tail call void @free(ptr nocapture nonnull [[TMP0]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[END:%.*]]
; CHECK:       rec:
; CHECK-NEXT:    tail call void @free_in_scc1(ptr nocapture [[TMP0]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@free_in_scc2
; CHECK-DL-SAME: (ptr nocapture nonnull [[TMP0:%.*]]) local_unnamed_addr #[[ATTR1]] {
; CHECK-DL-NEXT:    br label [[CALL:%.*]]
; CHECK-DL:       call:
; CHECK-DL-NEXT:    tail call void @free(ptr nocapture nonnull [[TMP0]]) #[[ATTR0]]
; CHECK-DL-NEXT:    br label [[END:%.*]]
; CHECK-DL:       rec:
; CHECK-DL-NEXT:    unreachable
; CHECK-DL:       end:
; CHECK-DL-NEXT:    ret void
;
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %rec, label %call
call:
  tail call void @free(ptr %0) #1
  br label %end
rec:
  tail call void @free_in_scc1(ptr %0)
  br label %end
end:
  ret void
}

; TEST 5
; C++ delete operation (negative case)
; void delete_op (char p[]){
;     delete [] p;
; }

define void @_Z9delete_opPc(ptr %0) local_unnamed_addr #0 {
; CHECK: Function Attrs: noinline nounwind uwtable
; CHECK-LABEL: define {{[^@]+}}@_Z9delete_opPc
; CHECK-SAME: (ptr [[TMP0:%.*]]) local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq ptr [[TMP0]], null
; CHECK-NEXT:    br i1 [[TMP2]], label [[TMP4:%.*]], label [[TMP3:%.*]]
; CHECK:       3:
; CHECK-NEXT:    tail call void @_ZdaPv(ptr nonnull [[TMP0]]) #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    br label [[TMP4]]
; CHECK:       4:
; CHECK-NEXT:    ret void
;
; CHECK-DL: Function Attrs: noinline nounwind uwtable
; CHECK-DL-LABEL: define {{[^@]+}}@_Z9delete_opPc
; CHECK-DL-SAME: (ptr nonnull [[TMP0:%.*]]) local_unnamed_addr #[[ATTR1]] {
; CHECK-DL-NEXT:    br label [[TMP2:%.*]]
; CHECK-DL:       2:
; CHECK-DL-NEXT:    tail call void @_ZdaPv(ptr nonnull [[TMP0]]) #[[ATTR2:[0-9]+]]
; CHECK-DL-NEXT:    br label [[TMP3:%.*]]
; CHECK-DL:       3:
; CHECK-DL-NEXT:    ret void
;
  %2 = icmp eq ptr %0, null
  br i1 %2, label %4, label %3

; <label>:3:                                      ; preds = %1
  tail call void @_ZdaPv(ptr nonnull %0) #2
  br label %4

; <label>:4:                                      ; preds = %3, %1
  ret void
}

declare void @llvm.assume(i1)
declare void @unknown(ptr, ptr, ptr, ptr)
declare void @use_i8_ptr(ptr nocapture readnone) nounwind
declare void @use_i8_ptr_ret(ptr nocapture readnone) nounwind willreturn

declare noalias ptr @malloc(i64)

attributes #0 = { nounwind uwtable noinline }
attributes #1 = { nounwind }
attributes #2 = { nobuiltin nounwind }
;.
; CHECK: attributes #[[ATTR0]] = { nounwind }
; CHECK: attributes #[[ATTR1]] = { noinline nounwind uwtable }
; CHECK: attributes #[[ATTR2]] = { nobuiltin nounwind }
; CHECK: attributes #[[ATTR3:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
; CHECK: attributes #[[ATTR4:[0-9]+]] = { nounwind willreturn }
;.
; CHECK-DL: attributes #[[ATTR0]] = { nounwind }
; CHECK-DL: attributes #[[ATTR1]] = { noinline nounwind uwtable }
; CHECK-DL: attributes #[[ATTR2]] = { nobuiltin nounwind }
; CHECK-DL: attributes #[[ATTR3:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
; CHECK-DL: attributes #[[ATTR4:[0-9]+]] = { nounwind willreturn }
;.
