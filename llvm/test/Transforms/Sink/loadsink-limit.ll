; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S < %s -passes=sink -sink-load-store-limit=2 | FileCheck %s --check-prefix=CHECK_LIMIT_2
; RUN: opt -S < %s -passes=sink -sink-load-store-limit=3 | FileCheck %s --check-prefix=CHECK_LIMIT_3

; Test -sink-load-store-limit option

; Load can be sunk if -sink-load-store-limit >=3.  There are 3 stores to analyze in block thenA.
define void @load_can_sink_noalias(i1 %condReturn, i1 %condA, i1 %condB, ptr noalias %a, ptr %b, ptr %c, ptr %d) {
; CHECK_LIMIT_2-LABEL: define void @load_can_sink_noalias(
; CHECK_LIMIT_2-SAME: i1 [[CONDRETURN:%.*]], i1 [[CONDA:%.*]], i1 [[CONDB:%.*]], ptr noalias [[A:%.*]], ptr [[B:%.*]], ptr [[C:%.*]], ptr [[D:%.*]]) {
; CHECK_LIMIT_2-NEXT:  [[ENTRY:.*:]]
; CHECK_LIMIT_2-NEXT:    br i1 [[CONDRETURN]], label %[[IFA:.*]], label %[[RETURN_BLOCK:.*]]
; CHECK_LIMIT_2:       [[IFA]]:
; CHECK_LIMIT_2-NEXT:    [[VALUE:%.*]] = load i32, ptr [[A]], align 4
; CHECK_LIMIT_2-NEXT:    br i1 [[CONDA]], label %[[THENA:.*]], label %[[IFB:.*]]
; CHECK_LIMIT_2:       [[THENA]]:
; CHECK_LIMIT_2-NEXT:    store i32 0, ptr [[B]], align 4
; CHECK_LIMIT_2-NEXT:    store i32 1, ptr [[C]], align 4
; CHECK_LIMIT_2-NEXT:    store i32 2, ptr [[D]], align 4
; CHECK_LIMIT_2-NEXT:    br label %[[IFB]]
; CHECK_LIMIT_2:       [[IFB]]:
; CHECK_LIMIT_2-NEXT:    br i1 [[CONDB]], label %[[THENB:.*]], label %[[RETURN_BLOCK]]
; CHECK_LIMIT_2:       [[THENB]]:
; CHECK_LIMIT_2-NEXT:    store i32 [[VALUE]], ptr [[B]], align 4
; CHECK_LIMIT_2-NEXT:    br label %[[RETURN_BLOCK]]
; CHECK_LIMIT_2:       [[RETURN_BLOCK]]:
; CHECK_LIMIT_2-NEXT:    ret void
;
; CHECK_LIMIT_3-LABEL: define void @load_can_sink_noalias(
; CHECK_LIMIT_3-SAME: i1 [[CONDRETURN:%.*]], i1 [[CONDA:%.*]], i1 [[CONDB:%.*]], ptr noalias [[A:%.*]], ptr [[B:%.*]], ptr [[C:%.*]], ptr [[D:%.*]]) {
; CHECK_LIMIT_3-NEXT:  [[ENTRY:.*:]]
; CHECK_LIMIT_3-NEXT:    br i1 [[CONDRETURN]], label %[[IFA:.*]], label %[[RETURN_BLOCK:.*]]
; CHECK_LIMIT_3:       [[IFA]]:
; CHECK_LIMIT_3-NEXT:    br i1 [[CONDA]], label %[[THENA:.*]], label %[[IFB:.*]]
; CHECK_LIMIT_3:       [[THENA]]:
; CHECK_LIMIT_3-NEXT:    store i32 0, ptr [[B]], align 4
; CHECK_LIMIT_3-NEXT:    store i32 1, ptr [[C]], align 4
; CHECK_LIMIT_3-NEXT:    store i32 2, ptr [[D]], align 4
; CHECK_LIMIT_3-NEXT:    br label %[[IFB]]
; CHECK_LIMIT_3:       [[IFB]]:
; CHECK_LIMIT_3-NEXT:    br i1 [[CONDB]], label %[[THENB:.*]], label %[[RETURN_BLOCK]]
; CHECK_LIMIT_3:       [[THENB]]:
; CHECK_LIMIT_3-NEXT:    [[VALUE:%.*]] = load i32, ptr [[A]], align 4
; CHECK_LIMIT_3-NEXT:    store i32 [[VALUE]], ptr [[B]], align 4
; CHECK_LIMIT_3-NEXT:    br label %[[RETURN_BLOCK]]
; CHECK_LIMIT_3:       [[RETURN_BLOCK]]:
; CHECK_LIMIT_3-NEXT:    ret void
;
entry:
  %value = load i32, ptr %a, align 4
  br i1 %condReturn, label %ifA, label %return_block
ifA:
  br i1 %condA, label %thenA, label %ifB
thenA:
  store i32 0, ptr %b
  store i32 1, ptr %c
  store i32 2, ptr %d
  br label %ifB
ifB:
  br i1 %condB, label %thenB, label %return_block
thenB:
  store i32 %value, ptr %b
  br label %return_block
return_block:
  ret void
}

