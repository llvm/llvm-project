; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=infer-alignment -S < %s | FileCheck %s

define void @store_b32_basealign2_offset1(ptr align 2 %p, i32 %v) {
; CHECK-LABEL: define void @store_b32_basealign2_offset1(
; CHECK-SAME: ptr align 2 [[P:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 1, !align_offset [[META0:![0-9]+]]
; CHECK-NEXT:    store i32 [[V]], ptr [[LEN]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 1
  store i32 %v, ptr %len, align 1
  ret void
}

define void @store_b32_basealign2_offset3(ptr align 2 %p, i32 %v) {
; CHECK-LABEL: define void @store_b32_basealign2_offset3(
; CHECK-SAME: ptr align 2 [[P:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 3, !align_offset [[META1:![0-9]+]]
; CHECK-NEXT:    store i32 [[V]], ptr [[LEN]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 3
  store i32 %v, ptr %len, align 1
  ret void
}

define void @store_b64_basealign4_offset1(ptr align 4 %p) {
; CHECK-LABEL: define void @store_b64_basealign4_offset1(
; CHECK-SAME: ptr align 4 [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 1, !align_offset [[META2:![0-9]+]]
; CHECK-NEXT:    store i64 0, ptr [[LEN]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 1
  store i64 0, ptr %len, align 1
  ret void
}

define void @store_b64_basealign4_offset2(ptr align 4 %p) {
; CHECK-LABEL: define void @store_b64_basealign4_offset2(
; CHECK-SAME: ptr align 4 [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 2, !align_offset [[META3:![0-9]+]]
; CHECK-NEXT:    store i64 0, ptr [[LEN]], align 2
; CHECK-NEXT:    ret void
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 2
  store i64 0, ptr %len, align 2
  ret void
}

define i32 @load_b32_base_align2_offset1(ptr align 2 %p) {
; CHECK-LABEL: define i32 @load_b32_base_align2_offset1(
; CHECK-SAME: ptr align 2 [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 1, !align_offset [[META0]]
; CHECK-NEXT:    [[V:%.*]] = load i32, ptr [[LEN]], align 1
; CHECK-NEXT:    ret i32 [[V]]
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 1
  %v = load i32, ptr %len, align 1
  ret i32 %v
}

define i32 @load_b32_base_align2_offset3(ptr align 2 %p) {
; CHECK-LABEL: define i32 @load_b32_base_align2_offset3(
; CHECK-SAME: ptr align 2 [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 3, !align_offset [[META1]]
; CHECK-NEXT:    [[V:%.*]] = load i32, ptr [[LEN]], align 1
; CHECK-NEXT:    ret i32 [[V]]
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 3
  %v = load i32, ptr %len, align 1
  ret i32 %v
}

define i64 @load_b64_base_align4_offset1(ptr align 4 %p) {
; CHECK-LABEL: define i64 @load_b64_base_align4_offset1(
; CHECK-SAME: ptr align 4 [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 1, !align_offset [[META2]]
; CHECK-NEXT:    [[V:%.*]] = load i64, ptr [[LEN]], align 1
; CHECK-NEXT:    ret i64 [[V]]
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 1
  %v = load i64, ptr %len, align 1
  ret i64 %v
}

define i64 @load_b64_base_align4_offset2(ptr align 4 %p) {
; CHECK-LABEL: define i64 @load_b64_base_align4_offset2(
; CHECK-SAME: ptr align 4 [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i32 2, !align_offset [[META3]]
; CHECK-NEXT:    [[V:%.*]] = load i64, ptr [[LEN]], align 2
; CHECK-NEXT:    ret i64 [[V]]
;
entry:
  %len = getelementptr inbounds nuw i8, ptr %p, i32 2
  %v = load i64, ptr %len, align 2
  ret i64 %v
}

%struct.str_t = type <{ i8, i8, i8, i32, i8, i32, i32 }>

define dso_local void @loop_base_align16_offset3(ptr align 16 %p, i32 signext %N) {
; CHECK-LABEL: define dso_local void @loop_base_align16_offset3(
; CHECK-SAME: ptr align 16 [[P:%.*]], i32 signext [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP11:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP11]], label %[[FOR_BODY_PREHEADER:.*]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_BODY_PREHEADER]]:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext nneg i32 [[N]] to i64
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [[STRUCT_STR_T:%.*]], ptr [[P]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[LEN:%.*]] = getelementptr inbounds nuw i8, ptr [[ARRAYIDX]], i64 3, !align_offset [[META4:![0-9]+]]
; CHECK-NEXT:    store i32 0, ptr [[LEN]], align 1
; CHECK-NEXT:    [[LEN2:%.*]] = getelementptr inbounds nuw i8, ptr [[ARRAYIDX]], i64 8
; CHECK-NEXT:    store i32 2, ptr [[LEN2]], align 8
; CHECK-NEXT:    [[LEN3:%.*]] = getelementptr inbounds nuw i8, ptr [[ARRAYIDX]], i64 12
; CHECK-NEXT:    store i32 3, ptr [[LEN3]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
;
entry:
  %cmp11 = icmp sgt i32 %N, 0
  br i1 %cmp11, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %N to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds nuw %struct.str_t, ptr %p, i64 %indvars.iv
  %len = getelementptr inbounds nuw i8, ptr %arrayidx, i64 3
  store i32 0, ptr %len, align 1
  %len2 = getelementptr inbounds nuw i8, ptr %arrayidx, i64 8
  store i32 2, ptr %len2, align 8
  %len3 = getelementptr inbounds nuw i8, ptr %arrayidx, i64 12
  store i32 3, ptr %len3, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

;.
; CHECK: [[META0]] = !{i64 2, i64 1}
; CHECK: [[META1]] = !{i64 2, i64 3}
; CHECK: [[META2]] = !{i64 4, i64 1}
; CHECK: [[META3]] = !{i64 4, i64 2}
; CHECK: [[META4]] = !{i64 16, i64 3}
;.
