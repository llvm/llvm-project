; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=packedintcombine %s | FileCheck %s --check-prefix=LAZY
; RUN: opt -S -passes=packedintcombine -packedint-aggressive-rewriter %s | FileCheck %s --check-prefix=AGGRESSIVE

define i32 @extract_i32(<4 x i8> %from) {
; LAZY-LABEL: define i32 @extract_i32(
; LAZY-SAME: <4 x i8> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_CAST:%.*]] = bitcast <4 x i8> [[FROM]] to i32
; LAZY-NEXT:    ret i32 [[FROM_CAST]]
;
; AGGRESSIVE-LABEL: define i32 @extract_i32(
; AGGRESSIVE-SAME: <4 x i8> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_CAST:%.*]] = bitcast <4 x i8> [[FROM]] to i32
; AGGRESSIVE-NEXT:    ret i32 [[FROM_CAST]]
;
  %mask.0 = extractelement <4 x i8> %from, i64 0
  %get.0 = zext i8 %mask.0 to i32

  %mask.1 = extractelement <4 x i8> %from, i64 1
  %zext.1 = zext i8 %mask.1 to i32
  %get.1 = shl i32 %zext.1, 8
  %out.1 = or i32 %get.0, %get.1

  %mask.2 = extractelement <4 x i8> %from, i64 2
  %zext.2 = zext i8 %mask.2 to i32
  %get.2 = shl i32 %zext.2, 16

  %mask.3 = extractelement <4 x i8> %from, i64 3
  %zext.3 = zext i8 %mask.3 to i32
  %get.3 = shl i32 %zext.3, 24
  %out.2 = or i32 %get.2, %get.3

  %out = or i32 %out.1, %out.2
  ret i32 %out
}

define i32 @extract_i32.i16(<2 x i16> %from) {
; LAZY-LABEL: define i32 @extract_i32.i16(
; LAZY-SAME: <2 x i16> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_CAST:%.*]] = bitcast <2 x i16> [[FROM]] to i32
; LAZY-NEXT:    ret i32 [[FROM_CAST]]
;
; AGGRESSIVE-LABEL: define i32 @extract_i32.i16(
; AGGRESSIVE-SAME: <2 x i16> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_CAST:%.*]] = bitcast <2 x i16> [[FROM]] to i32
; AGGRESSIVE-NEXT:    ret i32 [[FROM_CAST]]
;
  %mask.0 = extractelement <2 x i16> %from, i64 0
  %get.0 = zext i16 %mask.0 to i32

  %mask.1 = extractelement <2 x i16> %from, i64 1
  %zext.1 = zext i16 %mask.1 to i32
  %get.1 = shl i32 %zext.1, 16

  %out = or i32 %get.0, %get.1
  ret i32 %out
}

define i32 @extract_i32_lower(<8 x i8> %from) {
; LAZY-LABEL: define i32 @extract_i32_lower(
; LAZY-SAME: <8 x i8> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <8 x i8> [[FROM]], <8 x i8> zeroinitializer, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
; LAZY-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <4 x i8> [[FROM_SHUFFLE]] to i32
; LAZY-NEXT:    ret i32 [[FROM_SHUFFLE_CAST]]
;
; AGGRESSIVE-LABEL: define i32 @extract_i32_lower(
; AGGRESSIVE-SAME: <8 x i8> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <8 x i8> [[FROM]], <8 x i8> zeroinitializer, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <4 x i8> [[FROM_SHUFFLE]] to i32
; AGGRESSIVE-NEXT:    ret i32 [[FROM_SHUFFLE_CAST]]
;
  %mask.0 = extractelement <8 x i8> %from, i64 4
  %get.0 = zext i8 %mask.0 to i32

  %mask.1 = extractelement <8 x i8> %from, i64 5
  %zext.1 = zext i8 %mask.1 to i32
  %get.1 = shl i32 %zext.1, 8
  %out.1 = or i32 %get.0, %get.1

  %mask.2 = extractelement <8 x i8> %from, i64 6
  %zext.2 = zext i8 %mask.2 to i32
  %get.2 = shl i32 %zext.2, 16

  %mask.3 = extractelement <8 x i8> %from, i64 7
  %zext.3 = zext i8 %mask.3 to i32
  %get.3 = shl i32 %zext.3, 24
  %out.2 = or i32 %get.2, %get.3

  %out = or i32 %out.1, %out.2
  ret i32 %out
}

define i32 @extract_i32_lower.i16(<4 x i16> %from) {
; LAZY-LABEL: define i32 @extract_i32_lower.i16(
; LAZY-SAME: <4 x i16> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <4 x i16> [[FROM]], <4 x i16> zeroinitializer, <2 x i32> <i32 2, i32 3>
; LAZY-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <2 x i16> [[FROM_SHUFFLE]] to i32
; LAZY-NEXT:    ret i32 [[FROM_SHUFFLE_CAST]]
;
; AGGRESSIVE-LABEL: define i32 @extract_i32_lower.i16(
; AGGRESSIVE-SAME: <4 x i16> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <4 x i16> [[FROM]], <4 x i16> zeroinitializer, <2 x i32> <i32 2, i32 3>
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <2 x i16> [[FROM_SHUFFLE]] to i32
; AGGRESSIVE-NEXT:    ret i32 [[FROM_SHUFFLE_CAST]]
;
  %mask.0 = extractelement <4 x i16> %from, i64 2
  %get.0 = zext i16 %mask.0 to i32

  %mask.1 = extractelement <4 x i16> %from, i64 3
  %zext.1 = zext i16 %mask.1 to i32
  %get.1 = shl i32 %zext.1, 16

  %out = or i32 %get.0, %get.1
  ret i32 %out
}

;; u0xff00ffff = -16711681
define i32 @extract_i32_masked(<4 x i8> %from) {
; LAZY-LABEL: define i32 @extract_i32_masked(
; LAZY-SAME: <4 x i8> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_CAST:%.*]] = bitcast <4 x i8> [[FROM]] to i32
; LAZY-NEXT:    [[FROM_MASK:%.*]] = and i32 [[FROM_CAST]], -16711681
; LAZY-NEXT:    ret i32 [[FROM_MASK]]
;
; AGGRESSIVE-LABEL: define i32 @extract_i32_masked(
; AGGRESSIVE-SAME: <4 x i8> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_CAST:%.*]] = bitcast <4 x i8> [[FROM]] to i32
; AGGRESSIVE-NEXT:    [[FROM_MASK:%.*]] = and i32 [[FROM_CAST]], -16711681
; AGGRESSIVE-NEXT:    ret i32 [[FROM_MASK]]
;
  %mask.0 = extractelement <4 x i8> %from, i64 0
  %get.0 = zext i8 %mask.0 to i32

  %mask.1 = extractelement <4 x i8> %from, i64 1
  %zext.1 = zext i8 %mask.1 to i32
  %get.1 = shl i32 %zext.1, 8
  %out.1 = or i32 %get.0, %get.1

  %mask.3 = extractelement <4 x i8> %from, i64 3
  %zext.3 = zext i8 %mask.3 to i32
  %get.3 = shl i32 %zext.3, 24
  %out.2 = or i32 %out.1, %get.3

  ret i32 %out.2
}

;; u0xff00ffff = -16711681
define i32 @extract_i32_masked.i16(<2 x i16> %from) {
; LAZY-LABEL: define i32 @extract_i32_masked.i16(
; LAZY-SAME: <2 x i16> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_CAST:%.*]] = bitcast <2 x i16> [[FROM]] to i32
; LAZY-NEXT:    [[FROM_MASK:%.*]] = and i32 [[FROM_CAST]], -16711681
; LAZY-NEXT:    ret i32 [[FROM_MASK]]
;
; AGGRESSIVE-LABEL: define i32 @extract_i32_masked.i16(
; AGGRESSIVE-SAME: <2 x i16> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_CAST:%.*]] = bitcast <2 x i16> [[FROM]] to i32
; AGGRESSIVE-NEXT:    [[FROM_MASK:%.*]] = and i32 [[FROM_CAST]], -16711681
; AGGRESSIVE-NEXT:    ret i32 [[FROM_MASK]]
;
  %mask.0 = extractelement <2 x i16> %from, i64 0
  %get.0 = zext i16 %mask.0 to i32

  %mask.1 = extractelement <2 x i16> %from, i64 1
  %mask.1.1 = and i16 %mask.1, u0xff00
  %zext.1 = zext i16 %mask.1.1 to i32
  %get.1 = shl i32 %zext.1, 16

  %out = or i32 %get.0, %get.1
  ret i32 %out
}

define i64 @extract_i64(<4 x i8> %from) {
; LAZY-LABEL: define i64 @extract_i64(
; LAZY-SAME: <4 x i8> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <4 x i8> [[FROM]], <4 x i8> zeroinitializer, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 4, i32 4, i32 4>
; LAZY-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <8 x i8> [[FROM_SHUFFLE]] to i64
; LAZY-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
; AGGRESSIVE-LABEL: define i64 @extract_i64(
; AGGRESSIVE-SAME: <4 x i8> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <4 x i8> [[FROM]], <4 x i8> zeroinitializer, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 4, i32 4, i32 4>
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <8 x i8> [[FROM_SHUFFLE]] to i64
; AGGRESSIVE-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
  %mask.0 = extractelement <4 x i8> %from, i64 0
  %get.0 = zext i8 %mask.0 to i64

  %mask.1 = extractelement <4 x i8> %from, i64 1
  %zext.1 = zext i8 %mask.1 to i64
  %get.1 = shl i64 %zext.1, 8
  %out.1 = or i64 %get.0, %get.1

  %mask.2 = extractelement <4 x i8> %from, i64 2
  %zext.2 = zext i8 %mask.2 to i64
  %get.2 = shl i64 %zext.2, 16

  %mask.3 = extractelement <4 x i8> %from, i64 3
  %zext.3 = zext i8 %mask.3 to i64
  %get.3 = shl i64 %zext.3, 24
  %out.2 = or i64 %get.2, %get.3

  %out = or i64 %out.1, %out.2
  ret i64 %out
}

define i64 @extract_i64.i16(<2 x i16> %from) {
; LAZY-LABEL: define i64 @extract_i64.i16(
; LAZY-SAME: <2 x i16> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <2 x i16> [[FROM]], <2 x i16> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; LAZY-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <4 x i16> [[FROM_SHUFFLE]] to i64
; LAZY-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
; AGGRESSIVE-LABEL: define i64 @extract_i64.i16(
; AGGRESSIVE-SAME: <2 x i16> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <2 x i16> [[FROM]], <2 x i16> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <4 x i16> [[FROM_SHUFFLE]] to i64
; AGGRESSIVE-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
  %mask.0 = extractelement <2 x i16> %from, i64 0
  %get.0 = zext i16 %mask.0 to i64

  %mask.1 = extractelement <2 x i16> %from, i64 1
  %zext.1 = zext i16 %mask.1 to i64
  %get.1 = shl i64 %zext.1, 16

  %out = or i64 %get.0, %get.1
  ret i64 %out
}

define i64 @extract_i64_shifted(<4 x i8> %from) {
; LAZY-LABEL: define i64 @extract_i64_shifted(
; LAZY-SAME: <4 x i8> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <4 x i8> [[FROM]], <4 x i8> zeroinitializer, <8 x i32> <i32 4, i32 4, i32 4, i32 4, i32 0, i32 1, i32 2, i32 3>
; LAZY-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <8 x i8> [[FROM_SHUFFLE]] to i64
; LAZY-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
; AGGRESSIVE-LABEL: define i64 @extract_i64_shifted(
; AGGRESSIVE-SAME: <4 x i8> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <4 x i8> [[FROM]], <4 x i8> zeroinitializer, <8 x i32> <i32 4, i32 4, i32 4, i32 4, i32 0, i32 1, i32 2, i32 3>
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <8 x i8> [[FROM_SHUFFLE]] to i64
; AGGRESSIVE-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
  %mask.0 = extractelement <4 x i8> %from, i64 0
  %zext.0 = zext i8 %mask.0 to i64
  %get.0 = shl i64 %zext.0, 32

  %mask.1 = extractelement <4 x i8> %from, i64 1
  %zext.1 = zext i8 %mask.1 to i64
  %get.1 = shl i64 %zext.1, 40
  %out.1 = or i64 %get.0, %get.1

  %mask.2 = extractelement <4 x i8> %from, i64 2
  %zext.2 = zext i8 %mask.2 to i64
  %get.2 = shl i64 %zext.2, 48

  %mask.3 = extractelement <4 x i8> %from, i64 3
  %zext.3 = zext i8 %mask.3 to i64
  %get.3 = shl i64 %zext.3, 56
  %out.2 = or i64 %get.2, %get.3

  %out = or i64 %out.1, %out.2
  ret i64 %out
}

define i64 @extract_i64_shifted.i16(<2 x i16> %from) {
; LAZY-LABEL: define i64 @extract_i64_shifted.i16(
; LAZY-SAME: <2 x i16> [[FROM:%.*]]) {
; LAZY-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <2 x i16> [[FROM]], <2 x i16> zeroinitializer, <4 x i32> <i32 2, i32 2, i32 0, i32 1>
; LAZY-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <4 x i16> [[FROM_SHUFFLE]] to i64
; LAZY-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
; AGGRESSIVE-LABEL: define i64 @extract_i64_shifted.i16(
; AGGRESSIVE-SAME: <2 x i16> [[FROM:%.*]]) {
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE:%.*]] = shufflevector <2 x i16> [[FROM]], <2 x i16> zeroinitializer, <4 x i32> <i32 2, i32 2, i32 0, i32 1>
; AGGRESSIVE-NEXT:    [[FROM_SHUFFLE_CAST:%.*]] = bitcast <4 x i16> [[FROM_SHUFFLE]] to i64
; AGGRESSIVE-NEXT:    ret i64 [[FROM_SHUFFLE_CAST]]
;
  %mask.0 = extractelement <2 x i16> %from, i64 0
  %zext.0 = zext i16 %mask.0 to i64
  %get.0 = shl i64 %zext.0, 32

  %mask.1 = extractelement <2 x i16> %from, i64 1
  %zext.1 = zext i16 %mask.1 to i64
  %get.1 = shl i64 %zext.1, 48

  %out = or i64 %get.0, %get.1
  ret i64 %out
}

define i64 @extract_combine(i32 %bot, <4 x i8> %top) {
; LAZY-LABEL: define i64 @extract_combine(
; LAZY-SAME: i32 [[BOT:%.*]], <4 x i8> [[TOP:%.*]]) {
; LAZY-NEXT:    [[BOT_CAST:%.*]] = zext i32 [[BOT]] to i64
; LAZY-NEXT:    [[TOP_SHUFFLE:%.*]] = shufflevector <4 x i8> [[TOP]], <4 x i8> zeroinitializer, <8 x i32> <i32 4, i32 4, i32 4, i32 4, i32 0, i32 1, i32 2, i32 3>
; LAZY-NEXT:    [[TOP_SHUFFLE_CAST:%.*]] = bitcast <8 x i8> [[TOP_SHUFFLE]] to i64
; LAZY-NEXT:    [[OUT_3_MERGE:%.*]] = or disjoint i64 [[BOT_CAST]], [[TOP_SHUFFLE_CAST]]
; LAZY-NEXT:    ret i64 [[OUT_3_MERGE]]
;
; AGGRESSIVE-LABEL: define i64 @extract_combine(
; AGGRESSIVE-SAME: i32 [[BOT:%.*]], <4 x i8> [[TOP:%.*]]) {
; AGGRESSIVE-NEXT:    [[BOT_CAST:%.*]] = zext i32 [[BOT]] to i64
; AGGRESSIVE-NEXT:    [[TOP_SHUFFLE:%.*]] = shufflevector <4 x i8> [[TOP]], <4 x i8> zeroinitializer, <8 x i32> <i32 4, i32 4, i32 4, i32 4, i32 0, i32 1, i32 2, i32 3>
; AGGRESSIVE-NEXT:    [[TOP_SHUFFLE_CAST:%.*]] = bitcast <8 x i8> [[TOP_SHUFFLE]] to i64
; AGGRESSIVE-NEXT:    [[OUT_3_MERGE:%.*]] = or disjoint i64 [[BOT_CAST]], [[TOP_SHUFFLE_CAST]]
; AGGRESSIVE-NEXT:    ret i64 [[OUT_3_MERGE]]
;
  %base = zext i32 %bot to i64

  %mask.0 = extractelement <4 x i8> %top, i64 0
  %zext.0 = zext i8 %mask.0 to i64
  %get.0 = shl i64 %zext.0, 32
  %out.0 = or i64 %base, %get.0

  %mask.1 = extractelement <4 x i8> %top, i64 1
  %zext.1 = zext i8 %mask.1 to i64
  %get.1 = shl i64 %zext.1, 40
  %out.1 = or i64 %out.0, %get.1

  %mask.2 = extractelement <4 x i8> %top, i64 2
  %zext.2 = zext i8 %mask.2 to i64
  %get.2 = shl i64 %zext.2, 48
  %out.2 = or i64 %out.1, %get.2

  %mask.3 = extractelement <4 x i8> %top, i64 3
  %zext.3 = zext i8 %mask.3 to i64
  %get.3 = shl i64 %zext.3, 56
  %out.3 = or i64 %out.2, %get.3

  ret i64 %out.3
}

define i64 @extract_combine.i16(i32 %bot, <2 x i16> %top) {
; LAZY-LABEL: define i64 @extract_combine.i16(
; LAZY-SAME: i32 [[BOT:%.*]], <2 x i16> [[TOP:%.*]]) {
; LAZY-NEXT:    [[BOT_CAST:%.*]] = zext i32 [[BOT]] to i64
; LAZY-NEXT:    [[TOP_SHUFFLE:%.*]] = shufflevector <2 x i16> [[TOP]], <2 x i16> zeroinitializer, <4 x i32> <i32 2, i32 2, i32 0, i32 1>
; LAZY-NEXT:    [[TOP_SHUFFLE_CAST:%.*]] = bitcast <4 x i16> [[TOP_SHUFFLE]] to i64
; LAZY-NEXT:    [[OUT_1_MERGE:%.*]] = or disjoint i64 [[BOT_CAST]], [[TOP_SHUFFLE_CAST]]
; LAZY-NEXT:    ret i64 [[OUT_1_MERGE]]
;
; AGGRESSIVE-LABEL: define i64 @extract_combine.i16(
; AGGRESSIVE-SAME: i32 [[BOT:%.*]], <2 x i16> [[TOP:%.*]]) {
; AGGRESSIVE-NEXT:    [[BOT_CAST:%.*]] = zext i32 [[BOT]] to i64
; AGGRESSIVE-NEXT:    [[TOP_SHUFFLE:%.*]] = shufflevector <2 x i16> [[TOP]], <2 x i16> zeroinitializer, <4 x i32> <i32 2, i32 2, i32 0, i32 1>
; AGGRESSIVE-NEXT:    [[TOP_SHUFFLE_CAST:%.*]] = bitcast <4 x i16> [[TOP_SHUFFLE]] to i64
; AGGRESSIVE-NEXT:    [[OUT_1_MERGE:%.*]] = or disjoint i64 [[BOT_CAST]], [[TOP_SHUFFLE_CAST]]
; AGGRESSIVE-NEXT:    ret i64 [[OUT_1_MERGE]]
;
  %base = zext i32 %bot to i64

  %mask.0 = extractelement <2 x i16> %top, i64 0
  %zext.0 = zext i16 %mask.0 to i64
  %get.0 = shl i64 %zext.0, 32
  %out.0 = or i64 %base, %get.0

  %mask.1 = extractelement <2 x i16> %top, i64 1
  %zext.1 = zext i16 %mask.1 to i64
  %get.1 = shl i64 %zext.1, 48
  %out.1 = or i64 %out.0, %get.1

  ret i64 %out.1
}

define i32 @extract_bigelt.0(<4 x i64> %src) {
; LAZY-LABEL: define i32 @extract_bigelt.0(
; LAZY-SAME: <4 x i64> [[SRC:%.*]]) {
; LAZY-NEXT:    [[SRC_0:%.*]] = extractelement <4 x i64> [[SRC]], i64 3
; LAZY-NEXT:    [[TRUNC:%.*]] = trunc i64 [[SRC_0]] to i32
; LAZY-NEXT:    ret i32 [[TRUNC]]
;
; AGGRESSIVE-LABEL: define i32 @extract_bigelt.0(
; AGGRESSIVE-SAME: <4 x i64> [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_CAST:%.*]] = bitcast <4 x i64> [[SRC]] to <8 x i32>
; AGGRESSIVE-NEXT:    [[SRC_EXTRACT:%.*]] = extractelement <8 x i32> [[SRC_CAST]], i32 6
; AGGRESSIVE-NEXT:    ret i32 [[SRC_EXTRACT]]
;
  %src.0 = extractelement <4 x i64> %src, i64 3
  %trunc = trunc i64 %src.0 to i32
  ret i32 %trunc
}

define i32 @extract_bigelt.1(<4 x i64> %src) {
; LAZY-LABEL: define i32 @extract_bigelt.1(
; LAZY-SAME: <4 x i64> [[SRC:%.*]]) {
; LAZY-NEXT:    [[SRC_0:%.*]] = extractelement <4 x i64> [[SRC]], i64 3
; LAZY-NEXT:    [[SHR:%.*]] = lshr i64 [[SRC_0]], 32
; LAZY-NEXT:    [[TRUNC:%.*]] = trunc i64 [[SHR]] to i32
; LAZY-NEXT:    ret i32 [[TRUNC]]
;
; AGGRESSIVE-LABEL: define i32 @extract_bigelt.1(
; AGGRESSIVE-SAME: <4 x i64> [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_CAST:%.*]] = bitcast <4 x i64> [[SRC]] to <8 x i32>
; AGGRESSIVE-NEXT:    [[SRC_EXTRACT:%.*]] = extractelement <8 x i32> [[SRC_CAST]], i32 7
; AGGRESSIVE-NEXT:    ret i32 [[SRC_EXTRACT]]
;
  %src.0 = extractelement <4 x i64> %src, i64 3
  %shr = lshr i64 %src.0, 32
  %trunc = trunc i64 %shr to i32
  ret i32 %trunc
}

;; Nothing happens because the shift amount is too small.
define i32 @extract_bigelt.2(<4 x i64> %src) {
; LAZY-LABEL: define i32 @extract_bigelt.2(
; LAZY-SAME: <4 x i64> [[SRC:%.*]]) {
; LAZY-NEXT:    [[SRC_0:%.*]] = extractelement <4 x i64> [[SRC]], i64 3
; LAZY-NEXT:    [[SHR:%.*]] = lshr i64 [[SRC_0]], 16
; LAZY-NEXT:    [[TRUNC:%.*]] = trunc i64 [[SHR]] to i32
; LAZY-NEXT:    ret i32 [[TRUNC]]
;
; AGGRESSIVE-LABEL: define i32 @extract_bigelt.2(
; AGGRESSIVE-SAME: <4 x i64> [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_0:%.*]] = extractelement <4 x i64> [[SRC]], i64 3
; AGGRESSIVE-NEXT:    [[SHR:%.*]] = lshr i64 [[SRC_0]], 16
; AGGRESSIVE-NEXT:    [[TRUNC:%.*]] = trunc i64 [[SHR]] to i32
; AGGRESSIVE-NEXT:    ret i32 [[TRUNC]]
;
  %src.0 = extractelement <4 x i64> %src, i64 3
  %shr = lshr i64 %src.0, 16
  %trunc = trunc i64 %shr to i32
  ret i32 %trunc
}

;; u0x0000ff00 = 65280
;; u0x00ff0000 = 16711680
;; u0xff0000ff = -16776961
define i32 @shuffle_elts(<4 x i8> %vec) {
; LAZY-LABEL: define i32 @shuffle_elts(
; LAZY-SAME: <4 x i8> [[VEC:%.*]]) {
; LAZY-NEXT:    [[VEC_0:%.*]] = extractelement <4 x i8> [[VEC]], i32 0
; LAZY-NEXT:    [[VEC_1:%.*]] = extractelement <4 x i8> [[VEC]], i32 1
; LAZY-NEXT:    [[VEC_2:%.*]] = extractelement <4 x i8> [[VEC]], i32 2
; LAZY-NEXT:    [[VEC_3:%.*]] = extractelement <4 x i8> [[VEC]], i32 3
; LAZY-NEXT:    [[ZEXT_0:%.*]] = zext i8 [[VEC_0]] to i32
; LAZY-NEXT:    [[ZEXT_1:%.*]] = zext i8 [[VEC_1]] to i32
; LAZY-NEXT:    [[SHL_1:%.*]] = shl i32 [[ZEXT_1]], 16
; LAZY-NEXT:    [[OUT_1:%.*]] = or i32 [[ZEXT_0]], [[SHL_1]]
; LAZY-NEXT:    [[ZEXT_2:%.*]] = zext i8 [[VEC_2]] to i32
; LAZY-NEXT:    [[SHL_2:%.*]] = shl i32 [[ZEXT_2]], 8
; LAZY-NEXT:    [[ZEXT_3:%.*]] = zext i8 [[VEC_3]] to i32
; LAZY-NEXT:    [[SHL_3:%.*]] = shl i32 [[ZEXT_3]], 24
; LAZY-NEXT:    [[OUT_2:%.*]] = or i32 [[SHL_2]], [[SHL_3]]
; LAZY-NEXT:    [[OUT:%.*]] = or i32 [[OUT_1]], [[OUT_2]]
; LAZY-NEXT:    ret i32 [[OUT]]
;
; AGGRESSIVE-LABEL: define i32 @shuffle_elts(
; AGGRESSIVE-SAME: <4 x i8> [[VEC:%.*]]) {
; AGGRESSIVE-NEXT:    [[VEC_CAST:%.*]] = bitcast <4 x i8> [[VEC]] to i32
; AGGRESSIVE-NEXT:    [[VEC_MASK:%.*]] = and i32 [[VEC_CAST]], -16776961
; AGGRESSIVE-NEXT:    [[VEC_SHIFT:%.*]] = lshr i32 [[VEC_CAST]], 8
; AGGRESSIVE-NEXT:    [[VEC_MASK2:%.*]] = and i32 [[VEC_SHIFT]], 65280
; AGGRESSIVE-NEXT:    [[VEC_SHIFT4:%.*]] = shl i32 [[VEC_CAST]], 8
; AGGRESSIVE-NEXT:    [[VEC_MASK6:%.*]] = and i32 [[VEC_SHIFT4]], 16711680
; AGGRESSIVE-NEXT:    [[OUT_MERGE:%.*]] = or disjoint i32 [[VEC_MASK]], [[VEC_MASK2]]
; AGGRESSIVE-NEXT:    [[OUT_MERGE8:%.*]] = or disjoint i32 [[OUT_MERGE]], [[VEC_MASK6]]
; AGGRESSIVE-NEXT:    ret i32 [[OUT_MERGE8]]
;
  %vec.0 = extractelement <4 x i8> %vec, i32 0
  %vec.1 = extractelement <4 x i8> %vec, i32 1
  %vec.2 = extractelement <4 x i8> %vec, i32 2
  %vec.3 = extractelement <4 x i8> %vec, i32 3

  %zext.0 = zext i8 %vec.0 to i32

  %zext.1 = zext i8 %vec.1 to i32
  %shl.1 = shl i32 %zext.1, 16
  %out.1 = or i32 %zext.0, %shl.1

  %zext.2 = zext i8 %vec.2 to i32
  %shl.2 = shl i32 %zext.2, 8

  %zext.3 = zext i8 %vec.3 to i32
  %shl.3 = shl i32 %zext.3, 24
  %out.2 = or i32 %shl.2, %shl.3

  %out = or i32 %out.1, %out.2

  ret i32 %out
}
