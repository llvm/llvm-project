; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=packedintcombine %s | FileCheck %s --check-prefix=LAZY
; RUN: opt -S -passes=packedintcombine -packedint-aggressive-rewriter %s | FileCheck %s --check-prefix=AGGRESSIVE

;; u0xff00ff00 = -16711936
;; u0x00ff00ff = 16711935
define i32 @add.0(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @add.0(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -16711936
; LAZY-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], 16711935
; LAZY-NEXT:    [[ADD:%.*]] = add i32 [[A_MASK]], [[B_MASK]]
; LAZY-NEXT:    ret i32 [[ADD]]
;
; AGGRESSIVE-LABEL: define i32 @add.0(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[B_MASK2:%.*]] = and i32 [[B]], 16711935
; AGGRESSIVE-NEXT:    [[A_MASK4:%.*]] = and i32 [[A]], -16711936
; AGGRESSIVE-NEXT:    [[ADD_MERGE:%.*]] = or disjoint i32 [[B_MASK2]], [[A_MASK4]]
; AGGRESSIVE-NEXT:    ret i32 [[ADD_MERGE]]
;
  %a.mask = and i32 %a, u0xff00ff00
  %b.mask = and i32 %b, u0x00ff00ff
  %add = add i32 %a.mask, %b.mask
  ret i32 %add
}

;; u0xff00ffff = -16711681
;; u0x00ff00ff = 16711935
;; Nothing happens in this case because of the overlapping bytes.
define i32 @add.1(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @add.1(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -16711681
; LAZY-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], 16711935
; LAZY-NEXT:    [[ADD:%.*]] = add i32 [[A_MASK]], [[B_MASK]]
; LAZY-NEXT:    ret i32 [[ADD]]
;
; AGGRESSIVE-LABEL: define i32 @add.1(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[A_MASK2:%.*]] = and i32 [[A]], -16711681
; AGGRESSIVE-NEXT:    [[B_MASK4:%.*]] = and i32 [[B]], 16711935
; AGGRESSIVE-NEXT:    [[ADD:%.*]] = add i32 [[A_MASK2]], [[B_MASK4]]
; AGGRESSIVE-NEXT:    ret i32 [[ADD]]
;
  %a.mask = and i32 %a, u0xff00ffff
  %b.mask = and i32 %b, u0x00ff00ff
  %add = add i32 %a.mask, %b.mask
  ret i32 %add
}

define i32 @and.0(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @and.0(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    ret i32 0
;
; AGGRESSIVE-LABEL: define i32 @and.0(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    ret i32 0
;
  %a.mask = and i32 %a, u0xff00ff00
  %b.mask = and i32 %b, u0x00ff00ff
  %and = and i32 %a.mask, %b.mask
  ret i32 %and
}

;; u0xff00ff00 = -16711936
;; u0x00ff00ff = 16711935
define i32 @and.1(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @and.1(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -16711681
; LAZY-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], 16711935
; LAZY-NEXT:    [[AND:%.*]] = and i32 [[A_MASK]], [[B_MASK]]
; LAZY-NEXT:    ret i32 [[AND]]
;
; AGGRESSIVE-LABEL: define i32 @and.1(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[A_MASK2:%.*]] = and i32 [[A]], -16711681
; AGGRESSIVE-NEXT:    [[B_MASK4:%.*]] = and i32 [[B]], 16711935
; AGGRESSIVE-NEXT:    [[AND:%.*]] = and i32 [[A_MASK2]], [[B_MASK4]]
; AGGRESSIVE-NEXT:    ret i32 [[AND]]
;
  %a.mask = and i32 %a, u0xff00ffff
  %b.mask = and i32 %b, u0x00ff00ff
  %and = and i32 %a.mask, %b.mask
  ret i32 %and
}

define i32 @and.2(i32 %x) {
; LAZY-LABEL: define i32 @and.2(
; LAZY-SAME: i32 [[X:%.*]]) {
; LAZY-NEXT:    [[X_0:%.*]] = and i32 [[X]], -16711681
; LAZY-NEXT:    [[X_1:%.*]] = and i32 [[X]], 16711935
; LAZY-NEXT:    [[AND:%.*]] = and i32 [[X_0]], [[X_1]]
; LAZY-NEXT:    ret i32 [[AND]]
;
; AGGRESSIVE-LABEL: define i32 @and.2(
; AGGRESSIVE-SAME: i32 [[X:%.*]]) {
; AGGRESSIVE-NEXT:    [[X_MASK:%.*]] = and i32 [[X]], 255
; AGGRESSIVE-NEXT:    ret i32 [[X_MASK]]
;
  %x.0 = and i32 %x, u0xff00ffff
  %x.1 = and i32 %x, u0x00ff00ff
  %and = and i32 %x.0, %x.1
  ret i32 %and
}

;; u0xff00ff00 = -16711936
;; u0x00ff00ff = 16711935
define i32 @or.0(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @or.0(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -16711936
; LAZY-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], 16711935
; LAZY-NEXT:    [[OR:%.*]] = or i32 [[A_MASK]], [[B_MASK]]
; LAZY-NEXT:    ret i32 [[OR]]
;
; AGGRESSIVE-LABEL: define i32 @or.0(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[B_MASK2:%.*]] = and i32 [[B]], 16711935
; AGGRESSIVE-NEXT:    [[A_MASK4:%.*]] = and i32 [[A]], -16711936
; AGGRESSIVE-NEXT:    [[OR_MERGE:%.*]] = or disjoint i32 [[B_MASK2]], [[A_MASK4]]
; AGGRESSIVE-NEXT:    ret i32 [[OR_MERGE]]
;
  %a.mask = and i32 %a, u0xff00ff00
  %b.mask = and i32 %b, u0x00ff00ff
  %or = or i32 %a.mask, %b.mask
  ret i32 %or
}

;; u0xff00ffff = -16711681
;; u0x00ff00ff = 16711935
;; Nothing happens in this case because of the overlapping bytes.
define i32 @or.1(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @or.1(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -16711681
; LAZY-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], 16711935
; LAZY-NEXT:    [[OR:%.*]] = or i32 [[A_MASK]], [[B_MASK]]
; LAZY-NEXT:    ret i32 [[OR]]
;
; AGGRESSIVE-LABEL: define i32 @or.1(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[A_MASK2:%.*]] = and i32 [[A]], -16711681
; AGGRESSIVE-NEXT:    [[B_MASK4:%.*]] = and i32 [[B]], 16711935
; AGGRESSIVE-NEXT:    [[OR:%.*]] = or i32 [[A_MASK2]], [[B_MASK4]]
; AGGRESSIVE-NEXT:    ret i32 [[OR]]
;
  %a.mask = and i32 %a, u0xff00ffff
  %b.mask = and i32 %b, u0x00ff00ff
  %or = or i32 %a.mask, %b.mask
  ret i32 %or
}

define i32 @or.2(i32 %x) {
; LAZY-LABEL: define i32 @or.2(
; LAZY-SAME: i32 [[X:%.*]]) {
; LAZY-NEXT:    ret i32 [[X]]
;
; AGGRESSIVE-LABEL: define i32 @or.2(
; AGGRESSIVE-SAME: i32 [[X:%.*]]) {
; AGGRESSIVE-NEXT:    ret i32 [[X]]
;
  %x.0 = and i32 %x, u0xff00ffff
  %x.1 = and i32 %x, u0x00ff00ff
  %or = or i32 %x.0, %x.1
  ret i32 %or
}

;; u0xff00ff00 = -16711936
;; u0x00ff00ff = 16711935
define i32 @or.3(i32 %x) {
; LAZY-LABEL: define i32 @or.3(
; LAZY-SAME: i32 [[X:%.*]]) {
; LAZY-NEXT:    [[X_0:%.*]] = or i32 [[X]], 16711935
; LAZY-NEXT:    ret i32 [[X_0]]
;
; AGGRESSIVE-LABEL: define i32 @or.3(
; AGGRESSIVE-SAME: i32 [[X:%.*]]) {
; AGGRESSIVE-NEXT:    [[X_MASK:%.*]] = and i32 [[X]], -16711936
; AGGRESSIVE-NEXT:    [[X_0_MERGE:%.*]] = or disjoint i32 [[X_MASK]], 16711935
; AGGRESSIVE-NEXT:    ret i32 [[X_0_MERGE]]
;
  %x.0 = or i32 %x, u0x00ff00ff
  ret i32 %x.0
}

;; u0xff00ff00 = -16711936
;; u0x00ff00ff = 16711935
define i32 @xor.0(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @xor.0(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -16711936
; LAZY-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], 16711935
; LAZY-NEXT:    [[XOR:%.*]] = xor i32 [[A_MASK]], [[B_MASK]]
; LAZY-NEXT:    ret i32 [[XOR]]
;
; AGGRESSIVE-LABEL: define i32 @xor.0(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[B_MASK2:%.*]] = and i32 [[B]], 16711935
; AGGRESSIVE-NEXT:    [[A_MASK4:%.*]] = and i32 [[A]], -16711936
; AGGRESSIVE-NEXT:    [[XOR_MERGE:%.*]] = or disjoint i32 [[B_MASK2]], [[A_MASK4]]
; AGGRESSIVE-NEXT:    ret i32 [[XOR_MERGE]]
;
  %a.mask = and i32 %a, u0xff00ff00
  %b.mask = and i32 %b, u0x00ff00ff
  %xor = xor i32 %a.mask, %b.mask
  ret i32 %xor
}

;; u0xff00ffff = -16711681
;; u0x00ff00ff = 16711935
;; Nothing happens in this case because of the overlapping bytes.
define i32 @xor.1(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @xor.1(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -16711681
; LAZY-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], 16711935
; LAZY-NEXT:    [[XOR:%.*]] = xor i32 [[A_MASK]], [[B_MASK]]
; LAZY-NEXT:    ret i32 [[XOR]]
;
; AGGRESSIVE-LABEL: define i32 @xor.1(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[A_MASK2:%.*]] = and i32 [[A]], -16711681
; AGGRESSIVE-NEXT:    [[B_MASK4:%.*]] = and i32 [[B]], 16711935
; AGGRESSIVE-NEXT:    [[XOR:%.*]] = xor i32 [[A_MASK2]], [[B_MASK4]]
; AGGRESSIVE-NEXT:    ret i32 [[XOR]]
;
  %a.mask = and i32 %a, u0xff00ffff
  %b.mask = and i32 %b, u0x00ff00ff
  %xor = xor i32 %a.mask, %b.mask
  ret i32 %xor
}

define i32 @xor.2(i32 %x) {
; LAZY-LABEL: define i32 @xor.2(
; LAZY-SAME: i32 [[X:%.*]]) {
; LAZY-NEXT:    [[X_MASK:%.*]] = and i32 [[X]], -256
; LAZY-NEXT:    ret i32 [[X_MASK]]
;
; AGGRESSIVE-LABEL: define i32 @xor.2(
; AGGRESSIVE-SAME: i32 [[X:%.*]]) {
; AGGRESSIVE-NEXT:    [[X_MASK:%.*]] = and i32 [[X]], -256
; AGGRESSIVE-NEXT:    ret i32 [[X_MASK]]
;
  %x.0 = and i32 %x, u0xff00ffff
  %x.1 = and i32 %x, u0x00ff00ff
  %xor = xor i32 %x.0, %x.1
  ret i32 %xor
}

define i32 @shl.0(i32 %base) {
; LAZY-LABEL: define i32 @shl.0(
; LAZY-SAME: i32 [[BASE:%.*]]) {
; LAZY-NEXT:    [[PRE:%.*]] = and i32 [[BASE]], 16777215
; LAZY-NEXT:    [[SHL:%.*]] = shl i32 [[PRE]], 8
; LAZY-NEXT:    [[POST:%.*]] = and i32 [[SHL]], -256
; LAZY-NEXT:    ret i32 [[POST]]
;
; AGGRESSIVE-LABEL: define i32 @shl.0(
; AGGRESSIVE-SAME: i32 [[BASE:%.*]]) {
; AGGRESSIVE-NEXT:    [[BASE_SHIFT:%.*]] = shl i32 [[BASE]], 8
; AGGRESSIVE-NEXT:    ret i32 [[BASE_SHIFT]]
;
  %pre = and i32 %base, u0x00ffffff
  %shl = shl i32 %pre, 8
  %post = and i32 %shl, u0xffffff00
  ret i32 %post
}

;; u0x0000ff00 = 65280
define i32 @shl.1(i32 %base) {
; LAZY-LABEL: define i32 @shl.1(
; LAZY-SAME: i32 [[BASE:%.*]]) {
; LAZY-NEXT:    [[PRE:%.*]] = and i32 [[BASE]], -16711936
; LAZY-NEXT:    [[SHL:%.*]] = shl i32 [[PRE]], 8
; LAZY-NEXT:    ret i32 [[SHL]]
;
; AGGRESSIVE-LABEL: define i32 @shl.1(
; AGGRESSIVE-SAME: i32 [[BASE:%.*]]) {
; AGGRESSIVE-NEXT:    [[BASE_MASK:%.*]] = and i32 [[BASE]], 65280
; AGGRESSIVE-NEXT:    [[BASE_SHIFT:%.*]] = shl i32 [[BASE_MASK]], 8
; AGGRESSIVE-NEXT:    ret i32 [[BASE_SHIFT]]
;
  %pre = and i32 %base, u0xff00ff00
  %shl = shl i32 %pre, 8
  ret i32 %shl
}

;; u0x0fffffff = 268435455
;; Nothing happens because it is not byte-aligned.
define i32 @shl.2(i32 %base) {
; LAZY-LABEL: define i32 @shl.2(
; LAZY-SAME: i32 [[BASE:%.*]]) {
; LAZY-NEXT:    [[PRE:%.*]] = and i32 [[BASE]], 268435455
; LAZY-NEXT:    [[SHL:%.*]] = shl i32 [[PRE]], 4
; LAZY-NEXT:    [[POST:%.*]] = and i32 [[SHL]], -16
; LAZY-NEXT:    ret i32 [[POST]]
;
; AGGRESSIVE-LABEL: define i32 @shl.2(
; AGGRESSIVE-SAME: i32 [[BASE:%.*]]) {
; AGGRESSIVE-NEXT:    [[PRE:%.*]] = and i32 [[BASE]], 268435455
; AGGRESSIVE-NEXT:    [[SHL:%.*]] = shl i32 [[PRE]], 4
; AGGRESSIVE-NEXT:    [[POST:%.*]] = and i32 [[SHL]], -16
; AGGRESSIVE-NEXT:    ret i32 [[POST]]
;
  %pre = and i32 %base, u0x0fffffff
  %shl = shl i32 %pre, 4
  %post = and i32 %shl, u0xfffffff0
  ret i32 %post
}

define <8 x i8> @shl.vec(<2 x i32> %base) {
; LAZY-LABEL: define <8 x i8> @shl.vec(
; LAZY-SAME: <2 x i32> [[BASE:%.*]]) {
; LAZY-NEXT:    [[PRE:%.*]] = and <2 x i32> [[BASE]], <i32 -65281, i32 16777215>
; LAZY-NEXT:    [[SHL:%.*]] = shl <2 x i32> [[PRE]], <i32 16, i32 8>
; LAZY-NEXT:    [[POST:%.*]] = and <2 x i32> [[SHL]], splat (i32 -256)
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <2 x i32> [[POST]] to <8 x i8>
; LAZY-NEXT:    ret <8 x i8> [[CAST]]
;
; AGGRESSIVE-LABEL: define <8 x i8> @shl.vec(
; AGGRESSIVE-SAME: <2 x i32> [[BASE:%.*]]) {
; AGGRESSIVE-NEXT:    [[BASE_CAST:%.*]] = bitcast <2 x i32> [[BASE]] to <8 x i8>
; AGGRESSIVE-NEXT:    [[BASE_SHUFFLE:%.*]] = shufflevector <8 x i8> [[BASE_CAST]], <8 x i8> zeroinitializer, <8 x i32> <i32 8, i32 9, i32 0, i32 11, i32 12, i32 13, i32 14, i32 15>
; AGGRESSIVE-NEXT:    [[BASE_SHUFFLE2:%.*]] = shufflevector <8 x i8> [[BASE_CAST]], <8 x i8> [[BASE_SHUFFLE]], <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 4, i32 5, i32 6>
; AGGRESSIVE-NEXT:    ret <8 x i8> [[BASE_SHUFFLE2]]
;
  %pre = and <2 x i32> %base, <i32 u0xffff00ff, i32 u0x00ffffff>
  %shl = shl <2 x i32> %pre, <i32 16, i32 8>
  %post = and <2 x i32> %shl, splat(i32 u0xffffff00)
  %cast = bitcast <2 x i32> %post to <8 x i8>
  ret <8 x i8> %cast
}

define i32 @lshr.0(i32 %base) {
; LAZY-LABEL: define i32 @lshr.0(
; LAZY-SAME: i32 [[BASE:%.*]]) {
; LAZY-NEXT:    [[PRE:%.*]] = and i32 [[BASE]], -256
; LAZY-NEXT:    [[LSHR:%.*]] = lshr i32 [[PRE]], 8
; LAZY-NEXT:    [[POST:%.*]] = and i32 [[LSHR]], 16777215
; LAZY-NEXT:    ret i32 [[POST]]
;
; AGGRESSIVE-LABEL: define i32 @lshr.0(
; AGGRESSIVE-SAME: i32 [[BASE:%.*]]) {
; AGGRESSIVE-NEXT:    [[BASE_SHIFT:%.*]] = lshr i32 [[BASE]], 8
; AGGRESSIVE-NEXT:    ret i32 [[BASE_SHIFT]]
;
  %pre = and i32 %base, u0xffffff00
  %lshr = lshr i32 %pre, 8
  %post = and i32 %lshr, u0x00ffffff
  ret i32 %post
}

;; u0x0000ff00 = 65280
define i32 @lshr.1(i32 %base) {
; LAZY-LABEL: define i32 @lshr.1(
; LAZY-SAME: i32 [[BASE:%.*]]) {
; LAZY-NEXT:    [[PRE:%.*]] = and i32 [[BASE]], 16711935
; LAZY-NEXT:    [[LSHR:%.*]] = lshr i32 [[PRE]], 8
; LAZY-NEXT:    ret i32 [[LSHR]]
;
; AGGRESSIVE-LABEL: define i32 @lshr.1(
; AGGRESSIVE-SAME: i32 [[BASE:%.*]]) {
; AGGRESSIVE-NEXT:    [[BASE_SHIFT:%.*]] = lshr i32 [[BASE]], 8
; AGGRESSIVE-NEXT:    [[BASE_MASK:%.*]] = and i32 [[BASE_SHIFT]], 65280
; AGGRESSIVE-NEXT:    ret i32 [[BASE_MASK]]
;
  %pre = and i32 %base, u0x00ff00ff
  %lshr = lshr i32 %pre, 8
  ret i32 %lshr
}

define <8 x i8> @lshr.vec(<2 x i32> %base) {
; LAZY-LABEL: define <8 x i8> @lshr.vec(
; LAZY-SAME: <2 x i32> [[BASE:%.*]]) {
; LAZY-NEXT:    [[PRE:%.*]] = and <2 x i32> [[BASE]], <i32 -16711681, i32 -256>
; LAZY-NEXT:    [[LSHR:%.*]] = lshr <2 x i32> [[PRE]], <i32 16, i32 8>
; LAZY-NEXT:    [[POST:%.*]] = and <2 x i32> [[LSHR]], splat (i32 16777215)
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <2 x i32> [[POST]] to <8 x i8>
; LAZY-NEXT:    ret <8 x i8> [[CAST]]
;
; AGGRESSIVE-LABEL: define <8 x i8> @lshr.vec(
; AGGRESSIVE-SAME: <2 x i32> [[BASE:%.*]]) {
; AGGRESSIVE-NEXT:    [[BASE_CAST:%.*]] = bitcast <2 x i32> [[BASE]] to <8 x i8>
; AGGRESSIVE-NEXT:    [[BASE_SHUFFLE:%.*]] = shufflevector <8 x i8> [[BASE_CAST]], <8 x i8> zeroinitializer, <8 x i32> <i32 8, i32 3, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; AGGRESSIVE-NEXT:    [[BASE_SHUFFLE2:%.*]] = shufflevector <8 x i8> [[BASE_CAST]], <8 x i8> [[BASE_SHUFFLE]], <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 5, i32 6, i32 7, i32 15>
; AGGRESSIVE-NEXT:    ret <8 x i8> [[BASE_SHUFFLE2]]
;
  %pre = and <2 x i32> %base, <i32 u0xff00ffff, i32 u0xffffff00>
  %lshr = lshr <2 x i32> %pre, <i32 16, i32 8>
  %post = and <2 x i32> %lshr, splat(i32 u0x00ffffff)
  %cast = bitcast <2 x i32> %post to <8 x i8>
  ret <8 x i8> %cast
}

define i32 @trunc.0(i64 %src) {
; LAZY-LABEL: define i32 @trunc.0(
; LAZY-SAME: i64 [[SRC:%.*]]) {
; LAZY-NEXT:    [[MASK:%.*]] = and i64 [[SRC]], 4294967295
; LAZY-NEXT:    [[TRUNC:%.*]] = trunc i64 [[MASK]] to i32
; LAZY-NEXT:    ret i32 [[TRUNC]]
;
; AGGRESSIVE-LABEL: define i32 @trunc.0(
; AGGRESSIVE-SAME: i64 [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_CAST:%.*]] = trunc i64 [[SRC]] to i32
; AGGRESSIVE-NEXT:    ret i32 [[SRC_CAST]]
;
  %mask = and i64 %src, u0x00000000ffffffff
  %trunc = trunc i64 %mask to i32
  ret i32 %trunc
}

;; u0xff00ff00 = -16711936
define i32 @trunc.1(i64 %src) {
; LAZY-LABEL: define i32 @trunc.1(
; LAZY-SAME: i64 [[SRC:%.*]]) {
; LAZY-NEXT:    [[MASK:%.*]] = and i64 [[SRC]], -71777214294589696
; LAZY-NEXT:    [[TRUNC:%.*]] = trunc i64 [[MASK]] to i32
; LAZY-NEXT:    ret i32 [[TRUNC]]
;
; AGGRESSIVE-LABEL: define i32 @trunc.1(
; AGGRESSIVE-SAME: i64 [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_CAST:%.*]] = trunc i64 [[SRC]] to i32
; AGGRESSIVE-NEXT:    [[SRC_MASK:%.*]] = and i32 [[SRC_CAST]], -16711936
; AGGRESSIVE-NEXT:    ret i32 [[SRC_MASK]]
;
  %mask = and i64 %src, u0xff00ff00ff00ff00
  %trunc = trunc i64 %mask to i32
  ret i32 %trunc
}

define <4 x i8> @trunc.vec(<2 x i32> %src) {
; LAZY-LABEL: define <4 x i8> @trunc.vec(
; LAZY-SAME: <2 x i32> [[SRC:%.*]]) {
; LAZY-NEXT:    [[TRUNC:%.*]] = trunc <2 x i32> [[SRC]] to <2 x i16>
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <2 x i16> [[TRUNC]] to <4 x i8>
; LAZY-NEXT:    ret <4 x i8> [[CAST]]
;
; AGGRESSIVE-LABEL: define <4 x i8> @trunc.vec(
; AGGRESSIVE-SAME: <2 x i32> [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_CAST:%.*]] = bitcast <2 x i32> [[SRC]] to <8 x i8>
; AGGRESSIVE-NEXT:    [[SRC_EXTRACT:%.*]] = shufflevector <8 x i8> [[SRC_CAST]], <8 x i8> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
; AGGRESSIVE-NEXT:    [[SRC_SHUFFLE:%.*]] = shufflevector <4 x i8> [[SRC_EXTRACT]], <4 x i8> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
; AGGRESSIVE-NEXT:    [[SRC_EXTRACT2:%.*]] = shufflevector <8 x i8> [[SRC_CAST]], <8 x i8> poison, <4 x i32> <i32 poison, i32 poison, i32 4, i32 5>
; AGGRESSIVE-NEXT:    [[SRC_SHUFFLE4:%.*]] = shufflevector <4 x i8> [[SRC_EXTRACT2]], <4 x i8> [[SRC_SHUFFLE]], <4 x i32> <i32 4, i32 5, i32 2, i32 3>
; AGGRESSIVE-NEXT:    ret <4 x i8> [[SRC_SHUFFLE4]]
;
  %trunc = trunc <2 x i32> %src to <2 x i16>
  %cast = bitcast <2 x i16> %trunc to <4 x i8>
  ret <4 x i8> %cast
}

define i32 @bitcast.0(i32 %x) {
; LAZY-LABEL: define i32 @bitcast.0(
; LAZY-SAME: i32 [[X:%.*]]) {
; LAZY-NEXT:    [[CAST:%.*]] = bitcast i32 [[X]] to <4 x i8>
; LAZY-NEXT:    [[BACK:%.*]] = bitcast <4 x i8> [[CAST]] to i32
; LAZY-NEXT:    ret i32 [[BACK]]
;
; AGGRESSIVE-LABEL: define i32 @bitcast.0(
; AGGRESSIVE-SAME: i32 [[X:%.*]]) {
; AGGRESSIVE-NEXT:    ret i32 [[X]]
;
  %cast = bitcast i32 %x to <4 x i8>
  %back = bitcast <4 x i8> %cast to i32
  ret i32 %back
}

define i8 @extractelement.0(i32 %src) {
; LAZY-LABEL: define i8 @extractelement.0(
; LAZY-SAME: i32 [[SRC:%.*]]) {
; LAZY-NEXT:    [[CAST:%.*]] = bitcast i32 [[SRC]] to <4 x i8>
; LAZY-NEXT:    [[ELT:%.*]] = extractelement <4 x i8> [[CAST]], i64 3
; LAZY-NEXT:    ret i8 [[ELT]]
;
; AGGRESSIVE-LABEL: define i8 @extractelement.0(
; AGGRESSIVE-SAME: i32 [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_SHIFT:%.*]] = lshr i32 [[SRC]], 24
; AGGRESSIVE-NEXT:    [[SRC_SHIFT_CAST:%.*]] = trunc i32 [[SRC_SHIFT]] to i8
; AGGRESSIVE-NEXT:    ret i8 [[SRC_SHIFT_CAST]]
;
  %cast = bitcast i32 %src to <4 x i8>
  %elt = extractelement <4 x i8> %cast, i64 3
  ret i8 %elt
}

define i32 @insertelement.0(i8 %src) {
; LAZY-LABEL: define i32 @insertelement.0(
; LAZY-SAME: i8 [[SRC:%.*]]) {
; LAZY-NEXT:    [[INSERT:%.*]] = insertelement <4 x i8> zeroinitializer, i8 [[SRC]], i64 3
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <4 x i8> [[INSERT]] to i32
; LAZY-NEXT:    ret i32 [[CAST]]
;
; AGGRESSIVE-LABEL: define i32 @insertelement.0(
; AGGRESSIVE-SAME: i8 [[SRC:%.*]]) {
; AGGRESSIVE-NEXT:    [[SRC_CAST:%.*]] = zext i8 [[SRC]] to i32
; AGGRESSIVE-NEXT:    [[SRC_SHIFT:%.*]] = shl i32 [[SRC_CAST]], 24
; AGGRESSIVE-NEXT:    ret i32 [[SRC_SHIFT]]
;
  %insert = insertelement <4 x i8> zeroinitializer, i8 %src, i64 3
  %cast = bitcast <4 x i8> %insert to i32
  ret i32 %cast
}

define i32 @insertelement.1(i8 %a, i8 %b) {
; LAZY-LABEL: define i32 @insertelement.1(
; LAZY-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; LAZY-NEXT:    [[INSERT_A:%.*]] = insertelement <4 x i8> zeroinitializer, i8 [[A]], i64 3
; LAZY-NEXT:    [[INSERT_B:%.*]] = insertelement <4 x i8> [[INSERT_A]], i8 [[B]], i64 1
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <4 x i8> [[INSERT_B]] to i32
; LAZY-NEXT:    ret i32 [[CAST]]
;
; AGGRESSIVE-LABEL: define i32 @insertelement.1(
; AGGRESSIVE-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[A_CAST:%.*]] = zext i8 [[A]] to i32
; AGGRESSIVE-NEXT:    [[B_CAST:%.*]] = zext i8 [[B]] to i32
; AGGRESSIVE-NEXT:    [[B_SHIFT:%.*]] = shl i32 [[B_CAST]], 8
; AGGRESSIVE-NEXT:    [[A_SHIFT:%.*]] = shl i32 [[A_CAST]], 24
; AGGRESSIVE-NEXT:    [[CAST_MERGE:%.*]] = or disjoint i32 [[B_SHIFT]], [[A_SHIFT]]
; AGGRESSIVE-NEXT:    ret i32 [[CAST_MERGE]]
;
  %insert.a = insertelement <4 x i8> zeroinitializer, i8 %a, i64 3
  %insert.b = insertelement <4 x i8> %insert.a, i8 %b, i64 1
  %cast = bitcast <4 x i8> %insert.b to i32
  ret i32 %cast
}

define i64 @shufflevector.0(i32 %a, i32 %b) {
; LAZY-LABEL: define i64 @shufflevector.0(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_CAST:%.*]] = bitcast i32 [[A]] to <4 x i8>
; LAZY-NEXT:    [[B_CAST:%.*]] = bitcast i32 [[B]] to <4 x i8>
; LAZY-NEXT:    [[SHUFFLE:%.*]] = shufflevector <4 x i8> [[A_CAST]], <4 x i8> [[B_CAST]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <8 x i8> [[SHUFFLE]] to i64
; LAZY-NEXT:    ret i64 [[CAST]]
;
; AGGRESSIVE-LABEL: define i64 @shufflevector.0(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[B_CAST2:%.*]] = zext i32 [[B]] to i64
; AGGRESSIVE-NEXT:    [[A_CAST1:%.*]] = zext i32 [[A]] to i64
; AGGRESSIVE-NEXT:    [[B_SHIFT:%.*]] = shl i64 [[B_CAST2]], 32
; AGGRESSIVE-NEXT:    [[CAST_MERGE:%.*]] = or disjoint i64 [[A_CAST1]], [[B_SHIFT]]
; AGGRESSIVE-NEXT:    ret i64 [[CAST_MERGE]]
;
  %a.cast = bitcast i32 %a to <4 x i8>
  %b.cast = bitcast i32 %b to <4 x i8>
  %shuffle = shufflevector <4 x i8> %a.cast, <4 x i8> %b.cast, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  %cast = bitcast <8 x i8> %shuffle to i64
  ret i64 %cast
}

define i32 @shufflevector.1(i32 %a, i32 %b) {
; LAZY-LABEL: define i32 @shufflevector.1(
; LAZY-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; LAZY-NEXT:    [[A_CAST:%.*]] = bitcast i32 [[A]] to <4 x i8>
; LAZY-NEXT:    [[B_CAST:%.*]] = bitcast i32 [[B]] to <4 x i8>
; LAZY-NEXT:    [[SHUFFLE:%.*]] = shufflevector <4 x i8> [[A_CAST]], <4 x i8> [[B_CAST]], <4 x i32> <i32 0, i32 5, i32 2, i32 7>
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <4 x i8> [[SHUFFLE]] to i32
; LAZY-NEXT:    ret i32 [[CAST]]
;
; AGGRESSIVE-LABEL: define i32 @shufflevector.1(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], 16711935
; AGGRESSIVE-NEXT:    [[B_MASK:%.*]] = and i32 [[B]], -16711936
; AGGRESSIVE-NEXT:    [[CAST_MERGE:%.*]] = or disjoint i32 [[A_MASK]], [[B_MASK]]
; AGGRESSIVE-NEXT:    ret i32 [[CAST_MERGE]]
;
  %a.cast = bitcast i32 %a to <4 x i8>
  %b.cast = bitcast i32 %b to <4 x i8>
  %shuffle = shufflevector <4 x i8> %a.cast, <4 x i8> %b.cast, <4 x i32> <i32 0, i32 5, i32 2, i32 7>
  %cast = bitcast <4 x i8> %shuffle to i32
  ret i32 %cast
}

define i32 @shufflevector.2(i32 %a, i64 %b) {
; LAZY-LABEL: define i32 @shufflevector.2(
; LAZY-SAME: i32 [[A:%.*]], i64 [[B:%.*]]) {
; LAZY-NEXT:    [[A_CAST:%.*]] = bitcast i32 [[A]] to <4 x i8>
; LAZY-NEXT:    [[B_CAST:%.*]] = bitcast i64 [[B]] to <8 x i8>
; LAZY-NEXT:    [[SHUFFLE_0:%.*]] = shufflevector <8 x i8> [[B_CAST]], <8 x i8> poison, <4 x i32> <i32 6, i32 7, i32 poison, i32 poison>
; LAZY-NEXT:    [[SHUFFLE_1:%.*]] = shufflevector <4 x i8> [[SHUFFLE_0]], <4 x i8> [[A_CAST]], <4 x i32> <i32 0, i32 1, i32 6, i32 7>
; LAZY-NEXT:    [[CAST:%.*]] = bitcast <4 x i8> [[SHUFFLE_1]] to i32
; LAZY-NEXT:    ret i32 [[CAST]]
;
; AGGRESSIVE-LABEL: define i32 @shufflevector.2(
; AGGRESSIVE-SAME: i32 [[A:%.*]], i64 [[B:%.*]]) {
; AGGRESSIVE-NEXT:    [[B_SHIFT:%.*]] = lshr i64 [[B]], 48
; AGGRESSIVE-NEXT:    [[B_SHIFT_CAST:%.*]] = trunc i64 [[B_SHIFT]] to i32
; AGGRESSIVE-NEXT:    [[A_MASK:%.*]] = and i32 [[A]], -65536
; AGGRESSIVE-NEXT:    [[CAST_MERGE:%.*]] = or disjoint i32 [[B_SHIFT_CAST]], [[A_MASK]]
; AGGRESSIVE-NEXT:    ret i32 [[CAST_MERGE]]
;
  %a.cast = bitcast i32 %a to <4 x i8>
  %b.cast = bitcast i64 %b to <8 x i8>
  %shuffle.0 = shufflevector <8 x i8> %b.cast, <8 x i8> poison, <4 x i32> <i32 6, i32 7, i32 poison, i32 poison>
  %shuffle.1 = shufflevector <4 x i8> %shuffle.0, <4 x i8> %a.cast, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
  %cast = bitcast <4 x i8> %shuffle.1 to i32
  ret i32 %cast
}
