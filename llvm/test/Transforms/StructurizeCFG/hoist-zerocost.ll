; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=structurizecfg < %s | FileCheck %s


%pair = type { i32, i32 }
define void @test_if_then_else(ptr %ptr, i1 %cond) {
; CHECK-LABEL: define void @test_if_then_else(
; CHECK-SAME: ptr [[PTR:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[COND_INV:%.*]] = xor i1 [[COND]], true
; CHECK-NEXT:    [[LOAD_THEN:%.*]] = load [[PAIR:%.*]], ptr [[PTR]], align 4
; CHECK-NEXT:    [[A_THEN:%.*]] = extractvalue [[PAIR]] [[LOAD_THEN]], 0
; CHECK-NEXT:    br i1 [[COND_INV]], label %[[ELSE:.*]], label %[[FLOW:.*]]
; CHECK:       [[FLOW]]:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i32 [ [[SUM_ELSE:%.*]], %[[ELSE]] ], [ [[A_THEN]], %[[ENTRY]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = phi i1 [ false, %[[ELSE]] ], [ true, %[[ENTRY]] ]
; CHECK-NEXT:    br i1 [[TMP1]], label %[[THEN:.*]], label %[[MERGE:.*]]
; CHECK:       [[THEN]]:
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[ELSE]]:
; CHECK-NEXT:    [[A_ELSE:%.*]] = extractvalue [[PAIR]] [[LOAD_THEN]], 0
; CHECK-NEXT:    [[SUM_ELSE]] = add i32 [[A_ELSE]], 1
; CHECK-NEXT:    br label %[[FLOW]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[PTR]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %load_then = load %pair, ptr %ptr
  br i1 %cond, label %then, label %else

then:
  %a_then = extractvalue %pair %load_then, 0
  br label %merge

else:
  %a_else = extractvalue %pair %load_then, 0
  %sum_else = add i32 %a_else, 1
  br label %merge

merge:
  %phi = phi i32  [ %a_then, %then ], [ %sum_else, %else ]
  store i32 %phi, ptr  %ptr
  ret void
}

define void @test_if_else_then(ptr %ptr, i1 %cond) {
; CHECK-LABEL: define void @test_if_else_then(
; CHECK-SAME: ptr [[PTR:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[COND_INV:%.*]] = xor i1 [[COND]], true
; CHECK-NEXT:    [[LOAD_THEN:%.*]] = load [[PAIR:%.*]], ptr [[PTR]], align 4
; CHECK-NEXT:    br i1 [[COND_INV]], label %[[THEN:.*]], label %[[FLOW:.*]]
; CHECK:       [[THEN]]:
; CHECK-NEXT:    [[A_THEN:%.*]] = extractvalue [[PAIR]] [[LOAD_THEN]], 0
; CHECK-NEXT:    br label %[[FLOW]]
; CHECK:       [[FLOW]]:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i32 [ [[A_THEN]], %[[THEN]] ], [ poison, %[[ENTRY]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = phi i1 [ false, %[[THEN]] ], [ true, %[[ENTRY]] ]
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ELSE:.*]], label %[[MERGE:.*]]
; CHECK:       [[ELSE]]:
; CHECK-NEXT:    [[A_ELSE:%.*]] = extractvalue [[PAIR]] [[LOAD_THEN]], 0
; CHECK-NEXT:    [[SUM_ELSE:%.*]] = add i32 [[A_ELSE]], 1
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[TMP0]], %[[FLOW]] ], [ [[SUM_ELSE]], %[[ELSE]] ]
; CHECK-NEXT:    store i32 [[PHI]], ptr [[PTR]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %load_then = load %pair, ptr %ptr
  br i1 %cond, label %else, label %then

then:
  %a_then = extractvalue %pair %load_then, 0
  br label %merge

else:
  %a_else = extractvalue %pair %load_then, 0
  %sum_else = add i32 %a_else, 1
  br label %merge

merge:
  %phi = phi i32  [ %a_then, %then ], [ %sum_else, %else ]
  store i32 %phi, ptr  %ptr
  ret void
}

define amdgpu_kernel void @test_loop_with_if( ptr %ptr, i1 %cond) #0 {
; CHECK-LABEL: define amdgpu_kernel void @test_loop_with_if(
; CHECK-SAME: ptr [[PTR:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[COND_INV:%.*]] = xor i1 [[COND]], true
; CHECK-NEXT:    [[I:%.*]] = tail call i32 @llvm.amdgcn.workitem.id.x()
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I15:%.*]], %[[LATCH:.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load [[PAIR:%.*]], ptr [[PTR]], align 4
; CHECK-NEXT:    [[A_THEN:%.*]] = extractvalue [[PAIR]] [[LOAD]], 0
; CHECK-NEXT:    br i1 [[COND]], label %[[IF:.*]], label %[[FLOW:.*]]
; CHECK:       [[IF]]:
; CHECK-NEXT:    [[I9:%.*]] = icmp sle i32 [[I3]], 10
; CHECK-NEXT:    br label %[[FLOW]]
; CHECK:       [[FLOW1:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i32 [ [[Y:%.*]], %[[ELSE:.*]] ], [ [[A_THEN]], %[[FLOW]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = phi i1 [ false, %[[ELSE]] ], [ [[TMP2:%.*]], %[[FLOW]] ]
; CHECK-NEXT:    br i1 [[TMP1]], label %[[THEN:.*]], label %[[LATCH]]
; CHECK:       [[THEN]]:
; CHECK-NEXT:    store i32 [[I]], ptr [[PTR]], align 4
; CHECK-NEXT:    br label %[[LATCH]]
; CHECK:       [[FLOW]]:
; CHECK-NEXT:    [[TMP2]] = phi i1 [ true, %[[IF]] ], [ false, %[[LOOP]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = phi i1 [ [[I9]], %[[IF]] ], [ [[COND_INV]], %[[LOOP]] ]
; CHECK-NEXT:    br i1 [[TMP3]], label %[[ELSE]], label %[[FLOW1]]
; CHECK:       [[ELSE]]:
; CHECK-NEXT:    [[I2:%.*]] = extractvalue [[PAIR]] [[LOAD]], 1
; CHECK-NEXT:    [[A_ELSE:%.*]] = extractvalue [[PAIR]] [[LOAD]], 0
; CHECK-NEXT:    [[Y]] = add i32 [[A_ELSE]], [[I2]]
; CHECK-NEXT:    br label %[[FLOW1]]
; CHECK:       [[LATCH]]:
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[PTR]], align 4
; CHECK-NEXT:    [[I15]] = add nsw i32 [[TMP0]], 20
; CHECK-NEXT:    [[I16:%.*]] = icmp sge i32 [[I15]], 255
; CHECK-NEXT:    br i1 [[I16]], label %[[END:.*]], label %[[LOOP]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret void
;
entry:
  %a = tail call i32 @llvm.amdgcn.workitem.id.x()
  br label %loop

loop:
  %entry_phi = phi i32 [ 0, %entry ], [ %a15, %latch ]
  %load = load %pair, ptr %ptr
  br i1 %cond, label %if, label %else

if:
  %cmp = icmp sgt i32 %entry_phi, 10
  br i1 %cmp, label %then, label %else

then:
  %a_then = extractvalue %pair %load, 0
  store i32 %a, ptr %ptr, align 4
  br label %latch

else:
  %a2 = extractvalue %pair %load, 1
  %y = extractvalue %pair %load, 0
  %a_else = add i32 %y, %a2
  br label %latch

latch:
  %a_test = phi i32 [ %a_then, %then ], [ %a_else, %else ]
  store i32 %a_test, ptr  %ptr
  %a15 = add nsw i32 %a_test, 20
  %a16 = icmp slt i32  %a15, 255
  br i1 %a16, label %loop, label %end

end:
  ret void
}

define void @test_nested_if(ptr %ptr, i32 %val, i1 %cond) {
; CHECK-LABEL: define void @test_nested_if(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[VAL:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[COND_INV:%.*]] = xor i1 [[COND]], true
; CHECK-NEXT:    [[LOAD_THEN:%.*]] = load [[PAIR:%.*]], ptr [[PTR]], align 4
; CHECK-NEXT:    [[A_ELSE:%.*]] = extractvalue [[PAIR]] [[LOAD_THEN]], 0
; CHECK-NEXT:    br i1 [[COND_INV]], label %[[THEN:.*]], label %[[FLOW:.*]]
; CHECK:       [[THEN]]:
; CHECK-NEXT:    [[A16:%.*]] = icmp slt i32 [[VAL]], 255
; CHECK-NEXT:    br i1 [[COND_INV]], label %[[THEN_2:.*]], label %[[FLOW1:.*]]
; CHECK:       [[FLOW]]:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i32 [ [[TMP2:%.*]], %[[FLOW1]] ], [ poison, %[[ENTRY]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = phi i1 [ [[TMP3:%.*]], %[[FLOW1]] ], [ [[COND]], %[[ENTRY]] ]
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ELSE:.*]], label %[[MERGE:.*]]
; CHECK:       [[THEN_2]]:
; CHECK-NEXT:    [[LOADED:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    br label %[[FLOW1]]
; CHECK:       [[FLOW1]]:
; CHECK-NEXT:    [[TMP2]] = phi i32 [ [[LOADED]], %[[THEN_2]] ], [ [[A_ELSE]], %[[THEN]] ]
; CHECK-NEXT:    [[TMP3]] = phi i1 [ false, %[[THEN_2]] ], [ true, %[[THEN]] ]
; CHECK-NEXT:    br label %[[FLOW]]
; CHECK:       [[ELSE]]:
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[PTR]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %load_then = load %pair, ptr %ptr
  br i1 %cond, label %else, label %then

then:
  %a16 = icmp slt i32  %val, 255
  br i1 %cond, label %else, label %then_2

then_2:
  %loaded = load i32, ptr  %ptr
  br label %merge

else:
  %a_else = extractvalue %pair %load_then, 0
  br label %merge

merge:
  %phi = phi i32  [ %loaded, %then_2 ], [ %a_else, %else ]
  store i32 %phi, ptr  %ptr
  ret void
}
