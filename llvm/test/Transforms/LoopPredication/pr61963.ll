; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -S -passes=loop-predication < %s 2>&1 | FileCheck %s

; Do not convert branch in loop_outer block on the widenable_cond11 to a
; loop-varying one.
; It will result in a miscompile.
; deopt9 will have incorrect deopt state (it currently uses init_val because
; indvars identified that if that exit is taken, it will be taken on first
; iteration, since widenable_cond11 is a loop-invariant condition).
define i32 @foo(ptr addrspace(1) %arg) {
; CHECK-LABEL: define i32 @foo
; CHECK-SAME: (ptr addrspace(1) [[ARG:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[INIT_VAL:%.*]] = load i32, ptr addrspace(1) [[ARG]], align 4
; CHECK-NEXT:    br label [[LOOP_OUTER:%.*]]
; CHECK:       loop_outer:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[PHI36:%.*]], [[OUTER_LOOP_LATCH:%.*]] ], [ 42, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[PHI21:%.*]] = phi i32 [ [[ADD39:%.*]], [[OUTER_LOOP_LATCH]] ], [ [[INIT_VAL]], [[ENTRY]] ]
; CHECK-NEXT:    [[ADD27:%.*]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[ICMP28:%.*]] = icmp eq i32 [[ADD27]], 60
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 -2, [[IV]]
; CHECK-NEXT:    [[UMIN:%.*]] = call i32 @llvm.umin.i32(i32 [[TMP0]], i32 8)
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ugt i32 [[TMP0]], [[UMIN]]
; CHECK-NEXT:    [[TMP2:%.*]] = freeze i1 [[TMP1]]
; CHECK-NEXT:    [[WIDENABLE_COND11:%.*]] = call i1 @llvm.experimental.widenable.condition()
; CHECK-NEXT:    [[TMP3:%.*]] = and i1 [[TMP2]], [[WIDENABLE_COND11]]
; CHECK-NEXT:    br i1 [[TMP3]], label [[INNER_LOOP_PH:%.*]], label [[DEOPT9:%.*]]
; CHECK:       inner_loop_ph:
; CHECK-NEXT:    store atomic i32 606, ptr addrspace(1) [[ARG]] unordered, align 4
; CHECK-NEXT:    br label [[INNER_LOOP:%.*]]
; CHECK:       inner_loop:
; CHECK-NEXT:    [[PHI43:%.*]] = phi i32 [ 1, [[INNER_LOOP_PH]] ], [ [[ADD55:%.*]], [[INNER_LOOP_LATCH:%.*]] ]
; CHECK-NEXT:    [[PHI44:%.*]] = phi i32 [ [[ADD27]], [[INNER_LOOP_PH]] ], [ [[ADD48:%.*]], [[INNER_LOOP_LATCH]] ]
; CHECK-NEXT:    [[ADD48]] = add i32 [[PHI44]], 1
; CHECK-NEXT:    [[ICMP49:%.*]] = icmp eq i32 [[ADD48]], 0
; CHECK-NEXT:    br i1 false, label [[DEOPT57:%.*]], label [[INNER_LOOP_LATCH]]
; CHECK:       inner_loop_latch:
; CHECK-NEXT:    store atomic i32 606, ptr addrspace(1) [[ARG]] unordered, align 4
; CHECK-NEXT:    [[ADD55]] = add nuw nsw i32 [[PHI43]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[ADD55]], 10
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[OUTER_LOOP_LATCH]], label [[INNER_LOOP]]
; CHECK:       outer_loop_latch:
; CHECK-NEXT:    [[PHI36]] = phi i32 [ [[ADD48]], [[INNER_LOOP_LATCH]] ]
; CHECK-NEXT:    [[ADD39]] = add i32 [[PHI21]], 1
; CHECK-NEXT:    br label [[LOOP_OUTER]]
; CHECK:       deopt9:
; CHECK-NEXT:    [[LCSSA:%.*]] = phi i32 [ [[INIT_VAL]], [[LOOP_OUTER]] ]
; CHECK-NEXT:    [[CALL53:%.*]] = call i32 (...) @llvm.experimental.deoptimize.i32(i32 13) [ "deopt"(i32 606, i32 [[LCSSA]]) ]
; CHECK-NEXT:    ret i32 [[CALL53]]
; CHECK:       deopt57:
; CHECK-NEXT:    [[CALL62:%.*]] = call i32 (...) @llvm.experimental.deoptimize.i32(i32 12) [ "deopt"(i32 7) ]
; CHECK-NEXT:    ret i32 [[CALL62]]
;
entry:
  %init_val = load i32, ptr addrspace(1) %arg, align 4
  %widenable_cond11 = call i1 @llvm.experimental.widenable.condition()
  br label %loop_outer

loop_outer:                                       ; preds = %outer_loop_latch, %entry
  %iv = phi i32 [ %phi36, %outer_loop_latch ], [ 42, %entry ]
  %phi21 = phi i32 [ %add39, %outer_loop_latch ], [ %init_val, %entry ]
  %add27 = add i32 %iv, 1
  %icmp28 = icmp eq i32 %add27, 60
  br i1 %widenable_cond11, label %inner_loop_ph, label %deopt9

inner_loop_ph:                                             ; preds = %loop_outer
  store atomic i32 606, ptr addrspace(1) %arg unordered, align 4
  br label %inner_loop

inner_loop:                                       ; preds = %inner_loop_latch, %inner_loop_ph
  %phi43 = phi i32 [ 1, %inner_loop_ph ], [ %add55, %inner_loop_latch ]
  %phi44 = phi i32 [ %add27, %inner_loop_ph ], [ %add48, %inner_loop_latch ]
  %add48 = add i32 %phi44, 1
  %icmp49 = icmp eq i32 %add48, 0
  br i1 %icmp49, label %deopt57, label %inner_loop_latch

inner_loop_latch:                                             ; preds = %inner_loop
  store atomic i32 606, ptr addrspace(1) %arg unordered, align 4
  %add55 = add nuw nsw i32 %phi43, 1
  %exitcond = icmp eq i32 %add55, 10
  br i1 %exitcond, label %outer_loop_latch, label %inner_loop

outer_loop_latch:                                             ; preds = %inner_loop_latch
  %phi36 = phi i32 [ %add48, %inner_loop_latch ]
  %add39 = add i32 %phi21, 1
  br label %loop_outer

deopt9:                                           ; preds = %loop_outer
  %lcssa = phi i32 [ %init_val, %loop_outer ]
  %call53 = call i32 (...) @llvm.experimental.deoptimize.i32(i32 13) [ "deopt"(i32 606, i32 %lcssa) ]
  ret i32 %call53

deopt57:                                             ; preds = %inner_loop
  %call62 = call i32 (...) @llvm.experimental.deoptimize.i32(i32 12) [ "deopt"(i32 7) ]
  ret i32 %call62
}

declare i32 @llvm.experimental.deoptimize.i32(...)

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(inaccessiblemem: readwrite)
declare noundef i1 @llvm.experimental.widenable.condition()
