; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='sroa,instcombine,lower-constant-intrinsics,dce' -S < %s | FileCheck --check-prefixes CHECK,CHECK-REF %s
; RUN: opt -passes=lower-constant-intrinsics,dce -S < %s | FileCheck --check-prefixes CHECK,CHECK-TST %s

; Some extra tests using 16-bit pointers and 16-bit index type size. This
; allows us to for example test what happens when the index type used in a
; getelementptr does not match with the index type size (e.g. when not running
; full opt pipeline before the lower-constant-intrinsics pass).

target datalayout = "e-p:16:16:16"


define i32 @possible_out_of_bounds_gep_i8(i1 %c0, i1 %c1) {
; CHECK-LABEL: define i32 @possible_out_of_bounds_gep_i8(
; CHECK-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 3, i32 0
; CHECK-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i8 2, i8 10
  %ptr.slide = getelementptr i8, ptr %obj, i8 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

define i32 @possible_out_of_bounds_gep_i16(i1 %c0, i1 %c1) {
; CHECK-LABEL: define i32 @possible_out_of_bounds_gep_i16(
; CHECK-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 3, i32 0
; CHECK-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i16 2, i16 10
  %ptr.slide = getelementptr i8, ptr %obj, i16 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

define i32 @possible_out_of_bounds_gep_i32(i1 %c0, i1 %c1) {
; CHECK-LABEL: define i32 @possible_out_of_bounds_gep_i32(
; CHECK-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 3, i32 0
; CHECK-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i32 2, i32 10
  %ptr.slide = getelementptr i8, ptr %obj, i32 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

; SROA would produce IR like this if applied to @possible_out_of_bounds_gep_i16.
; FIXME: The %objsize_min result here looks wrong.
define i32 @possible_out_of_bounds_gep_i16_sroa(i1 %c0, i1 %c1) {
; CHECK-REF-LABEL: define i32 @possible_out_of_bounds_gep_i16_sroa(
; CHECK-REF-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-REF-NEXT:  [[ENTRY:.*:]]
; CHECK-REF-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 3, i32 0
; CHECK-REF-NEXT:    ret i32 [[RES]]
;
; CHECK-TST-LABEL: define i32 @possible_out_of_bounds_gep_i16_sroa(
; CHECK-TST-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-TST-NEXT:  [[ENTRY:.*:]]
; CHECK-TST-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 3, i32 65531
; CHECK-TST-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8], align 1
  %.sroa.gep = getelementptr i8, ptr %obj, i16 2
  %.sroa.gep1 = getelementptr i8, ptr %obj, i16 10
  %offset.sroa.sel = select i1 %c0, ptr %.sroa.gep, ptr %.sroa.gep1
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %offset.sroa.sel, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %offset.sroa.sel, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

; Indices are truncated to the pointer size in a gep. So "i32 -65526" should
; be truncated to "i16 10".
; FIXME: The TST result here is incorrect!
define i32 @possible_out_of_bounds_gep_i32_trunc(i1 %c0, i1 %c1) {
; CHECK-REF-LABEL: define i32 @possible_out_of_bounds_gep_i32_trunc(
; CHECK-REF-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-REF-NEXT:  [[ENTRY:.*:]]
; CHECK-REF-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 3, i32 0
; CHECK-REF-NEXT:    ret i32 [[RES]]
;
; CHECK-TST-LABEL: define i32 @possible_out_of_bounds_gep_i32_trunc(
; CHECK-TST-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-TST-NEXT:  [[ENTRY:.*:]]
; CHECK-TST-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 0, i32 3
; CHECK-TST-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i32 2, i32 -65526  ; 0xffff000a
  %ptr.slide = getelementptr i8, ptr %obj, i32 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

define i32 @out_of_bounds_gep_i8(i1 %c0, i1 %c1) {
; CHECK-REF-LABEL: define i32 @out_of_bounds_gep_i8(
; CHECK-REF-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-REF-NEXT:  [[ENTRY:.*:]]
; CHECK-REF-NEXT:    [[RES:%.*]] = sext i1 [[C1]] to i32
; CHECK-REF-NEXT:    ret i32 [[RES]]
;
; CHECK-TST-LABEL: define i32 @out_of_bounds_gep_i8(
; CHECK-TST-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-TST-NEXT:  [[ENTRY:.*:]]
; CHECK-TST-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 -1, i32 0
; CHECK-TST-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %ptr.slide = getelementptr i8, ptr %obj, i8 -128
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

define i32 @out_of_bounds_gep_i32(i1 %c0, i1 %c1) {
; CHECK-LABEL: define i32 @out_of_bounds_gep_i32(
; CHECK-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 0
;
entry:
  %obj = alloca [5 x i8]
  %ptr.slide = getelementptr i8, ptr %obj, i32 10
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

define i32 @out_of_bounds_gep_i32_trunc(i1 %c0, i1 %c1) {
; CHECK-LABEL: define i32 @out_of_bounds_gep_i32_trunc(
; CHECK-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 0
;
entry:
  %obj = alloca [5 x i8]
  %ptr.slide = getelementptr i8, ptr %obj, i32 -65526
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

; In this test the index will be out-of-bounds, but the current analysis won't
; detect that. The analysis will find out that %offset is in the range [-2,
; 10] which includes valid offsets that aren't out-of-bounds. Therefore we can
; expect the result -1 for %objsize_max.
define i32 @out_of_bounds_gep_i16_pos_neg(i1 %c0, i1 %c1) {
; CHECK-REF-LABEL: define i32 @out_of_bounds_gep_i16_pos_neg(
; CHECK-REF-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-REF-NEXT:  [[ENTRY:.*:]]
; CHECK-REF-NEXT:    [[RES:%.*]] = sext i1 [[C1]] to i32
; CHECK-REF-NEXT:    ret i32 [[RES]]
;
; CHECK-TST-LABEL: define i32 @out_of_bounds_gep_i16_pos_neg(
; CHECK-TST-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-TST-NEXT:  [[ENTRY:.*:]]
; CHECK-TST-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 -1, i32 0
; CHECK-TST-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i32 10, i32 -2
  %ptr.slide = getelementptr i8, ptr %obj, i32 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

; With 16-bit index size %offset is either 32767 or -32768. Thus, when
; aggregating the possible offsets it we know that it is in the range [-32768,
; 32767], which includes valid offsets that aren't out-of-bounds. This is
; similar to the out_of_bounds_gep_i16_pos_neg test above, and we can expect
; the result -1 for %objsize_max.
define i32 @out_of_bounds_gep_i32_trunc_select(i1 %c0, i1 %c1) {
; CHECK-REF-LABEL: define i32 @out_of_bounds_gep_i32_trunc_select(
; CHECK-REF-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-REF-NEXT:  [[ENTRY:.*:]]
; CHECK-REF-NEXT:    [[RES:%.*]] = sext i1 [[C1]] to i32
; CHECK-REF-NEXT:    ret i32 [[RES]]
;
; CHECK-TST-LABEL: define i32 @out_of_bounds_gep_i32_trunc_select(
; CHECK-TST-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-TST-NEXT:  [[ENTRY:.*:]]
; CHECK-TST-NEXT:    ret i32 0
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i32 32767, i32 32768
  %ptr.slide = getelementptr i8, ptr %obj, i32 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

; FIXME: Is 3 really correct for %objsize_min here?
define i32 @possible_out_of_bounds_gep_i8_neg(i1 %c0, i1 %c1) {
; CHECK-LABEL: define i32 @possible_out_of_bounds_gep_i8_neg(
; CHECK-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 -1, i32 3
; CHECK-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i8 2, i8 -10
  %ptr.slide = getelementptr i8, ptr %obj, i8 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}

; FIXME: Is 3 really correct for %objsize_min here?
define i32 @possible_out_of_bounds_gep_i16_neg(i1 %c0, i1 %c1) {
; CHECK-LABEL: define i32 @possible_out_of_bounds_gep_i16_neg(
; CHECK-SAME: i1 [[C0:%.*]], i1 [[C1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RES:%.*]] = select i1 [[C1]], i32 -1, i32 3
; CHECK-NEXT:    ret i32 [[RES]]
;
entry:
  %obj = alloca [5 x i8]
  %offset = select i1 %c0, i16 2, i16 -10
  %ptr.slide = getelementptr i8, ptr %obj, i16 %offset
  %objsize_max = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 false, i1 true, i1 false)
  %objsize_min = call i32 @llvm.objectsize.i32.p0(ptr %ptr.slide, i1 true, i1 true, i1 false)
  %res = select i1 %c1, i32 %objsize_max, i32 %objsize_min
  ret i32 %res
}
