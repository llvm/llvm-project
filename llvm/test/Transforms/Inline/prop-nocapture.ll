; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -passes=inline -S < %s | FileCheck --check-prefixes=CHECK,NO_ASSUME %s
; RUN: opt -passes=inline -S --enable-knowledge-retention < %s | FileCheck %s --check-prefixes=CHECK,USE_ASSUME

declare void @void.call.p0(ptr)
declare void @void.call.p0.p1(ptr, ptr)
declare i32 @ret.call.p0(ptr)
declare ptr @retp.call.p0(ptr)

define void @simple_nocapture_prop(ptr captures(none) %p) {
; CHECK-LABEL: define {{[^@]+}}@simple_nocapture_prop
; CHECK-SAME: (ptr captures(none) [[P:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    ret void
;
  call void @void.call.p0(ptr %p)
  ret void
}

define void @simple_nocapture_prop_caller(ptr %p) {
; CHECK-LABEL: define {{[^@]+}}@simple_nocapture_prop_caller
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr captures(none) [[P]])
; CHECK-NEXT:    ret void
;
  call void @simple_nocapture_prop(ptr %p)
  ret void
}

define i32 @nocapture_with_return_prop(ptr captures(none) %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_with_return_prop
; CHECK-SAME: (ptr captures(none) [[P:%.*]]) {
; CHECK-NEXT:    [[R:%.*]] = call i32 @ret.call.p0(ptr [[P]])
; CHECK-NEXT:    ret i32 [[R]]
;
  %r = call i32 @ret.call.p0(ptr %p)
  ret i32 %r
}

define i32 @nocapture_with_return_prop_caller(ptr %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_with_return_prop_caller
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    [[R_I:%.*]] = call i32 @ret.call.p0(ptr captures(none) [[P]])
; CHECK-NEXT:    ret i32 [[R_I]]
;
  %r = call i32 @nocapture_with_return_prop(ptr %p)
  ret i32 %r
}

define i32 @nocapture_with_return_prop_todo_indirect(ptr captures(none) %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_with_return_prop_todo_indirect
; CHECK-SAME: (ptr captures(none) [[P:%.*]]) {
; CHECK-NEXT:    [[R:%.*]] = call i32 @ret.call.p0(ptr [[P]])
; CHECK-NEXT:    [[RR:%.*]] = xor i32 [[R]], -1
; CHECK-NEXT:    ret i32 [[RR]]
;
  %r = call i32 @ret.call.p0(ptr %p)
  %rr = xor i32 %r, -1
  ret i32 %rr
}

define i32 @nocapture_with_return_prop_todo_indirect_caller(ptr %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_with_return_prop_todo_indirect_caller
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    [[R_I:%.*]] = call i32 @ret.call.p0(ptr [[P]])
; CHECK-NEXT:    [[RR_I:%.*]] = xor i32 [[R_I]], -1
; CHECK-NEXT:    ret i32 [[RR_I]]
;
  %r = call i32 @nocapture_with_return_prop_todo_indirect(ptr %p)
  ret i32 %r
}

define i32 @nocapture_with_return_prop_fail_maybe_captures(ptr captures(none) %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_with_return_prop_fail_maybe_captures
; CHECK-SAME: (ptr captures(none) [[P:%.*]]) {
; CHECK-NEXT:    [[R:%.*]] = call ptr @void.call.p0(ptr [[P]])
; CHECK-NEXT:    [[RR:%.*]] = load i32, ptr [[R]], align 4
; CHECK-NEXT:    ret i32 [[RR]]
;
  %r = call ptr @void.call.p0(ptr %p)
  %rr = load i32, ptr %r
  ret i32 %rr
}

define i32 @nocapture_with_return_prop_fail_maybe_captures_caller(ptr %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_with_return_prop_fail_maybe_captures_caller
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    [[R_I:%.*]] = call ptr @void.call.p0(ptr [[P]])
; CHECK-NEXT:    [[RR_I:%.*]] = load i32, ptr [[R_I]], align 4
; CHECK-NEXT:    ret i32 [[RR_I]]
;
  %r = call i32 @nocapture_with_return_prop_fail_maybe_captures(ptr %p)
  ret i32 %r
}

define void @nocapture_prop_fail_preceding_alloca(ptr captures(none) %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_preceding_alloca
; CHECK-SAME: (ptr captures(none) [[P:%.*]]) {
; CHECK-NEXT:    [[P2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @void.call.p0.p1(ptr [[P]], ptr [[P2]])
; CHECK-NEXT:    ret void
;
  %p2 = alloca i32
  call void @void.call.p0.p1(ptr %p, ptr %p2)
  ret void
}

define void @nocapture_prop_fail_preceding_alloca_caller(ptr %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_preceding_alloca_caller
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    [[P2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @nocapture_prop_fail_preceding_alloca(ptr [[P]], ptr [[P2]])
; CHECK-NEXT:    ret void
;
  %p2 = alloca i32
  call void @nocapture_prop_fail_preceding_alloca(ptr %p, ptr %p2)
  ret void
}

define void @nocapture_prop_fail_preceding_alloca2(ptr captures(none) %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_preceding_alloca2
; CHECK-SAME: (ptr captures(none) [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    [[P2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    call void @void.call.p0(ptr [[P2]])
; CHECK-NEXT:    ret void
; CHECK:       F:
; CHECK-NEXT:    call void @void.call.p0.p1(ptr [[P]], ptr [[P2]])
; CHECK-NEXT:    ret void
;
  %p2 = alloca i32
  br i1 %c, label %T, label %F
T:
  call void @void.call.p0(ptr %p2)
  ret void
F:
  call void @void.call.p0.p1(ptr %p, ptr %p2)
  ret void
}

define void @nocapture_prop_fail_preceding_alloca2_caller(ptr %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_preceding_alloca2_caller
; CHECK-SAME: (ptr [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    [[P2_I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[P2_I]])
; CHECK-NEXT:    br i1 [[C]], label [[T_I:%.*]], label [[F_I:%.*]]
; CHECK:       T.i:
; CHECK-NEXT:    call void @void.call.p0(ptr [[P2_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[P2_I]])
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_FAIL_PRECEDING_ALLOCA2_EXIT:%.*]]
; CHECK:       F.i:
; CHECK-NEXT:    call void @void.call.p0.p1(ptr [[P]], ptr [[P2_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[P2_I]])
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_FAIL_PRECEDING_ALLOCA2_EXIT]]
; CHECK:       nocapture_prop_fail_preceding_alloca2.exit:
; CHECK-NEXT:    ret void
;
  call void @nocapture_prop_fail_preceding_alloca2(ptr %p, i1 %c)
  ret void
}

define void @nocapture_prop_okay_seperate_alloca(ptr captures(none) %p, i1 %c) alwaysinline {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_okay_seperate_alloca
; CHECK-SAME: (ptr captures(none) [[P:%.*]], i1 [[C:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    [[P2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @void.call.p0(ptr [[P2]])
; CHECK-NEXT:    ret void
; CHECK:       F:
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    ret void
;
  br i1 %c, label %T, label %F
T:
  %p2 = alloca i32
  call void @void.call.p0(ptr %p2)
  ret void
F:
  call void @void.call.p0(ptr %p)
  ret void
}

define void @nocapture_prop_okay_seperate_alloca_caller(ptr %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_okay_seperate_alloca_caller
; CHECK-SAME: (ptr [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    [[SAVEDSTACK:%.*]] = call ptr @llvm.stacksave.p0()
; CHECK-NEXT:    br i1 [[C]], label [[T_I:%.*]], label [[F_I:%.*]]
; CHECK:       T.i:
; CHECK-NEXT:    [[P2_I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @void.call.p0(ptr [[P2_I]])
; CHECK-NEXT:    call void @llvm.stackrestore.p0(ptr [[SAVEDSTACK]])
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_OKAY_SEPERATE_ALLOCA_EXIT:%.*]]
; CHECK:       F.i:
; CHECK-NEXT:    call void @void.call.p0(ptr captures(none) [[P]])
; CHECK-NEXT:    call void @llvm.stackrestore.p0(ptr [[SAVEDSTACK]])
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_OKAY_SEPERATE_ALLOCA_EXIT]]
; CHECK:       nocapture_prop_okay_seperate_alloca.exit:
; CHECK-NEXT:    ret void
;
  call void @nocapture_prop_okay_seperate_alloca(ptr %p, i1 %c)
  ret void
}

define void @nocapture_prop_fail_ensuing_side_effects(ptr captures(none) %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_ensuing_side_effects
; CHECK-SAME: (ptr captures(none) [[P:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    ret void
;
  call void @void.call.p0(ptr %p)
  call void @void.call.p0(ptr %p)
  ret void
}

define void @nocapture_prop_fail_ensuing_side_effects_caller(ptr %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_ensuing_side_effects_caller
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    ret void
;
  call void @nocapture_prop_fail_ensuing_side_effects(ptr %p)
  ret void
}

define void @nocapture_prop_fail_ensuing_side_effects2(ptr captures(none) %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_ensuing_side_effects2
; CHECK-SAME: (ptr captures(none) [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    ret void
; CHECK:       F:
; CHECK-NEXT:    ret void
;
  call void @void.call.p0(ptr %p)
  br i1 %c, label %T, label %F
T:
  call void @void.call.p0(ptr %p)
  ret void
F:
  ret void
}

define void @nocapture_prop_fail_ensuing_side_effects2_caller(ptr %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_fail_ensuing_side_effects2_caller
; CHECK-SAME: (ptr [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    br i1 [[C]], label [[T_I:%.*]], label [[F_I:%.*]]
; CHECK:       T.i:
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_FAIL_ENSUING_SIDE_EFFECTS2_EXIT:%.*]]
; CHECK:       F.i:
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_FAIL_ENSUING_SIDE_EFFECTS2_EXIT]]
; CHECK:       nocapture_prop_fail_ensuing_side_effects2.exit:
; CHECK-NEXT:    ret void
;
  call void @nocapture_prop_fail_ensuing_side_effects2(ptr %p, i1 %c)
  ret void
}

define i32 @nocapture_prop_okay_no_sideeffects(ptr captures(none) %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_okay_no_sideeffects
; CHECK-SAME: (ptr captures(none) [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    br i1 [[C]], label [[T:%.*]], label [[F:%.*]]
; CHECK:       T:
; CHECK-NEXT:    [[R:%.*]] = call i32 @ret.call.p0(ptr [[P]]) #[[ATTR3:[0-9]+]]
; CHECK-NEXT:    ret i32 [[R]]
; CHECK:       F:
; CHECK-NEXT:    ret i32 0
;
  call void @void.call.p0(ptr %p)
  br i1 %c, label %T, label %F
T:
  %r = call i32 @ret.call.p0(ptr %p) nounwind readonly willreturn
  ret i32 %r
F:
  ret i32 0
}

define i32 @nocapture_prop_okay_no_sideeffects_caller(ptr %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_okay_no_sideeffects_caller
; CHECK-SAME: (ptr [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr captures(none) [[P]])
; CHECK-NEXT:    br i1 [[C]], label [[T_I:%.*]], label [[F_I:%.*]]
; CHECK:       T.i:
; CHECK-NEXT:    [[R_I:%.*]] = call i32 @ret.call.p0(ptr captures(none) [[P]]) #[[ATTR3]]
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_OKAY_NO_SIDEEFFECTS_EXIT:%.*]]
; CHECK:       F.i:
; CHECK-NEXT:    br label [[NOCAPTURE_PROP_OKAY_NO_SIDEEFFECTS_EXIT]]
; CHECK:       nocapture_prop_okay_no_sideeffects.exit:
; CHECK-NEXT:    [[R1:%.*]] = phi i32 [ [[R_I]], [[T_I]] ], [ 0, [[F_I]] ]
; CHECK-NEXT:    ret i32 [[R1]]
;
  %r = call i32 @nocapture_prop_okay_no_sideeffects(ptr %p, i1 %c)
  ret i32 %r
}

define i32 @nocapture_prop_okay_no_sideeffects2(ptr captures(none) %p) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_okay_no_sideeffects2
; CHECK-SAME: (ptr captures(none) [[P:%.*]]) {
; CHECK-NEXT:    call void @void.call.p0(ptr [[P]])
; CHECK-NEXT:    [[R:%.*]] = call i32 @ret.call.p0(ptr [[P]]) #[[ATTR3]]
; CHECK-NEXT:    ret i32 [[R]]
;
  call void @void.call.p0(ptr %p)
  %r = call i32 @ret.call.p0(ptr %p) nounwind readonly willreturn
  ret i32 %r
}

define i32 @nocapture_prop_okay_no_sideeffects2_caller(ptr %p, i1 %c) {
; CHECK-LABEL: define {{[^@]+}}@nocapture_prop_okay_no_sideeffects2_caller
; CHECK-SAME: (ptr [[P:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:    [[R:%.*]] = call i32 @nocapture_prop_okay_no_sideeffects2(ptr [[P]], i1 [[C]])
; CHECK-NEXT:    ret i32 [[R]]
;
  %r = call i32 @nocapture_prop_okay_no_sideeffects2(ptr %p, i1 %c)
  ret i32 %r
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; NO_ASSUME: {{.*}}
; USE_ASSUME: {{.*}}
