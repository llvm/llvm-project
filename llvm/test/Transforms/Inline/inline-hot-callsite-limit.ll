; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; This tests that a hot callsite gets the (higher) inlinehint-threshold even without
; without inline hints and gets inlined because the cost is less than
; RUN: opt < %s -passes=inline -inline-threshold=0 -locally-hot-callsite-threshold=30 -S | FileCheck %s
; RUN: opt < %s -passes=module-inline -inline-threshold=0 -locally-hot-callsite-threshold=30 -S | FileCheck %s

; Due to the hot call site, foo0 inlined foo1, foo2, and foo3,
; but foo4 is not inlined due to the accumulated cost.

declare void @bar(ptr)

define void @foo0(ptr %p) {
; CHECK-LABEL: define void @foo0(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[HEADER:.*:]]
; CHECK-NEXT:    [[I_I2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I_I1:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I_I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I_I]])
; CHECK-NEXT:    call void @bar(ptr [[I_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I_I1]])
; CHECK-NEXT:    call void @bar(ptr [[I_I1]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr [[I_I2]])
; CHECK-NEXT:    call void @bar(ptr [[I_I2]])
; CHECK-NEXT:    call void @foo4(ptr [[P]]) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I_I2]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I_I1]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr [[I_I]])
; CHECK-NEXT:    br label %[[LOOP]]
;
header:
  br label %loop

loop:
  call void @foo1(ptr %p)
  br label %loop
}

define void @foo1(ptr %p) {
; CHECK-LABEL: define void @foo1(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @bar(ptr [[I]])
; CHECK-NEXT:    call void @foo2(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @bar(ptr %i)
  call void @foo2(ptr %p)
  ret void
}

define void @foo2(ptr %p) {
; CHECK-LABEL: define void @foo2(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @bar(ptr [[I]])
; CHECK-NEXT:    call void @foo3(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @bar(ptr %i)
  call void @foo3(ptr %p)
  ret void
}

define void @foo3(ptr %p) {
; CHECK-LABEL: define void @foo3(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @bar(ptr [[I]])
; CHECK-NEXT:    call void @foo4(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @bar(ptr %i)
  call void @foo4(ptr %p)
  ret void
}

define void @foo4(ptr %p) {
; CHECK-LABEL: define void @foo4(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @bar(ptr [[I]])
; CHECK-NEXT:    call void @foo5(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @bar(ptr %i)
  call void @foo5(ptr %p)
  ret void
}

define void @foo5(ptr %p) {
; CHECK-LABEL: define void @foo5(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @bar(ptr [[I]])
; CHECK-NEXT:    call void @bar(ptr [[I]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @bar(ptr %i)
  call void @bar(ptr %i)
  ret void
}
