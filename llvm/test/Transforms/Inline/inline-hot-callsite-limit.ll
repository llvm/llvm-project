; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals all --version 6
; RUN: opt < %s -passes=inline -inline-threshold=0 -locally-hot-callsite-threshold=30 -S | FileCheck %s
; RUN: opt < %s -passes=module-inline -inline-threshold=0 -locally-hot-callsite-threshold=30 -S | FileCheck %s

; Make sure that we do not inline an exponential number of calls.

declare void @callee0(ptr)

define void @caller(ptr %p) {
; CHECK-LABEL: define void @caller(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[HEADER:.*:]]
; CHECK-NEXT:    [[I_I2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I_I1:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I_I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[I_I]])
; CHECK-NEXT:    call void @callee0(ptr [[I_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[I_I1]])
; CHECK-NEXT:    call void @callee0(ptr [[I_I1]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[I_I2]])
; CHECK-NEXT:    call void @callee0(ptr [[I_I2]])
; CHECK-NEXT:    call void @callee4(ptr [[P]]) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[I_I2]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[I_I1]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[I_I]])
; CHECK-NEXT:    br label %[[LOOP]]
;
header:
  br label %loop

loop:
  call void @callee1(ptr %p)
  br label %loop
}

define void @callee1(ptr %p) {
; CHECK-LABEL: define void @callee1(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @callee0(ptr [[I]])
; CHECK-NEXT:    call void @callee2(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @callee0(ptr %i)
  call void @callee2(ptr %p)
  ret void
}

define void @callee2(ptr %p) {
; CHECK-LABEL: define void @callee2(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @callee0(ptr [[I]])
; CHECK-NEXT:    call void @callee3(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @callee0(ptr %i)
  call void @callee3(ptr %p)
  ret void
}

define void @callee3(ptr %p) {
; CHECK-LABEL: define void @callee3(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @callee0(ptr [[I]])
; CHECK-NEXT:    call void @callee4(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @callee0(ptr %i)
  call void @callee4(ptr %p)
  ret void
}

define void @callee4(ptr %p) {
; CHECK-LABEL: define void @callee4(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @callee0(ptr [[I]])
; CHECK-NEXT:    call void @callee5(ptr [[P]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @callee0(ptr %i)
  call void @callee5(ptr %p)
  ret void
}

define void @callee5(ptr %p) {
; CHECK-LABEL: define void @callee5(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @callee0(ptr [[I]])
; CHECK-NEXT:    call void @callee0(ptr [[I]])
; CHECK-NEXT:    ret void
;
  %i = alloca i32
  call void @callee0(ptr %i)
  call void @callee0(ptr %i)
  ret void
}
;.
; CHECK: attributes #[[ATTR0:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
; CHECK: attributes #[[ATTR1]] = { "function-inline-additional-cost"="6" }
;.
