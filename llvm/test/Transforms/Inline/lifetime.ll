; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -opaque-pointers=0 -passes=inline -S < %s | FileCheck %s
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"

declare void @llvm.lifetime.start.p0i8(i64, i8*)
declare void @llvm.lifetime.end.p0i8(i64, i8*)

define void @helper_both_markers() {
; CHECK-LABEL: define void @helper_both_markers() {
; CHECK-NEXT:    [[A:%.*]] = alloca i8, align 1
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 2, i8* [[A]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 2, i8* [[A]])
; CHECK-NEXT:    ret void
;
  %a = alloca i8
  ; Size in llvm.lifetime.start / llvm.lifetime.end differs from
  ; allocation size. We should use the former.
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %a)
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %a)
  ret void
}

define void @test_both_markers() {
; CHECK-LABEL: define void @test_both_markers() {
; CHECK-NEXT:    [[A_I1:%.*]] = alloca i8, align 1
; CHECK-NEXT:    [[A_I:%.*]] = alloca i8, align 1
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 2, i8* [[A_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 2, i8* [[A_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 2, i8* [[A_I1]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 2, i8* [[A_I1]])
; CHECK-NEXT:    ret void
;
  call void @helper_both_markers()
  call void @helper_both_markers()
  ret void
}

;; Without this, the inliner will simplify out @test_no_marker before adding
;; any lifetime markers.
declare void @use(i8* %a)

define void @helper_no_markers() {
; CHECK-LABEL: define void @helper_no_markers() {
; CHECK-NEXT:    [[A:%.*]] = alloca i8, align 1
; CHECK-NEXT:    call void @use(i8* [[A]])
; CHECK-NEXT:    ret void
;
  %a = alloca i8 ; Allocation size is 1 byte.
  call void @use(i8* %a)
  ret void
}

define void @test_no_marker() {
; CHECK-LABEL: define void @test_no_marker() {
; CHECK-NEXT:    [[A_I1:%.*]] = alloca i8, align 1
; CHECK-NEXT:    [[A_I:%.*]] = alloca i8, align 1
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 1, i8* [[A_I]])
; CHECK-NEXT:    call void @use(i8* [[A_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 1, i8* [[A_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 1, i8* [[A_I1]])
; CHECK-NEXT:    call void @use(i8* [[A_I1]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 1, i8* [[A_I1]])
; CHECK-NEXT:    ret void
;
  call void @helper_no_markers()
  call void @helper_no_markers()
  ret void
}

define void @helper_two_casts() {
; CHECK-LABEL: define void @helper_two_casts() {
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = bitcast i32* [[A]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 4, i8* [[B]])
; CHECK-NEXT:    [[C:%.*]] = bitcast i32* [[A]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 4, i8* [[C]])
; CHECK-NEXT:    ret void
;
  %a = alloca i32
  %b = bitcast i32* %a to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %b)
  %c = bitcast i32* %a to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %c)
  ret void
}

define void @test_two_casts() {
; CHECK-LABEL: define void @test_two_casts() {
; CHECK-NEXT:    [[A_I1:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[A_I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B_I:%.*]] = bitcast i32* [[A_I]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 4, i8* [[B_I]])
; CHECK-NEXT:    [[C_I:%.*]] = bitcast i32* [[A_I]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 4, i8* [[C_I]])
; CHECK-NEXT:    [[B_I2:%.*]] = bitcast i32* [[A_I1]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 4, i8* [[B_I2]])
; CHECK-NEXT:    [[C_I3:%.*]] = bitcast i32* [[A_I1]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 4, i8* [[C_I3]])
; CHECK-NEXT:    ret void
;
  call void @helper_two_casts()
  call void @helper_two_casts()
  ret void
}

define void @helper_arrays_alloca() {
; CHECK-LABEL: define void @helper_arrays_alloca() {
; CHECK-NEXT:    [[A:%.*]] = alloca [10 x i32], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast [10 x i32]* [[A]] to i8*
; CHECK-NEXT:    call void @use(i8* [[TMP1]])
; CHECK-NEXT:    ret void
;
  %a = alloca [10 x i32], align 16
  %1 = bitcast [10 x i32]* %a to i8*
  call void @use(i8* %1)
  ret void
}

define void @test_arrays_alloca() {
; CHECK-LABEL: define void @test_arrays_alloca() {
; CHECK-NEXT:    [[A_I:%.*]] = alloca [10 x i32], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast [10 x i32]* [[A_I]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 40, i8* [[TMP1]])
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast [10 x i32]* [[A_I]] to i8*
; CHECK-NEXT:    call void @use(i8* [[TMP2]])
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast [10 x i32]* [[A_I]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 40, i8* [[TMP3]])
; CHECK-NEXT:    ret void
;
  call void @helper_arrays_alloca()
  ret void
}

%swift.error = type opaque

define void @helper_swifterror_alloca() {
; CHECK-LABEL: define void @helper_swifterror_alloca() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SWIFTERROR:%.*]] = alloca swifterror %swift.error*, align 8
; CHECK-NEXT:    store %swift.error* null, %swift.error** [[SWIFTERROR]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %swifterror = alloca swifterror %swift.error*, align 8
  store %swift.error* null, %swift.error** %swifterror, align 8
  ret void
}

define void @test_swifterror_alloca() {
; CHECK-LABEL: define void @test_swifterror_alloca() {
; CHECK-NEXT:    [[SWIFTERROR_I:%.*]] = alloca swifterror %swift.error*, align 8
; CHECK-NEXT:    store %swift.error* null, %swift.error** [[SWIFTERROR_I]], align 8
; CHECK-NEXT:    ret void
;
  call void @helper_swifterror_alloca()
  ret void
}
