; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --version 5
; RUN: opt -p inline -S %s | FileCheck %s

@g = external global float

define float @add(float %a, float %b) {
; CHECK-LABEL: define float @add(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = fadd float [[A]], [[B]]
; CHECK-NEXT:    ret float [[ADD]]
;
  %add = fadd float %a, %b
  ret float %add
}

define float @caller1(float %a, float %b) {
; CHECK-LABEL: define float @caller1(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    [[ADD_I:%.*]] = fadd reassoc float [[A]], [[B]]
; CHECK-NEXT:    ret float [[ADD_I]]
;
  %r = call reassoc float @add(float %a, float %b)
  ret float %r
}

define float @add_with_unrelated_fp_math(float %a, float %b) {
; CHECK-LABEL: define float @add_with_unrelated_fp_math(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    [[L:%.*]] = load float, ptr @g, align 4
; CHECK-NEXT:    [[RES:%.*]] = fmul float [[L]], [[A]]
; CHECK-NEXT:    store float [[RES]], ptr @g, align 4
; CHECK-NEXT:    [[ADD:%.*]] = fadd float [[A]], [[B]]
; CHECK-NEXT:    ret float [[ADD]]
;
  %l = load float, ptr @g
  %res = fmul float %l, %a
  store float %res, ptr @g
  %add = fadd float %a, %b
  ret float %add
}

; Make sure the call-site fast-math flags are not added to instructions where
; not all operands have the new fast-math flags.
define float @caller2(float %a, float %b) {
; CHECK-LABEL: define float @caller2(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    [[L_I:%.*]] = load float, ptr @g, align 4
; CHECK-NEXT:    [[RES_I:%.*]] = fmul float [[L_I]], [[A]]
; CHECK-NEXT:    store float [[RES_I]], ptr @g, align 4
; CHECK-NEXT:    [[ADD_I:%.*]] = fadd nnan float [[A]], [[B]]
; CHECK-NEXT:    ret float [[ADD_I]]
;
  %r = call nnan float @add_with_unrelated_fp_math(float %a, float %b)
  ret float %r
}

define float @add_with_nnan(float %a, float %b) {
; CHECK-LABEL: define float @add_with_nnan(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = fadd nnan float [[A]], [[B]]
; CHECK-NEXT:    ret float [[ADD]]
;
  %add = fadd nnan float %a, %b
  ret float %add
}

; Make sure the fast-math flags on the original instruction are kept and the
; call-site flags are added.
define float @caller3(float %a, float %b) {
; CHECK-LABEL: define float @caller3(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    [[ADD_I:%.*]] = fadd nnan ninf float [[A]], [[B]]
; CHECK-NEXT:    ret float [[ADD_I]]
;
  %r = call ninf float @add_with_nnan(float %a, float %b)
  ret float %r
}

; Make sure the fast-math flags don't get accidentally propagated to
; instructions in the caller, reachable via the passed arguments.
define float @caller4(float %a, float %b) {
; CHECK-LABEL: define float @caller4(
; CHECK-SAME: float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    [[ADD_I:%.*]] = fadd ninf float [[A]], [[B]]
; CHECK-NEXT:    [[DIV:%.*]] = fdiv float [[A]], [[B]]
; CHECK-NEXT:    [[ADD:%.*]] = fadd float [[ADD_I]], [[DIV]]
; CHECK-NEXT:    ret float [[ADD]]
;
  %r = call ninf float @add(float %a, float %b)
  %div = fdiv float %a, %b
  %add = fadd float %r, %div
  ret float %add
}
