; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=inline -S | FileCheck %s
; Check that only the unterminated try scope for unwind destination catch.dispatch6
; is terminated upon inlining into main.

define i32 @ExitOnThrow(i32 %argc) personality ptr @__C_specific_handler {
; CHECK-LABEL: define i32 @ExitOnThrow(
; CHECK-SAME: i32 [[ARGC:%.*]]) personality ptr @__C_specific_handler {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARGC_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[ARGC]], ptr [[ARGC_ADDR]], align 4
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[INVOKE_CONT:.*]] unwind label %[[CATCH_DISPATCH:.*]]
; CHECK:       [[INVOKE_CONT]]:
; CHECK-NEXT:    invoke void @DoSth()
; CHECK-NEXT:            to label %[[INVOKE_CONT1:.*]] unwind label %[[CATCH_DISPATCH]]
; CHECK:       [[INVOKE_CONT1]]:
; CHECK-NEXT:    invoke void @llvm.seh.try.end()
; CHECK-NEXT:            to label %[[__TRY_CONT:.*]] unwind label %[[CATCH_DISPATCH]]
; CHECK:       [[CATCH_DISPATCH]]:
; CHECK-NEXT:    [[TMP0:%.*]] = catchswitch within none [label %__except] unwind to caller
; CHECK:       [[__EXCEPT:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = catchpad within [[TMP0]] [ptr null]
; CHECK-NEXT:    catchret from [[TMP1]] to label %[[__EXCEPT3:.*]]
; CHECK:       [[__EXCEPT3]]:
; CHECK-NEXT:    [[TMP2:%.*]] = tail call i32 @llvm.eh.exceptioncode(token [[TMP1]])
; CHECK-NEXT:    br label %[[__TRY_CONT]]
; CHECK:       [[__TRY_CONT]]:
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[INVOKE_CONT5:.*]] unwind label %[[CATCH_DISPATCH6:.*]]
; CHECK:       [[CATCH_DISPATCH6]]:
; CHECK-NEXT:    [[TMP3:%.*]] = catchswitch within none [label %__except7] unwind to caller
; CHECK:       [[__EXCEPT7:.*:]]
; CHECK-NEXT:    [[TMP4:%.*]] = catchpad within [[TMP3]] [ptr null]
; CHECK-NEXT:    catchret from [[TMP4]] to label %[[__EXCEPT8:.*]]
; CHECK:       [[__EXCEPT8]]:
; CHECK-NEXT:    [[TMP5:%.*]] = tail call i32 @llvm.eh.exceptioncode(token [[TMP4]])
; CHECK-NEXT:    tail call void @Exit() #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    unreachable
; CHECK:       [[INVOKE_CONT5]]:
; CHECK-NEXT:    [[ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_:%.*]] = load volatile i32, ptr [[ARGC_ADDR]], align 4
; CHECK-NEXT:    ret i32 [[ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_]]
;
entry:
  %argc.addr = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  invoke void @llvm.seh.try.begin()
  to label %invoke.cont unwind label %catch.dispatch

invoke.cont:                                      ; preds = %entry
  invoke void @DoSth()
  to label %invoke.cont1 unwind label %catch.dispatch

invoke.cont1:                                     ; preds = %invoke.cont
  invoke void @llvm.seh.try.end()
  to label %__try.cont unwind label %catch.dispatch

catch.dispatch:                                   ; preds = %invoke.cont1, %invoke.cont, %entry
  %0 = catchswitch within none [label %__except] unwind to caller

__except:                                         ; preds = %catch.dispatch
  %1 = catchpad within %0 [ptr null]
  catchret from %1 to label %__except3

__except3:                                        ; preds = %__except
  %2 = tail call i32 @llvm.eh.exceptioncode(token %1)
  br label %__try.cont

__try.cont:                                       ; preds = %invoke.cont1, %__except3
  invoke void @llvm.seh.try.begin()
  to label %invoke.cont5 unwind label %catch.dispatch6

catch.dispatch6:                                  ; preds = %__try.cont
  %3 = catchswitch within none [label %__except7] unwind to caller

__except7:                                        ; preds = %catch.dispatch6
  %4 = catchpad within %3 [ptr null]
  catchret from %4 to label %__except8

__except8:                                        ; preds = %__except7
  %5 = tail call i32 @llvm.eh.exceptioncode(token %4)
  tail call void @Exit() #0
  unreachable

invoke.cont5:                                     ; preds = %__try.cont
  %argc.addr.0.argc.addr.0.argc.addr.0.argc.addr.0. = load volatile i32, ptr %argc.addr, align 4
  ret i32 %argc.addr.0.argc.addr.0.argc.addr.0.argc.addr.0.
}

define i32 @main(i32 noundef %argc, ptr noundef %argv) {
; CHECK-LABEL: define i32 @main(
; CHECK-SAME: i32 noundef [[ARGC:%.*]], ptr noundef [[ARGV:%.*]]) personality ptr @__C_specific_handler {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARGC_ADDR_I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ARGC_ADDR_I]])
; CHECK-NEXT:    store i32 [[ARGC]], ptr [[ARGC_ADDR_I]], align 4
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[INVOKE_CONT_I:.*]] unwind label %[[CATCH_DISPATCH_I:.*]]
; CHECK:       [[INVOKE_CONT_I]]:
; CHECK-NEXT:    invoke void @DoSth()
; CHECK-NEXT:            to label %[[INVOKE_CONT1_I:.*]] unwind label %[[CATCH_DISPATCH_I]]
; CHECK:       [[INVOKE_CONT1_I]]:
; CHECK-NEXT:    invoke void @llvm.seh.try.end()
; CHECK-NEXT:            to label %[[__TRY_CONT_I:.*]] unwind label %[[CATCH_DISPATCH_I]]
; CHECK:       [[CATCH_DISPATCH_I]]:
; CHECK-NEXT:    [[TMP0:%.*]] = catchswitch within none [label %__except.i] unwind to caller
; CHECK:       [[__EXCEPT_I:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = catchpad within [[TMP0]] [ptr null]
; CHECK-NEXT:    catchret from [[TMP1]] to label %[[__EXCEPT3_I:.*]]
; CHECK:       [[__EXCEPT3_I]]:
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.eh.exceptioncode(token [[TMP1]])
; CHECK-NEXT:    br label %[[__TRY_CONT_I]]
; CHECK:       [[__TRY_CONT_I]]:
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[TRY_END:.*]] unwind label %[[CATCH_DISPATCH6_I:.*]]
; CHECK:       [[CATCH_DISPATCH6_I]]:
; CHECK-NEXT:    [[TMP3:%.*]] = catchswitch within none [label %__except7.i] unwind to caller
; CHECK:       [[__EXCEPT7_I:.*:]]
; CHECK-NEXT:    [[TMP4:%.*]] = catchpad within [[TMP3]] [ptr null]
; CHECK-NEXT:    catchret from [[TMP4]] to label %[[__EXCEPT8_I:.*]]
; CHECK:       [[__EXCEPT8_I]]:
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @llvm.eh.exceptioncode(token [[TMP4]])
; CHECK-NEXT:    call void @Exit() #[[ATTR2]]
; CHECK-NEXT:    unreachable
; CHECK:       [[TRY_END]]:
; CHECK-NEXT:    [[ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0__I:%.*]] = load volatile i32, ptr [[ARGC_ADDR_I]], align 4
; CHECK-NEXT:    invoke void @llvm.seh.try.end()
; CHECK-NEXT:            to label %[[EXITONTHROW_EXIT:.*]] unwind label %[[CATCH_DISPATCH6_I]]
; CHECK:       [[EXITONTHROW_EXIT]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ARGC_ADDR_I]])
; CHECK-NEXT:    [[CALL1:%.*]] = call i32 @AlwaysThrows(i32 noundef [[ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0__I]])
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0_ARGC_ADDR_0__I]], [[CALL1]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %call = call i32 @ExitOnThrow(i32 noundef %argc)
  %call1 = call i32 @AlwaysThrows(i32 noundef %call)
  %add = add nsw i32 %call, %call1
  ret i32 %add
}

declare void @llvm.seh.try.begin()
declare void @llvm.seh.try.end()
declare i32 @llvm.eh.exceptioncode(token)
declare i32 @__C_specific_handler(...)
declare void @Fault()
declare void @Exit() #0
declare i32 @AlwaysThrows(i32 %id)
declare void @DoSth(i32 %val)

attributes #0 = { noreturn nounwind }

!llvm.module.flags = !{!0}
!0 = !{i32 2, !"eh-asynch", i32 1}
