; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=inline -S | FileCheck %s
; Check that the try scope of ExitOnThrow is terminated upon inlining into main.

define i32 @ExitOnThrow(i32 %argc) personality ptr @__CxxFrameHandler3 {
; CHECK-LABEL: define i32 @ExitOnThrow(
; CHECK-SAME: i32 [[ARGC:%.*]]) personality ptr @__CxxFrameHandler3 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[INVOKE_CONT:.*]] unwind label %[[CATCH_DISPATCH:.*]]
; CHECK:       [[INVOKE_CONT]]:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[ARGC]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    invoke void @ThrowException()
; CHECK-NEXT:            to label %[[UNREACHABLE:.*]] unwind label %[[CATCH_DISPATCH]]
; CHECK:       [[CATCH_DISPATCH]]:
; CHECK-NEXT:    [[TMP0:%.*]] = catchswitch within none [label %catch] unwind to caller
; CHECK:       [[CATCH:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = catchpad within [[TMP0]] [ptr null, i32 0, ptr null]
; CHECK-NEXT:    catchret from [[TMP1]] to label %[[TRY_CONT:.*]]
; CHECK:       [[TRY_CONT]]:
; CHECK-NEXT:    call void @Exit()
; CHECK-NEXT:    unreachable
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    ret i32 [[ARGC]]
; CHECK:       [[UNREACHABLE]]:
; CHECK-NEXT:    unreachable
;
entry:
  invoke void @llvm.seh.try.begin()
  to label %invoke.cont unwind label %catch.dispatch

invoke.cont:                                      ; preds = %entry
  %tobool.not = icmp eq i32 %argc, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont
  invoke void @ThrowException()
  to label %unreachable unwind label %catch.dispatch

catch.dispatch:                                   ; preds = %if.then, %entry
  %0 = catchswitch within none [label %catch] unwind to caller

catch:                                            ; preds = %catch.dispatch
  %1 = catchpad within %0 [ptr null, i32 0, ptr null]
  catchret from %1 to label %try.cont

try.cont:                                         ; preds = %catch
  call void @Exit()
  unreachable

if.end:                                           ; preds = %invoke.cont
  ret i32 %argc

unreachable:                                      ; preds = %if.then
  unreachable
}

define i32 @main(i32 noundef %argc, ptr noundef %argv) {
; CHECK-LABEL: define i32 @main(
; CHECK-SAME: i32 noundef [[ARGC:%.*]], ptr noundef [[ARGV:%.*]]) personality ptr @__CxxFrameHandler3 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[INVOKE_CONT_I:.*]] unwind label %[[CATCH_DISPATCH_I:.*]]
; CHECK:       [[INVOKE_CONT_I]]:
; CHECK-NEXT:    [[TOBOOL_NOT_I:%.*]] = icmp eq i32 [[ARGC]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT_I]], label %[[IF_THEN_I:.*]], label %[[TRY_END:.*]]
; CHECK:       [[IF_THEN_I]]:
; CHECK-NEXT:    invoke void @ThrowException()
; CHECK-NEXT:            to label %[[UNREACHABLE_I:.*]] unwind label %[[CATCH_DISPATCH_I]]
; CHECK:       [[CATCH_DISPATCH_I]]:
; CHECK-NEXT:    [[TMP0:%.*]] = catchswitch within none [label %catch.i] unwind to caller
; CHECK:       [[CATCH_I:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = catchpad within [[TMP0]] [ptr null, i32 0, ptr null]
; CHECK-NEXT:    catchret from [[TMP1]] to label %[[TRY_CONT_I:.*]]
; CHECK:       [[TRY_CONT_I]]:
; CHECK-NEXT:    call void @Exit()
; CHECK-NEXT:    unreachable
; CHECK:       [[TRY_END]]:
; CHECK-NEXT:    invoke void @llvm.seh.try.end()
; CHECK-NEXT:            to label %[[EXITONTHROW_EXIT:.*]] unwind label %[[CATCH_DISPATCH_I]]
; CHECK:       [[UNREACHABLE_I]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[EXITONTHROW_EXIT]]:
; CHECK-NEXT:    [[CALL1:%.*]] = call i32 @AlwaysThrows(i32 noundef [[ARGC]])
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[ARGC]], [[CALL1]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %call = call i32 @ExitOnThrow(i32 noundef %argc)
  %call1 = call i32 @AlwaysThrows(i32 noundef %call)
  %add = add nsw i32 %call, %call1
  ret i32 %add
}

declare void @llvm.seh.try.begin()
declare i32 @__CxxFrameHandler3(...)
declare void @ThrowException()
declare void @Exit() #0
declare i32 @AlwaysThrows(i32 %id)

attributes #0 = { noreturn }

!llvm.module.flags = !{!0}
!0 = !{i32 2, !"eh-asynch", i32 1}
