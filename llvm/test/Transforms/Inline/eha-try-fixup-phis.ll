; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=inline -S | FileCheck %s
; Check that the phi in catch.dispatch is adjusted for the try scope end upon inlining.

define i32 @ExitOnThrow(i32 %argc) #3 personality ptr @__CxxFrameHandler3 {
; CHECK-LABEL: define i32 @ExitOnThrow(
; CHECK-SAME: i32 [[ARGC:%.*]]) #[[ATTR0:[0-9]+]] personality ptr @__CxxFrameHandler3 {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[INVOKE_CONT:.*]] unwind label %[[CATCH_DISPATCH:.*]]
; CHECK:       [[INVOKE_CONT]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[ARGC]], 0
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    invoke void @ThrowException() #[[ATTR2:[0-9]+]]
; CHECK-NEXT:            to label %[[UNREACHABLE:.*]] unwind label %[[CATCH_DISPATCH]]
; CHECK:       [[CATCH_DISPATCH]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 1, %[[IF_THEN]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = catchswitch within none [label %catch] unwind to caller
; CHECK:       [[CATCH:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = catchpad within [[TMP0]] [ptr null, i32 0, ptr null]
; CHECK-NEXT:    call void @DoSth(i32 noundef [[PHI]]) #[[ATTR3:[0-9]+]] [ "funclet"(token [[TMP1]]) ]
; CHECK-NEXT:    catchret from [[TMP1]] to label %[[TRY_CONT:.*]]
; CHECK:       [[TRY_CONT]]:
; CHECK-NEXT:    call void @Exit() #[[ATTR4:[0-9]+]]
; CHECK-NEXT:    unreachable
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[ARGC]], 5
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       [[UNREACHABLE]]:
; CHECK-NEXT:    unreachable
;
entry:
  invoke void @llvm.seh.try.begin()
  to label %invoke.cont unwind label %catch.dispatch

invoke.cont:                                      ; preds = %entry
  %cmp = icmp sgt i32 %argc, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %invoke.cont
  invoke void @ThrowException() #0
  to label %unreachable unwind label %catch.dispatch

catch.dispatch:                                   ; preds = %if.then, %entry
  %phi = phi i32 [ 1, %if.then ], [ 0, %entry ]
  %0 = catchswitch within none [label %catch] unwind to caller

catch:                                            ; preds = %catch.dispatch
  %1 = catchpad within %0 [ptr null, i32 0, ptr null]
  call void @DoSth(i32 noundef %phi) #1 [ "funclet"(token %1) ]
  catchret from %1 to label %try.cont

try.cont:                                         ; preds = %catch, %invoke.cont
  call void @Exit() #2
  unreachable

if.end:                                           ; preds = %invoke.cont
  %add = add nsw i32 %argc, 5
  ret i32 %add

unreachable:                                      ; preds = %if.then
  unreachable
}

define i32 @main(i32 noundef %argc, ptr noundef %argv) {
; CHECK-LABEL: define i32 @main(
; CHECK-SAME: i32 noundef [[ARGC:%.*]], ptr noundef [[ARGV:%.*]]) personality ptr @__CxxFrameHandler3 {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    invoke void @llvm.seh.try.begin()
; CHECK-NEXT:            to label %[[INVOKE_CONT_I:.*]] unwind label %[[CATCH_DISPATCH_I:.*]]
; CHECK:       [[INVOKE_CONT_I]]:
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp sgt i32 [[ARGC]], 0
; CHECK-NEXT:    br i1 [[CMP_I]], label %[[IF_THEN_I:.*]], label %[[TRY_END:.*]]
; CHECK:       [[IF_THEN_I]]:
; CHECK-NEXT:    invoke void @ThrowException() #[[ATTR2]]
; CHECK-NEXT:            to label %[[UNREACHABLE_I:.*]] unwind label %[[CATCH_DISPATCH_I]]
; CHECK:       [[CATCH_DISPATCH_I]]:
; CHECK-NEXT:    [[PHI_I:%.*]] = phi i32 [ 1, %[[IF_THEN_I]] ], [ 0, %[[ENTRY]] ], [ poison, %[[TRY_END]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = catchswitch within none [label %catch.i] unwind to caller
; CHECK:       [[CATCH_I:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = catchpad within [[TMP0]] [ptr null, i32 0, ptr null]
; CHECK-NEXT:    call void @DoSth(i32 noundef [[PHI_I]]) #[[ATTR3]] [ "funclet"(token [[TMP1]]) ]
; CHECK-NEXT:    catchret from [[TMP1]] to label %[[TRY_CONT_I:.*]]
; CHECK:       [[TRY_CONT_I]]:
; CHECK-NEXT:    call void @Exit() #[[ATTR4]]
; CHECK-NEXT:    unreachable
; CHECK:       [[TRY_END]]:
; CHECK-NEXT:    [[ADD_I:%.*]] = add nsw i32 [[ARGC]], 5
; CHECK-NEXT:    invoke void @llvm.seh.try.end()
; CHECK-NEXT:            to label %[[EXITONTHROW_EXIT:.*]] unwind label %[[CATCH_DISPATCH_I]]
; CHECK:       [[UNREACHABLE_I]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[EXITONTHROW_EXIT]]:
; CHECK-NEXT:    [[CALL1:%.*]] = call i32 @AlwaysThrows(i32 noundef [[ADD_I]])
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[ADD_I]], [[CALL1]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %call = call i32 @ExitOnThrow(i32 noundef %argc)
  %call1 = call i32 @AlwaysThrows(i32 noundef %call)
  %add = add nsw i32 %call, %call1
  ret i32 %add
}

declare void @llvm.seh.try.begin()
declare i32 @__CxxFrameHandler3(...)
declare void @ThrowException()
declare void @Exit() #0
declare i32 @AlwaysThrows(i32 %id)
declare void @DoSth(i32 %val)

attributes #0 = { noreturn }
attributes #1 = { nounwind }
attributes #2 = { noreturn nounwind }
attributes #3 = { mustprogress noreturn nounwind uwtable }

!llvm.module.flags = !{!0}
!0 = !{i32 2, !"eh-asynch", i32 1}
