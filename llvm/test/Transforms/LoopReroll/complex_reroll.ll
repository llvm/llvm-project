; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=loop-reroll   %s | FileCheck %s
declare i32 @goo(i32, i32)

@buf = external global i8*
@aaa = global [16 x i8] c"\01\02\03\04\05\06\07\08\09\0A\0B\0C\0D\0E\0F\10", align 1

define i32 @test1(i32 %len) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[INDVAR:%.*]] = phi i64 [ [[INDVAR_NEXT:%.*]], [[WHILE_BODY]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[SUM44_020:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[WHILE_BODY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = trunc i64 [[INDVAR]] to i32
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr [16 x i8], [16 x i8]* @aaa, i64 0, i64 [[INDVAR]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, i8* [[SCEVGEP]], align 1
; CHECK-NEXT:    [[CONV:%.*]] = zext i8 [[TMP1]] to i64
; CHECK-NEXT:    [[ADD]] = add i64 [[CONV]], [[SUM44_020]]
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i64 [[INDVAR]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[TMP0]], 15
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[WHILE_END:%.*]], label [[WHILE_BODY]]
; CHECK:       while.end:
; CHECK-NEXT:    [[ADD9_LCSSA:%.*]] = phi i64 [ [[ADD]], [[WHILE_BODY]] ]
; CHECK-NEXT:    [[CONV11:%.*]] = trunc i64 [[ADD9_LCSSA]] to i32
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @goo(i32 0, i32 [[CONV11]])
; CHECK-NEXT:    unreachable
;
entry:
  br label %while.body

while.body:

  %dec22 = phi i32 [ 4, %entry ], [ %dec, %while.body ]
  %buf.021 = phi i8* [ getelementptr inbounds ([16 x i8], [16 x i8]* @aaa, i64 0, i64 0), %entry ], [ %add.ptr, %while.body ]
  %sum44.020 = phi i64 [ 0, %entry ], [ %add9, %while.body ]
  %0 = load i8, i8* %buf.021, align 1
  %conv = zext i8 %0 to i64
  %add = add i64 %conv, %sum44.020
  %arrayidx1 = getelementptr inbounds i8, i8* %buf.021, i64 1
  %1 = load i8, i8* %arrayidx1, align 1
  %conv2 = zext i8 %1 to i64
  %add3 = add i64 %add, %conv2
  %arrayidx4 = getelementptr inbounds i8, i8* %buf.021, i64 2
  %2 = load i8, i8* %arrayidx4, align 1
  %conv5 = zext i8 %2 to i64
  %add6 = add i64 %add3, %conv5
  %arrayidx7 = getelementptr inbounds i8, i8* %buf.021, i64 3
  %3 = load i8, i8* %arrayidx7, align 1
  %conv8 = zext i8 %3 to i64
  %add9 = add i64 %add6, %conv8
  %add.ptr = getelementptr inbounds i8, i8* %buf.021, i64 4
  %dec = add nsw i32 %dec22, -1
  %tobool = icmp eq i32 %dec, 0
  br i1 %tobool, label %while.end, label %while.body

while.end:                                        ; preds = %while.body
  %conv11 = trunc i64 %add9 to i32
  %call = tail call i32 @goo(i32 0, i32 %conv11)
  unreachable
}

define i32 @test2(i32 %N, i32* nocapture readonly %a, i32 %S) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_9:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP_9]], label [[FOR_BODY_LR_PH:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.lr.ph:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i32 [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = shl nuw i32 [[TMP1]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = add nuw nsw i32 [[TMP2]], 1
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.for.cond.cleanup_crit_edge:
; CHECK-NEXT:    [[ADD2_LCSSA:%.*]] = phi i32 [ [[ADD:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[S_ADDR_0_LCSSA:%.*]] = phi i32 [ [[ADD2_LCSSA]], [[FOR_COND_FOR_COND_CLEANUP_CRIT_EDGE:%.*]] ], [ [[S:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[S_ADDR_0_LCSSA]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVAR:%.*]] = phi i64 [ [[INDVAR_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_LR_PH]] ]
; CHECK-NEXT:    [[S_ADDR_011:%.*]] = phi i32 [ [[S]], [[FOR_BODY_LR_PH]] ], [ [[ADD]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = trunc i64 [[INDVAR]] to i32
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i32, i32* [[A:%.*]], i64 [[INDVAR]]
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32* [[SCEVGEP]], align 4
; CHECK-NEXT:    [[ADD]] = add nsw i32 [[TMP5]], [[S_ADDR_011]]
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i64 [[INDVAR]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[TMP4]], [[TMP3]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_FOR_COND_CLEANUP_CRIT_EDGE]], label [[FOR_BODY]]
;
entry:
  %cmp.9 = icmp sgt i32 %N, 0
  br i1 %cmp.9, label %for.body.lr.ph, label %for.cond.cleanup

for.body.lr.ph:
  br label %for.body

for.cond.for.cond.cleanup_crit_edge:
  br label %for.cond.cleanup

for.cond.cleanup:
  %S.addr.0.lcssa = phi i32 [ %add2, %for.cond.for.cond.cleanup_crit_edge ], [ %S, %entry ]
  ret i32 %S.addr.0.lcssa

for.body:

  %i.012 = phi i32 [ 0, %for.body.lr.ph ], [ %add3, %for.body ]
  %S.addr.011 = phi i32 [ %S, %for.body.lr.ph ], [ %add2, %for.body ]
  %a.addr.010 = phi i32* [ %a, %for.body.lr.ph ], [ %incdec.ptr1, %for.body ]
  %incdec.ptr = getelementptr inbounds i32, i32* %a.addr.010, i64 1
  %0 = load i32, i32* %a.addr.010, align 4
  %add = add nsw i32 %0, %S.addr.011
  %incdec.ptr1 = getelementptr inbounds i32, i32* %a.addr.010, i64 2
  %1 = load i32, i32* %incdec.ptr, align 4
  %add2 = add nsw i32 %add, %1
  %add3 = add nsw i32 %i.012, 2
  %cmp = icmp slt i32 %add3, %N
  br i1 %cmp, label %for.body, label %for.cond.for.cond.cleanup_crit_edge
}

define i32 @test3(i32* nocapture readonly %buf, i32 %len) #0 {
; CHECK-LABEL: @test3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP10:%.*]] = icmp sgt i32 [[LEN:%.*]], 1
; CHECK-NEXT:    br i1 [[CMP10]], label [[WHILE_BODY_PREHEADER:%.*]], label [[WHILE_END:%.*]]
; CHECK:       while.body.preheader:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[LEN]], -2
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i32 [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = shl nuw i32 [[TMP1]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = add nuw nsw i32 [[TMP2]], 1
; CHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[INDVAR:%.*]] = phi i64 [ [[INDVAR_NEXT:%.*]], [[WHILE_BODY]] ], [ 0, [[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[S_012:%.*]] = phi i32 [ [[ADD:%.*]], [[WHILE_BODY]] ], [ undef, [[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = trunc i64 [[INDVAR]] to i32
; CHECK-NEXT:    [[TMP5:%.*]] = mul nsw i64 [[INDVAR]], -1
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i32, i32* [[BUF:%.*]], i64 [[TMP5]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, i32* [[SCEVGEP]], align 4
; CHECK-NEXT:    [[ADD]] = add nsw i32 [[TMP6]], [[S_012]]
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i64 [[INDVAR]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[TMP4]], [[TMP3]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[WHILE_END_LOOPEXIT:%.*]], label [[WHILE_BODY]]
; CHECK:       while.end.loopexit:
; CHECK-NEXT:    [[ADD2_LCSSA:%.*]] = phi i32 [ [[ADD]], [[WHILE_BODY]] ]
; CHECK-NEXT:    br label [[WHILE_END]]
; CHECK:       while.end:
; CHECK-NEXT:    [[S_0_LCSSA:%.*]] = phi i32 [ undef, [[ENTRY:%.*]] ], [ [[ADD2_LCSSA]], [[WHILE_END_LOOPEXIT]] ]
; CHECK-NEXT:    ret i32 [[S_0_LCSSA]]
;
entry:
  %cmp10 = icmp sgt i32 %len, 1
  br i1 %cmp10, label %while.body.preheader, label %while.end

while.body.preheader:                             ; preds = %entry
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %while.body

  %i.013 = phi i32 [ %sub, %while.body ], [ %len, %while.body.preheader ]
  %S.012 = phi i32 [ %add2, %while.body ], [ undef, %while.body.preheader ]
  %buf.addr.011 = phi i32* [ %add.ptr, %while.body ], [ %buf, %while.body.preheader ]
  %0 = load i32, i32* %buf.addr.011, align 4
  %add = add nsw i32 %0, %S.012
  %arrayidx1 = getelementptr inbounds i32, i32* %buf.addr.011, i64 -1
  %1 = load i32, i32* %arrayidx1, align 4
  %add2 = add nsw i32 %add, %1
  %add.ptr = getelementptr inbounds i32, i32* %buf.addr.011, i64 -2
  %sub = add nsw i32 %i.013, -2
  %cmp = icmp sgt i32 %sub, 1
  br i1 %cmp, label %while.body, label %while.end.loopexit

while.end.loopexit:                               ; preds = %while.body
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %entry
  %S.0.lcssa = phi i32 [ undef, %entry ], [ %add2, %while.end.loopexit ]
  ret i32 %S.0.lcssa
}

define i32 @test4(i32 %len) {
; CHECK-LABEL: @test4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[INDVAR:%.*]] = phi i64 [ [[INDVAR_NEXT:%.*]], [[WHILE_BODY]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[SUM44_020:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[WHILE_BODY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = trunc i64 [[INDVAR]] to i32
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr [16 x i8], [16 x i8]* @aaa, i64 0, i64 [[INDVAR]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, i8* [[SCEVGEP]], align 1
; CHECK-NEXT:    [[CONV:%.*]] = zext i8 [[TMP1]] to i64
; CHECK-NEXT:    [[ADD]] = add i64 [[CONV]], [[SUM44_020]]
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i64 [[INDVAR]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[TMP0]], 23
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[WHILE_END:%.*]], label [[WHILE_BODY]]
; CHECK:       while.end:
; CHECK-NEXT:    [[ADD9_LCSSA:%.*]] = phi i64 [ [[ADD]], [[WHILE_BODY]] ]
; CHECK-NEXT:    [[CONV11:%.*]] = trunc i64 [[ADD9_LCSSA]] to i32
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @goo(i32 0, i32 [[CONV11]])
; CHECK-NEXT:    unreachable
;
entry:
  br label %while.body

while.body:
  %a = phi i32 [ 4, %entry ], [ %a.next, %while.body ]
  %b = phi i32 [ 6, %entry ], [ %b.next, %while.body ]
  %buf.021 = phi i8* [ getelementptr inbounds ([16 x i8], [16 x i8]* @aaa, i64 0, i64 0), %entry ], [ %add.ptr, %while.body ]
  %sum44.020 = phi i64 [ 0, %entry ], [ %add9, %while.body ]
  %0 = load i8, i8* %buf.021, align 1
  %conv = zext i8 %0 to i64
  %add = add i64 %conv, %sum44.020
  %arrayidx1 = getelementptr inbounds i8, i8* %buf.021, i64 1
  %1 = load i8, i8* %arrayidx1, align 1
  %conv2 = zext i8 %1 to i64
  %add3 = add i64 %add, %conv2
  %arrayidx4 = getelementptr inbounds i8, i8* %buf.021, i64 2
  %2 = load i8, i8* %arrayidx4, align 1
  %conv5 = zext i8 %2 to i64
  %add6 = add i64 %add3, %conv5
  %arrayidx7 = getelementptr inbounds i8, i8* %buf.021, i64 3
  %3 = load i8, i8* %arrayidx7, align 1
  %conv8 = zext i8 %3 to i64
  %add9 = add i64 %add6, %conv8
  %add.ptr = getelementptr inbounds i8, i8* %buf.021, i64 4
  %a.next = add nsw i32 %a, -1
  %b.next = add nsw i32 %b, -1
  %cond = add nsw i32 %a, %b
  %tobool = icmp eq i32 %cond, 0
  br i1 %tobool, label %while.end, label %while.body

while.end:                                        ; preds = %while.body
  %conv11 = trunc i64 %add9 to i32
  %call = tail call i32 @goo(i32 0, i32 %conv11)
  unreachable
}

