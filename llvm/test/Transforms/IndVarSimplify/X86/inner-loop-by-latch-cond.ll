; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=indvars -S | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1"
target triple = "x86_64-unknown-linux-gnu"

declare void @foo(i64)

define void @test(i64 %a) {
; CHECK-LABEL: define void @test(
; CHECK-SAME: i64 [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[OUTER_HEADER:%.*]]
; CHECK:       outer_header:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[OUTER_LATCH:%.*]] ], [ 21, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 20, [[ENTRY]] ], [ [[I_NEXT:%.*]], [[OUTER_LATCH]] ]
; CHECK-NEXT:    br label [[INNER_HEADER:%.*]]
; CHECK:       inner_header:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ 1, [[OUTER_HEADER]] ], [ [[J_NEXT:%.*]], [[INNER_HEADER]] ]
; CHECK-NEXT:    call void @foo(i64 [[J]])
; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[J_NEXT]], [[INDVARS_IV]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[INNER_HEADER]], label [[OUTER_LATCH]]
; CHECK:       outer_latch:
; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[COND2:%.*]] = icmp ne i64 [[I_NEXT]], 40
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    br i1 [[COND2]], label [[OUTER_HEADER]], label [[RETURN:%.*]]
; CHECK:       return:
; CHECK-NEXT:    ret void
;
entry:
  br label %outer_header

outer_header:
  %i = phi i64 [20, %entry], [%i.next, %outer_latch]
  %i.next = add nuw nsw i64 %i, 1
  br label %inner_header

inner_header:
  %j = phi i64 [1, %outer_header], [%j.next, %inner_header]
  %cmp = icmp ult i64 %j, %i.next
  %s = select i1 %cmp, i64 %j, i64 %i
  call void @foo(i64 %s)
  %j.next = add nuw nsw i64 %j, 1
  %cond = icmp ult i64 %j, %i
  br i1 %cond, label %inner_header, label %outer_latch

outer_latch:
  %cond2 = icmp ne i64 %i.next, 40
  br i1 %cond2, label %outer_header, label %return

return:
  ret void
}
