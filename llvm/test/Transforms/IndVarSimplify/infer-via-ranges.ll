; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=indvars -S < %s | FileCheck %s

define void @infer_via_ranges(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @infer_via_ranges(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[FIRST_ITR_CHECK:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-NEXT:    [[START:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    br i1 [[FIRST_ITR_CHECK]], label %[[LOOP_PREHEADER:.*]], label %[[EXIT:.*]]
; CHECK:       [[LOOP_PREHEADER]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IDX:%.*]] = phi i32 [ [[IDX_DEC:%.*]], %[[IN_BOUNDS:.*]] ], [ [[START]], %[[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[IDX_DEC]] = sub nsw i32 [[IDX]], 1
; CHECK-NEXT:    br i1 true, label %[[IN_BOUNDS]], label %[[OUT_OF_BOUNDS:.*]]
; CHECK:       [[IN_BOUNDS]]:
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i32, ptr [[ARR]], i32 [[IDX]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR]], align 4
; CHECK-NEXT:    [[NEXT:%.*]] = icmp sgt i32 [[IDX_DEC]], -1
; CHECK-NEXT:    br i1 [[NEXT]], label %[[LOOP]], label %[[EXIT_LOOPEXIT:.*]]
; CHECK:       [[OUT_OF_BOUNDS]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXIT_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
  entry:
  %first.itr.check = icmp sgt i32 %n, 0
  %start = sub i32 %n, 1
  br i1 %first.itr.check, label %loop, label %exit

  loop:
  %idx = phi i32 [ %start, %entry ] , [ %idx.dec, %in.bounds ]
  %idx.dec = sub i32 %idx, 1
  %abc = icmp sge i32 %idx, 0
  br i1 %abc, label %in.bounds, label %out.of.bounds

  in.bounds:
  %addr = getelementptr i32, ptr %arr, i32 %idx
  store i32 0, ptr %addr
  %next = icmp sgt i32 %idx.dec, -1
  br i1 %next, label %loop, label %exit

  out.of.bounds:
  ret void

  exit:
  ret void
}
