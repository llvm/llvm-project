; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=indvars -S -o - | FileCheck %s


define void @mat_transpose(float* %pIn, float* %pOut, i32 %nRows, i32 %nCols) {
; CHECK-LABEL: define void @mat_transpose(
; CHECK-SAME: ptr [[PIN:%.*]], ptr [[POUT:%.*]], i32 [[NROWS:%.*]], i32 [[NCOLS:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP_ROW:.*]]
; CHECK:       [[LOOP_ROW]]:
; CHECK-NEXT:    [[ROW_IV:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[ROW_INC:%.*]], %[[LOOP_ROW_END:.*]] ]
; CHECK-NEXT:    [[CMP_ROW:%.*]] = icmp ult i32 [[ROW_IV]], [[NROWS]]
; CHECK-NEXT:    br i1 [[CMP_ROW]], label %[[LOOP_COL_PRE:.*]], label %[[EXIT:.*]]
; CHECK:       [[LOOP_COL_PRE]]:
; CHECK-NEXT:    [[PX_BASE:%.*]] = getelementptr inbounds float, ptr [[POUT]], i32 [[ROW_IV]]
; CHECK-NEXT:    br label %[[LOOP_COL:.*]]
; CHECK:       [[LOOP_COL]]:
; CHECK-NEXT:    [[COL_IV:%.*]] = phi i32 [ 0, %[[LOOP_COL_PRE]] ], [ [[COL_INC:%.*]], %[[LOOP_COL]] ]
; CHECK-NEXT:    [[PIN_PTR:%.*]] = phi ptr [ [[PIN]], %[[LOOP_COL_PRE]] ], [ [[PIN_NEXT:%.*]], %[[LOOP_COL]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = mul i32 [[COL_IV]], [[NROWS]]
; CHECK-NEXT:    [[PX_PTR:%.*]] = getelementptr inbounds float, ptr [[PX_BASE]], i32 [[TMP0]]
; CHECK-NEXT:    [[PIN_LOAD:%.*]] = load float, ptr [[PIN_PTR]], align 4
; CHECK-NEXT:    [[PIN_NEXT]] = getelementptr float, ptr [[PIN_PTR]], i32 1
; CHECK-NEXT:    store float [[PIN_LOAD]], ptr [[PX_PTR]], align 4
; CHECK-NEXT:    [[COL_INC]] = add nuw i32 [[COL_IV]], 1
; CHECK-NEXT:    [[CMP_COL:%.*]] = icmp ult i32 [[COL_INC]], [[NCOLS]]
; CHECK-NEXT:    br i1 [[CMP_COL]], label %[[LOOP_COL]], label %[[LOOP_ROW_END]]
; CHECK:       [[LOOP_ROW_END]]:
; CHECK-NEXT:    [[ROW_INC]] = add nuw i32 [[ROW_IV]], 1
; CHECK-NEXT:    br label %[[LOOP_ROW]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop_row

loop_row:
  %row.iv = phi i32 [ 0, %entry ], [ %row.inc, %loop_row_end ]
  %cmp.row = icmp ult i32 %row.iv, %nRows
  br i1 %cmp.row, label %loop_col_pre, label %exit

loop_col_pre:
  %px.base = getelementptr inbounds float, float* %pOut, i32 %row.iv
  br label %loop_col

loop_col:
  %col.iv = phi i32 [ 0, %loop_col_pre ], [ %col.inc,  %loop_col  ]
  %pIn.ptr = phi float* [ %pIn, %loop_col_pre ], [ %pIn.next, %loop_col   ]
  %px.ptr = phi float* [ %px.base, %loop_col_pre ], [ %px.next,  %loop_col   ]
  %pIn.load = load float, float* %pIn.ptr
  %pIn.next = getelementptr float, float* %pIn.ptr, i32 1
  store float %pIn.load, float* %px.ptr
  %px.next = getelementptr float, float* %px.ptr, i32 %nRows
  %col.inc = add nuw i32 %col.iv, 1
  %cmp.col = icmp ult i32 %col.inc, %nCols
  br i1 %cmp.col, label %loop_col, label %loop_row_end

loop_row_end:
  %row.inc = add nuw i32 %row.iv, 1
  br label %loop_row

exit:
  ret void
}
