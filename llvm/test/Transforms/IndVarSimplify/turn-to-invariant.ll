; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=indvars -S < %s | FileCheck %s

declare i1 @cond()

; Range check here can be turned into invariant check.
define i32 @test_simple_case(i32 %start, i32 %len) {
; CHECK-LABEL: @test_simple_case(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[START:%.*]], -1
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[START]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE:%.*]] ]
; CHECK-NEXT:    [[ZERO_CHECK:%.*]] = icmp ne i32 [[IV]], 0
; CHECK-NEXT:    br i1 [[ZERO_CHECK]], label [[RANGE_CHECK_BLOCK:%.*]], label [[FAILED_1:%.*]]
; CHECK:       range_check_block:
; CHECK-NEXT:    [[RANGE_CHECK3:%.*]] = icmp ult i32 [[TMP0]], [[LEN:%.*]]
; CHECK-NEXT:    br i1 [[RANGE_CHECK3]], label [[BACKEDGE]], label [[FAILED_2:%.*]]
; CHECK:       backedge:
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], -1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[DONE:%.*]], label [[LOOP]]
; CHECK:       done:
; CHECK-NEXT:    [[IV_LCSSA2:%.*]] = phi i32 [ [[IV]], [[BACKEDGE]] ]
; CHECK-NEXT:    ret i32 [[IV_LCSSA2]]
; CHECK:       failed_1:
; CHECK-NEXT:    ret i32 -1
; CHECK:       failed_2:
; CHECK-NEXT:    ret i32 -2
;
entry:
  br label %loop

loop:
  %iv = phi i32 [%start, %entry], [%iv.next, %backedge]
  %zero_check = icmp ne i32 %iv, 0
  br i1 %zero_check, label %range_check_block, label %failed_1

range_check_block:
  %iv.minus.1 = add i32 %iv, -1
  %range_check = icmp ult i32 %iv.minus.1, %len
  br i1 %range_check, label %backedge, label %failed_2

backedge:
  %iv.next = add i32 %iv, -1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %done, label %loop

done:
  ret i32 %iv

failed_1:
  ret i32 -1

failed_2:
  ret i32 -2
}

; TODO: This example is equivalent to @test_simple_case, with only difference that
;       both checks are littered with extra irrelevant conditions. We should be able
;       to replace it with invariant despite this fact.
;       https://alive2.llvm.org/ce/z/G4iW8c
define i32 @test_litter_conditions(i32 %start, i32 %len) {
; CHECK-LABEL: @test_litter_conditions(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[START:%.*]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE:%.*]] ]
; CHECK-NEXT:    [[ZERO_CHECK:%.*]] = icmp ne i32 [[IV]], 0
; CHECK-NEXT:    [[FAKE_1:%.*]] = call i1 @cond()
; CHECK-NEXT:    [[AND_1:%.*]] = and i1 [[ZERO_CHECK]], [[FAKE_1]]
; CHECK-NEXT:    br i1 [[AND_1]], label [[RANGE_CHECK_BLOCK:%.*]], label [[FAILED_1:%.*]]
; CHECK:       range_check_block:
; CHECK-NEXT:    [[IV_MINUS_1:%.*]] = add i32 [[IV]], -1
; CHECK-NEXT:    [[RANGE_CHECK:%.*]] = icmp ult i32 [[IV_MINUS_1]], [[LEN:%.*]]
; CHECK-NEXT:    [[FAKE_2:%.*]] = call i1 @cond()
; CHECK-NEXT:    [[AND_2:%.*]] = and i1 [[RANGE_CHECK]], [[FAKE_2]]
; CHECK-NEXT:    br i1 [[AND_2]], label [[BACKEDGE]], label [[FAILED_2:%.*]]
; CHECK:       backedge:
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], -1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[DONE:%.*]], label [[LOOP]]
; CHECK:       done:
; CHECK-NEXT:    [[IV_LCSSA2:%.*]] = phi i32 [ [[IV]], [[BACKEDGE]] ]
; CHECK-NEXT:    ret i32 [[IV_LCSSA2]]
; CHECK:       failed_1:
; CHECK-NEXT:    ret i32 -1
; CHECK:       failed_2:
; CHECK-NEXT:    ret i32 -2
;
entry:
  br label %loop

loop:
  %iv = phi i32 [%start, %entry], [%iv.next, %backedge]
  %zero_check = icmp ne i32 %iv, 0
  %fake_1 = call i1 @cond()
  %and_1 = and i1 %zero_check, %fake_1
  br i1 %and_1, label %range_check_block, label %failed_1

range_check_block:
  %iv.minus.1 = add i32 %iv, -1
  %range_check = icmp ult i32 %iv.minus.1, %len
  %fake_2 = call i1 @cond()
  %and_2 = and i1 %range_check, %fake_2
  br i1 %and_2, label %backedge, label %failed_2

backedge:
  %iv.next = add i32 %iv, -1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %done, label %loop

done:
  ret i32 %iv

failed_1:
  ret i32 -1

failed_2:
  ret i32 -2
}

; TODO: Same as @test_litter_conditions, but all conditions are computed in
;       header block. Make sure we infer fact from the right context.
;       https://alive2.llvm.org/ce/z/JiD-Pw
define i32 @test_litter_conditions_bad_context(i32 %start, i32 %len) {
; CHECK-LABEL: @test_litter_conditions_bad_context(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[START:%.*]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE:%.*]] ]
; CHECK-NEXT:    [[ZERO_CHECK:%.*]] = icmp ne i32 [[IV]], 0
; CHECK-NEXT:    [[FAKE_1:%.*]] = call i1 @cond()
; CHECK-NEXT:    [[AND_1:%.*]] = and i1 [[ZERO_CHECK]], [[FAKE_1]]
; CHECK-NEXT:    [[IV_MINUS_1:%.*]] = add i32 [[IV]], -1
; CHECK-NEXT:    [[RANGE_CHECK:%.*]] = icmp ult i32 [[IV_MINUS_1]], [[LEN:%.*]]
; CHECK-NEXT:    [[FAKE_2:%.*]] = call i1 @cond()
; CHECK-NEXT:    [[AND_2:%.*]] = and i1 [[RANGE_CHECK]], [[FAKE_2]]
; CHECK-NEXT:    br i1 [[AND_1]], label [[RANGE_CHECK_BLOCK:%.*]], label [[FAILED_1:%.*]]
; CHECK:       range_check_block:
; CHECK-NEXT:    br i1 [[AND_2]], label [[BACKEDGE]], label [[FAILED_2:%.*]]
; CHECK:       backedge:
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], -1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[DONE:%.*]], label [[LOOP]]
; CHECK:       done:
; CHECK-NEXT:    [[IV_LCSSA2:%.*]] = phi i32 [ [[IV]], [[BACKEDGE]] ]
; CHECK-NEXT:    ret i32 [[IV_LCSSA2]]
; CHECK:       failed_1:
; CHECK-NEXT:    ret i32 -1
; CHECK:       failed_2:
; CHECK-NEXT:    ret i32 -2
;
entry:
  br label %loop

loop:
  %iv = phi i32 [%start, %entry], [%iv.next, %backedge]
  %zero_check = icmp ne i32 %iv, 0
  %fake_1 = call i1 @cond()
  %and_1 = and i1 %zero_check, %fake_1
  %iv.minus.1 = add i32 %iv, -1
  %range_check = icmp ult i32 %iv.minus.1, %len
  %fake_2 = call i1 @cond()
  %and_2 = and i1 %range_check, %fake_2
  br i1 %and_1, label %range_check_block, label %failed_1

range_check_block:
  br i1 %and_2, label %backedge, label %failed_2

backedge:
  %iv.next = add i32 %iv, -1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %done, label %loop

done:
  ret i32 %iv

failed_1:
  ret i32 -1

failed_2:
  ret i32 -2
}

; TODO: This test is equivalent to @test_simple_case, with only difference
;       that both checks are merged together into one 'and' check. This
;       should not prevent turning the range check into invariant.
;       https://alive2.llvm.org/ce/z/G-2ERB
define i32 @test_and_conditions(i32 %start, i32 %len) {
; CHECK-LABEL: @test_and_conditions(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[START:%.*]], [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE:%.*]] ]
; CHECK-NEXT:    [[ZERO_CHECK:%.*]] = icmp ne i32 [[IV]], 0
; CHECK-NEXT:    [[IV_MINUS_1:%.*]] = add i32 [[IV]], -1
; CHECK-NEXT:    [[RANGE_CHECK:%.*]] = icmp ult i32 [[IV_MINUS_1]], [[LEN:%.*]]
; CHECK-NEXT:    [[BOTH_CHECKS:%.*]] = and i1 [[ZERO_CHECK]], [[RANGE_CHECK]]
; CHECK-NEXT:    br i1 [[BOTH_CHECKS]], label [[BACKEDGE]], label [[FAILED:%.*]]
; CHECK:       backedge:
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], -1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[DONE:%.*]], label [[LOOP]]
; CHECK:       done:
; CHECK-NEXT:    [[IV_LCSSA1:%.*]] = phi i32 [ [[IV]], [[BACKEDGE]] ]
; CHECK-NEXT:    ret i32 [[IV_LCSSA1]]
; CHECK:       failed:
; CHECK-NEXT:    ret i32 -3
;
entry:
  br label %loop

loop:
  %iv = phi i32 [%start, %entry], [%iv.next, %backedge]
  %zero_check = icmp ne i32 %iv, 0
  %iv.minus.1 = add i32 %iv, -1
  %range_check = icmp ult i32 %iv.minus.1, %len
  %both_checks = and i1 %zero_check, %range_check
  br i1 %both_checks, label %backedge, label %failed

backedge:
  %iv.next = add i32 %iv, -1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %done, label %loop

done:
  ret i32 %iv

failed:
  ret i32 -3
}
