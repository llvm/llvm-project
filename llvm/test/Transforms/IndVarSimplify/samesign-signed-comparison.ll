; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=indvars -S < %s | FileCheck %s

; Make sure that IV starting from zero turns to unsigned.
define i32 @test_01(i32 %start, i32 %end, ptr %p) {
; CHECK-LABEL: define i32 @test_01(
; CHECK-SAME: i32 [[START:%.*]], i32 [[END:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[BACKEDGE:.*]] ]
; CHECK-NEXT:    br i1 true, label %[[CHECKED:.*]], label %[[BAD:.*]]
; CHECK:       [[CHECKED]]:
; CHECK-NEXT:    [[LEN:%.*]] = load i32, ptr [[P]], align 4, !range [[RNG0:![0-9]+]], !invariant.load [[META1:![0-9]+]], !noundef [[META1]]
; CHECK-NEXT:    [[CMP_S:%.*]] = icmp samesign ult i32 [[I]], [[LEN]]
; CHECK-NEXT:    br i1 [[CMP_S]], label %[[BACKEDGE]], label %[[BAD]]
; CHECK:       [[BACKEDGE]]:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[I]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label %[[LOOP]], label %[[GOOD:.*]]
; CHECK:       [[GOOD]]:
; CHECK-NEXT:    ret i32 42
; CHECK:       [[BAD]]:
; CHECK-NEXT:    ret i32 -1
;
entry:
  br label %loop

loop:
  %i = phi i32 [0, %entry], [%iv.next, %backedge]
  %cond_i = icmp sge i32 %i, 0
  br i1 %cond_i, label %checked, label %bad

checked:
  %len = load i32, ptr %p, align 4, !invariant.load !0, !noundef !0, !range !1
  %cmp_s = icmp slt i32 %i, %len
  br i1 %cmp_s, label %backedge, label %bad

backedge:
  %iv.next = add i32 %i, 1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %loop, label %good

good:
  ret i32 42

bad:
  ret i32 -1
}

; Make sure that IV starting from zero turns to unsigned even if comparison is a part of AND.
define i32 @test_02(i32 %start, i32 %end, ptr %p) {
; CHECK-LABEL: define i32 @test_02(
; CHECK-SAME: i32 [[START:%.*]], i32 [[END:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[BACKEDGE:.*]] ]
; CHECK-NEXT:    br i1 true, label %[[CHECKED:.*]], label %[[BAD:.*]]
; CHECK:       [[CHECKED]]:
; CHECK-NEXT:    [[LEN:%.*]] = load i32, ptr [[P]], align 4, !range [[RNG0]], !invariant.load [[META1]], !noundef [[META1]]
; CHECK-NEXT:    [[CMP_S:%.*]] = icmp samesign ult i32 [[I]], [[LEN]]
; CHECK-NEXT:    [[CMP_U:%.*]] = icmp samesign ult i32 [[I]], [[LEN]]
; CHECK-NEXT:    [[CMP_BOTH:%.*]] = and i1 [[CMP_S]], [[CMP_U]]
; CHECK-NEXT:    br i1 [[CMP_BOTH]], label %[[BACKEDGE]], label %[[BAD]]
; CHECK:       [[BACKEDGE]]:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[I]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label %[[LOOP]], label %[[GOOD:.*]]
; CHECK:       [[GOOD]]:
; CHECK-NEXT:    ret i32 42
; CHECK:       [[BAD]]:
; CHECK-NEXT:    ret i32 -1
;
entry:
  br label %loop

loop:
  %i = phi i32 [0, %entry], [%iv.next, %backedge]
  %cond_i = icmp sge i32 %i, 0
  br i1 %cond_i, label %checked, label %bad

checked:
  %len = load i32, ptr %p, align 4, !invariant.load !0, !noundef !0, !range !1
  %cmp_s = icmp slt i32 %i, %len
  %cmp_u = icmp ult i32 %i, %len
  %cmp_both = and i1 %cmp_s, %cmp_u
  br i1 %cmp_both, label %backedge, label %bad

backedge:
  %iv.next = add i32 %i, 1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %loop, label %good

good:
  ret i32 42

bad:
  ret i32 -1
}

; i is known non-negative from dominating condition. Turn comparison to unsigned.
define i32 @test_03(i32 %start, i32 %end, ptr %p) {
; CHECK-LABEL: define i32 @test_03(
; CHECK-SAME: i32 [[START:%.*]], i32 [[END:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ [[START]], %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[BACKEDGE:.*]] ]
; CHECK-NEXT:    [[COND_I:%.*]] = icmp sge i32 [[I]], 0
; CHECK-NEXT:    br i1 [[COND_I]], label %[[CHECKED:.*]], label %[[BAD:.*]]
; CHECK:       [[CHECKED]]:
; CHECK-NEXT:    [[LEN:%.*]] = load i32, ptr [[P]], align 4, !range [[RNG0]], !invariant.load [[META1]], !noundef [[META1]]
; CHECK-NEXT:    [[CMP_S:%.*]] = icmp samesign ult i32 [[I]], [[LEN]]
; CHECK-NEXT:    br i1 [[CMP_S]], label %[[BACKEDGE]], label %[[BAD]]
; CHECK:       [[BACKEDGE]]:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[I]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label %[[LOOP]], label %[[GOOD:.*]]
; CHECK:       [[GOOD]]:
; CHECK-NEXT:    ret i32 42
; CHECK:       [[BAD]]:
; CHECK-NEXT:    ret i32 -1
;
entry:
  br label %loop

loop:
  %i = phi i32 [%start, %entry], [%iv.next, %backedge]
  %cond_i = icmp sge i32 %i, 0
  br i1 %cond_i, label %checked, label %bad

checked:
  %len = load i32, ptr %p, align 4, !invariant.load !0, !noundef !0, !range !1
  %cmp_s = icmp slt i32 %i, %len
  br i1 %cmp_s, label %backedge, label %bad

backedge:
  %iv.next = add i32 %i, 1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %loop, label %good

good:
  ret i32 42

bad:
  ret i32 -1
}

; i is known non-negative from dominating condition. Turn comparison to unsigned even if it's a part of AND.
define i32 @test_04(i32 %start, i32 %end, ptr %p) {
; CHECK-LABEL: define i32 @test_04(
; CHECK-SAME: i32 [[START:%.*]], i32 [[END:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ [[START]], %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[BACKEDGE:.*]] ]
; CHECK-NEXT:    [[COND_I:%.*]] = icmp sge i32 [[I]], 0
; CHECK-NEXT:    br i1 [[COND_I]], label %[[CHECKED:.*]], label %[[BAD:.*]]
; CHECK:       [[CHECKED]]:
; CHECK-NEXT:    [[LEN:%.*]] = load i32, ptr [[P]], align 4, !range [[RNG0]], !invariant.load [[META1]], !noundef [[META1]]
; CHECK-NEXT:    [[CMP_U:%.*]] = icmp samesign ult i32 [[I]], [[LEN]]
; CHECK-NEXT:    [[CMP_U1:%.*]] = icmp samesign ult i32 [[I]], [[LEN]]
; CHECK-NEXT:    [[CMP_BOTH:%.*]] = and i1 [[CMP_U]], [[CMP_U1]]
; CHECK-NEXT:    br i1 [[CMP_BOTH]], label %[[BACKEDGE]], label %[[BAD]]
; CHECK:       [[BACKEDGE]]:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[I]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[LOOP_COND]], label %[[LOOP]], label %[[GOOD:.*]]
; CHECK:       [[GOOD]]:
; CHECK-NEXT:    ret i32 42
; CHECK:       [[BAD]]:
; CHECK-NEXT:    ret i32 -1
;
entry:
  br label %loop

loop:
  %i = phi i32 [%start, %entry], [%iv.next, %backedge]
  %cond_i = icmp sge i32 %i, 0
  br i1 %cond_i, label %checked, label %bad

checked:
  %len = load i32, ptr %p, align 4, !invariant.load !0, !noundef !0, !range !1
  %cmp_s = icmp slt i32 %i, %len
  %cmp_u = icmp ult i32 %i, %len
  %cmp_both = and i1 %cmp_s, %cmp_u
  br i1 %cmp_both, label %backedge, label %bad

backedge:
  %iv.next = add i32 %i, 1
  %loop_cond = call i1 @cond()
  br i1 %loop_cond, label %loop, label %good

good:
  ret i32 42

bad:
  ret i32 -1
}

!0 = !{}
!1 = !{i32 0, i32 10000}

declare i1 @cond() readonly
;.
; CHECK: [[RNG0]] = !{i32 0, i32 10000}
; CHECK: [[META1]] = !{}
;.
