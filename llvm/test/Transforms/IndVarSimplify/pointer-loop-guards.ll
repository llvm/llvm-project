; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -p indvars -S %s | FileCheck %s
; RUN: opt -p indvars  -data-layout='n32:64' -S %s | FileCheck --check-prefix=N32 %s

declare i1 @cond()

define i64 @test_ptr_compare_guard(ptr %start, ptr %end) {
; CHECK-LABEL: define i64 @test_ptr_compare_guard(
; CHECK-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[C_0:%.*]] = icmp eq ptr [[START]], [[END]]
; CHECK-NEXT:    br i1 [[C_0]], label %[[EXIT:.*]], label %[[LOOP_HEADER_PREHEADER:.*]]
; CHECK:       [[LOOP_HEADER_PREHEADER]]:
; CHECK-NEXT:    br label %[[LOOP_HEADER:.*]]
; CHECK:       [[LOOP_HEADER]]:
; CHECK-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ [[START]], %[[LOOP_HEADER_PREHEADER]] ]
; CHECK-NEXT:    [[I64_IV:%.*]] = phi i64 [ [[I64_IV_NEXT:%.*]], %[[LOOP_LATCH]] ], [ 0, %[[LOOP_HEADER_PREHEADER]] ]
; CHECK-NEXT:    [[C_1:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C_1]], label %[[LOOP_LATCH]], label %[[EXIT_LOOPEXIT:.*]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[PTR_IV_NEXT]] = getelementptr i8, ptr [[PTR_IV]], i64 1
; CHECK-NEXT:    [[I64_IV_NEXT]] = add nuw i64 [[I64_IV]], 1
; CHECK-NEXT:    [[C_2:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; CHECK-NEXT:    br i1 [[C_2]], label %[[EXIT_LOOPEXIT]], label %[[LOOP_HEADER]]
; CHECK:       [[EXIT_LOOPEXIT]]:
; CHECK-NEXT:    [[RES_PH:%.*]] = phi i64 [ 0, %[[LOOP_HEADER]] ], [ [[I64_IV]], %[[LOOP_LATCH]] ]
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[RES:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[RES_PH]], %[[EXIT_LOOPEXIT]] ]
; CHECK-NEXT:    ret i64 [[RES]]
;
; N32-LABEL: define i64 @test_ptr_compare_guard(
; N32-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) {
; N32-NEXT:  [[ENTRY:.*]]:
; N32-NEXT:    [[START2:%.*]] = ptrtoint ptr [[START]] to i64
; N32-NEXT:    [[END1:%.*]] = ptrtoint ptr [[END]] to i64
; N32-NEXT:    [[C_0:%.*]] = icmp eq ptr [[START]], [[END]]
; N32-NEXT:    br i1 [[C_0]], label %[[EXIT:.*]], label %[[LOOP_HEADER_PREHEADER:.*]]
; N32:       [[LOOP_HEADER_PREHEADER]]:
; N32-NEXT:    [[TMP0:%.*]] = add i64 [[END1]], -1
; N32-NEXT:    [[TMP1:%.*]] = sub i64 [[TMP0]], [[START2]]
; N32-NEXT:    br label %[[LOOP_HEADER:.*]]
; N32:       [[LOOP_HEADER]]:
; N32-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ [[START]], %[[LOOP_HEADER_PREHEADER]] ]
; N32-NEXT:    [[C_1:%.*]] = call i1 @cond()
; N32-NEXT:    br i1 [[C_1]], label %[[LOOP_LATCH]], label %[[EXIT_LOOPEXIT:.*]]
; N32:       [[LOOP_LATCH]]:
; N32-NEXT:    [[PTR_IV_NEXT]] = getelementptr i8, ptr [[PTR_IV]], i64 1
; N32-NEXT:    [[C_2:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; N32-NEXT:    br i1 [[C_2]], label %[[EXIT_LOOPEXIT]], label %[[LOOP_HEADER]]
; N32:       [[EXIT_LOOPEXIT]]:
; N32-NEXT:    [[RES_PH:%.*]] = phi i64 [ 0, %[[LOOP_HEADER]] ], [ [[TMP1]], %[[LOOP_LATCH]] ]
; N32-NEXT:    br label %[[EXIT]]
; N32:       [[EXIT]]:
; N32-NEXT:    [[RES:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[RES_PH]], %[[EXIT_LOOPEXIT]] ]
; N32-NEXT:    ret i64 [[RES]]
;
entry:
  %c.0 = icmp eq ptr %start, %end
  br i1 %c.0, label %exit, label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %i64.iv = phi i64 [ 0, %entry ], [ %i64.iv.next, %loop.latch ]
  %c.1 = call i1 @cond()
  br i1 %c.1, label %loop.latch, label %exit

loop.latch:
  %ptr.iv.next = getelementptr i8, ptr %ptr.iv, i64 1
  %i64.iv.next = add i64 %i64.iv, 1
  %c.2 = icmp eq ptr %ptr.iv.next, %end
  br i1 %c.2, label %exit, label %loop.header

exit:
  %res = phi i64 [ 0, %entry ], [ %i64.iv, %loop.latch ], [ 0, %loop.header ]
  ret i64 %res
}

define void @test_sub_cmp(ptr align 8 %start, ptr %end) {
; CHECK-LABEL: define void @test_sub_cmp(
; CHECK-SAME: ptr align 8 [[START:%.*]], ptr [[END:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[START_INT:%.*]] = ptrtoint ptr [[START]] to i64
; CHECK-NEXT:    [[END_INT:%.*]] = ptrtoint ptr [[END]] to i64
; CHECK-NEXT:    [[PTR_DIFF:%.*]] = sub i64 [[START_INT]], [[END_INT]]
; CHECK-NEXT:    [[CMP_ENTRY:%.*]] = icmp eq ptr [[START]], [[END]]
; CHECK-NEXT:    br i1 [[CMP_ENTRY]], label %[[EXIT:.*]], label %[[LOOP_HEADER_PREHEADER:.*]]
; CHECK:       [[LOOP_HEADER_PREHEADER]]:
; CHECK-NEXT:    br label %[[LOOP_HEADER:.*]]
; CHECK:       [[LOOP_HEADER]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ 0, %[[LOOP_HEADER_PREHEADER]] ]
; CHECK-NEXT:    [[C_1:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C_1]], label %[[EXIT_EARLY:.*]], label %[[LOOP_LATCH]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw i64 [[IV]], 1
; CHECK-NEXT:    [[CMP_LATCH:%.*]] = icmp ult i64 [[IV_NEXT]], [[PTR_DIFF]]
; CHECK-NEXT:    br i1 [[CMP_LATCH]], label %[[LOOP_HEADER]], label %[[EXIT_LOOPEXIT:.*]]
; CHECK:       [[EXIT_EARLY]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
; N32-LABEL: define void @test_sub_cmp(
; N32-SAME: ptr align 8 [[START:%.*]], ptr [[END:%.*]]) {
; N32-NEXT:  [[ENTRY:.*:]]
; N32-NEXT:    [[START_INT:%.*]] = ptrtoint ptr [[START]] to i64
; N32-NEXT:    [[END_INT:%.*]] = ptrtoint ptr [[END]] to i64
; N32-NEXT:    [[PTR_DIFF:%.*]] = sub i64 [[START_INT]], [[END_INT]]
; N32-NEXT:    [[CMP_ENTRY:%.*]] = icmp eq ptr [[START]], [[END]]
; N32-NEXT:    br i1 [[CMP_ENTRY]], label %[[EXIT:.*]], label %[[LOOP_HEADER_PREHEADER:.*]]
; N32:       [[LOOP_HEADER_PREHEADER]]:
; N32-NEXT:    [[UMAX:%.*]] = call i64 @llvm.umax.i64(i64 [[PTR_DIFF]], i64 1)
; N32-NEXT:    br label %[[LOOP_HEADER:.*]]
; N32:       [[LOOP_HEADER]]:
; N32-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ 0, %[[LOOP_HEADER_PREHEADER]] ]
; N32-NEXT:    [[C_1:%.*]] = call i1 @cond()
; N32-NEXT:    br i1 [[C_1]], label %[[EXIT_EARLY:.*]], label %[[LOOP_LATCH]]
; N32:       [[LOOP_LATCH]]:
; N32-NEXT:    [[IV_NEXT]] = add nuw i64 [[IV]], 1
; N32-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[IV_NEXT]], [[UMAX]]
; N32-NEXT:    br i1 [[EXITCOND]], label %[[LOOP_HEADER]], label %[[EXIT_LOOPEXIT:.*]]
; N32:       [[EXIT_EARLY]]:
; N32-NEXT:    br label %[[EXIT]]
; N32:       [[EXIT_LOOPEXIT]]:
; N32-NEXT:    br label %[[EXIT]]
; N32:       [[EXIT]]:
; N32-NEXT:    ret void
;
entry:
  %start.int = ptrtoint ptr %start to i64
  %end.int = ptrtoint ptr %end to i64
  %ptr.diff = sub i64 %start.int, %end.int
  %cmp.entry = icmp eq ptr %start, %end
  br i1 %cmp.entry, label %exit, label %loop.header

loop.header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]
  %c.1 = call i1 @cond()
  br i1 %c.1, label %exit.early, label %loop.latch

loop.latch:
  %iv.next = add i64 %iv, 1
  %cmp.latch = icmp ult i64 %iv.next, %ptr.diff
  br i1 %cmp.latch, label %loop.header, label %exit

exit.early:
  br label %exit

exit:
  ret void
}


define void @test_ptr_diff_with_assume(ptr align 8 %start, ptr align 8 %end, ptr %P) {
; CHECK-LABEL: define void @test_ptr_diff_with_assume(
; CHECK-SAME: ptr align 8 [[START:%.*]], ptr align 8 [[END:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[START_INT:%.*]] = ptrtoint ptr [[START]] to i64
; CHECK-NEXT:    [[END_INT:%.*]] = ptrtoint ptr [[END]] to i64
; CHECK-NEXT:    [[PTR_DIFF:%.*]] = sub i64 [[START_INT]], [[END_INT]]
; CHECK-NEXT:    [[DIFF_CMP:%.*]] = icmp ult i64 [[PTR_DIFF]], 2
; CHECK-NEXT:    call void @llvm.assume(i1 [[DIFF_CMP]])
; CHECK-NEXT:    [[ENTRY_CMP:%.*]] = icmp eq ptr [[START]], [[END]]
; CHECK-NEXT:    br i1 [[ENTRY_CMP]], label %[[EXIT:.*]], label %[[LOOP_BODY_PREHEADER:.*]]
; CHECK:       [[LOOP_BODY_PREHEADER]]:
; CHECK-NEXT:    br label %[[LOOP_BODY:.*]]
; CHECK:       [[LOOP_BODY]]:
; CHECK-NEXT:    [[TMP0:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 true, label %[[EXIT_LOOPEXIT:.*]], label %[[LOOP_BODY]]
; CHECK:       [[EXIT_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
; N32-LABEL: define void @test_ptr_diff_with_assume(
; N32-SAME: ptr align 8 [[START:%.*]], ptr align 8 [[END:%.*]], ptr [[P:%.*]]) {
; N32-NEXT:  [[ENTRY:.*:]]
; N32-NEXT:    [[START_INT:%.*]] = ptrtoint ptr [[START]] to i64
; N32-NEXT:    [[END_INT:%.*]] = ptrtoint ptr [[END]] to i64
; N32-NEXT:    [[PTR_DIFF:%.*]] = sub i64 [[START_INT]], [[END_INT]]
; N32-NEXT:    [[DIFF_CMP:%.*]] = icmp ult i64 [[PTR_DIFF]], 2
; N32-NEXT:    call void @llvm.assume(i1 [[DIFF_CMP]])
; N32-NEXT:    [[ENTRY_CMP:%.*]] = icmp eq ptr [[START]], [[END]]
; N32-NEXT:    br i1 [[ENTRY_CMP]], label %[[EXIT:.*]], label %[[LOOP_BODY_PREHEADER:.*]]
; N32:       [[LOOP_BODY_PREHEADER]]:
; N32-NEXT:    br label %[[LOOP_BODY:.*]]
; N32:       [[LOOP_BODY]]:
; N32-NEXT:    [[TMP0:%.*]] = call i1 @cond()
; N32-NEXT:    br i1 true, label %[[EXIT_LOOPEXIT:.*]], label %[[LOOP_BODY]]
; N32:       [[EXIT_LOOPEXIT]]:
; N32-NEXT:    br label %[[EXIT]]
; N32:       [[EXIT]]:
; N32-NEXT:    ret void
;
entry:
  %start.int = ptrtoint ptr %start to i64
  %end.int = ptrtoint ptr %end to i64
  %ptr.diff = sub i64 %start.int, %end.int
  %diff.cmp = icmp ult i64 %ptr.diff, 2
  call void @llvm.assume(i1 %diff.cmp)
  %computed.end = getelementptr i8, ptr %start, i64 %ptr.diff
  %entry.cmp = icmp eq ptr %start, %end
  br i1 %entry.cmp, label %exit, label %loop.body

loop.body:
  %iv = phi ptr [ %start, %entry ], [ %iv.next, %loop.body ]
  call i1 @cond()
  %iv.next = getelementptr i8, ptr %iv, i64 1
  %loop.cmp = icmp eq ptr %iv.next, %computed.end
  br i1 %loop.cmp, label %exit, label %loop.body

exit:
  ret void
}
