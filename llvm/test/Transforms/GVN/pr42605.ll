; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=gvn %s -S | FileCheck %s

; PR42605. Check phi-translate won't translate the value number of a call
; to the value of another call with clobber in between.

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@global = dso_local local_unnamed_addr global i32 0, align 4
@.str = private unnamed_addr constant [8 x i8] c"%d, %d\0A\00", align 1

; Function Attrs: nofree nounwind
declare dso_local i32 @printf(ptr nocapture readonly, ...) local_unnamed_addr

; Function Attrs: noinline norecurse nounwind readonly uwtable
define dso_local i32 @_Z3gooi(i32 %i) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local i32 @_Z3gooi(
; CHECK-SAME: i32 [[I:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[T0:%.*]] = load i32, ptr @global, align 4, !tbaa [[INT_TBAA2:![0-9]+]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[T0]], [[I]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %t0 = load i32, ptr @global, align 4, !tbaa !2
  %add = add nsw i32 %t0, %i
  ret i32 %add
}

; Function Attrs: nofree nounwind uwtable
define dso_local void @noclobber() local_unnamed_addr {
; CHECK-LABEL: define dso_local void @noclobber() local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @_Z3gooi(i32 2)
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[CALL]], 5
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[ADD]], 2
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @_Z3gooi(i32 3)
; CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[CALL1]], 5
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[ADD4_PRE_PHI:%.*]] = phi i32 [ [[ADD2]], %[[IF_THEN]] ], [ [[ADD]], %[[ENTRY]] ]
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 3, %[[IF_THEN]] ], [ 2, %[[ENTRY]] ]
; CHECK-NEXT:    [[GLOBAL2_0:%.*]] = phi i32 [ [[ADD2]], %[[IF_THEN]] ], [ [[ADD]], %[[ENTRY]] ]
; CHECK-NEXT:    [[CALL3:%.*]] = tail call i32 @_Z3gooi(i32 [[I_0]])
; CHECK-NEXT:    [[CALL5:%.*]] = tail call i32 (ptr, ...) @printf(ptr @.str, i32 [[GLOBAL2_0]], i32 [[ADD4_PRE_PHI]])
; CHECK-NEXT:    ret void
;
entry:
  %call = tail call i32 @_Z3gooi(i32 2)
  %add = add nsw i32 %call, 5
  %cmp = icmp sgt i32 %add, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call i32 @_Z3gooi(i32 3)
  %add2 = add nsw i32 %call1, 5
  br label %if.end

; Check pre happens after phitranslate.

if.end:                                           ; preds = %if.then, %entry
  %i.0 = phi i32 [ 3, %if.then ], [ 2, %entry ]
  %global2.0 = phi i32 [ %add2, %if.then ], [ %add, %entry ]
  %call3 = tail call i32 @_Z3gooi(i32 %i.0)
  %add4 = add nsw i32 %call3, 5
  %call5 = tail call i32 (ptr, ...) @printf(ptr @.str, i32 %global2.0, i32 %add4)
  ret void
}

; Function Attrs: nofree nounwind uwtable
define dso_local void @hasclobber() local_unnamed_addr {
; CHECK-LABEL: define dso_local void @hasclobber() local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @_Z3gooi(i32 2)
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[CALL]], 5
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[ADD]], 2
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @_Z3gooi(i32 3)
; CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[CALL1]], 5
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 3, %[[IF_THEN]] ], [ 2, %[[ENTRY]] ]
; CHECK-NEXT:    [[GLOBAL2_0:%.*]] = phi i32 [ [[ADD2]], %[[IF_THEN]] ], [ [[ADD]], %[[ENTRY]] ]
; CHECK-NEXT:    store i32 5, ptr @global, align 4, !tbaa [[INT_TBAA2]]
; CHECK-NEXT:    [[CALL3:%.*]] = tail call i32 @_Z3gooi(i32 [[I_0]])
; CHECK-NEXT:    [[ADD4:%.*]] = add nsw i32 [[CALL3]], 5
; CHECK-NEXT:    [[CALL5:%.*]] = tail call i32 (ptr, ...) @printf(ptr @.str, i32 [[GLOBAL2_0]], i32 [[ADD4]])
; CHECK-NEXT:    ret void
;
entry:
  %call = tail call i32 @_Z3gooi(i32 2)
  %add = add nsw i32 %call, 5
  %cmp = icmp sgt i32 %add, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call i32 @_Z3gooi(i32 3)
  %add2 = add nsw i32 %call1, 5
  br label %if.end

; Check no pre happens.

if.end:                                           ; preds = %if.then, %entry
  %i.0 = phi i32 [ 3, %if.then ], [ 2, %entry ]
  %global2.0 = phi i32 [ %add2, %if.then ], [ %add, %entry ]
  store i32 5, ptr @global, align 4, !tbaa !2
  %call3 = tail call i32 @_Z3gooi(i32 %i.0)
  %add4 = add nsw i32 %call3, 5
  %call5 = tail call i32 (ptr, ...) @printf(ptr @.str, i32 %global2.0, i32 %add4)
  ret void
}

attributes #0 = { noinline norecurse nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 10.0.0 (trunk 369798)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C++ TBAA"}
;.
; CHECK: [[INT_TBAA2]] = !{[[META3:![0-9]+]], [[META3]], i64 0}
; CHECK: [[META3]] = !{!"int", [[META4:![0-9]+]], i64 0}
; CHECK: [[META4]] = !{!"omnipotent char", [[META5:![0-9]+]], i64 0}
; CHECK: [[META5]] = !{!"Simple C++ TBAA"}
;.
