; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -S -passes=gvn < %s | FileCheck %s

declare void @willreturn() nounwind willreturn

declare void @capture(ptr)

; Make sure ICF is invalidated when the callee becomes known.

define i64 @test(ptr %p) {
; CHECK-LABEL: define i64 @test(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = alloca [2 x ptr], align 8
; CHECK-NEXT:    [[A2:%.*]] = getelementptr ptr, ptr [[A]], i64 1
; CHECK-NEXT:    call void @capture(ptr [[A]])
; CHECK-NEXT:    br i1 false, label [[IF:%.*]], label [[ENTRY_EXIT_CRIT_EDGE:%.*]]
; CHECK:       entry.exit_crit_edge:
; CHECK-NEXT:    [[RES_PRE:%.*]] = load i64, ptr [[A2]], align 8
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[P1:%.*]] = load ptr, ptr [[A2]], align 8
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[RES:%.*]] = phi i64 [ [[RES_PRE]], [[ENTRY_EXIT_CRIT_EDGE]] ], [ undef, [[IF]] ]
; CHECK-NEXT:    store ptr @willreturn, ptr [[P]], align 8
; CHECK-NEXT:    tail call void @willreturn()
; CHECK-NEXT:    ret i64 [[RES]]
;
entry:
  %a = alloca [2 x ptr], align 8
  %a2 = getelementptr ptr, ptr %a, i64 1
  call void @capture(ptr %a)
  br i1 false, label %if, label %exit

if:
  %p0 = load ptr, ptr %a, align 8
  %p1 = load ptr, ptr %a2, align 8
  br label %exit

exit:
  store ptr @willreturn, ptr %p
  %p2 = load ptr, ptr %a, align 8
  %pgocount.i = load i64, ptr %p2, align 8
  %fn = load ptr, ptr %p
  tail call void %fn()
  %res = load i64, ptr %a2, align 8
  ret i64 %res
}
