; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=gvn -S %s | FileCheck %s

; This test case is extracted from rnflow (fortran) benchmark in polyhedron benchmark suite.
; The function minlst primarily takes two indices (i.e. range), scans backwards in the range
; and returns the firstIV of the minimum value.

define i32 @minlst(i32 %first_index, i32 %last_index, ptr %array) {
; CHECK-LABEL: define i32 @minlst(
; CHECK-SAME: i32 [[FIRST_INDEX:%.*]], i32 [[LAST_INDEX:%.*]], ptr [[ARRAY:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[FIRST_INDEX_SEXT:%.*]] = sext i32 [[FIRST_INDEX]] to i64
; CHECK-NEXT:    [[LAST_INDEX_NEG:%.*]] = sub i32 0, [[LAST_INDEX]]
; CHECK-NEXT:    [[LAST_INDEX_NEG_SEXT:%.*]] = sext i32 [[LAST_INDEX_NEG]] to i64
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[FIRST_INDEX_SEXT]], [[LAST_INDEX_NEG_SEXT]]
; CHECK-NEXT:    [[DIFF:%.*]] = sub nsw i64 0, [[ADD]]
; CHECK-NEXT:    [[FIRST_PTR:%.*]] = getelementptr i8, ptr [[ARRAY]], i64 -8
; CHECK-NEXT:    [[SECOND_PTR:%.*]] = getelementptr i8, ptr [[ARRAY]], i64 -4
; CHECK-NEXT:    [[EARLY_EXIT_COND:%.*]] = icmp slt i64 [[ADD]], 0
; CHECK-NEXT:    br i1 [[EARLY_EXIT_COND]], label %[[LOOP_PREHEADER:.*]], [[DOT_CRIT_EDGE:label %.*]]
; CHECK:       [[LOOP_PREHEADER]]:
; CHECK-NEXT:    [[LAST_INDEX_SEXT:%.*]] = sext i32 [[LAST_INDEX]] to i64
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], %[[LOOP]] ], [ [[LAST_INDEX_SEXT]], %[[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[DEC_IV:%.*]] = phi i64 [ [[DEC:%.*]], %[[LOOP]] ], [ [[DIFF]], %[[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ [[SELECT:%.*]], %[[LOOP]] ], [ [[LAST_INDEX]], %[[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add nsw i64 [[IV]], -1
; CHECK-NEXT:    [[LOAD1_PTR:%.*]] = getelementptr float, ptr [[FIRST_PTR]], i64 [[IV]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[LOAD1_PTR]], align 4
; CHECK-NEXT:    [[INDEX_SEXT:%.*]] = sext i32 [[INDEX]] to i64
; CHECK-NEXT:    [[LOAD2_PTR:%.*]] = getelementptr float, ptr [[SECOND_PTR]], i64 [[INDEX_SEXT]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[LOAD2_PTR]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp contract olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[IV_NEXT_TRUNC:%.*]] = trunc nsw i64 [[IV_NEXT]] to i32
; CHECK-NEXT:    [[SELECT]] = select i1 [[CMP]], i32 [[IV_NEXT_TRUNC]], i32 [[INDEX]]
; CHECK-NEXT:    [[DEC]] = add nsw i64 [[DEC_IV]], -1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp sgt i64 [[DEC_IV]], 1
; CHECK-NEXT:    br i1 [[LOOP_COND]], label %[[LOOP]], [[DOT_CRIT_EDGE]]
; CHECK:       [[__CRIT_EDGE:.*:]]
; CHECK-NEXT:    [[LAST_INDEX_RET:%.*]] = phi i32 [ [[SELECT]], %[[LOOP]] ], [ [[LAST_INDEX]], %[[ENTRY]] ]
; CHECK-NEXT:    ret i32 [[LAST_INDEX_RET]]
;
entry:
  %first_index_sext = sext i32 %first_index to i64
  %last_index_neg = sub i32 0, %last_index
  %last_index_neg_sext = sext i32 %last_index_neg to i64
  %add = add nsw i64 %first_index_sext, %last_index_neg_sext
  %diff = sub nsw i64 0, %add
  %first_ptr = getelementptr i8, ptr %array, i64 -8
  %second_ptr = getelementptr i8, ptr %array, i64 -4
  %early_exit_cond = icmp slt i64 %add, 0
  br i1 %early_exit_cond, label %loop.preheader, label %._crit_edge

loop.preheader:                                 ; preds = %entry
  %last_index_sext = sext i32 %last_index to i64
  br label %loop

loop:                                           ; preds = %loop.preheader, %loop
  %iv = phi i64 [%iv.next, %loop], [ %last_index_sext, %loop.preheader ]
  %dec_iv = phi i64 [ %dec, %loop ], [ %diff, %loop.preheader ]
  %index = phi i32 [ %select, %loop ], [ %last_index, %loop.preheader ]
  %iv.next = add nsw i64 %iv, -1
  %load1_ptr = getelementptr float, ptr %first_ptr, i64 %iv
  %load1 = load float, ptr %load1_ptr, align 4
  %index_sext = sext i32 %index to i64
  %load2_ptr = getelementptr float, ptr %second_ptr, i64 %index_sext
  %load2 = load float, ptr %load2_ptr, align 4
  %cmp = fcmp contract olt float %load1, %load2
  %iv.next.trunc = trunc nsw i64 %iv.next to i32
  %select = select i1 %cmp, i32 %iv.next.trunc, i32 %index
  %dec = add nsw i64 %dec_iv, -1
  %loop_cond = icmp sgt i64 %dec_iv, 1
  br i1 %loop_cond, label %loop, label %._crit_edge

._crit_edge:                                      ; preds = %loop, %entry
  %last_index_ret = phi i32 [ %select, %loop ], [ %last_index, %entry ]
  ret i32 %last_index_ret
}
