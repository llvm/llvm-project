; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=gvn -S | FileCheck %s
;
; Tests for assume-based ballot optimizations
; This optimization recognizes patterns like:
;   assume(ballot(cmp) == -1) -> cmp is true on all lanes
;   assume(ballot(cmp) == 0)  -> cmp is false on all lanes

declare void @llvm.assume(i1)
declare i64 @llvm.amdgcn.ballot.i64(i1)
declare i32 @llvm.amdgcn.ballot.i32(i1)

; ============================================================================
; POSITIVE CASES
; ============================================================================

; Test 1: assume(ballot(cmp) == -1) -> cmp replaced with true
define amdgpu_kernel void @assume_ballot_all_lanes_i64(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_all_lanes_i64(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    store i32 1, ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    store i32 0, ptr addrspace(1) [[OUT]], align 4
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 %ballot, -1
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  store i32 1, ptr addrspace(1) %out
  ret void
bar:
  store i32 0, ptr addrspace(1) %out
  ret void
}

; Test 2: assume(ballot(cmp) == 0) -> cmp replaced with false
define amdgpu_kernel void @assume_ballot_no_lanes_i64(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_no_lanes_i64(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[NONE:%.*]] = icmp eq i64 [[BALLOT]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[NONE]])
; CHECK-NEXT:    store i32 0, ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %none = icmp eq i64 %ballot, 0
  call void @llvm.assume(i1 %none)
  %sel = select i1 %cmp, i32 1, i32 0
  store i32 %sel, ptr addrspace(1) %out
  ret void
}

; Test 3: ballot(cmp) == ballot(true) -> cmp replaced with true (EXEC MASK)
define amdgpu_kernel void @assume_ballot_exec_mask_ballot_true(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_exec_mask_ballot_true(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[EXEC:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], [[EXEC]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %exec = call i64 @llvm.amdgcn.ballot.i64(i1 true)
  %all = icmp eq i64 %ballot, %exec
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 4: assume(ballot(cmp) == -1) -> cmp replaced with true (wave32 variant with ballot.i32)
define amdgpu_kernel void @assume_ballot_all_lanes_i32(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_all_lanes_i32(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i32 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i32 @llvm.amdgcn.ballot.i32(i1 %cmp)
  %all = icmp eq i32 %ballot, -1
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 5: assume(ballot(cmp) == 0) -> cmp replaced with false (wave32 variant with ballot.i32)
define amdgpu_kernel void @assume_ballot_no_lanes_i32(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_no_lanes_i32(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 [[CMP]])
; CHECK-NEXT:    [[NONE:%.*]] = icmp eq i32 [[BALLOT]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[NONE]])
; CHECK-NEXT:    br i1 false, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i32 @llvm.amdgcn.ballot.i32(i1 %cmp)
  %none = icmp eq i32 %ballot, 0
  call void @llvm.assume(i1 %none)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 6: assume(ballot(cmp) == -1) -> cmp replaced with true (EXEC MASK - wave32 variant with ballot.i32)
define amdgpu_kernel void @assume_ballot_exec_mask_wave32(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_exec_mask_wave32(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 [[CMP]])
; CHECK-NEXT:    [[EXEC:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 true)
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i32 [[BALLOT]], [[EXEC]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i32 @llvm.amdgcn.ballot.i32(i1 %cmp)
  %exec = call i32 @llvm.amdgcn.ballot.i32(i1 true)
  %all = icmp eq i32 %ballot, %exec
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 7: Dominance -> only dominated uses replaced with truth values
define amdgpu_kernel void @assume_ballot_dominance(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_dominance(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[USE_BEFORE:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    store i32 [[USE_BEFORE]], ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    [[OUT2:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 1
; CHECK-NEXT:    store i32 1, ptr addrspace(1) [[OUT2]], align 4
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %use_before = zext i1 %cmp to i32
  store i32 %use_before, ptr addrspace(1) %out
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 %ballot, -1
  call void @llvm.assume(i1 %all)
  %use_after = zext i1 %cmp to i32
  %out2 = getelementptr i32, ptr addrspace(1) %out, i64 1
  store i32 %use_after, ptr addrspace(1) %out2
  ret void
}

; Test 8: Swapped operands in icmp -> cmp replaced with true
define amdgpu_kernel void @assume_ballot_swapped(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_swapped(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 -1, [[BALLOT]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 -1, %ballot
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 9: Swapped operands in icmp -> cmp replaced with true (EXEC MASK)
define amdgpu_kernel void @assume_ballot_exec_mask_swapped(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_exec_mask_swapped(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[EXEC:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[EXEC]], [[BALLOT]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %exec = call i64 @llvm.amdgcn.ballot.i64(i1 true)
  %all = icmp eq i64 %exec, %ballot
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 10: Multiple uses of cmp after assume -> uses 1 & 2 replaced with truth values
define amdgpu_kernel void @assume_ballot_multiple_uses(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_multiple_uses(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    store i32 1, ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    [[OUT2:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 1
; CHECK-NEXT:    store i32 10, ptr addrspace(1) [[OUT2]], align 4
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 %ballot, -1
  call void @llvm.assume(i1 %all)
  %use1 = zext i1 %cmp to i32
  store i32 %use1, ptr addrspace(1) %out
  %use2 = select i1 %cmp, i32 10, i32 20
  %out2 = getelementptr i32, ptr addrspace(1) %out, i64 1
  store i32 %use2, ptr addrspace(1) %out2
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 11: Multiple uses of cmp after assume -> uses 1 & 2 replaced with truth values (EXEC MASK)
define amdgpu_kernel void @assume_ballot_exec_mask_multiple_uses(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_exec_mask_multiple_uses(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[EXEC:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], [[EXEC]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    [[USE1:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    store i32 [[USE1]], ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    [[USE2:%.*]] = select i1 [[CMP]], i32 10, i32 20
; CHECK-NEXT:    [[OUT2:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 1
; CHECK-NEXT:    store i32 [[USE2]], ptr addrspace(1) [[OUT2]], align 4
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %exec = call i64 @llvm.amdgcn.ballot.i64(i1 true)
  %all = icmp eq i64 %ballot, %exec
  call void @llvm.assume(i1 %all)
  %use1 = zext i1 %cmp to i32
  store i32 %use1, ptr addrspace(1) %out
  %use2 = select i1 %cmp, i32 10, i32 20
  %out2 = getelementptr i32, ptr addrspace(1) %out, i64 1
  store i32 %use2, ptr addrspace(1) %out2
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; ============================================================================
; NEGATIVE CASES
; ============================================================================

; Test 1: assume(ballot != -1) -> cmp should not be transformed (cmp is false in atleast one lane)
define amdgpu_kernel void @assume_ballot_ne_negative(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_ne_negative(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[NOT_ALL:%.*]] = icmp ne i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[NOT_ALL]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %not_all = icmp ne i64 %ballot, -1
  call void @llvm.assume(i1 %not_all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 2: assume(ballot != 0) -> cmp should not be transformed (cmp is true in atleast one lane)
define amdgpu_kernel void @assume_ballot_ne_zero_negative(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_ne_zero_negative(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[SOME:%.*]] = icmp ne i64 [[BALLOT]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[SOME]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %some = icmp ne i64 %ballot, 0
  call void @llvm.assume(i1 %some)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 3: ballot(cmp) == ballot(false) -> cmp should not be transformed (RHS is not EXEC MASK)
define amdgpu_kernel void @assume_ballot_not_exec_mask(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_not_exec_mask(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[NOT_EXEC:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 false)
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i64 [[BALLOT]], [[NOT_EXEC]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[MATCHES]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %not_exec = call i64 @llvm.amdgcn.ballot.i64(i1 false)
  %matches = icmp eq i64 %ballot, %not_exec
  call void @llvm.assume(i1 %matches)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 4: Constant as mask value (other than -1 or 0) -> cmp should not be transformed
define amdgpu_kernel void @assume_ballot_constant_mask(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_constant_mask(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i64 [[BALLOT]], 255
; CHECK-NEXT:    call void @llvm.assume(i1 [[MATCHES]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %matches = icmp eq i64 %ballot, 255  ; partial mask
  call void @llvm.assume(i1 %matches)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 5: Arbitrary mask -> cmp should not be transformed
define amdgpu_kernel void @assume_ballot_arbitrary_mask(i32 %x, i64 %mask, ptr addrspace(1) %out) {
; CHECK-LABEL: @assume_ballot_arbitrary_mask(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i64 [[BALLOT]], [[MASK:%.*]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[MATCHES]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %matches = icmp eq i64 %ballot, %mask
  call void @llvm.assume(i1 %matches)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}
