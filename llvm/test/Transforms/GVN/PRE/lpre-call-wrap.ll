; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=gvn -enable-load-pre < %s | FileCheck %s --check-prefixes=CHECK,MDEP
; RUN: opt -S -passes='gvn<memoryssa>' -enable-load-pre < %s | FileCheck %s --check-prefixes=CHECK,MSSA
;
; Make sure the load in bb3.backedge is removed and moved into bb1 after the
; call.  This makes the non-call case faster.
;
; This test is derived from this C++ code (GCC PR 37810):
; void g();
; struct A {
;   int n; int m;
;   A& operator++(void) { ++n; if (n == m) g(); return *this; }
;   A() : n(0), m(0) { }
;   friend bool operator!=(A const& a1, A const& a2) { return a1.n != a2.n; }
; };
; void testfunction(A& iter) { A const end; while (iter != end) ++iter; }
;
target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128"
  %struct.A = type { i32, i32 }

define void @_Z12testfunctionR1A(ptr %iter) {
; MDEP-LABEL: @_Z12testfunctionR1A(
; MDEP-NEXT:  entry:
; MDEP-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ITER:%.*]], align 4
; MDEP-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[TMP0]], 0
; MDEP-NEXT:    br i1 [[TMP1]], label [[RETURN:%.*]], label [[BB_NPH:%.*]]
; MDEP:       bb.nph:
; MDEP-NEXT:    [[TMP2:%.*]] = getelementptr [[STRUCT_A:%.*]], ptr [[ITER]], i32 0, i32 1
; MDEP-NEXT:    br label [[BB:%.*]]
; MDEP:       bb:
; MDEP-NEXT:    [[DOTRLE:%.*]] = phi i32 [ [[TMP0]], [[BB_NPH]] ], [ [[TMP6:%.*]], [[BB3_BACKEDGE:%.*]] ]
; MDEP-NEXT:    [[TMP3:%.*]] = add i32 [[DOTRLE]], 1
; MDEP-NEXT:    store i32 [[TMP3]], ptr [[ITER]], align 4
; MDEP-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP2]], align 4
; MDEP-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[TMP3]], [[TMP4]]
; MDEP-NEXT:    br i1 [[TMP5]], label [[BB1:%.*]], label [[BB3_BACKEDGE]]
; MDEP:       bb1:
; MDEP-NEXT:    tail call void @_Z1gv()
; MDEP-NEXT:    [[DOTPRE:%.*]] = load i32, ptr [[ITER]], align 4
; MDEP-NEXT:    br label [[BB3_BACKEDGE]]
; MDEP:       bb3.backedge:
; MDEP-NEXT:    [[TMP6]] = phi i32 [ [[DOTPRE]], [[BB1]] ], [ [[TMP3]], [[BB]] ]
; MDEP-NEXT:    [[TMP7:%.*]] = icmp eq i32 [[TMP6]], 0
; MDEP-NEXT:    br i1 [[TMP7]], label [[RETURN]], label [[BB]]
; MDEP:       return:
; MDEP-NEXT:    ret void
;
; MSSA-LABEL: @_Z12testfunctionR1A(
; MSSA-NEXT:  entry:
; MSSA-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ITER:%.*]], align 4
; MSSA-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[TMP0]], 0
; MSSA-NEXT:    br i1 [[TMP1]], label [[RETURN:%.*]], label [[BB_NPH:%.*]]
; MSSA:       bb.nph:
; MSSA-NEXT:    [[TMP2:%.*]] = getelementptr [[STRUCT_A:%.*]], ptr [[ITER]], i32 0, i32 1
; MSSA-NEXT:    br label [[BB:%.*]]
; MSSA:       bb:
; MSSA-NEXT:    [[DOTRLE:%.*]] = phi i32 [ [[TMP0]], [[BB_NPH]] ], [ [[TMP6:%.*]], [[BB3_BACKEDGE:%.*]] ]
; MSSA-NEXT:    [[TMP3:%.*]] = add i32 [[DOTRLE]], 1
; MSSA-NEXT:    store i32 [[TMP3]], ptr [[ITER]], align 4
; MSSA-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP2]], align 4
; MSSA-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[TMP3]], [[TMP4]]
; MSSA-NEXT:    br i1 [[TMP5]], label [[BB1:%.*]], label [[BB3_BACKEDGE]]
; MSSA:       bb1:
; MSSA-NEXT:    tail call void @_Z1gv()
; MSSA-NEXT:    br label [[BB3_BACKEDGE]]
; MSSA:       bb3.backedge:
; MSSA-NEXT:    [[TMP6]] = load i32, ptr [[ITER]], align 4
; MSSA-NEXT:    [[TMP7:%.*]] = icmp eq i32 [[TMP6]], 0
; MSSA-NEXT:    br i1 [[TMP7]], label [[RETURN]], label [[BB]]
; MSSA:       return:
; MSSA-NEXT:    ret void
;
entry:
  %0 = getelementptr %struct.A, ptr %iter, i32 0, i32 0		; <ptr> [#uses=3]
  %1 = load i32, ptr %0, align 4		; <i32> [#uses=2]
  %2 = icmp eq i32 %1, 0		; <i1> [#uses=1]
  br i1 %2, label %return, label %bb.nph

bb.nph:		; preds = %entry
  %3 = getelementptr %struct.A, ptr %iter, i32 0, i32 1		; <ptr> [#uses=1]
  br label %bb

bb:		; preds = %bb3.backedge, %bb.nph
  %.rle = phi i32 [ %1, %bb.nph ], [ %7, %bb3.backedge ]		; <i32> [#uses=1]
  %4 = add i32 %.rle, 1		; <i32> [#uses=2]
  store i32 %4, ptr %0, align 4
  %5 = load i32, ptr %3, align 4		; <i32> [#uses=1]
  %6 = icmp eq i32 %4, %5		; <i1> [#uses=1]
  br i1 %6, label %bb1, label %bb3.backedge

bb1:		; preds = %bb
  tail call void @_Z1gv()
  br label %bb3.backedge

bb3.backedge:		; preds = %bb, %bb1
  %7 = load i32, ptr %0, align 4		; <i32> [#uses=2]
  %8 = icmp eq i32 %7, 0		; <i1> [#uses=1]
  br i1 %8, label %return, label %bb

return:		; preds = %bb3.backedge, %entry
  ret void
}

declare void @_Z1gv()
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
