; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes='require<phi-values>,gvn' -S < %s | FileCheck %s

declare noalias i8* @malloc(i64)

; Detecting that %s is fully redundant should let us detect that %w is partially
; redundant.
define void @fn1(i32** noalias %start, i32* %width, i32 %h) {
; CHECK-LABEL: @fn1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = tail call noalias i8* @malloc(i64 1024)
; CHECK-NEXT:    [[CALL_CAST:%.*]] = bitcast i8* [[CALL]] to i32*
; CHECK-NEXT:    store i32* [[CALL_CAST]], i32** [[START:%.*]], align 8
; CHECK-NEXT:    br label [[PREHEADER:%.*]]
; CHECK:       preheader:
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 1, [[H:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[PREHEADER_BODY_CRIT_EDGE:%.*]], label [[EXIT:%.*]]
; CHECK:       preheader.body_crit_edge:
; CHECK-NEXT:    [[W_PRE:%.*]] = load i32, i32* [[WIDTH:%.*]], align 8
; CHECK-NEXT:    br label [[BODY:%.*]]
; CHECK:       body:
; CHECK-NEXT:    [[J:%.*]] = phi i32 [ 0, [[PREHEADER_BODY_CRIT_EDGE]] ], [ [[J_NEXT:%.*]], [[BODY]] ]
; CHECK-NEXT:    store i32 0, i32* [[CALL_CAST]], align 4
; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i32 [[J]], 1
; CHECK-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[J_NEXT]], [[W_PRE]]
; CHECK-NEXT:    br i1 [[CMP3]], label [[BODY]], label [[PREHEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %call = tail call noalias i8* @malloc(i64 1024)
  %call.cast = bitcast i8* %call to i32*
  store i32* %call.cast, i32** %start, align 8
  br label %preheader

preheader:
  %cmp = icmp slt i32 1, %h
  br i1 %cmp, label %body, label %exit

body:
  %j = phi i32 [ 0, %preheader ], [ %j.next, %body ]
  %s = load i32*, i32** %start, align 8
  %idx = getelementptr inbounds i32, i32* %s, i64 0
  store i32 0, i32* %idx, align 4
  %j.next = add nuw nsw i32 %j, 1
  %w = load i32, i32* %width, align 8
  %cmp3 = icmp slt i32 %j.next, %w
  br i1 %cmp3, label %body, label %preheader

exit:
  ret void
}

; %s is fully redundant but has more than one available value. Detecting that
; %w is partially redundant requires alias analysis that can analyze those
; values.
define void @fn2(i32** noalias %start, i32* %width, i32 %h, i32 %arg) {
; CHECK-LABEL: @fn2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = tail call noalias i8* @malloc(i64 1024)
; CHECK-NEXT:    [[CALL_CAST:%.*]] = bitcast i8* [[CALL]] to i32*
; CHECK-NEXT:    [[CMP1:%.*]] = icmp slt i32 [[ARG:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK:       if:
; CHECK-NEXT:    store i32* [[CALL_CAST]], i32** [[START:%.*]], align 8
; CHECK-NEXT:    br label [[PREHEADER:%.*]]
; CHECK:       else:
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i32, i32* [[CALL_CAST]], i32 [[ARG]]
; CHECK-NEXT:    store i32* [[GEP]], i32** [[START]], align 8
; CHECK-NEXT:    br label [[PREHEADER]]
; CHECK:       preheader:
; CHECK-NEXT:    [[S:%.*]] = phi i32* [ [[S]], [[BODY:%.*]] ], [ [[GEP]], [[ELSE]] ], [ [[CALL_CAST]], [[IF]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 1, [[H:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[PREHEADER_BODY_CRIT_EDGE:%.*]], label [[EXIT:%.*]]
; CHECK:       preheader.body_crit_edge:
; CHECK-NEXT:    [[W_PRE:%.*]] = load i32, i32* [[WIDTH:%.*]], align 8
; CHECK-NEXT:    br label [[BODY]]
; CHECK:       body:
; CHECK-NEXT:    [[J:%.*]] = phi i32 [ 0, [[PREHEADER_BODY_CRIT_EDGE]] ], [ [[J_NEXT:%.*]], [[BODY]] ]
; CHECK-NEXT:    store i32 0, i32* [[S]], align 4
; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i32 [[J]], 1
; CHECK-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[J_NEXT]], [[W_PRE]]
; CHECK-NEXT:    br i1 [[CMP3]], label [[BODY]], label [[PREHEADER]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %call = tail call noalias i8* @malloc(i64 1024)
  %call.cast = bitcast i8* %call to i32*
  %cmp1 = icmp slt i32 %arg, 0
  br i1 %cmp1, label %if, label %else

if:
  store i32* %call.cast, i32** %start, align 8
  br label %preheader

else:
  %gep = getelementptr inbounds i32, i32* %call.cast, i32 %arg
  store i32* %gep, i32** %start, align 8
  br label %preheader

preheader:
  %cmp = icmp slt i32 1, %h
  br i1 %cmp, label %body, label %exit

body:
  %j = phi i32 [ 0, %preheader ], [ %j.next, %body ]
  %s = load i32*, i32** %start, align 8
  %idx = getelementptr inbounds i32, i32* %s, i64 0
  store i32 0, i32* %idx, align 4
  %j.next = add nuw nsw i32 %j, 1
  %w = load i32, i32* %width, align 8
  %cmp3 = icmp slt i32 %j.next, %w
  br i1 %cmp3, label %body, label %preheader

exit:
  ret void
}
