; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=gvn -S < %s | FileCheck %s

define void @test_gvn_min_pattern(ptr %0) {
; CHECK-LABEL: define void @test_gvn_min_pattern(
; CHECK-SAME: ptr [[TMP0:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[HOIST_GEP1:%.*]] = getelementptr float, ptr [[TMP0]], i64 1
; CHECK-NEXT:    [[HOIST_GEP2:%.*]] = getelementptr i8, ptr [[HOIST_GEP1]], i64 -4
; CHECK-NEXT:    [[HOISTED_LOAD:%.*]] = load float, ptr [[HOIST_GEP2]], align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[KNOWN_MIN:%.*]] = phi float [ [[HOISTED_LOAD]], %[[ENTRY]] ], [ [[CURRENT_MIN:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_I:%.*]] = phi i64 [ 1, %[[ENTRY]] ], [ [[INDVARS_IV_NEXT_I:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[LOOP_COUNTER:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[LOOP_COUNTER_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ 1, %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_NEXT_I]] = add nsw i64 [[INDVARS_IV_I]], -1
; CHECK-NEXT:    [[PTR_FLOAT_IV:%.*]] = getelementptr float, ptr [[TMP0]], i64 [[INDVARS_IV_I]]
; CHECK-NEXT:    [[PTR_FIRST_LOAD:%.*]] = getelementptr i8, ptr [[PTR_FLOAT_IV]], i64 -8
; CHECK-NEXT:    [[VAL_FIRST:%.*]] = load float, ptr [[PTR_FIRST_LOAD]], align 4
; CHECK-NEXT:    [[MIN_IDX_EXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[PTR_FLOAT_MIN:%.*]] = getelementptr float, ptr [[TMP0]], i64 [[MIN_IDX_EXT]]
; CHECK-NEXT:    [[PTR_SECOND_LOAD:%.*]] = getelementptr i8, ptr [[PTR_FLOAT_MIN]], i64 -4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp contract olt float [[VAL_FIRST]], [[KNOWN_MIN]]
; CHECK-NEXT:    [[NEXT_IDX_TRUNC:%.*]] = trunc nsw i64 [[INDVARS_IV_NEXT_I]] to i32
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[NEXT_IDX_TRUNC]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[LOOP_COUNTER_NEXT]] = add nsw i64 [[LOOP_COUNTER]], -1
; CHECK-NEXT:    [[LOOP_CONTINUE:%.*]] = icmp samesign ugt i64 [[LOOP_COUNTER]], 1
; CHECK-NEXT:    [[CURRENT_MIN]] = select i1 [[CMP]], float [[VAL_FIRST]], float [[KNOWN_MIN]]
; CHECK-NEXT:    br i1 [[LOOP_CONTINUE]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:                                         ; preds = %loop, %entry
  %indvars.iv.i = phi i64 [ 1, %entry ], [ %indvars.iv.next.i, %loop ]
  %loop.counter = phi i64 [ 0, %entry ], [ %loop.counter.next, %loop ]
  %min.idx = phi i32 [ 1, %entry ], [ %min.idx.next, %loop ]
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, -1
  %ptr.float.iv = getelementptr float, ptr %0, i64 %indvars.iv.i
  %ptr.first.load = getelementptr i8, ptr %ptr.float.iv, i64 -8
  %val.first = load float, ptr %ptr.first.load, align 4
  %min.idx.ext = sext i32 %min.idx to i64
  %ptr.float.min = getelementptr float, ptr %0, i64 %min.idx.ext
  %ptr.second.load = getelementptr i8, ptr %ptr.float.min, i64 -4
  %val.current.min = load float, ptr %ptr.second.load, align 4
  %cmp = fcmp contract olt float %val.first, %val.current.min
  %next.idx.trunc = trunc nsw i64 %indvars.iv.next.i to i32
  %min.idx.next = select i1 %cmp, i32 %next.idx.trunc, i32 %min.idx
  %loop.counter.next = add nsw i64 %loop.counter, -1
  %loop.continue = icmp samesign ugt i64 %loop.counter, 1
  br i1 %loop.continue, label %loop, label %exit

exit:
  ret void
}
