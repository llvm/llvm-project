; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=gvn -S < %s | FileCheck %s

; Test the minimum finding pattern.
; The following test case is extracted from rnflow app in Polyhedron benchmark suite.
define void @test_gvn_min_pattern(ptr %0, i32 %initial_min_idx) {
; CHECK-LABEL: define void @test_gvn_min_pattern(
; CHECK-SAME: ptr [[TMP0:%.*]], i32 [[INITIAL_MIN_IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[HOIST_SEXT:%.*]] = sext i32 [[INITIAL_MIN_IDX]] to i64
; CHECK-NEXT:    [[HOIST_GEP1:%.*]] = getelementptr float, ptr [[TMP0]], i64 [[HOIST_SEXT]]
; CHECK-NEXT:    [[HOIST_GEP2:%.*]] = getelementptr i8, ptr [[HOIST_GEP1]], i64 -4
; CHECK-NEXT:    [[HOISTED_LOAD:%.*]] = load float, ptr [[HOIST_GEP2]], align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[KNOWN_MIN:%.*]] = phi float [ [[HOISTED_LOAD]], %[[ENTRY]] ], [ [[CURRENT_MIN:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_I:%.*]] = phi i64 [ 1, %[[ENTRY]] ], [ [[INDVARS_IV_NEXT_I:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[LOOP_COUNTER:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[LOOP_COUNTER_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ [[INITIAL_MIN_IDX]], %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_NEXT_I]] = add nsw i64 [[INDVARS_IV_I]], -1
; CHECK-NEXT:    [[PTR_FLOAT_IV:%.*]] = getelementptr float, ptr [[TMP0]], i64 [[INDVARS_IV_I]]
; CHECK-NEXT:    [[PTR_FIRST_LOAD:%.*]] = getelementptr i8, ptr [[PTR_FLOAT_IV]], i64 -8
; CHECK-NEXT:    [[VAL_FIRST:%.*]] = load float, ptr [[PTR_FIRST_LOAD]], align 4
; CHECK-NEXT:    [[MIN_IDX_EXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[PTR_FLOAT_MIN:%.*]] = getelementptr float, ptr [[TMP0]], i64 [[MIN_IDX_EXT]]
; CHECK-NEXT:    [[PTR_SECOND_LOAD:%.*]] = getelementptr i8, ptr [[PTR_FLOAT_MIN]], i64 -4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp contract olt float [[VAL_FIRST]], [[KNOWN_MIN]]
; CHECK-NEXT:    [[NEXT_IDX_TRUNC:%.*]] = trunc nsw i64 [[INDVARS_IV_NEXT_I]] to i32
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[NEXT_IDX_TRUNC]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[LOOP_COUNTER_NEXT]] = add nsw i64 [[LOOP_COUNTER]], -1
; CHECK-NEXT:    [[LOOP_CONTINUE:%.*]] = icmp samesign ugt i64 [[LOOP_COUNTER]], 1
; CHECK-NEXT:    [[CURRENT_MIN]] = select i1 [[CMP]], float [[VAL_FIRST]], float [[KNOWN_MIN]]
; CHECK-NEXT:    br i1 [[LOOP_CONTINUE]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:                                         ; preds = %loop, %entry
  %indvars.iv.i = phi i64 [ 1, %entry ], [ %indvars.iv.next.i, %loop ]
  %loop.counter = phi i64 [ 0, %entry ], [ %loop.counter.next, %loop ]
  %min.idx = phi i32 [ %initial_min_idx, %entry ], [ %min.idx.next, %loop ]
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, -1
  %ptr.float.iv = getelementptr float, ptr %0, i64 %indvars.iv.i
  %ptr.first.load = getelementptr i8, ptr %ptr.float.iv, i64 -8
  %val.first = load float, ptr %ptr.first.load, align 4
  %min.idx.ext = sext i32 %min.idx to i64
  %ptr.float.min = getelementptr float, ptr %0, i64 %min.idx.ext
  %ptr.second.load = getelementptr i8, ptr %ptr.float.min, i64 -4
  %val.current.min = load float, ptr %ptr.second.load, align 4
  %cmp = fcmp contract olt float %val.first, %val.current.min
  %next.idx.trunc = trunc nsw i64 %indvars.iv.next.i to i32
  %min.idx.next = select i1 %cmp, i32 %next.idx.trunc, i32 %min.idx
  %loop.counter.next = add nsw i64 %loop.counter, -1
  %loop.continue = icmp samesign ugt i64 %loop.counter, 1
  br i1 %loop.continue, label %loop, label %exit

exit:
  ret void
}

; Positive test: Minimum finding pattern with i32 loads.
define void @test_gvn_min_pattern_i32(ptr %arr, i32 %initial_min_idx) {
; CHECK-LABEL: define void @test_gvn_min_pattern_i32(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[INITIAL_MIN_IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[HOIST_SEXT:%.*]] = sext i32 [[INITIAL_MIN_IDX]] to i64
; CHECK-NEXT:    [[HOIST_GEP1:%.*]] = getelementptr i32, ptr [[ARR]], i64 [[HOIST_SEXT]]
; CHECK-NEXT:    [[HOIST_GEP2:%.*]] = getelementptr i8, ptr [[HOIST_GEP1]], i64 -4
; CHECK-NEXT:    [[HOISTED_LOAD:%.*]] = load i32, ptr [[HOIST_GEP2]], align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[KNOWN_MIN:%.*]] = phi i32 [ [[HOISTED_LOAD]], %[[ENTRY]] ], [ [[CURRENT_MIN:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_I:%.*]] = phi i64 [ 1, %[[ENTRY]] ], [ [[INDVARS_IV_NEXT_I:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[LOOP_COUNTER:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[LOOP_COUNTER_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ [[INITIAL_MIN_IDX]], %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_NEXT_I]] = add nsw i64 [[INDVARS_IV_I]], -1
; CHECK-NEXT:    [[PTR_FLOAT_IV:%.*]] = getelementptr i32, ptr [[ARR]], i64 [[INDVARS_IV_I]]
; CHECK-NEXT:    [[PTR_FIRST_LOAD:%.*]] = getelementptr i8, ptr [[PTR_FLOAT_IV]], i64 -8
; CHECK-NEXT:    [[VAL_FIRST:%.*]] = load i32, ptr [[PTR_FIRST_LOAD]], align 4
; CHECK-NEXT:    [[MIN_IDX_EXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[PTR_FLOAT_MIN:%.*]] = getelementptr i32, ptr [[ARR]], i64 [[MIN_IDX_EXT]]
; CHECK-NEXT:    [[PTR_SECOND_LOAD:%.*]] = getelementptr i8, ptr [[PTR_FLOAT_MIN]], i64 -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[VAL_FIRST]], [[KNOWN_MIN]]
; CHECK-NEXT:    [[NEXT_IDX_TRUNC:%.*]] = trunc nsw i64 [[INDVARS_IV_NEXT_I]] to i32
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[NEXT_IDX_TRUNC]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[LOOP_COUNTER_NEXT]] = add nsw i64 [[LOOP_COUNTER]], -1
; CHECK-NEXT:    [[LOOP_CONTINUE:%.*]] = icmp samesign ugt i64 [[LOOP_COUNTER]], 1
; CHECK-NEXT:    [[CURRENT_MIN]] = select i1 [[CMP]], i32 [[VAL_FIRST]], i32 [[KNOWN_MIN]]
; CHECK-NEXT:    br i1 [[LOOP_CONTINUE]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:                                         ; preds = %loop, %entry
  %indvars.iv.i = phi i64 [ 1, %entry ], [ %indvars.iv.next.i, %loop ]
  %loop.counter = phi i64 [ 0, %entry ], [ %loop.counter.next, %loop ]
  %min.idx = phi i32 [ %initial_min_idx, %entry ], [ %min.idx.next, %loop ]
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, -1
  %ptr.i32.iv = getelementptr i32, ptr %arr, i64 %indvars.iv.i
  %ptr.first.load = getelementptr i8, ptr %ptr.i32.iv, i64 -8
  %val.first = load i32, ptr %ptr.first.load, align 4
  %min.idx.ext = sext i32 %min.idx to i64
  %ptr.i32.min = getelementptr i32, ptr %arr, i64 %min.idx.ext
  %ptr.second.load = getelementptr i8, ptr %ptr.i32.min, i64 -4
  %val.current.min = load i32, ptr %ptr.second.load, align 4
  %cmp = icmp slt i32 %val.first, %val.current.min
  %next.idx.trunc = trunc nsw i64 %indvars.iv.next.i to i32
  %min.idx.next = select i1 %cmp, i32 %next.idx.trunc, i32 %min.idx
  %loop.counter.next = add nsw i64 %loop.counter, -1
  %loop.continue = icmp samesign ugt i64 %loop.counter, 1
  br i1 %loop.continue, label %loop, label %exit

exit:
  ret void
}

; Positive test: Minimum finding pattern with i64 loads.
define void @test_gvn_min_pattern_i64(ptr %0, i32 %initial_min_idx) {
; CHECK-LABEL: define void @test_gvn_min_pattern_i64(
; CHECK-SAME: ptr [[TMP0:%.*]], i32 [[INITIAL_MIN_IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[HOIST_SEXT:%.*]] = sext i32 [[INITIAL_MIN_IDX]] to i64
; CHECK-NEXT:    [[HOIST_GEP1:%.*]] = getelementptr i64, ptr [[TMP0]], i64 [[HOIST_SEXT]]
; CHECK-NEXT:    [[HOIST_GEP2:%.*]] = getelementptr i8, ptr [[HOIST_GEP1]], i64 -4
; CHECK-NEXT:    [[HOISTED_LOAD:%.*]] = load i64, ptr [[HOIST_GEP2]], align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[KNOWN_MIN:%.*]] = phi i64 [ [[HOISTED_LOAD]], %[[ENTRY]] ], [ [[CURRENT_MIN:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_I:%.*]] = phi i64 [ 1, %[[ENTRY]] ], [ [[INDVARS_IV_NEXT_I:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[LOOP_COUNTER:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[LOOP_COUNTER_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ [[INITIAL_MIN_IDX]], %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[INDVARS_IV_NEXT_I]] = add nsw i64 [[INDVARS_IV_I]], -1
; CHECK-NEXT:    [[PTR_I64_IV:%.*]] = getelementptr i64, ptr [[TMP0]], i64 [[INDVARS_IV_I]]
; CHECK-NEXT:    [[PTR_FIRST_LOAD:%.*]] = getelementptr i8, ptr [[PTR_I64_IV]], i64 -8
; CHECK-NEXT:    [[VAL_FIRST:%.*]] = load i64, ptr [[PTR_FIRST_LOAD]], align 4
; CHECK-NEXT:    [[MIN_IDX_EXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[PTR_I64_MIN:%.*]] = getelementptr i64, ptr [[TMP0]], i64 [[MIN_IDX_EXT]]
; CHECK-NEXT:    [[PTR_SECOND_LOAD:%.*]] = getelementptr i8, ptr [[PTR_I64_MIN]], i64 -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i64 [[VAL_FIRST]], [[KNOWN_MIN]]
; CHECK-NEXT:    [[NEXT_IDX_TRUNC:%.*]] = trunc nsw i64 [[INDVARS_IV_NEXT_I]] to i32
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[NEXT_IDX_TRUNC]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[LOOP_COUNTER_NEXT]] = add nsw i64 [[LOOP_COUNTER]], -1
; CHECK-NEXT:    [[LOOP_CONTINUE:%.*]] = icmp samesign ugt i64 [[LOOP_COUNTER]], 1
; CHECK-NEXT:    [[CURRENT_MIN]] = select i1 [[CMP]], i64 [[VAL_FIRST]], i64 [[KNOWN_MIN]]
; CHECK-NEXT:    br i1 [[LOOP_CONTINUE]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:                                         ; preds = %loop, %entry
  %indvars.iv.i = phi i64 [ 1, %entry ], [ %indvars.iv.next.i, %loop ]
  %loop.counter = phi i64 [ 0, %entry ], [ %loop.counter.next, %loop ]
  %min.idx = phi i32 [ %initial_min_idx, %entry ], [ %min.idx.next, %loop ]
  %indvars.iv.next.i = add nsw i64 %indvars.iv.i, -1
  %ptr.i64.iv = getelementptr i64, ptr %0, i64 %indvars.iv.i
  %ptr.first.load = getelementptr i8, ptr %ptr.i64.iv, i64 -8
  %val.first = load i64, ptr %ptr.first.load, align 4
  %min.idx.ext = sext i32 %min.idx to i64
  %ptr.i64.min = getelementptr i64, ptr %0, i64 %min.idx.ext
  %ptr.second.load = getelementptr i8, ptr %ptr.i64.min, i64 -4
  %val.current.min = load i64, ptr %ptr.second.load, align 4
  %cmp = icmp slt i64 %val.first, %val.current.min
  %next.idx.trunc = trunc nsw i64 %indvars.iv.next.i to i32
  %min.idx.next = select i1 %cmp, i32 %next.idx.trunc, i32 %min.idx
  %loop.counter.next = add nsw i64 %loop.counter, -1
  %loop.continue = icmp samesign ugt i64 %loop.counter, 1
  br i1 %loop.continue, label %loop, label %exit

exit:
  ret void
}

; Negative test: Select not in a loop.
define void @test_not_in_loop(ptr %arr) {
; CHECK-LABEL: define void @test_not_in_loop(
; CHECK-SAME: ptr [[ARR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[ARR]], align 4
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 1
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float [[LOAD2]]
; CHECK-NEXT:    ret void
;
entry:
  %gep1 = getelementptr float, ptr %arr, i32 0
  %load1 = load float, ptr %gep1
  %sext = sext i32 1 to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  ret void
}

; Negative test: Loop without preheader (multiple entry points).
define void @test_no_preheader(ptr %arr, i32 %n, i1 %cond) {
; CHECK-LABEL: define void @test_no_preheader(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP:.*]], label %[[OTHER_ENTRY:.*]]
; CHECK:       [[OTHER_ENTRY]]:
; CHECK-NEXT:    br label %[[LOOP]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ 0, %[[OTHER_ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[I]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 [[SEXT]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %cond, label %loop, label %other_entry

other_entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ 0, %other_entry ], [ %i.next, %loop ]
  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %sext = sext i32 %i to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: Condition is not a CmpInst.
define void @test_condition_not_cmp(ptr %arr, i32 %n, i1 %bool) {
; CHECK-LABEL: define void @test_condition_not_cmp(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]], i1 [[BOOL:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[I]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 [[SEXT]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %sext = sext i32 %i to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %sel = select i1 %bool, float %load1, float %load2
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: Wrong comparison predicate (>= instead of <).
define void @test_wrong_predicate(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_wrong_predicate(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[I]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 [[SEXT]]
; CHECK-NEXT:    [[CMP:%.*]] = fcmp oge float [[LOAD1]], [[LOAD1]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %sext = sext i32 %i to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp oge float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: Not both operands are loads (constant RHS).
define void @test_not_both_loads(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_not_both_loads(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], 0.000000e+00
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float 0.000000e+00
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %cmp = fcmp olt float %load1, 0.0
  %sel = select i1 %cmp, float %load1, float 0.0
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: Load doesn't match GEP(GEP(...))nested pattern.
define void @test_wrong_gep_pattern(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_wrong_gep_pattern(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  ; Simple GEP, not nested GEP(GEP(...))
  %gep2 = getelementptr float, ptr %arr, i32 %i
  %load2 = load float, ptr %gep2
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: ZExt instead of SExt.
define void @test_no_sext(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_no_sext(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[ZEXT:%.*]] = zext i32 [[I]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 [[ZEXT]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float [[LOAD2]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %zext = zext i32 %i to i64
  %gep2 = getelementptr float, ptr %arr, i64 %zext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: SExt with wrong types (i16->i32 instead of i32->i64).
define void @test_wrong_sext_types(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_wrong_sext_types(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[I16:%.*]] = trunc i32 [[I]] to i16
; CHECK-NEXT:    [[SEXT:%.*]] = sext i16 [[I16]] to i32
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i32 [[SEXT]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float [[LOAD2]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %i16 = trunc i32 %i to i16
  %sext = sext i16 %i16 to i32
  %gep2 = getelementptr float, ptr %arr, i32 %sext
  %gep3 = getelementptr i8, ptr %gep2, i32 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: IndexVal is a constant, not a PHI node.
define void @test_index_is_constant(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_index_is_constant(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 5
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float [[LOAD2]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]

  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  ; IndexVal is a constant (5), not a PHI node!
  %sext = sext i32 5 to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

declare void @external_function(ptr)

; Negative test: Initial min index value is not 1.
define void @test_initial_index_not_one(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_initial_index_not_one(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 [[SEXT]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float [[LOAD2]]
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[I]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  ; Initial value is 0, not 1!
  %min.idx = phi i32 [ 0, %entry ], [ %min.idx.next, %loop ]

  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %sext = sext i32 %min.idx to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %min.idx.next = select i1 %cmp, i32 %i, i32 %min.idx
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: Pattern recognized but hoisting not safe due to aliasing store in loop.
define void @test_aliasing_store_in_loop(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_aliasing_store_in_loop(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ 1, %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[STORE_GEP:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    store float 0.000000e+00, ptr [[STORE_GEP]], align 4
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 [[SEXT]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float 0.000000e+00, [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float 0.000000e+00, float [[LOAD2]]
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[I]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %min.idx = phi i32 [ 1, %entry ], [ %min.idx.next, %loop ]

  ; This store aliases with the loads, preventing hoisting.
  %store.gep = getelementptr float, ptr %arr, i32 %i
  store float 0.0, ptr %store.gep

  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %sext = sext i32 %min.idx to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %min.idx.next = select i1 %cmp, i32 %i, i32 %min.idx
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: Pattern recognized but BasePtr is not loop invariant.
define void @test_non_invariant_base_ptr(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_non_invariant_base_ptr(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ 1, %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[BASE_PTR:%.*]] = phi ptr [ [[ARR]], %[[ENTRY]] ], [ [[BASE_PTR_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[BASE_PTR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[BASE_PTR]], i64 [[SEXT]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float [[LOAD2]]
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[I]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[BASE_PTR_NEXT]] = getelementptr float, ptr [[BASE_PTR]], i32 1
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %min.idx = phi i32 [ 1, %entry ], [ %min.idx.next, %loop ]
  ; Base pointer changes each iteration - not loop invariant!
  %base.ptr = phi ptr [ %arr, %entry ], [ %base.ptr.next, %loop ]

  %gep1 = getelementptr float, ptr %base.ptr, i32 %i
  %load1 = load float, ptr %gep1
  %sext = sext i32 %min.idx to i64
  %gep2 = getelementptr float, ptr %base.ptr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %min.idx.next = select i1 %cmp, i32 %i, i32 %min.idx
  %base.ptr.next = getelementptr float, ptr %base.ptr, i32 1
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}

; Negative test: Pattern recognized but may-alias call in loop.
define void @test_may_alias_call_in_loop(ptr %arr, i32 %n) {
; CHECK-LABEL: define void @test_may_alias_call_in_loop(
; CHECK-SAME: ptr [[ARR:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MIN_IDX:%.*]] = phi i32 [ 1, %[[ENTRY]] ], [ [[MIN_IDX_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    call void @external_function(ptr [[ARR]])
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr float, ptr [[ARR]], i32 [[I]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load float, ptr [[GEP1]], align 4
; CHECK-NEXT:    [[SEXT:%.*]] = sext i32 [[MIN_IDX]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr float, ptr [[ARR]], i64 [[SEXT]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load float, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = fcmp olt float [[LOAD1]], [[LOAD2]]
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP]], float [[LOAD1]], float [[LOAD2]]
; CHECK-NEXT:    [[MIN_IDX_NEXT]] = select i1 [[CMP]], i32 [[I]], i32 [[MIN_IDX]]
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[EXIT:%.*]] = icmp slt i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT]], label %[[LOOP]], label %[[EXIT_BLOCK:.*]]
; CHECK:       [[EXIT_BLOCK]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %min.idx = phi i32 [ 1, %entry ], [ %min.idx.next, %loop ]

  ; External function may modify memory.
  call void @external_function(ptr %arr)

  %gep1 = getelementptr float, ptr %arr, i32 %i
  %load1 = load float, ptr %gep1
  %sext = sext i32 %min.idx to i64
  %gep2 = getelementptr float, ptr %arr, i64 %sext
  %gep3 = getelementptr i8, ptr %gep2, i64 0
  %load2 = load float, ptr %gep3
  %cmp = fcmp olt float %load1, %load2
  %sel = select i1 %cmp, float %load1, float %load2
  %min.idx.next = select i1 %cmp, i32 %i, i32 %min.idx
  %i.next = add i32 %i, 1
  %exit = icmp slt i32 %i.next, %n
  br i1 %exit, label %loop, label %exit_block

exit_block:
  ret void
}
