; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=gvn %s | FileCheck %s

; NOTE: when we use a Token like type we should not introduce a phi

@Out.str = private unnamed_addr constant [4 x i8] c"Out\00", align 1

define void @CSMain() local_unnamed_addr {
; CHECK-LABEL: define void @CSMain() local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call i32 @llvm.dx.flattened.thread.id.in.group()
; CHECK-NEXT:    [[CMP_I1_NOT:%.*]] = icmp eq i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP_I1_NOT]], label %[[CSMAIN_EXIT:.*]], label %[[FOR_BODY_I_LR_PH:.*]]
; CHECK:       [[FOR_BODY_I_LR_PH]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call target("dx.RawBuffer", i32, 1, 0) @llvm.dx.resource.handlefrombinding.tdx.RawBuffer_i32_1_0t(i32 0, i32 0, i32 4, i32 [[TMP0]], ptr nonnull @Out.str)
; CHECK-NEXT:    br label %[[FOR_BODY_I:.*]]
; CHECK:       [[FOR_BODY_I]]:
; CHECK-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, %[[FOR_BODY_I_LR_PH]] ], [ [[INC_I:%.*]], %[[FOR_BODY_I]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = tail call noundef i32 @llvm.dx.resource.updatecounter.tdx.RawBuffer_i32_1_0t(target("dx.RawBuffer", i32, 1, 0) [[TMP1]], i8 1)
; CHECK-NEXT:    [[INC_I]] = add nuw nsw i32 [[I_0_I2]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC_I]], [[TMP0]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[FOR_BODY_I]], label %[[CSMAIN_EXIT_LOOPEXIT:.*]]
; CHECK:       [[CSMAIN_EXIT_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[CSMAIN_EXIT]]
; CHECK:       [[CSMAIN_EXIT]]:
; CHECK-NEXT:    [[TMP3:%.*]] = tail call target("dx.RawBuffer", i32, 1, 0) @llvm.dx.resource.handlefrombinding.tdx.RawBuffer_i32_1_0t(i32 0, i32 0, i32 4, i32 [[TMP0]], ptr nonnull @Out.str)
; CHECK-NEXT:    [[TMP4:%.*]] = tail call noundef i32 @llvm.dx.resource.updatecounter.tdx.RawBuffer_i32_1_0t(target("dx.RawBuffer", i32, 1, 0) [[TMP3]], i8 1)
; CHECK-NEXT:    [[TMP5:%.*]] = tail call noundef nonnull align 4 dereferenceable(4) ptr @llvm.dx.resource.getpointer.p0.tdx.RawBuffer_i32_1_0t(target("dx.RawBuffer", i32, 1, 0) [[TMP3]], i32 0)
; CHECK-NEXT:    store i32 [[TMP4]], ptr [[TMP5]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %0 = tail call i32 @llvm.dx.flattened.thread.id.in.group()
  %cmp.i1.not = icmp eq i32 %0, 0
  br i1 %cmp.i1.not, label %CSMain.exit, label %for.body.i.lr.ph

for.body.i.lr.ph:                                 ; preds = %entry
  %1 = tail call target("dx.RawBuffer", i32, 1, 0) @llvm.dx.resource.handlefrombinding.tdx.RawBuffer_i32_1_0t(i32 0, i32 0, i32 4, i32 %0, ptr nonnull @Out.str)
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i.lr.ph, %for.body.i
  %i.0.i2 = phi i32 [ 0, %for.body.i.lr.ph ], [ %inc.i, %for.body.i ]
  %2 = tail call noundef i32 @llvm.dx.resource.updatecounter.tdx.RawBuffer_i32_1_0t(target("dx.RawBuffer", i32, 1, 0) %1, i8 1)
  %inc.i = add nuw nsw i32 %i.0.i2, 1
  %exitcond = icmp ne i32 %inc.i, %0
  br i1 %exitcond, label %for.body.i, label %CSMain.exit.loopexit

CSMain.exit.loopexit:                         ; preds = %for.body.i
  br label %CSMain.exit

CSMain.exit:                                  ; preds = %CSMain.exit.loopexit, %entry
  %3 = tail call target("dx.RawBuffer", i32, 1, 0) @llvm.dx.resource.handlefrombinding.tdx.RawBuffer_i32_1_0t(i32 0, i32 0, i32 4, i32 %0, ptr nonnull @Out.str)
  %4 = tail call noundef i32 @llvm.dx.resource.updatecounter.tdx.RawBuffer_i32_1_0t(target("dx.RawBuffer", i32, 1, 0) %3, i8 1)
  %5 = tail call noundef nonnull align 4 dereferenceable(4) ptr @llvm.dx.resource.getpointer.p0.tdx.RawBuffer_i32_1_0t(target("dx.RawBuffer", i32, 1, 0) %3, i32 0)
  store i32 %4, ptr %5, align 4
  ret void
}
