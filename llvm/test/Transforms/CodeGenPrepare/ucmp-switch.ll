; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -codegenprepare -mtriple=x86_64-unknown-linux-gnu < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; --- DECLARATIONS ---
declare void @func_less()
declare void @func_equal()
declare void @func_greater()
declare i8 @llvm.ucmp.i8.i8(i8, i8)
declare i8 @llvm.scmp.i8.i8(i8, i8)
declare i8 @llvm.ucmp.i8.i47(i47, i47)

; --- BASIC TESTS ---

define void @test_ucmp_switch(i8 noundef %x, i8 noundef %y) {
; CHECK-LABEL: @test_ucmp_switch(
; CHECK-NEXT:  start:
; CHECK:         [[CMP_LESS:%.*]] = icmp ult i8 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_LESS]], label [[LESS:%.*]], label [[CHECK_EQ:%.*]]
; CHECK:       check.eq:
; CHECK-NEXT:    [[CMP_EQ:%.*]] = icmp eq i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP_EQ]], label [[EQUAL:%.*]], label [[GREATER:%.*]]
; CHECK:       less:
; CHECK-NEXT:    tail call void @func_less()
; CHECK-NEXT:    ret void
; CHECK:       equal:
; CHECK-NEXT:    tail call void @func_equal()
; CHECK-NEXT:    ret void
; CHECK:       greater:
; CHECK-NEXT:    tail call void @func_greater()
; CHECK-NEXT:    ret void
;
start:
  %val = call i8 @llvm.ucmp.i8.i8(i8 %x, i8 %y)
  %ext = zext i8 %val to i32
  switch i32 %ext, label %unreachable_block [
    i32 255, label %less
    i32 0, label %equal
    i32 1, label %greater
  ]

unreachable_block:
  unreachable

less:
  tail call void @func_less()
  ret void

equal:
  tail call void @func_equal()
  ret void

greater:
  tail call void @func_greater()
  ret void
}

define void @test_scmp_switch(i8 noundef %x, i8 noundef %y) {
; CHECK-LABEL: @test_scmp_switch(
; CHECK-NEXT:  start:
; CHECK:         [[CMP_LESS:%.*]] = icmp slt i8 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_LESS]], label [[LESS:%.*]], label [[CHECK_EQ:%.*]]
; CHECK:       check.eq:
; CHECK-NEXT:    [[CMP_EQ:%.*]] = icmp eq i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP_EQ]], label [[EQUAL:%.*]], label [[GREATER:%.*]]
;
start:
  %val = call i8 @llvm.scmp.i8.i8(i8 %x, i8 %y)
  %ext = zext i8 %val to i32
  switch i32 %ext, label %unreachable_block [
    i32 255, label %less
    i32 0, label %equal
    i32 1, label %greater
  ]

unreachable_block:
  unreachable

less:
  tail call void @func_less()
  ret void

equal:
  tail call void @func_equal()
  ret void

greater:
  tail call void @func_greater()
  ret void
}

; --- STRESS TESTS (Corner Cases) ---

define void @stress_missing_case_default(i8 %x, i8 %y) {
; CHECK-LABEL: @stress_missing_case_default(
; CHECK-NEXT:  start:
; CHECK:         [[CMP_LESS:%.*]] = icmp ult i8 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_LESS]], label [[LESS:%.*]], label [[CHECK_EQ:%.*]]
; CHECK:       check.eq:
; CHECK-NEXT:    [[CMP_EQ:%.*]] = icmp eq i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP_EQ]], label [[DEFAULT:%.*]], label [[GREATER:%.*]]
;
start:
  %val = call i8 @llvm.ucmp.i8.i8(i8 %x, i8 %y)
  %ext = zext i8 %val to i32
  switch i32 %ext, label %default [
    i32 255, label %less    ; -1 goes to Less
    i32 1, label %greater   ; 1 goes to Greater
    ; 0 is MISSING! It should go to %default.
  ]

less:
  tail call void @func_less()
  ret void

greater:
  tail call void @func_greater()
  ret void

default: ; acts as Equal
  tail call void @func_equal()
  ret void
}

define void @stress_weird_types(i47 %x, i47 %y) {
; CHECK-LABEL: @stress_weird_types(
; CHECK-NEXT:  start:
; CHECK:         [[CMP_LESS:%.*]] = icmp ult i47 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_LESS]], label [[LESS:%.*]], label [[CHECK_EQ:%.*]]
; CHECK:       check.eq:
; CHECK-NEXT:    [[CMP_EQ:%.*]] = icmp eq i47 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP_EQ]], label [[EQUAL:%.*]], label [[GREATER:%.*]]
;
start:
  %val = call i8 @llvm.ucmp.i8.i47(i47 %x, i47 %y)
  %ext = zext i8 %val to i32
  switch i32 %ext, label %unreachable_block [
    i32 255, label %less
    i32 0, label %equal
    i32 1, label %greater
  ]

unreachable_block:
  unreachable

less:
  tail call void @func_less()
  ret void

equal:
  tail call void @func_equal()
  ret void

greater:
  tail call void @func_greater()
  ret void
}

define void @stress_sext_scmp(i8 %x, i8 %y) {
; CHECK-LABEL: @stress_sext_scmp(
; CHECK-NEXT:  start:
; CHECK:         [[CMP_LESS:%.*]] = icmp slt i8 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_LESS]], label [[LESS:%.*]], label [[CHECK_EQ:%.*]]
; CHECK:       check.eq:
; CHECK-NEXT:    [[CMP_EQ:%.*]] = icmp eq i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP_EQ]], label [[EQUAL:%.*]], label [[GREATER:%.*]]
;
start:
  %val = call i8 @llvm.scmp.i8.i8(i8 %x, i8 %y)
  %ext = sext i8 %val to i32  ; <--- Testing SEXT here
  switch i32 %ext, label %unreachable_block [
    i32 -1, label %less       ; Case value is -1 (0xFFFFFFFF)
    i32 0, label %equal
    i32 1, label %greater
  ]

unreachable_block:
  unreachable

less:
  tail call void @func_less()
  ret void

equal:
  tail call void @func_equal()
  ret void

greater:
  tail call void @func_greater()
  ret void
}

define void @stress_no_cast(i8 %x, i8 %y) {
; CHECK-LABEL: @stress_no_cast(
; CHECK-NEXT:  start:
; CHECK:         [[CMP_LESS:%.*]] = icmp ult i8 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_LESS]], label [[LESS:%.*]], label [[CHECK_EQ:%.*]]
; CHECK:       check.eq:
; CHECK-NEXT:    [[CMP_EQ:%.*]] = icmp eq i8 [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP_EQ]], label [[EQUAL:%.*]], label [[GREATER:%.*]]
;
start:
  %val = call i8 @llvm.ucmp.i8.i8(i8 %x, i8 %y)
  ; NO CAST HERE! Switch directly on the intrinsic result.
  switch i8 %val, label %unreachable_block [
    i8 255, label %less
    i8 0, label %equal
    i8 1, label %greater
  ]

unreachable_block:
  unreachable

less:
  tail call void @func_less()
  ret void

equal:
  tail call void @func_equal()
  ret void

greater:
  tail call void @func_greater()
  ret void
}

; --- PHI NODE HANDLING TEST ---

define i32 @test_phi_nodes(i8 %x, i8 %y, i32 %a, i32 %b, i1 %cond) {
; CHECK-LABEL: @test_phi_nodes(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[PRE_SWITCH:%.*]], label [[FALLTHROUGH:%.*]]
;
; CHECK:       pre.switch:
; CHECK-NEXT:    [[VAL:%.*]] = call i8 @llvm.ucmp.i8.i8(i8 [[X:%.*]], i8 [[Y:%.*]])
; CHECK-NEXT:    [[EXT:%.*]] = zext i8 [[VAL]] to i32
; CHECK-NEXT:    [[CMP_LESS:%.*]] = icmp ult i8 [[X]], [[Y]]
;                ;; Verify 'less' branch still comes from pre.switch
; CHECK-NEXT:    br i1 [[CMP_LESS]], label [[LESS:%.*]], label [[CHECK_EQ:%.*]]
;
; CHECK:       check.eq:
; CHECK-NEXT:    [[CMP_EQ:%.*]] = icmp eq i8 [[X]], [[Y]]
;                ;; Verify equal/greater come from check.eq
; CHECK-NEXT:    br i1 [[CMP_EQ]], label [[EQUAL:%.*]], label [[GREATER:%.*]]
;
; CHECK:       less:
;                ;; CRITICAL: Verify predecessor is still [[PRE_SWITCH]]
; CHECK-NEXT:    [[PHI_LESS:%.*]] = phi i32 [ [[A:%.*]], [[PRE_SWITCH]] ], [ [[B:%.*]], %entry ]
; CHECK-NEXT:    ret i32 [[PHI_LESS]]
;
; CHECK:       equal:
;                ;; CRITICAL: Verify predecessor updated to [[CHECK_EQ]]
; CHECK-NEXT:    ret i32 [[A]]
;
; CHECK:       greater:
;                ;; CRITICAL: Verify predecessor updated to [[CHECK_EQ]]
; CHECK-NEXT:    ret i32 [[B]]
;
entry:
  br i1 %cond, label %pre.switch, label %fallthrough

pre.switch:
  %val = call i8 @llvm.ucmp.i8.i8(i8 %x, i8 %y)
  %ext = zext i8 %val to i32
  switch i32 %ext, label %unreachable_block [
    i32 255, label %less
    i32 0, label %equal
    i32 1, label %greater
  ]

fallthrough:
  br label %less

unreachable_block:
  unreachable

less:
  %phi.less = phi i32 [ %a, %pre.switch ], [ %b, %fallthrough ]
  ret i32 %phi.less

equal:
  %phi.equal = phi i32 [ %a, %pre.switch ]
  ret i32 %phi.equal

greater:
  %phi.greater = phi i32 [ %b, %pre.switch ]
  ret i32 %phi.greater
}