; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -p 'require<profile-summary>,codegenprepare' -cgpp-huge-func=0 < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-grtev4-linux-gnu"

declare void @g(ptr)

; %load and %load5 use the same address, %load5 is optimized first, %load is
; optimized later and reuse the same address computation instruction. We must
; make sure not to generate use before def error.

define void @f(ptr %arg) {
; CHECK-LABEL: define void @f(
; CHECK-SAME: ptr [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[GETELEMENTPTR:%.*]] = getelementptr i8, ptr [[ARG]], i64 -64
; CHECK-NEXT:    call void @g(ptr [[GETELEMENTPTR]])
; CHECK-NEXT:    [[SUNKADDR1:%.*]] = getelementptr i8, ptr [[ARG]], i64 -64
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[SUNKADDR1]], align 8
; CHECK-NEXT:    [[SUNKADDR:%.*]] = getelementptr i8, ptr [[ARG]], i64 -56
; CHECK-NEXT:    [[LOAD4:%.*]] = load i32, ptr [[SUNKADDR]], align 8
; CHECK-NEXT:    [[LOAD5:%.*]] = load ptr, ptr [[SUNKADDR1]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 1, i32 0)
; CHECK-NEXT:    [[MATH:%.*]] = extractvalue { i32, i1 } [[TMP0]], 0
; CHECK-NEXT:    ret void
;
bb:
  %getelementptr = getelementptr i8, ptr %arg, i64 -64
  %getelementptr1 = getelementptr i8, ptr %arg, i64 -56
  call void @g(ptr %getelementptr)
  br label %bb3

bb3:
  %load = load ptr, ptr %getelementptr, align 8
  %load4 = load i32, ptr %getelementptr1, align 8
  %load5 = load ptr, ptr %getelementptr, align 8
  %add = add i32 1, 0
  %icmp = icmp eq i32 %add, 0
  br i1 %icmp, label %bb7, label %bb7

bb7:
  ret void
}

; Test a scenario when the address is the last instruction in the basic block.

define void @adress_terminator() personality ptr null {
; CHECK-LABEL: define void @adress_terminator() personality ptr null {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[PTR:%.*]] = invoke ptr null(i64 0)
; CHECK-NEXT:            to label %[[BODY_1:.*]] unwind label %[[EHCLEANUP:.*]]
; CHECK:       [[EHCLEANUP]]:
; CHECK-NEXT:    [[TMP0:%.*]] = cleanuppad within none []
; CHECK-NEXT:    cleanupret from [[TMP0]] unwind to caller
; CHECK:       [[BODY_1]]:
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast ptr [[PTR]] to ptr
; CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[TMP1]], align 4
; CHECK-NEXT:    [[V0:%.*]] = load <4 x i32>, ptr [[PTR]], align 4
; CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[PTR]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %ptr = invoke ptr null(i64 0) to label %body.1 unwind label %ehcleanup

body.2:
  %v0 = load <4 x i32>, ptr %2, align 4
  store <4 x i32> zeroinitializer, ptr %2, align 4
  ret void

ehcleanup:
  %1 = cleanuppad within none []
  cleanupret from %1 unwind to caller

body.1:
  %2 = getelementptr { i32 }, ptr %ptr, i64 0, i32 0
  store <4 x i32> zeroinitializer, ptr %2, align 4
  br label %body.2
}
