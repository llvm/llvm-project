; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes='require<profile-summary>,function(codegenprepare)' < %s | FileCheck --check-prefix=GEP %s
; RUN: opt -S -passes='require<profile-summary>,function(codegenprepare)' -addr-sink-using-gep=false < %s | FileCheck --check-prefix=NO-GEP %s

target triple = "x86_64--linux-gnu"
target datalayout = "e-m:e-p0:128:128-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
; -p0:128:128 is added to ensure that transformation will be triggered.

define i128 @test(i128 %arg) {
; GEP-LABEL: define i128 @test(
; GEP-SAME: i128 [[ARG:%.*]]) {
; GEP-NEXT:  [[ENTRY:.*]]:
; GEP-NEXT:    [[CMP:%.*]] = icmp ugt i128 [[ARG]], 10
; GEP-NEXT:    br i1 [[CMP]], label %[[THEN:.*]], label %[[EXIT:.*]]
; GEP:       [[THEN]]:
; GEP-NEXT:    [[SUNKADDR:%.*]] = inttoptr i128 [[ARG]] to ptr
; GEP-NEXT:    [[SUNKADDR1:%.*]] = getelementptr i8, ptr [[SUNKADDR]], i128 -32
; GEP-NEXT:    [[LOAD:%.*]] = load i128, ptr [[SUNKADDR1]], align 16
; GEP-NEXT:    br label %[[EXIT]]
; GEP:       [[EXIT]]:
; GEP-NEXT:    [[PHI:%.*]] = phi i128 [ [[LOAD]], %[[THEN]] ], [ 0, %[[ENTRY]] ]
; GEP-NEXT:    ret i128 [[PHI]]
;
; NO-GEP-LABEL: define i128 @test(
; NO-GEP-SAME: i128 [[ARG:%.*]]) {
; NO-GEP-NEXT:  [[ENTRY:.*]]:
; NO-GEP-NEXT:    [[CMP:%.*]] = icmp ugt i128 [[ARG]], 10
; NO-GEP-NEXT:    br i1 [[CMP]], label %[[THEN:.*]], label %[[EXIT:.*]]
; NO-GEP:       [[THEN]]:
; NO-GEP-NEXT:    [[SUNKADDR:%.*]] = add i128 [[ARG]], -32
; NO-GEP-NEXT:    [[SUNKADDR1:%.*]] = inttoptr i128 [[SUNKADDR]] to ptr
; NO-GEP-NEXT:    [[LOAD:%.*]] = load i128, ptr [[SUNKADDR1]], align 16
; NO-GEP-NEXT:    br label %[[EXIT]]
; NO-GEP:       [[EXIT]]:
; NO-GEP-NEXT:    [[PHI:%.*]] = phi i128 [ [[LOAD]], %[[THEN]] ], [ 0, %[[ENTRY]] ]
; NO-GEP-NEXT:    ret i128 [[PHI]]
;
entry:
  %add = add i128 %arg, -32
  %cmp = icmp ugt i128 %arg, 10
  br i1 %cmp, label %then, label %exit

then:
  %inttoptr = inttoptr i128 %add to ptr
  %load = load i128, ptr %inttoptr, align 16
  br label %exit

exit:
  %phi = phi i128 [ %load, %then ], [ 0, %entry ]
  ret i128 %phi
}

define void @test_combine(ptr %ptr, i128 %arg) {
; GEP-LABEL: define void @test_combine(
; GEP-SAME: ptr [[PTR:%.*]], i128 [[ARG:%.*]]) {
; GEP-NEXT:  [[ENTRY:.*:]]
; GEP-NEXT:    [[CMP:%.*]] = icmp ugt i128 [[ARG]], 10
; GEP-NEXT:    [[SELECT1:%.*]] = select i1 [[CMP]], i128 -32, i128 0
; GEP-NEXT:    [[SUNKADDR:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i128 [[SELECT1]]
; GEP-NEXT:    store i128 1, ptr [[SUNKADDR]], align 16
; GEP-NEXT:    ret void
;
; NO-GEP-LABEL: define void @test_combine(
; NO-GEP-SAME: ptr [[PTR:%.*]], i128 [[ARG:%.*]]) {
; NO-GEP-NEXT:  [[ENTRY:.*:]]
; NO-GEP-NEXT:    [[CMP:%.*]] = icmp ugt i128 [[ARG]], 10
; NO-GEP-NEXT:    [[SELECT1:%.*]] = select i1 [[CMP]], i128 -32, i128 0
; NO-GEP-NEXT:    [[SUNKADDR:%.*]] = ptrtoint ptr [[PTR]] to i128
; NO-GEP-NEXT:    [[SUNKADDR2:%.*]] = add i128 [[SUNKADDR]], [[SELECT1]]
; NO-GEP-NEXT:    [[SUNKADDR3:%.*]] = inttoptr i128 [[SUNKADDR2]] to ptr
; NO-GEP-NEXT:    store i128 1, ptr [[SUNKADDR3]], align 16
; NO-GEP-NEXT:    ret void
;
entry:
  %cmp = icmp ugt i128 %arg, 10
  %gep = getelementptr inbounds i8, ptr %ptr, i128 -32
  %select = select i1 %cmp, ptr %gep, ptr %ptr
  store i128 1, ptr %select, align 16
  ret void
}

