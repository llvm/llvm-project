; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -O3 -S < %s | FileCheck %s

target datalayout = "n8:16:32:64"

define i32 @main(i32 %a) {
; CHECK-LABEL: @main(
; CHECK-NEXT:  if.end:
; CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[A:%.*]] to i8
; CHECK-NEXT:    [[TMP1:%.*]] = add i8 [[TMP0]], 1
; CHECK-NEXT:    [[CONV:%.*]] = and i8 [[TMP1]], 8
; CHECK-NEXT:    [[CMP_I_NOT:%.*]] = icmp eq i8 [[CONV]], 0
; CHECK-NEXT:    [[SHL_I:%.*]] = select i1 [[CMP_I_NOT]], i8 7, i8 0
; CHECK-NEXT:    [[COND_I:%.*]] = shl i8 [[CONV]], [[SHL_I]]
; CHECK-NEXT:    [[CONV1:%.*]] = sext i8 [[COND_I]] to i32
; CHECK-NEXT:    [[SEXT:%.*]] = mul i32 [[CONV1]], 1355350016
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[SEXT]], 65536
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[TOBOOL]])
; CHECK-NEXT:    ret i32 0
;
  %inc = add nsw i32 %a, 1
  %and = and i32 %inc, 8
  %conv = trunc i32 %and to i8
  %call = call fastcc i8 @a(i8 %conv, i32 7)
  %conv1 = sext i8 %call to i64
  %call2 = call fastcc i64 @d(i64 %conv1)
  %mul = mul nsw i64 %call2, 20681
  %conv3 = trunc i64 %mul to i16
  %conv4 = sext i16 %conv3 to i32
  %xor = xor i32 %conv4, 1
  %tobool = icmp ne i32 %xor, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:
  call void undef()
  br label %if.end

if.end:
  %call5 = call fastcc i8 @a(i8 0, i32 0)
  ret i32 0
}

define internal fastcc i8 @a(i8 %h, i32 %i) {
  %t0 = zext i8 %h to i32
  %cmp = icmp sgt i32 %t0, %i
  %shl = shl i32 %t0, %i
  %cond = select i1 %cmp, i32 %t0, i32 %shl
  %conv4 = trunc i32 %cond to i8
  ret i8 %conv4
}

define internal fastcc i64 @d(i64 %h) {
  ret i64 %h
}
