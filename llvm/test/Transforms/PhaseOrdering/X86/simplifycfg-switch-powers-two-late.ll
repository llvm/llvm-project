; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes="default<O2>" -S < %s | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"

define void @simplifycfg_switch_power_two_late_optimized(i64 %x, ptr noalias dereferenceable(8) %y, ptr %z) {
; CHECK-LABEL: define void @simplifycfg_switch_power_two_late_optimized(
; CHECK-SAME: i64 [[X:%.*]], ptr noalias readonly captures(none) dereferenceable(8) [[Y:%.*]], ptr [[Z:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOC1:%.*]] = alloca [24 x i8], align 8
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp eq i64 [[X]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[Z]], null
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], i1 [[TMP1]], i1 undef
; CHECK-NEXT:    br i1 [[SPEC_SELECT]], label %[[EXIT:.*]], label %[[OPAQUE_CALL:.*]]
; CHECK:       [[OPAQUE_CALL]]:
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[Y]], align 8
; CHECK-NEXT:    store i64 [[TMP2]], ptr [[ALLOC1]], align 8
; CHECK-NEXT:    [[PTR_IDX:%.*]] = getelementptr inbounds nuw i8, ptr [[ALLOC1]], i64 16
; CHECK-NEXT:    store ptr [[Z]], ptr [[PTR_IDX]], align 8
; CHECK-NEXT:    call void @opaque(ptr nonnull [[ALLOC1]])
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %alloc1 = alloca [24 x i8], align 8
  %alloc2 = alloca [8 x i8], align 8
  %alloc3 = alloca [8 x i8], align 8
  store i64 %x, ptr %alloc3, align 8
  %val = load i64, ptr %alloc3, align 8
  switch i64 %val, label %bb.default [
  i64 1, label %bb.1
  i64 2, label %bb.2
  i64 4, label %bb.3
  i64 8, label %bb.4
  ]

bb.default:                                       ; preds = %continue, %entry
  unreachable

bb.1:                                             ; preds = %entry
  store ptr %z, ptr %alloc2, align 8
  br label %continue

bb.2:                                             ; preds = %entry
  br label %continue

bb.3:                                             ; preds = %entry
  br label %continue

bb.4:                                             ; preds = %entry
  br label %continue

continue:                                         ; preds = %bb.4, %bb.3, %bb.2, %bb.1
  %val2 = load ptr, ptr %alloc2, align 8
  %cast = ptrtoint ptr %val2 to i64
  %icmp = icmp eq i64 %cast, 0
  %cond = select i1 %icmp, i64 0, i64 1
  switch i64 %cond, label %bb.default [
  i64 0, label %exit
  i64 1, label %opaque.call
  ]

opaque.call:                                      ; preds = %continue
  call void @llvm.memcpy.p0.p0.i64(ptr %alloc1, ptr align 8 %y, i64 8, i1 false)
  %ptr.idx = getelementptr inbounds i8, ptr %alloc1, i64 16
  store ptr %z, ptr %ptr.idx, align 8
  call void @opaque(ptr %alloc1)
  br label %exit

exit:                                             ; preds = %opaque.call
  ret void
}

declare void @opaque(ptr)
