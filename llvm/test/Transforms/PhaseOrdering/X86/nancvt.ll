; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -O3 -S | FileCheck %s

; Compile time conversions of NaNs.

target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128"
target triple = "i686-apple-darwin8"

%struct..0anon = type { float }
%struct..1anon = type { double }

@fnan = constant [3 x i32] [ i32 2143831397, i32 2143831396, i32 2143831398 ]
@dnan = constant [3 x i64] [ i64 9223235251041752696, i64 9223235251041752697, i64 9223235250773317239 ], align 8
@fsnan = constant [3 x i32] [ i32 2139637093, i32 2139637092, i32 2139637094 ]
@dsnan = constant [3 x i64] [ i64 9220983451228067448, i64 9220983451228067449, i64 9220983450959631991 ], align 8
@.str = internal constant [10 x i8] c"%08x%08x\0A\00"
@.str1 = internal constant [6 x i8] c"%08x\0A\00"

@var = external global i32

; SNAN becomes QNAN on fptrunc:
; 2147228864 = 0x7ffc1cc0 : QNAN

define i32 @main() {
; CHECK-LABEL: @main(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store volatile i32 2147027116, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 -1610612736, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147027116, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 -2147483648, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147027116, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 -1073741824, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147228864, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147228864, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147228864, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147027116, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 -1610612736, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147027116, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 -2147483648, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147027116, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 -1073741824, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147228864, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147228864, ptr @var, align 4
; CHECK-NEXT:    store volatile i32 2147228864, ptr @var, align 4
; CHECK-NEXT:    ret i32 undef
;
entry:
  %retval = alloca i32, align 4
  %i = alloca i32, align 4
  %uf = alloca %struct..0anon, align 4
  %ud = alloca %struct..1anon, align 8
  %"alloca point" = bitcast i32 0 to i32
  store i32 0, ptr %i, align 4
  br label %bb23

bb:		; preds = %bb23
  %t = load i32, ptr %i, align 4
  %t1 = getelementptr [3 x i32], ptr @fnan, i32 0, i32 %t
  %t2 = load i32, ptr %t1, align 4
  store i32 %t2, ptr %uf, align 4
  %t6 = load float, ptr %uf, align 4
  %t67 = fpext float %t6 to double
  store double %t67, ptr %ud, align 8
  %t11 = load i64, ptr %ud, align 8
  %t1112 = trunc i64 %t11 to i32
  %t13 = and i32 %t1112, -1
  %t16 = load i64, ptr %ud, align 8
  %.cast = zext i32 32 to i64
  %t17 = ashr i64 %t16, %.cast
  %t1718 = trunc i64 %t17 to i32
  store volatile i32 %t1718, ptr @var
  store volatile i32 %t13, ptr @var
  %t21 = load i32, ptr %i, align 4
  %t22 = add i32 %t21, 1
  store i32 %t22, ptr %i, align 4
  br label %bb23

bb23:		; preds = %bb, %entry
  %t24 = load i32, ptr %i, align 4
  %t25 = icmp sle i32 %t24, 2
  %t2526 = zext i1 %t25 to i8
  %toBool = icmp ne i8 %t2526, 0
  br i1 %toBool, label %bb, label %bb27

bb27:		; preds = %bb23
  store i32 0, ptr %i, align 4
  br label %bb46

bb28:		; preds = %bb46
  %t29 = load i32, ptr %i, align 4
  %t30 = getelementptr [3 x i64], ptr @dnan, i32 0, i32 %t29
  %t31 = load i64, ptr %t30, align 8
  store i64 %t31, ptr %ud, align 8
  %t36 = load double, ptr %ud, align 8
  %t3637 = fptrunc double %t36 to float
  store float %t3637, ptr %uf, align 4
  %t41 = load i32, ptr %uf, align 4
  store volatile i32 %t41, ptr @var
  %t44 = load i32, ptr %i, align 4
  %t45 = add i32 %t44, 1
  store i32 %t45, ptr %i, align 4
  br label %bb46

bb46:		; preds = %bb28, %bb27
  %t47 = load i32, ptr %i, align 4
  %t48 = icmp sle i32 %t47, 2
  %t4849 = zext i1 %t48 to i8
  %toBool50 = icmp ne i8 %t4849, 0
  br i1 %toBool50, label %bb28, label %bb51

bb51:		; preds = %bb46
  store i32 0, ptr %i, align 4
  br label %bb78

bb52:		; preds = %bb78
  %t53 = load i32, ptr %i, align 4
  %t54 = getelementptr [3 x i32], ptr @fsnan, i32 0, i32 %t53
  %t55 = load i32, ptr %t54, align 4
  store i32 %t55, ptr %uf, align 4
  %t59 = load float, ptr %uf, align 4
  %t5960 = fpext float %t59 to double
  store double %t5960, ptr %ud, align 8
  %t64 = load i64, ptr %ud, align 8
  %t6465 = trunc i64 %t64 to i32
  %t66 = and i32 %t6465, -1
  %t70 = load i64, ptr %ud, align 8
  %.cast71 = zext i32 32 to i64
  %t72 = ashr i64 %t70, %.cast71
  %t7273 = trunc i64 %t72 to i32
  store volatile i32 %t7273, ptr @var
  store volatile i32 %t66, ptr @var
  %t76 = load i32, ptr %i, align 4
  %t77 = add i32 %t76, 1
  store i32 %t77, ptr %i, align 4
  br label %bb78

bb78:		; preds = %bb52, %bb51
  %t79 = load i32, ptr %i, align 4
  %t80 = icmp sle i32 %t79, 2
  %t8081 = zext i1 %t80 to i8
  %toBool82 = icmp ne i8 %t8081, 0
  br i1 %toBool82, label %bb52, label %bb83

bb83:		; preds = %bb78
  store i32 0, ptr %i, align 4
  br label %bb101

bb84:		; preds = %bb101
  %t85 = load i32, ptr %i, align 4
  %t86 = getelementptr [3 x i64], ptr @dsnan, i32 0, i32 %t85
  %t87 = load i64, ptr %t86, align 8
  store i64 %t87, ptr %ud, align 8
  %t91 = load double, ptr %ud, align 8
  %t9192 = fptrunc double %t91 to float
  store float %t9192, ptr %uf, align 4
  %t96 = load i32, ptr %uf, align 4
  store volatile i32 %t96, ptr @var
  %t99 = load i32, ptr %i, align 4
  %t100 = add i32 %t99, 1
  store i32 %t100, ptr %i, align 4
  br label %bb101

bb101:		; preds = %bb84, %bb83
  %t102 = load i32, ptr %i, align 4
  %t103 = icmp sle i32 %t102, 2
  %t103104 = zext i1 %t103 to i8
  %toBool105 = icmp ne i8 %t103104, 0
  br i1 %toBool105, label %bb84, label %bb106

bb106:		; preds = %bb101
  br label %return

return:		; preds = %bb106
  %retval107 = load i32, ptr %retval
  ret i32 %retval107
}
