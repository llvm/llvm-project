; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -O3 -S                   | FileCheck %s
; RUN: opt < %s -passes="default<O3>" -S | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%t0 = type { ptr, ptr }
%t1 = type { [16 x i32] }
%t2 = type { %t3, ptr }
%t3 = type { i8 }

define void @wibble(ptr %arg) personality ptr null {
; CHECK-LABEL: @wibble(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[I1:%.*]] = alloca [[T1:%.*]], align 16
; CHECK-NEXT:    [[I10_3_I_PRE:%.*]] = load i8, ptr [[ARG:%.*]], align 1
; CHECK-NEXT:    [[VECTOR_RECUR_INIT:%.*]] = insertelement <4 x i8> poison, i8 [[I10_3_I_PRE]], i64 3
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr [64 x i8], ptr [[ARG]], i64 0, i64 1
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i8>, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i8> [[VECTOR_RECUR_INIT]], <4 x i8> [[WIDE_LOAD]], <4 x i32> <i32 3, i32 4, i32 5, i32 6>
; CHECK-NEXT:    [[TMP2:%.*]] = or <4 x i8> [[TMP1]], <i8 1, i8 1, i8 1, i8 1>
; CHECK-NEXT:    [[TMP3:%.*]] = zext <4 x i8> [[TMP2]] to <4 x i32>
; CHECK-NEXT:    store <4 x i32> [[TMP3]], ptr [[I1]], align 16
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [16 x i32], ptr [[I1]], i64 0, i64 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [64 x i8], ptr [[ARG]], i64 0, i64 5
; CHECK-NEXT:    [[WIDE_LOAD_1:%.*]] = load <4 x i8>, ptr [[TMP5]], align 1
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x i8> [[WIDE_LOAD]], <4 x i8> [[WIDE_LOAD_1]], <4 x i32> <i32 3, i32 4, i32 5, i32 6>
; CHECK-NEXT:    [[TMP7:%.*]] = or <4 x i8> [[TMP6]], <i8 1, i8 1, i8 1, i8 1>
; CHECK-NEXT:    [[TMP8:%.*]] = zext <4 x i8> [[TMP7]] to <4 x i32>
; CHECK-NEXT:    store <4 x i32> [[TMP8]], ptr [[TMP4]], align 16
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds [16 x i32], ptr [[I1]], i64 0, i64 8
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr [64 x i8], ptr [[ARG]], i64 0, i64 9
; CHECK-NEXT:    [[WIDE_LOAD_2:%.*]] = load <4 x i8>, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP11:%.*]] = shufflevector <4 x i8> [[WIDE_LOAD_1]], <4 x i8> [[WIDE_LOAD_2]], <4 x i32> <i32 3, i32 4, i32 5, i32 6>
; CHECK-NEXT:    [[TMP12:%.*]] = or <4 x i8> [[TMP11]], <i8 1, i8 1, i8 1, i8 1>
; CHECK-NEXT:    [[TMP13:%.*]] = zext <4 x i8> [[TMP12]] to <4 x i32>
; CHECK-NEXT:    store <4 x i32> [[TMP13]], ptr [[TMP9]], align 16
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds [16 x i32], ptr [[I1]], i64 0, i64 12
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr [64 x i8], ptr [[ARG]], i64 0, i64 13
; CHECK-NEXT:    [[WIDE_LOAD_3:%.*]] = load <4 x i8>, ptr [[TMP15]], align 1
; CHECK-NEXT:    [[TMP16:%.*]] = shufflevector <4 x i8> [[WIDE_LOAD_2]], <4 x i8> [[WIDE_LOAD_3]], <4 x i32> <i32 3, i32 4, i32 5, i32 6>
; CHECK-NEXT:    [[TMP17:%.*]] = or <4 x i8> [[TMP16]], <i8 1, i8 1, i8 1, i8 1>
; CHECK-NEXT:    [[TMP18:%.*]] = zext <4 x i8> [[TMP17]] to <4 x i32>
; CHECK-NEXT:    store <4 x i32> [[TMP18]], ptr [[TMP14]], align 16
; CHECK-NEXT:    [[I3_I_I:%.*]] = load i32, ptr [[I1]], align 16
; CHECK-NEXT:    [[I4_I_I:%.*]] = add i32 [[I3_I_I]], 1
; CHECK-NEXT:    store i32 [[I4_I_I]], ptr [[ARG]], align 4
; CHECK-NEXT:    ret void
;
bb:
  %i = alloca [0 x [0 x [0 x [0 x [0 x [0 x %t0]]]]]], i32 0, align 8
  %i1 = alloca %t1, align 4
  store ptr %arg, ptr %i, align 8
  %i2 = getelementptr %t0, ptr %i, i64 0, i32 1
  store ptr %i1, ptr %i2, align 8
  br label %bb3

bb3:                                              ; preds = %bb7, %bb
  %i4 = phi i32 [ 0, %bb ], [ %i8, %bb7 ]
  %i5 = icmp ult i32 %i4, 16
  br i1 %i5, label %bb7, label %bb6

bb6:                                              ; preds = %bb3
  call void @baz(ptr %i, ptr %arg)
  ret void

bb7:                                              ; preds = %bb3
  call void @foo(ptr %i, i32 %i4)
  %i8 = add i32 %i4, 1
  br label %bb3
}

define linkonce_odr ptr @hoge(ptr %arg, i64 %arg1) {
bb:
  %i = call ptr @ham(ptr %arg, i64 %arg1)
  ret ptr %i
}

define linkonce_odr void @foo(ptr %arg, i32 %arg1) {
bb:
  %i = load ptr, ptr %arg, align 8
  br label %bb2

bb2:                                              ; preds = %bb6, %bb
  %i3 = phi i32 [ 3, %bb ], [ %i17, %bb6 ]
  %i4 = icmp sgt i32 %i3, -1
  br i1 %i4, label %bb6, label %bb5

bb5:                                              ; preds = %bb2
  ret void

bb6:                                              ; preds = %bb2
  %i7 = add i32 %i3, %arg1
  %i8 = sext i32 %i7 to i64
  %i9 = call ptr @hoge(ptr %i, i64 %i8)
  %i10 = load i8, ptr %i9, align 1
  %i11 = getelementptr %t0, ptr %arg, i64 0, i32 1
  %i12 = load ptr, ptr %i11, align 8
  %i13 = sext i32 %arg1 to i64
  %i14 = call ptr @foo.1(ptr %i12, i64 %i13)
  %i15 = or i8 %i10, 1
  %i16 = zext i8 %i15 to i32
  store i32 %i16, ptr %i14, align 4
  %i17 = add i32 %i3, -1
  br label %bb2
}

define linkonce_odr void @baz(ptr %arg, ptr %arg1) {
bb:
  call void @pluto(ptr %arg, ptr %arg1)
  ret void
}

define linkonce_odr ptr @foo.1(ptr %arg, i64 %arg1) {
bb:
  %i = call ptr @baz.2(ptr %arg, i64 %arg1)
  ret ptr %i
}

define linkonce_odr ptr @baz.2(ptr %arg, i64 %arg1) {
bb:
  %i = getelementptr [16 x i32], ptr %arg, i64 0, i64 %arg1
  ret ptr %i
}

define linkonce_odr void @pluto(ptr %arg, ptr %arg1) {
bb:
  %i = getelementptr %t2, ptr %arg, i64 0, i32 1
  %i2 = load ptr, ptr %i, align 8
  %i3 = load i32, ptr %i2, align 4
  %i4 = add i32 %i3, 1
  store i32 %i4, ptr %arg1, align 4
  ret void
}

define linkonce_odr ptr @ham(ptr %arg, i64 %arg1) {
bb:
  %i = getelementptr [64 x i8], ptr %arg, i64 0, i64 %arg1
  ret ptr %i
}
