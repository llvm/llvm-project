; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -O2 -S -mtriple=x86_64-unknown-unknown < %s | FileCheck %s


; Examples of when moving memcmp expansion earlier in the pipeline are beneficial

@s1 = internal global ptr @.str, align 8
@s2 = internal global ptr @.str.1, align 8
@s3 = internal global ptr @.str.2, align 8
@.str = private unnamed_addr constant [9 x i8] c"01234000\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"0123!000\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c"0123?000\00", align 1

; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @memcmp_same_prefix_consts(ptr noundef %x) #0 {
; CHECK-LABEL: define dso_local noundef i32 @memcmp_same_prefix_consts(
; CHECK-SAME: ptr nocapture noundef readonly [[X:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = xor i32 [[TMP0]], 858927408
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[X]], i64 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr [[TMP2]], align 1
; CHECK-NEXT:    [[TMP4:%.*]] = zext i8 [[TMP3]] to i32
; CHECK-NEXT:    [[TMP5:%.*]] = xor i32 [[TMP4]], 52
; CHECK-NEXT:    [[TMP6:%.*]] = or i32 [[TMP1]], [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ne i32 [[TMP6]], 0
; CHECK-NEXT:    [[TMP8:%.*]] = zext i1 [[TMP7]] to i32
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[TMP8]], 0
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[IF_END8:%.*]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[X]], align 1
; CHECK-NEXT:    [[TMP10:%.*]] = xor i32 [[TMP9]], 858927408
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr [[X]], i64 4
; CHECK-NEXT:    [[TMP12:%.*]] = load i8, ptr [[TMP11]], align 1
; CHECK-NEXT:    [[TMP13:%.*]] = zext i8 [[TMP12]] to i32
; CHECK-NEXT:    [[TMP14:%.*]] = xor i32 [[TMP13]], 33
; CHECK-NEXT:    [[TMP15:%.*]] = or i32 [[TMP10]], [[TMP14]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp ne i32 [[TMP15]], 0
; CHECK-NEXT:    [[TMP17:%.*]] = zext i1 [[TMP16]] to i32
; CHECK-NEXT:    [[CMP2_NOT:%.*]] = icmp eq i32 [[TMP17]], 0
; CHECK-NEXT:    br i1 [[CMP2_NOT]], label [[IF_END8]], label [[IF_THEN3:%.*]]
; CHECK:       if.then3:
; CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[X]], align 1
; CHECK-NEXT:    [[TMP19:%.*]] = xor i32 [[TMP18]], 858927408
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr i8, ptr [[X]], i64 4
; CHECK-NEXT:    [[TMP21:%.*]] = load i8, ptr [[TMP20]], align 1
; CHECK-NEXT:    [[TMP22:%.*]] = zext i8 [[TMP21]] to i32
; CHECK-NEXT:    [[TMP23:%.*]] = xor i32 [[TMP22]], 63
; CHECK-NEXT:    [[TMP24:%.*]] = or i32 [[TMP19]], [[TMP23]]
; CHECK-NEXT:    [[TMP25:%.*]] = icmp ne i32 [[TMP24]], 0
; CHECK-NEXT:    [[TMP26:%.*]] = zext i1 [[TMP25]] to i32
; CHECK-NEXT:    [[CMP5_NOT:%.*]] = icmp eq i32 [[TMP26]], 0
; CHECK-NEXT:    br i1 [[CMP5_NOT]], label [[IF_END8]], label [[RETURN:%.*]]
; CHECK:       if.end8:
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, [[IF_END8]] ], [ 42, [[IF_THEN3]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr @s1, align 8
  %call = call i32 @memcmp(ptr noundef %0, ptr noundef %1, i64 noundef 5) #2
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %x.addr, align 8
  %3 = load ptr, ptr @s2, align 8
  %call1 = call i32 @memcmp(ptr noundef %2, ptr noundef %3, i64 noundef 5) #2
  %cmp2 = icmp ne i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %x.addr, align 8
  %5 = load ptr, ptr @s3, align 8
  %call4 = call i32 @memcmp(ptr noundef %4, ptr noundef %5, i64 noundef 5) #2
  %cmp5 = icmp ne i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then3
  store i32 42, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then6
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #1

