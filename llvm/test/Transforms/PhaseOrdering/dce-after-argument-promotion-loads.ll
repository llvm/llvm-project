; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -O3 -S < %s | FileCheck %s

; Arg promotion eliminates the struct argument, and eliminates dead arguments, but introduces and leaves dead loads of the eliminated dead arg in callers

%struct.ss = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }

define internal void @phantomLoad(ptr %p, ptr %y, ptr %x) {
entry:
  %0 = load i32, ptr %x
  store i32 %0, ptr %y
  ret void
}

define ptr @parent(ptr align 8 dereferenceable(72) %f, i16 %val1, i16 %val2, i32 %val3) align 2 {
; CHECK-LABEL: define {{[^@]+}}@parent
; CHECK-SAME: (ptr readonly returned align 8 dereferenceable(72) [[F:%.*]], i16 [[VAL1:%.*]], i16 [[VAL2:%.*]], i32 [[VAL3:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] align 2 {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT_NOT_I:%.*]] = icmp eq i32 [[VAL3]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [[STRUCT_SS:%.*]], ptr [[F]], i64 0, i32 8
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    br i1 [[CMP_NOT_NOT_I]], label [[IF_THEN_I:%.*]], label [[IF_ELSE_I:%.*]]
; CHECK:       if.then.i:
; CHECK-NEXT:    store i16 [[VAL1]], ptr [[TMP1]], align 2
; CHECK-NEXT:    [[ADD_PTR_I_I_I_I_I:%.*]] = getelementptr inbounds i8, ptr [[TMP1]], i64 16
; CHECK-NEXT:    br label [[BADCHILD_EXIT:%.*]]
; CHECK:       if.else.i:
; CHECK-NEXT:    [[ADD_PTR_I_I_I_I7_I:%.*]] = getelementptr inbounds i8, ptr [[TMP1]], i64 16
; CHECK-NEXT:    store i16 [[VAL1]], ptr [[ADD_PTR_I_I_I_I7_I]], align 2
; CHECK-NEXT:    br label [[BADCHILD_EXIT]]
; CHECK:       badChild.exit:
; CHECK-NEXT:    [[DOTSINK_I:%.*]] = phi ptr [ [[TMP1]], [[IF_ELSE_I]] ], [ [[ADD_PTR_I_I_I_I_I]], [[IF_THEN_I]] ]
; CHECK-NEXT:    store i16 [[VAL2]], ptr [[DOTSINK_I]], align 2
; CHECK-NEXT:    ret ptr [[F]]
;
entry:
  call void @badChild(ptr align 8 dereferenceable(72) %f, i16 %val1, i16 %val2, i32 %val3) #4
  ret ptr %f
}

define internal void @badChild(ptr align 8 dereferenceable(72) %this, i16 %val1, i16 %val2, i32 %val3) align 2 {
entry:
  %othergep = getelementptr inbounds %struct.ss, ptr %this, i64 0, i32 2
  %load0 = load ptr, ptr %othergep, align 8
  %load2 = load ptr, ptr %this
  %x = alloca i32
  %y = alloca i32
  call void @phantomLoad(ptr %load0, ptr %x, ptr %y)
  call void @phantomLoad(ptr %load2, ptr %x, ptr %y)
  %cmp.not.not = icmp eq i32 %val3, 0
  br i1 %cmp.not.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = getelementptr inbounds %struct.ss, ptr %this, i64 0, i32 8
  %1 = load ptr, ptr %0, align 8
  store i16 %val1, ptr %1, align 2
  %add.ptr.i.i.i.i = getelementptr inbounds i8, ptr %1, i64 16
  store i16 %val2, ptr %add.ptr.i.i.i.i, align 2
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = getelementptr inbounds %struct.ss, ptr %this, i64 0, i32 8
  %3 = load ptr, ptr %2, align 8
  %add.ptr.i.i.i.i7 = getelementptr inbounds i8, ptr %3, i64 16
  store i16 %val1, ptr %add.ptr.i.i.i.i7, align 2
  store i16 %val2, ptr %3, align 2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

