; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -O2 -S < %s | FileCheck %s

define <3 x float> @PR52631(<3 x float> %a, <3 x float> %b, <3 x i32> %c) {
; CHECK-LABEL: @PR52631(
; CHECK-NEXT:    [[ISNEG3:%.*]] = icmp slt <3 x i32> [[C:%.*]], zeroinitializer
; CHECK-NEXT:    [[OR_V:%.*]] = select <3 x i1> [[ISNEG3]], <3 x float> [[B:%.*]], <3 x float> [[A:%.*]]
; CHECK-NEXT:    ret <3 x float> [[OR_V]]
;
  %a.addr = alloca <3 x float>, align 16
  %b.addr = alloca <3 x float>, align 16
  %c.addr = alloca <3 x i32>, align 16
  %zero = alloca <3 x i32>, align 16
  %mask = alloca <3 x i32>, align 16
  %res = alloca <3 x i32>, align 16
  %extractVec = shufflevector <3 x float> %a, <3 x float> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  store <4 x float> %extractVec, ptr %a.addr, align 16
  %extractVec1 = shufflevector <3 x float> %b, <3 x float> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  store <4 x float> %extractVec1, ptr %b.addr, align 16
  %extractVec3 = shufflevector <3 x i32> %c, <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  store <4 x i32> %extractVec3, ptr %c.addr, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr %zero) #2
  store <4 x i32> <i32 0, i32 0, i32 0, i32 undef>, ptr %zero, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr %mask) #2
  %loadVec4 = load <4 x i32>, ptr %zero, align 16
  %extractVec6 = shufflevector <4 x i32> %loadVec4, <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
  %loadVec48 = load <4 x i32>, ptr %c.addr, align 16
  %extractVec9 = shufflevector <4 x i32> %loadVec48, <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
  %cmp = icmp sgt <3 x i32> %extractVec6, %extractVec9
  %sext = sext <3 x i1> %cmp to <3 x i32>
  %extractVec10 = shufflevector <3 x i32> %sext, <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  store <4 x i32> %extractVec10, ptr %mask, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr %res) #2
  %loadVec413 = load <4 x i32>, ptr %mask, align 16
  %extractVec14 = shufflevector <4 x i32> %loadVec413, <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
  %loadVec416 = load <4 x float>, ptr %b.addr, align 16
  %extractVec17 = shufflevector <4 x float> %loadVec416, <4 x float> poison, <3 x i32> <i32 0, i32 1, i32 2>
  %astype = bitcast <3 x float> %extractVec17 to <3 x i32>
  %and = and <3 x i32> %extractVec14, %astype
  %extractVec18 = shufflevector <3 x i32> %and, <3 x i32> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  store <4 x i32> %extractVec18, ptr %res, align 16
  %loadVec421 = load <4 x i32>, ptr %mask, align 16
  %extractVec22 = shufflevector <4 x i32> %loadVec421, <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
  %cmp23 = icmp eq <3 x i32> %extractVec22, zeroinitializer
  %sext24 = sext <3 x i1> %cmp23 to <3 x i32>
  %loadVec426 = load <4 x float>, ptr %a.addr, align 16
  %extractVec27 = shufflevector <4 x float> %loadVec426, <4 x float> poison, <3 x i32> <i32 0, i32 1, i32 2>
  %astype28 = bitcast <3 x float> %extractVec27 to <3 x i32>
  %and29 = and <3 x i32> %sext24, %astype28
  %loadVec431 = load <4 x i32>, ptr %res, align 16
  %extractVec32 = shufflevector <4 x i32> %loadVec431, <4 x i32> poison, <3 x i32> <i32 0, i32 1, i32 2>
  %or = or <3 x i32> %and29, %extractVec32
  %astype33 = bitcast <3 x i32> %or to <3 x float>
  call void @llvm.lifetime.end.p0(i64 16, ptr %res) #2
  call void @llvm.lifetime.end.p0(i64 16, ptr %mask) #2
  call void @llvm.lifetime.end.p0(i64 16, ptr %zero) #2
  ret <3 x float> %astype33
}

define <4 x i8> @allSignBits_vec(<4 x i8> %cond, <4 x i8> %tval, <4 x i8> %fval) {
; CHECK-LABEL: @allSignBits_vec(
; CHECK-NEXT:    [[ISNEG1:%.*]] = icmp slt <4 x i8> [[COND:%.*]], zeroinitializer
; CHECK-NEXT:    [[SEL:%.*]] = select <4 x i1> [[ISNEG1]], <4 x i8> [[TVAL:%.*]], <4 x i8> [[FVAL:%.*]]
; CHECK-NEXT:    ret <4 x i8> [[SEL]]
;
  %bitmask = ashr <4 x i8> %cond, <i8 7, i8 7, i8 7, i8 7>
  %not_bitmask = xor <4 x i8> %bitmask, <i8 -1, i8 -1, i8 -1, i8 -1>
  %a1 = and <4 x i8> %tval, %bitmask
  %a2 = and <4 x i8> %fval, %not_bitmask
  %sel = or <4 x i8> %a2, %a1
  ret <4 x i8> %sel
}

define <4 x i32> @PR42100(<4 x i32> noundef %x, <4 x i32> noundef %min) {
; CHECK-LABEL: @PR42100(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x i32> @llvm.smin.v4i32(<4 x i32> [[X:%.*]], <4 x i32> [[MIN:%.*]])
; CHECK-NEXT:    ret <4 x i32> [[TMP0]]
;
entry:
  br label %for.cond

for.cond:
  %min.addr.0 = phi <4 x i32> [ %min, %entry ], [ %min.addr.1, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ne i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:
  br label %for.end

for.body:
  %vecext = extractelement <4 x i32> %x, i32 %i.0
  %vecext1 = extractelement <4 x i32> %min.addr.0, i32 %i.0
  %cmp2 = icmp slt i32 %vecext, %vecext1
  br i1 %cmp2, label %if.then, label %if.end

if.then:
  %vecext3 = extractelement <4 x i32> %x, i32 %i.0
  %vecins = insertelement <4 x i32> %min.addr.0, i32 %vecext3, i32 %i.0
  br label %if.end

if.end:
  %min.addr.1 = phi <4 x i32> [ %vecins, %if.then ], [ %min.addr.0, %for.body ]
  br label %for.inc

for.inc:
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:
  ret <4 x i32> %min.addr.0
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1
