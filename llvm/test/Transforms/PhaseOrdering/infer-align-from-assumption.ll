; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='default<O3>' -S %s | FileCheck %s

target triple = "arm64-apple-macosx"

declare void @llvm.assume(i1 noundef)

define i32 @entry(ptr %0) {
; CHECK-LABEL: define i32 @entry(
; CHECK-SAME: ptr nocapture [[TMP0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[TMP2]], i64 4) ]
; CHECK-NEXT:    [[DOT0_COPYLOAD_I_I_I:%.*]] = load i32, ptr [[TMP2]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = tail call i32 @swap(i32 [[DOT0_COPYLOAD_I_I_I]])
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP4]], i64 4
; CHECK-NEXT:    store ptr [[TMP5]], ptr [[TMP0]], align 8
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[TMP5]], i64 4) ]
; CHECK-NEXT:    [[DOT0_COPYLOAD_I_I_I1:%.*]] = load i32, ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = tail call i32 @swap(i32 [[DOT0_COPYLOAD_I_I_I1]])
; CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[TMP7]], i64 4
; CHECK-NEXT:    store ptr [[TMP8]], ptr [[TMP0]], align 8
; CHECK-NEXT:    ret i32 [[TMP6]]
;
  %2 = call i32 @fn1(ptr %0)
  %3 = call i32 @fn1(ptr %0)
  ret i32 %3
}


define i32 @fn1(ptr %0) {
; CHECK-LABEL: define i32 @fn1(
; CHECK-SAME: ptr nocapture [[TMP0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[TMP2]], i64 4) ]
; CHECK-NEXT:    [[DOT0_COPYLOAD_I_I:%.*]] = load i32, ptr [[TMP2]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = tail call i32 @swap(i32 [[DOT0_COPYLOAD_I_I]])
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP4]], i64 4
; CHECK-NEXT:    store ptr [[TMP5]], ptr [[TMP0]], align 8
; CHECK-NEXT:    ret i32 [[TMP3]]
;
  %2 = call i32 @fn2(ptr %0)
  ret i32 %2
}

define i32 @fn2(ptr %0) {
; CHECK-LABEL: define i32 @fn2(
; CHECK-SAME: ptr nocapture [[TMP0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[TMP2]], i64 4) ]
; CHECK-NEXT:    [[DOT0_COPYLOAD_I:%.*]] = load i32, ptr [[TMP2]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = tail call i32 @swap(i32 [[DOT0_COPYLOAD_I]])
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP4]], i64 4
; CHECK-NEXT:    store ptr [[TMP5]], ptr [[TMP0]], align 8
; CHECK-NEXT:    ret i32 [[TMP3]]
;
  %2 = load ptr, ptr %0, align 8
  %3 = call i32 @load_assume_aligned(ptr %2)
  %4 = load ptr, ptr %0, align 8
  %5 = getelementptr i8, ptr %4, i64 4
  store ptr %5, ptr %0, align 8
  ret i32 %3
}

define i32 @load_assume_aligned(ptr %0) {
; CHECK-LABEL: define i32 @load_assume_aligned(
; CHECK-SAME: ptr [[TMP0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[TMP0]], i64 4) ]
; CHECK-NEXT:    [[DOT0_COPYLOAD:%.*]] = load i32, ptr [[TMP0]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = tail call i32 @swap(i32 [[DOT0_COPYLOAD]])
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  call void @llvm.assume(i1 true) [ "align"(ptr %0, i64 4) ]
  %.0.copyload = load i32, ptr %0, align 1
  %2 = call i32 @swap(i32 %.0.copyload)
  ret i32 %2
}

declare i32 @swap(i32)
