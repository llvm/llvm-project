; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=newgvn -S | FileCheck %s
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"

define void @foo(i32 %arg, i32 %arg1, ptr %arg2) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br label [[BB3:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    [[TMP:%.*]] = phi i32 [ [[ARG1:%.*]], [[BB:%.*]] ], [ [[TMP4:%.*]], [[BB7:%.*]] ]
; CHECK-NEXT:    [[TMP4]] = phi i32 [ [[ARG:%.*]], [[BB]] ], [ [[TMP]], [[BB7]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 [[ARG2:%.*]](i32 [[TMP4]], i32 [[TMP]])
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i32 [[TMP5]], 0
; CHECK-NEXT:    br i1 [[TMP6]], label [[BB7]], label [[BB8:%.*]]
; CHECK:       bb7:
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb8:
; CHECK-NEXT:    ret void
;
bb:
  br label %bb3

;; While non-standard, llvm allows mutually dependent phi nodes
;; Ensure we do not infinite loop trying to process them
bb3:                                              ; preds = %bb7, %bb
  %tmp = phi i32 [ %arg1, %bb ], [ %tmp4, %bb7 ]
  %tmp4 = phi i32 [ %arg, %bb ], [ %tmp, %bb7 ]
  %tmp5 = call i32 %arg2(i32 %tmp4, i32 %tmp)
  %tmp6 = icmp ne i32 %tmp5, 0
  br i1 %tmp6, label %bb7, label %bb8

bb7:                                              ; preds = %bb3
  br label %bb3

bb8:                                              ; preds = %bb3
  ret void
}
