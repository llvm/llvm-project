; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=newgvn -S | FileCheck %s
;

%0 = type { i64, i1 }

define i64 @test1(i64 %a, i64 %b) nounwind ssp {
; CHECK-LABEL: define i64 @test1(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { i64, i1 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue [[TMP0]] poison, i64 [[TMP1]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { i64, i1 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = insertvalue [[TMP0]] [[TMP2]], i1 [[TMP3]], 1
; CHECK-NEXT:    [[UADD_0:%.*]] = extractvalue [[TMP0]] [[TMP4]], 0
; CHECK-NEXT:    [[ADD2:%.*]] = add i64 [[TMP1]], [[UADD_0]]
; CHECK-NEXT:    ret i64 [[ADD2]]
;
entry:
  %uadd = tail call %0 @llvm.uadd.with.overflow.i64(i64 %a, i64 %b)
  %uadd.0 = extractvalue %0 %uadd, 0
  %add1 = add i64 %a, %b
  %add2 =  add i64 %add1, %uadd.0
  ret i64 %add2
}


define i64 @test2(i64 %a, i64 %b) nounwind ssp {
; CHECK-LABEL: define i64 @test2(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call { i64, i1 } @llvm.usub.with.overflow.i64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { i64, i1 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue [[TMP0]] poison, i64 [[TMP1]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { i64, i1 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = insertvalue [[TMP0]] [[TMP2]], i1 [[TMP3]], 1
; CHECK-NEXT:    [[USUB_0:%.*]] = extractvalue [[TMP0]] [[TMP4]], 0
; CHECK-NEXT:    [[ADD2:%.*]] = add i64 [[TMP1]], [[USUB_0]]
; CHECK-NEXT:    ret i64 [[ADD2]]
;
entry:
  %usub = tail call %0 @llvm.usub.with.overflow.i64(i64 %a, i64 %b)
  %usub.0 = extractvalue %0 %usub, 0
  %sub1 = sub i64 %a, %b
  %add2 =  add i64 %sub1, %usub.0
  ret i64 %add2
}


define i64 @test3(i64 %a, i64 %b) nounwind ssp {
; CHECK-LABEL: define i64 @test3(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { i64, i1 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue [[TMP0]] poison, i64 [[TMP1]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { i64, i1 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = insertvalue [[TMP0]] [[TMP2]], i1 [[TMP3]], 1
; CHECK-NEXT:    [[UMUL_0:%.*]] = extractvalue [[TMP0]] [[TMP4]], 0
; CHECK-NEXT:    [[ADD2:%.*]] = add i64 [[TMP1]], [[UMUL_0]]
; CHECK-NEXT:    ret i64 [[ADD2]]
;
entry:
  %umul = tail call %0 @llvm.umul.with.overflow.i64(i64 %a, i64 %b)
  %umul.0 = extractvalue %0 %umul, 0
  %mul1 = mul i64 %a, %b
  %add2 =  add i64 %mul1, %umul.0
  ret i64 %add2
}


define i64 @test4(i64 %a, i64 %b) nounwind ssp {
; CHECK-LABEL: define i64 @test4(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { i64, i1 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue [[TMP0]] poison, i64 [[TMP1]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { i64, i1 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = insertvalue [[TMP0]] [[TMP2]], i1 [[TMP3]], 1
; CHECK-NEXT:    [[SADD_0:%.*]] = extractvalue [[TMP0]] [[TMP4]], 0
; CHECK-NEXT:    [[ADD2:%.*]] = add i64 [[TMP1]], [[SADD_0]]
; CHECK-NEXT:    ret i64 [[ADD2]]
;
entry:
  %sadd = tail call %0 @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)
  %sadd.0 = extractvalue %0 %sadd, 0
  %add1 = add i64 %a, %b
  %add2 =  add i64 %add1, %sadd.0
  ret i64 %add2
}


define i64 @test5(i64 %a, i64 %b) nounwind ssp {
; CHECK-LABEL: define i64 @test5(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { i64, i1 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue [[TMP0]] poison, i64 [[TMP1]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { i64, i1 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = insertvalue [[TMP0]] [[TMP2]], i1 [[TMP3]], 1
; CHECK-NEXT:    [[SSUB_0:%.*]] = extractvalue [[TMP0]] [[TMP4]], 0
; CHECK-NEXT:    [[ADD2:%.*]] = add i64 [[TMP1]], [[SSUB_0]]
; CHECK-NEXT:    ret i64 [[ADD2]]
;
entry:
  %ssub = tail call %0 @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)
  %ssub.0 = extractvalue %0 %ssub, 0
  %sub1 = sub i64 %a, %b
  %add2 =  add i64 %sub1, %ssub.0
  ret i64 %add2
}


define i64 @test6(i64 %a, i64 %b) nounwind ssp {
; CHECK-LABEL: define i64 @test6(
; CHECK-SAME: i64 [[A:%.*]], i64 [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call { i64, i1 } @llvm.smul.with.overflow.i64(i64 [[A]], i64 [[B]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { i64, i1 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue [[TMP0]] poison, i64 [[TMP1]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { i64, i1 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = insertvalue [[TMP0]] [[TMP2]], i1 [[TMP3]], 1
; CHECK-NEXT:    [[SMUL_0:%.*]] = extractvalue [[TMP0]] [[TMP4]], 0
; CHECK-NEXT:    [[ADD2:%.*]] = add i64 [[TMP1]], [[SMUL_0]]
; CHECK-NEXT:    ret i64 [[ADD2]]
;
entry:
  %smul = tail call %0 @llvm.smul.with.overflow.i64(i64 %a, i64 %b)
  %smul.0 = extractvalue %0 %smul, 0
  %mul1 = mul i64 %a, %b
  %add2 =  add i64 %mul1, %smul.0
  ret i64 %add2
}


declare void @exit(i32) noreturn
declare %0 @llvm.uadd.with.overflow.i64(i64, i64) nounwind readnone
declare %0 @llvm.usub.with.overflow.i64(i64, i64) nounwind readnone
declare %0 @llvm.umul.with.overflow.i64(i64, i64) nounwind readnone
declare %0 @llvm.sadd.with.overflow.i64(i64, i64) nounwind readnone
declare %0 @llvm.ssub.with.overflow.i64(i64, i64) nounwind readnone
declare %0 @llvm.smul.with.overflow.i64(i64, i64) nounwind readnone

