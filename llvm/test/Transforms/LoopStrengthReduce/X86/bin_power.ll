; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -scalar-evolution-huge-expr-threshold=1000000 -loop-reduce -S | FileCheck %s

target datalayout = "e-m:e-i32:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Show that the b^2 is expanded correctly.
define i32 @test_01(i32 %a) {
; CHECK-LABEL: define i32 @test_01(
; CHECK-SAME: i32 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], %[[LOOP]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[B:%.*]] = add i32 [[A]], 1
; CHECK-NEXT:    [[B_POW_2:%.*]] = mul i32 [[B]], [[B]]
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], -80
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[B_POW_2]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[TMP0]], [[LSR_IV_NEXT]]
; CHECK-NEXT:    ret i32 [[TMP1]]
;

entry:
  br label %loop

loop:                                           ; preds = %loop, %entry
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %b = add i32 %a, 1
  %b.pow.2 = mul i32 %b, %b
  %result = add i32 %b.pow.2, %indvars.iv
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 80
  br i1 %exitcond, label %exit, label %loop

exit:                                             ; preds = %loop
  ret i32 %result
}

; Show that b^8 is expanded correctly.
define i32 @test_02(i32 %a) {
; CHECK-LABEL: define i32 @test_02(
; CHECK-SAME: i32 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], %[[LOOP]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[B:%.*]] = add i32 [[A]], 1
; CHECK-NEXT:    [[B_POW_2:%.*]] = mul i32 [[B]], [[B]]
; CHECK-NEXT:    [[B_POW_4:%.*]] = mul i32 [[B_POW_2]], [[B_POW_2]]
; CHECK-NEXT:    [[B_POW_8:%.*]] = mul i32 [[B_POW_4]], [[B_POW_4]]
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], -80
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[B_POW_8]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[TMP0]], [[LSR_IV_NEXT]]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
entry:
  br label %loop

loop:                                           ; preds = %loop, %entry
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %b = add i32 %a, 1
  %b.pow.2 = mul i32 %b, %b
  %b.pow.4 = mul i32 %b.pow.2, %b.pow.2
  %b.pow.8 = mul i32 %b.pow.4, %b.pow.4
  %result = add i32 %b.pow.8, %indvars.iv
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 80
  br i1 %exitcond, label %exit, label %loop

exit:                                             ; preds = %loop
  ret i32 %result
}

; Show that b^27 (27 = 1 + 2 + 8 + 16) is expanded correctly.
define i32 @test_03(i32 %a) {
; CHECK-LABEL: define i32 @test_03(
; CHECK-SAME: i32 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], %[[LOOP]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[B:%.*]] = add i32 [[A]], 1
; CHECK-NEXT:    [[B_POW_2:%.*]] = mul i32 [[B]], [[B]]
; CHECK-NEXT:    [[B_POW_4:%.*]] = mul i32 [[B_POW_2]], [[B_POW_2]]
; CHECK-NEXT:    [[B_POW_8:%.*]] = mul i32 [[B_POW_4]], [[B_POW_4]]
; CHECK-NEXT:    [[B_POW_16:%.*]] = mul i32 [[B_POW_8]], [[B_POW_8]]
; CHECK-NEXT:    [[B_POW_24:%.*]] = mul i32 [[B_POW_16]], [[B_POW_8]]
; CHECK-NEXT:    [[B_POW_25:%.*]] = mul i32 [[B_POW_24]], [[B]]
; CHECK-NEXT:    [[B_POW_26:%.*]] = mul i32 [[B_POW_25]], [[B]]
; CHECK-NEXT:    [[B_POW_27:%.*]] = mul i32 [[B_POW_26]], [[B]]
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], -80
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[B_POW_27]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[TMP0]], [[LSR_IV_NEXT]]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
entry:
  br label %loop

loop:                                           ; preds = %loop, %entry
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %b = add i32 %a, 1
  %b.pow.2 = mul i32 %b, %b
  %b.pow.4 = mul i32 %b.pow.2, %b.pow.2
  %b.pow.8 = mul i32 %b.pow.4, %b.pow.4
  %b.pow.16 = mul i32 %b.pow.8, %b.pow.8
  %b.pow.24 = mul i32 %b.pow.16, %b.pow.8
  %b.pow.25 = mul i32 %b.pow.24, %b
  %b.pow.26 = mul i32 %b.pow.25, %b
  %b.pow.27 = mul i32 %b.pow.26, %b
  %result = add i32 %b.pow.27, %indvars.iv
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 80
  br i1 %exitcond, label %exit, label %loop

exit:                                             ; preds = %loop
  ret i32 %result
}

; Show how linear calculation of b^16 is turned into logarithmic.
define i32 @test_04(i32 %a) {
; CHECK-LABEL: define i32 @test_04(
; CHECK-SAME: i32 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], %[[LOOP]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[B:%.*]] = add i32 [[A]], 1
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], -80
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = mul i32 [[B]], [[B]]
; CHECK-NEXT:    [[TMP1:%.*]] = mul i32 [[TMP0]], [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = mul i32 [[TMP1]], [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = mul i32 [[TMP2]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = add i32 [[TMP3]], -1
; CHECK-NEXT:    [[TMP5:%.*]] = sub i32 [[TMP4]], [[LSR_IV_NEXT]]
; CHECK-NEXT:    ret i32 [[TMP5]]
;
entry:
  br label %loop

loop:                                           ; preds = %loop, %entry
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %b = add i32 %a, 1
  %b.pow.2 = mul i32 %b, %b
  %b.pow.3 = mul i32 %b.pow.2, %b
  %b.pow.4 = mul i32 %b.pow.3, %b
  %b.pow.5 = mul i32 %b.pow.4, %b
  %b.pow.6 = mul i32 %b.pow.5, %b
  %b.pow.7 = mul i32 %b.pow.6, %b
  %b.pow.8 = mul i32 %b.pow.7, %b
  %b.pow.9 = mul i32 %b.pow.8, %b
  %b.pow.10 = mul i32 %b.pow.9, %b
  %b.pow.11 = mul i32 %b.pow.10, %b
  %b.pow.12 = mul i32 %b.pow.11, %b
  %b.pow.13 = mul i32 %b.pow.12, %b
  %b.pow.14 = mul i32 %b.pow.13, %b
  %b.pow.15 = mul i32 %b.pow.14, %b
  %b.pow.16 = mul i32 %b.pow.15, %b
  %result = add i32 %b.pow.16, %indvars.iv
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 80
  br i1 %exitcond, label %exit, label %loop

exit:                                             ; preds = %loop
  ret i32 %result
}

; The output here is reasonably big, we just check that the amount of expanded
; instructions is sane.
define i32 @test_05(i32 %a) {
; CHECK-LABEL: define i32 @test_05(
; CHECK-SAME: i32 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], %[[LOOP]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A]], 1
; CHECK-NEXT:    [[MUL4:%.*]] = mul i32 [[ADD]], [[ADD]]
; CHECK-NEXT:    [[MUL5:%.*]] = mul i32 [[MUL4]], [[MUL4]]
; CHECK-NEXT:    [[MUL6:%.*]] = mul i32 [[MUL5]], [[MUL5]]
; CHECK-NEXT:    [[MUL7:%.*]] = mul i32 [[MUL6]], [[MUL6]]
; CHECK-NEXT:    [[MUL8:%.*]] = mul i32 [[MUL7]], [[MUL7]]
; CHECK-NEXT:    [[MUL9:%.*]] = mul i32 [[MUL8]], [[MUL8]]
; CHECK-NEXT:    [[MUL10:%.*]] = mul i32 [[MUL9]], [[MUL9]]
; CHECK-NEXT:    [[MUL11:%.*]] = mul i32 [[MUL10]], [[MUL10]]
; CHECK-NEXT:    [[MUL12:%.*]] = mul i32 [[MUL11]], [[MUL11]]
; CHECK-NEXT:    [[MUL13:%.*]] = mul i32 [[MUL12]], [[MUL12]]
; CHECK-NEXT:    [[MUL14:%.*]] = mul i32 [[MUL13]], [[MUL13]]
; CHECK-NEXT:    [[MUL15:%.*]] = mul i32 [[MUL14]], [[MUL14]]
; CHECK-NEXT:    [[MUL16:%.*]] = mul i32 [[MUL15]], [[MUL15]]
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], -80
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = mul i32 [[MUL16]], [[MUL15]]
; CHECK-NEXT:    [[TMP1:%.*]] = mul i32 [[TMP0]], [[MUL14]]
; CHECK-NEXT:    [[TMP2:%.*]] = mul i32 [[TMP1]], [[MUL13]]
; CHECK-NEXT:    [[TMP3:%.*]] = mul i32 [[TMP2]], [[MUL12]]
; CHECK-NEXT:    [[TMP4:%.*]] = mul i32 [[TMP3]], [[MUL11]]
; CHECK-NEXT:    [[TMP5:%.*]] = mul i32 [[TMP4]], [[MUL10]]
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 [[TMP5]], [[MUL9]]
; CHECK-NEXT:    [[TMP7:%.*]] = mul i32 [[TMP6]], [[MUL8]]
; CHECK-NEXT:    [[TMP8:%.*]] = mul i32 [[ADD]], [[ADD]]
; CHECK-NEXT:    [[TMP9:%.*]] = mul i32 [[TMP8]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = mul i32 [[TMP9]], [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = mul i32 [[TMP10]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = mul i32 [[TMP11]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = mul i32 [[TMP7]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = mul i32 [[TMP13]], [[MUL16]]
; CHECK-NEXT:    [[TMP15:%.*]] = mul i32 [[TMP14]], [[MUL15]]
; CHECK-NEXT:    [[TMP16:%.*]] = mul i32 [[TMP15]], [[MUL14]]
; CHECK-NEXT:    [[TMP17:%.*]] = mul i32 [[TMP16]], [[MUL13]]
; CHECK-NEXT:    [[TMP18:%.*]] = mul i32 [[TMP17]], [[MUL12]]
; CHECK-NEXT:    [[TMP19:%.*]] = mul i32 [[TMP18]], [[MUL11]]
; CHECK-NEXT:    [[TMP20:%.*]] = mul i32 [[TMP19]], [[MUL10]]
; CHECK-NEXT:    [[TMP21:%.*]] = mul i32 [[TMP20]], [[MUL9]]
; CHECK-NEXT:    [[TMP22:%.*]] = mul i32 [[TMP21]], [[MUL8]]
; CHECK-NEXT:    [[TMP23:%.*]] = mul i32 [[ADD]], [[ADD]]
; CHECK-NEXT:    [[TMP24:%.*]] = mul i32 [[TMP23]], [[TMP23]]
; CHECK-NEXT:    [[TMP25:%.*]] = mul i32 [[TMP24]], [[TMP24]]
; CHECK-NEXT:    [[TMP26:%.*]] = mul i32 [[TMP25]], [[TMP25]]
; CHECK-NEXT:    [[TMP27:%.*]] = mul i32 [[TMP26]], [[TMP26]]
; CHECK-NEXT:    [[TMP28:%.*]] = mul i32 [[TMP22]], [[TMP27]]
; CHECK-NEXT:    [[TMP29:%.*]] = mul i32 [[TMP28]], [[TMP13]]
; CHECK-NEXT:    [[TMP30:%.*]] = mul i32 [[TMP29]], [[MUL16]]
; CHECK-NEXT:    [[TMP31:%.*]] = mul i32 [[TMP30]], [[MUL15]]
; CHECK-NEXT:    [[TMP32:%.*]] = mul i32 [[TMP31]], [[MUL14]]
; CHECK-NEXT:    [[TMP33:%.*]] = mul i32 [[TMP32]], [[MUL13]]
; CHECK-NEXT:    [[TMP34:%.*]] = mul i32 [[TMP33]], [[MUL12]]
; CHECK-NEXT:    [[TMP35:%.*]] = mul i32 [[TMP34]], [[MUL11]]
; CHECK-NEXT:    [[TMP36:%.*]] = mul i32 [[TMP35]], [[MUL10]]
; CHECK-NEXT:    [[TMP37:%.*]] = mul i32 [[TMP36]], [[MUL9]]
; CHECK-NEXT:    [[TMP38:%.*]] = mul i32 [[TMP37]], [[MUL8]]
; CHECK-NEXT:    [[TMP39:%.*]] = mul i32 [[ADD]], [[ADD]]
; CHECK-NEXT:    [[TMP40:%.*]] = mul i32 [[TMP39]], [[TMP39]]
; CHECK-NEXT:    [[TMP41:%.*]] = mul i32 [[TMP40]], [[TMP40]]
; CHECK-NEXT:    [[TMP42:%.*]] = mul i32 [[TMP41]], [[TMP41]]
; CHECK-NEXT:    [[TMP43:%.*]] = mul i32 [[TMP42]], [[TMP42]]
; CHECK-NEXT:    [[TMP44:%.*]] = mul i32 [[TMP38]], [[TMP43]]
; CHECK-NEXT:    [[TMP45:%.*]] = mul i32 [[TMP44]], [[TMP28]]
; CHECK-NEXT:    [[TMP46:%.*]] = mul i32 [[TMP45]], [[TMP13]]
; CHECK-NEXT:    [[TMP47:%.*]] = mul i32 [[TMP46]], [[MUL16]]
; CHECK-NEXT:    [[TMP48:%.*]] = mul i32 [[TMP47]], [[MUL15]]
; CHECK-NEXT:    [[TMP49:%.*]] = mul i32 [[TMP48]], [[MUL14]]
; CHECK-NEXT:    [[TMP50:%.*]] = mul i32 [[TMP49]], [[MUL13]]
; CHECK-NEXT:    [[TMP51:%.*]] = mul i32 [[TMP50]], [[MUL12]]
; CHECK-NEXT:    [[TMP52:%.*]] = mul i32 [[TMP51]], [[MUL11]]
; CHECK-NEXT:    [[TMP53:%.*]] = mul i32 [[TMP52]], [[MUL10]]
; CHECK-NEXT:    [[TMP54:%.*]] = mul i32 [[TMP53]], [[MUL9]]
; CHECK-NEXT:    [[TMP55:%.*]] = mul i32 [[TMP54]], [[MUL8]]
; CHECK-NEXT:    [[TMP56:%.*]] = mul i32 [[ADD]], [[ADD]]
; CHECK-NEXT:    [[TMP57:%.*]] = mul i32 [[TMP56]], [[TMP56]]
; CHECK-NEXT:    [[TMP58:%.*]] = mul i32 [[TMP57]], [[TMP57]]
; CHECK-NEXT:    [[TMP59:%.*]] = mul i32 [[TMP58]], [[TMP58]]
; CHECK-NEXT:    [[TMP60:%.*]] = mul i32 [[TMP59]], [[TMP59]]
; CHECK-NEXT:    [[TMP61:%.*]] = mul i32 [[TMP55]], [[TMP60]]
; CHECK-NEXT:    [[TMP62:%.*]] = add i32 [[TMP61]], -1
; CHECK-NEXT:    [[TMP63:%.*]] = sub i32 [[TMP62]], [[LSR_IV_NEXT]]
; CHECK-NEXT:    ret i32 [[TMP63]]
;

entry:
  br label %loop

loop:                                           ; preds = %loop, %entry
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %add = add i32 %a, 1
  %mul4 = mul i32 %add, %add
  %mul5 = mul i32 %mul4, %mul4
  %mul6 = mul i32 %mul5, %mul5
  %mul7 = mul i32 %mul6, %mul6
  %mul8 = mul i32 %mul7, %mul7
  %mul9 = mul i32 %mul8, %mul8
  %mul10 = mul i32 %mul9, %mul9
  %mul11 = mul i32 %mul10, %mul10
  %mul12 = mul i32 %mul11, %mul11
  %mul13 = mul i32 %mul12, %mul12
  %mul14 = mul i32 %mul13, %mul13
  %mul15 = mul i32 %mul14, %mul14
  %mul16 = mul i32 %mul15, %mul15
  %mul17 = mul i32 %mul16, %mul16
  %mul18 = mul i32 %mul17, %mul17
  %mul19 = mul i32 %mul18, %mul18
  %mul20 = mul i32 %mul19, %mul19
  %res = add i32 %mul20, %indvars.iv
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 80
  br i1 %exitcond, label %exit, label %loop

exit:                                             ; preds = %loop
  ret i32 %res
}

; Show that the transformation works even if the calculation involves different
; values inside.
define i32 @test_06(i32 %a, i32 %c) {
; CHECK-LABEL: define i32 @test_06(
; CHECK-SAME: i32 [[A:%.*]], i32 [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], %[[LOOP]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[B:%.*]] = add i32 [[A]], 1
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], -80
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = mul i32 [[C]], [[C]]
; CHECK-NEXT:    [[TMP1:%.*]] = mul i32 [[C]], [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = mul i32 [[B]], [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = mul i32 [[TMP2]], [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = mul i32 [[TMP3]], [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = mul i32 [[TMP4]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 [[TMP1]], [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[TMP6]], -1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[TMP7]], [[LSR_IV_NEXT]]
; CHECK-NEXT:    ret i32 [[TMP8]]
;
entry:
  br label %loop

loop:                                           ; preds = %loop, %entry
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %b = add i32 %a, 1
  %b.pow.2.tmp = mul i32 %b, %b
  %b.pow.2 = mul i32 %b.pow.2.tmp, %c
  %b.pow.3 = mul i32 %b.pow.2, %b
  %b.pow.4 = mul i32 %b.pow.3, %b
  %b.pow.5 = mul i32 %b.pow.4, %b
  %b.pow.6.tmp = mul i32 %b.pow.5, %b
  %b.pow.6 = mul i32 %b.pow.6.tmp, %c
  %b.pow.7 = mul i32 %b.pow.6, %b
  %b.pow.8 = mul i32 %b.pow.7, %b
  %b.pow.9 = mul i32 %b.pow.8, %b
  %b.pow.10 = mul i32 %b.pow.9, %b
  %b.pow.11 = mul i32 %b.pow.10, %b
  %b.pow.12.tmp = mul i32 %b.pow.11, %b
  %b.pow.12 = mul i32 %c, %b.pow.12.tmp
  %b.pow.13 = mul i32 %b.pow.12, %b
  %b.pow.14 = mul i32 %b.pow.13, %b
  %b.pow.15 = mul i32 %b.pow.14, %b
  %b.pow.16 = mul i32 %b.pow.15, %b
  %result = add i32 %b.pow.16, %indvars.iv
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 80
  br i1 %exitcond, label %exit, label %loop

exit:                                             ; preds = %loop
  ret i32 %result
}
