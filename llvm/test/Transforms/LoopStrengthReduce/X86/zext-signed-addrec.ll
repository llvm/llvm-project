; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -loop-reduce -S %s | FileCheck %s
; PR18000

target datalayout = "e-i64:64-f80:128-s:64-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = global i32 0, align 4
@b = common global i32 0, align 4
@e = common global i8 0, align 1
@d = common global i32 0, align 4
@c = common global i32 0, align 4
@.str = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1

define i32 @foo() {
; CHECK-LABEL: define i32 @foo() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DOTPR:%.*]] = load i32, ptr @b, align 4
; CHECK-NEXT:    [[CMP10:%.*]] = icmp slt i32 [[DOTPR]], 1
; CHECK-NEXT:    br i1 [[CMP10]], label %[[OUTER_PH:.*]], label %[[ENTRY_ELSE:.*]]
; CHECK:       [[ENTRY_ELSE]]:
; CHECK-NEXT:    [[DOTPRE:%.*]] = load i32, ptr @c, align 4
; CHECK-NEXT:    br label %[[MERGE:.*]]
; CHECK:       [[OUTER_PH]]:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @a, align 4
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[OUTER_HEADER_PREHEADER:.*]], label %[[P_ELSE:.*]]
; CHECK:       [[OUTER_HEADER_PREHEADER]]:
; CHECK-NEXT:    br label %[[OUTER_HEADER:.*]]
; CHECK:       [[OUTER_HEADER]]:
; CHECK-NEXT:    [[TMP1:%.*]] = phi i32 [ [[INC:%.*]], %[[OUTER_LATCH:.*]] ], [ [[DOTPR]], %[[OUTER_HEADER_PREHEADER]] ]
; CHECK-NEXT:    br label %[[INNER_LOOP:.*]]
; CHECK:       [[INNER_LOOP]]:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], %[[INNER_LOOP]] ], [ 516, %[[OUTER_HEADER]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = phi i8 [ 1, %[[OUTER_HEADER]] ], [ [[DEC:%.*]], %[[INNER_LOOP]] ]
; CHECK-NEXT:    [[SHL:%.*]] = add i32 [[LSR_IV]], -258
; CHECK-NEXT:    store i32 [[SHL]], ptr @c, align 4
; CHECK-NEXT:    [[DEC]] = add i8 [[TMP2]], -1
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV]], -258
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i8 [[DEC]], -1
; CHECK-NEXT:    br i1 [[CMP2]], label %[[INNER_LOOP]], label %[[OUTER_LATCH]]
; CHECK:       [[OUTER_LATCH]]:
; CHECK-NEXT:    [[LSR_IV_NEXT_LCSSA:%.*]] = phi i32 [ [[LSR_IV_NEXT]], %[[INNER_LOOP]] ]
; CHECK-NEXT:    store i32 0, ptr @d, align 4
; CHECK-NEXT:    [[INC]] = add nsw i32 [[TMP1]], 1
; CHECK-NEXT:    store i32 [[INC]], ptr @b, align 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[CMP]], label %[[OUTER_HEADER]], label %[[OUTER_EXIT:.*]]
; CHECK:       [[OUTER_EXIT]]:
; CHECK-NEXT:    [[LSR_IV_NEXT_LCSSA_LCSSA:%.*]] = phi i32 [ [[LSR_IV_NEXT_LCSSA]], %[[OUTER_LATCH]] ]
; CHECK-NEXT:    store i8 [[DEC]], ptr @e, align 1
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ [[DOTPRE]], %[[ENTRY_ELSE]] ], [ [[LSR_IV_NEXT_LCSSA_LCSSA]], %[[OUTER_EXIT]] ]
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @bar(i32 [[TMP3]])
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[P_ELSE]]:
; CHECK-NEXT:    store i8 1, ptr @e, align 1
; CHECK-NEXT:    store i32 0, ptr @d, align 4
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, %[[MERGE]] ], [ 1, %[[P_ELSE]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %.pr = load i32, ptr @b, align 4
  %cmp10 = icmp slt i32 %.pr, 1
  br i1 %cmp10, label %outer.ph, label %entry.else

entry.else:
  %.pre = load i32, ptr @c, align 4
  br label %merge

outer.ph:
  %0 = load i32, ptr @a, align 4
  %tobool = icmp eq i32 %0, 0
  br i1 %tobool, label %outer.header, label %p.else

outer.header:
  %1 = phi i32 [ %.pr, %outer.ph ], [ %inc, %outer.latch ]
  br label %inner.loop

inner.loop:
  %iv = phi i32 [ 1, %outer.header ], [ %iv.next, %inner.loop ]
  %2 = phi i8 [ 1, %outer.header ], [ %dec, %inner.loop ]
  %conv7 = mul i32 %iv, 258
  %shl = and i32 %conv7, 510
  store i32 %shl, ptr @c, align 4
  %dec = add i8 %2, -1
  %cmp2 = icmp sgt i8 %dec, -1
  %iv.next = add i32 %iv, -1
  br i1 %cmp2, label %inner.loop, label %outer.latch

outer.latch:
  store i32 0, ptr @d, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, ptr @b, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %outer.header, label %outer.exit

outer.exit:
  store i8 %dec, ptr @e, align 1
  br label %merge

merge:
  %3 = phi i32 [ %.pre, %entry.else ], [ %shl, %outer.exit ]
  %call = tail call i32 @bar(i32 %3)
  br label %return

p.else:
  store i8 1, ptr @e, align 1
  store i32 0, ptr @d, align 4
  br label %return

return:
  %retval.0 = phi i32 [ 0, %merge ], [ 1, %p.else ]
  ret i32 %retval.0
}

declare i32 @bar(i32)

