; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -loop-reduce -S < %s | FileCheck %s
; PR9939

; LSR should properly handle the post-inc offset when folding the
; non-IV operand of an icmp into the IV.

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"

%struct.Vector2 = type { ptr, [64 x i16], i32 }

@.str = private unnamed_addr constant [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00"

define void @_Z15IntegerToStringjjR7Vector2(i32 %i, i32 %radix, ptr nocapture %result) nounwind noinline {
; CHECK-LABEL: @_Z15IntegerToStringjjR7Vector2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca [33 x i16], align 16
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr [33 x i16], ptr [[BUFFER]], i64 0, i64 33
; CHECK-NEXT:    [[SUB_PTR_LHS_CAST:%.*]] = ptrtoint ptr [[ADD_PTR]] to i64
; CHECK-NEXT:    [[SUB_PTR_RHS_CAST:%.*]] = ptrtoint ptr [[ADD_PTR]] to i64
; CHECK-NEXT:    [[SCEVGEP3:%.*]] = getelementptr nuw i8, ptr [[BUFFER]], i64 64
; CHECK-NEXT:    br label [[DO_BODY:%.*]]
; CHECK:       do.body:
; CHECK-NEXT:    [[LSR_IV10:%.*]] = phi i64 [ [[LSR_IV_NEXT11:%.*]], [[DO_BODY]] ], [ -1, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[LSR_IV8:%.*]] = phi ptr [ [[SCEVGEP9:%.*]], [[DO_BODY]] ], [ [[ADD_PTR]], [[ENTRY]] ]
; CHECK-NEXT:    [[LSR_IV4:%.*]] = phi ptr [ [[SCEVGEP5:%.*]], [[DO_BODY]] ], [ [[SCEVGEP3]], [[ENTRY]] ]
; CHECK-NEXT:    [[I_ADDR_0:%.*]] = phi i32 [ [[DIV:%.*]], [[DO_BODY]] ], [ [[I:%.*]], [[ENTRY]] ]
; CHECK-NEXT:    [[REM:%.*]] = urem i32 [[I_ADDR_0]], 10
; CHECK-NEXT:    [[DIV]] = udiv i32 [[I_ADDR_0]], 10
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext i32 [[REM]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [37 x i8], ptr @.str, i64 0, i64 [[IDXPROM]]
; CHECK-NEXT:    [[INST5:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[CONV:%.*]] = sext i8 [[INST5]] to i16
; CHECK-NEXT:    store i16 [[CONV]], ptr [[LSR_IV4]], align 2
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i32 [[I_ADDR_0]], 9
; CHECK-NEXT:    [[SCEVGEP5]] = getelementptr i8, ptr [[LSR_IV4]], i64 -2
; CHECK-NEXT:    [[SCEVGEP9]] = getelementptr i8, ptr [[LSR_IV8]], i64 -2
; CHECK-NEXT:    [[LSR_IV_NEXT11]] = add i64 [[LSR_IV10]], 1
; CHECK-NEXT:    br i1 [[TMP0]], label [[DO_BODY]], label [[DO_END:%.*]]
; CHECK:       do.end:
; CHECK-NEXT:    [[SCEVGEP9_LCSSA:%.*]] = phi ptr [ [[SCEVGEP9]], [[DO_BODY]] ]
; CHECK-NEXT:    [[XAP_0:%.*]] = inttoptr i64 [[LSR_IV_NEXT11]] to ptr
; CHECK-NEXT:    [[CAP_0:%.*]] = ptrtoint ptr [[XAP_0]] to i64
; CHECK-NEXT:    [[SUB_PTR_SUB:%.*]] = sub i64 [[SUB_PTR_LHS_CAST]], [[SUB_PTR_RHS_CAST]]
; CHECK-NEXT:    [[SUB_PTR_DIV39:%.*]] = lshr exact i64 [[SUB_PTR_SUB]], 1
; CHECK-NEXT:    [[CONV11:%.*]] = trunc i64 [[SUB_PTR_DIV39]] to i32
; CHECK-NEXT:    [[MLENGTH:%.*]] = getelementptr inbounds [[STRUCT_VECTOR2:%.*]], ptr [[RESULT:%.*]], i64 0, i32 2
; CHECK-NEXT:    [[IDX_EXT21:%.*]] = bitcast i64 [[SUB_PTR_DIV39]] to i64
; CHECK-NEXT:    [[CMP2740:%.*]] = icmp eq i64 [[IDX_EXT21]], 0
; CHECK-NEXT:    br i1 [[CMP2740]], label [[FOR_END:%.*]], label [[FOR_BODY_LR_PH:%.*]]
; CHECK:       for.body.lr.ph:
; CHECK-NEXT:    [[INST16:%.*]] = load i32, ptr [[MLENGTH]], align 4
; CHECK-NEXT:    [[INST14:%.*]] = load ptr, ptr [[RESULT]], align 8
; CHECK-NEXT:    [[INST48:%.*]] = zext i32 [[INST16]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = shl nuw nsw i64 [[INST48]], 1
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[INST14]], i64 [[TMP1]]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[LSR_IV6:%.*]] = phi ptr [ [[SCEVGEP7:%.*]], [[FOR_BODY]] ], [ [[SCEVGEP9_LCSSA]], [[FOR_BODY_LR_PH]] ]
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_LR_PH]] ]
; CHECK-NEXT:    [[SCEVGEP1:%.*]] = getelementptr i8, ptr [[SCEVGEP]], i64 [[LSR_IV]]
; CHECK-NEXT:    [[INST29:%.*]] = load i16, ptr [[LSR_IV6]], align 2
; CHECK-NEXT:    store i16 [[INST29]], ptr [[SCEVGEP1]], align 2
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], 2
; CHECK-NEXT:    [[LSR_IV_NEXT2:%.*]] = inttoptr i64 [[LSR_IV_NEXT]] to ptr
; CHECK-NEXT:    [[SCEVGEP7]] = getelementptr i8, ptr [[LSR_IV6]], i64 2
; CHECK-NEXT:    [[CMP27:%.*]] = icmp eq ptr [[LSR_IV_NEXT2]], null
; CHECK-NEXT:    br i1 [[CMP27]], label [[FOR_END_LOOPEXIT:%.*]], label [[FOR_BODY]]
; CHECK:       for.end.loopexit:
; CHECK-NEXT:    br label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    [[INST38:%.*]] = load i32, ptr [[MLENGTH]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[INST38]], [[CONV11]]
; CHECK-NEXT:    store i32 [[ADD]], ptr [[MLENGTH]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %buffer = alloca [33 x i16], align 16
  %add.ptr = getelementptr inbounds [33 x i16], ptr %buffer, i64 0, i64 33
  %sub.ptr.lhs.cast = ptrtoint ptr %add.ptr to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %add.ptr to i64
  br label %do.body

do.body:                                          ; preds = %do.body, %entry
  %0 = phi i64 [ %indvar.next44, %do.body ], [ 0, %entry ]
  %i.addr.0 = phi i32 [ %div, %do.body ], [ %i, %entry ]
  %inst51 = sub i64 32, %0
  %incdec.ptr = getelementptr [33 x i16], ptr %buffer, i64 0, i64 %inst51
  %rem = urem i32 %i.addr.0, 10
  %div = udiv i32 %i.addr.0, 10
  %idxprom = zext i32 %rem to i64
  %arrayidx = getelementptr inbounds [37 x i8], ptr @.str, i64 0, i64 %idxprom
  %inst5 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %inst5 to i16
  store i16 %conv, ptr %incdec.ptr, align 2
  %1 = icmp ugt i32 %i.addr.0, 9
  %indvar.next44 = add i64 %0, 1
  br i1 %1, label %do.body, label %do.end

do.end:                                           ; preds = %do.body
  %xap.0 = inttoptr i64 %0 to ptr
  %cap.0 = ptrtoint ptr %xap.0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div39 = lshr exact i64 %sub.ptr.sub, 1
  %conv11 = trunc i64 %sub.ptr.div39 to i32
  %mLength = getelementptr inbounds %struct.Vector2, ptr %result, i64 0, i32 2
  %idx.ext21 = bitcast i64 %sub.ptr.div39 to i64
  %incdec.ptr.sum = add i64 %idx.ext21, -1
  %cp.0.sum = sub i64 %incdec.ptr.sum, %0
  %add.ptr22 = getelementptr [33 x i16], ptr %buffer, i64 1, i64 %cp.0.sum
  %cmp2740 = icmp eq i64 %idx.ext21, 0
  br i1 %cmp2740, label %for.end, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %do.end
  %inst16 = load i32, ptr %mLength, align 4
  %inst14 = load ptr, ptr %result, align 8
  %inst48 = zext i32 %inst16 to i64
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.lr.ph
  %indvar = phi i64 [ 0, %for.body.lr.ph ], [ %indvar.next, %for.body ]
  %inst46 = add i64 %inst51, %indvar
  %p.042 = getelementptr [33 x i16], ptr %buffer, i64 0, i64 %inst46
  %inst47 = sub i64 %indvar, %0
  %incdec.ptr32 = getelementptr [33 x i16], ptr %buffer, i64 1, i64 %inst47
  %inst49 = add i64 %inst48, %indvar
  %dst.041 = getelementptr i16, ptr %inst14, i64 %inst49
  %inst29 = load i16, ptr %p.042, align 2
  store i16 %inst29, ptr %dst.041, align 2
  %cmp27 = icmp eq ptr %incdec.ptr32, %add.ptr22
  %indvar.next = add i64 %indvar, 1
  br i1 %cmp27, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %do.end
  %inst38 = load i32, ptr %mLength, align 4
  %add = add i32 %inst38, %conv11
  store i32 %add, ptr %mLength, align 4
  ret void
}
