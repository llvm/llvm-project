; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64-unknown-unknown | FileCheck %s

target datalayout = "e-m:w-p:64:64-i32:32-i64:64-i128:128-n32:64-S128"

; we need to generate post index load for this case
define i32 @test(i32 %c, ptr %a, ptr %b) {
; CHECK-LABEL: test:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp w0, #1
; CHECK-NEXT:    b.lt .LBB0_4
; CHECK-NEXT:  // %bb.1: // %for.body.preheader
; CHECK-NEXT:    mov w8, w0
; CHECK-NEXT:  .LBB0_2: // %for.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr w9, [x1]
; CHECK-NEXT:    cbnz w9, .LBB0_5
; CHECK-NEXT:  // %bb.3: // %for.cond
; CHECK-NEXT:    // in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    add x1, x1, #4
; CHECK-NEXT:    subs x8, x8, #1
; CHECK-NEXT:    b.ne .LBB0_2
; CHECK-NEXT:  .LBB0_4:
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_5:
; CHECK-NEXT:    mov w0, #1
; CHECK-NEXT:    ret
entry:
  %cmp13 = icmp sgt i32 %c, 0
  br i1 %cmp13, label %for.body.preheader, label %return

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %c to i64
  br label %for.body

for.cond:                                         ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %return, label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.cond
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.cond ]
  %arrayidx = getelementptr inbounds i32, ptr %a, i64 %indvars.iv
  %val = load i32, ptr %arrayidx, align 4
  %tobool3.not = icmp eq i32 %val, 0
  br i1 %tobool3.not, label %for.cond, label %return

return:                                           ; preds = %for.cond, %for.body, %entry
  %retval.1 = phi i32 [ 0, %entry ], [ 0, %for.cond ], [ 1, %for.body ]
  ret i32 %retval.1
}
