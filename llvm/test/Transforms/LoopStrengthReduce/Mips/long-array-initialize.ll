; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=loop-reduce,loop-term-fold -S | FileCheck %s --check-prefix=CHECK-OPT
; RUN: llc < %s -o - | FileCheck %s --check-prefix=CHECK-LLC

target datalayout = "E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64"
target triple = "mips-unknown-linux-gnu"

@x = dso_local local_unnamed_addr global [128000 x i32] zeroinitializer, align 4

; Function Attrs: nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none)
define dso_local void @in128000(i32 noundef signext %k, i32 noundef signext %n) local_unnamed_addr #0 {
; CHECK-LLC-LABEL: in128000:
; CHECK-LLC:       # %bb.0: # %entry
; CHECK-LLC-NEXT:    lui $1, %hi(x)
; CHECK-LLC-NEXT:    addiu $2, $1, %lo(x)
; CHECK-LLC-NEXT:    lui $1, 7
; CHECK-LLC-NEXT:    ori $1, $1, 53248
; CHECK-LLC-NEXT:    addu $3, $2, $1
; CHECK-LLC-NEXT:  $BB0_1: # %for.body
; CHECK-LLC-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-LLC-NEXT:    sw $4, 0($2)
; CHECK-LLC-NEXT:    addiu $2, $2, 4
; CHECK-LLC-NEXT:    bne $2, $3, $BB0_1
; CHECK-LLC-NEXT:    nop
; CHECK-LLC-NEXT:  # %bb.2: # %for.cond.cleanup
; CHECK-LLC-NEXT:    jr $ra
; CHECK-LLC-NEXT:    nop
; CHECK-OPT-LABEL: define dso_local void @in128000(
; CHECK-OPT-SAME: i32 noundef signext [[K:%.*]], i32 noundef signext [[N:%.*]]) local_unnamed_addr {
; CHECK-OPT-NEXT:  [[ENTRY:.*]]:
; CHECK-OPT-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-OPT:       [[FOR_COND_CLEANUP:.*]]:
; CHECK-OPT-NEXT:    ret void
; CHECK-OPT:       [[FOR_BODY]]:
; CHECK-OPT-NEXT:    [[LSR_IV1:%.*]] = phi ptr [ [[SCEVGEP:%.*]], %[[FOR_BODY]] ], [ @x, %[[ENTRY]] ]
; CHECK-OPT-NEXT:    store i32 [[K]], ptr [[LSR_IV1]], align 4
; CHECK-OPT-NEXT:    [[SCEVGEP]] = getelementptr i8, ptr [[LSR_IV1]], i32 4
; CHECK-OPT-NEXT:    [[LSR_FOLD_TERM_COND_REPLACED_TERM_COND:%.*]] = icmp eq ptr [[SCEVGEP]], getelementptr inbounds nuw (i8, ptr @x, i32 512000)
; CHECK-OPT-NEXT:    br i1 [[LSR_FOLD_TERM_COND_REPLACED_TERM_COND]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
;
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.03 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds nuw [128000 x i32], ptr @x, i32 0, i32 %i.03
  store i32 %k, ptr %arrayidx, align 4
  %inc = add nuw nsw i32 %i.03, 1
  %exitcond.not = icmp eq i32 %inc, 128000
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none)
define dso_local void @in1000(i32 noundef signext %k, i32 noundef signext %n) local_unnamed_addr #0 {
; CHECK-LLC-LABEL: in1000:
; CHECK-LLC:       # %bb.0: # %entry
; CHECK-LLC-NEXT:    lui $1, %hi(x)
; CHECK-LLC-NEXT:    addiu $2, $1, %lo(x)
; CHECK-LLC-NEXT:    addiu $3, $2, 4000
; CHECK-LLC-NEXT:  $BB1_1: # %for.body
; CHECK-LLC-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-LLC-NEXT:    sw $4, 0($2)
; CHECK-LLC-NEXT:    addiu $2, $2, 4
; CHECK-LLC-NEXT:    bne $2, $3, $BB1_1
; CHECK-LLC-NEXT:    nop
; CHECK-LLC-NEXT:  # %bb.2: # %for.cond.cleanup
; CHECK-LLC-NEXT:    jr $ra
; CHECK-LLC-NEXT:    nop
; CHECK-OPT-LABEL: define dso_local void @in1000(
; CHECK-OPT-SAME: i32 noundef signext [[K:%.*]], i32 noundef signext [[N:%.*]]) local_unnamed_addr {
; CHECK-OPT-NEXT:  [[ENTRY:.*]]:
; CHECK-OPT-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-OPT:       [[FOR_COND_CLEANUP:.*]]:
; CHECK-OPT-NEXT:    ret void
; CHECK-OPT:       [[FOR_BODY]]:
; CHECK-OPT-NEXT:    [[LSR_IV1:%.*]] = phi ptr [ [[SCEVGEP:%.*]], %[[FOR_BODY]] ], [ @x, %[[ENTRY]] ]
; CHECK-OPT-NEXT:    store i32 [[K]], ptr [[LSR_IV1]], align 4
; CHECK-OPT-NEXT:    [[SCEVGEP]] = getelementptr i8, ptr [[LSR_IV1]], i32 4
; CHECK-OPT-NEXT:    [[LSR_FOLD_TERM_COND_REPLACED_TERM_COND:%.*]] = icmp eq ptr [[SCEVGEP]], getelementptr inbounds nuw (i8, ptr @x, i32 4000)
; CHECK-OPT-NEXT:    br i1 [[LSR_FOLD_TERM_COND_REPLACED_TERM_COND]], label %[[FOR_COND_CLEANUP]], label %[[FOR_BODY]]
;
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.03 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds nuw [128000 x i32], ptr @x, i32 0, i32 %i.03
  store i32 %k, ptr %arrayidx, align 4
  %inc = add nuw nsw i32 %i.03, 1
  %exitcond.not = icmp eq i32 %inc, 1000
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

