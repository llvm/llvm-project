; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt < %s -loop-reduce -lsr-preferred-addressing-mode=none -S | FileCheck %s --check-prefixes=CHECK,CHECK-NONE
; RUN: opt < %s -loop-reduce -lsr-preferred-addressing-mode=preindexed -S | FileCheck %s --check-prefixes=CHECK,CHECK-PREINDEXED
; RUN: opt < %s -loop-reduce -lsr-preferred-addressing-mode=postindexed -S | FileCheck %s --check-prefixes=CHECK,CHECK-POSTINDEXED

target datalayout = "e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "thumbv7m-arm-none-eabi"

; This is an example where we should always pre/postincrement, as it can be
; folded into the load.
define i32 @has_load(ptr %p, i32 %n) {
; CHECK-NONE-LABEL: define i32 @has_load(
; CHECK-NONE-SAME: ptr [[P:%.*]], i32 [[N:%.*]]) {
; CHECK-NONE-NEXT:  entry:
; CHECK-NONE-NEXT:    br label [[LOOP:%.*]]
; CHECK-NONE:       loop:
; CHECK-NONE-NEXT:    [[LSR_IV1:%.*]] = phi ptr [ [[SCEVGEP:%.*]], [[LOOP]] ], [ [[P]], [[ENTRY:%.*]] ]
; CHECK-NONE-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], [[LOOP]] ], [ [[N]], [[ENTRY]] ]
; CHECK-NONE-NEXT:    [[ACC:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP]] ]
; CHECK-NONE-NEXT:    [[LOAD:%.*]] = load i32, ptr [[LSR_IV1]], align 4
; CHECK-NONE-NEXT:    [[ADD]] = add i32 [[ACC]], [[LOAD]]
; CHECK-NONE-NEXT:    [[LSR_IV_NEXT]] = add i32 [[LSR_IV]], -1
; CHECK-NONE-NEXT:    [[SCEVGEP]] = getelementptr i8, ptr [[LSR_IV1]], i32 4
; CHECK-NONE-NEXT:    [[COND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], 0
; CHECK-NONE-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK-NONE:       exit:
; CHECK-NONE-NEXT:    ret i32 [[ACC]]
;
; CHECK-PREINDEXED-LABEL: define i32 @has_load(
; CHECK-PREINDEXED-SAME: ptr [[P:%.*]], i32 [[N:%.*]]) {
; CHECK-PREINDEXED-NEXT:  entry:
; CHECK-PREINDEXED-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[P]], i32 -4
; CHECK-PREINDEXED-NEXT:    br label [[LOOP:%.*]]
; CHECK-PREINDEXED:       loop:
; CHECK-PREINDEXED-NEXT:    [[LSR_IV1:%.*]] = phi ptr [ [[SCEVGEP2:%.*]], [[LOOP]] ], [ [[SCEVGEP]], [[ENTRY:%.*]] ]
; CHECK-PREINDEXED-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], [[LOOP]] ], [ [[N]], [[ENTRY]] ]
; CHECK-PREINDEXED-NEXT:    [[ACC:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP]] ]
; CHECK-PREINDEXED-NEXT:    [[SCEVGEP3:%.*]] = getelementptr i8, ptr [[LSR_IV1]], i32 4
; CHECK-PREINDEXED-NEXT:    [[LOAD:%.*]] = load i32, ptr [[SCEVGEP3]], align 4
; CHECK-PREINDEXED-NEXT:    [[ADD]] = add i32 [[ACC]], [[LOAD]]
; CHECK-PREINDEXED-NEXT:    [[LSR_IV_NEXT]] = add i32 [[LSR_IV]], -1
; CHECK-PREINDEXED-NEXT:    [[SCEVGEP2]] = getelementptr i8, ptr [[LSR_IV1]], i32 4
; CHECK-PREINDEXED-NEXT:    [[COND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], 0
; CHECK-PREINDEXED-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK-PREINDEXED:       exit:
; CHECK-PREINDEXED-NEXT:    ret i32 [[ACC]]
;
; CHECK-POSTINDEXED-LABEL: define i32 @has_load(
; CHECK-POSTINDEXED-SAME: ptr [[P:%.*]], i32 [[N:%.*]]) {
; CHECK-POSTINDEXED-NEXT:  entry:
; CHECK-POSTINDEXED-NEXT:    br label [[LOOP:%.*]]
; CHECK-POSTINDEXED:       loop:
; CHECK-POSTINDEXED-NEXT:    [[LSR_IV1:%.*]] = phi ptr [ [[SCEVGEP:%.*]], [[LOOP]] ], [ [[P]], [[ENTRY:%.*]] ]
; CHECK-POSTINDEXED-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[LSR_IV_NEXT:%.*]], [[LOOP]] ], [ [[N]], [[ENTRY]] ]
; CHECK-POSTINDEXED-NEXT:    [[ACC:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP]] ]
; CHECK-POSTINDEXED-NEXT:    [[LOAD:%.*]] = load i32, ptr [[LSR_IV1]], align 4
; CHECK-POSTINDEXED-NEXT:    [[ADD]] = add i32 [[ACC]], [[LOAD]]
; CHECK-POSTINDEXED-NEXT:    [[LSR_IV_NEXT]] = add i32 [[LSR_IV]], -1
; CHECK-POSTINDEXED-NEXT:    [[SCEVGEP]] = getelementptr i8, ptr [[LSR_IV1]], i32 4
; CHECK-POSTINDEXED-NEXT:    [[COND:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], 0
; CHECK-POSTINDEXED-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK-POSTINDEXED:       exit:
; CHECK-POSTINDEXED-NEXT:    ret i32 [[ACC]]
;
entry:
  br label %loop

loop:
  %idx = phi i32 [ 0, %entry ], [ %idx.next, %loop ]
  %acc = phi i32 [ 0, %entry ], [ %add, %loop ]
  %gep = getelementptr i32, ptr %p, i32 %idx
  %load = load i32, ptr %gep, align 4
  %add = add i32 %acc, %load
  %idx.next = add nuw i32 %idx, 1
  %cond = icmp eq i32 %idx.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret i32 %acc
}

; Here there's no load, so there's nothing to fold a pre/postincrement into.
define i32 @no_mem_access(i32 %n) {
; CHECK-LABEL: define i32 @no_mem_access(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IDX:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IDX_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ACC:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ADD]] = add i32 [[ACC]], [[IDX]]
; CHECK-NEXT:    [[IDX_NEXT]] = add nuw i32 [[IDX]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[N]], [[IDX_NEXT]]
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 [[ACC]]
;
entry:
  br label %loop

loop:
  %idx = phi i32 [ 0, %entry ], [ %idx.next, %loop ]
  %acc = phi i32 [ 0, %entry ], [ %add, %loop ]
  %add = add i32 %acc, %idx
  %idx.next = add nuw i32 %idx, 1
  %cond = icmp eq i32 %idx.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret i32 %acc
}

; Here there's a load, but the address is generated in a way that means
; pre/postincrement isn't possible.
define i32 @has_load_bad_addr(ptr %p, i32 %n) {
; CHECK-LABEL: define i32 @has_load_bad_addr(
; CHECK-SAME: ptr [[P:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IDX:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IDX_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ACC:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[IDX]], 64
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[P]], i32 [[AND]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-NEXT:    [[ADD]] = add i32 [[ACC]], [[LOAD]]
; CHECK-NEXT:    [[IDX_NEXT]] = add nuw i32 [[IDX]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[N]], [[IDX_NEXT]]
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret i32 [[ACC]]
;
entry:
  br label %loop

loop:
  %idx = phi i32 [ 0, %entry ], [ %idx.next, %loop ]
  %acc = phi i32 [ 0, %entry ], [ %add, %loop ]
  %and = and i32 %idx, 64
  %gep = getelementptr i32, ptr %p, i32 %and
  %load = load i32, ptr %gep, align 4
  %add = add i32 %acc, %load
  %idx.next = add nuw i32 %idx, 1
  %cond = icmp eq i32 %idx.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret i32 %acc
}
