; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes=licm < %s | FileCheck %s

target triple = "aarch64-unknown-linux-gnu"

define i64 @sve_uaddv(<vscale x 4 x i32> %inv, i1 %c) {
; CHECK-LABEL: define i64 @sve_uaddv(
; CHECK-SAME: <vscale x 4 x i32> [[INV:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[UADDV:%.*]] = call i64 @llvm.aarch64.sve.uaddv.nxv4i32(<vscale x 4 x i1> splat (i1 true), <vscale x 4 x i32> [[INV]])
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i64 [[IV]], 1
; CHECK-NEXT:    [[BACKEDGE_COND:%.*]] = icmp ult i64 [[IV]], [[UADDV]]
; CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[C]], i1 [[BACKEDGE_COND]], i1 false
; CHECK-NEXT:    br i1 [[OR_COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[IV_LCSSA:%.*]] = phi i64 [ [[IV]], %[[LOOP]] ]
; CHECK-NEXT:    ret i64 [[IV_LCSSA]]
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %cond.true ]
  %iv.next = add i64 %iv, 1
  br i1 %c, label %cond.true, label %exit

cond.true:
  %uaddv = call i64 @llvm.aarch64.sve.uaddv.nxv4i32(<vscale x 4 x i1> splat (i1 true), <vscale x 4 x i32> %inv)
  %backedge.cond = icmp ult i64 %iv, %uaddv
  br i1 %backedge.cond, label %loop, label %exit

exit:
  ret i64 %iv
}

define i64 @sve_faddv(<vscale x 4 x float> %inv, i1 %c) {
; CHECK-LABEL: define i64 @sve_faddv(
; CHECK-SAME: <vscale x 4 x float> [[INV:%.*]], i1 [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[COND_TRUE:.*]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i64 [[IV]], 1
; CHECK-NEXT:    br i1 [[C]], label %[[COND_TRUE]], label %[[EXIT:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[FADDV:%.*]] = call float @llvm.aarch64.sve.faddv.nxv4f32(<vscale x 4 x i1> splat (i1 true), <vscale x 4 x float> [[INV]])
; CHECK-NEXT:    [[IV_AS_FLOAT:%.*]] = sitofp i64 [[IV]] to float
; CHECK-NEXT:    [[BACKEDGE_COND:%.*]] = fcmp olt float [[IV_AS_FLOAT]], [[FADDV]]
; CHECK-NEXT:    br i1 [[BACKEDGE_COND]], label %[[LOOP]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[IV_LCSSA:%.*]] = phi i64 [ [[IV]], %[[COND_TRUE]] ], [ [[IV]], %[[LOOP]] ]
; CHECK-NEXT:    ret i64 [[IV_LCSSA]]
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %cond.true ]
  %iv.next = add i64 %iv, 1
  br i1 %c, label %cond.true, label %exit

cond.true:
  %faddv = call float @llvm.aarch64.sve.faddv.nxv4i32(<vscale x 4 x i1> splat (i1 true), <vscale x 4 x float> %inv)
  %iv.as.float = sitofp i64 %iv to float
  %backedge.cond = fcmp olt float %iv.as.float, %faddv
  br i1 %backedge.cond, label %loop, label %exit

exit:
  ret i64 %iv
}
