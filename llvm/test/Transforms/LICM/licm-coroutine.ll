; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=licm -S | FileCheck %s

; %fca.0 and %fca.1 should not be hoisted out of the loop because the ramp
; function and resume function have different stack frames, so %pointer1 and
; %pointer2 have different values before and after @llvm.coro.suspend.

define ptr @f(i32 %n) presplitcoroutine {
; CHECK-LABEL: define ptr @f(
; CHECK-SAME: i32 [[N:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[POINTER1:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[POINTER2:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[ID:%.*]] = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
; CHECK-NEXT:    [[SIZE:%.*]] = call i32 @llvm.coro.size.i32()
; CHECK-NEXT:    [[ALLOC:%.*]] = call ptr @malloc(i32 [[SIZE]])
; CHECK-NEXT:    [[HDL:%.*]] = call noalias ptr @llvm.coro.begin(token [[ID]], ptr [[ALLOC]])
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[N_VAL:%.*]] = phi i32 [ [[N]], %[[ENTRY]] ], [ [[INC:%.*]], %[[RESUME:.*]] ]
; CHECK-NEXT:    [[INC]] = add nsw i32 [[N_VAL]], 1
; CHECK-NEXT:    call void @print(i32 [[N_VAL]])
; CHECK-NEXT:    [[TMP0:%.*]] = call i8 @llvm.coro.suspend(token none, i1 false)
; CHECK-NEXT:    switch i8 [[TMP0]], label %[[SUSPEND_LOOPEXIT:.*]] [
; CHECK-NEXT:      i8 0, label %[[RESUME]]
; CHECK-NEXT:      i8 1, label %[[CLEANUP:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[RESUME]]:
; CHECK-NEXT:    [[FCA_0:%.*]] = insertvalue [2 x ptr] poison, ptr [[POINTER1]], 0
; CHECK-NEXT:    [[FCA_1:%.*]] = insertvalue [2 x ptr] [[FCA_0]], ptr [[POINTER2]], 1
; CHECK-NEXT:    call void @foo([2 x ptr] [[FCA_1]])
; CHECK-NEXT:    br label %[[LOOP]]
; CHECK:       [[CLEANUP]]:
; CHECK-NEXT:    [[MEM:%.*]] = call ptr @llvm.coro.free(token [[ID]], ptr [[HDL]])
; CHECK-NEXT:    call void @free(ptr [[MEM]])
; CHECK-NEXT:    br label %[[SUSPEND:.*]]
; CHECK:       [[SUSPEND_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[SUSPEND]]
; CHECK:       [[SUSPEND]]:
; CHECK-NEXT:    [[UNUSED:%.*]] = call i1 @llvm.coro.end(ptr [[HDL]], i1 false, token none)
; CHECK-NEXT:    ret ptr [[HDL]]
;
entry:
  %pointer1 = alloca ptr
  %pointer2 = alloca ptr
  %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
  %size = call i32 @llvm.coro.size.i32()
  %alloc = call ptr @malloc(i32 %size)
  %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc)
  br label %loop

loop:
  %n.val = phi i32 [ %n, %entry ], [ %inc, %resume ]
  %inc = add nsw i32 %n.val, 1
  call void @print(i32 %n.val)
  %0 = call i8 @llvm.coro.suspend(token none, i1 false)
  switch i8 %0, label %suspend [i8 0, label %resume
  i8 1, label %cleanup]

resume:
  %fca.0 = insertvalue [2 x ptr] poison, ptr %pointer1, 0
  %fca.1 = insertvalue [2 x ptr] %fca.0, ptr %pointer2, 1
  call void @foo([2 x ptr] %fca.1)
  br label %loop

cleanup:
  %mem = call ptr @llvm.coro.free(token %id, ptr %hdl)
  call void @free(ptr %mem)
  br label %suspend
suspend:
  %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none)
  ret ptr %hdl
}

declare void @free(ptr)
declare ptr @malloc(i32)
declare void @print(i32)
declare void @foo([2 x ptr])
