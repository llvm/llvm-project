; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -aa-pipeline=basic-aa -passes='require<aa>,require<target-ir>,loop-mssa(licm)' < %s -S | FileCheck %s


define dso_local i32 @loop_alias(i32 %x, ptr %a, ptr %b)  #0{
; CHECK-LABEL: define dso_local i32 @loop_alias(
; CHECK-SAME: i32 [[X:%.*]], ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[VAL:%.*]] = getelementptr inbounds nuw i32, ptr [[A]], i64 1
; CHECK-NEXT:    call void @fn_write_inaccessible_mem()
; CHECK-NEXT:    call void @fn_read_inaccessible_mem()
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[GEP:%.*]], %[[LOOP]] ], [ [[VAL]], %[[ENTRY]] ]
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr i8, ptr [[PHI]], i64 0
; CHECK-NEXT:    [[VAL2:%.*]] = call i32 @fn_args(ptr [[GEP2]])
; CHECK-NEXT:    [[GEP]] = getelementptr inbounds nuw i32, ptr [[PHI]], i64 0
; CHECK-NEXT:    [[ACC:%.*]] = add nuw nsw i32 [[VAL2]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[ACC]], 10
; CHECK-NEXT:    br i1 [[CMP]], label %[[LOOP]], label %[[AFTER_LOOP:.*]]
; CHECK:       [[AFTER_LOOP]]:
; CHECK-NEXT:    [[ACC_LCSSA:%.*]] = phi i32 [ [[ACC]], %[[LOOP]] ]
; CHECK-NEXT:    ret i32 [[ACC_LCSSA]]
;
entry:
  %val = getelementptr inbounds nuw i32, ptr %a, i64 1
  br label %loop
loop:
  %phi = phi ptr [ %gep, %loop ], [ %val, %entry ]
  %44 = load i32, ptr %phi, align 16
  %gep2 = getelementptr i8, ptr %phi, i64 0
  %val2 = call i32 @fn_args(ptr  %gep2)
  call void @fn_write_inaccessible_mem()
  call void @fn_read_inaccessible_mem()
  %gep = getelementptr inbounds nuw i32, ptr %phi, i64 0
  %acc = add nuw nsw i32 %val2, 1
  %cmp = icmp ult i32 %acc, 10
  br i1 %cmp, label %loop, label %after_loop
after_loop:
  ret i32 %acc
}

declare i32  @fn_args(ptr) nounwind willreturn
memory(argmem: read)

define void @hoist_untill_I(ptr noalias %loc, ptr noalias %loc2){
; CHECK-LABEL: define void @hoist_untill_I(
; CHECK-SAME: ptr noalias [[LOC:%.*]], ptr noalias [[LOC2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[LOC2]], align 4
; CHECK-NEXT:    call void @fn_write_inaccessible_mem()
; CHECK-NEXT:    call void @fn_read_inaccessible_mem()
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_COND_CLEANUP:.*:]]
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    store i32 [[VAL]], ptr [[LOC]], align 4
; CHECK-NEXT:    br label %[[FOR_BODY]]
;
entry:
  br label %for.body
for.cond.cleanup:                                 ; preds = %for.body
  ret void
for.body:
  %val = load i32, ptr %loc2
  store i32 %val, ptr %loc
  call void @fn_write_inaccessible_mem()
  call void @fn_read_inaccessible_mem()
  br label %for.body
}


define void @neg_hoist_untill_I(ptr noalias %loc, ptr noalias %loc2){
; CHECK-LABEL: define void @neg_hoist_untill_I(
; CHECK-SAME: ptr noalias [[LOC:%.*]], ptr noalias [[LOC2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[LOC2]], align 4
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    store i32 [[VAL]], ptr [[LOC]], align 4
; CHECK-NEXT:    call void @fn_read_inaccessible_mem()
; CHECK-NEXT:    call void @fn_write_inaccessible_mem()
; CHECK-NEXT:    call void @fn_read_inaccessible_mem()
; CHECK-NEXT:    br label %[[FOR_BODY]]
;
entry:
  br label %for.body
for.body:
  %val = load i32, ptr %loc2
  store i32 %val, ptr %loc
  call void @fn_read_inaccessible_mem()
  call void @fn_write_inaccessible_mem()
  call void @fn_read_inaccessible_mem()
  br label %for.body
}


; Nothing should be hoisted from the loop because volatile
; sets inaccessible memory to read write
define void @neg_volatile(ptr %loc, ptr %loc2) {
; CHECK-LABEL: define void @neg_volatile(
; CHECK-SAME: ptr [[LOC:%.*]], ptr [[LOC2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    store volatile i32 0, ptr [[LOC]], align 4
; CHECK-NEXT:    call void @fn_write_inaccessible_mem()
; CHECK-NEXT:    call void @fn_read_inaccessible_mem()
; CHECK-NEXT:    br label %[[LOOP]]
;
entry:
  br label %loop

loop:
  %val = load i32, ptr %loc2
  store volatile i32 0, ptr %loc
  call void @fn_write_inaccessible_mem()
  call void @fn_read_inaccessible_mem()
  br label %loop
}

declare void @fn_write_inaccessible_mem()#0
  memory(inaccessiblemem:  write)

declare void @fn_read_inaccessible_mem()#0
  memory(inaccessiblemem: read)

declare void @fn_readwrite_inaccessible_mem()#0
  memory(inaccessiblemem: readwrite)

; Needs to set nounwind because of doesNotThrow
attributes #0 = { mustprogress nofree norecurse nosync nounwind}
