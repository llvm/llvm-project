; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=licm -verify-memoryssa -S | FileCheck %s

; We perform sinking here, Changed flag should be set properly.
define i32 @test(i32 %a, i32 %b, i32 %N) {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %add = add i32 %a, %b
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.next = add i32 %iv, 1
  %cmp = icmp slt i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 %add
}

define i32 @test_with_unused_load(i32 %a, ptr %b, i32 %N) {
; CHECK-LABEL: @test_with_unused_load(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A:%.*]], [[LOAD]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %load = load i32, ptr %b
  %add = add i32 %a, %load
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.next = add i32 %iv, 1
  %cmp = icmp slt i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 %add
}

define i32 @test_with_unused_load_modified_store(i32 %a, ptr %b, i32 %N) {
; CHECK-LABEL: @test_with_unused_load_modified_store(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], [[A:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[SMAX:%.*]] = phi i32 [ [[IV_NEXT]], [[LOOP]] ]
; CHECK-NEXT:    store i32 [[SMAX]], ptr [[B]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A]], [[LOAD]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %load = load i32, ptr %b
  %add = add i32 %a, %load
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.next = add i32 %iv, %a
  store i32 %iv.next, ptr %b
  %cmp = icmp slt i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 %add
}

; Volatile loads must not be sunk.
define i32 @test_with_volatile_load_no_sink(i32 %a, ptr %b, i32 %N) {
; CHECK-LABEL: @test_with_volatile_load_no_sink(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LD:%.*]] = load volatile i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A:%.*]], [[LD]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %ld = load volatile i32, ptr %b, align 4
  %add = add i32 %a, %ld
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.next = add i32 %iv, 1
  %cmp = icmp slt i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 %add
}

; Ordered/atomic loads must not be sunk.
define i32 @test_with_atomic_load_no_sink(i32 %a, ptr %b, i32 %N) {
; CHECK-LABEL: @test_with_atomic_load_no_sink(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LD:%.*]] = load atomic i32, ptr [[B:%.*]] acquire, align 4
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A:%.*]], [[LD]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %ld = load atomic i32, ptr %b acquire, align 4
  %add = add i32 %a, %ld
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.next = add i32 %iv, 1
  %cmp = icmp slt i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 %add
}

declare void @clobber(ptr)

; Calls that may write memory in the loop should prevent sinking the load.
define i32 @test_with_unused_load_clobbered_by_call(i32 %a, ptr %b, i32 %N) {
; CHECK-LABEL: @test_with_unused_load_clobbered_by_call(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LD:%.*]] = load i32, ptr [[B:%.*]], align 4
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    call void @clobber(ptr [[B]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[IV_NEXT]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[A:%.*]], [[LD]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %ld = load i32, ptr %b, align 4
  %add = add i32 %a, %ld
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.next = add i32 %iv, 1
  call void @clobber(ptr %b)
  %cmp = icmp slt i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  ret i32 %add
}
