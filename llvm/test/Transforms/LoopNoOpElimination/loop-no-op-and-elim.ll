; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -S | FileCheck %s

define i64 @elim_no_op_and(i64 %N) {
; CHECK-LABEL: define i64 @elim_no_op_and(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i64 [[N]], 4294967295
; CHECK-NEXT:    br i1 [[TMP0]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[TMP1]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[INDEX_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ugt i64 %N, 4294967295
  br i1 %cmp, label %end, label %vector.body
vector.body:
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ugt i64 %index.next, %N
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}

define i64 @elim_no_op_and_reverse_condition_1(i64 %N) {
; CHECK-LABEL: define i64 @elim_no_op_and_reverse_condition_1(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 4294967295, [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[AND]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[INDEX_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ult i64 4294967295, %N
  br i1 %cmp, label %end, label %vector.body
vector.body:
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ugt i64 %index.next, %N
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}


define i64 @elim_no_op_and_reverse_condition_2(i64 %N) {
; CHECK-LABEL: define i64 @elim_no_op_and_reverse_condition_2(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 4294967295, [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[AND]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ult i64 [[N]], [[INDEX_NEXT]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ult i64 4294967295, %N
  br i1 %cmp, label %end, label %vector.body
vector.body:
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ult i64 %N, %index.next
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}


define i64 @elim_no_op_and_reverse_condition_3(i64 %N) {
; CHECK-LABEL: define i64 @elim_no_op_and_reverse_condition_3(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i64 [[N]], 4294967295
; CHECK-NEXT:    br i1 [[CMP]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[AND]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ult i64 [[N]], [[INDEX_NEXT]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ugt i64 %N, 4294967295
  br i1 %cmp, label %end, label %vector.body
vector.body:
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ult i64 %N, %index.next
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}


define i64 @elim_no_op_and_loop_with_preheader(i64 %N) {
; CHECK-LABEL: define i64 @elim_no_op_and_loop_with_preheader(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i64 [[N]], 4294967295
; CHECK-NEXT:    br i1 [[TMP0]], label %[[END:.*]], label %[[VECTOR_PREHEADER:.*]]
; CHECK:       [[VECTOR_PREHEADER]]:
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PREHEADER]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[TMP1]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[INDEX_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ugt i64 %N, 4294967295
  br i1 %cmp, label %end, label %vector.preheader
vector.preheader:
  br label %vector.body
vector.body:
  %index = phi i64 [ 0, %vector.preheader ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ugt i64 %index.next, %N
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}

define i64 @fail_elim_no_op_and_latch_not_using_constant(i64 %N, i64 %C) {
; CHECK-LABEL: define i64 @fail_elim_no_op_and_latch_not_using_constant(
; CHECK-SAME: i64 [[N:%.*]], i64 [[C:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i64 [[N]], 4294967295
; CHECK-NEXT:    br i1 [[CMP]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[AND]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[INDEX_NEXT]], [[C]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ugt i64 %N, 4294967295
  br i1 %cmp, label %end, label %vector.body
vector.body:
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ugt i64 %index.next, %C
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N

}

define i64 @fail_elim_no_op_and_signed_conditional(i64 %N) {
; CHECK-LABEL: define i64 @fail_elim_no_op_and_signed_conditional(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i64 [[N]], 4294967295
; CHECK-NEXT:    br i1 [[CMP]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[AND]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[INDEX_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:                                 ; preds = %for.cond1.preheader.lr.ph
  %cmp = icmp sgt i64 %N, 4294967295
  br i1 %cmp, label %end, label %vector.body
vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ugt i64 %index.next, %N
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}

define i64 @fail_elim_no_op_and_branch_on_false(i64 %N) {
; CHECK-LABEL: define i64 @fail_elim_no_op_and_branch_on_false(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i64 [[N]], 4294967295
; CHECK-NEXT:    br i1 [[CMP]], label %[[VECTOR_BODY:.*]], label %[[END:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[AND]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[INDEX_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ugt i64 %N, 4294967295
  br i1 %cmp, label %vector.body, label %end
vector.body:
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ugt i64 %index.next, %N
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}

define i64 @fail_elim_no_op_and_large_mask(i64 %N) {
; CHECK-LABEL: define i64 @fail_elim_no_op_and_large_mask(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i64 [[N]], 1
; CHECK-NEXT:    br i1 [[CMP]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[INDEX]], 4294967295
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[AND]], 1
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[INDEX_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ugt i64 %N, 1
  br i1 %cmp, label %end, label %vector.body
vector.body:
  %index = phi i64 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %and = and i64 %index, 4294967295
  %index.next = add i64 %and, 1
  %exit.cond = icmp ugt i64 %index.next, %N
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}

define i64 @fail_elim_no_op_and_mismatched_types(i64 %N) {
; CHECK-LABEL: define i64 @fail_elim_no_op_and_mismatched_types(
; CHECK-SAME: i64 [[N:%.*]]) {
; CHECK-NEXT:  [[VECTOR_SCEVCHECK:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i64 [[N]], 4294967295
; CHECK-NEXT:    br i1 [[CMP]], label %[[END:.*]], label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_SCEVCHECK]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[EXT:%.*]] = zext i32 [[INDEX]] to i64
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[EXT]], 4294967295
; CHECK-NEXT:    [[EXIT_COND:%.*]] = icmp ugt i64 [[AND]], [[N]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 1
; CHECK-NEXT:    br i1 [[EXIT_COND]], label %[[END]], label %[[VECTOR_BODY]]
; CHECK:       [[END]]:
; CHECK-NEXT:    ret i64 [[N]]
;
vector.scevcheck:
  %cmp = icmp ugt i64 %N, 4294967295
  br i1 %cmp, label %end, label %vector.body
vector.body:
  %index = phi i32 [ 0, %vector.scevcheck ], [ %index.next, %vector.body ]
  %ext = zext i32 %index to i64
  %and = and i64 %ext, 4294967295
  %exit.cond = icmp ugt i64 %and, %N
  %index.next = add i32 %index, 1
  br i1 %exit.cond, label %end, label %vector.body
end:
  ret i64 %N
}
