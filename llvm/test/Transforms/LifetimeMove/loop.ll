; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=lifetime-move -S | FileCheck %s

; Test we correctly expose loop exiting blocks for lifetime.end
define void @fn1() presplitcoroutine {
; CHECK-LABEL: define void @fn1(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TESTVAL:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[TESTVAL]])
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY:.*]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], ptr [[I]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[STOREMERGE]], 500
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[TESTVAL]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[INC]] = add nsw i32 [[TMP1]], 1
; CHECK-NEXT:    br label %[[FOR_COND]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[TESTVAL]])
; CHECK-NEXT:    [[UNUSED:%.*]] = call i8 @llvm.coro.suspend(token none, i1 false)
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %testval = alloca i32, align 4
  %i = alloca i32, align 4
  call void @llvm.lifetime.start.p0(ptr nonnull %testval)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %coro.init
  %storemerge = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  store i32 %storemerge, ptr %i, align 4
  %cmp = icmp slt i32 %storemerge, 500
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %testval, align 4
  %1 = load i32, ptr %i, align 4
  %inc = add nsw i32 %1, 1
  br label %for.cond

for.cond.cleanup:
  %unused = call i8 @llvm.coro.suspend(token none, i1 false)
  br label %exit

exit:
  call void @llvm.lifetime.end.p0(ptr nonnull %testval)
  ret void
}

; Test do not move lifetime markers into a loop
define void @fn2(i1 %cond) presplitcoroutine {
; CHECK-LABEL: define void @fn2(
; CHECK-SAME: ) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TESTVAL:%.*]] = alloca i32, align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[TESTVAL]])
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[UNUSED:%.*]] = call i8 @llvm.coro.suspend(token none, i1 false)
; CHECK-NEXT:    br i1 %cond, label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[TESTVAL]])
; CHECK-NEXT:    ret void
;
entry:
  %testval = alloca i32, align 4
  call void @llvm.lifetime.start.p0(ptr nonnull %testval)
  br label %loop

loop:
  %unused = call i8 @llvm.coro.suspend(token none, i1 false)
  br i1 %cond, label %exit, label %loop

exit:
  call void @llvm.lifetime.end.p0(ptr nonnull %testval)
  ret void
}
