; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; Test we do not rise lifetime.end markers for allocas that may escape
; RUN: opt < %s -passes='lifetime-move' -S | FileCheck %s

define void @fn() presplitcoroutine {
; CHECK-LABEL: define void @fn(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ESCAPE_GEP:%.*]] = alloca [500 x i8], align 16
; CHECK-NEXT:    [[GEP_PTR:%.*]] = getelementptr inbounds nuw i8, ptr [[ESCAPE_GEP]], i64 8
; CHECK-NEXT:    [[ESCAPE_STORE:%.*]] = alloca [500 x i8], align 16
; CHECK-NEXT:    [[STORE_PTR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 500, ptr [[ESCAPE_STORE]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 8, ptr [[STORE_PTR]])
; CHECK-NEXT:    store ptr [[ESCAPE_STORE]], ptr [[STORE_PTR]], align 8
; CHECK-NEXT:    [[ESCAPE_CALL:%.*]] = alloca [500 x i8], align 16
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 500, ptr [[ESCAPE_CALL]])
; CHECK-NEXT:    call void @capture(ptr [[ESCAPE_CALL]])
; CHECK-NEXT:    [[UNUSED:%.*]] = call i8 @llvm.coro.suspend(token none, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 500, ptr [[ESCAPE_GEP]])
; CHECK-NEXT:    call void @capture(ptr [[GEP_PTR]])
; CHECK-NEXT:    call void @capture(ptr [[STORE_PTR]])
; CHECK-NEXT:    br label %[[END:.*]]
; CHECK:       [[END]]:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 500, ptr [[ESCAPE_GEP]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 500, ptr [[ESCAPE_STORE]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 500, ptr [[ESCAPE_CALL]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 8, ptr [[STORE_PTR]])
; CHECK-NEXT:    ret void
;
entry:
  %escape.gep = alloca [500 x i8], align 16
  call void @llvm.lifetime.start.p0(i64 500, ptr %escape.gep)
  %gep.ptr = getelementptr inbounds nuw i8, ptr %escape.gep, i64 8

  %escape.store = alloca [500 x i8], align 16
  %store.ptr = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 500, ptr %escape.store)
  call void @llvm.lifetime.start.p0(i64 8, ptr %store.ptr)
  store ptr %escape.store, ptr %store.ptr, align 8

  %escape.call = alloca [500 x i8], align 16
  call void @llvm.lifetime.start.p0(i64 500, ptr %escape.call)
  call void @capture(ptr %escape.call)

  %unused = call i8 @llvm.coro.suspend(token none, i1 false)
  call void @capture(ptr %gep.ptr)
  call void @capture(ptr %store.ptr)
  br label %end
end:
  call void @llvm.lifetime.end.p0(i64 500, ptr %escape.gep)
  call void @llvm.lifetime.end.p0(i64 500, ptr %escape.store)
  call void @llvm.lifetime.end.p0(i64 500, ptr %escape.call)
  call void @llvm.lifetime.end.p0(i64 8, ptr %store.ptr)
  ret void
}

declare void @capture(ptr)
