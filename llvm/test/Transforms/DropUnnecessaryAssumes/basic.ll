; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes=drop-unnecessary-assumes < %s | FileCheck %s

define void @basic_dead(i32 %x) {
; CHECK-LABEL: define void @basic_dead(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    ret void
;
  %cond = icmp sge i32 %x, 0
  call void @llvm.assume(i1 %cond)
  ret void
}

define i32 @basic_live(i32 %x) {
; CHECK-LABEL: define i32 @basic_live(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    [[COND:%.*]] = icmp sge i32 [[X]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    ret i32 [[X]]
;
  %cond = icmp sge i32 %x, 0
  call void @llvm.assume(i1 %cond)
  ret i32 %x
}

; Affected value is not direct operand of the condition.
define i32 @complex_live(i32 %x) {
; CHECK-LABEL: define i32 @complex_live(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[AND]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    ret i32 [[X]]
;
  %and = and i32 %x, 1
  %cond = icmp ne i32 %and, 0
  call void @llvm.assume(i1 %cond)
  ret i32 %x
}

; There are multiple affected values, and not all are one-use.
define i32 @multiple_live1(i32 %x, i32 %y) {
; CHECK-LABEL: define i32 @multiple_live1(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[X]], [[Y]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    ret i32 [[X]]
;
  %cond = icmp eq i32 %x, %y
  call void @llvm.assume(i1 %cond)
  ret i32 %x
}

define i32 @multiple_live2(i32 %x, i32 %y) {
; CHECK-LABEL: define i32 @multiple_live2(
; CHECK-SAME: i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[X]], [[Y]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    ret i32 [[Y]]
;
  %cond = icmp eq i32 %x, %y
  call void @llvm.assume(i1 %cond)
  ret i32 %y
}

define void @operand_bundle_dead(ptr %x) {
; CHECK-LABEL: define void @operand_bundle_dead(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[X]], i64 8) ]
; CHECK-NEXT:    ret void
;
  call void @llvm.assume(i1 true) ["align"(ptr %x, i64 8)]
  ret void
}

define ptr @operand_bundle_live(ptr %x) {
; CHECK-LABEL: define ptr @operand_bundle_live(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[X]], i64 8) ]
; CHECK-NEXT:    ret ptr [[X]]
;
  call void @llvm.assume(i1 true) ["align"(ptr %x, i64 8)]
  ret ptr %x
}

define void @type_test(ptr %x) {
; CHECK-LABEL: define void @type_test(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[TEST:%.*]] = call i1 @llvm.type.test(ptr [[X]], metadata !"typeid")
; CHECK-NEXT:    call void @llvm.assume(i1 [[TEST]])
; CHECK-NEXT:    ret void
;
  %test = call i1 @llvm.type.test(ptr %x, metadata !"typeid")
  call void @llvm.assume(i1 %test)
  ret void
}
