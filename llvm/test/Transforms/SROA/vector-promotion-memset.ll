; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes='sroa' -S | FileCheck %s
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-n8:16:32:64"

%struct_a = type { <32 x i8> }
define i8 @vector_promote_a(ptr %arg0) {
; CHECK-LABEL: @vector_promote_a(
; CHECK-NEXT:    [[V0:%.*]] = load i8, ptr [[ARG0:%.*]], align 1
; CHECK-NEXT:    [[A0_SROA_0_0_VEC_INSERT:%.*]] = insertelement <32 x i8> zeroinitializer, i8 [[V0]], i32 0
; CHECK-NEXT:    [[A0_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <32 x i8> [[A0_SROA_0_0_VEC_INSERT]], i32 4
; CHECK-NEXT:    ret i8 [[A0_SROA_0_4_VEC_EXTRACT]]
;
  %a0 = alloca %struct_a, align 32
  call void @llvm.memset.p0.i64(ptr align 32 %a0, i8 0, i64 32, i1 false)
  %v0 = load i8, ptr %arg0, align 1
  store i8 %v0, ptr %a0, align 1
  %p0 = getelementptr inbounds i8, ptr %a0, i64 4
  %v1 = load i8, ptr %p0, align 1
  ret i8 %v1
}

%struct_b = type { <16 x i16> }
define i16 @vector_promote_b(ptr %arg0) {
; CHECK-LABEL: @vector_promote_b(
; CHECK-NEXT:    [[V0:%.*]] = load i16, ptr [[ARG0:%.*]], align 1
; CHECK-NEXT:    [[A0_SROA_0_20_VEC_INSERT:%.*]] = insertelement <16 x i16> zeroinitializer, i16 [[V0]], i32 10
; CHECK-NEXT:    [[A0_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[A0_SROA_0_20_VEC_INSERT]], i32 2
; CHECK-NEXT:    ret i16 [[A0_SROA_0_4_VEC_EXTRACT]]
;
  %a0 = alloca %struct_b, align 32
  call void @llvm.memset.p0.i64(ptr align 32 %a0, i8 0, i64 32, i1 false)
  %v0 = load i16, ptr %arg0, align 1
  %p0 = getelementptr inbounds i16, ptr %a0, i64 10
  store i16 %v0, ptr %p0, align 1
  %p1 = getelementptr inbounds i16, ptr %a0, i64 2
  %v1 = load i16, ptr %p1, align 1
  ret i16 %v1
}

%struct_c = type { <4 x i32> }
define i32 @vector_promote_c(ptr %arg0) {
; CHECK-LABEL: @vector_promote_c(
; CHECK-NEXT:    [[V0:%.*]] = load i32, ptr [[ARG0:%.*]], align 1
; CHECK-NEXT:    [[A0_SROA_0_12_VEC_INSERT:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[V0]], i32 3
; CHECK-NEXT:    [[A0_SROA_0_8_VEC_EXTRACT:%.*]] = extractelement <4 x i32> [[A0_SROA_0_12_VEC_INSERT]], i32 2
; CHECK-NEXT:    ret i32 [[A0_SROA_0_8_VEC_EXTRACT]]
;
  %a0 = alloca %struct_c, align 32
  call void @llvm.memset.p0.i64(ptr align 32 %a0, i8 0, i64 16, i1 false)
  %v0 = load i32, ptr %arg0, align 1
  %p0 = getelementptr inbounds i32, ptr %a0, i64 3
  store i32 %v0, ptr %p0, align 1
  %p1 = getelementptr inbounds i32, ptr %a0, i64 2
  %v1 = load i32, ptr %p1, align 1
  ret i32 %v1
}

; These memsets do not get promoted because getTypePartition does not break
; vectors into smaller vectors.
%struct_d = type { <8 x i32> }
define i32 @vector_promote_d(ptr %arg0) {
; CHECK-LABEL: @vector_promote_d(
; CHECK-NEXT:    [[A0_SROA_0:%.*]] = alloca [3 x i32], align 32
; CHECK-NEXT:    [[A0_SROA_4:%.*]] = alloca [3 x i32], align 4
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 32 [[A0_SROA_0]], i8 0, i64 12, i1 false)
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[A0_SROA_4]], i8 1, i64 12, i1 false)
; CHECK-NEXT:    [[V0:%.*]] = load i32, ptr [[ARG0:%.*]], align 1
; CHECK-NEXT:    ret i32 16843009
;
  %a0 = alloca %struct_d, align 32

  call void @llvm.memset.p0.i64(ptr align 32 %a0, i8 0, i64 16, i1 false)
  %p0 = getelementptr inbounds i32, ptr %a0, i64 4
  call void @llvm.memset.p0.i64(ptr align 32 %p0, i8 1, i64 16, i1 false)

  %v0 = load i32, ptr %arg0, align 1
  %p1 = getelementptr inbounds i32, ptr %a0, i64 3
  store i32 %v0, ptr %p1, align 1
  %p2 = getelementptr inbounds i32, ptr %a0, i64 4
  %v1 = load i32, ptr %p2, align 1
  ret i32 %v1
}

%struct_e = type { %struct_c, %struct_c }
define i32 @vector_promote_e(ptr %arg0) {
; CHECK-LABEL: @vector_promote_e(
; CHECK-NEXT:    [[V0:%.*]] = load i32, ptr [[ARG0:%.*]], align 1
; CHECK-NEXT:    [[A0_SROA_0_12_VEC_INSERT:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[V0]], i32 3
; CHECK-NEXT:    [[A0_SROA_2_16_VEC_EXTRACT:%.*]] = extractelement <4 x i32> splat (i32 16843009), i32 0
; CHECK-NEXT:    ret i32 [[A0_SROA_2_16_VEC_EXTRACT]]
;
  %a0 = alloca %struct_e, align 32

  call void @llvm.memset.p0.i64(ptr align 32 %a0, i8 0, i64 16, i1 false)
  %p0 = getelementptr inbounds i32, ptr %a0, i64 4
  call void @llvm.memset.p0.i64(ptr align 32 %p0, i8 1, i64 16, i1 false)

  %v0 = load i32, ptr %arg0, align 1
  %p1 = getelementptr inbounds i32, ptr %a0, i64 3
  store i32 %v0, ptr %p1, align 1
  %p2 = getelementptr inbounds i32, ptr %a0, i64 4
  %v1 = load i32, ptr %p2, align 1
  ret i32 %v1
}

; Don't promote non-vector alloca type
%struct_f = type { [32 x i8] }
define i8 @vector_promote_f(ptr %arg0) {
; CHECK-LABEL: @vector_promote_f(
; CHECK-NEXT:    [[A0_SROA_2:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    [[A0_SROA_3:%.*]] = alloca [27 x i8], align 1
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 1 [[A0_SROA_2]], i8 0, i64 3, i1 false)
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 1 [[A0_SROA_3]], i8 0, i64 27, i1 false)
; CHECK-NEXT:    [[V0:%.*]] = load i8, ptr [[ARG0:%.*]], align 1
; CHECK-NEXT:    ret i8 0
;
  %a0 = alloca %struct_f, align 32
  call void @llvm.memset.p0.i64(ptr align 32 %a0, i8 0, i64 32, i1 false)
  %v0 = load i8, ptr %arg0, align 1
  store i8 %v0, ptr %a0, align 1
  %p0 = getelementptr inbounds i8, ptr %a0, i64 4
  %v1 = load i8, ptr %p0, align 1
  ret i8 %v1
}

; Don't promote memset that crosses vector partition boundary
%struct_g = type { i8, i8, i8, i8, <32 x i8> }
define i8 @vector_promote_g(ptr %arg0) {
; CHECK-LABEL: @vector_promote_g(
; CHECK-NEXT:    [[A0_SROA_2:%.*]] = alloca [27 x i8], align 1
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 1 [[A0_SROA_2]], i8 0, i64 27, i1 false)
; CHECK-NEXT:    ret i8 0
;
  %a0 = alloca %struct_g, align 32
  call void @llvm.memset.p0.i64(ptr align 32 %a0, i8 0, i64 36, i1 false)
  %p0 = getelementptr inbounds i8, ptr %a0, i64 8
  %v0 = load i8, ptr %p0, align 1
  ret i8 %v0
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr writeonly captures(none), i8, i64, i1 immarg) #0
declare void @llvm.memset.p0.i32(ptr writeonly captures(none), i8, i32, i1 immarg) #0

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }
