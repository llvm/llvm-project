; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=sroa -S | FileCheck %s

%S = type { [4 x i8] }

; Ensure the load/store of integer types whose size is not equal to the store
; size are not split.

define i8 @foo(i23 %0) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  Entry:
; CHECK-NEXT:    [[DOTSROA_0:%.*]] = alloca [3 x i8], align 8
; CHECK-NEXT:    store i23 [[TMP0:%.*]], ptr [[DOTSROA_0]], align 8
; CHECK-NEXT:    [[DOTSROA_0_1__SROA_IDX1:%.*]] = getelementptr inbounds i8, ptr [[DOTSROA_0]], i64 1
; CHECK-NEXT:    [[DOTSROA_0_1__SROA_0_1_:%.*]] = load i8, ptr [[DOTSROA_0_1__SROA_IDX1]], align 1
; CHECK-NEXT:    ret i8 [[DOTSROA_0_1__SROA_0_1_]]
;
Entry:
  %1 = alloca %S
  %2 = bitcast ptr %1 to ptr
  store i23 %0, ptr %2
  %3 = getelementptr inbounds %S, ptr %1, i64 0, i32 0, i32 1
  %4 = load i8, ptr %3
  ret i8 %4
}

define i32 @bar(i16 %0) {
; CHECK-LABEL: @bar(
; CHECK-NEXT:  Entry:
; CHECK-NEXT:    [[DOTSROA_0:%.*]] = alloca [3 x i8], align 8
; CHECK-NEXT:    store i16 [[TMP0:%.*]], ptr [[DOTSROA_0]], align 8
; CHECK-NEXT:    [[DOTSROA_0_0__SROA_0_0_:%.*]] = load i17, ptr [[DOTSROA_0]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = zext i17 [[DOTSROA_0_0__SROA_0_0_]] to i32
; CHECK-NEXT:    ret i32 [[TMP1]]
;
Entry:
  %1 = alloca %S
  %2 = bitcast ptr %1 to ptr
  store i16 %0, ptr %2
  %3 = getelementptr inbounds %S, ptr %1, i64 0, i32 0
  %4 = load i17, ptr %3
  %5 = zext i17 %4 to i32
  ret i32 %5
}
