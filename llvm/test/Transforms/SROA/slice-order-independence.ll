; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=sroa -S | FileCheck %s
target datalayout = "e-p:64:64:64-p1:16:16:16-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-n8:16:32:64"

declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i1) nounwind

; Check that the chosen type for a split is independent from the order of
; slices even in case of types that are skipped because their width is not a
; byte width multiple
define void @skipped_inttype_first({ i16*, i32 }*) {
; CHECK-LABEL: @skipped_inttype_first(
; CHECK-NEXT:    [[ARG_SROA_0:%.*]] = alloca i8*, align 8
; CHECK-NEXT:    [[ARG_SROA_0_0__SROA_CAST:%.*]] = bitcast { i16*, i32 }* [[TMP0:%.*]] to i8**
; CHECK-NEXT:    [[ARG_SROA_0_0_COPYLOAD:%.*]] = load i8*, i8** [[ARG_SROA_0_0__SROA_CAST]], align 8
; CHECK-NEXT:    store i8* [[ARG_SROA_0_0_COPYLOAD]], i8** [[ARG_SROA_0]], align 8
; CHECK-NEXT:    [[ARG_SROA_3_0__SROA_IDX1:%.*]] = getelementptr inbounds { i16*, i32 }, { i16*, i32 }* [[TMP0]], i64 0, i32 1
; CHECK-NEXT:    [[ARG_SROA_3_0__SROA_CAST:%.*]] = bitcast i32* [[ARG_SROA_3_0__SROA_IDX1]] to i64*
; CHECK-NEXT:    [[ARG_SROA_3_0_COPYLOAD:%.*]] = load i64, i64* [[ARG_SROA_3_0__SROA_CAST]], align 8
; CHECK-NEXT:    [[ARG_SROA_0_0_PB0_SROA_CAST2:%.*]] = bitcast i8** [[ARG_SROA_0]] to i63*
; CHECK-NEXT:    [[ARG_SROA_0_0_ARG_SROA_0_0_B0:%.*]] = load i63, i63* [[ARG_SROA_0_0_PB0_SROA_CAST2]], align 8
; CHECK-NEXT:    [[ARG_SROA_0_0_ARG_SROA_0_0_B1:%.*]] = load i8*, i8** [[ARG_SROA_0]], align 8
; CHECK-NEXT:    ret void
;
  %arg = alloca { i16*, i32 }, align 8
  %2 = bitcast { i16*, i32 }* %0 to i8*
  %3 = bitcast { i16*, i32 }* %arg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 %2, i32 16, i1 false)
  %b = getelementptr inbounds { i16*, i32 }, { i16*, i32 }* %arg, i64 0, i32 0
  %pb0 = bitcast i16** %b to i63*
  %b0 = load i63, i63* %pb0
  %pb1 = bitcast i16** %b to i8**
  %b1 = load i8*, i8** %pb1
  ret void
}

define void @skipped_inttype_last({ i16*, i32 }*) {
; CHECK-LABEL: @skipped_inttype_last(
; CHECK-NEXT:    [[ARG_SROA_0:%.*]] = alloca i8*, align 8
; CHECK-NEXT:    [[ARG_SROA_0_0__SROA_CAST:%.*]] = bitcast { i16*, i32 }* [[TMP0:%.*]] to i8**
; CHECK-NEXT:    [[ARG_SROA_0_0_COPYLOAD:%.*]] = load i8*, i8** [[ARG_SROA_0_0__SROA_CAST]], align 8
; CHECK-NEXT:    store i8* [[ARG_SROA_0_0_COPYLOAD]], i8** [[ARG_SROA_0]], align 8
; CHECK-NEXT:    [[ARG_SROA_3_0__SROA_IDX1:%.*]] = getelementptr inbounds { i16*, i32 }, { i16*, i32 }* [[TMP0]], i64 0, i32 1
; CHECK-NEXT:    [[ARG_SROA_3_0__SROA_CAST:%.*]] = bitcast i32* [[ARG_SROA_3_0__SROA_IDX1]] to i64*
; CHECK-NEXT:    [[ARG_SROA_3_0_COPYLOAD:%.*]] = load i64, i64* [[ARG_SROA_3_0__SROA_CAST]], align 8
; CHECK-NEXT:    [[ARG_SROA_0_0_ARG_SROA_0_0_B1:%.*]] = load i8*, i8** [[ARG_SROA_0]], align 8
; CHECK-NEXT:    [[ARG_SROA_0_0_PB0_SROA_CAST2:%.*]] = bitcast i8** [[ARG_SROA_0]] to i63*
; CHECK-NEXT:    [[ARG_SROA_0_0_ARG_SROA_0_0_B0:%.*]] = load i63, i63* [[ARG_SROA_0_0_PB0_SROA_CAST2]], align 8
; CHECK-NEXT:    ret void
;
  %arg = alloca { i16*, i32 }, align 8
  %2 = bitcast { i16*, i32 }* %0 to i8*
  %3 = bitcast { i16*, i32 }* %arg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %3, i8* align 8 %2, i32 16, i1 false)
  %b = getelementptr inbounds { i16*, i32 }, { i16*, i32 }* %arg, i64 0, i32 0
  %pb1 = bitcast i16** %b to i8**
  %b1 = load i8*, i8** %pb1
  %pb0 = bitcast i16** %b to i63*
  %b0 = load i63, i63* %pb0
  ret void
}
