; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes='sroa<preserve-cfg;decompose-structs>' %s | FileCheck %s --check-prefixes=CHECK,CHECK-PRESERVE-CFG
; RUN: opt -S -passes='sroa<modify-cfg;decompose-structs>' %s | FileCheck %s --check-prefixes=CHECK,CHECK-MODIFY-CFG

%struct.basic = type { i32, [2 x i32] }

define void @basic(i32 %i, i32 %v) {
; CHECK-LABEL: define void @basic(
; CHECK-SAME: i32 [[I:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [2 x i32], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    [[ARR_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1]], i32 0
; CHECK-NEXT:    [[ELEM:%.*]] = getelementptr inbounds [2 x i32], ptr [[ARR_1]], i32 0, i32 [[I]]
; CHECK-NEXT:    store i32 [[V]], ptr [[ELEM]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca %struct.basic
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  %arr = getelementptr inbounds %struct.basic, ptr %alloca, i32 0, i32 1
  %elem = getelementptr inbounds [2 x i32], ptr %arr, i32 0, i32 %i
  store i32 %v, ptr %elem
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

%struct.nested = type { [3 x double], %struct.basic }

define void @nested(i32 %i, i32 %v) {
; CHECK-LABEL: define void @nested(
; CHECK-SAME: i32 [[I:%.*]], i32 [[V:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_1_1:%.*]] = alloca [2 x i32], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1_1]])
; CHECK-NEXT:    [[BASIC_1_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1_1]], i32 0
; CHECK-NEXT:    [[ARRAY_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[BASIC_1_1]], i32 0
; CHECK-NEXT:    [[ELEM:%.*]] = getelementptr inbounds [2 x i32], ptr [[ARRAY_1]], i32 0, i32 [[I]]
; CHECK-NEXT:    store i32 [[V]], ptr [[ELEM]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca %struct.nested
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  %basic = getelementptr inbounds %struct.nested, ptr %alloca, i32 0, i32 1
  %array = getelementptr inbounds %struct.basic, ptr %basic, i32 0, i32 1
  %elem = getelementptr inbounds [2 x i32], ptr %array, i32 0, i32 %i
  store i32 %v, ptr %elem
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

define void @array1d(i32 %s, i32 %i) {
;
; CHECK-LABEL: define void @array1d(
; CHECK-SAME: i32 [[S:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [10 x [2 x i32]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    [[STRUCT_1:%.*]] = getelementptr inbounds [10 x [2 x i32]], ptr [[ALLOCA_1]], i32 0, i32 [[S]]
; CHECK-NEXT:    [[ARRAY_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[STRUCT_1]], i32 0
; CHECK-NEXT:    [[ELEM:%.*]] = getelementptr inbounds [2 x i32], ptr [[ARRAY_1]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[ELEM]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca [10 x %struct.basic]
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  %struct = getelementptr inbounds [10 x %struct.basic], ptr %alloca, i32 0, i32 %s
  %array = getelementptr inbounds %struct.basic, ptr %struct, i32 0, i32 1
  %elem = getelementptr inbounds [2 x i32], ptr %array, i32 0, i32 %i
  %load = load i32, ptr %elem
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

define void @array1d_2(i32 %s, i32 %i) {
;
; CHECK-LABEL: define void @array1d_2(
; CHECK-SAME: i32 [[S:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [10 x [2 x i32]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    [[ARRAY_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1]], i32 [[S]]
; CHECK-NEXT:    [[ELEM:%.*]] = getelementptr inbounds [2 x i32], ptr [[ARRAY_1]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[ELEM]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca [10 x %struct.basic]
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  %array = getelementptr inbounds %struct.basic, ptr %alloca, i32 %s, i32 1
  %elem = getelementptr inbounds [2 x i32], ptr %array, i32 0, i32 %i
  %load = load i32, ptr %elem
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

define void @array2d(i32 %si, i32 %sj, i32 %i) {
;
; CHECK-LABEL: define void @array2d(
; CHECK-SAME: i32 [[SI:%.*]], i32 [[SJ:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [3 x [2 x [2 x i32]]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    [[STRUCT_1:%.*]] = getelementptr inbounds [3 x [2 x [2 x i32]]], ptr [[ALLOCA_1]], i32 0, i32 [[SI]], i32 [[SJ]]
; CHECK-NEXT:    [[ARRAY_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[STRUCT_1]], i32 0
; CHECK-NEXT:    [[ELEM:%.*]] = getelementptr inbounds [2 x i32], ptr [[ARRAY_1]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[ELEM]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca [3 x [2 x %struct.basic]]
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  %struct = getelementptr inbounds [3 x [2 x %struct.basic]], ptr %alloca, i32 0, i32 %si, i32 %sj
  %array = getelementptr inbounds %struct.basic, ptr %struct, i32 0, i32 1
  %elem = getelementptr inbounds [2 x i32], ptr %array, i32 0, i32 %i
  %load = load i32, ptr %elem
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

define void @array2d_2(i32 %si, i32 %sj, i32 %i) {
;
; CHECK-LABEL: define void @array2d_2(
; CHECK-SAME: i32 [[SI:%.*]], i32 [[SJ:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [3 x [2 x [2 x i32]]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    [[ELEM_1:%.*]] = getelementptr inbounds [2 x [2 x i32]], ptr [[ALLOCA_1]], i32 [[SI]], i32 [[SJ]], i32 [[I]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[ELEM_1]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca [3 x [2 x %struct.basic]]
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  %elem = getelementptr inbounds [2 x %struct.basic], ptr %alloca, i32 %si, i32 %sj, i32 1, i32 %i
  %load = load i32, ptr %elem
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

%struct.S = type { [2 x %struct.X], [2 x %struct.Y] }
%struct.X = type { i32, float }
%struct.Y = type { i32, i32 }

define void @nested_structs_arrays(i32 %i) {
; CHECK-LABEL: define void @nested_structs_arrays(
; CHECK-SAME: i32 [[I:%.*]]) {
; CHECK-NEXT:    [[S_0_1:%.*]] = alloca [10 x [2 x float]], align 4
; CHECK-NEXT:    [[S_1_1:%.*]] = alloca [10 x [2 x i32]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[S_0_1]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[S_1_1]])
; CHECK-NEXT:    [[SI_0_1:%.*]] = getelementptr inbounds [2 x float], ptr [[S_0_1]], i32 [[I]]
; CHECK-NEXT:    [[SI_1_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[S_1_1]], i32 [[I]]
; CHECK-NEXT:    [[X_0_1:%.*]] = getelementptr inbounds [2 x float], ptr [[SI_0_1]], i32 0
; CHECK-NEXT:    [[B_1:%.*]] = getelementptr inbounds float, ptr [[X_0_1]], i32 [[I]]
; CHECK-NEXT:    [[LB:%.*]] = load float, ptr [[B_1]], align 1
; CHECK-NEXT:    [[Y_1_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[SI_1_1]], i32 0
; CHECK-NEXT:    [[D_1:%.*]] = getelementptr inbounds i32, ptr [[Y_1_1]], i32 [[I]]
; CHECK-NEXT:    [[LD:%.*]] = load i32, ptr [[D_1]], align 1
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[S_0_1]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[S_1_1]])
; CHECK-NEXT:    ret void
;
  %s = alloca [10 x %struct.S]
  call void @llvm.lifetime.start.p0(ptr nonnull %s)
  %si = getelementptr inbounds %struct.S, ptr %s, i32 %i
  %x = getelementptr inbounds %struct.S, ptr %si, i32 0, i32 0
  %b = getelementptr inbounds %struct.X, ptr %x, i32 %i, i32 1
  %lb = load float, ptr %b, align 1
  %y = getelementptr inbounds %struct.S, ptr %si, i32 0, i32 1
  %d = getelementptr inbounds %struct.Y, ptr %y, i32 %i, i32 1
  %ld = load i32, ptr %d, align 1
  call void @llvm.lifetime.end.p0(ptr nonnull %s)
  ret void
}

define void @memset_single_struct() {
; CHECK-LABEL: define void @memset_single_struct() {
; CHECK-NEXT:    [[ALLOCA_0:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [2 x i32], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[ALLOCA_0]], i8 0, i64 4, i1 false)
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[ALLOCA_1]], i8 0, i64 8, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca %struct.basic
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  call void @llvm.memset.p0.i32(ptr %alloca, i8 0, i32 12, i1 false)
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

define void @memset_array_of_structs() {
;
; CHECK-LABEL: define void @memset_array_of_structs() {
; CHECK-NEXT:    [[ALLOCA_0:%.*]] = alloca [2 x [2 x i32]], align 4
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [2 x [2 x [2 x i32]]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[ALLOCA_0]], i8 0, i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[ALLOCA_1]], i8 0, i64 32, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca [2 x [2 x %struct.basic]]
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  call void @llvm.memset.p0.i32(ptr %alloca, i8 0, i32 48, i1 false)
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

define void @memcpy_single_struct(ptr byval(%struct.basic) %arg) {
;
; CHECK-LABEL: define void @memcpy_single_struct(
; CHECK-SAME: ptr byval([[STRUCT_BASIC:%.*]]) [[ARG:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [2 x i32], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    [[ARG_0_0:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 0, i32 0
; CHECK-NEXT:    [[ALLOCA_0_0_COPYLOAD:%.*]] = load i32, ptr [[ARG_0_0]], align 1
; CHECK-NEXT:    [[ALLOCA_1_0:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1]], i32 0
; CHECK-NEXT:    [[ARG_0_1:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 0, i32 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_1_0]], ptr [[ARG_0_1]], i64 8, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca %struct.basic
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  call void @llvm.memcpy.p0.p0.i32(ptr %alloca, ptr %arg, i32 12, i1 false)
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

define void @memcpy_array_of_structs(ptr byval([2 x [2 x %struct.basic]]) %arg) {
; CHECK-LABEL: define void @memcpy_array_of_structs(
; CHECK-SAME: ptr byval([2 x [2 x %struct.basic]]) [[ARG:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_0:%.*]] = alloca [2 x [2 x i32]], align 4
; CHECK-NEXT:    [[ALLOCA_1:%.*]] = alloca [2 x [2 x [2 x i32]]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    [[ALLOCA_0_0:%.*]] = getelementptr inbounds i32, ptr [[ALLOCA_0]], i32 0
; CHECK-NEXT:    [[ARG_0_0:%.*]] = getelementptr inbounds [[STRUCT_BASIC:%.*]], ptr [[ARG]], i32 0, i32 0
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_0_0]], ptr [[ARG_0_0]], i64 16, i1 false)
; CHECK-NEXT:    [[ALLOCA_0_1:%.*]] = getelementptr inbounds i32, ptr [[ALLOCA_0]], i32 1
; CHECK-NEXT:    [[ARG_1_0:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 1, i32 0
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_0_1]], ptr [[ARG_1_0]], i64 16, i1 false)
; CHECK-NEXT:    [[ALLOCA_0_2:%.*]] = getelementptr inbounds i32, ptr [[ALLOCA_0]], i32 2
; CHECK-NEXT:    [[ARG_2_0:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 2, i32 0
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_0_2]], ptr [[ARG_2_0]], i64 16, i1 false)
; CHECK-NEXT:    [[ALLOCA_0_3:%.*]] = getelementptr inbounds i32, ptr [[ALLOCA_0]], i32 3
; CHECK-NEXT:    [[ARG_3_0:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 3, i32 0
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_0_3]], ptr [[ARG_3_0]], i64 16, i1 false)
; CHECK-NEXT:    [[ALLOCA_1_0:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1]], i32 0
; CHECK-NEXT:    [[ARG_0_1:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 0, i32 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_1_0]], ptr [[ARG_0_1]], i64 32, i1 false)
; CHECK-NEXT:    [[ALLOCA_1_1:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1]], i32 1
; CHECK-NEXT:    [[ARG_1_1:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 1, i32 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_1_1]], ptr [[ARG_1_1]], i64 32, i1 false)
; CHECK-NEXT:    [[ALLOCA_1_2:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1]], i32 2
; CHECK-NEXT:    [[ARG_2_1:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 2, i32 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_1_2]], ptr [[ARG_2_1]], i64 32, i1 false)
; CHECK-NEXT:    [[ALLOCA_1_3:%.*]] = getelementptr inbounds [2 x i32], ptr [[ALLOCA_1]], i32 3
; CHECK-NEXT:    [[ARG_3_1:%.*]] = getelementptr inbounds [[STRUCT_BASIC]], ptr [[ARG]], i32 3, i32 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[ALLOCA_1_3]], ptr [[ARG_3_1]], i64 32, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[ALLOCA_1]])
; CHECK-NEXT:    ret void
;
  %alloca = alloca [2 x [2 x %struct.basic]]
  call void @llvm.lifetime.start.p0(ptr nonnull %alloca)
  call void @llvm.memcpy.p0.p0.i32(ptr %alloca, ptr %arg, i32 48, i1 false)
  call void @llvm.lifetime.end.p0(ptr nonnull %alloca)
  ret void
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK-MODIFY-CFG: {{.*}}
; CHECK-PRESERVE-CFG: {{.*}}
