; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=sroa -S | FileCheck %s
; RUN: opt -passes='debugify,function(sroa)' -S < %s | FileCheck %s -check-prefix DEBUGLOC

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-n8:16:32:64"

declare void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define void @test1({ i8, i8 }* %a, { i8, i8 }* %b) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ALLOCA_SROA_0_0_GEP_A_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[A:%.*]], i64 0, i32 0
; CHECK-NEXT:    [[ALLOCA_SROA_0_0_COPYLOAD:%.*]] = load i8, i8* [[ALLOCA_SROA_0_0_GEP_A_SROA_IDX]], align 16
; CHECK-NEXT:    [[ALLOCA_SROA_3_0_GEP_A_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[A]], i64 0, i32 1
; CHECK-NEXT:    [[ALLOCA_SROA_3_0_COPYLOAD:%.*]] = load i8, i8* [[ALLOCA_SROA_3_0_GEP_A_SROA_IDX]], align 1
; CHECK-NEXT:    [[ALLOCA_SROA_0_0_GEP_B_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[B:%.*]], i64 0, i32 0
; CHECK-NEXT:    store i8 [[ALLOCA_SROA_0_0_COPYLOAD]], i8* [[ALLOCA_SROA_0_0_GEP_B_SROA_IDX]], align 16
; CHECK-NEXT:    [[ALLOCA_SROA_3_0_GEP_B_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[B]], i64 0, i32 1
; CHECK-NEXT:    store i8 [[ALLOCA_SROA_3_0_COPYLOAD]], i8* [[ALLOCA_SROA_3_0_GEP_B_SROA_IDX]], align 1
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test1(
; DEBUGLOC-NEXT:  entry:
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata { i8, i8 }* undef, metadata [[META9:![0-9]+]], metadata !DIExpression()), !dbg [[DBG14:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META11:![0-9]+]], metadata !DIExpression()), !dbg [[DBG15:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META12:![0-9]+]], metadata !DIExpression()), !dbg [[DBG16:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META13:![0-9]+]], metadata !DIExpression()), !dbg [[DBG17:![0-9]+]]
; DEBUGLOC-NEXT:    [[ALLOCA_SROA_0_0_GEP_A_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[A:%.*]], i64 0, i32 0, !dbg [[DBG18:![0-9]+]]
; DEBUGLOC-NEXT:    [[ALLOCA_SROA_0_0_COPYLOAD:%.*]] = load i8, i8* [[ALLOCA_SROA_0_0_GEP_A_SROA_IDX]], align 16, !dbg [[DBG18]]
; DEBUGLOC-NEXT:    [[ALLOCA_SROA_3_0_GEP_A_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[A]], i64 0, i32 1, !dbg [[DBG18]]
; DEBUGLOC-NEXT:    [[ALLOCA_SROA_3_0_COPYLOAD:%.*]] = load i8, i8* [[ALLOCA_SROA_3_0_GEP_A_SROA_IDX]], align 1, !dbg [[DBG18]]
; DEBUGLOC-NEXT:    [[ALLOCA_SROA_0_0_GEP_B_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[B:%.*]], i64 0, i32 0, !dbg [[DBG19:![0-9]+]]
; DEBUGLOC-NEXT:    store i8 [[ALLOCA_SROA_0_0_COPYLOAD]], i8* [[ALLOCA_SROA_0_0_GEP_B_SROA_IDX]], align 16, !dbg [[DBG19]]
; DEBUGLOC-NEXT:    [[ALLOCA_SROA_3_0_GEP_B_SROA_IDX:%.*]] = getelementptr inbounds { i8, i8 }, { i8, i8 }* [[B]], i64 0, i32 1, !dbg [[DBG19]]
; DEBUGLOC-NEXT:    store i8 [[ALLOCA_SROA_3_0_COPYLOAD]], i8* [[ALLOCA_SROA_3_0_GEP_B_SROA_IDX]], align 1, !dbg [[DBG19]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG20:![0-9]+]]
;

entry:
  %alloca = alloca { i8, i8 }, align 16
  %gep_a = getelementptr { i8, i8 }, { i8, i8 }* %a, i32 0, i32 0
  %gep_alloca = getelementptr { i8, i8 }, { i8, i8 }* %alloca, i32 0, i32 0
  %gep_b = getelementptr { i8, i8 }, { i8, i8 }* %b, i32 0, i32 0

  store i8 420, i8* %gep_alloca, align 16

  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %gep_alloca, i8* align 16 %gep_a, i32 2, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 16 %gep_b, i8* align 16 %gep_alloca, i32 2, i1 false)
  ret void
}

define void @test2() {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_SROA_0:%.*]] = alloca i16, align 2
; CHECK-NEXT:    store volatile i16 0, i16* [[A_SROA_0]], align 2
; CHECK-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_CAST:%.*]] = bitcast i16* [[A_SROA_0]] to i8*
; CHECK-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_IDX:%.*]] = getelementptr inbounds i8, i8* [[A_SROA_0_1_GEP2_SROA_RAW_CAST]], i64 1
; CHECK-NEXT:    [[A_SROA_0_1_A_SROA_0_2_RESULT:%.*]] = load i8, i8* [[A_SROA_0_1_GEP2_SROA_RAW_IDX]], align 1
; CHECK-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_CAST3:%.*]] = bitcast i16* [[A_SROA_0]] to i8*
; CHECK-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_IDX4:%.*]] = getelementptr inbounds i8, i8* [[A_SROA_0_1_GEP2_SROA_RAW_CAST3]], i64 1
; CHECK-NEXT:    store i8 42, i8* [[A_SROA_0_1_GEP2_SROA_RAW_IDX4]], align 1
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test2(
; DEBUGLOC-NEXT:  entry:
; DEBUGLOC-NEXT:    [[A_SROA_0:%.*]] = alloca i16, align 2, !dbg [[DBG29:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata { i8, i8, i8, i8 }* undef, metadata [[META23:![0-9]+]], metadata !DIExpression()), !dbg [[DBG29]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META24:![0-9]+]], metadata !DIExpression()), !dbg [[DBG30:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i16* undef, metadata [[META25:![0-9]+]], metadata !DIExpression()), !dbg [[DBG31:![0-9]+]]
; DEBUGLOC-NEXT:    store volatile i16 0, i16* [[A_SROA_0]], align 2, !dbg [[DBG32:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META26:![0-9]+]], metadata !DIExpression()), !dbg [[DBG33:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_CAST:%.*]] = bitcast i16* [[A_SROA_0]] to i8*, !dbg [[DBG34:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_IDX:%.*]] = getelementptr inbounds i8, i8* [[A_SROA_0_1_GEP2_SROA_RAW_CAST]], i64 1, !dbg [[DBG34]]
; DEBUGLOC-NEXT:    [[A_SROA_0_1_A_SROA_0_2_RESULT:%.*]] = load i8, i8* [[A_SROA_0_1_GEP2_SROA_RAW_IDX]], align 1, !dbg [[DBG34]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8 [[A_SROA_0_1_A_SROA_0_2_RESULT]], metadata [[META27:![0-9]+]], metadata !DIExpression()), !dbg [[DBG34]]
; DEBUGLOC-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_CAST3:%.*]] = bitcast i16* [[A_SROA_0]] to i8*, !dbg [[DBG35:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_1_GEP2_SROA_RAW_IDX4:%.*]] = getelementptr inbounds i8, i8* [[A_SROA_0_1_GEP2_SROA_RAW_CAST3]], i64 1, !dbg [[DBG35]]
; DEBUGLOC-NEXT:    store i8 42, i8* [[A_SROA_0_1_GEP2_SROA_RAW_IDX4]], align 1, !dbg [[DBG35]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG36:![0-9]+]]
;

; Check that when sroa rewrites the alloca partition
; it preserves the original DebugLocation.

entry:
  %a = alloca { i8, i8, i8, i8 }, align 2      ; "line 9" to -debugify
  %gep1 = getelementptr { i8, i8, i8, i8 }, { i8, i8, i8, i8 }* %a, i32 0, i32 1
  %cast1 = bitcast i8* %gep1 to i16*
  store volatile i16 0, i16* %cast1
  %gep2 = getelementptr { i8, i8, i8, i8 }, { i8, i8, i8, i8 }* %a, i32 0, i32 2
  %result = load i8, i8* %gep2
  store i8 42, i8* %gep2
  ret void
}

define void @PR13920(<2 x i64>* %a, i16* %b) {
; Test that alignments on memcpy intrinsics get propagated to loads and stores.
; CHECK-LABEL: @PR13920(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64>* [[A:%.*]], align 2
; CHECK-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16* [[B:%.*]] to <2 x i64>*
; CHECK-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64>* [[AA_0_BPTR_SROA_CAST]], align 2
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @PR13920(
; DEBUGLOC-NEXT:  entry:
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata <2 x i64>* undef, metadata [[META39:![0-9]+]], metadata !DIExpression()), !dbg [[DBG43:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META40:![0-9]+]], metadata !DIExpression()), !dbg [[DBG44:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META41:![0-9]+]], metadata !DIExpression()), !dbg [[DBG45:![0-9]+]]
; DEBUGLOC-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64>* [[A:%.*]], align 2, !dbg [[DBG46:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META42:![0-9]+]], metadata !DIExpression()), !dbg [[DBG47:![0-9]+]]
; DEBUGLOC-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16* [[B:%.*]] to <2 x i64>*, !dbg [[DBG48:![0-9]+]]
; DEBUGLOC-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64>* [[AA_0_BPTR_SROA_CAST]], align 2, !dbg [[DBG48]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG49:![0-9]+]]
;

entry:
  %aa = alloca <2 x i64>, align 16
  %aptr = bitcast <2 x i64>* %a to i8*
  %aaptr = bitcast <2 x i64>* %aa to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 2 %aaptr, i8* align 2 %aptr, i32 16, i1 false)
  %bptr = bitcast i16* %b to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 2 %bptr, i8* align 2 %aaptr, i32 16, i1 false)
  ret void
}

define void @test3(i8* %x) {
; Test that when we promote an alloca to a type with lower ABI alignment, we
; provide the needed explicit alignment that code using the alloca may be
; expecting. However, also check that any offset within an alloca can in turn
; reduce the alignment.
; CHECK-LABEL: @test3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_SROA_0:%.*]] = alloca [22 x i8], align 8
; CHECK-NEXT:    [[B_SROA_0:%.*]] = alloca [18 x i8], align 2
; CHECK-NEXT:    [[A_SROA_0_0_A_RAW_SROA_IDX:%.*]] = getelementptr inbounds [22 x i8], [22 x i8]* [[A_SROA_0]], i64 0, i64 0
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 [[A_SROA_0_0_A_RAW_SROA_IDX]], i8* align 8 [[X:%.*]], i32 22, i1 false)
; CHECK-NEXT:    [[B_SROA_0_6_B_GEP_SROA_IDX:%.*]] = getelementptr inbounds [18 x i8], [18 x i8]* [[B_SROA_0]], i64 0, i64 0
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 2 [[B_SROA_0_6_B_GEP_SROA_IDX]], i8* align 2 [[X]], i32 18, i1 false)
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test3(
; DEBUGLOC-NEXT:  entry:
; DEBUGLOC-NEXT:    [[A_SROA_0:%.*]] = alloca [22 x i8], align 8, !dbg [[DBG57:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata { i8*, i8*, i8* }* undef, metadata [[META52:![0-9]+]], metadata !DIExpression()), !dbg [[DBG57]]
; DEBUGLOC-NEXT:    [[B_SROA_0:%.*]] = alloca [18 x i8], align 2, !dbg [[DBG58:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata { i8*, i8*, i8* }* undef, metadata [[META53:![0-9]+]], metadata !DIExpression()), !dbg [[DBG58]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META54:![0-9]+]], metadata !DIExpression()), !dbg [[DBG59:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_A_RAW_SROA_IDX:%.*]] = getelementptr inbounds [22 x i8], [22 x i8]* [[A_SROA_0]], i64 0, i64 0, !dbg [[DBG60:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 [[A_SROA_0_0_A_RAW_SROA_IDX]], i8* align 8 [[X:%.*]], i32 22, i1 false), !dbg [[DBG60]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META55:![0-9]+]], metadata !DIExpression()), !dbg [[DBG61:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META56:![0-9]+]], metadata !DIExpression()), !dbg [[DBG62:![0-9]+]]
; DEBUGLOC-NEXT:    [[B_SROA_0_6_B_GEP_SROA_IDX:%.*]] = getelementptr inbounds [18 x i8], [18 x i8]* [[B_SROA_0]], i64 0, i64 0, !dbg [[DBG63:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 2 [[B_SROA_0_6_B_GEP_SROA_IDX]], i8* align 2 [[X]], i32 18, i1 false), !dbg [[DBG63]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG64:![0-9]+]]
;

entry:
  %a = alloca { i8*, i8*, i8* }
  %b = alloca { i8*, i8*, i8* }
  %a_raw = bitcast { i8*, i8*, i8* }* %a to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 8 %a_raw, i8* align 8 %x, i32 22, i1 false)
  %b_raw = bitcast { i8*, i8*, i8* }* %b to i8*
  %b_gep = getelementptr i8, i8* %b_raw, i32 6
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 2 %b_gep, i8* align 2 %x, i32 18, i1 false)
  ret void
}

define void @test5() {
; Test that we preserve underaligned loads and stores when splitting. The use
; of volatile in this test case is just to force the loads and stores to not be
; split or promoted out of existence.
;
; CHECK-LABEL: @test5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_SROA_0:%.*]] = alloca [9 x i8], align 1
; CHECK-NEXT:    [[A_SROA_3:%.*]] = alloca [9 x i8], align 1
; CHECK-NEXT:    [[A_SROA_0_0_PTR1_SROA_CAST2:%.*]] = bitcast [9 x i8]* [[A_SROA_0]] to double*
; CHECK-NEXT:    store volatile double 0.000000e+00, double* [[A_SROA_0_0_PTR1_SROA_CAST2]], align 1
; CHECK-NEXT:    [[A_SROA_0_7_WEIRD_CAST1_SROA_IDX4:%.*]] = getelementptr inbounds [9 x i8], [9 x i8]* [[A_SROA_0]], i64 0, i64 7
; CHECK-NEXT:    [[A_SROA_0_7_WEIRD_CAST1_SROA_CAST5:%.*]] = bitcast i8* [[A_SROA_0_7_WEIRD_CAST1_SROA_IDX4]] to i16*
; CHECK-NEXT:    [[A_SROA_0_7_A_SROA_0_7_WEIRD_LOAD1:%.*]] = load volatile i16, i16* [[A_SROA_0_7_WEIRD_CAST1_SROA_CAST5]], align 1
; CHECK-NEXT:    [[A_SROA_0_0_PTR1_SROA_CAST3:%.*]] = bitcast [9 x i8]* [[A_SROA_0]] to double*
; CHECK-NEXT:    [[A_SROA_0_0_A_SROA_0_0_D1:%.*]] = load double, double* [[A_SROA_0_0_PTR1_SROA_CAST3]], align 1
; CHECK-NEXT:    [[A_SROA_3_0_PTR2_SROA_CAST:%.*]] = bitcast [9 x i8]* [[A_SROA_3]] to double*
; CHECK-NEXT:    store volatile double [[A_SROA_0_0_A_SROA_0_0_D1]], double* [[A_SROA_3_0_PTR2_SROA_CAST]], align 1
; CHECK-NEXT:    [[A_SROA_3_7_WEIRD_CAST2_SROA_IDX:%.*]] = getelementptr inbounds [9 x i8], [9 x i8]* [[A_SROA_3]], i64 0, i64 7
; CHECK-NEXT:    [[A_SROA_3_7_WEIRD_CAST2_SROA_CAST:%.*]] = bitcast i8* [[A_SROA_3_7_WEIRD_CAST2_SROA_IDX]] to i16*
; CHECK-NEXT:    [[A_SROA_3_7_A_SROA_3_16_WEIRD_LOAD2:%.*]] = load volatile i16, i16* [[A_SROA_3_7_WEIRD_CAST2_SROA_CAST]], align 1
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test5(
; DEBUGLOC-NEXT:  entry:
; DEBUGLOC-NEXT:    [[A_SROA_0:%.*]] = alloca [9 x i8], align 1, !dbg [[DBG80:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_3:%.*]] = alloca [9 x i8], align 1, !dbg [[DBG80]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata [18 x i8]* undef, metadata [[META67:![0-9]+]], metadata !DIExpression()), !dbg [[DBG80]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META68:![0-9]+]], metadata !DIExpression()), !dbg [[DBG81:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double* undef, metadata [[META69:![0-9]+]], metadata !DIExpression()), !dbg [[DBG82:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_PTR1_SROA_CAST2:%.*]] = bitcast [9 x i8]* [[A_SROA_0]] to double*, !dbg [[DBG83:![0-9]+]]
; DEBUGLOC-NEXT:    store volatile double 0.000000e+00, double* [[A_SROA_0_0_PTR1_SROA_CAST2]], align 1, !dbg [[DBG83]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META70:![0-9]+]], metadata !DIExpression()), !dbg [[DBG84:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i16* undef, metadata [[META71:![0-9]+]], metadata !DIExpression()), !dbg [[DBG85:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_7_WEIRD_CAST1_SROA_IDX4:%.*]] = getelementptr inbounds [9 x i8], [9 x i8]* [[A_SROA_0]], i64 0, i64 7, !dbg [[DBG86:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_7_WEIRD_CAST1_SROA_CAST5:%.*]] = bitcast i8* [[A_SROA_0_7_WEIRD_CAST1_SROA_IDX4]] to i16*, !dbg [[DBG86]]
; DEBUGLOC-NEXT:    [[A_SROA_0_7_A_SROA_0_7_WEIRD_LOAD1:%.*]] = load volatile i16, i16* [[A_SROA_0_7_WEIRD_CAST1_SROA_CAST5]], align 1, !dbg [[DBG86]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i16 [[A_SROA_0_7_A_SROA_0_7_WEIRD_LOAD1]], metadata [[META72:![0-9]+]], metadata !DIExpression()), !dbg [[DBG86]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META74:![0-9]+]], metadata !DIExpression()), !dbg [[DBG87:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double* undef, metadata [[META75:![0-9]+]], metadata !DIExpression()), !dbg [[DBG88:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_PTR1_SROA_CAST3:%.*]] = bitcast [9 x i8]* [[A_SROA_0]] to double*, !dbg [[DBG89:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_A_SROA_0_0_D1:%.*]] = load double, double* [[A_SROA_0_0_PTR1_SROA_CAST3]], align 1, !dbg [[DBG89]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double [[A_SROA_0_0_A_SROA_0_0_D1]], metadata [[META76:![0-9]+]], metadata !DIExpression()), !dbg [[DBG89]]
; DEBUGLOC-NEXT:    [[A_SROA_3_0_PTR2_SROA_CAST:%.*]] = bitcast [9 x i8]* [[A_SROA_3]] to double*, !dbg [[DBG90:![0-9]+]]
; DEBUGLOC-NEXT:    store volatile double [[A_SROA_0_0_A_SROA_0_0_D1]], double* [[A_SROA_3_0_PTR2_SROA_CAST]], align 1, !dbg [[DBG90]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META77:![0-9]+]], metadata !DIExpression()), !dbg [[DBG91:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i16* undef, metadata [[META78:![0-9]+]], metadata !DIExpression()), !dbg [[DBG92:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_3_7_WEIRD_CAST2_SROA_IDX:%.*]] = getelementptr inbounds [9 x i8], [9 x i8]* [[A_SROA_3]], i64 0, i64 7, !dbg [[DBG93:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_3_7_WEIRD_CAST2_SROA_CAST:%.*]] = bitcast i8* [[A_SROA_3_7_WEIRD_CAST2_SROA_IDX]] to i16*, !dbg [[DBG93]]
; DEBUGLOC-NEXT:    [[A_SROA_3_7_A_SROA_3_16_WEIRD_LOAD2:%.*]] = load volatile i16, i16* [[A_SROA_3_7_WEIRD_CAST2_SROA_CAST]], align 1, !dbg [[DBG93]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i16 [[A_SROA_3_7_A_SROA_3_16_WEIRD_LOAD2]], metadata [[META79:![0-9]+]], metadata !DIExpression()), !dbg [[DBG93]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG94:![0-9]+]]
;

entry:
  %a = alloca [18 x i8]
  %raw1 = getelementptr inbounds [18 x i8], [18 x i8]* %a, i32 0, i32 0
  %ptr1 = bitcast i8* %raw1 to double*
  store volatile double 0.0, double* %ptr1, align 1
  %weird_gep1 = getelementptr inbounds [18 x i8], [18 x i8]* %a, i32 0, i32 7
  %weird_cast1 = bitcast i8* %weird_gep1 to i16*
  %weird_load1 = load volatile i16, i16* %weird_cast1, align 1

  %raw2 = getelementptr inbounds [18 x i8], [18 x i8]* %a, i32 0, i32 9
  %ptr2 = bitcast i8* %raw2 to double*
  %d1 = load double, double* %ptr1, align 1
  store volatile double %d1, double* %ptr2, align 1
  %weird_gep2 = getelementptr inbounds [18 x i8], [18 x i8]* %a, i32 0, i32 16
  %weird_cast2 = bitcast i8* %weird_gep2 to i16*
  %weird_load2 = load volatile i16, i16* %weird_cast2, align 1

  ret void
}

define void @test6() {
; We should set the alignment on all load and store operations; make sure
; we choose an appropriate alignment.
; CHECK-LABEL: @test6(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_SROA_0:%.*]] = alloca double, align 8
; CHECK-NEXT:    [[A_SROA_2:%.*]] = alloca double, align 8
; CHECK-NEXT:    store volatile double 0.000000e+00, double* [[A_SROA_0]], align 8
; CHECK-NEXT:    [[A_SROA_0_0_A_SROA_0_0_VAL:%.*]] = load double, double* [[A_SROA_0]], align 8
; CHECK-NEXT:    store volatile double [[A_SROA_0_0_A_SROA_0_0_VAL]], double* [[A_SROA_2]], align 8
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test6(
; DEBUGLOC-NEXT:  entry:
; DEBUGLOC-NEXT:    [[A_SROA_0:%.*]] = alloca double, align 8, !dbg [[DBG103:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_2:%.*]] = alloca double, align 8, !dbg [[DBG103]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata [16 x i8]* undef, metadata [[META97:![0-9]+]], metadata !DIExpression()), !dbg [[DBG103]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META98:![0-9]+]], metadata !DIExpression()), !dbg [[DBG104:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double* undef, metadata [[META99:![0-9]+]], metadata !DIExpression()), !dbg [[DBG105:![0-9]+]]
; DEBUGLOC-NEXT:    store volatile double 0.000000e+00, double* [[A_SROA_0]], align 8, !dbg [[DBG106:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META100:![0-9]+]], metadata !DIExpression()), !dbg [[DBG107:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double* undef, metadata [[META101:![0-9]+]], metadata !DIExpression()), !dbg [[DBG108:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_A_SROA_0_0_VAL:%.*]] = load double, double* [[A_SROA_0]], align 8, !dbg [[DBG109:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double [[A_SROA_0_0_A_SROA_0_0_VAL]], metadata [[META102:![0-9]+]], metadata !DIExpression()), !dbg [[DBG109]]
; DEBUGLOC-NEXT:    store volatile double [[A_SROA_0_0_A_SROA_0_0_VAL]], double* [[A_SROA_2]], align 8, !dbg [[DBG110:![0-9]+]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG111:![0-9]+]]
;

entry:
  %a = alloca [16 x i8]
  %raw1 = getelementptr inbounds [16 x i8], [16 x i8]* %a, i32 0, i32 0
  %ptr1 = bitcast i8* %raw1 to double*
  store volatile double 0.0, double* %ptr1, align 1

  %raw2 = getelementptr inbounds [16 x i8], [16 x i8]* %a, i32 0, i32 8
  %ptr2 = bitcast i8* %raw2 to double*
  %val = load double, double* %ptr1, align 1
  store volatile double %val, double* %ptr2, align 1

  ret void
}

define void @test7(i8* %out) {
; Test that we properly compute the destination alignment when rewriting
; memcpys as direct loads or stores.
; CHECK-LABEL: @test7(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A_SROA_0_0_OUT_SROA_CAST:%.*]] = bitcast i8* [[OUT:%.*]] to double*
; CHECK-NEXT:    [[A_SROA_0_0_COPYLOAD:%.*]] = load double, double* [[A_SROA_0_0_OUT_SROA_CAST]], align 1
; CHECK-NEXT:    [[A_SROA_4_0_OUT_SROA_IDX:%.*]] = getelementptr inbounds i8, i8* [[OUT]], i64 8
; CHECK-NEXT:    [[A_SROA_4_0_OUT_SROA_CAST:%.*]] = bitcast i8* [[A_SROA_4_0_OUT_SROA_IDX]] to double*
; CHECK-NEXT:    [[A_SROA_4_0_COPYLOAD:%.*]] = load double, double* [[A_SROA_4_0_OUT_SROA_CAST]], align 1
; CHECK-NEXT:    [[A_SROA_0_0_OUT_SROA_CAST1:%.*]] = bitcast i8* [[OUT]] to double*
; CHECK-NEXT:    store double [[A_SROA_4_0_COPYLOAD]], double* [[A_SROA_0_0_OUT_SROA_CAST1]], align 1
; CHECK-NEXT:    [[A_SROA_4_0_OUT_SROA_IDX3:%.*]] = getelementptr inbounds i8, i8* [[OUT]], i64 8
; CHECK-NEXT:    [[A_SROA_4_0_OUT_SROA_CAST4:%.*]] = bitcast i8* [[A_SROA_4_0_OUT_SROA_IDX3]] to double*
; CHECK-NEXT:    store double [[A_SROA_0_0_COPYLOAD]], double* [[A_SROA_4_0_OUT_SROA_CAST4]], align 1
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test7(
; DEBUGLOC-NEXT:  entry:
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata [16 x i8]* undef, metadata [[META114:![0-9]+]], metadata !DIExpression()), !dbg [[DBG121:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META115:![0-9]+]], metadata !DIExpression()), !dbg [[DBG122:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double* undef, metadata [[META116:![0-9]+]], metadata !DIExpression()), !dbg [[DBG123:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* undef, metadata [[META117:![0-9]+]], metadata !DIExpression()), !dbg [[DBG124:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double* undef, metadata [[META118:![0-9]+]], metadata !DIExpression()), !dbg [[DBG125:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_OUT_SROA_CAST:%.*]] = bitcast i8* [[OUT:%.*]] to double*, !dbg [[DBG126:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_COPYLOAD:%.*]] = load double, double* [[A_SROA_0_0_OUT_SROA_CAST]], align 1, !dbg [[DBG126]]
; DEBUGLOC-NEXT:    [[A_SROA_4_0_OUT_SROA_IDX:%.*]] = getelementptr inbounds i8, i8* [[OUT]], i64 8, !dbg [[DBG126]]
; DEBUGLOC-NEXT:    [[A_SROA_4_0_OUT_SROA_CAST:%.*]] = bitcast i8* [[A_SROA_4_0_OUT_SROA_IDX]] to double*, !dbg [[DBG126]]
; DEBUGLOC-NEXT:    [[A_SROA_4_0_COPYLOAD:%.*]] = load double, double* [[A_SROA_4_0_OUT_SROA_CAST]], align 1, !dbg [[DBG126]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double [[A_SROA_4_0_COPYLOAD]], metadata [[META119:![0-9]+]], metadata !DIExpression()), !dbg [[DBG127:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata double [[A_SROA_0_0_COPYLOAD]], metadata [[META120:![0-9]+]], metadata !DIExpression()), !dbg [[DBG128:![0-9]+]]
; DEBUGLOC-NEXT:    [[A_SROA_0_0_OUT_SROA_CAST1:%.*]] = bitcast i8* [[OUT]] to double*, !dbg [[DBG129:![0-9]+]]
; DEBUGLOC-NEXT:    store double [[A_SROA_4_0_COPYLOAD]], double* [[A_SROA_0_0_OUT_SROA_CAST1]], align 1, !dbg [[DBG129]]
; DEBUGLOC-NEXT:    [[A_SROA_4_0_OUT_SROA_IDX3:%.*]] = getelementptr inbounds i8, i8* [[OUT]], i64 8, !dbg [[DBG129]]
; DEBUGLOC-NEXT:    [[A_SROA_4_0_OUT_SROA_CAST4:%.*]] = bitcast i8* [[A_SROA_4_0_OUT_SROA_IDX3]] to double*, !dbg [[DBG129]]
; DEBUGLOC-NEXT:    store double [[A_SROA_0_0_COPYLOAD]], double* [[A_SROA_4_0_OUT_SROA_CAST4]], align 1, !dbg [[DBG129]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG130:![0-9]+]]
;

entry:
  %a = alloca [16 x i8]
  %raw1 = getelementptr inbounds [16 x i8], [16 x i8]* %a, i32 0, i32 0
  %ptr1 = bitcast i8* %raw1 to double*
  %raw2 = getelementptr inbounds [16 x i8], [16 x i8]* %a, i32 0, i32 8
  %ptr2 = bitcast i8* %raw2 to double*

  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %raw1, i8* %out, i32 16, i1 false)

  %val1 = load double, double* %ptr2, align 1
  %val2 = load double, double* %ptr1, align 1

  store double %val1, double* %ptr1, align 1
  store double %val2, double* %ptr2, align 1

  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %out, i8* %raw1, i32 16, i1 false)

  ret void
}

define void @test8() {
; CHECK-LABEL: @test8(
; CHECK-NEXT:    [[PTR:%.*]] = alloca [5 x i32], align 1
; CHECK-NEXT:    [[PTR_8:%.*]] = bitcast [5 x i32]* [[PTR]] to i8*
; CHECK-NEXT:    call void @populate(i8* [[PTR_8]])
; CHECK-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_LOAD:%.*]] = load i32, i32* [[VAL_FCA_0_GEP]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [5 x i32] poison, i32 [[VAL_FCA_0_LOAD]], 0
; CHECK-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_1_LOAD:%.*]] = load i32, i32* [[VAL_FCA_1_GEP]], align 1
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_0_INSERT]], i32 [[VAL_FCA_1_LOAD]], 1
; CHECK-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_2_LOAD:%.*]] = load i32, i32* [[VAL_FCA_2_GEP]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_1_INSERT]], i32 [[VAL_FCA_2_LOAD]], 2
; CHECK-NEXT:    [[VAL_FCA_3_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_3_LOAD:%.*]] = load i32, i32* [[VAL_FCA_3_GEP]], align 1
; CHECK-NEXT:    [[VAL_FCA_3_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_2_INSERT]], i32 [[VAL_FCA_3_LOAD]], 3
; CHECK-NEXT:    [[VAL_FCA_4_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 4
; CHECK-NEXT:    [[VAL_FCA_4_LOAD:%.*]] = load i32, i32* [[VAL_FCA_4_GEP]], align 1
; CHECK-NEXT:    [[VAL_FCA_4_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_3_INSERT]], i32 [[VAL_FCA_4_LOAD]], 4
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test8(
; DEBUGLOC-NEXT:    [[PTR:%.*]] = alloca [5 x i32], align 1, !dbg [[DBG137:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata [5 x i32]* [[PTR]], metadata [[META133:![0-9]+]], metadata !DIExpression()), !dbg [[DBG137]]
; DEBUGLOC-NEXT:    [[PTR_8:%.*]] = bitcast [5 x i32]* [[PTR]] to i8*, !dbg [[DBG138:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* [[PTR_8]], metadata [[META134:![0-9]+]], metadata !DIExpression()), !dbg [[DBG138]]
; DEBUGLOC-NEXT:    call void @populate(i8* [[PTR_8]]), !dbg [[DBG139:![0-9]+]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 0, !dbg [[DBG140:![0-9]+]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_LOAD:%.*]] = load i32, i32* [[VAL_FCA_0_GEP]], align 1, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [5 x i32] poison, i32 [[VAL_FCA_0_LOAD]], 0, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 1, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_LOAD:%.*]] = load i32, i32* [[VAL_FCA_1_GEP]], align 1, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_0_INSERT]], i32 [[VAL_FCA_1_LOAD]], 1, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 2, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_LOAD:%.*]] = load i32, i32* [[VAL_FCA_2_GEP]], align 1, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_1_INSERT]], i32 [[VAL_FCA_2_LOAD]], 2, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 3, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_LOAD:%.*]] = load i32, i32* [[VAL_FCA_3_GEP]], align 1, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_2_INSERT]], i32 [[VAL_FCA_3_LOAD]], 3, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_4_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 4, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_4_LOAD:%.*]] = load i32, i32* [[VAL_FCA_4_GEP]], align 1, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    [[VAL_FCA_4_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_3_INSERT]], i32 [[VAL_FCA_4_LOAD]], 4, !dbg [[DBG140]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata [5 x i32] [[VAL_FCA_4_INSERT]], metadata [[META135:![0-9]+]], metadata !DIExpression()), !dbg [[DBG140]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG141:![0-9]+]]
;

  %ptr = alloca [5 x i32], align 1
  %ptr.8 = bitcast [5 x i32]* %ptr to i8*
  call void @populate(i8* %ptr.8)
  %val = load [5 x i32], [5 x i32]* %ptr, align 1
  ret void
}

define void @test9() {
; CHECK-LABEL: @test9(
; CHECK-NEXT:    [[PTR:%.*]] = alloca [5 x i32], align 8
; CHECK-NEXT:    [[PTR_8:%.*]] = bitcast [5 x i32]* [[PTR]] to i8*
; CHECK-NEXT:    call void @populate(i8* [[PTR_8]])
; CHECK-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_LOAD:%.*]] = load i32, i32* [[VAL_FCA_0_GEP]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [5 x i32] poison, i32 [[VAL_FCA_0_LOAD]], 0
; CHECK-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_1_LOAD:%.*]] = load i32, i32* [[VAL_FCA_1_GEP]], align 4
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_0_INSERT]], i32 [[VAL_FCA_1_LOAD]], 1
; CHECK-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_2_LOAD:%.*]] = load i32, i32* [[VAL_FCA_2_GEP]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_1_INSERT]], i32 [[VAL_FCA_2_LOAD]], 2
; CHECK-NEXT:    [[VAL_FCA_3_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_3_LOAD:%.*]] = load i32, i32* [[VAL_FCA_3_GEP]], align 4
; CHECK-NEXT:    [[VAL_FCA_3_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_2_INSERT]], i32 [[VAL_FCA_3_LOAD]], 3
; CHECK-NEXT:    [[VAL_FCA_4_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 4
; CHECK-NEXT:    [[VAL_FCA_4_LOAD:%.*]] = load i32, i32* [[VAL_FCA_4_GEP]], align 8
; CHECK-NEXT:    [[VAL_FCA_4_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_3_INSERT]], i32 [[VAL_FCA_4_LOAD]], 4
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test9(
; DEBUGLOC-NEXT:    [[PTR:%.*]] = alloca [5 x i32], align 8, !dbg [[DBG147:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata [5 x i32]* [[PTR]], metadata [[META144:![0-9]+]], metadata !DIExpression()), !dbg [[DBG147]]
; DEBUGLOC-NEXT:    [[PTR_8:%.*]] = bitcast [5 x i32]* [[PTR]] to i8*, !dbg [[DBG148:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* [[PTR_8]], metadata [[META145:![0-9]+]], metadata !DIExpression()), !dbg [[DBG148]]
; DEBUGLOC-NEXT:    call void @populate(i8* [[PTR_8]]), !dbg [[DBG149:![0-9]+]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 0, !dbg [[DBG150:![0-9]+]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_LOAD:%.*]] = load i32, i32* [[VAL_FCA_0_GEP]], align 8, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [5 x i32] poison, i32 [[VAL_FCA_0_LOAD]], 0, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 1, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_LOAD:%.*]] = load i32, i32* [[VAL_FCA_1_GEP]], align 4, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_0_INSERT]], i32 [[VAL_FCA_1_LOAD]], 1, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 2, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_LOAD:%.*]] = load i32, i32* [[VAL_FCA_2_GEP]], align 8, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_1_INSERT]], i32 [[VAL_FCA_2_LOAD]], 2, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 3, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_LOAD:%.*]] = load i32, i32* [[VAL_FCA_3_GEP]], align 4, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_2_INSERT]], i32 [[VAL_FCA_3_LOAD]], 3, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_4_GEP:%.*]] = getelementptr inbounds [5 x i32], [5 x i32]* [[PTR]], i32 0, i32 4, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_4_LOAD:%.*]] = load i32, i32* [[VAL_FCA_4_GEP]], align 8, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    [[VAL_FCA_4_INSERT:%.*]] = insertvalue [5 x i32] [[VAL_FCA_3_INSERT]], i32 [[VAL_FCA_4_LOAD]], 4, !dbg [[DBG150]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata [5 x i32] [[VAL_FCA_4_INSERT]], metadata [[META146:![0-9]+]], metadata !DIExpression()), !dbg [[DBG150]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG151:![0-9]+]]
;

  %ptr = alloca [5 x i32], align 8
  %ptr.8 = bitcast [5 x i32]* %ptr to i8*
  call void @populate(i8* %ptr.8)
  %val = load [5 x i32], [5 x i32]* %ptr, align 8
  ret void
}

define void @test10() {
; CHECK-LABEL: @test10(
; CHECK-NEXT:    [[PTR:%.*]] = alloca { i32, i8, i8, { i8, i16 } }, align 2
; CHECK-NEXT:    [[PTR_8:%.*]] = bitcast { i32, i8, i8, { i8, i16 } }* [[PTR]] to i8*
; CHECK-NEXT:    call void @populate(i8* [[PTR_8]])
; CHECK-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_LOAD:%.*]] = load i32, i32* [[VAL_FCA_0_GEP]], align 2
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } poison, i32 [[VAL_FCA_0_LOAD]], 0
; CHECK-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_1_LOAD:%.*]] = load i8, i8* [[VAL_FCA_1_GEP]], align 2
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_0_INSERT]], i8 [[VAL_FCA_1_LOAD]], 1
; CHECK-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_2_LOAD:%.*]] = load i8, i8* [[VAL_FCA_2_GEP]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_1_INSERT]], i8 [[VAL_FCA_2_LOAD]], 2
; CHECK-NEXT:    [[VAL_FCA_3_0_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 3, i32 0
; CHECK-NEXT:    [[VAL_FCA_3_0_LOAD:%.*]] = load i8, i8* [[VAL_FCA_3_0_GEP]], align 2
; CHECK-NEXT:    [[VAL_FCA_3_0_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_2_INSERT]], i8 [[VAL_FCA_3_0_LOAD]], 3, 0
; CHECK-NEXT:    [[VAL_FCA_3_1_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 3, i32 1
; CHECK-NEXT:    [[VAL_FCA_3_1_LOAD:%.*]] = load i16, i16* [[VAL_FCA_3_1_GEP]], align 2
; CHECK-NEXT:    [[VAL_FCA_3_1_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_3_0_INSERT]], i16 [[VAL_FCA_3_1_LOAD]], 3, 1
; CHECK-NEXT:    ret void
;
; DEBUGLOC-LABEL: @test10(
; DEBUGLOC-NEXT:    [[PTR:%.*]] = alloca { i32, i8, i8, { i8, i16 } }, align 2, !dbg [[DBG158:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata { i32, i8, i8, { i8, i16 } }* [[PTR]], metadata [[META154:![0-9]+]], metadata !DIExpression()), !dbg [[DBG158]]
; DEBUGLOC-NEXT:    [[PTR_8:%.*]] = bitcast { i32, i8, i8, { i8, i16 } }* [[PTR]] to i8*, !dbg [[DBG159:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8* [[PTR_8]], metadata [[META155:![0-9]+]], metadata !DIExpression()), !dbg [[DBG159]]
; DEBUGLOC-NEXT:    call void @populate(i8* [[PTR_8]]), !dbg [[DBG160:![0-9]+]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 0, !dbg [[DBG161:![0-9]+]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_LOAD:%.*]] = load i32, i32* [[VAL_FCA_0_GEP]], align 2, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } poison, i32 [[VAL_FCA_0_LOAD]], 0, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 1, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_LOAD:%.*]] = load i8, i8* [[VAL_FCA_1_GEP]], align 2, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_0_INSERT]], i8 [[VAL_FCA_1_LOAD]], 1, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 2, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_LOAD:%.*]] = load i8, i8* [[VAL_FCA_2_GEP]], align 1, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_1_INSERT]], i8 [[VAL_FCA_2_LOAD]], 2, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_0_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 3, i32 0, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_0_LOAD:%.*]] = load i8, i8* [[VAL_FCA_3_0_GEP]], align 2, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_0_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_2_INSERT]], i8 [[VAL_FCA_3_0_LOAD]], 3, 0, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_1_GEP:%.*]] = getelementptr inbounds { i32, i8, i8, { i8, i16 } }, { i32, i8, i8, { i8, i16 } }* [[PTR]], i32 0, i32 3, i32 1, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_1_LOAD:%.*]] = load i16, i16* [[VAL_FCA_3_1_GEP]], align 2, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    [[VAL_FCA_3_1_INSERT:%.*]] = insertvalue { i32, i8, i8, { i8, i16 } } [[VAL_FCA_3_0_INSERT]], i16 [[VAL_FCA_3_1_LOAD]], 3, 1, !dbg [[DBG161]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata { i32, i8, i8, { i8, i16 } } [[VAL_FCA_3_1_INSERT]], metadata [[META156:![0-9]+]], metadata !DIExpression()), !dbg [[DBG161]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG162:![0-9]+]]
;

  %ptr = alloca {i32, i8, i8, {i8, i16}}, align 2
  %ptr.8 = bitcast {i32, i8, i8, {i8, i16}}* %ptr to i8*
  call void @populate(i8* %ptr.8)
  %val = load {i32, i8, i8, {i8, i16}}, {i32, i8, i8, {i8, i16}}* %ptr, align 2
  ret void
}

%struct = type { i32, i32 }
define dso_local i32 @pr45010(%struct* %A) {
; CHECK-LABEL: @pr45010(
; CHECK-NEXT:    [[B_SROA_0:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[A_I:%.*]] = getelementptr inbounds [[STRUCT:%.*]], %struct* [[A:%.*]], i32 0, i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[A_I]], align 4
; CHECK-NEXT:    store atomic volatile i32 [[TMP1]], i32* [[B_SROA_0]] release, align 4
; CHECK-NEXT:    [[B_SROA_0_0_B_SROA_0_0_X:%.*]] = load atomic volatile i32, i32* [[B_SROA_0]] acquire, align 4
; CHECK-NEXT:    ret i32 [[B_SROA_0_0_B_SROA_0_0_X]]
;
; DEBUGLOC-LABEL: @pr45010(
; DEBUGLOC-NEXT:    [[B_SROA_0:%.*]] = alloca i32, align 4, !dbg [[DBG172:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata %struct* undef, metadata [[META165:![0-9]+]], metadata !DIExpression()), !dbg [[DBG172]]
; DEBUGLOC-NEXT:    [[A_I:%.*]] = getelementptr inbounds [[STRUCT:%.*]], %struct* [[A:%.*]], i32 0, i32 0, !dbg [[DBG173:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32* [[A_I]], metadata [[META166:![0-9]+]], metadata !DIExpression()), !dbg [[DBG173]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32* undef, metadata [[META167:![0-9]+]], metadata !DIExpression()), !dbg [[DBG174:![0-9]+]]
; DEBUGLOC-NEXT:    [[TMP1:%.*]] = load i32, i32* [[A_I]], align 4, !dbg [[DBG175:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32 [[TMP1]], metadata [[META168:![0-9]+]], metadata !DIExpression()), !dbg [[DBG175]]
; DEBUGLOC-NEXT:    store atomic volatile i32 [[TMP1]], i32* [[B_SROA_0]] release, align 4, !dbg [[DBG176:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32* undef, metadata [[META170:![0-9]+]], metadata !DIExpression()), !dbg [[DBG177:![0-9]+]]
; DEBUGLOC-NEXT:    [[B_SROA_0_0_B_SROA_0_0_X:%.*]] = load atomic volatile i32, i32* [[B_SROA_0]] acquire, align 4, !dbg [[DBG178:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32 [[B_SROA_0_0_B_SROA_0_0_X]], metadata [[META171:![0-9]+]], metadata !DIExpression()), !dbg [[DBG178]]
; DEBUGLOC-NEXT:    ret i32 [[B_SROA_0_0_B_SROA_0_0_X]], !dbg [[DBG179:![0-9]+]]
;

  %B = alloca %struct, align 4
  %A.i = getelementptr inbounds %struct, %struct* %A, i32 0, i32 0
  %B.i = getelementptr inbounds %struct, %struct* %B, i32 0, i32 0
  %1 = load i32, i32* %A.i, align 4
  store atomic volatile i32 %1, i32* %B.i release, align 4
  %2 = bitcast %struct* %B to i32*
  %x = load atomic volatile i32, i32* %2 acquire, align 4
  ret i32 %x
}

declare void @populate(i8*)
