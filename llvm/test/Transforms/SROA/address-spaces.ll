; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=sroa -S | FileCheck %s
target datalayout = "e-p:64:64:64-p1:16:16:16-p3:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-n8:16:32:64"

declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture readonly, i32, i1)
declare void @llvm.memcpy.p1i8.p0i8.i32(i8 addrspace(1)* nocapture, i8* nocapture readonly, i32, i1)
declare void @llvm.memcpy.p0i8.p1i8.i32(i8* nocapture, i8 addrspace(1)* nocapture readonly, i32, i1)
declare void @llvm.memcpy.p1i8.p1i8.i32(i8 addrspace(1)* nocapture, i8 addrspace(1)* nocapture readonly, i32, i1)


; Make sure an illegal bitcast isn't introduced
define void @test_address_space_1_1(<2 x i64> addrspace(1)* %a, i16 addrspace(1)* %b) {
; CHECK-LABEL: @test_address_space_1_1(
; CHECK-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64> addrspace(1)* [[A:%.*]], align 2
; CHECK-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16 addrspace(1)* [[B:%.*]] to <2 x i64> addrspace(1)*
; CHECK-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64> addrspace(1)* [[AA_0_BPTR_SROA_CAST]], align 2
; CHECK-NEXT:    ret void
;
  %aa = alloca <2 x i64>, align 16
  %aptr = bitcast <2 x i64> addrspace(1)* %a to i8 addrspace(1)*
  %aaptr = bitcast <2 x i64>* %aa to i8*
  call void @llvm.memcpy.p0i8.p1i8.i32(i8* align 2 %aaptr, i8 addrspace(1)* align 2 %aptr, i32 16, i1 false)
  %bptr = bitcast i16 addrspace(1)* %b to i8 addrspace(1)*
  call void @llvm.memcpy.p1i8.p0i8.i32(i8 addrspace(1)* align 2 %bptr, i8* align 2 %aaptr, i32 16, i1 false)
  ret void
}

define void @test_address_space_1_0(<2 x i64> addrspace(1)* %a, i16* %b) {
; CHECK-LABEL: @test_address_space_1_0(
; CHECK-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64> addrspace(1)* [[A:%.*]], align 2
; CHECK-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16* [[B:%.*]] to <2 x i64>*
; CHECK-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64>* [[AA_0_BPTR_SROA_CAST]], align 2
; CHECK-NEXT:    ret void
;
  %aa = alloca <2 x i64>, align 16
  %aptr = bitcast <2 x i64> addrspace(1)* %a to i8 addrspace(1)*
  %aaptr = bitcast <2 x i64>* %aa to i8*
  call void @llvm.memcpy.p0i8.p1i8.i32(i8* align 2 %aaptr, i8 addrspace(1)* align 2 %aptr, i32 16, i1 false)
  %bptr = bitcast i16* %b to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 2 %bptr, i8* align 2 %aaptr, i32 16, i1 false)
  ret void
}

define void @test_address_space_0_1(<2 x i64>* %a, i16 addrspace(1)* %b) {
; CHECK-LABEL: @test_address_space_0_1(
; CHECK-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64>* [[A:%.*]], align 2
; CHECK-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16 addrspace(1)* [[B:%.*]] to <2 x i64> addrspace(1)*
; CHECK-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64> addrspace(1)* [[AA_0_BPTR_SROA_CAST]], align 2
; CHECK-NEXT:    ret void
;
  %aa = alloca <2 x i64>, align 16
  %aptr = bitcast <2 x i64>* %a to i8*
  %aaptr = bitcast <2 x i64>* %aa to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 2 %aaptr, i8* align 2 %aptr, i32 16, i1 false)
  %bptr = bitcast i16 addrspace(1)* %b to i8 addrspace(1)*
  call void @llvm.memcpy.p1i8.p0i8.i32(i8 addrspace(1)* align 2 %bptr, i8* align 2 %aaptr, i32 16, i1 false)
  ret void
}

%struct.struct_test_27.0.13 = type { i32, float, i64, i8, [4 x i32] }

define void @copy_struct([5 x i64] %in.coerce, i8 addrspace(1)* align 4 %ptr) {
; CHECK-LABEL: @copy_struct(
; CHECK-NEXT:  for.end:
; CHECK-NEXT:    [[IN_COERCE_FCA_0_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE:%.*]], 0
; CHECK-NEXT:    [[IN_COERCE_FCA_1_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE]], 1
; CHECK-NEXT:    [[IN_COERCE_FCA_2_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE]], 2
; CHECK-NEXT:    [[IN_COERCE_FCA_3_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE]], 3
; CHECK-NEXT:    [[IN_SROA_2_4_PTR_SROA_CAST:%.*]] = bitcast i8 addrspace(1)* [[PTR:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    [[IN_SROA_2_4_EXTRACT_SHIFT:%.*]] = lshr i64 [[IN_COERCE_FCA_2_EXTRACT]], 32
; CHECK-NEXT:    [[IN_SROA_2_4_EXTRACT_TRUNC:%.*]] = trunc i64 [[IN_SROA_2_4_EXTRACT_SHIFT]] to i32
; CHECK-NEXT:    store i32 [[IN_SROA_2_4_EXTRACT_TRUNC]], i32 addrspace(1)* [[IN_SROA_2_4_PTR_SROA_CAST]], align 4
; CHECK-NEXT:    [[IN_SROA_4_20_PTR_SROA_IDX:%.*]] = getelementptr inbounds i8, i8 addrspace(1)* [[PTR]], i16 4
; CHECK-NEXT:    [[IN_SROA_4_20_PTR_SROA_CAST:%.*]] = bitcast i8 addrspace(1)* [[IN_SROA_4_20_PTR_SROA_IDX]] to i64 addrspace(1)*
; CHECK-NEXT:    store i64 [[IN_COERCE_FCA_3_EXTRACT]], i64 addrspace(1)* [[IN_SROA_4_20_PTR_SROA_CAST]], align 4
; CHECK-NEXT:    [[IN_SROA_5_20_PTR_SROA_IDX:%.*]] = getelementptr inbounds i8, i8 addrspace(1)* [[PTR]], i16 12
; CHECK-NEXT:    [[IN_SROA_5_20_PTR_SROA_CAST:%.*]] = bitcast i8 addrspace(1)* [[IN_SROA_5_20_PTR_SROA_IDX]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 undef, i32 addrspace(1)* [[IN_SROA_5_20_PTR_SROA_CAST]], align 4
; CHECK-NEXT:    ret void
;
for.end:
  %in = alloca %struct.struct_test_27.0.13, align 8
  %0 = bitcast %struct.struct_test_27.0.13* %in to [5 x i64]*
  store [5 x i64] %in.coerce, [5 x i64]* %0, align 8
  %scevgep9 = getelementptr %struct.struct_test_27.0.13, %struct.struct_test_27.0.13* %in, i32 0, i32 4, i32 0
  %scevgep910 = bitcast i32* %scevgep9 to i8*
  call void @llvm.memcpy.p1i8.p0i8.i32(i8 addrspace(1)* align 4 %ptr, i8* align 4 %scevgep910, i32 16, i1 false)
  ret void
}

%union.anon = type { i32* }

@g = common global i32 0, align 4
@l = common addrspace(3) global i32 0, align 4

; If pointers from different address spaces have different sizes, make sure an
; illegal bitcast isn't introduced
define void @pr27557() {
; CHECK-LABEL: @pr27557(
; CHECK-NEXT:    [[DOTSROA_0:%.*]] = alloca i32*, align 8
; CHECK-NEXT:    store i32* @g, i32** [[DOTSROA_0]], align 8
; CHECK-NEXT:    [[DOTSROA_0_0__SROA_CAST1:%.*]] = bitcast i32** [[DOTSROA_0]] to i32 addrspace(3)**
; CHECK-NEXT:    store i32 addrspace(3)* @l, i32 addrspace(3)** [[DOTSROA_0_0__SROA_CAST1]], align 8
; CHECK-NEXT:    ret void
;
  %1 = alloca %union.anon, align 8
  %2 = bitcast %union.anon* %1 to i32**
  store i32* @g, i32** %2, align 8
  %3 = bitcast %union.anon* %1 to i32 addrspace(3)**
  store i32 addrspace(3)* @l, i32 addrspace(3)** %3, align 8
  ret void
}

@l2 = common addrspace(2) global i32 0, align 4

; If pointers from different address spaces have the same size, that pointer
; should be promoted through the pair of `ptrtoint`/`inttoptr`.
define i32* @pr27557.alt() {
; CHECK-LABEL: @pr27557.alt(
; CHECK-NEXT:    ret i32* inttoptr (i64 ptrtoint (i32 addrspace(2)* @l2 to i64) to i32*)
;
  %1 = alloca %union.anon, align 8
  %2 = bitcast %union.anon* %1 to i32 addrspace(2)**
  store i32 addrspace(2)* @l2, i32 addrspace(2)** %2, align 8
  %3 = bitcast %union.anon* %1 to i32**
  %4 = load i32*, i32** %3, align 8
  ret i32* %4
}

; Make sure pre-splitting doesn't try to introduce an illegal bitcast
define float @presplit(i64 addrspace(1)* %p) {
; CHECK-LABEL: @presplit(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[P_SROA_CAST:%.*]] = bitcast i64 addrspace(1)* [[P:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    [[L1:%.*]] = load i32, i32 addrspace(1)* [[P_SROA_CAST]], align 4
; CHECK-NEXT:    [[P_SROA_RAW_CAST:%.*]] = bitcast i64 addrspace(1)* [[P]] to i8 addrspace(1)*
; CHECK-NEXT:    [[P_SROA_RAW_IDX:%.*]] = getelementptr inbounds i8, i8 addrspace(1)* [[P_SROA_RAW_CAST]], i16 4
; CHECK-NEXT:    [[P_SROA_CAST2:%.*]] = bitcast i8 addrspace(1)* [[P_SROA_RAW_IDX]] to i32 addrspace(1)*
; CHECK-NEXT:    [[L3:%.*]] = load i32, i32 addrspace(1)* [[P_SROA_CAST2]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 [[L1]] to float
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[L3]] to float
; CHECK-NEXT:    [[RET:%.*]] = fadd float [[TMP0]], [[TMP1]]
; CHECK-NEXT:    ret float [[RET]]
;
entry:
  %b = alloca i64
  %b.cast = bitcast i64* %b to [2 x float]*
  %b.gep1 = getelementptr [2 x float], [2 x float]* %b.cast, i32 0, i32 0
  %b.gep2 = getelementptr [2 x float], [2 x float]* %b.cast, i32 0, i32 1
  %l = load i64, i64 addrspace(1)* %p
  store i64 %l, i64* %b
  %f1 = load float, float* %b.gep1
  %f2 = load float, float* %b.gep2
  %ret = fadd float %f1, %f2
  ret float %ret
}

; Test load from and store to non-zero address space.
define void @test_load_store_diff_addr_space([2 x float] addrspace(1)* %complex1, [2 x float] addrspace(1)* %complex2) {
; CHECK-LABEL: @test_load_store_diff_addr_space(
; CHECK-NEXT:    [[P1_SROA_CAST:%.*]] = bitcast [2 x float] addrspace(1)* [[COMPLEX1:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    [[V15:%.*]] = load i32, i32 addrspace(1)* [[P1_SROA_CAST]], align 4
; CHECK-NEXT:    [[P1_SROA_IDX:%.*]] = getelementptr inbounds [2 x float], [2 x float] addrspace(1)* [[COMPLEX1]], i16 0, i16 1
; CHECK-NEXT:    [[P1_SROA_CAST7:%.*]] = bitcast float addrspace(1)* [[P1_SROA_IDX]] to i32 addrspace(1)*
; CHECK-NEXT:    [[V18:%.*]] = load i32, i32 addrspace(1)* [[P1_SROA_CAST7]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[V15]] to float
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[V18]] to float
; CHECK-NEXT:    [[SUM:%.*]] = fadd float [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast float [[SUM]] to i32
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast float [[SUM]] to i32
; CHECK-NEXT:    [[P2_SROA_CAST:%.*]] = bitcast [2 x float] addrspace(1)* [[COMPLEX2:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 [[TMP3]], i32 addrspace(1)* [[P2_SROA_CAST]], align 4
; CHECK-NEXT:    [[P2_SROA_IDX:%.*]] = getelementptr inbounds [2 x float], [2 x float] addrspace(1)* [[COMPLEX2]], i16 0, i16 1
; CHECK-NEXT:    [[P2_SROA_CAST4:%.*]] = bitcast float addrspace(1)* [[P2_SROA_IDX]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 [[TMP4]], i32 addrspace(1)* [[P2_SROA_CAST4]], align 4
; CHECK-NEXT:    ret void
;
  %a = alloca i64
  %a.cast = bitcast i64* %a to [2 x float]*
  %a.gep1 = getelementptr [2 x float], [2 x float]* %a.cast, i32 0, i32 0
  %a.gep2 = getelementptr [2 x float], [2 x float]* %a.cast, i32 0, i32 1
  %complex1.gep = getelementptr [2 x float], [2 x float] addrspace(1)* %complex1, i32 0, i32 0
  %p1 = bitcast float addrspace(1)* %complex1.gep to i64 addrspace(1)*
  %v1 = load i64, i64 addrspace(1)* %p1
  store i64 %v1, i64* %a
  %f1 = load float, float* %a.gep1
  %f2 = load float, float* %a.gep2
  %sum = fadd float %f1, %f2
  store float %sum, float* %a.gep1
  store float %sum, float* %a.gep2
  %v2 = load i64, i64* %a
  %complex2.gep = getelementptr [2 x float], [2 x float] addrspace(1)* %complex2, i32 0, i32 0
  %p2 = bitcast float addrspace(1)* %complex2.gep to i64 addrspace(1)*
  store i64 %v2, i64 addrspace(1)* %p2
  ret void
}
