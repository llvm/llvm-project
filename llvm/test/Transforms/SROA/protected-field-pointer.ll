; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=sroa -S < %s | FileCheck %s

define void @slice(ptr %ptr1, ptr %ptr2, ptr %out1, ptr %out2) {
; CHECK-LABEL: define void @slice(
; CHECK-SAME: ptr [[PTR1:%.*]], ptr [[PTR2:%.*]], ptr [[OUT1:%.*]], ptr [[OUT2:%.*]]) {
; CHECK-NEXT:    store ptr [[PTR1]], ptr [[OUT1]], align 8
; CHECK-NEXT:    store ptr [[PTR2]], ptr [[OUT2]], align 8
; CHECK-NEXT:    ret void
;
  %alloca = alloca { ptr, ptr }

  %protptrptr1.1 = call ptr @llvm.protected.field.ptr.p0(ptr %alloca, i64 1, i1 true)
  store ptr %ptr1, ptr %protptrptr1.1
  %protptrptr1.2 = call ptr @llvm.protected.field.ptr.p0(ptr %alloca, i64 1, i1 true)
  %ptr1a = load ptr, ptr %protptrptr1.2

  %gep = getelementptr { ptr, ptr }, ptr %alloca, i64 0, i32 1
  %protptrptr2.1 = call ptr @llvm.protected.field.ptr.p0(ptr %gep, i64 2, i1 true)
  store ptr %ptr2, ptr %protptrptr2.1
  %protptrptr2.2 = call ptr @llvm.protected.field.ptr.p0(ptr %gep, i64 2, i1 true)
  %ptr2a = load ptr, ptr %protptrptr2.2

  store ptr %ptr1a, ptr %out1
  store ptr %ptr2a, ptr %out2
  ret void
}

define ptr @mixed(ptr %ptr) {
; CHECK-LABEL: define ptr @mixed(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[PTR]], ptr [[ALLOCA]], align 8
; CHECK-NEXT:    [[PROTPTRPTR1_2:%.*]] = call ptr @llvm.protected.field.ptr.p0(ptr [[ALLOCA]], i64 1, i1 true)
; CHECK-NEXT:    [[PTR1A:%.*]] = load ptr, ptr [[PROTPTRPTR1_2]], align 8
; CHECK-NEXT:    ret ptr [[PTR1A]]
;
  %alloca = alloca ptr

  store ptr %ptr, ptr %alloca
  %protptrptr1.2 = call ptr @llvm.protected.field.ptr.p0(ptr %alloca, i64 1, i1 true)
  %ptr1a = load ptr, ptr %protptrptr1.2

  ret ptr %ptr1a
}

define ptr @mixed2(ptr %ptr) {
; CHECK-LABEL: define ptr @mixed2(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[PROTPTRPTR1_2:%.*]] = call ptr @llvm.protected.field.ptr.p0(ptr [[ALLOCA]], i64 1, i1 true)
; CHECK-NEXT:    store ptr [[PTR]], ptr [[PROTPTRPTR1_2]], align 8
; CHECK-NEXT:    [[PROTPTRPTR2_2:%.*]] = call ptr @llvm.protected.field.ptr.p0(ptr [[ALLOCA]], i64 2, i1 true)
; CHECK-NEXT:    [[PTR1A:%.*]] = load ptr, ptr [[PROTPTRPTR2_2]], align 8
; CHECK-NEXT:    ret ptr [[PTR1A]]
;
  %alloca = alloca ptr

  %protptrptr1.2 = call ptr @llvm.protected.field.ptr.p0(ptr %alloca, i64 1, i1 true)
  store ptr %ptr, ptr %protptrptr1.2
  %protptrptr2.2 = call ptr @llvm.protected.field.ptr.p0(ptr %alloca, i64 2, i1 true)
  %ptr1a = load ptr, ptr %protptrptr2.2

  ret ptr %ptr1a
}

define void @split_non_promotable(ptr %ptr1, ptr %ptr2, ptr %out1, ptr %out2) {
; CHECK-LABEL: define void @split_non_promotable(
; CHECK-SAME: ptr [[PTR1:%.*]], ptr [[PTR2:%.*]], ptr [[OUT1:%.*]], ptr [[OUT2:%.*]]) {
; CHECK-NEXT:    [[ALLOCA_SROA_2:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store volatile ptr [[PTR2]], ptr [[ALLOCA_SROA_2]], align 8
; CHECK-NEXT:    [[PTR2A:%.*]] = load volatile ptr, ptr [[ALLOCA_SROA_2]], align 8
; CHECK-NEXT:    store ptr [[PTR1]], ptr [[OUT1]], align 8
; CHECK-NEXT:    store ptr [[PTR2A]], ptr [[OUT2]], align 8
; CHECK-NEXT:    ret void
;
  %alloca = alloca { ptr, ptr }

  %protptrptr1.1 = call ptr @llvm.protected.field.ptr.p0(ptr %alloca, i64 1, i1 true)
  store ptr %ptr1, ptr %protptrptr1.1
  %protptrptr1.2 = call ptr @llvm.protected.field.ptr.p0(ptr %alloca, i64 1, i1 true)
  %ptr1a = load ptr, ptr %protptrptr1.2

  %gep = getelementptr { ptr, ptr }, ptr %alloca, i64 0, i32 1
  %protptrptr2.1 = call ptr @llvm.protected.field.ptr.p0(ptr %gep, i64 2, i1 true)
  store volatile ptr %ptr2, ptr %protptrptr2.1
  %protptrptr2.2 = call ptr @llvm.protected.field.ptr.p0(ptr %gep, i64 2, i1 true)
  %ptr2a = load volatile ptr, ptr %protptrptr2.2

  store ptr %ptr1a, ptr %out1
  store ptr %ptr2a, ptr %out2
  ret void
}
