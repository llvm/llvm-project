; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes='sroa<preserve-cfg>' -S < %s | FileCheck %s --check-prefixes=CHECK,CHECK-PRESERVE-CFG
; RUN: opt -passes='sroa<modify-cfg>' -S < %s | FileCheck %s --check-prefixes=CHECK,CHECK-MODIFY-CFG

%"struct.a" = type { <8 x half> }
%"struct.b" = type { %"struct.a" }
%"struct.c" = type { %"struct.a", i32, i8 }
%"struct.d" = type { [4 x i32], %"struct.a" }
%"struct.e" = type { [2 x <8 x half>], i32, i32 }
%"struct.f" = type { [2 x <8 x i16>], i32, i32 }
%"array.a" = type [2 x <8 x half>]
%"array.b" = type [2 x %"struct.a"]

define amdgpu_kernel void @test_zeroinit() #0 {
; CHECK-LABEL: @test_zeroinit(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA]] to <8 x i16>
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"struct.b", align 16
  store <8 x half> zeroinitializer, ptr %b_blockwise_copy, align 16
  %data = load <4 x float>, ptr undef
  store <4 x float> %data, ptr %b_blockwise_copy, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_memset() #0 {
; CHECK-LABEL: @test_memset(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA]] to <8 x i16>
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"struct.b", align 16
  call void @llvm.memset.p0.i64(ptr align 16 %b_blockwise_copy, i8 0, i64 16, i1 false)
  %data = load <4 x float>, ptr undef
  store <4 x float> %data, ptr %b_blockwise_copy, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @vector_type_alloca() #0 {
; CHECK-LABEL: @vector_type_alloca(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA]] to <8 x i16>
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca <8 x half>, align 16
  store <8 x half> zeroinitializer, ptr %b_blockwise_copy, align 16
  %data = load <4 x float>, ptr undef
  store <4 x float> %data, ptr %b_blockwise_copy, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_struct_contain_multiple_types1() #0 {
; CHECK-LABEL: @test_struct_contain_multiple_types1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA]] to <8 x i16>
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"struct.c", align 16
  store <8 x half> zeroinitializer, ptr %b_blockwise_copy, align 16
  %data = load <4 x float>, ptr undef
  store <4 x float> %data, ptr %b_blockwise_copy, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_struct_contain_multiple_types2() #0 {
; CHECK-LABEL: @test_struct_contain_multiple_types2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA1:%.*]] = load [4 x i32], ptr undef, align 4
; CHECK-NEXT:    [[DATA1_FCA_0_EXTRACT:%.*]] = extractvalue [4 x i32] [[DATA1]], 0
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_INSERT:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[DATA1_FCA_0_EXTRACT]], i32 0
; CHECK-NEXT:    [[DATA1_FCA_1_EXTRACT:%.*]] = extractvalue [4 x i32] [[DATA1]], 1
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_INSERT:%.*]] = insertelement <4 x i32> [[B_BLOCKWISE_COPY_SROA_0_0_VEC_INSERT]], i32 [[DATA1_FCA_1_EXTRACT]], i32 1
; CHECK-NEXT:    [[DATA1_FCA_2_EXTRACT:%.*]] = extractvalue [4 x i32] [[DATA1]], 2
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_8_VEC_INSERT:%.*]] = insertelement <4 x i32> [[B_BLOCKWISE_COPY_SROA_0_4_VEC_INSERT]], i32 [[DATA1_FCA_2_EXTRACT]], i32 2
; CHECK-NEXT:    [[DATA1_FCA_3_EXTRACT:%.*]] = extractvalue [4 x i32] [[DATA1]], 3
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_12_VEC_INSERT:%.*]] = insertelement <4 x i32> [[B_BLOCKWISE_COPY_SROA_0_8_VEC_INSERT]], i32 [[DATA1_FCA_3_EXTRACT]], i32 3
; CHECK-NEXT:    [[DATA2:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA2]] to <8 x i16>
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_5_16_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_5_16_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_5_18_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_5_18_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_5_20_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_5_20_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"struct.d", align 16
  call void @llvm.memset.p0.i32(ptr align 16 %b_blockwise_copy, i8 0, i32 16, i1 false)
  %data1 = load [4 x i32], ptr undef
  store [4 x i32] %data1, ptr %b_blockwise_copy, align 16
  %data2_gep = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 16
  store <8 x half> zeroinitializer, ptr %data2_gep, align 16
  %data2 = load <4 x float>, ptr undef
  store <4 x float> %data2, ptr %data2_gep, align 16
  br label %bb

bb:
  %ptr1 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 16
  %load1 = load half, ptr %ptr1, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 18
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 20
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_struct_array_vector() #0 {
; CHECK-LABEL: @test_struct_array_vector(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA0:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA0]] to <8 x i16>
; CHECK-NEXT:    [[DATA1:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x float> [[DATA1]] to <8 x i16>
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP0]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_3_16_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_3_16_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"struct.e", align 16
  store <8 x half> zeroinitializer, ptr %b_blockwise_copy, align 16
  %0 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 16
  store <8 x half> zeroinitializer, ptr %0, align 16
  %data0 = load <4 x float>, ptr undef
  store <4 x float> %data0, ptr %b_blockwise_copy, align 16
  %data1 = load <4 x float>, ptr undef
  store <4 x float> %data1, ptr %0, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 16
  %load2 = load half, ptr %ptr2, align 16
  ret void
}

define amdgpu_kernel void @test_struct_array_vector_i16() #0 {
; CHECK-LABEL: @test_struct_array_vector_i16(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load <4 x i32>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i32> [[DATA]] to <8 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND:%.*]] = shufflevector <8 x i16> [[TMP0]], <8 x i16> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND:%.*]] = select <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND]], <16 x i16> zeroinitializer
; CHECK-NEXT:    [[DATA2:%.*]] = load <4 x i32>, ptr undef, align 16
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i32> [[DATA2]] to <8 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_16_VEC_EXPAND:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <16 x i32> <i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_16_VECBLEND:%.*]] = select <16 x i1> <i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_16_VEC_EXPAND]], <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]]
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_16_VECBLEND]], i32 0
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_16_VECBLEND]], i32 1
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_16_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_16_VECBLEND]], i32 8
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"struct.f", align 16
  call void @llvm.memset.p0.i32(ptr align 16 %b_blockwise_copy, i8 0, i32 32, i1 false)
  %data = load <4 x i32>, ptr undef
  store <4 x i32> %data, ptr %b_blockwise_copy, align 16
  %data2 = load <4 x i32>, ptr undef
  %data2_gep = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 16
  store <4 x i32> %data2, ptr %data2_gep, align 16
  br label %bb

bb:
  %load1 = load i16, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load i16, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 16
  %load3 = load i16, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_half_array() #0 {
; CHECK-LABEL: @test_half_array(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load [4 x float], ptr undef, align 4
; CHECK-NEXT:    [[DATA_FCA_0_EXTRACT:%.*]] = extractvalue [4 x float] [[DATA]], 0
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast float [[DATA_FCA_0_EXTRACT]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP0]], <2 x i16> poison, <8 x i32> <i32 0, i32 1, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND:%.*]] = select <8 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND]], <8 x i16> zeroinitializer
; CHECK-NEXT:    [[DATA_FCA_1_EXTRACT:%.*]] = extractvalue [4 x float] [[DATA]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast float [[DATA_FCA_1_EXTRACT]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP1]], <2 x i16> poison, <8 x i32> <i32 poison, i32 poison, i32 0, i32 1, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VECBLEND:%.*]] = select <8 x i1> <i1 false, i1 false, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false>, <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXPAND]], <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]]
; CHECK-NEXT:    [[DATA_FCA_2_EXTRACT:%.*]] = extractvalue [4 x float] [[DATA]], 2
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast float [[DATA_FCA_2_EXTRACT]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_8_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP2]], <2 x i16> poison, <8 x i32> <i32 poison, i32 poison, i32 poison, i32 poison, i32 0, i32 1, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_8_VECBLEND:%.*]] = select <8 x i1> <i1 false, i1 false, i1 false, i1 false, i1 true, i1 true, i1 false, i1 false>, <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_8_VEC_EXPAND]], <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_4_VECBLEND]]
; CHECK-NEXT:    [[DATA_FCA_3_EXTRACT:%.*]] = extractvalue [4 x float] [[DATA]], 3
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast float [[DATA_FCA_3_EXTRACT]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_12_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP3]], <2 x i16> poison, <8 x i32> <i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 0, i32 1>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND:%.*]] = select <8 x i1> <i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 true, i1 true>, <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VEC_EXPAND]], <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_8_VECBLEND]]
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <8 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 2
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca [8 x half], align 16
  call void @llvm.memset.p0.i32(ptr align 16 %b_blockwise_copy, i8 0, i32 16, i1 false)
  %data = load [4 x float], ptr undef
  store [4 x float] %data, ptr %b_blockwise_copy, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_array_vector() #0 {
; CHECK-LABEL: @test_array_vector(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA]] to <8 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND:%.*]] = shufflevector <8 x i16> [[TMP0]], <8 x i16> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND:%.*]] = select <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND]], <16 x i16> zeroinitializer
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"array.a", align 16
  call void @llvm.memset.p0.i32(ptr align 16 %b_blockwise_copy, i8 0, i32 32, i1 false)
  %data = load <4 x float>, ptr undef
  store <4 x float> %data, ptr %b_blockwise_copy, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_array_vector2() #0 {
; CHECK-LABEL: @test_array_vector2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA:%.*]] = load <4 x float>, ptr undef, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[DATA]] to <8 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND:%.*]] = shufflevector <8 x i16> [[TMP0]], <8 x i16> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND:%.*]] = select <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND]], <16 x i16> zeroinitializer
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"array.b", align 16
  call void @llvm.memset.p0.i32(ptr align 16 %b_blockwise_copy, i8 0, i32 32, i1 false)
  %data = load <4 x float>, ptr undef
  store <4 x float> %data, ptr %b_blockwise_copy, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  ret void
}

define amdgpu_kernel void @test_array_vector_no_vector_common_type() #0 {
; CHECK-LABEL: @test_array_vector_no_vector_common_type(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DATA1:%.*]] = load float, ptr undef, align 4
; CHECK-NEXT:    [[DATA2:%.*]] = load float, ptr undef, align 4
; CHECK-NEXT:    [[DATA3:%.*]] = load float, ptr undef, align 4
; CHECK-NEXT:    [[DATA4:%.*]] = load float, ptr undef, align 4
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast float [[DATA1]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP0]], <2 x i16> poison, <16 x i32> <i32 0, i32 1, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND:%.*]] = select <16 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXPAND]], <16 x i16> zeroinitializer
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast float [[DATA2]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP1]], <2 x i16> poison, <16 x i32> <i32 poison, i32 poison, i32 0, i32 1, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VECBLEND:%.*]] = select <16 x i1> <i1 false, i1 false, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXPAND]], <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_0_VECBLEND]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast float [[DATA3]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_8_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP2]], <2 x i16> poison, <16 x i32> <i32 poison, i32 poison, i32 poison, i32 poison, i32 0, i32 1, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_8_VECBLEND:%.*]] = select <16 x i1> <i1 false, i1 false, i1 false, i1 false, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_8_VEC_EXPAND]], <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_4_VECBLEND]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast float [[DATA4]] to <2 x i16>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_12_VEC_EXPAND:%.*]] = shufflevector <2 x i16> [[TMP3]], <2 x i16> poison, <16 x i32> <i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 0, i32 1, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND:%.*]] = select <16 x i1> <i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VEC_EXPAND]], <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_8_VECBLEND]]
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_0_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_2_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 2
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_4_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_6_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 3
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_6_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_8_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 4
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_8_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_10_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 5
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_10_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_12_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 6
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_12_VEC_EXTRACT]] to half
; CHECK-NEXT:    [[B_BLOCKWISE_COPY_SROA_0_14_VEC_EXTRACT:%.*]] = extractelement <16 x i16> [[B_BLOCKWISE_COPY_SROA_0_12_VECBLEND]], i32 7
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast i16 [[B_BLOCKWISE_COPY_SROA_0_14_VEC_EXTRACT]] to half
; CHECK-NEXT:    ret void
;
entry:
  %b_blockwise_copy = alloca %"array.a", align 16
  call void @llvm.memset.p0.i32(ptr align 16 %b_blockwise_copy, i8 0, i32 32, i1 false)
  %data1 = load float, ptr undef
  %data2 = load float, ptr undef
  %data3 = load float, ptr undef
  %data4 = load float, ptr undef
  store float %data1, ptr %b_blockwise_copy, align 16
  %data_ptr1 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  store float %data2, ptr %data_ptr1, align 16
  %data_ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 8
  store float %data3, ptr %data_ptr2, align 16
  %data_ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 12
  store float %data4, ptr %data_ptr3, align 16
  br label %bb

bb:
  %load1 = load half, ptr %b_blockwise_copy, align 16
  %ptr2 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 2
  %load2 = load half, ptr %ptr2, align 16
  %ptr3 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 4
  %load3 = load half, ptr %ptr3, align 16
  %ptr4 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 6
  %load4 = load half, ptr %ptr4, align 16
  %ptr5 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 8
  %load5 = load half, ptr %ptr5, align 16
  %ptr6 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 10
  %load6 = load half, ptr %ptr6, align 16
  %ptr7 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 12
  %load7 = load half, ptr %ptr7, align 16
  %ptr8 = getelementptr inbounds i8, ptr %b_blockwise_copy, i64 14
  %load8 = load half, ptr %ptr8, align 16
  ret void
}

declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1) nounwind
declare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1) nounwind
attributes #0 = { nounwind readonly }

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK-MODIFY-CFG: {{.*}}
; CHECK-PRESERVE-CFG: {{.*}}
