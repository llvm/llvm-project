; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=sroa -S | FileCheck %s
target datalayout = "e-p:64:64:64-p1:16:16:16-p2:32:32-p3:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-n8:16:32:64-A2"

declare void @llvm.memcpy.p2i8.p2i8.i32(i8 addrspace(2)* nocapture, i8 addrspace(2)* nocapture readonly, i32, i1)
declare void @llvm.memcpy.p1i8.p2i8.i32(i8 addrspace(1)* nocapture, i8 addrspace(2)* nocapture readonly, i32, i1)
declare void @llvm.memcpy.p2i8.p1i8.i32(i8 addrspace(2)* nocapture, i8 addrspace(1)* nocapture readonly, i32, i1)
declare void @llvm.memcpy.p1i8.p1i8.i32(i8 addrspace(1)* nocapture, i8 addrspace(1)* nocapture readonly, i32, i1)


define void @test_address_space_1_1(<2 x i64> addrspace(1)* %a, i16 addrspace(1)* %b) {
; CHECK-LABEL: @test_address_space_1_1(
; CHECK-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64> addrspace(1)* [[A:%.*]], align 2
; CHECK-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16 addrspace(1)* [[B:%.*]] to <2 x i64> addrspace(1)*
; CHECK-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64> addrspace(1)* [[AA_0_BPTR_SROA_CAST]], align 2
; CHECK-NEXT:    ret void
;
  %aa = alloca <2 x i64>, align 16, addrspace(2)
  %aptr = bitcast <2 x i64> addrspace(1)* %a to i8 addrspace(1)*
  %aaptr = bitcast <2 x i64> addrspace(2)* %aa to i8 addrspace(2)*
  call void @llvm.memcpy.p2i8.p1i8.i32(i8 addrspace(2)* align 2 %aaptr, i8 addrspace(1)* align 2 %aptr, i32 16, i1 false)
  %bptr = bitcast i16 addrspace(1)* %b to i8 addrspace(1)*
  call void @llvm.memcpy.p1i8.p2i8.i32(i8 addrspace(1)* align 2 %bptr, i8 addrspace(2)* align 2 %aaptr, i32 16, i1 false)
  ret void
}

define void @test_address_space_1_0(<2 x i64> addrspace(1)* %a, i16 addrspace(2)* %b) {
; CHECK-LABEL: @test_address_space_1_0(
; CHECK-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64> addrspace(1)* [[A:%.*]], align 2
; CHECK-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16 addrspace(2)* [[B:%.*]] to <2 x i64> addrspace(2)*
; CHECK-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64> addrspace(2)* [[AA_0_BPTR_SROA_CAST]], align 2
; CHECK-NEXT:    ret void
;
  %aa = alloca <2 x i64>, align 16, addrspace(2)
  %aptr = bitcast <2 x i64> addrspace(1)* %a to i8 addrspace(1)*
  %aaptr = bitcast <2 x i64> addrspace(2)* %aa to i8 addrspace(2)*
  call void @llvm.memcpy.p2i8.p1i8.i32(i8 addrspace(2)* align 2 %aaptr, i8 addrspace(1)* align 2 %aptr, i32 16, i1 false)
  %bptr = bitcast i16 addrspace(2)* %b to i8 addrspace(2)*
  call void @llvm.memcpy.p2i8.p2i8.i32(i8 addrspace(2)* align 2 %bptr, i8 addrspace(2)* align 2 %aaptr, i32 16, i1 false)
  ret void
}

define void @test_address_space_0_1(<2 x i64> addrspace(2)* %a, i16 addrspace(1)* %b) {
; CHECK-LABEL: @test_address_space_0_1(
; CHECK-NEXT:    [[AA_0_COPYLOAD:%.*]] = load <2 x i64>, <2 x i64> addrspace(2)* [[A:%.*]], align 2
; CHECK-NEXT:    [[AA_0_BPTR_SROA_CAST:%.*]] = bitcast i16 addrspace(1)* [[B:%.*]] to <2 x i64> addrspace(1)*
; CHECK-NEXT:    store <2 x i64> [[AA_0_COPYLOAD]], <2 x i64> addrspace(1)* [[AA_0_BPTR_SROA_CAST]], align 2
; CHECK-NEXT:    ret void
;
  %aa = alloca <2 x i64>, align 16, addrspace(2)
  %aptr = bitcast <2 x i64> addrspace(2)* %a to i8 addrspace(2)*
  %aaptr = bitcast <2 x i64> addrspace(2)* %aa to i8 addrspace(2)*
  call void @llvm.memcpy.p2i8.p2i8.i32(i8 addrspace(2)* align 2 %aaptr, i8 addrspace(2)* align 2 %aptr, i32 16, i1 false)
  %bptr = bitcast i16 addrspace(1)* %b to i8 addrspace(1)*
  call void @llvm.memcpy.p1i8.p2i8.i32(i8 addrspace(1)* align 2 %bptr, i8 addrspace(2)* align 2 %aaptr, i32 16, i1 false)
  ret void
}

%struct.struct_test_27.0.13 = type { i32, float, i64, i8, [4 x i32] }

define void @copy_struct([5 x i64] %in.coerce, i8 addrspace(1)* align 4 %ptr) {
; CHECK-LABEL: @copy_struct(
; CHECK-NEXT:  for.end:
; CHECK-NEXT:    [[IN_COERCE_FCA_0_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE:%.*]], 0
; CHECK-NEXT:    [[IN_COERCE_FCA_1_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE]], 1
; CHECK-NEXT:    [[IN_COERCE_FCA_2_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE]], 2
; CHECK-NEXT:    [[IN_COERCE_FCA_3_EXTRACT:%.*]] = extractvalue [5 x i64] [[IN_COERCE]], 3
; CHECK-NEXT:    [[IN_SROA_2_4_PTR_SROA_CAST:%.*]] = bitcast i8 addrspace(1)* [[PTR:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    [[IN_SROA_2_4_EXTRACT_SHIFT:%.*]] = lshr i64 [[IN_COERCE_FCA_2_EXTRACT]], 32
; CHECK-NEXT:    [[IN_SROA_2_4_EXTRACT_TRUNC:%.*]] = trunc i64 [[IN_SROA_2_4_EXTRACT_SHIFT]] to i32
; CHECK-NEXT:    store i32 [[IN_SROA_2_4_EXTRACT_TRUNC]], i32 addrspace(1)* [[IN_SROA_2_4_PTR_SROA_CAST]], align 4
; CHECK-NEXT:    [[IN_SROA_4_20_PTR_SROA_IDX:%.*]] = getelementptr inbounds i8, i8 addrspace(1)* [[PTR]], i16 4
; CHECK-NEXT:    [[IN_SROA_4_20_PTR_SROA_CAST:%.*]] = bitcast i8 addrspace(1)* [[IN_SROA_4_20_PTR_SROA_IDX]] to i64 addrspace(1)*
; CHECK-NEXT:    store i64 [[IN_COERCE_FCA_3_EXTRACT]], i64 addrspace(1)* [[IN_SROA_4_20_PTR_SROA_CAST]], align 4
; CHECK-NEXT:    [[IN_SROA_5_20_PTR_SROA_IDX:%.*]] = getelementptr inbounds i8, i8 addrspace(1)* [[PTR]], i16 12
; CHECK-NEXT:    [[IN_SROA_5_20_PTR_SROA_CAST:%.*]] = bitcast i8 addrspace(1)* [[IN_SROA_5_20_PTR_SROA_IDX]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 undef, i32 addrspace(1)* [[IN_SROA_5_20_PTR_SROA_CAST]], align 4
; CHECK-NEXT:    ret void
;
for.end:
  %in = alloca %struct.struct_test_27.0.13, align 8, addrspace(2)
  %0 = bitcast %struct.struct_test_27.0.13 addrspace(2)* %in to [5 x i64] addrspace(2)*
  store [5 x i64] %in.coerce, [5 x i64] addrspace(2)* %0, align 8
  %scevgep9 = getelementptr %struct.struct_test_27.0.13, %struct.struct_test_27.0.13 addrspace(2)* %in, i32 0, i32 4, i32 0
  %scevgep910 = bitcast i32 addrspace(2)* %scevgep9 to i8 addrspace(2)*
  call void @llvm.memcpy.p1i8.p2i8.i32(i8 addrspace(1)* align 4 %ptr, i8 addrspace(2)* align 4 %scevgep910, i32 16, i1 false)
  ret void
}

%union.anon = type { i32* }

@g = common global i32 0, align 4
@l = common addrspace(3) global i32 0, align 4

; If pointers from different address spaces have different sizes, make sure an
; illegal bitcast isn't introduced
define void @pr27557() {
; CHECK-LABEL: @pr27557(
; CHECK-NEXT:    [[DOTSROA_0:%.*]] = alloca i32*, align 8, addrspace(2)
; CHECK-NEXT:    store i32* @g, i32* addrspace(2)* [[DOTSROA_0]], align 8
; CHECK-NEXT:    [[DOTSROA_0_0__SROA_CAST1:%.*]] = bitcast i32* addrspace(2)* [[DOTSROA_0]] to i32 addrspace(3)* addrspace(2)*
; CHECK-NEXT:    store i32 addrspace(3)* @l, i32 addrspace(3)* addrspace(2)* [[DOTSROA_0_0__SROA_CAST1]], align 8
; CHECK-NEXT:    ret void
;
  %1 = alloca %union.anon, align 8, addrspace(2)
  %2 = bitcast %union.anon addrspace(2)* %1 to i32* addrspace(2)*
  store i32* @g, i32* addrspace(2)* %2, align 8
  %3 = bitcast %union.anon addrspace(2)* %1 to i32 addrspace(3)* addrspace(2)*
  store i32 addrspace(3)* @l, i32 addrspace(3)* addrspace(2)* %3, align 8
  ret void
}

@l4 = common addrspace(4) global i32 0, align 4

; If pointers from different address spaces have the same size, that pointer
; should be promoted through the pair of `ptrtoint`/`inttoptr`.
define i32* @pr27557.alt() {
; CHECK-LABEL: @pr27557.alt(
; CHECK-NEXT:    ret i32* inttoptr (i64 ptrtoint (i32 addrspace(4)* @l4 to i64) to i32*)
;
  %1 = alloca %union.anon, align 8, addrspace(2)
  %2 = bitcast %union.anon addrspace(2)* %1 to i32 addrspace(4)* addrspace(2)*
  store i32 addrspace(4)* @l4, i32 addrspace(4)* addrspace(2)* %2, align 8
  %3 = bitcast %union.anon addrspace(2)* %1 to i32* addrspace(2)*
  %4 = load i32*, i32* addrspace(2)* %3, align 8
  ret i32* %4
}

; Test load from and store to non-zero address space.
define void @test_load_store_diff_addr_space([2 x float] addrspace(1)* %complex1, [2 x float] addrspace(1)* %complex2) {
; CHECK-LABEL: @test_load_store_diff_addr_space(
; CHECK-NEXT:    [[P1_SROA_CAST:%.*]] = bitcast [2 x float] addrspace(1)* [[COMPLEX1:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    [[V15:%.*]] = load i32, i32 addrspace(1)* [[P1_SROA_CAST]], align 4
; CHECK-NEXT:    [[P1_SROA_IDX:%.*]] = getelementptr inbounds [2 x float], [2 x float] addrspace(1)* [[COMPLEX1]], i16 0, i16 1
; CHECK-NEXT:    [[P1_SROA_CAST7:%.*]] = bitcast float addrspace(1)* [[P1_SROA_IDX]] to i32 addrspace(1)*
; CHECK-NEXT:    [[V18:%.*]] = load i32, i32 addrspace(1)* [[P1_SROA_CAST7]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[V15]] to float
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[V18]] to float
; CHECK-NEXT:    [[SUM:%.*]] = fadd float [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast float [[SUM]] to i32
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast float [[SUM]] to i32
; CHECK-NEXT:    [[P2_SROA_CAST:%.*]] = bitcast [2 x float] addrspace(1)* [[COMPLEX2:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 [[TMP3]], i32 addrspace(1)* [[P2_SROA_CAST]], align 4
; CHECK-NEXT:    [[P2_SROA_IDX:%.*]] = getelementptr inbounds [2 x float], [2 x float] addrspace(1)* [[COMPLEX2]], i16 0, i16 1
; CHECK-NEXT:    [[P2_SROA_CAST4:%.*]] = bitcast float addrspace(1)* [[P2_SROA_IDX]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 [[TMP4]], i32 addrspace(1)* [[P2_SROA_CAST4]], align 4
; CHECK-NEXT:    ret void
;
  %a0 = alloca [2 x i64], align 8, addrspace(2)
  %a = getelementptr [2 x i64], [2 x i64] addrspace(2)* %a0, i32 0, i32 0
  %a.cast = bitcast i64 addrspace(2)* %a to [2 x float] addrspace(2)*
  %a.gep1 = getelementptr [2 x float], [2 x float] addrspace(2)* %a.cast, i32 0, i32 0
  %a.gep2 = getelementptr [2 x float], [2 x float] addrspace(2)* %a.cast, i32 0, i32 1
  %complex1.gep = getelementptr [2 x float], [2 x float] addrspace(1)* %complex1, i32 0, i32 0
  %p1 = bitcast float addrspace(1)* %complex1.gep to i64 addrspace(1)*
  %v1 = load i64, i64 addrspace(1)* %p1
  store i64 %v1, i64 addrspace(2)* %a
  %f1 = load float, float addrspace(2)* %a.gep1
  %f2 = load float, float addrspace(2)* %a.gep2
  %sum = fadd float %f1, %f2
  store float %sum, float addrspace(2)* %a.gep1
  store float %sum, float addrspace(2)* %a.gep2
  %v2 = load i64, i64 addrspace(2)* %a
  %complex2.gep = getelementptr [2 x float], [2 x float] addrspace(1)* %complex2, i32 0, i32 0
  %p2 = bitcast float addrspace(1)* %complex2.gep to i64 addrspace(1)*
  store i64 %v2, i64 addrspace(1)* %p2
  ret void
}

define void @addressspace_alloca_lifetime() {
; CHECK-LABEL: @addressspace_alloca_lifetime(
; CHECK-NEXT:    ret void
;
  %alloca = alloca i8, align 8, addrspace(2)
  %cast = addrspacecast i8 addrspace(2)* %alloca to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %cast)
  ret void
}

declare void @llvm.lifetime.start.p0i8(i64 %size, i8* nocapture %ptr)
