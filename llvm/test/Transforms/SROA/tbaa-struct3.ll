; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -p sroa -S %s | FileCheck %s

define void @load_store_transfer_split_struct_tbaa_2_float(ptr dereferenceable(24) %res, float %a, float %b) {
; CHECK-LABEL: define void @load_store_transfer_split_struct_tbaa_2_float(
; CHECK-SAME: ptr dereferenceable(24) [[RES:%.*]], float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast float [[A]] to i32
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast float [[B]] to i32
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[RES]], align 4
; CHECK-NEXT:    [[RES_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[RES]], i64 4
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[RES_SROA_IDX]], align 4
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[RES]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %tmp = alloca { float, float }, align 4
  store float %a, ptr %tmp, align 4
  %tmp.4 = getelementptr inbounds i8, ptr %tmp, i64 4
  store float %b, ptr %tmp.4, align 4
  %l1 = load i64, ptr %tmp, !tbaa.struct !0
  store i64 %l1, ptr %res, !tbaa.struct !0
  %p = load ptr, ptr %res, align 8
  ret void
}

define void @memcpy_transfer(ptr dereferenceable(24) %res, float %a, float %b) {
; CHECK-LABEL: define void @memcpy_transfer(
; CHECK-SAME: ptr dereferenceable(24) [[RES:%.*]], float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[L_PTR:%.*]] = load ptr, ptr [[RES]], align 8
; CHECK-NEXT:    store float [[A]], ptr [[L_PTR]], align 1, !tbaa.struct [[TBAA_STRUCT0:![0-9]+]]
; CHECK-NEXT:    [[TMP_SROA_2_0_L_PTR_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[L_PTR]], i64 4
; CHECK-NEXT:    store float [[B]], ptr [[TMP_SROA_2_0_L_PTR_SROA_IDX]], align 1, !tbaa.struct [[TBAA_STRUCT5:![0-9]+]]
; CHECK-NEXT:    ret void
;
entry:
  %tmp = alloca { float, float }, align 4
  store float %a, ptr %tmp, align 4
  %__im_.i.i = getelementptr inbounds i8, ptr %tmp, i64 4
  store float %b, ptr %__im_.i.i, align 4
  %l.ptr = load ptr, ptr %res, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %l.ptr, ptr %tmp, i64 8, i1 false), !tbaa.struct !0
  ret void
}

define void @memcpy_transfer_tbaa_field_and_size_do_not_align(ptr dereferenceable(24) %res, float %a, float %b) {
; CHECK-LABEL: define void @memcpy_transfer_tbaa_field_and_size_do_not_align(
; CHECK-SAME: ptr dereferenceable(24) [[RES:%.*]], float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[L_PTR:%.*]] = load ptr, ptr [[RES]], align 8
; CHECK-NEXT:    store float [[A]], ptr [[L_PTR]], align 1, !tbaa.struct [[TBAA_STRUCT0]]
; CHECK-NEXT:    [[TMP_SROA_2_0_L_PTR_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[L_PTR]], i64 4
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast float [[B]] to i32
; CHECK-NEXT:    [[TMP_SROA_2_0_EXTRACT_TRUNC:%.*]] = trunc i32 [[TMP0]] to i16
; CHECK-NEXT:    store i16 [[TMP_SROA_2_0_EXTRACT_TRUNC]], ptr [[TMP_SROA_2_0_L_PTR_SROA_IDX]], align 1, !tbaa.struct [[TBAA_STRUCT5]]
; CHECK-NEXT:    ret void
;
entry:
  %tmp = alloca { float, float }, align 4
  store float %a, ptr %tmp, align 4
  %__im_.i.i = getelementptr inbounds i8, ptr %tmp, i64 4
  store float %b, ptr %__im_.i.i, align 4
  %l.ptr = load ptr, ptr %res, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %l.ptr, ptr %tmp, i64 6, i1 false), !tbaa.struct !0
  ret void
}

define void @load_store_transfer_split_struct_tbaa_2_i31(ptr dereferenceable(24) %res, i31 %a, i31 %b) {
; CHECK-LABEL: define void @load_store_transfer_split_struct_tbaa_2_i31(
; CHECK-SAME: ptr dereferenceable(24) [[RES:%.*]], i31 [[A:%.*]], i31 [[B:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP:%.*]] = alloca { i31, i31 }, align 4
; CHECK-NEXT:    store i31 [[A]], ptr [[TMP]], align 4
; CHECK-NEXT:    [[TMP_4_TMP_4_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[TMP]], i64 4
; CHECK-NEXT:    store i31 [[B]], ptr [[TMP_4_TMP_4_SROA_IDX]], align 4
; CHECK-NEXT:    [[TMP_0_L1:%.*]] = load i62, ptr [[TMP]], align 4, !tbaa.struct [[TBAA_STRUCT0]]
; CHECK-NEXT:    store i62 [[TMP_0_L1]], ptr [[RES]], align 4, !tbaa.struct [[TBAA_STRUCT0]]
; CHECK-NEXT:    ret void
;
entry:
  %tmp = alloca { i31 , i31 }, align 4
  store i31 %a, ptr %tmp, align 4
  %tmp.4  = getelementptr inbounds i8, ptr %tmp, i64 4
  store i31 %b, ptr %tmp.4, align 4
  %l1 = load i62, ptr %tmp, !tbaa.struct !0
  store i62 %l1, ptr %res, !tbaa.struct !0
  ret void
}


; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #2

!0 = !{i64 0, i64 4, !1, i64 4, i64 4, !1}
!1 = !{!2, !2, i64 0}
!2 = !{!"float", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C++ TBAA"}
;.
; CHECK: [[TBAA_STRUCT0]] = !{i64 0, i64 4, [[META1:![0-9]+]], i64 4, i64 4, [[META1]]}
; CHECK: [[META1]] = !{[[META2:![0-9]+]], [[META2]], i64 0}
; CHECK: [[META2]] = !{!"float", [[META3:![0-9]+]], i64 0}
; CHECK: [[META3]] = !{!"omnipotent char", [[META4:![0-9]+]], i64 0}
; CHECK: [[META4]] = !{!"Simple C++ TBAA"}
; CHECK: [[TBAA_STRUCT5]] = !{i64 0, i64 4, [[META1]]}
;.
