; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=objc-arc < %s | FileCheck %s

target datalayout = "e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32"
target triple = "i686--windows-msvc"

declare ptr @f(ptr, ptr)

declare i32 @__CxxFrameHandler3(...)

declare dllimport ptr @llvm.objc.autoreleaseReturnValue(ptr returned)
declare dllimport ptr @llvm.objc.retain(ptr returned)
declare dllimport ptr @llvm.objc.retainAutoreleasedReturnValue(ptr returned)
declare dllimport void @llvm.objc.release(ptr)

define ptr @g(ptr %p, ptr %q) local_unnamed_addr personality ptr @__CxxFrameHandler3 {
; CHECK-LABEL: @g(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P:%.*]]) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    [[V1:%.*]] = call ptr @f(ptr null, ptr null)
; CHECK-NEXT:    [[CALL:%.*]] = invoke ptr @f(ptr [[P]], ptr [[Q:%.*]])
; CHECK-NEXT:    to label [[INVOKE_CONT:%.*]] unwind label [[CATCH_DISPATCH:%.*]], !clang.arc.no_objc_arc_exceptions !0
; CHECK:       catch.dispatch:
; CHECK-NEXT:    [[TMP1:%.*]] = catchswitch within none [label %catch] unwind to caller
; CHECK:       catch:
; CHECK-NEXT:    [[TMP2:%.*]] = catchpad within [[TMP1]] [ptr null, i32 64, ptr null]
; CHECK-NEXT:    catchret from [[TMP2]] to label [[CLEANUP:%.*]]
; CHECK:       invoke.cont:
; CHECK-NEXT:    [[TMP3:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[CALL]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[CLEANUP]]
; CHECK:       cleanup:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi ptr [ [[CALL]], [[INVOKE_CONT]] ], [ null, [[CATCH:%.*]] ]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    [[TMP4:%.*]] = tail call ptr @llvm.objc.autoreleaseReturnValue(ptr [[RETVAL_0]]) #[[ATTR0]]
; CHECK-NEXT:    ret ptr [[RETVAL_0]]
;
entry:
  %0 = tail call ptr @llvm.objc.retain(ptr %p) #0
  ; the following call prevents ARC optimizer from removing the retain/release
  ; pair on %p
  %v1 = call ptr @f(ptr null, ptr null)
  %1 = tail call ptr @llvm.objc.retain(ptr %q) #0
  %call = invoke ptr @f(ptr %p, ptr %q)
  to label %invoke.cont unwind label %catch.dispatch, !clang.arc.no_objc_arc_exceptions !0

catch.dispatch:
  %2 = catchswitch within none [label %catch] unwind to caller

catch:
  %3 = catchpad within %2 [ptr null, i32 64, ptr null]
  catchret from %3 to label %cleanup

invoke.cont:
  %4 = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %call) #0
  br label %cleanup

cleanup:
  %retval.0 = phi ptr [ %call, %invoke.cont ], [ null, %catch ]
  tail call void @llvm.objc.release(ptr %q) #0, !clang.imprecise_release !0
  tail call void @llvm.objc.release(ptr %p) #0, !clang.imprecise_release !0
  %5 = tail call ptr @llvm.objc.autoreleaseReturnValue(ptr %retval.0) #0
  ret ptr %retval.0
}

attributes #0 = { nounwind }

!0 = !{}
