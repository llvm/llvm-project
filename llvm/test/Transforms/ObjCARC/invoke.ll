; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=objc-arc < %s | FileCheck %s

declare ptr @llvm.objc.retain(ptr)
declare void @llvm.objc.release(ptr)
declare ptr @llvm.objc.retainAutoreleasedReturnValue(ptr)
declare ptr @objc_msgSend(ptr, ptr, ...)
declare void @use_pointer(ptr)
declare void @callee()
declare ptr @returner()

; ARCOpt shouldn't try to move the releases to the block containing the invoke.

define void @test0(ptr %zipFile) personality ptr @__gxx_personality_v0 {
; CHECK-LABEL: define void @test0(
; CHECK-SAME: ptr [[ZIPFILE:%.*]]) personality ptr @__gxx_personality_v0 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[ZIPFILE]]) #[[ATTR0:[0-9]+]], !clang.imprecise_release [[META0:![0-9]+]]
; CHECK-NEXT:    call void @use_pointer(ptr [[ZIPFILE]])
; CHECK-NEXT:    invoke void @objc_msgSend(ptr [[ZIPFILE]])
; CHECK-NEXT:            to label %[[INVOKE_CONT:.*]] unwind label %[[LPAD:.*]]
; CHECK:       [[INVOKE_CONT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[ZIPFILE]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
; CHECK:       [[LPAD]]:
; CHECK-NEXT:    [[EXN:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[ZIPFILE]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %zipFile) nounwind
  call void @use_pointer(ptr %zipFile)
  invoke void @objc_msgSend(ptr %zipFile)
  to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @llvm.objc.release(ptr %zipFile) nounwind, !clang.imprecise_release !0
  ret void

lpad:                                             ; preds = %entry
  %exn = landingpad {ptr, i32}
  cleanup
  call void @llvm.objc.release(ptr %zipFile) nounwind, !clang.imprecise_release !0
  ret void
}

; ARCOpt should move the release before the callee calls.

define void @test1(ptr %zipFile) personality ptr @__gxx_personality_v0 {
; CHECK-LABEL: define void @test1(
; CHECK-SAME: ptr [[ZIPFILE:%.*]]) personality ptr @__gxx_personality_v0 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[ZIPFILE]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[ZIPFILE]])
; CHECK-NEXT:    invoke void @objc_msgSend(ptr [[ZIPFILE]])
; CHECK-NEXT:            to label %[[INVOKE_CONT:.*]] unwind label %[[LPAD:.*]]
; CHECK:       [[INVOKE_CONT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[ZIPFILE]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[DONE:.*]]
; CHECK:       [[LPAD]]:
; CHECK-NEXT:    [[EXN:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[ZIPFILE]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %zipFile) nounwind
  call void @use_pointer(ptr %zipFile)
  invoke void @objc_msgSend(ptr %zipFile)
  to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @callee()
  br label %done

lpad:                                             ; preds = %entry
  %exn = landingpad {ptr, i32}
  cleanup
  call void @callee()
  br label %done

done:
  call void @llvm.objc.release(ptr %zipFile) nounwind, !clang.imprecise_release !0
  ret void
}

; The optimizer should ignore invoke unwind paths consistently.
; PR12265

define void @test2() personality ptr @__objc_personality_v0 {
; CHECK-LABEL: define void @test2() personality ptr @__objc_personality_v0 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CALL:%.*]] = invoke ptr @objc_msgSend()
; CHECK-NEXT:            to label %[[INVOKE_CONT:.*]] unwind label %[[FINALLY_RETHROW:.*]], !clang.arc.no_objc_arc_exceptions [[META0]]
; CHECK:       [[INVOKE_CONT]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[CALL]]) #[[ATTR0]]
; CHECK-NEXT:    call void @objc_msgSend(), !clang.arc.no_objc_arc_exceptions [[META0]]
; CHECK-NEXT:    invoke void @use_pointer(ptr [[CALL]])
; CHECK-NEXT:            to label %[[FINALLY_CONT:.*]] unwind label %[[FINALLY_RETHROW]], !clang.arc.no_objc_arc_exceptions [[META0]]
; CHECK:       [[FINALLY_CONT]]:
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[CALL]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    ret void
; CHECK:       [[FINALLY_RETHROW]]:
; CHECK-NEXT:    [[TMP2:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            catch ptr null
; CHECK-NEXT:    unreachable
;
entry:
  %call = invoke ptr @objc_msgSend()
  to label %invoke.cont unwind label %finally.rethrow, !clang.arc.no_objc_arc_exceptions !0

invoke.cont:                                      ; preds = %entry
  %tmp1 = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %call) nounwind
  call void @objc_msgSend(), !clang.arc.no_objc_arc_exceptions !0
  invoke void @use_pointer(ptr %call)
  to label %finally.cont unwind label %finally.rethrow, !clang.arc.no_objc_arc_exceptions !0

finally.cont:                                     ; preds = %invoke.cont
  tail call void @llvm.objc.release(ptr %call) nounwind, !clang.imprecise_release !0
  ret void

finally.rethrow:                                  ; preds = %invoke.cont, %entry
  %tmp2 = landingpad { ptr, i32 }
  catch ptr null
  unreachable
}

; Don't try to place code on invoke critical edges.

define void @test3(ptr %p, i1 %b) personality ptr @__objc_personality_v0 {
; CHECK-LABEL: define void @test3(
; CHECK-SAME: ptr [[P:%.*]], i1 [[B:%.*]]) personality ptr @__objc_personality_v0 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br i1 [[B]], label %[[IF_ELSE:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    invoke void @use_pointer(ptr [[P]])
; CHECK-NEXT:            to label %[[IF_END:.*]] unwind label %[[LPAD:.*]], !clang.arc.no_objc_arc_exceptions [[META0]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    invoke void @use_pointer(ptr [[P]])
; CHECK-NEXT:            to label %[[IF_END]] unwind label %[[LPAD]], !clang.arc.no_objc_arc_exceptions [[META0]]
; CHECK:       [[LPAD]]:
; CHECK-NEXT:    [[R:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:    ret void
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  br i1 %b, label %if.else, label %if.then

if.then:
  invoke void @use_pointer(ptr %p)
  to label %if.end unwind label %lpad, !clang.arc.no_objc_arc_exceptions !0

if.else:
  invoke void @use_pointer(ptr %p)
  to label %if.end unwind label %lpad, !clang.arc.no_objc_arc_exceptions !0

lpad:
  %r = landingpad { ptr, i32 }
  cleanup
  ret void

if.end:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Like test3, but with ARC-relevant exception handling.

define void @test4(ptr %p, i1 %b) personality ptr @__objc_personality_v0 {
; CHECK-LABEL: define void @test4(
; CHECK-SAME: ptr [[P:%.*]], i1 [[B:%.*]]) personality ptr @__objc_personality_v0 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br i1 [[B]], label %[[IF_ELSE:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    invoke void @use_pointer(ptr [[P]])
; CHECK-NEXT:            to label %[[IF_END:.*]] unwind label %[[LPAD:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    invoke void @use_pointer(ptr [[P]])
; CHECK-NEXT:            to label %[[IF_END]] unwind label %[[LPAD]]
; CHECK:       [[LPAD]]:
; CHECK-NEXT:    [[R:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  br i1 %b, label %if.else, label %if.then

if.then:
  invoke void @use_pointer(ptr %p)
  to label %if.end unwind label %lpad

if.else:
  invoke void @use_pointer(ptr %p)
  to label %if.end unwind label %lpad

lpad:
  %r = landingpad { ptr, i32 }
  cleanup
  call void @llvm.objc.release(ptr %p)
  ret void

if.end:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Don't turn the retainAutoreleaseReturnValue into retain, because it's
; for an invoke which we can assume codegen will put immediately prior.

define void @test5() personality ptr @__objc_personality_v0 {
; CHECK-LABEL: define void @test5() personality ptr @__objc_personality_v0 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[Z:%.*]] = invoke ptr @returner()
; CHECK-NEXT:            to label %[[IF_END:.*]] unwind label %[[LPAD:.*]], !clang.arc.no_objc_arc_exceptions [[META0]]
; CHECK:       [[LPAD]]:
; CHECK-NEXT:    [[R13:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:    ret void
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[Z]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %z = invoke ptr @returner()
  to label %if.end unwind label %lpad, !clang.arc.no_objc_arc_exceptions !0

lpad:
  %r13 = landingpad { ptr, i32 }
  cleanup
  ret void

if.end:
  call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %z)
  ret void
}

; Like test5, but there's intervening code.

define void @test6() personality ptr @__objc_personality_v0 {
; CHECK-LABEL: define void @test6() personality ptr @__objc_personality_v0 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[Z:%.*]] = invoke ptr @returner()
; CHECK-NEXT:            to label %[[IF_END:.*]] unwind label %[[LPAD:.*]], !clang.arc.no_objc_arc_exceptions [[META0]]
; CHECK:       [[LPAD]]:
; CHECK-NEXT:    [[R13:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:    ret void
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[Z]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %z = invoke ptr @returner()
  to label %if.end unwind label %lpad, !clang.arc.no_objc_arc_exceptions !0

lpad:
  %r13 = landingpad { ptr, i32 }
  cleanup
  ret void

if.end:
  call void @callee()
  call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %z)
  ret void
}

declare i32 @__gxx_personality_v0(...)
declare i32 @__objc_personality_v0(...)


!0 = !{}
;.
; CHECK: [[META0]] = !{}
;.
