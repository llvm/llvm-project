; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=objc-arc < %s | FileCheck %s
; rdar://9503416

; Detect loop boundaries and don't move retains and releases
; across them.

declare void @use_pointer(i8*)
declare i8* @llvm.objc.retain(i8*)
declare void @llvm.objc.release(i8*)
declare void @callee()
declare void @block_callee(void ()*)

define void @test0(i8* %digits) {
; CHECK-LABEL: @test0(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call i8* @llvm.objc.retain(i8* [[DIGITS:%.*]]) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    call void @use_pointer(i8* [[DIGITS]])
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[UPCDIGITINDEX_01:%.*]] = phi i64 [ 2, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    call void @use_pointer(i8* [[DIGITS]])
; CHECK-NEXT:    [[INC]] = add i64 [[UPCDIGITINDEX_01]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[INC]], 12
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.end:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[DIGITS]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %tmp1 = call i8* @llvm.objc.retain(i8* %digits) nounwind
  call void @use_pointer(i8* %digits)
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %upcDigitIndex.01 = phi i64 [ 2, %entry ], [ %inc, %for.body ]
  call void @use_pointer(i8* %digits)
  %inc = add i64 %upcDigitIndex.01, 1
  %cmp = icmp ult i64 %inc, 12
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  call void @llvm.objc.release(i8* %digits) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test1(i8* %digits) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call i8* @llvm.objc.retain(i8* [[DIGITS:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[UPCDIGITINDEX_01:%.*]] = phi i64 [ 2, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    call void @use_pointer(i8* [[DIGITS]])
; CHECK-NEXT:    call void @use_pointer(i8* [[DIGITS]])
; CHECK-NEXT:    [[INC]] = add i64 [[UPCDIGITINDEX_01]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[INC]], 12
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.end:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[DIGITS]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %tmp1 = call i8* @llvm.objc.retain(i8* %digits) nounwind
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %upcDigitIndex.01 = phi i64 [ 2, %entry ], [ %inc, %for.body ]
  call void @use_pointer(i8* %digits)
  call void @use_pointer(i8* %digits)
  %inc = add i64 %upcDigitIndex.01, 1
  %cmp = icmp ult i64 %inc, 12
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  call void @llvm.objc.release(i8* %digits) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test2(i8* %digits) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call i8* @llvm.objc.retain(i8* [[DIGITS:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[UPCDIGITINDEX_01:%.*]] = phi i64 [ 2, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    call void @use_pointer(i8* [[DIGITS]])
; CHECK-NEXT:    [[INC]] = add i64 [[UPCDIGITINDEX_01]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[INC]], 12
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; CHECK:       for.end:
; CHECK-NEXT:    call void @use_pointer(i8* [[DIGITS]])
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[DIGITS]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %tmp1 = call i8* @llvm.objc.retain(i8* %digits) nounwind
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %upcDigitIndex.01 = phi i64 [ 2, %entry ], [ %inc, %for.body ]
  call void @use_pointer(i8* %digits)
  %inc = add i64 %upcDigitIndex.01, 1
  %cmp = icmp ult i64 %inc, 12
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  call void @use_pointer(i8* %digits)
  call void @llvm.objc.release(i8* %digits) nounwind, !clang.imprecise_release !0
  ret void
}

; Delete nested retain+release pairs around loops.
define void @test3(i8* %a) nounwind {
; CHECK-LABEL: @test3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, i8* [[A]], align 1
; CHECK-NEXT:    br i1 undef, label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %outer = call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  call void @callee()
  store i8 0, i8* %a
  br i1 undef, label %loop, label %exit

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test4(i8* %a) nounwind {
; CHECK-LABEL: @test4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br label [[MORE:%.*]]
; CHECK:       more:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, i8* [[A]], align 1
; CHECK-NEXT:    br i1 undef, label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %outer = call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  br label %more

more:
  call void @callee()
  call void @callee()
  store i8 0, i8* %a
  br i1 undef, label %loop, label %exit

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test5(i8* %a) nounwind {
; CHECK-LABEL: @test5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    br label [[MORE]]
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    call void @use_pointer(i8* [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  call void @callee()
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  br label %more

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @use_pointer(i8* %a)
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test6(i8* %a) nounwind {
; CHECK-LABEL: @test6(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label [[MORE]]
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    call void @use_pointer(i8* [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  call void @callee()
  br label %more

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @use_pointer(i8* %a)
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test7(i8* %a) nounwind {
; CHECK-LABEL: @test7(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    call void @use_pointer(i8* [[A]])
; CHECK-NEXT:    br label [[MORE]]
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  call void @callee()
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  call void @use_pointer(i8* %a)
  br label %more

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test8(i8* %a) nounwind {
; CHECK-LABEL: @test8(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(i8* [[A]])
; CHECK-NEXT:    br label [[MORE]]
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  call void @callee()
  call void @use_pointer(i8* %a)
  br label %more

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test9(i8* %a) nounwind {
; CHECK-LABEL: @test9(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    call void @use_pointer(i8* [[A:%.*]])
; CHECK-NEXT:    br label [[MORE]]
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  call void @use_pointer(i8* %a)
  br label %more

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test10(i8* %a) nounwind {
; CHECK-LABEL: @test10(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label [[MORE]]
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  call void @callee()
  br label %more

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test11(i8* %a) nounwind {
; CHECK-LABEL: @test11(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    br label [[MORE]]
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  br label %more

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

; Don't delete anything if they're not balanced.

define void @test12(i8* %a) nounwind {
; CHECK-LABEL: @test12(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUTER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    [[INNER:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[TRUE:%.*]], label [[MORE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    ret void
; CHECK:       more:
; CHECK-NEXT:    br i1 undef, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %outer = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  %inner = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  br i1 undef, label %true, label %more

true:
  ret void

more:
  br i1 undef, label %exit, label %loop

exit:
  call void @llvm.objc.release(i8* %a) nounwind
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

; Do not improperly pair retains in a for loop with releases outside of a for
; loop when the proper pairing is disguised by a separate provenance represented
; by an alloca.
; rdar://12969722

define void @test13(i8* %a) nounwind {
; CHECK-LABEL: @test13(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BLOCK:%.*]] = alloca i8*, align 8
; CHECK-NEXT:    [[A1:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[A2:%.*]] = tail call i8* @llvm.objc.retain(i8* [[A]]) #[[ATTR0]]
; CHECK-NEXT:    store i8* [[A]], i8** [[BLOCK]], align 8
; CHECK-NEXT:    [[CASTED_BLOCK:%.*]] = bitcast i8** [[BLOCK]] to void ()*
; CHECK-NEXT:    call void @block_callee(void ()* [[CASTED_BLOCK]])
; CHECK-NEXT:    [[RELOADED_A:%.*]] = load i8*, i8** [[BLOCK]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[RELOADED_A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    br i1 undef, label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[A]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %block = alloca i8*
  %a1 = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  br label %loop

loop:
  %a2 = tail call i8* @llvm.objc.retain(i8* %a) nounwind
  store i8* %a, i8** %block, align 8
  %casted_block = bitcast i8** %block to void ()*
  call void @block_callee(void ()* %casted_block)
  %reloaded_a = load i8*, i8** %block, align 8
  call void @llvm.objc.release(i8* %reloaded_a) nounwind, !clang.imprecise_release !0
  br i1 undef, label %loop, label %exit

exit:
  call void @llvm.objc.release(i8* %a) nounwind, !clang.imprecise_release !0
  ret void
}

; The retain call in the entry block shouldn't be moved to the loop body.

define void @test14(i8* %val0, i8 %val1) {
; CHECK-LABEL: @test14(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V1:%.*]] = tail call i8* @llvm.objc.retain(i8* [[VAL0:%.*]]) #[[ATTR0]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8* [[VAL0]], null
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_END27:%.*]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i8 [[VAL1:%.*]], 1
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[CMP6:%.*]] = icmp eq i8 [[VAL1]], 2
; CHECK-NEXT:    br i1 [[CMP6]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    [[TOBOOL9:%.*]] = icmp eq i8 [[VAL1]], 0
; CHECK-NEXT:    br i1 [[TOBOOL9]], label [[FOR_COND:%.*]], label [[IF_THEN10:%.*]]
; CHECK:       if.then10:
; CHECK-NEXT:    br label [[FOR_END:%.*]]
; CHECK:       for.end.loopexit:
; CHECK-NEXT:    br label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(i8* [[V1]])
; CHECK-NEXT:    br label [[IF_END27]]
; CHECK:       if.end27:
; CHECK-NEXT:    call void @llvm.objc.release(i8* [[V1]]) #[[ATTR0]], !clang.imprecise_release !0
; CHECK-NEXT:    ret void
;
entry:
  %v1 = tail call i8* @llvm.objc.retain(i8* %val0)
  %cmp = icmp eq i8* %val0, null
  br i1 %cmp, label %if.end27, label %if.then

if.then:
  %tobool = icmp eq i8 %val1, 1
  br label %for.body

for.cond:
  %cmp6 = icmp eq i8 %val1, 2
  br i1 %cmp6, label %for.body, label %for.end.loopexit

for.body:
  call void @callee()
  %tobool9 = icmp eq i8 %val1, 0
  br i1 %tobool9, label %for.cond, label %if.then10

if.then10:
  br label %for.end

for.end.loopexit:
  br label %for.end

for.end:
  call void @callee()
  call void @use_pointer(i8* %v1)
  br label %if.end27

if.end27:
  call void @llvm.objc.release(i8* %v1) #0, !clang.imprecise_release !0
  ret void
}


!0 = !{}
