; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -aa-pipeline=basic-aa -passes=objc-arc -S < %s | FileCheck %s

target datalayout = "e-p:64:64:64"

declare ptr @llvm.objc.retain(ptr)
declare ptr @llvm.objc.retainAutoreleasedReturnValue(ptr)
declare ptr @llvm.objc.unsafeClaimAutoreleasedReturnValue(ptr)
declare void @llvm.objc.release(ptr)
declare ptr @llvm.objc.autorelease(ptr)
declare ptr @llvm.objc.autoreleaseReturnValue(ptr)
declare void @llvm.objc.autoreleasePoolPop(ptr)
declare ptr @llvm.objc.autoreleasePoolPush()
declare ptr @llvm.objc.retainBlock(ptr)

declare ptr @llvm.objc.retainedObject(ptr)
declare ptr @llvm.objc.unretainedObject(ptr)
declare ptr @llvm.objc.unretainedPointer(ptr)

declare void @use_pointer(ptr)
declare void @callee()
declare void @callee2(ptr, ptr)
declare void @callee_fnptr(ptr)
declare void @invokee()
declare ptr @returner()
declare void @bar(ptr)

declare void @llvm.dbg.value(metadata, metadata, metadata)

declare ptr @objc_msgSend(ptr, ptr, ...)

; Simple retain+release pair deletion, with some intervening control
; flow and harmless instructions.

define void @test0_precise(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test0_precise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  store i32 7, ptr %x
  br label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test0_imprecise(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test0_imprecise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  store i32 7, ptr %x
  br label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}

; Like test0 but the release isn't always executed when the retain is,
; so the optimization is not safe.

; TODO: Make the llvm.objc.release's argument be %0.

define void @test1_precise(ptr %x, i1 %p, i1 %q) nounwind {
; CHECK-LABEL: define void @test1_precise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br i1 [[Q]], label %[[RETURN]], label %[[ALT_RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
; CHECK:       [[ALT_RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  store i32 7, ptr %x
  call void @callee()
  br i1 %q, label %return, label %alt_return

return:
  call void @llvm.objc.release(ptr %x) nounwind
  ret void

alt_return:
  ret void
}

define void @test1_imprecise(ptr %x, i1 %p, i1 %q) nounwind {
; CHECK-LABEL: define void @test1_imprecise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br i1 [[Q]], label %[[RETURN]], label %[[ALT_RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3:![0-9]+]]
; CHECK-NEXT:    ret void
; CHECK:       [[ALT_RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  store i32 7, ptr %x
  call void @callee()
  br i1 %q, label %return, label %alt_return

return:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void

alt_return:
  ret void
}


; Don't do partial elimination into two different CFG diamonds.

define void @test1b_precise(ptr %x, i1 %p, i1 %q) {
; CHECK-LABEL: define void @test1b_precise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    tail call void @callee()
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    br i1 [[Q]], label %[[IF_THEN3:.*]], label %[[IF_END5:.*]]
; CHECK:       [[IF_THEN3]]:
; CHECK-NEXT:    tail call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    br label %[[IF_END5]]
; CHECK:       [[IF_END5]]:
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  tail call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @callee()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br i1 %q, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  tail call void @use_pointer(ptr %x)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  tail call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test1b_imprecise(ptr %x, i1 %p, i1 %q) {
; CHECK-LABEL: define void @test1b_imprecise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    tail call void @callee()
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    br i1 [[Q]], label %[[IF_THEN3:.*]], label %[[IF_END5:.*]]
; CHECK:       [[IF_THEN3]]:
; CHECK-NEXT:    tail call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    br label %[[IF_END5]]
; CHECK:       [[IF_END5]]:
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    ret void
;
entry:
  tail call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @callee()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br i1 %q, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  tail call void @use_pointer(ptr %x)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  tail call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}


; Like test0 but the pointer is passed to an intervening call,
; so the optimization is not safe.

define void @test2_precise(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test2_precise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @use_pointer(ptr [[TMP0]])
; CHECK-NEXT:    store float 3.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  store i32 7, ptr %x
  call void @use_pointer(ptr %0)
  store float 3.0, ptr %x
  br label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test2_imprecise(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test2_imprecise(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @use_pointer(ptr [[TMP0]])
; CHECK-NEXT:    store float 3.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  store i32 7, ptr %x
  call void @use_pointer(ptr %0)
  store float 3.0, ptr %x
  br label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}

; Like test0 but the release is in a loop,
; so the optimization is not safe.

; TODO: For now, assume this can't happen.

; TODO: @llvm.objc.retain(ptr %a)
; TODO: @llvm.objc.release
; CHECK: {{^}}}
define void @test3_precise(ptr %x, ptr %q) nounwind {
; CHECK-LABEL: define void @test3_precise(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[J:%.*]] = load volatile i1, ptr [[Q]], align 1
; CHECK-NEXT:    br i1 [[J]], label %[[LOOP]], label %[[RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %loop

loop:
  call void @llvm.objc.release(ptr %x) nounwind
  %j = load volatile i1, ptr %q
  br i1 %j, label %loop, label %return

return:
  ret void
}

; TODO: @llvm.objc.retain(ptr %a)
; TODO: @llvm.objc.release
; CHECK: {{^}}}
define void @test3_imprecise(ptr %x, ptr %q) nounwind {
; CHECK-LABEL: define void @test3_imprecise(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[J:%.*]] = load volatile i1, ptr [[Q]], align 1
; CHECK-NEXT:    br i1 [[J]], label %[[LOOP]], label %[[RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %loop

loop:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  %j = load volatile i1, ptr %q
  br i1 %j, label %loop, label %return

return:
  ret void
}


; TODO: For now, assume this can't happen.

; Like test0 but the retain is in a loop,
; so the optimization is not safe.

; TODO: @llvm.objc.retain(ptr %a)
; TODO: @llvm.objc.release
; CHECK: {{^}}}
define void @test4_precise(ptr %x, ptr %q) nounwind {
; CHECK-LABEL: define void @test4_precise(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[J:%.*]] = load volatile i1, ptr [[Q]], align 1
; CHECK-NEXT:    br i1 [[J]], label %[[LOOP]], label %[[RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  %j = load volatile i1, ptr %q
  br i1 %j, label %loop, label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; TODO: @llvm.objc.retain(ptr %a)
; TODO: @llvm.objc.release
; CHECK: {{^}}}
define void @test4_imprecise(ptr %x, ptr %q) nounwind {
; CHECK-LABEL: define void @test4_imprecise(
; CHECK-SAME: ptr [[X:%.*]], ptr [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[J:%.*]] = load volatile i1, ptr [[Q]], align 1
; CHECK-NEXT:    br i1 [[J]], label %[[LOOP]], label %[[RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  %j = load volatile i1, ptr %q
  br i1 %j, label %loop, label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}


; Like test0 but the pointer is conditionally passed to an intervening call,
; so the optimization is not safe.

define void @test5a(ptr %x, i1 %q, ptr %y) nounwind {
; CHECK-LABEL: define void @test5a(
; CHECK-SAME: ptr [[X:%.*]], i1 [[Q:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S:%.*]] = select i1 [[Q]], ptr [[Y]], ptr [[X]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[S]])
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  %s = select i1 %q, ptr %y, ptr %0
  call void @use_pointer(ptr %s)
  store i32 7, ptr %x
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test5b(ptr %x, i1 %q, ptr %y) nounwind {
; CHECK-LABEL: define void @test5b(
; CHECK-SAME: ptr [[X:%.*]], i1 [[Q:%.*]], ptr [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[S:%.*]] = select i1 [[Q]], ptr [[Y]], ptr [[X]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @use_pointer(ptr [[S]])
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  %s = select i1 %q, ptr %y, ptr %0
  call void @use_pointer(ptr %s)
  store i32 7, ptr %x
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}


; retain+release pair deletion, where the release happens on two different
; flow paths.

define void @test6a(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test6a(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

f:
  store i32 7, ptr %x
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

return:
  ret void
}

define void @test6b(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test6b(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

f:
  store i32 7, ptr %x
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

return:
  ret void
}

define void @test6c(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test6c(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

f:
  store i32 7, ptr %x
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

return:
  ret void
}

define void @test6d(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test6d(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %p, label %t, label %f

t:
  store i8 3, ptr %x
  store float 2.0, ptr %x
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

f:
  store i32 7, ptr %x
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

return:
  ret void
}


; retain+release pair deletion, where the retain happens on two different
; flow paths.

define void @test7(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test7(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %p, label %t, label %f

t:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i32 7, ptr %x
  call void @callee()
  br label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test7b(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test7b(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %p, label %t, label %f

t:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i32 7, ptr %x
  call void @callee()
  br label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}

; Like test7, but there's a retain/retainBlock mismatch. Don't delete!

define void @test7c(ptr %x, i1 %p) nounwind {
; CHECK-LABEL: define void @test7c(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.objc.retainBlock(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %p, label %t, label %f

t:
  %0 = call ptr @llvm.objc.retainBlock(ptr %x) nounwind
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %return

f:
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i32 7, ptr %x
  call void @callee()
  br label %return

return:
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; retain+release pair deletion, where the retain and release both happen on
; different flow paths. Wild!

define void @test8a(ptr %x, i1 %p, i1 %q) nounwind {
; CHECK-LABEL: define void @test8a(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID]]
; CHECK:       [[MID]]:
; CHECK-NEXT:    br i1 [[Q]], label %[[U:.*]], label %[[G:.*]]
; CHECK:       [[U]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[G]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %p, label %t, label %f

t:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %mid

f:
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i32 7, ptr %x
  br label %mid

mid:
  br i1 %q, label %u, label %g

u:
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

g:
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

return:
  ret void
}

define void @test8b(ptr %x, i1 %p, i1 %q) nounwind {
; CHECK-LABEL: define void @test8b(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID]]
; CHECK:       [[MID]]:
; CHECK-NEXT:    br i1 [[Q]], label %[[U:.*]], label %[[G:.*]]
; CHECK:       [[U]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[G]]:
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %p, label %t, label %f

t:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %mid

f:
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i32 7, ptr %x
  br label %mid

mid:
  br i1 %q, label %u, label %g

u:
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

g:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

return:
  ret void
}

define void @test8c(ptr %x, i1 %p, i1 %q) nounwind {
; CHECK-LABEL: define void @test8c(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID]]
; CHECK:       [[MID]]:
; CHECK-NEXT:    br i1 [[Q]], label %[[U:.*]], label %[[G:.*]]
; CHECK:       [[U]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[G]]:
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %p, label %t, label %f

t:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %mid

f:
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i32 7, ptr %x
  br label %mid

mid:
  br i1 %q, label %u, label %g

u:
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

g:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

return:
  ret void
}

define void @test8d(ptr %x, i1 %p, i1 %q) nounwind {
; CHECK-LABEL: define void @test8d(
; CHECK-SAME: ptr [[X:%.*]], i1 [[P:%.*]], i1 [[Q:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[P]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i8 3, ptr [[X]], align 1
; CHECK-NEXT:    store float 2.000000e+00, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store i32 7, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[MID]]
; CHECK:       [[MID]]:
; CHECK-NEXT:    br i1 [[Q]], label %[[U:.*]], label %[[G:.*]]
; CHECK:       [[U]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[G]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %p, label %t, label %f

t:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i8 3, ptr %x
  store float 2.0, ptr %x
  br label %mid

f:
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  store i32 7, ptr %x
  br label %mid

mid:
  br i1 %q, label %u, label %g

u:
  call void @callee()
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %return

g:
  call void @llvm.objc.release(ptr %x) nounwind
  br label %return

return:
  ret void
}

; Trivial retain+release pair deletion.

define void @test9(ptr %x) nounwind {
; CHECK-LABEL: define void @test9(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @llvm.objc.release(ptr %0) nounwind
  ret void
}

; Retain+release pair, but on an unknown pointer relationship. Don't delete!

define void @test9b(ptr %x, i1 %j, ptr %p) nounwind {
; CHECK-LABEL: define void @test9b(
; CHECK-SAME: ptr [[X:%.*]], i1 [[J:%.*]], ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[S:%.*]] = select i1 [[J]], ptr [[X]], ptr [[P]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[S]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  %s = select i1 %j, ptr %x, ptr %p
  call void @llvm.objc.release(ptr %s) nounwind
  ret void
}

; Trivial retain+release pair with intervening calls - don't delete!

define void @test10(ptr %x) nounwind {
; CHECK-LABEL: define void @test10(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @callee()
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %0) nounwind
  ret void
}

; Trivial retain+autoreleaserelease pair. Don't delete!
; Also, add a tail keyword, since llvm.objc.retain can never be passed
; a stack argument.

define void @test11(ptr %x) nounwind {
; CHECK-LABEL: define void @test11(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[TMP0]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.autorelease(ptr %0) nounwind
  call void @use_pointer(ptr %x)
  ret void
}

; Same as test11 but with no use_pointer call. Delete the pair!

define void @test11a(ptr %x) nounwind {
; CHECK-LABEL: define void @test11a(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.autorelease(ptr %0) nounwind
  ret void
}

; Same as test11 but the value is returned. Do not perform an RV optimization
; since if the frontend emitted code for an __autoreleasing variable, we may
; want it to be in the autorelease pool.

define ptr @test11b(ptr %x) nounwind {
; CHECK-LABEL: define ptr @test11b(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[TMP0]]) #[[ATTR0]]
; CHECK-NEXT:    ret ptr [[X]]
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.autorelease(ptr %0) nounwind
  ret ptr %x
}

; We can not delete this retain, release since we do not have a post-dominating
; use of the release.

define void @test12(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test12(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Trivial retain,autorelease pair. Don't delete!

define void @test13(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test13(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP2:%.*]] = call ptr @llvm.objc.autorelease(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call ptr @llvm.objc.autorelease(ptr %x) nounwind
  ret void
}

; Delete the retain+release pair.

define void @test13b(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test13b(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Don't delete the retain+release pair because there's an
; autoreleasePoolPop in the way.

define void @test13c(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test13c(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.autoreleasePoolPop(ptr undef) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @llvm.objc.autoreleasePoolPop(ptr undef)
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Like test13c, but there's an autoreleasePoolPush in the way, but that
; doesn't matter.

define void @test13d(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test13d(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autoreleasePoolPush() #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.autoreleasePoolPush()
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Trivial retain,release pair with intervening call, and it's post-dominated by
; another release. But it is not known safe in the top down direction. We can
; not eliminate it.

define void @test14(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test14(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Trivial retain,autorelease pair with intervening call, but it's post-dominated
; by another release. Don't delete anything.

define void @test15(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test15(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.objc.autorelease(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call ptr @llvm.objc.autorelease(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Trivial retain,autorelease pair, post-dominated
; by another release. Delete the retain and release.

define void @test15b(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test15b(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.autorelease(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test15c(ptr %x, i64 %n) {
; CHECK-LABEL: define void @test15c(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.objc.autorelease(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.autorelease(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}

; Retain+release pairs in diamonds, all dominated by a retain.

define void @test16a(i1 %a, i1 %b, ptr %x) {
; CHECK-LABEL: define void @test16a(
; CHECK-SAME: i1 [[A:%.*]], i1 [[B:%.*]], ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[A]], label %[[RED:.*]], label %[[ORANGE:.*]]
; CHECK:       [[RED]]:
; CHECK-NEXT:    br label %[[YELLOW:.*]]
; CHECK:       [[ORANGE]]:
; CHECK-NEXT:    br label %[[YELLOW]]
; CHECK:       [[YELLOW]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    br i1 [[B]], label %[[GREEN:.*]], label %[[BLUE:.*]]
; CHECK:       [[GREEN]]:
; CHECK-NEXT:    br label %[[PURPLE:.*]]
; CHECK:       [[BLUE]]:
; CHECK-NEXT:    br label %[[PURPLE]]
; CHECK:       [[PURPLE]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %a, label %red, label %orange

red:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

orange:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

yellow:
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  br i1 %b, label %green, label %blue

green:
  call void @llvm.objc.release(ptr %x) nounwind
  br label %purple

blue:
  call void @llvm.objc.release(ptr %x) nounwind
  br label %purple

purple:
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test16b(i1 %a, i1 %b, ptr %x) {
; CHECK-LABEL: define void @test16b(
; CHECK-SAME: i1 [[A:%.*]], i1 [[B:%.*]], ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[A]], label %[[RED:.*]], label %[[ORANGE:.*]]
; CHECK:       [[RED]]:
; CHECK-NEXT:    br label %[[YELLOW:.*]]
; CHECK:       [[ORANGE]]:
; CHECK-NEXT:    br label %[[YELLOW]]
; CHECK:       [[YELLOW]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    br i1 [[B]], label %[[GREEN:.*]], label %[[BLUE:.*]]
; CHECK:       [[GREEN]]:
; CHECK-NEXT:    br label %[[PURPLE:.*]]
; CHECK:       [[BLUE]]:
; CHECK-NEXT:    br label %[[PURPLE]]
; CHECK:       [[PURPLE]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %a, label %red, label %orange

red:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

orange:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

yellow:
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  br i1 %b, label %green, label %blue

green:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %purple

blue:
  call void @llvm.objc.release(ptr %x) nounwind
  br label %purple

purple:
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

define void @test16c(i1 %a, i1 %b, ptr %x) {
; CHECK-LABEL: define void @test16c(
; CHECK-SAME: i1 [[A:%.*]], i1 [[B:%.*]], ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[A]], label %[[RED:.*]], label %[[ORANGE:.*]]
; CHECK:       [[RED]]:
; CHECK-NEXT:    br label %[[YELLOW:.*]]
; CHECK:       [[ORANGE]]:
; CHECK-NEXT:    br label %[[YELLOW]]
; CHECK:       [[YELLOW]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    br i1 [[B]], label %[[GREEN:.*]], label %[[BLUE:.*]]
; CHECK:       [[GREEN]]:
; CHECK-NEXT:    br label %[[PURPLE:.*]]
; CHECK:       [[BLUE]]:
; CHECK-NEXT:    br label %[[PURPLE]]
; CHECK:       [[PURPLE]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %a, label %red, label %orange

red:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

orange:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

yellow:
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  br i1 %b, label %green, label %blue

green:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %purple

blue:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %purple

purple:
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}

define void @test16d(i1 %a, i1 %b, ptr %x) {
; CHECK-LABEL: define void @test16d(
; CHECK-SAME: i1 [[A:%.*]], i1 [[B:%.*]], ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[A]], label %[[RED:.*]], label %[[ORANGE:.*]]
; CHECK:       [[RED]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[YELLOW:.*]]
; CHECK:       [[ORANGE]]:
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[YELLOW]]
; CHECK:       [[YELLOW]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    br i1 [[B]], label %[[GREEN:.*]], label %[[BLUE:.*]]
; CHECK:       [[GREEN]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[PURPLE:.*]]
; CHECK:       [[BLUE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    br label %[[PURPLE]]
; CHECK:       [[PURPLE]]:
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br i1 %a, label %red, label %orange

red:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

orange:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  br label %yellow

yellow:
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  br i1 %b, label %green, label %blue

green:
  call void @llvm.objc.release(ptr %x) nounwind
  br label %purple

blue:
  call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  br label %purple

purple:
  ret void
}

; Delete no-ops.

define void @test18() {
; CHECK-LABEL: define void @test18() {
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr null)
  call void @llvm.objc.release(ptr null)
  call ptr @llvm.objc.autorelease(ptr null)
  ret void
}

; Delete no-ops where undef can be assumed to be null.

define void @test18b() {
; CHECK-LABEL: define void @test18b() {
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr undef)
  call void @llvm.objc.release(ptr undef)
  call ptr @llvm.objc.autorelease(ptr undef)
  ret void
}

; Replace uses of arguments with uses of return values, to reduce
; register pressure.

define void @test19(ptr %y) {
; CHECK-LABEL: define void @test19(
; CHECK-SAME: ptr [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[Y]])
; CHECK-NEXT:    call void @use_pointer(ptr [[Y]])
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[Y]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %y) nounwind
  call void @use_pointer(ptr %y)
  call void @use_pointer(ptr %y)
  call void @llvm.objc.release(ptr %y)
  ret void
}

; Bitcast insertion

define void @test20(ptr %self) personality ptr @__gxx_personality_v0 {
; CHECK-LABEL: define void @test20(
; CHECK-SAME: ptr [[SELF:%.*]]) personality ptr @__gxx_personality_v0 {
; CHECK-NEXT:  [[IF_THEN12:.*]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[SELF]]) #[[ATTR0]]
; CHECK-NEXT:    invoke void @invokee()
; CHECK-NEXT:            to label %[[INVOKE_CONT23:.*]] unwind label %[[LPAD20:.*]]
; CHECK:       [[INVOKE_CONT23]]:
; CHECK-NEXT:    invoke void @invokee()
; CHECK-NEXT:            to label %[[IF_END:.*]] unwind label %[[LPAD20]]
; CHECK:       [[LPAD20]]:
; CHECK-NEXT:    [[TMP502:%.*]] = phi ptr [ undef, %[[INVOKE_CONT23]] ], [ [[SELF]], %[[IF_THEN12]] ]
; CHECK-NEXT:    [[EXN:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:            cleanup
; CHECK-NEXT:    unreachable
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    ret void
;
if.then12:
  %tmp1 = call ptr @llvm.objc.retain(ptr %self) nounwind
  invoke void @invokee()
  to label %invoke.cont23 unwind label %lpad20

invoke.cont23:                                    ; preds = %if.then12
  invoke void @invokee()
  to label %if.end unwind label %lpad20

lpad20:                                           ; preds = %invoke.cont23, %if.then12
  %tmp502 = phi ptr [ undef, %invoke.cont23 ], [ %self, %if.then12 ]
  %exn = landingpad {ptr, i32}
  cleanup
  unreachable

if.end:                                           ; preds = %invoke.cont23
  ret void
}

; Delete a redundant retain,autorelease when forwaring a call result
; directly to a return value.

define ptr @test21() {
; CHECK-LABEL: define ptr @test21() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @returner()
; CHECK-NEXT:    ret ptr [[CALL]]
;
entry:
  %call = call ptr @returner()
  %0 = call ptr @llvm.objc.retain(ptr %call) nounwind
  %1 = call ptr @llvm.objc.autorelease(ptr %0) nounwind
  ret ptr %1
}

; Move an objc call up through a phi that has null operands.

define void @test22(ptr %p, i1 %a) {
; CHECK-LABEL: define void @test22(
; CHECK-SAME: ptr [[P:%.*]], i1 [[A:%.*]]) {
; CHECK-NEXT:    br i1 [[A]], label %[[A:.*]], label %[[B:.*]]
; CHECK:       [[A]]:
; CHECK-NEXT:    br label %[[C:.*]]
; CHECK:       [[B]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[C]]
; CHECK:       [[C]]:
; CHECK-NEXT:    ret void
;
  br i1 %a, label %A, label %B
A:
  br label %C
B:
  br label %C
C:
  %h = phi ptr [ null, %A ], [ %p, %B ]
  call void @llvm.objc.release(ptr %h), !clang.imprecise_release !0
  ret void
}

; Do not move an llvm.objc.release that doesn't have the clang.imprecise_release tag.

define void @test22_precise(ptr %p, i1 %a) {
; CHECK-LABEL: define void @test22_precise(
; CHECK-SAME: ptr [[P:%.*]], i1 [[A:%.*]]) {
; CHECK-NEXT:    br i1 [[A]], label %[[A:.*]], label %[[B:.*]]
; CHECK:       [[A]]:
; CHECK-NEXT:    br label %[[C:.*]]
; CHECK:       [[B]]:
; CHECK-NEXT:    br label %[[C]]
; CHECK:       [[C]]:
; CHECK-NEXT:    [[H:%.*]] = phi ptr [ null, %[[A]] ], [ [[P]], %[[B]] ]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[H]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  br i1 %a, label %A, label %B
A:
  br label %C
B:
  br label %C
C:
  %h = phi ptr [ null, %A ], [ %p, %B ]
  call void @llvm.objc.release(ptr %h)
  ret void
}

; Any call can decrement a retain count.

define void @test24(ptr %r, ptr %a) {
; CHECK-LABEL: define void @test24(
; CHECK-SAME: ptr [[R:%.*]], ptr [[A:%.*]]) {
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[A]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[R]])
; CHECK-NEXT:    [[Q:%.*]] = load i8, ptr [[A]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[A]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr %a)
  call void @use_pointer(ptr %r)
  %q = load i8, ptr %a
  call void @llvm.objc.release(ptr %a)
  ret void
}

; Don't move a retain/release pair if the release can be moved
; but the retain can't be moved to balance it.

define void @test25(ptr %p, i1 %x) {
; CHECK-LABEL: define void @test25(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  br i1 %x, label %true, label %done

true:
  store i8 0, ptr %p
  br label %done

done:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Don't move a retain/release pair if the retain can be moved
; but the release can't be moved to balance it.

define void @test26(ptr %p, i1 %x) {
; CHECK-LABEL: define void @test26(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  br label %done

done:
  store i8 0, ptr %p
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Don't sink the retain,release into the loop.

define void @test27(ptr %p, i1 %x, i1 %y) {
; CHECK-LABEL: define void @test27(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[LOOP:.*]], label %[[DONE:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[Y]], label %[[DONE]], label %[[LOOP]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %loop, label %done

loop:
  call void @callee()
  store i8 0, ptr %p
  br i1 %y, label %done, label %loop

done:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Trivial code motion case: Triangle.

define void @test28(ptr %p, i1 %x) {
; CHECK-LABEL: define void @test28(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  store i8 0, ptr %p
  br label %done

done:
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}

; Trivial code motion case: Triangle, but no metadata. Don't move past
; unrelated memory references!

define void @test28b(ptr %p, i1 %x, ptr noalias %t) {
; CHECK-LABEL: define void @test28b(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], ptr noalias [[T:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    store i8 0, ptr [[T]], align 1
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  store i8 0, ptr %p
  br label %done

done:
  store i8 0, ptr %t
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Trivial code motion case: Triangle, with metadata. Do move past
; unrelated memory references! And preserve the metadata.

define void @test28c(ptr %p, i1 %x, ptr noalias %t) {
; CHECK-LABEL: define void @test28c(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], ptr noalias [[T:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    store i8 0, ptr [[T]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  store i8 0, ptr %p
  br label %done

done:
  store i8 0, ptr %t
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}

; Like test28. but with two releases.

define void @test29(ptr %p, i1 %x, i1 %y) {
; CHECK-LABEL: define void @test29(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[Y]], label %[[DONE]], label %[[OHNO:.*]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
; CHECK:       [[OHNO]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  store i8 0, ptr %p
  br i1 %y, label %done, label %ohno

done:
  call void @llvm.objc.release(ptr %p)
  ret void

ohno:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Basic case with the use and call in a diamond
; with an extra release.

define void @test30(ptr %p, i1 %x, i1 %y, i1 %z) {
; CHECK-LABEL: define void @test30(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], i1 [[Y:%.*]], i1 [[Z:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[Y]], label %[[DONE:.*]], label %[[OHNO:.*]]
; CHECK:       [[FALSE]]:
; CHECK-NEXT:    br i1 [[Z]], label %[[DONE]], label %[[OHNO]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
; CHECK:       [[OHNO]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %false

true:
  call void @callee()
  store i8 0, ptr %p
  br i1 %y, label %done, label %ohno

false:
  br i1 %z, label %done, label %ohno

done:
  call void @llvm.objc.release(ptr %p)
  ret void

ohno:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Basic case with a mergeable release.

define void @test31(ptr %p, i1 %x) {
; CHECK-LABEL: define void @test31(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
; CHECK:       [[FALSE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  store i8 0, ptr %p
  br i1 %x, label %true, label %false
true:
  call void @llvm.objc.release(ptr %p)
  ret void
false:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Don't consider bitcasts or getelementptrs direct uses.

define void @test32(ptr %p, i1 %x) {
; CHECK-LABEL: define void @test32(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  store i8 0, ptr %p
  br label %done

done:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Do consider icmps to be direct uses.

define void @test33(ptr %p, i1 %x, ptr %y) {
; CHECK-LABEL: define void @test33(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], ptr [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    [[V:%.*]] = icmp eq ptr [[P]], [[Y]]
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  %v = icmp eq ptr %p, %y
  br label %done

done:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Delete retain,release if there's just a possible dec and we have imprecise
; releases.

define void @test34a(ptr %p, i1 %x, ptr %y) {
; CHECK-LABEL: define void @test34a(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], ptr [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  br label %done

done:
  call void @llvm.objc.release(ptr %p)
  ret void
}

define void @test34b(ptr %p, i1 %x, ptr %y) {
; CHECK-LABEL: define void @test34b(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], ptr [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  call void @callee()
  br label %done

done:
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}


; Delete retain,release if there's just a use and we do not have a precise
; release.

; Precise.
define void @test35a(ptr %p, i1 %x, ptr %y) {
; CHECK-LABEL: define void @test35a(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], ptr [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[F0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    [[V:%.*]] = icmp eq ptr [[P]], [[Y]]
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  %v = icmp eq ptr %p, %y
  br label %done

done:
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Imprecise.
define void @test35b(ptr %p, i1 %x, ptr %y) {
; CHECK-LABEL: define void @test35b(
; CHECK-SAME: ptr [[P:%.*]], i1 [[X:%.*]], ptr [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[X]], label %[[TRUE:.*]], label %[[DONE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    [[V:%.*]] = icmp eq ptr [[P]], [[Y]]
; CHECK-NEXT:    br label %[[DONE]]
; CHECK:       [[DONE]]:
; CHECK-NEXT:    ret void
;
entry:
  %f0 = call ptr @llvm.objc.retain(ptr %p)
  br i1 %x, label %true, label %done

true:
  %v = icmp eq ptr %p, %y
  br label %done

done:
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}

; Delete a retain,release if there's no actual use and we have precise release.

define void @test36a(ptr %p) {
; CHECK-LABEL: define void @test36a(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  call void @callee()
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Like test36, but with metadata.

define void @test36b(ptr %p) {
; CHECK-LABEL: define void @test36b(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  call void @callee()
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}

; Be aggressive about analyzing phis to eliminate possible uses.

define void @test38(ptr %p, i1 %u, i1 %m, ptr %z, ptr %y, ptr %x, ptr %w) {
; CHECK-LABEL: define void @test38(
; CHECK-SAME: ptr [[P:%.*]], i1 [[U:%.*]], i1 [[M:%.*]], ptr [[Z:%.*]], ptr [[Y:%.*]], ptr [[X:%.*]], ptr [[W:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[U]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    br i1 [[M]], label %[[A:.*]], label %[[B:.*]]
; CHECK:       [[FALSE]]:
; CHECK-NEXT:    br i1 [[M]], label %[[C:.*]], label %[[D:.*]]
; CHECK:       [[A]]:
; CHECK-NEXT:    br label %[[E:.*]]
; CHECK:       [[B]]:
; CHECK-NEXT:    br label %[[E]]
; CHECK:       [[C]]:
; CHECK-NEXT:    br label %[[F:.*]]
; CHECK:       [[D]]:
; CHECK-NEXT:    br label %[[F]]
; CHECK:       [[E]]:
; CHECK-NEXT:    [[J:%.*]] = phi ptr [ [[Z]], %[[A]] ], [ [[Y]], %[[B]] ]
; CHECK-NEXT:    br label %[[G:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    [[K:%.*]] = phi ptr [ [[W]], %[[C]] ], [ [[X]], %[[D]] ]
; CHECK-NEXT:    br label %[[G]]
; CHECK:       [[G]]:
; CHECK-NEXT:    [[H:%.*]] = phi ptr [ [[J]], %[[E]] ], [ [[K]], %[[F]] ]
; CHECK-NEXT:    call void @use_pointer(ptr [[H]])
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %p)
  br i1 %u, label %true, label %false
true:
  br i1 %m, label %a, label %b
false:
  br i1 %m, label %c, label %d
a:
  br label %e
b:
  br label %e
c:
  br label %f
d:
  br label %f
e:
  %j = phi ptr [ %z, %a ], [ %y, %b ]
  br label %g
f:
  %k = phi ptr [ %w, %c ], [ %x, %d ]
  br label %g
g:
  %h = phi ptr [ %j, %e ], [ %k, %f ]
  call void @use_pointer(ptr %h)
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}

; Delete retain,release pairs around loops.

define void @test39(ptr %p, i1 %arg) {
; CHECK-LABEL: define void @test39(
; CHECK-SAME: ptr [[P:%.*]], i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    br i1 [[ARG]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %p)
  br label %loop

loop:                                             ; preds = %loop, %entry
  br i1 %arg, label %loop, label %exit

exit:                                             ; preds = %loop
  call void @llvm.objc.release(ptr %0), !clang.imprecise_release !0
  ret void
}

; Delete retain,release pairs around loops containing uses.

define void @test39b(ptr %p, i1 %arg) {
; CHECK-LABEL: define void @test39b(
; CHECK-SAME: ptr [[P:%.*]], i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[ARG]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %p)
  br label %loop

loop:                                             ; preds = %loop, %entry
  store i8 0, ptr %0
  br i1 %arg, label %loop, label %exit

exit:                                             ; preds = %loop
  call void @llvm.objc.release(ptr %0), !clang.imprecise_release !0
  ret void
}

; Delete retain,release pairs around loops containing potential decrements.

define void @test39c(ptr %p, i1 %arg) {
; CHECK-LABEL: define void @test39c(
; CHECK-SAME: ptr [[P:%.*]], i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    br i1 [[ARG]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %p)
  br label %loop

loop:                                             ; preds = %loop, %entry
  call void @use_pointer(ptr %0)
  br i1 %arg, label %loop, label %exit

exit:                                             ; preds = %loop
  call void @llvm.objc.release(ptr %0), !clang.imprecise_release !0
  ret void
}

; Delete retain,release pairs around loops even if
; the successors are in a different order.

define void @test40(ptr %p, i1 %arg) {
; CHECK-LABEL: define void @test40(
; CHECK-SAME: ptr [[P:%.*]], i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    br i1 [[ARG]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %p)
  br label %loop

loop:                                             ; preds = %loop, %entry
  call void @use_pointer(ptr %0)
  br i1 %arg, label %exit, label %loop

exit:                                             ; preds = %loop
  call void @llvm.objc.release(ptr %0), !clang.imprecise_release !0
  ret void
}

; Do the known-incremented retain+release elimination even if the pointer
; is also autoreleased.

define void @test42(ptr %p) {
; CHECK-LABEL: define void @test42(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %p)
  call ptr @llvm.objc.autorelease(ptr %p)
  call ptr @llvm.objc.retain(ptr %p)
  call void @use_pointer(ptr %p)
  call void @use_pointer(ptr %p)
  call void @llvm.objc.release(ptr %p)
  call void @use_pointer(ptr %p)
  call void @use_pointer(ptr %p)
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Don't the known-incremented retain+release elimination if the pointer is
; autoreleased and there's an autoreleasePoolPop.

define void @test43(ptr %p) {
; CHECK-LABEL: define void @test43(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @llvm.objc.autoreleasePoolPop(ptr undef) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %p)
  call ptr @llvm.objc.autorelease(ptr %p)
  call ptr @llvm.objc.retain(ptr %p)
  call void @use_pointer(ptr %p)
  call void @use_pointer(ptr %p)
  call void @llvm.objc.autoreleasePoolPop(ptr undef)
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Do the known-incremented retain+release elimination if the pointer is
; autoreleased and there's an autoreleasePoolPush.

define void @test43b(ptr %p) {
; CHECK-LABEL: define void @test43b(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    [[TMP2:%.*]] = call ptr @llvm.objc.autoreleasePoolPush() #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %p)
  call ptr @llvm.objc.autorelease(ptr %p)
  call ptr @llvm.objc.retain(ptr %p)
  call void @use_pointer(ptr %p)
  call void @use_pointer(ptr %p)
  call ptr @llvm.objc.autoreleasePoolPush()
  call void @llvm.objc.release(ptr %p)
  call void @use_pointer(ptr %p)
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Do retain+release elimination for non-provenance pointers.

define void @test44(ptr %pp) {
; CHECK-LABEL: define void @test44(
; CHECK-SAME: ptr [[PP:%.*]]) {
; CHECK-NEXT:    ret void
;
  %p = load ptr, ptr %pp
  %q = call ptr @llvm.objc.retain(ptr %p)
  call void @llvm.objc.release(ptr %q)
  ret void
}

; Don't delete retain+release with an unknown-provenance
; may-alias llvm.objc.release between them.

define void @test45(ptr %pp, ptr %qq) {
; CHECK-LABEL: define void @test45(
; CHECK-SAME: ptr [[PP:%.*]], ptr [[QQ:%.*]]) {
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[PP]], align 8
; CHECK-NEXT:    [[Q:%.*]] = load ptr, ptr [[QQ]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Q]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  %p = load ptr, ptr %pp
  %q = load ptr, ptr %qq
  call ptr @llvm.objc.retain(ptr %p)
  call void @llvm.objc.release(ptr %q)
  call void @use_pointer(ptr %p)
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Don't delete retain and autorelease here.

define void @test46(ptr %p, i1 %a) {
; CHECK-LABEL: define void @test46(
; CHECK-SAME: ptr [[P:%.*]], i1 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    br i1 [[A]], label %[[TRUE:.*]], label %[[FALSE:.*]]
; CHECK:       [[TRUE]]:
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[P]])
; CHECK-NEXT:    ret void
; CHECK:       [[FALSE]]:
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %p)
  br i1 %a, label %true, label %false

true:
  call ptr @llvm.objc.autorelease(ptr %p)
  call void @use_pointer(ptr %p)
  ret void

false:
  ret void
}

; Delete no-op cast calls.

define ptr @test47(ptr %p) nounwind {
; CHECK-LABEL: define ptr @test47(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    ret ptr [[P]]
;
  %x = call ptr @llvm.objc.retainedObject(ptr %p)
  ret ptr %x
}

; Delete no-op cast calls.

define ptr @test48(ptr %p) nounwind {
; CHECK-LABEL: define ptr @test48(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    ret ptr [[P]]
;
  %x = call ptr @llvm.objc.unretainedObject(ptr %p)
  ret ptr %x
}

; Delete no-op cast calls.

define ptr @test49(ptr %p) nounwind {
; CHECK-LABEL: define ptr @test49(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    ret ptr [[P]]
;
  %x = call ptr @llvm.objc.unretainedPointer(ptr %p)
  ret ptr %x
}

; Do delete retain+release with intervening stores of the address value if we
; have imprecise release attached to llvm.objc.release.

define void @test50a(ptr %p, ptr %pp) {
; CHECK-LABEL: define void @test50a(
; CHECK-SAME: ptr [[P:%.*]], ptr [[PP:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store ptr [[P]], ptr [[PP]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  store ptr %p, ptr %pp
  call void @llvm.objc.release(ptr %p)
  ret void
}

define void @test50b(ptr %p, ptr %pp) {
; CHECK-LABEL: define void @test50b(
; CHECK-SAME: ptr [[P:%.*]], ptr [[PP:%.*]]) {
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store ptr [[P]], ptr [[PP]], align 8
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  store ptr %p, ptr %pp
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}


; Don't delete retain+release with intervening stores through the
; address value.

define void @test51a(ptr %p) {
; CHECK-LABEL: define void @test51a(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  store i8 0, ptr %p
  call void @llvm.objc.release(ptr %p)
  ret void
}

define void @test51b(ptr %p) {
; CHECK-LABEL: define void @test51b(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    store i8 0, ptr [[P]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  store i8 0, ptr %p
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}

; Don't delete retain+release with intervening use of a pointer of
; unknown provenance.

define void @test52a(ptr %zz, ptr %pp) {
; CHECK-LABEL: define void @test52a(
; CHECK-SAME: ptr [[ZZ:%.*]], ptr [[PP:%.*]]) {
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[PP]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    [[Z:%.*]] = load ptr, ptr [[ZZ]], align 8
; CHECK-NEXT:    call void @use_pointer(ptr [[Z]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  %p = load ptr, ptr %pp
  %1 = call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  %z = load ptr, ptr %zz
  call void @use_pointer(ptr %z)
  call void @llvm.objc.release(ptr %p)
  ret void
}

define void @test52b(ptr %zz, ptr %pp) {
; CHECK-LABEL: define void @test52b(
; CHECK-SAME: ptr [[ZZ:%.*]], ptr [[PP:%.*]]) {
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[PP]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    [[Z:%.*]] = load ptr, ptr [[ZZ]], align 8
; CHECK-NEXT:    call void @use_pointer(ptr [[Z]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  %p = load ptr, ptr %pp
  %1 = call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  %z = load ptr, ptr %zz
  call void @use_pointer(ptr %z)
  call void @llvm.objc.release(ptr %p), !clang.imprecise_release !0
  ret void
}

; Like test52, but the pointer has function type, so it's assumed to
; be not reference counted.
; Oops. That's wrong. Clang sometimes uses function types gratuitously.
; See rdar://10551239.

define void @test53(ptr %zz, ptr %pp) {
; CHECK-LABEL: define void @test53(
; CHECK-SAME: ptr [[ZZ:%.*]], ptr [[PP:%.*]]) {
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[PP]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    [[Z:%.*]] = load ptr, ptr [[ZZ]], align 8
; CHECK-NEXT:    call void @callee_fnptr(ptr [[Z]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[P]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  %p = load ptr, ptr %pp
  %1 = call ptr @llvm.objc.retain(ptr %p)
  call void @callee()
  %z = load ptr, ptr %zz
  call void @callee_fnptr(ptr %z)
  call void @llvm.objc.release(ptr %p)
  ret void
}

; Convert autorelease to release if the value is unused.

define void @test54() {
; CHECK-LABEL: define void @test54() {
; CHECK-NEXT:    [[T:%.*]] = call ptr @returner()
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[T]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    ret void
;
  %t = call ptr @returner()
  call ptr @llvm.objc.autorelease(ptr %t)
  ret void
}

; Nested retain+release pairs. Delete them both.

define void @test55(ptr %x) {
; CHECK-LABEL: define void @test55(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = call ptr @llvm.objc.retain(ptr %x) nounwind
  %1 = call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Nested retain+release pairs where the inner pair depends
; on the outer pair to be removed, and then the outer pair
; can be partially eliminated. Plus an extra outer pair to
; eliminate, for fun.

define void @test56(ptr %x, i32 %n) {
; CHECK-LABEL: define void @test56(
; CHECK-SAME: ptr [[X:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[N]], 0
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[IF_END:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    tail call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    tail call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    ret void
;
entry:
  %0 = tail call ptr @llvm.objc.retain(ptr %x) nounwind
  %1 = tail call ptr @llvm.objc.retain(ptr %0) nounwind
  %tobool = icmp eq i32 %n, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = tail call ptr @llvm.objc.retain(ptr %1) nounwind
  tail call void @use_pointer(ptr %2)
  tail call void @use_pointer(ptr %2)
  tail call void @llvm.objc.release(ptr %2) nounwind, !clang.imprecise_release !0
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  tail call void @llvm.objc.release(ptr %1) nounwind, !clang.imprecise_release !0
  tail call void @llvm.objc.release(ptr %0) nounwind, !clang.imprecise_release !0
  ret void
}

; When there are adjacent retain+release pairs, the first one is known
; unnecessary because the presence of the second one means that the first one
; won't be deleting the object.

define void @test57(ptr %x) nounwind {
; CHECK-LABEL: define void @test57(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; An adjacent retain+release pair is sufficient even if it will be
; removed itself.

define void @test58(ptr %x) nounwind {
; CHECK-LABEL: define void @test58(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    ret void
;
entry:
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Don't delete the second retain+release pair in an adjacent set.

define void @test59(ptr %x) nounwind {
; CHECK-LABEL: define void @test59(
; CHECK-SAME: ptr [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %a = call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @llvm.objc.release(ptr %x) nounwind
  %b = call ptr @llvm.objc.retain(ptr %x) nounwind
  call void @use_pointer(ptr %x)
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x) nounwind
  ret void
}

; Constant pointers to objects don't need reference counting.

@constptr = external constant ptr
@something = external global ptr

; We have a precise lifetime retain/release here. We can not remove them since
; @something is not constant.

define void @test60a() {
; CHECK-LABEL: define void @test60a() {
; CHECK-NEXT:    [[T:%.*]] = load ptr, ptr @constptr, align 8
; CHECK-NEXT:    [[S:%.*]] = load ptr, ptr @something, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[S]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(ptr [[T]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[S]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
  %t = load ptr, ptr @constptr
  %s = load ptr, ptr @something
  call ptr @llvm.objc.retain(ptr %s)
  call void @callee()
  call void @use_pointer(ptr %t)
  call void @llvm.objc.release(ptr %s)
  ret void
}

define void @test60b() {
; CHECK-LABEL: define void @test60b() {
; CHECK-NEXT:    [[T:%.*]] = load ptr, ptr @constptr, align 8
; CHECK-NEXT:    [[S:%.*]] = load ptr, ptr @something, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[T]]) #[[ATTR0]]
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(ptr [[S]])
; CHECK-NEXT:    ret void
;
  %t = load ptr, ptr @constptr
  %s = load ptr, ptr @something
  call ptr @llvm.objc.retain(ptr %t)
  call ptr @llvm.objc.retain(ptr %t)
  call void @callee()
  call void @use_pointer(ptr %s)
  call void @llvm.objc.release(ptr %t)
  ret void
}

define void @test60c() {
; CHECK-LABEL: define void @test60c() {
; CHECK-NEXT:    [[S:%.*]] = load ptr, ptr @something, align 8
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(ptr [[S]])
; CHECK-NEXT:    ret void
;
  %t = load ptr, ptr @constptr
  %s = load ptr, ptr @something
  call ptr @llvm.objc.retain(ptr %t)
  call void @callee()
  call void @use_pointer(ptr %s)
  call void @llvm.objc.release(ptr %t), !clang.imprecise_release !0
  ret void
}

define void @test60d() {
; CHECK-LABEL: define void @test60d() {
; CHECK-NEXT:    [[S:%.*]] = load ptr, ptr @something, align 8
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(ptr [[S]])
; CHECK-NEXT:    ret void
;
  %t = load ptr, ptr @constptr
  %s = load ptr, ptr @something
  call ptr @llvm.objc.retain(ptr %t)
  call void @callee()
  call void @use_pointer(ptr %s)
  call void @llvm.objc.release(ptr %t)
  ret void
}

define void @test60e() {
; CHECK-LABEL: define void @test60e() {
; CHECK-NEXT:    [[S:%.*]] = load ptr, ptr @something, align 8
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(ptr [[S]])
; CHECK-NEXT:    ret void
;
  %t = load ptr, ptr @constptr
  %s = load ptr, ptr @something
  call ptr @llvm.objc.retain(ptr %t)
  call void @callee()
  call void @use_pointer(ptr %s)
  call void @llvm.objc.release(ptr %t), !clang.imprecise_release !0
  ret void
}

; Constant pointers to objects don't need to be considered related to other
; pointers.

define void @test61() {
; CHECK-LABEL: define void @test61() {
; CHECK-NEXT:    [[T:%.*]] = load ptr, ptr @constptr, align 8
; CHECK-NEXT:    call void @callee()
; CHECK-NEXT:    call void @use_pointer(ptr [[T]])
; CHECK-NEXT:    ret void
;
  %t = load ptr, ptr @constptr
  call ptr @llvm.objc.retain(ptr %t)
  call void @callee()
  call void @use_pointer(ptr %t)
  call void @llvm.objc.release(ptr %t)
  ret void
}

; Delete a retain matched by releases when one is inside the loop and the
; other is outside the loop.

define void @test62(ptr %x, ptr %p) nounwind {
; CHECK-LABEL: define void @test62(
; CHECK-SAME: ptr [[X:%.*]], ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[Q:%.*]] = load i1, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[Q]], label %[[LOOP_MORE:.*]], label %[[EXIT:.*]]
; CHECK:       [[LOOP_MORE]]:
; CHECK-NEXT:    br label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  call ptr @llvm.objc.retain(ptr %x)
  %q = load i1, ptr %p
  br i1 %q, label %loop.more, label %exit

loop.more:
  call void @llvm.objc.release(ptr %x)
  br label %loop

exit:
  call void @llvm.objc.release(ptr %x)
  ret void
}

; Like test62 but with no release in exit.
; Don't delete anything!

define void @test63(ptr %x, ptr %p) nounwind {
; CHECK-LABEL: define void @test63(
; CHECK-SAME: ptr [[X:%.*]], ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[Q:%.*]] = load i1, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[Q]], label %[[LOOP_MORE:.*]], label %[[EXIT:.*]]
; CHECK:       [[LOOP_MORE]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  call ptr @llvm.objc.retain(ptr %x)
  %q = load i1, ptr %p
  br i1 %q, label %loop.more, label %exit

loop.more:
  call void @llvm.objc.release(ptr %x)
  br label %loop

exit:
  ret void
}

; Like test62 but with no release in loop.more.
; Don't delete anything!

define void @test64(ptr %x, ptr %p) nounwind {
; CHECK-LABEL: define void @test64(
; CHECK-SAME: ptr [[X:%.*]], ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[Q:%.*]] = load i1, ptr [[P]], align 1
; CHECK-NEXT:    br i1 [[Q]], label %[[LOOP_MORE:.*]], label %[[EXIT:.*]]
; CHECK:       [[LOOP_MORE]]:
; CHECK-NEXT:    br label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  call ptr @llvm.objc.retain(ptr %x)
  %q = load i1, ptr %p
  br i1 %q, label %loop.more, label %exit

loop.more:
  br label %loop

exit:
  call void @llvm.objc.release(ptr %x)
  ret void
}

; Move an autorelease past a phi with a null.

define ptr @test65(i1 %x) {
; CHECK-LABEL: define ptr @test65(
; CHECK-SAME: i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[X]], label %[[RETURN:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[C:%.*]] = call ptr @returner()
; CHECK-NEXT:    [[S:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[C]]) #[[ATTR0]]
; CHECK-NEXT:    [[Q1:%.*]] = call ptr @llvm.objc.autorelease(ptr [[S]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[S]], %[[IF_THEN]] ], [ null, %[[ENTRY]] ]
; CHECK-NEXT:    ret ptr [[RETVAL]]
;
entry:
  br i1 %x, label %return, label %if.then

if.then:                                          ; preds = %entry
  %c = call ptr @returner()
  %s = call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %c) nounwind
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval = phi ptr [ %s, %if.then ], [ null, %entry ]
  %q = call ptr @llvm.objc.autorelease(ptr %retval) nounwind
  ret ptr %retval
}

; Don't move an autorelease past an autorelease pool boundary.

define ptr @test65b(i1 %x) {
; CHECK-LABEL: define ptr @test65b(
; CHECK-SAME: i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[T:%.*]] = call ptr @llvm.objc.autoreleasePoolPush() #[[ATTR0]]
; CHECK-NEXT:    br i1 [[X]], label %[[RETURN:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[C:%.*]] = call ptr @returner()
; CHECK-NEXT:    [[S:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[C]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[S]], %[[IF_THEN]] ], [ null, %[[ENTRY]] ]
; CHECK-NEXT:    call void @llvm.objc.autoreleasePoolPop(ptr [[T]]) #[[ATTR0]]
; CHECK-NEXT:    [[Q:%.*]] = call ptr @llvm.objc.autorelease(ptr [[RETVAL]]) #[[ATTR0]]
; CHECK-NEXT:    ret ptr [[RETVAL]]
;
entry:
  %t = call ptr @llvm.objc.autoreleasePoolPush()
  br i1 %x, label %return, label %if.then

if.then:                                          ; preds = %entry
  %c = call ptr @returner()
  %s = call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %c) nounwind
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval = phi ptr [ %s, %if.then ], [ null, %entry ]
  call void @llvm.objc.autoreleasePoolPop(ptr %t)
  %q = call ptr @llvm.objc.autorelease(ptr %retval) nounwind
  ret ptr %retval
}

; Don't move an autoreleaseReuturnValue, which would break
; the RV optimization.

define ptr @test65c(i1 %x) {
; CHECK-LABEL: define ptr @test65c(
; CHECK-SAME: i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[X]], label %[[RETURN:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[C:%.*]] = call ptr @returner()
; CHECK-NEXT:    [[S:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[C]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[S]], %[[IF_THEN]] ], [ null, %[[ENTRY]] ]
; CHECK-NEXT:    [[Q:%.*]] = tail call ptr @llvm.objc.autoreleaseReturnValue(ptr [[RETVAL]]) #[[ATTR0]]
; CHECK-NEXT:    ret ptr [[RETVAL]]
;
entry:
  br i1 %x, label %return, label %if.then

if.then:                                          ; preds = %entry
  %c = call ptr @returner()
  %s = call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %c) nounwind
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval = phi ptr [ %s, %if.then ], [ null, %entry ]
  %q = call ptr @llvm.objc.autoreleaseReturnValue(ptr %retval) nounwind
  ret ptr %retval
}

define ptr @test65d(i1 %x) {
; CHECK-LABEL: define ptr @test65d(
; CHECK-SAME: i1 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[X]], label %[[RETURN:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[C:%.*]] = call ptr @returner()
; CHECK-NEXT:    [[S:%.*]] = tail call ptr @llvm.objc.unsafeClaimAutoreleasedReturnValue(ptr [[C]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi ptr [ [[S]], %[[IF_THEN]] ], [ null, %[[ENTRY]] ]
; CHECK-NEXT:    [[Q:%.*]] = tail call ptr @llvm.objc.autoreleaseReturnValue(ptr [[RETVAL]]) #[[ATTR0]]
; CHECK-NEXT:    ret ptr [[RETVAL]]
;
entry:
  br i1 %x, label %return, label %if.then

if.then:                                          ; preds = %entry
  %c = call ptr @returner()
  %s = call ptr @llvm.objc.unsafeClaimAutoreleasedReturnValue(ptr %c) nounwind
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval = phi ptr [ %s, %if.then ], [ null, %entry ]
  %q = call ptr @llvm.objc.autoreleaseReturnValue(ptr %retval) nounwind
  ret ptr %retval
}

; An llvm.objc.retain can serve as a may-use for a different pointer.
; rdar://11931823

define void @test66a(ptr %tmp5, ptr %bar, i1 %tobool, i1 %tobool1, ptr %call) {
; CHECK-LABEL: define void @test66a(
; CHECK-SAME: ptr [[TMP5:%.*]], ptr [[BAR:%.*]], i1 [[TOBOOL:%.*]], i1 [[TOBOOL1:%.*]], ptr [[CALL:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    br label %[[COND_END]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    [[COND:%.*]] = phi ptr [ [[TMP5]], %[[COND_TRUE]] ], [ [[CALL]], %[[ENTRY]] ]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[COND]]) #[[ATTR0]]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[CALL]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TOBOOL1]], ptr [[COND]], ptr [[BAR]]
; CHECK-NEXT:    [[TMP9:%.*]] = tail call ptr @llvm.objc.retain(ptr [[TMP8]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[COND]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi ptr [ %tmp5, %cond.true ], [ %call, %entry ]
  %tmp7 = tail call ptr @llvm.objc.retain(ptr %cond) nounwind
  tail call void @llvm.objc.release(ptr %call) nounwind
  %tmp8 = select i1 %tobool1, ptr %cond, ptr %bar
  %tmp9 = tail call ptr @llvm.objc.retain(ptr %tmp8) nounwind
  tail call void @llvm.objc.release(ptr %cond) nounwind
  ret void
}

define void @test66b(ptr %tmp5, ptr %bar, i1 %tobool, i1 %tobool1, ptr %call) {
; CHECK-LABEL: define void @test66b(
; CHECK-SAME: ptr [[TMP5:%.*]], ptr [[BAR:%.*]], i1 [[TOBOOL:%.*]], i1 [[TOBOOL1:%.*]], ptr [[CALL:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    br label %[[COND_END]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    [[COND:%.*]] = phi ptr [ [[TMP5]], %[[COND_TRUE]] ], [ [[CALL]], %[[ENTRY]] ]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[COND]]) #[[ATTR0]]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[CALL]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TOBOOL1]], ptr [[COND]], ptr [[BAR]]
; CHECK-NEXT:    [[TMP9:%.*]] = tail call ptr @llvm.objc.retain(ptr [[TMP8]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[COND]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi ptr [ %tmp5, %cond.true ], [ %call, %entry ]
  %tmp7 = tail call ptr @llvm.objc.retain(ptr %cond) nounwind
  tail call void @llvm.objc.release(ptr %call) nounwind, !clang.imprecise_release !0
  %tmp8 = select i1 %tobool1, ptr %cond, ptr %bar
  %tmp9 = tail call ptr @llvm.objc.retain(ptr %tmp8) nounwind
  tail call void @llvm.objc.release(ptr %cond) nounwind
  ret void
}

define void @test66c(ptr %tmp5, ptr %bar, i1 %tobool, i1 %tobool1, ptr %call) {
; CHECK-LABEL: define void @test66c(
; CHECK-SAME: ptr [[TMP5:%.*]], ptr [[BAR:%.*]], i1 [[TOBOOL:%.*]], i1 [[TOBOOL1:%.*]], ptr [[CALL:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    br label %[[COND_END]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    [[COND:%.*]] = phi ptr [ [[TMP5]], %[[COND_TRUE]] ], [ [[CALL]], %[[ENTRY]] ]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[COND]]) #[[ATTR0]]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[CALL]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TOBOOL1]], ptr [[COND]], ptr [[BAR]]
; CHECK-NEXT:    [[TMP9:%.*]] = tail call ptr @llvm.objc.retain(ptr [[TMP8]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[COND]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi ptr [ %tmp5, %cond.true ], [ %call, %entry ]
  %tmp7 = tail call ptr @llvm.objc.retain(ptr %cond) nounwind
  tail call void @llvm.objc.release(ptr %call) nounwind
  %tmp8 = select i1 %tobool1, ptr %cond, ptr %bar
  %tmp9 = tail call ptr @llvm.objc.retain(ptr %tmp8) nounwind, !clang.imprecise_release !0
  tail call void @llvm.objc.release(ptr %cond) nounwind
  ret void
}

define void @test66d(ptr %tmp5, ptr %bar, i1 %tobool, i1 %tobool1, ptr %call) {
; CHECK-LABEL: define void @test66d(
; CHECK-SAME: ptr [[TMP5:%.*]], ptr [[BAR:%.*]], i1 [[TOBOOL:%.*]], i1 [[TOBOOL1:%.*]], ptr [[CALL:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[COND_TRUE:.*]], label %[[COND_END:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    br label %[[COND_END]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    [[COND:%.*]] = phi ptr [ [[TMP5]], %[[COND_TRUE]] ], [ [[CALL]], %[[ENTRY]] ]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[COND]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[CALL]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TOBOOL1]], ptr [[COND]], ptr [[BAR]]
; CHECK-NEXT:    [[TMP9:%.*]] = tail call ptr @llvm.objc.retain(ptr [[TMP8]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[COND]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi ptr [ %tmp5, %cond.true ], [ %call, %entry ]
  %tmp7 = tail call ptr @llvm.objc.retain(ptr %cond) nounwind
  tail call void @llvm.objc.release(ptr %call) nounwind, !clang.imprecise_release !0
  %tmp8 = select i1 %tobool1, ptr %cond, ptr %bar
  %tmp9 = tail call ptr @llvm.objc.retain(ptr %tmp8) nounwind
  tail call void @llvm.objc.release(ptr %cond) nounwind, !clang.imprecise_release !0
  ret void
}

; A few real-world testcases.

@.str4 = private unnamed_addr constant [33 x i8] c"-[A z] = { %f, %f, { %f, %f } }\0A\00"
@"OBJC_IVAR_$_A.myZ" = global i64 20, section "__DATA, __objc_const", align 8
declare i32 @printf(ptr captures(none), ...) nounwind
declare i32 @puts(ptr captures(none)) nounwind
@str = internal constant [16 x i8] c"-[ Top0 _getX ]\00"

; FIXME: Should be able to eliminate the retain and release
define { <2 x float>, <2 x float> } @"\01-[A z]"(ptr %self, ptr captures(none) %_cmd) nounwind {
invoke.cont:
  %i1 = tail call ptr @llvm.objc.retain(ptr %self) nounwind
  tail call void @llvm.dbg.value(metadata ptr %self, metadata !DILocalVariable(scope: !2), metadata !DIExpression()), !dbg !DILocation(scope: !2)
  tail call void @llvm.dbg.value(metadata ptr %self, metadata !DILocalVariable(scope: !2), metadata !DIExpression()), !dbg !DILocation(scope: !2)
  %ivar = load i64, ptr @"OBJC_IVAR_$_A.myZ", align 8
  %add.ptr = getelementptr i8, ptr %self, i64 %ivar
  %tmp2 = load float, ptr %add.ptr, align 4
  %conv = fpext float %tmp2 to double
  %add.ptr.sum = add i64 %ivar, 4
  %tmp6 = getelementptr inbounds i8, ptr %self, i64 %add.ptr.sum
  %tmp7 = load float, ptr %tmp6, align 4
  %conv8 = fpext float %tmp7 to double
  %add.ptr.sum36 = add i64 %ivar, 8
  %tmp12 = getelementptr inbounds i8, ptr %self, i64 %add.ptr.sum36
  %tmp13 = load float, ptr %tmp12, align 4
  %conv14 = fpext float %tmp13 to double
  %tmp12.sum = add i64 %ivar, 12
  %arrayidx19 = getelementptr inbounds i8, ptr %self, i64 %tmp12.sum
  %tmp20 = load float, ptr %arrayidx19, align 4
  %conv21 = fpext float %tmp20 to double
  %call = tail call i32 (ptr, ...) @printf(ptr @.str4, double %conv, double %conv8, double %conv14, double %conv21)
  %ivar23 = load i64, ptr @"OBJC_IVAR_$_A.myZ", align 8
  %add.ptr24 = getelementptr i8, ptr %self, i64 %ivar23
  %srcval = load i128, ptr %add.ptr24, align 4
  tail call void @llvm.objc.release(ptr %self) nounwind
  %tmp29 = trunc i128 %srcval to i64
  %tmp30 = bitcast i64 %tmp29 to <2 x float>
  %tmp31 = insertvalue { <2 x float>, <2 x float> } undef, <2 x float> %tmp30, 0
  %tmp32 = lshr i128 %srcval, 64
  %tmp33 = trunc i128 %tmp32 to i64
  %tmp34 = bitcast i64 %tmp33 to <2 x float>
  %tmp35 = insertvalue { <2 x float>, <2 x float> } %tmp31, <2 x float> %tmp34, 1
  ret { <2 x float>, <2 x float> } %tmp35
}

; FIXME: Should be able to eliminate the retain and release
define i32 @"\01-[Top0 _getX]"(ptr %self, ptr captures(none) %_cmd) nounwind {
invoke.cont:
  %i1 = tail call ptr @llvm.objc.retain(ptr %self) nounwind
  %puts = tail call i32 @puts(ptr @str)
  tail call void @llvm.objc.release(ptr %self) nounwind
  ret i32 0
}

@"\01L_OBJC_METH_VAR_NAME_" = internal global [5 x i8] c"frob\00", section "__TEXT,__cstring,cstring_literals", align 1@"\01L_OBJC_SELECTOR_REFERENCES_" = internal global ptr @"\01L_OBJC_METH_VAR_NAME_", section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_IMAGE_INFO" = internal constant [2 x i32] [i32 0, i32 16], section "__DATA, __objc_imageinfo, regular, no_dead_strip"
@llvm.used = appending global [3 x ptr] [ptr @"\01L_OBJC_METH_VAR_NAME_", ptr @"\01L_OBJC_SELECTOR_REFERENCES_", ptr @"\01L_OBJC_IMAGE_INFO"], section "llvm.metadata"

; A simple loop. Eliminate the retain and release inside of it!

define void @loop(ptr %x, i64 %n) {
; CHECK-LABEL: define void @loop(
; CHECK-SAME: ptr [[X:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    [[CMP9:%.*]] = icmp sgt i64 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP9]], label %[[FOR_BODY:.*]], label %[[FOR_END:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_010:%.*]] = phi i64 [ [[INC:%.*]], %[[FOR_BODY]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_", align 8
; CHECK-NEXT:    [[CALL:%.*]] = tail call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[X]], ptr [[TMP5]])
; CHECK-NEXT:    [[INC]] = add nsw i64 [[I_010]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[FOR_END]], label %[[FOR_BODY]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    tail call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    ret void
;
entry:
  %0 = tail call ptr @llvm.objc.retain(ptr %x) nounwind
  %cmp9 = icmp sgt i64 %n, 0
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.body
  %i.010 = phi i64 [ %inc, %for.body ], [ 0, %entry ]
  %1 = tail call ptr @llvm.objc.retain(ptr %x) nounwind
  %tmp5 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_", align 8
  %call = tail call ptr (ptr, ptr, ...) @objc_msgSend(ptr %1, ptr %tmp5)
  tail call void @llvm.objc.release(ptr %1) nounwind, !clang.imprecise_release !0
  %inc = add nsw i64 %i.010, 1
  %exitcond = icmp eq i64 %inc, %n
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  tail call void @llvm.objc.release(ptr %x) nounwind, !clang.imprecise_release !0
  ret void
}

; ObjCARCOpt can delete the retain,release on self.


%0 = type { ptr, ptr }
%1 = type opaque
%2 = type opaque
%3 = type opaque
%4 = type opaque
%5 = type opaque
%struct.NSConstantString = type { ptr, i32, ptr, i64 }
%struct._NSRange = type { i64, i64 }
%struct.__CFString = type opaque
%struct.__method_list_t = type { i32, i32, [0 x %struct._objc_method] }
%struct._class_ro_t = type { i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct._class_t = type { ptr, ptr, ptr, ptr, ptr }
%struct._ivar_list_t = type { i32, i32, [0 x %struct._ivar_t] }
%struct._ivar_t = type { ptr, ptr, ptr, i32, i32 }
%struct._message_ref_t = type { ptr, ptr }
%struct._objc_cache = type opaque
%struct._objc_method = type { ptr, ptr, ptr }
%struct._objc_protocol_list = type { i64, [0 x ptr] }
%struct._prop_list_t = type { i32, i32, [0 x %struct._message_ref_t] }
%struct._protocol_t = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32 }

@"\01L_OBJC_CLASSLIST_REFERENCES_$_17" = external hidden global ptr, section "__DATA, __objc_classrefs, regular, no_dead_strip", align 8
@kUTTypePlainText = external constant ptr
@"\01L_OBJC_SELECTOR_REFERENCES_19" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_21" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_23" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_25" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_CLASSLIST_REFERENCES_$_26" = external hidden global ptr, section "__DATA, __objc_classrefs, regular, no_dead_strip", align 8
@"\01L_OBJC_SELECTOR_REFERENCES_28" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_CLASSLIST_REFERENCES_$_29" = external hidden global ptr, section "__DATA, __objc_classrefs, regular, no_dead_strip", align 8
@"\01L_OBJC_SELECTOR_REFERENCES_31" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_33" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_35" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_37" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_CLASSLIST_REFERENCES_$_38" = external hidden global ptr, section "__DATA, __objc_classrefs, regular, no_dead_strip", align 8
@"\01L_OBJC_SELECTOR_REFERENCES_40" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_42" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@_unnamed_cfstring_44 = external hidden constant %struct.NSConstantString, section "__DATA,__cfstring"
@"\01L_OBJC_SELECTOR_REFERENCES_46" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_48" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01l_objc_msgSend_fixup_isEqual_" = external hidden global %0, section "__DATA, __objc_msgrefs, coalesced", align 16
@"\01L_OBJC_CLASSLIST_REFERENCES_$_50" = external hidden global ptr, section "__DATA, __objc_classrefs, regular, no_dead_strip", align 8
@NSCocoaErrorDomain = external constant ptr
@"\01L_OBJC_CLASSLIST_REFERENCES_$_51" = external hidden global ptr, section "__DATA, __objc_classrefs, regular, no_dead_strip", align 8
@NSFilePathErrorKey = external constant ptr
@"\01L_OBJC_SELECTOR_REFERENCES_53" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_55" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_CLASSLIST_REFERENCES_$_56" = external hidden global ptr, section "__DATA, __objc_classrefs, regular, no_dead_strip", align 8
@"\01L_OBJC_SELECTOR_REFERENCES_58" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"
@"\01L_OBJC_SELECTOR_REFERENCES_60" = external hidden global ptr, section "__DATA, __objc_selrefs, literal_pointers, no_dead_strip"

declare ptr @truncatedString(ptr, i64)
define void @TextEditTest(ptr %self, ptr %pboard) {
; CHECK-LABEL: define void @TextEditTest(
; CHECK-SAME: ptr [[SELF:%.*]], ptr [[PBOARD:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[ERR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr null, ptr [[ERR]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_17", align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @kUTTypePlainText, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_19", align 8
; CHECK-NEXT:    [[CALL5:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP1]], ptr [[TMP3]], ptr [[TMP2]])
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_21", align 8
; CHECK-NEXT:    [[CALL76:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[PBOARD]], ptr [[TMP5]], ptr [[CALL5]])
; CHECK-NEXT:    [[TMP9:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL76]]) #[[ATTR0]]
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq ptr [[TMP9]], null
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[END:.*]], label %[[LAND_LHS_TRUE:.*]]
; CHECK:       [[LAND_LHS_TRUE]]:
; CHECK-NEXT:    [[TMP11:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_23", align 8
; CHECK-NEXT:    [[CALL137:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[PBOARD]], ptr [[TMP11]], ptr [[TMP9]])
; CHECK-NEXT:    [[TMP10:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL137]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP12:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL137]]) #[[ATTR0]]
; CHECK-NEXT:    [[TOBOOL16:%.*]] = icmp eq ptr [[CALL137]], null
; CHECK-NEXT:    br i1 [[TOBOOL16]], label %[[END]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[TMP19:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_25", align 8
; CHECK-NEXT:    [[CALL21:%.*]] = call signext i8 @objc_msgSend(ptr [[CALL137]], ptr [[TMP19]])
; CHECK-NEXT:    [[TOBOOL22:%.*]] = icmp eq i8 [[CALL21]], 0
; CHECK-NEXT:    br i1 [[TOBOOL22]], label %[[IF_THEN44:.*]], label %[[LAND_LHS_TRUE23:.*]]
; CHECK:       [[LAND_LHS_TRUE23]]:
; CHECK-NEXT:    [[TMP24:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_26", align 8
; CHECK-NEXT:    [[TMP26:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_28", align 8
; CHECK-NEXT:    [[CALL2822:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP24]], ptr [[TMP26]], ptr [[CALL137]])
; CHECK-NEXT:    [[TMP14:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL2822]]) #[[ATTR0]]
; CHECK-NEXT:    [[TOBOOL30:%.*]] = icmp eq ptr [[CALL2822]], null
; CHECK-NEXT:    br i1 [[TOBOOL30]], label %[[IF_THEN44]], label %[[IF_END:.*]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[TMP32:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_29", align 8
; CHECK-NEXT:    [[TMP33:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_31", align 8
; CHECK-NEXT:    [[CALL35:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP32]], ptr [[TMP33]])
; CHECK-NEXT:    [[TMP37:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_33", align 8
; CHECK-NEXT:    [[CALL3923:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[CALL35]], ptr [[TMP37]], ptr [[CALL2822]], i32 signext 1, ptr [[ERR]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[CALL3923]], null
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN44]], label %[[END]]
; CHECK:       [[IF_THEN44]]:
; CHECK-NEXT:    [[URL_025:%.*]] = phi ptr [ [[CALL2822]], %[[IF_END]] ], [ [[CALL2822]], %[[LAND_LHS_TRUE23]] ], [ null, %[[IF_THEN]] ]
; CHECK-NEXT:    [[TMP49:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_35", align 8
; CHECK-NEXT:    [[CALL51:%.*]] = call [[STRUCT__NSRANGE:%.*]] @[[OBJC_MSGSEND:[a-zA-Z0-9_$\"\\.-]*[a-zA-Z_$\"\\.-][a-zA-Z0-9_$\"\\.-]*]](ptr [[CALL137]], ptr [[TMP49]], i64 0, i64 0)
; CHECK-NEXT:    [[CALL513:%.*]] = extractvalue [[STRUCT__NSRANGE]] [[CALL51]], 0
; CHECK-NEXT:    [[CALL514:%.*]] = extractvalue [[STRUCT__NSRANGE]] [[CALL51]], 1
; CHECK-NEXT:    [[TMP52:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_37", align 8
; CHECK-NEXT:    [[CALL548:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[CALL137]], ptr [[TMP52]], i64 [[CALL513]], i64 [[CALL514]])
; CHECK-NEXT:    [[TMP55:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_38", align 8
; CHECK-NEXT:    [[TMP56:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_40", align 8
; CHECK-NEXT:    [[CALL58:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP55]], ptr [[TMP56]])
; CHECK-NEXT:    [[TMP59:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_42", align 8
; CHECK-NEXT:    [[CALL6110:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[CALL548]], ptr [[TMP59]], ptr [[CALL58]])
; CHECK-NEXT:    [[TMP15:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL6110]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[CALL137]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP64:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_46", align 8
; CHECK-NEXT:    [[CALL66:%.*]] = call signext i8 @objc_msgSend(ptr [[CALL6110]], ptr [[TMP64]], ptr @_unnamed_cfstring_44)
; CHECK-NEXT:    [[TOBOOL67:%.*]] = icmp eq i8 [[CALL66]], 0
; CHECK-NEXT:    br i1 [[TOBOOL67]], label %[[IF_END74:.*]], label %[[IF_THEN68:.*]]
; CHECK:       [[IF_THEN68]]:
; CHECK-NEXT:    [[TMP70:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_48", align 8
; CHECK-NEXT:    [[CALL7220:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[CALL6110]], ptr [[TMP70]])
; CHECK-NEXT:    [[TMP16:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL7220]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[CALL6110]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[IF_END74]]
; CHECK:       [[IF_END74]]:
; CHECK-NEXT:    [[FILENAME_0_IN:%.*]] = phi ptr [ [[CALL7220]], %[[IF_THEN68]] ], [ [[CALL6110]], %[[IF_THEN44]] ]
; CHECK-NEXT:    [[TMP17:%.*]] = load ptr, ptr @"\01l_objc_msgSend_fixup_isEqual_", align 16
; CHECK-NEXT:    [[CALL78:%.*]] = call signext i8 (ptr, ptr, ptr, ...) [[TMP17]](ptr [[CALL137]], ptr @"\01l_objc_msgSend_fixup_isEqual_", ptr [[FILENAME_0_IN]])
; CHECK-NEXT:    [[TOBOOL79:%.*]] = icmp eq i8 [[CALL78]], 0
; CHECK-NEXT:    br i1 [[TOBOOL79]], label %[[LAND_LHS_TRUE80:.*]], label %[[IF_THEN109:.*]]
; CHECK:       [[LAND_LHS_TRUE80]]:
; CHECK-NEXT:    [[TMP82:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_25", align 8
; CHECK-NEXT:    [[CALL84:%.*]] = call signext i8 @objc_msgSend(ptr [[FILENAME_0_IN]], ptr [[TMP82]])
; CHECK-NEXT:    [[TOBOOL86:%.*]] = icmp eq i8 [[CALL84]], 0
; CHECK-NEXT:    br i1 [[TOBOOL86]], label %[[IF_THEN109]], label %[[IF_END106:.*]]
; CHECK:       [[IF_END106]]:
; CHECK-NEXT:    [[TMP88:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_26", align 8
; CHECK-NEXT:    [[TMP90:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_28", align 8
; CHECK-NEXT:    [[CALL9218:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP88]], ptr [[TMP90]], ptr [[FILENAME_0_IN]])
; CHECK-NEXT:    [[TMP21:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL9218]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[URL_025]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP94:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_29", align 8
; CHECK-NEXT:    [[TMP95:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_31", align 8
; CHECK-NEXT:    [[CALL97:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP94]], ptr [[TMP95]])
; CHECK-NEXT:    [[TMP99:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_33", align 8
; CHECK-NEXT:    [[CALL10119:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[CALL97]], ptr [[TMP99]], ptr [[CALL9218]], i32 signext 1, ptr [[ERR]])
; CHECK-NEXT:    [[PHITMP:%.*]] = icmp eq ptr [[CALL10119]], null
; CHECK-NEXT:    br i1 [[PHITMP]], label %[[IF_THEN109]], label %[[END]]
; CHECK:       [[IF_THEN109]]:
; CHECK-NEXT:    [[URL_129:%.*]] = phi ptr [ [[CALL9218]], %[[IF_END106]] ], [ [[URL_025]], %[[IF_END74]] ], [ [[URL_025]], %[[LAND_LHS_TRUE80]] ]
; CHECK-NEXT:    [[TMP110:%.*]] = load ptr, ptr [[ERR]], align 8
; CHECK-NEXT:    [[TOBOOL111:%.*]] = icmp eq ptr [[TMP110]], null
; CHECK-NEXT:    br i1 [[TOBOOL111]], label %[[IF_THEN112:.*]], label %[[IF_END125:.*]]
; CHECK:       [[IF_THEN112]]:
; CHECK-NEXT:    [[TMP113:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_50", align 8
; CHECK-NEXT:    [[TMP114:%.*]] = load ptr, ptr @NSCocoaErrorDomain, align 8
; CHECK-NEXT:    [[TMP115:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_51", align 8
; CHECK-NEXT:    [[CALL117:%.*]] = call ptr @truncatedString(ptr [[FILENAME_0_IN]], i64 1034)
; CHECK-NEXT:    [[TMP118:%.*]] = load ptr, ptr @NSFilePathErrorKey, align 8
; CHECK-NEXT:    [[TMP119:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_53", align 8
; CHECK-NEXT:    [[CALL12113:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP115]], ptr [[TMP119]], ptr [[CALL117]], ptr [[TMP118]], ptr null)
; CHECK-NEXT:    [[TMP122:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_55", align 8
; CHECK-NEXT:    [[CALL12414:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP113]], ptr [[TMP122]], ptr [[TMP114]], i64 258, ptr [[CALL12113]])
; CHECK-NEXT:    [[TMP23:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL12414]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP25:%.*]] = call ptr @llvm.objc.autorelease(ptr [[TMP23]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[TMP25]], ptr [[ERR]], align 8
; CHECK-NEXT:    br label %[[IF_END125]]
; CHECK:       [[IF_END125]]:
; CHECK-NEXT:    [[TMP127:%.*]] = phi ptr [ [[TMP110]], %[[IF_THEN109]] ], [ [[TMP25]], %[[IF_THEN112]] ]
; CHECK-NEXT:    [[TMP126:%.*]] = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_56", align 8
; CHECK-NEXT:    [[TMP128:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_58", align 8
; CHECK-NEXT:    [[CALL13015:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[TMP126]], ptr [[TMP128]], ptr [[TMP127]])
; CHECK-NEXT:    [[TMP131:%.*]] = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_60", align 8
; CHECK-NEXT:    [[CALL13317:%.*]] = call ptr (ptr, ptr, ...) @objc_msgSend(ptr [[CALL13015]], ptr [[TMP131]])
; CHECK-NEXT:    br label %[[END]]
; CHECK:       [[END]]:
; CHECK-NEXT:    [[FILENAME_2:%.*]] = phi ptr [ [[FILENAME_0_IN]], %[[IF_END106]] ], [ [[FILENAME_0_IN]], %[[IF_END125]] ], [ [[CALL137]], %[[LAND_LHS_TRUE]] ], [ null, %[[ENTRY]] ], [ [[CALL137]], %[[IF_END]] ]
; CHECK-NEXT:    [[ORIGFILENAME_0:%.*]] = phi ptr [ [[CALL137]], %[[IF_END106]] ], [ [[CALL137]], %[[IF_END125]] ], [ [[CALL137]], %[[LAND_LHS_TRUE]] ], [ null, %[[ENTRY]] ], [ [[CALL137]], %[[IF_END]] ]
; CHECK-NEXT:    [[URL_2:%.*]] = phi ptr [ [[CALL9218]], %[[IF_END106]] ], [ [[URL_129]], %[[IF_END125]] ], [ null, %[[LAND_LHS_TRUE]] ], [ null, %[[ENTRY]] ], [ [[CALL2822]], %[[IF_END]] ]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[TMP9]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[URL_2]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[ORIGFILENAME_0]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[FILENAME_2]]) #[[ATTR0]], !clang.imprecise_release [[META3]]
; CHECK-NEXT:    ret void
;
entry:
  %err = alloca ptr, align 8
  %tmp8 = call ptr @llvm.objc.retain(ptr %self) nounwind
  store ptr null, ptr %err, align 8
  %tmp1 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_17", align 8
  %tmp2 = load ptr, ptr @kUTTypePlainText, align 8
  %tmp3 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_19", align 8
  %call5 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp1, ptr %tmp3, ptr %tmp2)
  %tmp5 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_21", align 8
  %call76 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %pboard, ptr %tmp5, ptr %call5)
  %tmp9 = call ptr @llvm.objc.retain(ptr %call76) nounwind
  %tobool = icmp eq ptr %tmp9, null
  br i1 %tobool, label %end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %tmp11 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_23", align 8
  %call137 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %pboard, ptr %tmp11, ptr %tmp9)
  %tmp10 = call ptr @llvm.objc.retain(ptr %call137) nounwind
  call void @llvm.objc.release(ptr null) nounwind
  %tmp12 = call ptr @llvm.objc.retain(ptr %call137) nounwind
  call void @llvm.objc.release(ptr null) nounwind
  %tobool16 = icmp eq ptr %call137, null
  br i1 %tobool16, label %end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %tmp19 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_25", align 8
  %call21 = call signext i8 @objc_msgSend(ptr %call137, ptr %tmp19)
  %tobool22 = icmp eq i8 %call21, 0
  br i1 %tobool22, label %if.then44, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %if.then
  %tmp24 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_26", align 8
  %tmp26 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_28", align 8
  %call2822 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp24, ptr %tmp26, ptr %call137)
  %tmp14 = call ptr @llvm.objc.retain(ptr %call2822) nounwind
  call void @llvm.objc.release(ptr null) nounwind
  %tobool30 = icmp eq ptr %call2822, null
  br i1 %tobool30, label %if.then44, label %if.end

if.end:                                           ; preds = %land.lhs.true23
  %tmp32 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_29", align 8
  %tmp33 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_31", align 8
  %call35 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp32, ptr %tmp33)
  %tmp37 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_33", align 8
  %call3923 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %call35, ptr %tmp37, ptr %call2822, i32 signext 1, ptr %err)
  %cmp = icmp eq ptr %call3923, null
  br i1 %cmp, label %if.then44, label %end

if.then44:                                        ; preds = %if.end, %land.lhs.true23, %if.then
  %url.025 = phi ptr [ %call2822, %if.end ], [ %call2822, %land.lhs.true23 ], [ null, %if.then ]
  %tmp49 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_35", align 8
  %call51 = call %struct._NSRange @objc_msgSend(ptr %call137, ptr %tmp49, i64 0, i64 0)
  %call513 = extractvalue %struct._NSRange %call51, 0
  %call514 = extractvalue %struct._NSRange %call51, 1
  %tmp52 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_37", align 8
  %call548 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %call137, ptr %tmp52, i64 %call513, i64 %call514)
  %tmp55 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_38", align 8
  %tmp56 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_40", align 8
  %call58 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp55, ptr %tmp56)
  %tmp59 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_42", align 8
  %call6110 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %call548, ptr %tmp59, ptr %call58)
  %tmp15 = call ptr @llvm.objc.retain(ptr %call6110) nounwind
  call void @llvm.objc.release(ptr %call137) nounwind
  %tmp64 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_46", align 8
  %call66 = call signext i8 @objc_msgSend(ptr %call6110, ptr %tmp64, ptr @_unnamed_cfstring_44)
  %tobool67 = icmp eq i8 %call66, 0
  br i1 %tobool67, label %if.end74, label %if.then68

if.then68:                                        ; preds = %if.then44
  %tmp70 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_48", align 8
  %call7220 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %call6110, ptr %tmp70)
  %tmp16 = call ptr @llvm.objc.retain(ptr %call7220) nounwind
  call void @llvm.objc.release(ptr %call6110) nounwind
  br label %if.end74

if.end74:                                         ; preds = %if.then68, %if.then44
  %filename.0.in = phi ptr [ %call7220, %if.then68 ], [ %call6110, %if.then44 ]
  %tmp17 = load ptr, ptr @"\01l_objc_msgSend_fixup_isEqual_", align 16
  %call78 = call signext i8 (ptr, ptr, ptr, ...) %tmp17(ptr %call137, ptr @"\01l_objc_msgSend_fixup_isEqual_", ptr %filename.0.in)
  %tobool79 = icmp eq i8 %call78, 0
  br i1 %tobool79, label %land.lhs.true80, label %if.then109

land.lhs.true80:                                  ; preds = %if.end74
  %tmp82 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_25", align 8
  %call84 = call signext i8 @objc_msgSend(ptr %filename.0.in, ptr %tmp82)
  %tobool86 = icmp eq i8 %call84, 0
  br i1 %tobool86, label %if.then109, label %if.end106

if.end106:                                        ; preds = %land.lhs.true80
  %tmp88 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_26", align 8
  %tmp90 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_28", align 8
  %call9218 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp88, ptr %tmp90, ptr %filename.0.in)
  %tmp21 = call ptr @llvm.objc.retain(ptr %call9218) nounwind
  call void @llvm.objc.release(ptr %url.025) nounwind
  %tmp94 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_29", align 8
  %tmp95 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_31", align 8
  %call97 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp94, ptr %tmp95)
  %tmp99 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_33", align 8
  %call10119 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %call97, ptr %tmp99, ptr %call9218, i32 signext 1, ptr %err)
  %phitmp = icmp eq ptr %call10119, null
  br i1 %phitmp, label %if.then109, label %end

if.then109:                                       ; preds = %if.end106, %land.lhs.true80, %if.end74
  %url.129 = phi ptr [ %call9218, %if.end106 ], [ %url.025, %if.end74 ], [ %url.025, %land.lhs.true80 ]
  %tmp110 = load ptr, ptr %err, align 8
  %tobool111 = icmp eq ptr %tmp110, null
  br i1 %tobool111, label %if.then112, label %if.end125

if.then112:                                       ; preds = %if.then109
  %tmp113 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_50", align 8
  %tmp114 = load ptr, ptr @NSCocoaErrorDomain, align 8
  %tmp115 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_51", align 8
  %call117 = call ptr @truncatedString(ptr %filename.0.in, i64 1034)
  %tmp118 = load ptr, ptr @NSFilePathErrorKey, align 8
  %tmp119 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_53", align 8
  %call12113 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp115, ptr %tmp119, ptr %call117, ptr %tmp118, ptr null)
  %tmp122 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_55", align 8
  %call12414 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp113, ptr %tmp122, ptr %tmp114, i64 258, ptr %call12113)
  %tmp23 = call ptr @llvm.objc.retain(ptr %call12414) nounwind
  %tmp25 = call ptr @llvm.objc.autorelease(ptr %tmp23) nounwind
  store ptr %tmp25, ptr %err, align 8
  br label %if.end125

if.end125:                                        ; preds = %if.then112, %if.then109
  %tmp127 = phi ptr [ %tmp110, %if.then109 ], [ %tmp25, %if.then112 ]
  %tmp126 = load ptr, ptr @"\01L_OBJC_CLASSLIST_REFERENCES_$_56", align 8
  %tmp128 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_58", align 8
  %call13015 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %tmp126, ptr %tmp128, ptr %tmp127)
  %tmp131 = load ptr, ptr @"\01L_OBJC_SELECTOR_REFERENCES_60", align 8
  %call13317 = call ptr (ptr, ptr, ...) @objc_msgSend(ptr %call13015, ptr %tmp131)
  br label %end

end:                                              ; preds = %if.end125, %if.end106, %if.end, %land.lhs.true, %entry
  %filename.2 = phi ptr [ %filename.0.in, %if.end106 ], [ %filename.0.in, %if.end125 ], [ %call137, %land.lhs.true ], [ null, %entry ], [ %call137, %if.end ]
  %origFilename.0 = phi ptr [ %call137, %if.end106 ], [ %call137, %if.end125 ], [ %call137, %land.lhs.true ], [ null, %entry ], [ %call137, %if.end ]
  %url.2 = phi ptr [ %call9218, %if.end106 ], [ %url.129, %if.end125 ], [ null, %land.lhs.true ], [ null, %entry ], [ %call2822, %if.end ]
  call void @llvm.objc.release(ptr %tmp9) nounwind, !clang.imprecise_release !0
  call void @llvm.objc.release(ptr %url.2) nounwind, !clang.imprecise_release !0
  call void @llvm.objc.release(ptr %origFilename.0) nounwind, !clang.imprecise_release !0
  call void @llvm.objc.release(ptr %filename.2) nounwind, !clang.imprecise_release !0
  call void @llvm.objc.release(ptr %self) nounwind, !clang.imprecise_release !0
  ret void
}

declare i32 @__gxx_personality_v0(...)

declare i32 @llvm.objc.sync.enter(ptr)
declare i32 @llvm.objc.sync.exit(ptr)

; Make sure that we understand that objc_sync_{enter,exit} are IC_User not
; IC_Call/IC_CallOrUser.

define void @test67(ptr %x) {
; CHECK-LABEL: define void @test67(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.objc.sync.enter(ptr [[X]])
; CHECK-NEXT:    [[TMP2:%.*]] = call i32 @llvm.objc.sync.exit(ptr [[X]])
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr %x)
  call i32 @llvm.objc.sync.enter(ptr %x)
  call i32 @llvm.objc.sync.exit(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}


define void @test68(ptr %a, ptr %b) {
; CHECK-LABEL: define void @test68(
; CHECK-SAME: ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:    call void @callee2(ptr [[A]], ptr [[B]])
; CHECK-NEXT:    ret void
;
  call ptr @llvm.objc.retain(ptr %a)
  call ptr @llvm.objc.retain(ptr %b)
  call void @callee2(ptr %a, ptr %b)
  call void @llvm.objc.release(ptr %b), !clang.imprecise_release !0
  call void @llvm.objc.release(ptr %a), !clang.imprecise_release !0
  ret void
}

!llvm.module.flags = !{!1}
!llvm.dbg.cu = !{!3}

!0 = !{}
!1 = !{i32 1, !"Debug Info Version", i32 3}
!2 = distinct !DISubprogram(unit: !3)
!3 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang",
  file: !4,
  isOptimized: true, flags: "-O2",
  splitDebugFilename: "abc.debug", emissionKind: 2)
!4 = !DIFile(filename: "path/to/file", directory: "/path/to/dir")
!5 = !{i32 2, !"Debug Info Version", i32 3}

;.
; CHECK: [[META3]] = !{}
;.
