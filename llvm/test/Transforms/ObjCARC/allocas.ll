; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=objc-arc -S < %s | FileCheck %s

declare ptr @llvm.objc.retain(ptr)
declare ptr @llvm.objc.retainAutoreleasedReturnValue(ptr)
declare void @llvm.objc.release(ptr)
declare ptr @llvm.objc.autorelease(ptr)
declare ptr @llvm.objc.autoreleaseReturnValue(ptr)
declare void @llvm.objc.autoreleasePoolPop(ptr)
declare ptr @llvm.objc.autoreleasePoolPush()
declare ptr @llvm.objc.retainBlock(ptr)

declare ptr @objc_retainedObject(ptr)
declare ptr @objc_unretainedObject(ptr)
declare ptr @objc_unretainedPointer(ptr)

declare void @use_pointer(ptr)
declare void @callee()
declare void @callee_fnptr(ptr)
declare void @invokee()
declare ptr @returner()
declare ptr @returner1()
declare ptr @returner2()
declare void @bar(ptr)
declare void @use_alloca(ptr)

declare void @llvm.dbg.value(metadata, metadata, metadata)

declare ptr @objc_msgSend(ptr, ptr, ...)


; In the presence of allocas, unconditionally remove retain/release pairs only
; if they are known safe in both directions. This prevents matching up an inner
; retain with the boundary guarding release in the following situation:
;
; %A = alloca
; retain(%x)
; retain(%x) <--- Inner Retain
; store %x, %A
; %y = load %A
; ... DO STUFF ...
; release(%y)
; release(%x) <--- Guarding Release
;
; rdar://13750319

define void @test1a(ptr %x) {
; CHECK-LABEL: define void @test1a(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    store ptr [[X]], ptr [[A]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0:![0-9]+]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %A = alloca ptr
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  store ptr %x, ptr %A, align 8
  %y = load ptr, ptr %A
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

define void @test1b(ptr %x) {
; CHECK-LABEL: define void @test1b(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[X]], ptr [[A]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %A = alloca ptr
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  store ptr %x, ptr %A, align 8
  %y = load ptr, ptr %A
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}


define void @test1c(ptr %x) {
; CHECK-LABEL: define void @test1c(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, i32 3, align 8
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr ptr, ptr [[A]], i32 2
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[X]], ptr [[GEP]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[GEP]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %A = alloca ptr, i32 3
  %gep = getelementptr ptr, ptr %A, i32 2
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  store ptr %x, ptr %gep, align 8
  %y = load ptr, ptr %gep
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}


define void @test1d(ptr %x, i1 %arg) {
; CHECK-LABEL: define void @test1d(
; CHECK-SAME: ptr [[X:%.*]], i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[ARG]], label %[[USE_ALLOCAA:.*]], label %[[USE_ALLOCAB:.*]]
; CHECK:       [[USE_ALLOCAA]]:
; CHECK-NEXT:    [[ALLOCAA:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[USE_ALLOCAB]]:
; CHECK-NEXT:    [[ALLOCAB:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[A:%.*]] = phi ptr [ [[ALLOCAA]], %[[USE_ALLOCAA]] ], [ [[ALLOCAB]], %[[USE_ALLOCAB]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[X]], ptr [[A]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %arg, label %use_allocaA, label %use_allocaB

use_allocaA:
  %allocaA = alloca ptr
  br label %exit

use_allocaB:
  %allocaB = alloca ptr
  br label %exit

exit:
  %A = phi ptr [ %allocaA, %use_allocaA ], [ %allocaB, %use_allocaB ]
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  store ptr %x, ptr %A, align 8
  %y = load ptr, ptr %A
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

define void @test1e(ptr %x, i1 %arg) {
; CHECK-LABEL: define void @test1e(
; CHECK-SAME: ptr [[X:%.*]], i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[ARG]], label %[[USE_ALLOCAA:.*]], label %[[USE_ALLOCAB:.*]]
; CHECK:       [[USE_ALLOCAA]]:
; CHECK-NEXT:    [[ALLOCAA:%.*]] = alloca ptr, i32 4, align 8
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[USE_ALLOCAB]]:
; CHECK-NEXT:    [[ALLOCAB:%.*]] = alloca ptr, i32 4, align 8
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[A:%.*]] = phi ptr [ [[ALLOCAA]], %[[USE_ALLOCAA]] ], [ [[ALLOCAB]], %[[USE_ALLOCAB]] ]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr ptr, ptr [[A]], i32 2
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[X]], ptr [[GEP]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[GEP]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  br i1 %arg, label %use_allocaA, label %use_allocaB

use_allocaA:
  %allocaA = alloca ptr, i32 4
  br label %exit

use_allocaB:
  %allocaB = alloca ptr, i32 4
  br label %exit

exit:
  %A = phi ptr [ %allocaA, %use_allocaA ], [ %allocaB, %use_allocaB ]
  %gep = getelementptr ptr, ptr %A, i32 2
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  store ptr %x, ptr %gep, align 8
  %y = load ptr, ptr %gep
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

define void @test1f(ptr %x) {
; CHECK-LABEL: define void @test1f(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOCAONE:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[ALLOCATWO:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[A:%.*]] = select i1 undef, ptr [[ALLOCAONE]], ptr [[ALLOCATWO]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[X]], ptr [[A]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %allocaOne = alloca ptr
  %allocaTwo = alloca ptr
  %A = select i1 undef, ptr %allocaOne, ptr %allocaTwo
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  store ptr %x, ptr %A, align 8
  %y = load ptr, ptr %A
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

; Make sure that if a store is in a different basic block we handle known safe
; conservatively.


define void @test2a(ptr %x) {
; CHECK-LABEL: define void @test2a(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[X]], ptr [[A]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    br label %[[BB1:.*]]
; CHECK:       [[BB1]]:
; CHECK-NEXT:    br label %[[BB2:.*]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    br label %[[BB3:.*]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %A = alloca ptr
  store ptr %x, ptr %A, align 8
  %y = load ptr, ptr %A
  br label %bb1

bb1:
  br label %bb2

bb2:
  br label %bb3

bb3:
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

define void @test2b(ptr %x) {
; CHECK-LABEL: define void @test2b(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[X]], ptr [[A]], align 8
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    br label %[[BB1:.*]]
; CHECK:       [[BB1]]:
; CHECK-NEXT:    br label %[[BB2:.*]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    br label %[[BB3:.*]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %A = alloca ptr
  store ptr %x, ptr %A, align 8
  %y = load ptr, ptr %A
  br label %bb1

bb1:
  br label %bb2

bb2:
  br label %bb3

bb3:
  tail call ptr @llvm.objc.retain(ptr %x)
  tail call ptr @llvm.objc.retain(ptr %x)
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

define void @test2c(ptr %x) {
; CHECK-LABEL: define void @test2c(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = alloca ptr, i32 3, align 8
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr ptr, ptr [[A]], i32 2
; CHECK-NEXT:    store ptr [[X]], ptr [[GEP1]], align 8
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr ptr, ptr [[A]], i32 2
; CHECK-NEXT:    [[Y:%.*]] = load ptr, ptr [[GEP2]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[BB1:.*]]
; CHECK:       [[BB1]]:
; CHECK-NEXT:    br label %[[BB2:.*]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    br label %[[BB3:.*]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  %A = alloca ptr, i32 3
  %gep1 = getelementptr ptr, ptr %A, i32 2
  store ptr %x, ptr %gep1, align 8
  %gep2 = getelementptr ptr, ptr %A, i32 2
  %y = load ptr, ptr %gep2
  tail call ptr @llvm.objc.retain(ptr %x)
  br label %bb1

bb1:
  br label %bb2

bb2:
  br label %bb3

bb3:
  tail call ptr @llvm.objc.retain(ptr %x)
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

define void @test2d(ptr %x) {
; CHECK-LABEL: define void @test2d(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    br label %[[BB1:.*]]
; CHECK:       [[BB1]]:
; CHECK-NEXT:    [[ABB1:%.*]] = alloca ptr, i32 3, align 8
; CHECK-NEXT:    [[GEPBB11:%.*]] = getelementptr ptr, ptr [[ABB1]], i32 2
; CHECK-NEXT:    store ptr [[X]], ptr [[GEPBB11]], align 8
; CHECK-NEXT:    [[GEPBB12:%.*]] = getelementptr ptr, ptr [[ABB1]], i32 2
; CHECK-NEXT:    [[YBB1:%.*]] = load ptr, ptr [[GEPBB12]], align 8
; CHECK-NEXT:    br label %[[BB3:.*]]
; CHECK:       [[BB2:.*]]:
; CHECK-NEXT:    [[ABB2:%.*]] = alloca ptr, i32 4, align 8
; CHECK-NEXT:    [[GEPBB21:%.*]] = getelementptr ptr, ptr [[ABB2]], i32 2
; CHECK-NEXT:    store ptr [[X]], ptr [[GEPBB21]], align 8
; CHECK-NEXT:    [[GEPBB22:%.*]] = getelementptr ptr, ptr [[ABB2]], i32 2
; CHECK-NEXT:    [[YBB2:%.*]] = load ptr, ptr [[GEPBB22]], align 8
; CHECK-NEXT:    br label %[[BB3]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    [[A:%.*]] = phi ptr [ [[ABB1]], %[[BB1]] ], [ [[ABB2]], %[[BB2]] ]
; CHECK-NEXT:    [[Y:%.*]] = phi ptr [ [[YBB1]], %[[BB1]] ], [ [[YBB2]], %[[BB2]] ]
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[X]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_alloca(ptr [[A]])
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[Y]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    call void @use_pointer(ptr [[X]])
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[X]]) #[[ATTR0]]
; CHECK-NEXT:    ret void
;
entry:
  tail call ptr @llvm.objc.retain(ptr %x)
  br label %bb1

bb1:
  %Abb1 = alloca ptr, i32 3
  %gepbb11 = getelementptr ptr, ptr %Abb1, i32 2
  store ptr %x, ptr %gepbb11, align 8
  %gepbb12 = getelementptr ptr, ptr %Abb1, i32 2
  %ybb1 = load ptr, ptr %gepbb12
  br label %bb3

bb2:
  %Abb2 = alloca ptr, i32 4
  %gepbb21 = getelementptr ptr, ptr %Abb2, i32 2
  store ptr %x, ptr %gepbb21, align 8
  %gepbb22 = getelementptr ptr, ptr %Abb2, i32 2
  %ybb2 = load ptr, ptr %gepbb22
  br label %bb3

bb3:
  %A = phi ptr [ %Abb1, %bb1 ], [ %Abb2, %bb2 ]
  %y = phi ptr [ %ybb1, %bb1 ], [ %ybb2, %bb2 ]
  tail call ptr @llvm.objc.retain(ptr %x)
  call void @use_alloca(ptr %A)
  call void @llvm.objc.release(ptr %y), !clang.imprecise_release !0
  call void @use_pointer(ptr %x)
  call void @llvm.objc.release(ptr %x), !clang.imprecise_release !0
  ret void
}

; Make sure in the presence of allocas, if we find a cfghazard we do not perform
; code motion even if we are known safe. These two concepts are separate and
; should be treated as such.
;
; rdar://13949644

define void @test3a() {
; CHECK-LABEL: define void @test3a() {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[KEYS:%.*]] = alloca [2 x ptr], align 16
; CHECK-NEXT:    [[OBJS:%.*]] = alloca [2 x ptr], align 16
; CHECK-NEXT:    [[CALL1:%.*]] = call ptr @returner()
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[CALL1]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL1]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[CALL1]], ptr [[OBJS]], align 8
; CHECK-NEXT:    [[OBJS_ELT:%.*]] = getelementptr inbounds [2 x ptr], ptr [[OBJS]], i64 0, i64 1
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL1]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[CALL1]], ptr [[OBJS_ELT]], align 8
; CHECK-NEXT:    [[CALL2:%.*]] = call ptr @returner1()
; CHECK-NEXT:    [[CALL3:%.*]] = call ptr @returner2()
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL2]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[CALL2]], ptr [[KEYS]], align 8
; CHECK-NEXT:    [[KEYS_ELT:%.*]] = getelementptr inbounds [2 x ptr], ptr [[KEYS]], i64 0, i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL3]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[CALL3]], ptr [[KEYS_ELT]], align 8
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds [2 x ptr], ptr [[OBJS]], i64 0, i64 2
; CHECK-NEXT:    br label %[[ARRAYDESTROY_BODY:.*]]
; CHECK:       [[ARRAYDESTROY_BODY]]:
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENTPAST:%.*]] = phi ptr [ [[GEP]], %[[ENTRY]] ], [ [[ARRAYDESTROY_ELEMENT:%.*]], %[[ARRAYDESTROY_BODY]] ]
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENT]] = getelementptr inbounds ptr, ptr [[ARRAYDESTROY_ELEMENTPAST]], i64 -1
; CHECK-NEXT:    [[DESTROY_TMP:%.*]] = load ptr, ptr [[ARRAYDESTROY_ELEMENT]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[DESTROY_TMP]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    [[ARRAYDESTROY_CMP:%.*]] = icmp eq ptr [[ARRAYDESTROY_ELEMENT]], [[OBJS]]
; CHECK-NEXT:    br i1 [[ARRAYDESTROY_CMP]], label %[[ARRAYDESTROY_DONE:.*]], label %[[ARRAYDESTROY_BODY]]
; CHECK:       [[ARRAYDESTROY_DONE]]:
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds [2 x ptr], ptr [[KEYS]], i64 0, i64 2
; CHECK-NEXT:    br label %[[ARRAYDESTROY_BODY1:.*]]
; CHECK:       [[ARRAYDESTROY_BODY1]]:
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENTPAST1:%.*]] = phi ptr [ [[GEP1]], %[[ARRAYDESTROY_DONE]] ], [ [[ARRAYDESTROY_ELEMENT1:%.*]], %[[ARRAYDESTROY_BODY1]] ]
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENT1]] = getelementptr inbounds ptr, ptr [[ARRAYDESTROY_ELEMENTPAST1]], i64 -1
; CHECK-NEXT:    [[DESTROY_TMP1:%.*]] = load ptr, ptr [[ARRAYDESTROY_ELEMENT1]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[DESTROY_TMP1]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    [[ARRAYDESTROY_CMP1:%.*]] = icmp eq ptr [[ARRAYDESTROY_ELEMENT1]], [[KEYS]]
; CHECK-NEXT:    br i1 [[ARRAYDESTROY_CMP1]], label %[[ARRAYDESTROY_DONE1:.*]], label %[[ARRAYDESTROY_BODY1]]
; CHECK:       [[ARRAYDESTROY_DONE1]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[CALL1]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    ret void
;
entry:
  %keys = alloca [2 x ptr], align 16
  %objs = alloca [2 x ptr], align 16

  %call1 = call ptr @returner()
  %tmp0 = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %call1)

  tail call ptr @llvm.objc.retain(ptr %call1)
  store ptr %call1, ptr %objs, align 8
  %objs.elt = getelementptr inbounds [2 x ptr], ptr %objs, i64 0, i64 1
  tail call ptr @llvm.objc.retain(ptr %call1)
  store ptr %call1, ptr %objs.elt

  %call2 = call ptr @returner1()
  %call3 = call ptr @returner2()
  tail call ptr @llvm.objc.retain(ptr %call2)
  store ptr %call2, ptr %keys, align 8
  %keys.elt = getelementptr inbounds [2 x ptr], ptr %keys, i64 0, i64 1
  tail call ptr @llvm.objc.retain(ptr %call3)
  store ptr %call3, ptr %keys.elt

  %gep = getelementptr inbounds [2 x ptr], ptr %objs, i64 0, i64 2
  br label %arraydestroy.body

arraydestroy.body:
  %arraydestroy.elementPast = phi ptr [ %gep, %entry ], [ %arraydestroy.element, %arraydestroy.body ]
  %arraydestroy.element = getelementptr inbounds ptr, ptr %arraydestroy.elementPast, i64 -1
  %destroy_tmp = load ptr, ptr %arraydestroy.element, align 8
  call void @llvm.objc.release(ptr %destroy_tmp), !clang.imprecise_release !0
  %arraydestroy.cmp = icmp eq ptr %arraydestroy.element, %objs
  br i1 %arraydestroy.cmp, label %arraydestroy.done, label %arraydestroy.body

arraydestroy.done:
  %gep1 = getelementptr inbounds [2 x ptr], ptr %keys, i64 0, i64 2
  br label %arraydestroy.body1

arraydestroy.body1:
  %arraydestroy.elementPast1 = phi ptr [ %gep1, %arraydestroy.done ], [ %arraydestroy.element1, %arraydestroy.body1 ]
  %arraydestroy.element1 = getelementptr inbounds ptr, ptr %arraydestroy.elementPast1, i64 -1
  %destroy_tmp1 = load ptr, ptr %arraydestroy.element1, align 8
  call void @llvm.objc.release(ptr %destroy_tmp1), !clang.imprecise_release !0
  %arraydestroy.cmp1 = icmp eq ptr %arraydestroy.element1, %keys
  br i1 %arraydestroy.cmp1, label %arraydestroy.done1, label %arraydestroy.body1

arraydestroy.done1:
  call void @llvm.objc.release(ptr %call1), !clang.imprecise_release !0
  ret void
}

; Make sure that even though we stop said code motion we still allow for
; pointers to be removed if we are known safe in both directions.
;
; rdar://13949644

define void @test3b() {
; CHECK-LABEL: define void @test3b() {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[KEYS:%.*]] = alloca [2 x ptr], align 16
; CHECK-NEXT:    [[OBJS:%.*]] = alloca [2 x ptr], align 16
; CHECK-NEXT:    [[CALL1:%.*]] = call ptr @returner()
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr [[CALL1]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL1]]) #[[ATTR0]]
; CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL1]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[CALL1]], ptr [[OBJS]], align 8
; CHECK-NEXT:    [[OBJS_ELT:%.*]] = getelementptr inbounds [2 x ptr], ptr [[OBJS]], i64 0, i64 1
; CHECK-NEXT:    store ptr [[CALL1]], ptr [[OBJS_ELT]], align 8
; CHECK-NEXT:    [[CALL2:%.*]] = call ptr @returner1()
; CHECK-NEXT:    [[CALL3:%.*]] = call ptr @returner2()
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL2]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[CALL2]], ptr [[KEYS]], align 8
; CHECK-NEXT:    [[KEYS_ELT:%.*]] = getelementptr inbounds [2 x ptr], ptr [[KEYS]], i64 0, i64 1
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @llvm.objc.retain(ptr [[CALL3]]) #[[ATTR0]]
; CHECK-NEXT:    store ptr [[CALL3]], ptr [[KEYS_ELT]], align 8
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds [2 x ptr], ptr [[OBJS]], i64 0, i64 2
; CHECK-NEXT:    br label %[[ARRAYDESTROY_BODY:.*]]
; CHECK:       [[ARRAYDESTROY_BODY]]:
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENTPAST:%.*]] = phi ptr [ [[GEP]], %[[ENTRY]] ], [ [[ARRAYDESTROY_ELEMENT:%.*]], %[[ARRAYDESTROY_BODY]] ]
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENT]] = getelementptr inbounds ptr, ptr [[ARRAYDESTROY_ELEMENTPAST]], i64 -1
; CHECK-NEXT:    [[DESTROY_TMP:%.*]] = load ptr, ptr [[ARRAYDESTROY_ELEMENT]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[DESTROY_TMP]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    [[ARRAYDESTROY_CMP:%.*]] = icmp eq ptr [[ARRAYDESTROY_ELEMENT]], [[OBJS]]
; CHECK-NEXT:    br i1 [[ARRAYDESTROY_CMP]], label %[[ARRAYDESTROY_DONE:.*]], label %[[ARRAYDESTROY_BODY]]
; CHECK:       [[ARRAYDESTROY_DONE]]:
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds [2 x ptr], ptr [[KEYS]], i64 0, i64 2
; CHECK-NEXT:    br label %[[ARRAYDESTROY_BODY1:.*]]
; CHECK:       [[ARRAYDESTROY_BODY1]]:
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENTPAST1:%.*]] = phi ptr [ [[GEP1]], %[[ARRAYDESTROY_DONE]] ], [ [[ARRAYDESTROY_ELEMENT1:%.*]], %[[ARRAYDESTROY_BODY1]] ]
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENT1]] = getelementptr inbounds ptr, ptr [[ARRAYDESTROY_ELEMENTPAST1]], i64 -1
; CHECK-NEXT:    [[DESTROY_TMP1:%.*]] = load ptr, ptr [[ARRAYDESTROY_ELEMENT1]], align 8
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[DESTROY_TMP1]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    [[ARRAYDESTROY_CMP1:%.*]] = icmp eq ptr [[ARRAYDESTROY_ELEMENT1]], [[KEYS]]
; CHECK-NEXT:    br i1 [[ARRAYDESTROY_CMP1]], label %[[ARRAYDESTROY_DONE1:.*]], label %[[ARRAYDESTROY_BODY1]]
; CHECK:       [[ARRAYDESTROY_DONE1]]:
; CHECK-NEXT:    call void @llvm.objc.release(ptr [[CALL1]]) #[[ATTR0]], !clang.imprecise_release [[META0]]
; CHECK-NEXT:    ret void
;
entry:
  %keys = alloca [2 x ptr], align 16
  %objs = alloca [2 x ptr], align 16

  %call1 = call ptr @returner()
  %tmp0 = tail call ptr @llvm.objc.retainAutoreleasedReturnValue(ptr %call1)
  %tmp1 = tail call ptr @llvm.objc.retain(ptr %call1)

  tail call ptr @llvm.objc.retain(ptr %call1)
  store ptr %call1, ptr %objs, align 8
  %objs.elt = getelementptr inbounds [2 x ptr], ptr %objs, i64 0, i64 1
  tail call ptr @llvm.objc.retain(ptr %call1)
  store ptr %call1, ptr %objs.elt

  %call2 = call ptr @returner1()
  %call3 = call ptr @returner2()
  tail call ptr @llvm.objc.retain(ptr %call2)
  store ptr %call2, ptr %keys, align 8
  %keys.elt = getelementptr inbounds [2 x ptr], ptr %keys, i64 0, i64 1
  tail call ptr @llvm.objc.retain(ptr %call3)
  store ptr %call3, ptr %keys.elt

  %gep = getelementptr inbounds [2 x ptr], ptr %objs, i64 0, i64 2
  br label %arraydestroy.body

arraydestroy.body:
  %arraydestroy.elementPast = phi ptr [ %gep, %entry ], [ %arraydestroy.element, %arraydestroy.body ]
  %arraydestroy.element = getelementptr inbounds ptr, ptr %arraydestroy.elementPast, i64 -1
  %destroy_tmp = load ptr, ptr %arraydestroy.element, align 8
  call void @llvm.objc.release(ptr %destroy_tmp), !clang.imprecise_release !0
  %arraydestroy.cmp = icmp eq ptr %arraydestroy.element, %objs
  br i1 %arraydestroy.cmp, label %arraydestroy.done, label %arraydestroy.body

arraydestroy.done:
  %gep1 = getelementptr inbounds [2 x ptr], ptr %keys, i64 0, i64 2
  br label %arraydestroy.body1

arraydestroy.body1:
  %arraydestroy.elementPast1 = phi ptr [ %gep1, %arraydestroy.done ], [ %arraydestroy.element1, %arraydestroy.body1 ]
  %arraydestroy.element1 = getelementptr inbounds ptr, ptr %arraydestroy.elementPast1, i64 -1
  %destroy_tmp1 = load ptr, ptr %arraydestroy.element1, align 8
  call void @llvm.objc.release(ptr %destroy_tmp1), !clang.imprecise_release !0
  %arraydestroy.cmp1 = icmp eq ptr %arraydestroy.element1, %keys
  br i1 %arraydestroy.cmp1, label %arraydestroy.done1, label %arraydestroy.body1

arraydestroy.done1:
  call void @llvm.objc.release(ptr %call1), !clang.imprecise_release !0
  call void @llvm.objc.release(ptr %call1), !clang.imprecise_release !0
  ret void
}

!0 = !{}

declare i32 @__gxx_personality_v0(...)
;.
; CHECK: [[META0]] = !{}
;.
