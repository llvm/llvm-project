; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes='move-entry-alloca-init' -verify-memoryssa -S < %s | FileCheck %s

declare void @bar(ptr)

define void @src(i32 %a, i32 %b) {
; CHECK-LABEL: define void @src(
; CHECK-SAME: i32 [[A:%.*]], i32 [[B:%.*]]) {
; CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32
; CHECK-NEXT:    [[B_ADDR:%.*]] = alloca i32
; CHECK-NEXT:    [[S_ADDR:%.*]] = alloca { ptr, ptr }
; CHECK:         [[S_X:%.*]] = getelementptr inbounds { ptr, ptr }, ptr [[S_ADDR]], i32 0, i32 0
; CHECK:         [[S_Y:%.*]] = getelementptr inbounds { ptr, ptr }, ptr [[S_ADDR]], i32 0, i32 1
; CHECK:         [[CMP:%.*]] = icmp slt i32 [[A]], [[B]]
; CHECK:         br i1 [[CMP]], label [[COLD:%.*]], label [[RET:%.*]]
;
; CHECK:       cold:
; CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
; CHECK-NEXT:    store i32 [[B]], ptr [[B_ADDR]], align 4
; CHECK-NEXT:    store ptr [[A_ADDR]], ptr [[S_X]], align 8
; CHECK-NEXT:    store ptr [[B_ADDR]], ptr [[S_Y]], align 8
; CHECK-NEXT:    call void @bar(ptr [[S_ADDR]])
; CHECK-NEXT:    br label [[RET]]
;
; CHECK:       ret:
; CHECK-NEXT:    ret void
;
  %a.addr = alloca i32
  %b.addr = alloca i32
  %s.addr = alloca { ptr, ptr }

  store i32 %a, ptr %a.addr
  store i32 %b, ptr %b.addr

  %s.x = getelementptr inbounds { ptr, ptr }, ptr %s.addr, i32 0, i32 0
  store ptr %a.addr, ptr %s.x

  %s.y = getelementptr inbounds { ptr, ptr }, ptr %s.addr, i32 0, i32 1
  store ptr %b.addr, ptr %s.y

  %cmp = icmp slt i32 %a, %b
  br i1 %cmp, label %cold, label %ret

cold:
  call void @bar(ptr %s.addr)
  br label %ret

ret:
  ret void
}
