; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=dse -S %s | FileCheck %s

; Dead store in loop with a loop dependency of kind array[i] += array[i + 1].
define void @test() #0 {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [26 x i32], align 16
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(104) [[ARRAY]], i8 0, i64 104, i1 false)
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[ARRAY_CURR:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ARRAY_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[ARRAYIDX_NEXT:%.*]] = getelementptr inbounds [26 x i32], ptr [[ARRAY]], i64 0, i64 [[IV_NEXT]]
; CHECK-NEXT:    [[ARRAY_NEXT]] = load i32, ptr [[ARRAYIDX_NEXT]], align 4
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [26 x i32], ptr [[ARRAY]], i64 0, i64 [[IV]]
; CHECK-NEXT:    [[SUM:%.*]] = add nsw i32 [[ARRAY_CURR]], [[ARRAY_NEXT]]
; CHECK-NEXT:    store i32 [[SUM]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[IV_NEXT]], 25
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %array = alloca [26 x i32], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(104) %array, i8 0, i64 104, i1 false)
  br label %loop

loop:                                                ; preds = %entry, %loop
  %array.curr = phi i32 [ 0, %entry ], [ %array.next, %loop ]
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.next = add nuw nsw i64 %iv, 1
  %arrayidx.next = getelementptr inbounds [26 x i32], ptr %array, i64 0, i64 %iv.next
  %array.next = load i32, ptr %arrayidx.next, align 4
  %arrayidx = getelementptr inbounds [26 x i32], ptr %array, i64 0, i64 %iv
  %sum = add nsw i32 %array.curr, %array.next
  store i32 %sum, ptr %arrayidx, align 4
  %cond = icmp eq i64 %iv.next, 25
  br i1 %cond, label %exit, label %loop, !llvm.loop !0

exit:                                                ; preds = %loop
  ret void
}

; Final read of array[1] after loop dependency of kind array[i] += array[i - 1] + A[i].
define i32 @test1(ptr nocapture noundef readonly %A) #0 {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [25 x i32], align 16
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(100) [[ARRAY]], i8 0, i64 100, i1 false)
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[ARRAY_PREV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SUM:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 1, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A_IDX:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[IV]]
; CHECK-NEXT:    [[A_CURR:%.*]] = load i32, ptr [[A_IDX]], align 4
; CHECK-NEXT:    [[A_CURR_SUM_ARRAY_PREV:%.*]] = add nsw i32 [[A_CURR]], [[ARRAY_PREV]]
; CHECK-NEXT:    [[ARRAY_IDX:%.*]] = getelementptr inbounds [25 x i32], ptr [[ARRAY]], i64 0, i64 [[IV]]
; CHECK-NEXT:    [[ARRAY_CURR:%.*]] = load i32, ptr [[ARRAY_IDX]], align 4
; CHECK-NEXT:    [[SUM]] = add nsw i32 [[A_CURR_SUM_ARRAY_PREV]], [[ARRAY_CURR]]
; CHECK-NEXT:    store i32 [[SUM]], ptr [[ARRAY_IDX]], align 4
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[IV_NEXT]], 25
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP0]]
; CHECK:       exit:
; CHECK-NEXT:    [[ARRAY_IDX_1:%.*]] = getelementptr inbounds i8, ptr [[ARRAY]], i64 4
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAY_IDX_1]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %array = alloca [25 x i32], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(100) %array, i8 0, i64 100, i1 false)
  br label %loop

loop:                                                ; preds = %entry, %loop
  %array.prev = phi i32 [ 0, %entry ], [ %sum, %loop ]
  %iv = phi i64 [ 1, %entry ], [ %iv.next, %loop ]
  %A.idx = getelementptr inbounds i32, ptr %A, i64 %iv
  %A.curr = load i32, ptr %A.idx, align 4
  %A.curr.sum.array.prev = add nsw i32 %A.curr, %array.prev
  %array.idx = getelementptr inbounds [25 x i32], ptr %array, i64 0, i64 %iv
  %array.curr = load i32, ptr %array.idx, align 4
  %sum = add nsw i32 %A.curr.sum.array.prev, %array.curr
  store i32 %sum, ptr %array.idx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp eq i64 %iv.next, 25
  br i1 %cond, label %exit, label %loop, !llvm.loop !0

exit:                                                ; preds = %loop
  %array.idx.1 = getelementptr inbounds i8, ptr %array, i64 4
  %val = load i32, ptr %array.idx.1, align 4
  ret i32 %val
}

declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg)

!0 = distinct !{!0, !1}
!1 = !{!"llvm.loop.mustprogress"}

attributes #0 = { mustprogress }
