; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=dse -S %s | FileCheck %s

declare i1 @cond() readnone

define i32 @test() {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[M0:%.*]] = alloca [4 x i32], align 16
; CHECK-NEXT:    br label [[LOOP_1:%.*]]
; CHECK:       loop.1:
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.2:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[LOOP_1]] ], [ [[IV_NEXT:%.*]], [[LOOP_2]] ]
; CHECK-NEXT:    [[PTR_1:%.*]] = getelementptr inbounds [4 x i32], ptr [[M0]], i64 3, i64 [[IV]]
; CHECK-NEXT:    [[PTR_2:%.*]] = getelementptr inbounds [4 x i32], ptr [[M0]], i64 0, i64 [[IV]]
; CHECK-NEXT:    store i32 20, ptr [[PTR_2]], align 4
; CHECK-NEXT:    store i32 30, ptr [[PTR_1]], align 4
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[C_3:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C_3]], label [[LOOP_1_LATCH:%.*]], label [[LOOP_2]]
; CHECK:       loop.1.latch:
; CHECK-NEXT:    [[C_2:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C_2]], label [[EXIT:%.*]], label [[LOOP_1]]
; CHECK:       exit:
; CHECK-NEXT:    [[PTR_3:%.*]] = getelementptr inbounds [4 x i32], ptr [[M0]], i64 0, i64 1
; CHECK-NEXT:    [[LV:%.*]] = load i32, ptr [[PTR_3]], align 16
; CHECK-NEXT:    ret i32 [[LV]]
;
entry:
  %M0 = alloca [4 x i32], align 16
  br label %loop.1

loop.1:
  br label %loop.2

loop.2:
  %iv = phi i64 [ 0, %loop.1 ], [ %iv.next, %loop.2 ]
  %ptr.1 = getelementptr inbounds [4 x i32], ptr %M0, i64 3, i64 %iv
  store i32 10, ptr %ptr.1, align 4
  %ptr.2 = getelementptr inbounds [4 x i32], ptr %M0, i64 0, i64 %iv
  store i32 20, ptr %ptr.2, align 4
  store i32 30, ptr %ptr.1, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %c.3 = call i1 @cond()
  br i1 %c.3, label %loop.1.latch, label %loop.2

loop.1.latch:
  %c.2 = call i1 @cond()
  br i1 %c.2, label %exit, label %loop.1

exit:
  %ptr.3 = getelementptr inbounds [4 x i32], ptr %M0, i64 0, i64 1
  %lv = load i32, ptr %ptr.3, align 16
  ret i32 %lv
}

; No final read after clobbering.
define void @test1(i64 %arg) #0 {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [20 x i64], align 16
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_1:%.*]] = getelementptr inbounds [20 x i64], ptr [[ARRAY]], i64 0, i64 [[IV]]
; CHECK-NEXT:    store i64 0, ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[VAL:%.*]] = load i64, ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[VAL]], [[ARG:%.*]]
; CHECK-NEXT:    store i64 [[ADD]], ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i64 [[IV]], 4
; CHECK-NEXT:    br i1 [[COND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %array = alloca [20 x i64], align 16
  br label %loop

loop:                                                ; preds = %loop, %entry
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %ptr.1 = getelementptr inbounds [20 x i64], ptr %array, i64 0, i64 %iv
  store i64 0, ptr %ptr.1, align 8
  %val = load i64, ptr %ptr.1, align 8
  %add = add nsw i64 %val, %arg
  store i64 %add, ptr %ptr.1, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp ult i64 %iv, 4
  br i1 %cond, label %loop, label %exit

exit:                                                ; preds = %loop
  ret void
}

; Unused final read of %ptr.1 after clobbering it.
define void @test2(i64 %arg) #0 {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [20 x i64], align 16
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_1:%.*]] = getelementptr inbounds [20 x i64], ptr [[ARRAY]], i64 0, i64 [[IV]]
; CHECK-NEXT:    store i64 0, ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[VAL:%.*]] = load i64, ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[VAL]], [[ARG:%.*]]
; CHECK-NEXT:    store i64 [[ADD]], ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i64 [[IV]], 4
; CHECK-NEXT:    br i1 [[COND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[PTR_FIRST_ELEM:%.*]] = getelementptr inbounds [20 x i64], ptr [[ARRAY]], i64 0, i64 0
; CHECK-NEXT:    [[UNUSED_RV:%.*]] = load i64, ptr [[PTR_FIRST_ELEM]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %array = alloca [20 x i64], align 16
  br label %loop

loop:                                                ; preds = %loop, %entry
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %ptr.1 = getelementptr inbounds [20 x i64], ptr %array, i64 0, i64 %iv
  store i64 0, ptr %ptr.1, align 8
  %val = load i64, ptr %ptr.1, align 8
  %add = add nsw i64 %val, %arg
  store i64 %add, ptr %ptr.1, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp ult i64 %iv, 4
  br i1 %cond, label %loop, label %exit

exit:                                                ; preds = %loop
  %ptr.first.elem = getelementptr inbounds [20 x i64], ptr %array, i64 0, i64 0
  %unused_rv = load i64, ptr %ptr.first.elem, align 8
  ret void
}

; Used final read after clobbering %ptr.1.
define i64 @test3(i64 %arg) #0 {
; CHECK-LABEL: @test3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [20 x i64], align 16
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_1:%.*]] = getelementptr inbounds [20 x i64], ptr [[ARRAY]], i64 0, i64 [[IV]]
; CHECK-NEXT:    store i64 0, ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[VAL:%.*]] = load i64, ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[VAL]], [[ARG:%.*]]
; CHECK-NEXT:    store i64 [[ADD]], ptr [[PTR_1]], align 8
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i64 [[IV]], 4
; CHECK-NEXT:    br i1 [[COND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[PTR_FIRST_ELEM:%.*]] = getelementptr inbounds [20 x i64], ptr [[ARRAY]], i64 0, i64 0
; CHECK-NEXT:    [[RV:%.*]] = load i64, ptr [[PTR_FIRST_ELEM]], align 8
; CHECK-NEXT:    ret i64 [[RV]]
;
entry:
  %array = alloca [20 x i64], align 16
  br label %loop

loop:                                                ; preds = %loop, %entry
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %ptr.1 = getelementptr inbounds [20 x i64], ptr %array, i64 0, i64 %iv
  store i64 0, ptr %ptr.1, align 8
  %val = load i64, ptr %ptr.1, align 8
  %add = add nsw i64 %val, %arg
  store i64 %add, ptr %ptr.1, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp ult i64 %iv, 4
  br i1 %cond, label %loop, label %exit

exit:                                                ; preds = %loop
  %ptr.first.elem = getelementptr inbounds [20 x i64], ptr %array, i64 0, i64 0
  %rv = load i64, ptr %ptr.first.elem, align 8
  ret i64 %rv
}

; Used final read after clobbering %ptr.iv.2.
define i64 @test4() #0 {
; CHECK-LABEL: @test4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [20 x i64], align 16
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_IV:%.*]] = getelementptr inbounds [20 x i64], ptr [[ARRAY]], i64 0, i64 [[IV]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[IV]], 1
; CHECK-NEXT:    [[PTR_IV_2:%.*]] = getelementptr inbounds [20 x i64], ptr [[ARRAY]], i64 0, i64 [[ADD]]
; CHECK-NEXT:    store i64 10, ptr [[PTR_IV_2]], align 8
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i64 [[IV]], 4
; CHECK-NEXT:    br i1 [[COND]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[RV:%.*]] = load i64, ptr [[PTR_IV]], align 4
; CHECK-NEXT:    ret i64 [[RV]]
;
entry:
  %array = alloca [20 x i64], align 16
  br label %loop

loop:                                                ; preds = %loop, %entry
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %ptr.iv = getelementptr inbounds [20 x i64], ptr %array, i64 0, i64 %iv
  %add = add nsw i64 %iv, 1
  %ptr.iv.2 = getelementptr inbounds [20 x i64], ptr %array, i64 0, i64 %add
  store i64 10, ptr %ptr.iv.2, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp ult i64 %iv, 4
  br i1 %cond, label %loop, label %exit

exit:                                                ; preds = %loop
  %rv = load i64, ptr %ptr.iv
  ret i64 %rv
}

attributes #0 = { mustprogress }
