; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=dse -S -debug -disable-output %s 2>&1 | FileCheck %s
; REQUIRES: asserts

; Ensure MemoryDefs are visited bottom-up in eliminateDeadWritesAtEndOfFunction.

; CHECK:      Trying to eliminate MemoryDefs at the end of the function
; CHECK-NEXT:   Check if def 2 = MemoryDef(4) (  store i32 %sum, ptr %array.idx, align 4) is at the end the function
; CHECK-NEXT:   ... hit read clobber   call void @opaque(ptr noundef %array.idx).
; CHECK-NEXT:   Check if def 1 = MemoryDef(liveOnEntry) (  call void @llvm.memset.p0.i64(ptr noundef %array, i8 0, i64 100, i1 false)) is at the end the function
; CHECK-NEXT:   ... hit read clobber   %array.curr = load i32, ptr %array.idx, align 4.
define void @reverse_post_order_traversal_visit_test(ptr noundef %A) {
entry:
  %array = alloca [25 x i32], align 16
  call void @llvm.memset.p0.i64(ptr noundef %array, i8 0, i64 100, i1 false)
  br label %loop

loop:                                             ; preds = %loop, %entry
  %array.prev = phi i32 [ 0, %entry ], [ %sum, %loop ]
  %iv = phi i64 [ 1, %entry ], [ %iv.next, %loop ]
  %A.idx = getelementptr inbounds i32, ptr %A, i64 %iv
  %A.curr = load i32, ptr %A.idx, align 4
  %A.curr.sum.array.prev = add nsw i32 %A.curr, %array.prev
  %array.idx = getelementptr inbounds [25 x i32], ptr %array, i64 0, i64 %iv
  %array.curr = load i32, ptr %array.idx, align 4
  %sum = add nsw i32 %A.curr.sum.array.prev, %array.curr
  store i32 %sum, ptr %array.idx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp eq i64 %iv.next, 25
  br i1 %cond, label %exit, label %loop

exit:                                             ; preds = %loop
  call void @opaque(ptr noundef %array.idx)
  ret void
}

declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)
declare void @opaque(ptr)
