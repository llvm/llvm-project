; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -passes=dse < %s | FileCheck %s
;
; DSE kills both `store i32 44, ptr %struct.byte.4, align 4` and
; `call void @llvm.memset.p0.i64(...)` but the memset should not be killed
; because it has a clobber read: `%ret = load ptr, ptr %struct.byte.8`

%struct.type = type { ptr, ptr }

define ptr @foo(ptr noundef %ptr) {
; CHECK-LABEL: define ptr @foo(
; CHECK-SAME: ptr noundef [[PTR:%.*]]) {
; CHECK-NEXT:    [[STRUCT_ALLOCA:%.*]] = alloca [[STRUCT_TYPE:%.*]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 56, ptr nonnull [[STRUCT_ALLOCA]]) #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    [[STRUCT_BYTE_8:%.*]] = getelementptr inbounds i8, ptr [[STRUCT_ALLOCA]], i64 8
; CHECK-NEXT:    store i32 43, ptr [[STRUCT_BYTE_8]], align 4
; CHECK-NEXT:    [[RET:%.*]] = load ptr, ptr [[STRUCT_BYTE_8]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 56, ptr nonnull [[STRUCT_ALLOCA]]) #[[ATTR2]]
; CHECK-NEXT:    ret ptr [[RET]]
;
  %struct.alloca = alloca %struct.type, align 8
  call void @llvm.lifetime.start.p0(i64 56, ptr nonnull %struct.alloca) nounwind
  %struct.byte.8 = getelementptr inbounds i8, ptr %struct.alloca, i64 8
  ; Set %struct.alloca[8, 16) to 42.
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 %struct.byte.8, i8 42, i64 8, i1 false)
  ; Set %struct.alloca[8, 12) to 43.
  store i32 43, ptr %struct.byte.8, align 4
  ; Set %struct.alloca[4, 8) to 44.
  %struct.byte.4 = getelementptr inbounds i8, ptr %struct.alloca, i64 4
  store i32 44, ptr %struct.byte.4, align 4
  ; Return %struct.alloca[8, 16).
  %ret = load ptr, ptr %struct.byte.8
  call void @llvm.lifetime.end.p0(i64 56, ptr nonnull %struct.alloca) nounwind
  ret ptr %ret
}

declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #0
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #2
