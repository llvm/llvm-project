; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=loop-idiom < %s -S | FileCheck %s

%memcmp_idiom_arr = type { [50 x i32] }
define i1 @memcmp_idiom(ptr byval(%memcmp_idiom_arr) align 8 %lhs, ptr byval(%memcmp_idiom_arr) align 8 %rhs) {
; CHECK-LABEL: define i1 @memcmp_idiom(
; CHECK-SAME: ptr byval([[MEMCMP_IDIOM_ARR:%.*]]) align 8 [[LHS:%.*]], ptr byval([[MEMCMP_IDIOM_ARR]]) align 8 [[RHS:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[BODY:.*]]
; CHECK:       [[COND:.*]]:
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i64 [[INDVAR:%.*]], 1
; CHECK-NEXT:    [[STOP_LOOP:%.*]] = icmp eq i64 [[INC]], 50
; CHECK-NEXT:    br i1 [[STOP_LOOP]], label %[[EXIT:.*]], label %[[BODY]]
; CHECK:       [[BODY]]:
; CHECK-NEXT:    [[INDVAR]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC]], %[[COND]] ]
; CHECK-NEXT:    [[LHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[LHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[RHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[RHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[LHS_VAL:%.*]] = load i32, ptr [[LHS_ADDR]], align 4
; CHECK-NEXT:    [[RHS_VAL:%.*]] = load i32, ptr [[RHS_ADDR]], align 4
; CHECK-NEXT:    [[EQUAL:%.*]] = icmp eq i32 [[LHS_VAL]], [[RHS_VAL]]
; CHECK-NEXT:    br i1 [[EQUAL]], label %[[COND]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[LHS]], ptr [[RHS]], i64 200)
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i32 [[MEMCMP]], 0
; CHECK-NEXT:    ret i1 [[TMP0]]
;
entry:
  br label %body
cond:
  %inc = add nuw nsw i64 %indvar, 1
  %stop_loop = icmp eq i64 %inc, 50
  br i1 %stop_loop, label %exit, label %body
body:
  %indvar = phi i64 [ 0, %entry ], [ %inc, %cond ]
  %lhs_addr = getelementptr inbounds nuw i32, ptr %lhs, i64 %indvar
  %rhs_addr = getelementptr inbounds nuw i32, ptr %rhs, i64 %indvar
  %lhs_val = load i32, ptr %lhs_addr, align 4
  %rhs_val = load i32, ptr %rhs_addr, align 4
  %equal = icmp eq i32 %lhs_val, %rhs_val
  br i1 %equal, label %cond, label %exit
exit:
  %ret = phi i1 [ %equal, %body ], [ %equal, %cond ]
  ret i1 %ret
}

%too_short_arr = type { [49 x i32] }
define i1 @no_memcmp_idiom_array_too_short(ptr byval(%too_short_arr) align 8 %lhs, ptr byval(%too_short_arr) align 8 %rhs) {
; CHECK-LABEL: define i1 @no_memcmp_idiom_array_too_short(
; CHECK-SAME: ptr byval([[TOO_SHORT_ARR:%.*]]) align 8 [[LHS:%.*]], ptr byval([[TOO_SHORT_ARR]]) align 8 [[RHS:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[BODY:.*]]
; CHECK:       [[COND:.*]]:
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i64 [[INDVAR:%.*]], 1
; CHECK-NEXT:    [[STOP_LOOP:%.*]] = icmp eq i64 [[INC]], 50
; CHECK-NEXT:    br i1 [[STOP_LOOP]], label %[[EXIT:.*]], label %[[BODY]]
; CHECK:       [[BODY]]:
; CHECK-NEXT:    [[INDVAR]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC]], %[[COND]] ]
; CHECK-NEXT:    [[LHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[LHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[RHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[RHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[LHS_VAL:%.*]] = load i32, ptr [[LHS_ADDR]], align 4
; CHECK-NEXT:    [[RHS_VAL:%.*]] = load i32, ptr [[RHS_ADDR]], align 4
; CHECK-NEXT:    [[EQUAL:%.*]] = icmp eq i32 [[LHS_VAL]], [[RHS_VAL]]
; CHECK-NEXT:    br i1 [[EQUAL]], label %[[COND]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[RET:%.*]] = phi i1 [ [[EQUAL]], %[[BODY]] ], [ [[EQUAL]], %[[COND]] ]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  br label %body
cond:
  %inc = add nuw nsw i64 %indvar, 1
  %stop_loop = icmp eq i64 %inc, 50
  br i1 %stop_loop, label %exit, label %body
body:
  %indvar = phi i64 [ 0, %entry ], [ %inc, %cond ]
  %lhs_addr = getelementptr inbounds nuw i32, ptr %lhs, i64 %indvar
  %rhs_addr = getelementptr inbounds nuw i32, ptr %rhs, i64 %indvar
  %lhs_val = load i32, ptr %lhs_addr, align 4
  %rhs_val = load i32, ptr %rhs_addr, align 4
  %equal = icmp eq i32 %lhs_val, %rhs_val
  br i1 %equal, label %cond, label %exit
exit:
  %ret = phi i1 [ %equal, %body ], [ %equal, %cond ]
  ret i1 %ret
}

%has_padding_arr = type { [50 x i36] }
define i1 @no_memcmp_idiom_array_has_padding(ptr byval(%has_padding_arr) align 8 %lhs, ptr byval(%has_padding_arr) align 8 %rhs) {
; CHECK-LABEL: define i1 @no_memcmp_idiom_array_has_padding(
; CHECK-SAME: ptr byval([[HAS_PADDING_ARR:%.*]]) align 8 [[LHS:%.*]], ptr byval([[HAS_PADDING_ARR]]) align 8 [[RHS:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[BODY:.*]]
; CHECK:       [[COND:.*]]:
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i64 [[INDVAR:%.*]], 1
; CHECK-NEXT:    [[STOP_LOOP:%.*]] = icmp eq i64 [[INC]], 50
; CHECK-NEXT:    br i1 [[STOP_LOOP]], label %[[EXIT:.*]], label %[[BODY]]
; CHECK:       [[BODY]]:
; CHECK-NEXT:    [[INDVAR]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC]], %[[COND]] ]
; CHECK-NEXT:    [[LHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[LHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[RHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[RHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[LHS_VAL:%.*]] = load i36, ptr [[LHS_ADDR]], align 4
; CHECK-NEXT:    [[RHS_VAL:%.*]] = load i36, ptr [[RHS_ADDR]], align 4
; CHECK-NEXT:    [[EQUAL:%.*]] = icmp eq i36 [[LHS_VAL]], [[RHS_VAL]]
; CHECK-NEXT:    br i1 [[EQUAL]], label %[[COND]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[RET:%.*]] = phi i1 [ [[EQUAL]], %[[BODY]] ], [ [[EQUAL]], %[[COND]] ]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  br label %body
cond:
  %inc = add nuw nsw i64 %indvar, 1
  %stop_loop = icmp eq i64 %inc, 50
  br i1 %stop_loop, label %exit, label %body
body:
  %indvar = phi i64 [ 0, %entry ], [ %inc, %cond ]
  %lhs_addr = getelementptr inbounds nuw i32, ptr %lhs, i64 %indvar
  %rhs_addr = getelementptr inbounds nuw i32, ptr %rhs, i64 %indvar
  %lhs_val = load i36, ptr %lhs_addr, align 4
  %rhs_val = load i36, ptr %rhs_addr, align 4
  %equal = icmp eq i36 %lhs_val, %rhs_val
  br i1 %equal, label %cond, label %exit
exit:
  %ret = phi i1 [ %equal, %body ], [ %equal, %cond ]
  ret i1 %ret
}

%mismatched_stride_arr = type { [100 x i32] }
define i1 @no_memcmp_idiom_mismatched_stride(ptr byval(%mismatched_stride_arr) align 8 %lhs, ptr byval(%mismatched_stride_arr) align 8 %rhs) {
; CHECK-LABEL: define i1 @no_memcmp_idiom_mismatched_stride(
; CHECK-SAME: ptr byval([[MISMATCHED_STRIDE_ARR:%.*]]) align 8 [[LHS:%.*]], ptr byval([[MISMATCHED_STRIDE_ARR]]) align 8 [[RHS:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[BODY:.*]]
; CHECK:       [[COND:.*]]:
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i64 [[INDVAR:%.*]], 1
; CHECK-NEXT:    [[STOP_LOOP:%.*]] = icmp eq i64 [[INC]], 50
; CHECK-NEXT:    br i1 [[STOP_LOOP]], label %[[EXIT:.*]], label %[[BODY]]
; CHECK:       [[BODY]]:
; CHECK-NEXT:    [[INDVAR]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC]], %[[COND]] ]
; CHECK-NEXT:    [[DOUBLEINDVAR:%.*]] = mul i64 [[INDVAR]], 2
; CHECK-NEXT:    [[LHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[LHS]], i64 [[DOUBLEINDVAR]]
; CHECK-NEXT:    [[RHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[RHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[LHS_VAL:%.*]] = load i32, ptr [[LHS_ADDR]], align 4
; CHECK-NEXT:    [[RHS_VAL:%.*]] = load i32, ptr [[RHS_ADDR]], align 4
; CHECK-NEXT:    [[EQUAL:%.*]] = icmp eq i32 [[LHS_VAL]], [[RHS_VAL]]
; CHECK-NEXT:    br i1 [[EQUAL]], label %[[COND]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i1 [ [[EQUAL]], %[[BODY]] ], [ [[EQUAL]], %[[COND]] ]
; CHECK-NEXT:    ret i1 [[TMP0]]
;
entry:
  br label %body
cond:
  %inc = add nuw nsw i64 %indvar, 1
  %stop_loop = icmp eq i64 %inc, 50
  br i1 %stop_loop, label %exit, label %body
body:
  %indvar = phi i64 [ 0, %entry ], [ %inc, %cond ]
  %doubleindvar = mul i64 %indvar, 2
  %lhs_addr = getelementptr inbounds nuw i32, ptr %lhs, i64 %doubleindvar
  %rhs_addr = getelementptr inbounds nuw i32, ptr %rhs, i64 %indvar
  %lhs_val = load i32, ptr %lhs_addr, align 4
  %rhs_val = load i32, ptr %rhs_addr, align 4
  %equal = icmp eq i32 %lhs_val, %rhs_val
  br i1 %equal, label %cond, label %exit
exit:
  %ret = phi i1 [ %equal, %body ], [ %equal, %cond ]
  ret i1 %ret
}

define i1 @no_memcmp_idiom_volatile_loads(ptr byval(%memcmp_idiom_arr) align 8 %lhs, ptr byval(%memcmp_idiom_arr) align 8 %rhs) {
; CHECK-LABEL: define i1 @no_memcmp_idiom_volatile_loads(
; CHECK-SAME: ptr byval([[MEMCMP_IDIOM_ARR:%.*]]) align 8 [[LHS:%.*]], ptr byval([[MEMCMP_IDIOM_ARR]]) align 8 [[RHS:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[BODY:.*]]
; CHECK:       [[COND:.*]]:
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i64 [[INDVAR:%.*]], 1
; CHECK-NEXT:    [[STOP_LOOP:%.*]] = icmp eq i64 [[INC]], 50
; CHECK-NEXT:    br i1 [[STOP_LOOP]], label %[[EXIT:.*]], label %[[BODY]]
; CHECK:       [[BODY]]:
; CHECK-NEXT:    [[INDVAR]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC]], %[[COND]] ]
; CHECK-NEXT:    [[LHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[LHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[RHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[RHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[LHS_VAL:%.*]] = load volatile i32, ptr [[LHS_ADDR]], align 4
; CHECK-NEXT:    [[RHS_VAL:%.*]] = load volatile i32, ptr [[RHS_ADDR]], align 4
; CHECK-NEXT:    [[EQUAL:%.*]] = icmp eq i32 [[LHS_VAL]], [[RHS_VAL]]
; CHECK-NEXT:    br i1 [[EQUAL]], label %[[COND]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i1 [ [[EQUAL]], %[[BODY]] ], [ [[EQUAL]], %[[COND]] ]
; CHECK-NEXT:    ret i1 [[TMP0]]
;
entry:
  br label %body
cond:
  %inc = add nuw nsw i64 %indvar, 1
  %stop_loop = icmp eq i64 %inc, 50
  br i1 %stop_loop, label %exit, label %body
body:
  %indvar = phi i64 [ 0, %entry ], [ %inc, %cond ]
  %lhs_addr = getelementptr inbounds nuw i32, ptr %lhs, i64 %indvar
  %rhs_addr = getelementptr inbounds nuw i32, ptr %rhs, i64 %indvar
  %lhs_val = load volatile i32, ptr %lhs_addr, align 4
  %rhs_val = load volatile i32, ptr %rhs_addr, align 4
  %equal = icmp eq i32 %lhs_val, %rhs_val
  br i1 %equal, label %cond, label %exit
exit:
  %ret = phi i1 [ %equal, %body ], [ %equal, %cond ]
  ret i1 %ret
}

%float_arr = type { [50 x float] }
define i1 @no_memcmp_idiom_float_comparisons(ptr byval(%float_arr) align 8 %lhs, ptr byval(%float_arr) align 8 %rhs) {
; CHECK-LABEL: define i1 @no_memcmp_idiom_float_comparisons(
; CHECK-SAME: ptr byval([[FLOAT_ARR:%.*]]) align 8 [[LHS:%.*]], ptr byval([[FLOAT_ARR]]) align 8 [[RHS:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[BODY:.*]]
; CHECK:       [[COND:.*]]:
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i64 [[INDVAR:%.*]], 1
; CHECK-NEXT:    [[STOP_LOOP:%.*]] = icmp eq i64 [[INC]], 50
; CHECK-NEXT:    br i1 [[STOP_LOOP]], label %[[EXIT:.*]], label %[[BODY]]
; CHECK:       [[BODY]]:
; CHECK-NEXT:    [[INDVAR]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC]], %[[COND]] ]
; CHECK-NEXT:    [[LHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[LHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[RHS_ADDR:%.*]] = getelementptr inbounds nuw i32, ptr [[RHS]], i64 [[INDVAR]]
; CHECK-NEXT:    [[LHS_VAL:%.*]] = load float, ptr [[LHS_ADDR]], align 4
; CHECK-NEXT:    [[RHS_VAL:%.*]] = load float, ptr [[RHS_ADDR]], align 4
; CHECK-NEXT:    [[EQUAL:%.*]] = fcmp oeq float [[LHS_VAL]], [[RHS_VAL]]
; CHECK-NEXT:    br i1 [[EQUAL]], label %[[COND]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i1 [ [[EQUAL]], %[[BODY]] ], [ [[EQUAL]], %[[COND]] ]
; CHECK-NEXT:    ret i1 [[TMP0]]
;
entry:
  br label %body
cond:
  %inc = add nuw nsw i64 %indvar, 1
  %stop_loop = icmp eq i64 %inc, 50
  br i1 %stop_loop, label %exit, label %body
body:
  %indvar = phi i64 [ 0, %entry ], [ %inc, %cond ]
  %lhs_addr = getelementptr inbounds nuw i32, ptr %lhs, i64 %indvar
  %rhs_addr = getelementptr inbounds nuw i32, ptr %rhs, i64 %indvar
  %lhs_val = load float, ptr %lhs_addr, align 4
  %rhs_val = load float, ptr %rhs_addr, align 4
  %equal = fcmp oeq float %lhs_val, %rhs_val
  br i1 %equal, label %cond, label %exit
exit:
  %ret = phi i1 [ %equal, %body ], [ %equal, %cond ]
  ret i1 %ret
}
