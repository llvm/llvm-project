; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='loop-idiom' < %s -S | FileCheck %s

declare void @use(ptr)

define i64 @valid_strlen_1(ptr %0) {
; CHECK-LABEL: define i64 @valid_strlen_1(
; CHECK-SAME: ptr [[TMP0:%.*]]) {
; CHECK-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(ptr [[TMP0]])
; CHECK-NEXT:    [[DOTLCSSA:%.*]] = getelementptr i8, ptr [[TMP0]], i64 [[STRLEN]]
; CHECK-NEXT:    br label %[[BB2:.*]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i8 poison, 0
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i8, ptr poison, i64 1
; CHECK-NEXT:    br i1 true, label %[[BB5:.*]], label %[[BB2]]
; CHECK:       [[BB5]]:
; CHECK-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[DOTLCSSA]] to i64
; CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr [[TMP0]] to i64
; CHECK-NEXT:    [[TMP14:%.*]] = sub i64 [[TMP12]], [[TMP13]]
; CHECK-NEXT:    ret i64 [[TMP14]]
;
  br label %2

2:                                                ; preds = %2, %1
  %3 = phi ptr [ %0, %1 ], [ %6, %2 ]
  %4 = load i8, ptr %3, align 1
  %5 = icmp eq i8 %4, 0
  %6 = getelementptr inbounds i8, ptr %3, i64 1
  br i1 %5, label %7, label %2

7:                                                ; preds = %2
  %8 = ptrtoint ptr %3 to i64
  %9 = ptrtoint ptr %0 to i64
  %10 = sub i64 %8, %9
  ret i64 %10
}


define i32 @valid_strlen_2(ptr %0) {
; CHECK-LABEL: define i32 @valid_strlen_2(
; CHECK-SAME: ptr [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq ptr [[TMP0]], null
; CHECK-NEXT:    br i1 [[TMP2]], label %[[BB14:.*]], label %[[BB3:.*]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i8 [[TMP4]], 0
; CHECK-NEXT:    br i1 [[TMP5]], label %[[BB14]], label %[[DOTPREHEADER:.*]]
; CHECK:       [[_PREHEADER:.*:]]
; CHECK-NEXT:    [[STR:%.*]] = getelementptr i8, ptr [[TMP0]], i64 0
; CHECK-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(ptr [[STR]])
; CHECK-NEXT:    [[STR_ADDR_0_LCSSA:%.*]] = getelementptr i8, ptr [[STR]], i64 [[STRLEN]]
; CHECK-NEXT:    br label %[[BB6:.*]]
; CHECK:       [[BB6]]:
; CHECK-NEXT:    [[TMP7:%.*]] = phi ptr [ poison, %[[BB6]] ], [ [[TMP0]], %[[DOTPREHEADER]] ]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 poison, 0
; CHECK-NEXT:    br i1 true, label %[[BB9:.*]], label %[[BB6]]
; CHECK:       [[BB9]]:
; CHECK-NEXT:    [[SUB_PTR_LHS_CAST:%.*]] = ptrtoint ptr [[STR_ADDR_0_LCSSA]] to i64
; CHECK-NEXT:    [[SUB_PTR_RHS_CAST:%.*]] = ptrtoint ptr [[TMP0]] to i64
; CHECK-NEXT:    [[SUB_PTR_SUB:%.*]] = sub i64 [[SUB_PTR_LHS_CAST]], [[SUB_PTR_RHS_CAST]]
; CHECK-NEXT:    [[TMP13:%.*]] = trunc i64 [[SUB_PTR_SUB]] to i32
; CHECK-NEXT:    br label %[[BB14]]
; CHECK:       [[BB14]]:
; CHECK-NEXT:    [[TMP15:%.*]] = phi i32 [ [[TMP13]], %[[BB9]] ], [ 0, %[[BB3]] ], [ 0, [[TMP1:%.*]] ]
; CHECK-NEXT:    ret i32 [[TMP15]]
;
  %2 = icmp eq ptr %0, null
  br i1 %2, label %16, label %3

3:                                                ; preds = %1
  %4 = load i8, ptr %0, align 1
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %16, label %6

6:                                                ; preds = %3, %6
  %7 = phi ptr [ %8, %6 ], [ %0, %3 ]
  %8 = getelementptr inbounds i8, ptr %7, i64 1
  %9 = load i8, ptr %8, align 1
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %6

11:                                               ; preds = %6
  %12 = ptrtoint ptr %8 to i64
  %13 = ptrtoint ptr %0 to i64
  %14 = sub i64 %12, %13
  %15 = trunc i64 %14 to i32
  br label %16

16:                                               ; preds = %1, %3, %11
  %17 = phi i32 [ %15, %11 ], [ 0, %3 ], [ 0, %1 ]
  ret i32 %17
}

define i64 @valid_strlen_3(ptr %str) local_unnamed_addr #0 {
; CHECK-LABEL: define i64 @valid_strlen_3(
; CHECK-SAME: ptr [[STR:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  [[_PREHEADER:.*:]]
; CHECK-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(ptr [[STR]])
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[STR]], i64 [[STRLEN]]
; CHECK-NEXT:    br label %[[WHILE_COND:.*]]
; CHECK:       [[WHILE_COND]]:
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i8 poison, 0
; CHECK-NEXT:    [[INCDEC_PTR:%.*]] = getelementptr inbounds i8, ptr poison, i64 1
; CHECK-NEXT:    br i1 true, label %[[WHILE_END:.*]], label %[[WHILE_COND]]
; CHECK:       [[WHILE_END]]:
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint ptr [[TMP0]] to i64
; CHECK-NEXT:    [[SUB_PTR_RHS_CAST:%.*]] = ptrtoint ptr [[STR]] to i64
; CHECK-NEXT:    [[TMP13:%.*]] = sub i64 [[TMP10]], [[SUB_PTR_RHS_CAST]]
; CHECK-NEXT:    tail call void @use(ptr [[TMP0]])
; CHECK-NEXT:    tail call void @use(ptr [[STR]])
; CHECK-NEXT:    ret i64 [[TMP13]]
;
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %str.addr.0 = phi ptr [ %str, %entry ], [ %incdec.ptr, %while.cond ]
  %0 = load i8, ptr %str.addr.0, align 1
  %cmp.not = icmp eq i8 %0, 0
  %incdec.ptr = getelementptr inbounds i8, ptr %str.addr.0, i64 1
  br i1 %cmp.not, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  %sub.ptr.lhs.cast = ptrtoint ptr %str.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %str to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  tail call void @use(ptr %str.addr.0)
  tail call void @use(ptr %str)
  ret i64 %sub.ptr.sub
}

define i64 @valid_strlen_4(ptr %0) {
; CHECK-LABEL: define i64 @valid_strlen_4(
; CHECK-SAME: ptr [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq ptr [[TMP0]], null
; CHECK-NEXT:    br i1 [[TMP2]], label %[[BB10:.*]], label %[[DOTPREHEADER:.*]]
; CHECK:       [[_PREHEADER:.*:]]
; CHECK-NEXT:    [[NEWGEP:%.*]] = getelementptr i8, ptr [[TMP0]], i64 0
; CHECK-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(ptr [[NEWGEP]])
; CHECK-NEXT:    [[END:%.*]] = getelementptr i8, ptr [[NEWGEP]], i64 [[STRLEN]]
; CHECK-NEXT:    br label %[[BB3:.*]]
; CHECK:       [[BB3]]:
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ poison, %[[BB3]] ], [ [[TMP0]], %[[DOTPREHEADER]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i8 poison, 0
; CHECK-NEXT:    br i1 true, label %[[BB6:.*]], label %[[BB3]]
; CHECK:       [[BB6]]:
; CHECK-NEXT:    [[TMP7:%.*]] = ptrtoint ptr [[END]] to i64
; CHECK-NEXT:    [[TMP8:%.*]] = ptrtoint ptr [[TMP0]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = sub i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br label %[[BB10]]
; CHECK:       [[BB10]]:
; CHECK-NEXT:    [[TMP11:%.*]] = phi i64 [ [[TMP9]], %[[BB6]] ], [ 0, [[TMP1:%.*]] ]
; CHECK-NEXT:    ret i64 [[TMP11]]
;
  %2 = icmp eq ptr %0, null
  br i1 %2, label %12, label %3

3:                                                ; preds = %1, %3
  %4 = phi ptr [ %5, %3 ], [ %0, %1 ]
  %5 = getelementptr inbounds i8, ptr %4, i64 1
  %6 = load i8, ptr %5, align 1
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %3

8:                                                ; preds = %3
  %9 = ptrtoint ptr %5 to i64
  %10 = ptrtoint ptr %0 to i64
  %11 = sub i64 %9, %10
  br label %12

12:                                               ; preds = %1, %8
  %13 = phi i64 [ %11, %8 ], [ 0, %1 ]
  ret i64 %13
}

define i64 @valid_strlen_use(ptr %str) {
; CHECK-LABEL: define i64 @valid_strlen_use(
; CHECK-SAME: ptr [[STR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(ptr [[STR]])
; CHECK-NEXT:    [[END:%.*]] = getelementptr i8, ptr [[STR]], i64 [[STRLEN]]
; CHECK-NEXT:    br label %[[WHILE_COND:.*]]
; CHECK:       [[WHILE_COND]]:
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 poison, 0
; CHECK-NEXT:    [[INCDEC_PTR:%.*]] = getelementptr inbounds i8, ptr poison, i64 1
; CHECK-NEXT:    br i1 true, label %[[WHILE_END:.*]], label %[[WHILE_COND]]
; CHECK:       [[WHILE_END]]:
; CHECK-NEXT:    [[SUB_PTR_LHS_CAST:%.*]] = ptrtoint ptr [[END]] to i64
; CHECK-NEXT:    [[SUB_PTR_RHS_CAST:%.*]] = ptrtoint ptr [[STR]] to i64
; CHECK-NEXT:    [[SUB_PTR_SUB:%.*]] = sub i64 [[SUB_PTR_LHS_CAST]], [[SUB_PTR_RHS_CAST]]
; CHECK-NEXT:    tail call void @use(ptr noundef nonnull [[END]])
; CHECK-NEXT:    tail call void @use(ptr noundef [[STR]])
; CHECK-NEXT:    ret i64 [[SUB_PTR_SUB]]
;
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %str.addr.0 = phi ptr [ %str, %entry ], [ %incdec.ptr, %while.cond ]
  %0 = load i8, ptr %str.addr.0, align 1
  %cmp.not = icmp eq i8 %0, 0
  %incdec.ptr = getelementptr inbounds i8, ptr %str.addr.0, i64 1
  br i1 %cmp.not, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  %sub.ptr.lhs.cast = ptrtoint ptr %str.addr.0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %str to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  tail call void @use(ptr noundef nonnull %str.addr.0)
  tail call void @use(ptr noundef %str)
  ret i64 %sub.ptr.sub
}

define i64 @invalid_strlen_has_side_effect(ptr %0) {
; CHECK-LABEL: define i64 @invalid_strlen_has_side_effect(
; CHECK-SAME: ptr [[TMP0:%.*]]) {
; CHECK-NEXT:    br label %[[BB2:.*]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi ptr [ [[TMP0]], [[TMP1:%.*]] ], [ [[TMP6:%.*]], %[[BB2]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = load volatile i8, ptr [[TMP3]], align 1
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i8 [[TMP4]], 0
; CHECK-NEXT:    [[TMP6]] = getelementptr inbounds i8, ptr [[TMP3]], i64 1
; CHECK-NEXT:    br i1 [[TMP5]], label %[[BB7:.*]], label %[[BB2]]
; CHECK:       [[BB7]]:
; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi ptr [ [[TMP3]], %[[BB2]] ]
; CHECK-NEXT:    [[TMP8:%.*]] = ptrtoint ptr [[DOTLCSSA]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = ptrtoint ptr [[TMP0]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = sub i64 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    ret i64 [[TMP10]]
;
  br label %2

2:                                                ; preds = %2, %1
  %3 = phi ptr [ %0, %1 ], [ %6, %2 ]
  %4 = load volatile i8, ptr %3, align 1
  %5 = icmp eq i8 %4, 0
  %6 = getelementptr inbounds i8, ptr %3, i64 1
  br i1 %5, label %7, label %2

7:                                                ; preds = %2
  %8 = ptrtoint ptr %3 to i64
  %9 = ptrtoint ptr %0 to i64
  %10 = sub i64 %8, %9
  ret i64 %10
}

define i64 @invalid_strlen_idx_idiom(ptr %0) {
; CHECK-LABEL: define i64 @invalid_strlen_idx_idiom(
; CHECK-SAME: ptr [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i8 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[TMP3]], label %[[BB13:.*]], label %[[DOTPREHEADER:.*]]
; CHECK:       [[_PREHEADER:.*:]]
; CHECK-NEXT:    br label %[[BB4:.*]]
; CHECK:       [[BB4]]:
; CHECK-NEXT:    [[TMP5:%.*]] = phi i32 [ [[TMP7:%.*]], %[[BB4]] ], [ 0, %[[DOTPREHEADER]] ]
; CHECK-NEXT:    [[TMP6:%.*]] = phi ptr [ [[TMP8:%.*]], %[[BB4]] ], [ [[TMP0]], %[[DOTPREHEADER]] ]
; CHECK-NEXT:    [[TMP7]] = add nuw nsw i32 [[TMP5]], 1
; CHECK-NEXT:    [[TMP8]] = getelementptr inbounds i8, ptr [[TMP6]], i64 1
; CHECK-NEXT:    [[TMP9:%.*]] = load i8, ptr [[TMP8]], align 1
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i8 [[TMP9]], 0
; CHECK-NEXT:    br i1 [[TMP10]], label %[[BB11:.*]], label %[[BB4]]
; CHECK:       [[BB11]]:
; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi i32 [ [[TMP7]], %[[BB4]] ]
; CHECK-NEXT:    [[TMP12:%.*]] = zext nneg i32 [[DOTLCSSA]] to i64
; CHECK-NEXT:    br label %[[BB13]]
; CHECK:       [[BB13]]:
; CHECK-NEXT:    [[TMP14:%.*]] = phi i64 [ 0, [[TMP1:%.*]] ], [ [[TMP12]], %[[BB11]] ]
; CHECK-NEXT:    ret i64 [[TMP14]]
;
  %2 = load i8, ptr %0, align 1
  %3 = icmp eq i8 %2, 0
  br i1 %3, label %13, label %4

4:                                                ; preds = %1, %4
  %5 = phi i32 [ %7, %4 ], [ 0, %1 ]
  %6 = phi ptr [ %8, %4 ], [ %0, %1 ]
  %7 = add nuw nsw i32 %5, 1
  %8 = getelementptr inbounds i8, ptr %6, i64 1
  %9 = load i8, ptr %8, align 1
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %4

11:                                               ; preds = %4
  %12 = zext nneg i32 %7 to i64
  br label %13

13:                                               ; preds = %11, %1
  %14 = phi i64 [ 0, %1 ], [ %12, %11 ]
  ret i64 %14
}


