; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=loop-idiom < %s -S | FileCheck %s

; If the loop is dedicated one that transfers content from the source to the
; destination but we don't know if they are alias, version the loop.
define dso_local void @issue50892(ptr %dst, i64 noundef %d_len, ptr %src) {
; CHECK-LABEL: define dso_local void @issue50892(
; CHECK-SAME: ptr [[DST:%.*]], i64 noundef [[D_LEN:%.*]], ptr [[SRC:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DST1:%.*]] = ptrtoint ptr [[DST]] to i64
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw i8, ptr [[DST]], i64 [[D_LEN]]
; CHECK-NEXT:    [[CMP4_NOT:%.*]] = icmp eq i64 [[D_LEN]], 0
; CHECK-NEXT:    br i1 [[CMP4_NOT]], label %[[WHILE_END:.*]], label %[[WHILE_BODY_LVER_CHECK:.*]]
; CHECK:       [[WHILE_BODY_LVER_CHECK]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[D_LEN]], [[DST1]]
; CHECK-NEXT:    [[TMP1:%.*]] = add i64 [[DST1]], 1
; CHECK-NEXT:    [[UMAX:%.*]] = call i64 @llvm.umax.i64(i64 [[TMP0]], i64 [[TMP1]])
; CHECK-NEXT:    [[TMP2:%.*]] = sub i64 [[UMAX]], [[DST1]]
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[DST]], i64 [[TMP2]]
; CHECK-NEXT:    [[SCEVGEP2:%.*]] = getelementptr i8, ptr [[SRC]], i64 [[TMP2]]
; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ult ptr [[DST]], [[SCEVGEP2]]
; CHECK-NEXT:    [[BOUND1:%.*]] = icmp ult ptr [[SRC]], [[SCEVGEP]]
; CHECK-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]
; CHECK-NEXT:    [[TMP3:%.*]] = add i64 [[D_LEN]], [[DST1]]
; CHECK-NEXT:    [[TMP4:%.*]] = add i64 [[DST1]], 1
; CHECK-NEXT:    [[UMAX4:%.*]] = call i64 @llvm.umax.i64(i64 [[TMP3]], i64 [[TMP4]])
; CHECK-NEXT:    [[TMP9:%.*]] = add i64 [[UMAX4]], -1
; CHECK-NEXT:    [[TMP10:%.*]] = sub i64 [[TMP9]], [[DST1]]
; CHECK-NEXT:    [[TMP11:%.*]] = icmp slt i64 [[TMP10]], 12
; CHECK-NEXT:    [[TMP8:%.*]] = or i1 [[FOUND_CONFLICT]], [[TMP11]]
; CHECK-NEXT:    [[TMP5:%.*]] = sub i64 [[UMAX4]], [[DST1]]
; CHECK-NEXT:    br i1 [[TMP8]], label %[[WHILE_BODY_PH_LVER_ORIG:.*]], label %[[WHILE_BODY_PH:.*]]
; CHECK:       [[WHILE_BODY_PH_LVER_ORIG]]:
; CHECK-NEXT:    br label %[[WHILE_BODY_LVER_ORIG:.*]]
; CHECK:       [[WHILE_BODY_LVER_ORIG]]:
; CHECK-NEXT:    [[DST_ADDR_06_LVER_ORIG:%.*]] = phi ptr [ [[INCDEC_PTR1_LVER_ORIG:%.*]], %[[WHILE_BODY_LVER_ORIG]] ], [ [[DST]], %[[WHILE_BODY_PH_LVER_ORIG]] ]
; CHECK-NEXT:    [[SRC_ADDR_05_LVER_ORIG:%.*]] = phi ptr [ [[INCDEC_PTR_LVER_ORIG:%.*]], %[[WHILE_BODY_LVER_ORIG]] ], [ [[SRC]], %[[WHILE_BODY_PH_LVER_ORIG]] ]
; CHECK-NEXT:    [[INCDEC_PTR_LVER_ORIG]] = getelementptr inbounds nuw i8, ptr [[SRC_ADDR_05_LVER_ORIG]], i64 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr [[SRC_ADDR_05_LVER_ORIG]], align 1
; CHECK-NEXT:    [[INCDEC_PTR1_LVER_ORIG]] = getelementptr inbounds nuw i8, ptr [[DST_ADDR_06_LVER_ORIG]], i64 1
; CHECK-NEXT:    store i8 [[TMP6]], ptr [[DST_ADDR_06_LVER_ORIG]], align 1
; CHECK-NEXT:    [[CMP_LVER_ORIG:%.*]] = icmp ult ptr [[INCDEC_PTR1_LVER_ORIG]], [[ADD_PTR]]
; CHECK-NEXT:    br i1 [[CMP_LVER_ORIG]], label %[[WHILE_BODY_LVER_ORIG]], label %[[WHILE_END_LOOPEXIT_LOOPEXIT:.*]]
; CHECK:       [[WHILE_BODY_PH]]:
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[DST]], ptr align 1 [[SRC]], i64 [[TMP5]], i1 false)
; CHECK-NEXT:    br label %[[WHILE_BODY:.*]]
; CHECK:       [[WHILE_BODY]]:
; CHECK-NEXT:    [[DST_ADDR_06:%.*]] = phi ptr [ [[INCDEC_PTR1:%.*]], %[[WHILE_BODY]] ], [ [[DST]], %[[WHILE_BODY_PH]] ]
; CHECK-NEXT:    [[SRC_ADDR_05:%.*]] = phi ptr [ [[INCDEC_PTR:%.*]], %[[WHILE_BODY]] ], [ [[SRC]], %[[WHILE_BODY_PH]] ]
; CHECK-NEXT:    [[INCDEC_PTR]] = getelementptr inbounds nuw i8, ptr [[SRC_ADDR_05]], i64 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i8, ptr [[SRC_ADDR_05]], align 1
; CHECK-NEXT:    [[INCDEC_PTR1]] = getelementptr inbounds nuw i8, ptr [[DST_ADDR_06]], i64 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult ptr [[INCDEC_PTR1]], [[ADD_PTR]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[WHILE_BODY]], label %[[WHILE_END_LOOPEXIT_LOOPEXIT3:.*]]
; CHECK:       [[WHILE_END_LOOPEXIT_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[WHILE_END_LOOPEXIT:.*]]
; CHECK:       [[WHILE_END_LOOPEXIT_LOOPEXIT3]]:
; CHECK-NEXT:    br label %[[WHILE_END_LOOPEXIT]]
; CHECK:       [[WHILE_END_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[WHILE_END]]
; CHECK:       [[WHILE_END]]:
; CHECK-NEXT:    ret void
;
entry:
  %add.ptr = getelementptr inbounds nuw i8, ptr %dst, i64 %d_len
  %cmp4.not = icmp eq i64 %d_len, 0
  br i1 %cmp4.not, label %while.end, label %while.body.preheader

while.body.preheader:
  br label %while.body

while.body:
  %dst.addr.06 = phi ptr [ %incdec.ptr1, %while.body ], [ %dst, %while.body.preheader ]
  %src.addr.05 = phi ptr [ %incdec.ptr, %while.body ], [ %src, %while.body.preheader ]
  %incdec.ptr = getelementptr inbounds nuw i8, ptr %src.addr.05, i64 1
  %0 = load i8, ptr %src.addr.05, align 1
  %incdec.ptr1 = getelementptr inbounds nuw i8, ptr %dst.addr.06, i64 1
  store i8 %0, ptr %dst.addr.06, align 1
  %cmp = icmp ult ptr %incdec.ptr1, %add.ptr
  br i1 %cmp, label %while.body, label %while.end.loopexit

while.end.loopexit:
  br label %while.end

while.end:
  ret void
}

; If the loop has multiple loads or stores, we don't perform loop versioning to
; prevent code size from growing exponentially.
define dso_local void @multiple_load_store_pairs(ptr %dst0, ptr %src0, i32 noundef %n, ptr %dst1, ptr %src1) {
; CHECK-LABEL: define dso_local void @multiple_load_store_pairs(
; CHECK-SAME: ptr [[DST0:%.*]], ptr [[SRC0:%.*]], i32 noundef [[N:%.*]], ptr [[DST1:%.*]], ptr [[SRC1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP_NOT12:%.*]] = icmp eq i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP_NOT12]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY_PREHEADER:.*]]
; CHECK:       [[FOR_BODY_PREHEADER]]:
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_COND_CLEANUP_LOOPEXIT:.*]]:
; CHECK-NEXT:    br label %[[FOR_COND_CLEANUP]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_013:%.*]] = phi i32 [ [[INC:%.*]], %[[FOR_BODY]] ], [ 0, %[[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext i32 [[I_013]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i8, ptr [[SRC0]], i64 [[IDXPROM]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds nuw i8, ptr [[DST0]], i64 [[IDXPROM]]
; CHECK-NEXT:    store i8 [[TMP0]], ptr [[ARRAYIDX2]], align 1
; CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds nuw double, ptr [[SRC1]], i64 [[IDXPROM]]
; CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr [[ARRAYIDX4]], align 8
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds nuw double, ptr [[DST1]], i64 [[IDXPROM]]
; CHECK-NEXT:    [[TMP2:%.*]] = load double, ptr [[ARRAYIDX6]], align 8
; CHECK-NEXT:    [[ADD:%.*]] = fadd double [[TMP1]], [[TMP2]]
; CHECK-NEXT:    store double [[ADD]], ptr [[ARRAYIDX6]], align 8
; CHECK-NEXT:    [[INC]] = add i32 [[I_013]], 1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[FOR_COND_CLEANUP_LOOPEXIT]], label %[[FOR_BODY]]
;
entry:
  %cmp.not12 = icmp eq i32 %n, 0
  br i1 %cmp.not12, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:
  br label %for.body

for.cond.cleanup.loopexit:
  br label %for.cond.cleanup

for.cond.cleanup:
  ret void

for.body:
  %i.013 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %idxprom = zext i32 %i.013 to i64
  %arrayidx = getelementptr inbounds nuw i8, ptr %src0, i64 %idxprom
  %0 = load i8, ptr %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds nuw i8, ptr %dst0, i64 %idxprom
  store i8 %0, ptr %arrayidx2, align 1
  %arrayidx4 = getelementptr inbounds nuw double, ptr %src1, i64 %idxprom
  %1 = load double, ptr %arrayidx4, align 8
  %arrayidx6 = getelementptr inbounds nuw double, ptr %dst1, i64 %idxprom
  %2 = load double, ptr %arrayidx6, align 8
  %add = fadd double %1, %2
  store double %add, ptr %arrayidx6, align 8
  %inc = add i32 %i.013, 1
  %cmp.not = icmp eq i32 %inc, %n
  br i1 %cmp.not, label %for.cond.cleanup.loopexit, label %for.body
}

; If there are instructions other than the store, the load, or loop control
; instructions, we don't perform loop versioning to prevent code size from
; growing up.
define dso_local double @other_instrs_exist(ptr %dst, ptr %src, i32 noundef %n) {
; CHECK-LABEL: define dso_local double @other_instrs_exist(
; CHECK-SAME: ptr [[DST:%.*]], ptr [[SRC:%.*]], i32 noundef [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[CMP_NOT8:%.*]] = icmp eq i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP_NOT8]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY_PREHEADER:.*]]
; CHECK:       [[FOR_BODY_PREHEADER]]:
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_COND_CLEANUP_LOOPEXIT:.*]]:
; CHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi double [ [[ADD:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    br label %[[FOR_COND_CLEANUP]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    [[RES_0_LCSSA:%.*]] = phi double [ 0.000000e+00, %[[ENTRY]] ], [ [[ADD_LCSSA]], %[[FOR_COND_CLEANUP_LOOPEXIT]] ]
; CHECK-NEXT:    ret double [[RES_0_LCSSA]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[I_010:%.*]] = phi i32 [ [[INC:%.*]], %[[FOR_BODY]] ], [ 0, %[[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[RES_09:%.*]] = phi double [ [[ADD]], %[[FOR_BODY]] ], [ 0.000000e+00, %[[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext i32 [[I_010]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i8, ptr [[SRC]], i64 [[IDXPROM]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds nuw i8, ptr [[DST]], i64 [[IDXPROM]]
; CHECK-NEXT:    store i8 [[TMP0]], ptr [[ARRAYIDX2]], align 1
; CHECK-NEXT:    [[CONV:%.*]] = uitofp i32 [[I_010]] to double
; CHECK-NEXT:    [[ADD]] = fadd double [[RES_09]], [[CONV]]
; CHECK-NEXT:    [[INC]] = add i32 [[I_010]], 1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[FOR_COND_CLEANUP_LOOPEXIT]], label %[[FOR_BODY]]
;
entry:
  %cmp.not8 = icmp eq i32 %n, 0
  br i1 %cmp.not8, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:
  br label %for.body

for.cond.cleanup.loopexit:
  %add.lcssa = phi double [ %add, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:
  %res.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add.lcssa, %for.cond.cleanup.loopexit ]
  ret double %res.0.lcssa

for.body:
  %i.010 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %res.09 = phi double [ %add, %for.body ], [ 0.000000e+00, %for.body.preheader ]
  %idxprom = zext i32 %i.010 to i64
  %arrayidx = getelementptr inbounds nuw i8, ptr %src, i64 %idxprom
  %0 = load i8, ptr %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds nuw i8, ptr %dst, i64 %idxprom
  store i8 %0, ptr %arrayidx2, align 1
  %conv = uitofp i32 %i.010 to double
  %add = fadd double %res.09, %conv
  %inc = add i32 %i.010, 1
  %cmp.not = icmp eq i32 %inc, %n
  br i1 %cmp.not, label %for.cond.cleanup.loopexit, label %for.body
}
