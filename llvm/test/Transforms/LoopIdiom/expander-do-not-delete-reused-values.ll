; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=loop-idiom -enable-loop-idiom-version=0 -S %s | FileCheck %s --check-prefix=CHECK-NO-VERSION
; RUN: opt -passes=loop-idiom -S %s | FileCheck %s --check-prefix=CHECK-VERSION

; Make sure we do not delete instructions not inserted during expansion, e.g.
; because the expander re-used existing instructions.

define void @test(i64 %init, ptr %ptr) {
; CHECK-NO-VERSION-LABEL: @test(
; CHECK-NO-VERSION-NEXT:  entry:
; CHECK-NO-VERSION-NEXT:    br label [[OUTER_HEADER:%.*]]
; CHECK-NO-VERSION:       outer.header:
; CHECK-NO-VERSION-NEXT:    [[J_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[OUTER_LATCH:%.*]] ]
; CHECK-NO-VERSION-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[OUTER_LATCH]] ]
; CHECK-NO-VERSION-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds float, ptr [[PTR:%.*]], i32 [[I_0]]
; CHECK-NO-VERSION-NEXT:    br label [[INNER:%.*]]
; CHECK-NO-VERSION:       inner:
; CHECK-NO-VERSION-NEXT:    [[INNER_IV:%.*]] = phi i64 [ [[INNER_IV_NEXT:%.*]], [[INNER]] ], [ [[INIT:%.*]], [[OUTER_HEADER]] ]
; CHECK-NO-VERSION-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[PTR]], i64 [[INNER_IV]]
; CHECK-NO-VERSION-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NO-VERSION-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds float, ptr [[ADD_PTR]], i64 [[INNER_IV]]
; CHECK-NO-VERSION-NEXT:    store i32 [[TMP0]], ptr [[ARRAYIDX3]], align 4
; CHECK-NO-VERSION-NEXT:    [[INNER_IV_NEXT]] = add nsw i64 [[INNER_IV]], 1
; CHECK-NO-VERSION-NEXT:    [[EC_1:%.*]] = icmp eq i64 [[INNER_IV_NEXT]], 0
; CHECK-NO-VERSION-NEXT:    br i1 [[EC_1]], label [[OUTER_LATCH]], label [[INNER]]
; CHECK-NO-VERSION:       outer.latch:
; CHECK-NO-VERSION-NEXT:    [[INC]] = add nuw nsw i32 [[J_0]], 1
; CHECK-NO-VERSION-NEXT:    [[ADD]] = add nuw nsw i32 [[I_0]], [[INC]]
; CHECK-NO-VERSION-NEXT:    [[EC_2:%.*]] = icmp eq i32 [[ADD]], 4000
; CHECK-NO-VERSION-NEXT:    br i1 [[EC_2]], label [[EXIT:%.*]], label [[OUTER_HEADER]]
; CHECK-NO-VERSION:       exit:
; CHECK-NO-VERSION-NEXT:    ret void
;
; CHECK-VERSION-LABEL: @test(
; CHECK-VERSION-NEXT:  entry:
; CHECK-VERSION-NEXT:    [[TMP0:%.*]] = shl i64 [[INIT:%.*]], 2
; CHECK-VERSION-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[PTR:%.*]], i64 [[TMP0]]
; CHECK-VERSION-NEXT:    [[SCEVGEP2:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP0]]
; CHECK-VERSION-NEXT:    [[TMP9:%.*]] = sub i64 -1, [[INIT]]
; CHECK-VERSION-NEXT:    [[TMP1:%.*]] = mul i64 [[INIT]], -4
; CHECK-VERSION-NEXT:    br label [[INNER_LVER_CHECK:%.*]]
; CHECK-VERSION:       inner.lver.check:
; CHECK-VERSION-NEXT:    [[J_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[OUTER_LATCH:%.*]] ]
; CHECK-VERSION-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[OUTER_LATCH]] ]
; CHECK-VERSION-NEXT:    [[TMP2:%.*]] = sext i32 [[I_0]] to i64
; CHECK-VERSION-NEXT:    [[TMP3:%.*]] = shl nsw i64 [[TMP2]], 2
; CHECK-VERSION-NEXT:    [[SCEVGEP3:%.*]] = getelementptr i8, ptr [[SCEVGEP2]], i64 [[TMP3]]
; CHECK-VERSION-NEXT:    [[SCEVGEP4:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP3]]
; CHECK-VERSION-NEXT:    [[TMP4:%.*]] = sext i32 [[I_0]] to i64
; CHECK-VERSION-NEXT:    [[TMP5:%.*]] = shl nsw i64 [[TMP4]], 2
; CHECK-VERSION-NEXT:    [[SCEVGEP1:%.*]] = getelementptr i8, ptr [[SCEVGEP]], i64 [[TMP5]]
; CHECK-VERSION-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds float, ptr [[PTR]], i32 [[I_0]]
; CHECK-VERSION-NEXT:    [[BOUND0:%.*]] = icmp ult ptr [[SCEVGEP3]], [[PTR]]
; CHECK-VERSION-NEXT:    [[BOUND1:%.*]] = icmp ult ptr [[SCEVGEP2]], [[SCEVGEP4]]
; CHECK-VERSION-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]
; CHECK-VERSION-NEXT:    [[TMP10:%.*]] = icmp slt i64 [[TMP9]], 12
; CHECK-VERSION-NEXT:    [[TMP8:%.*]] = or i1 [[FOUND_CONFLICT]], [[TMP10]]
; CHECK-VERSION-NEXT:    br i1 [[TMP8]], label [[INNER_PH_LVER_ORIG:%.*]], label [[INNER_PH:%.*]]
; CHECK-VERSION:       inner.ph.lver.orig:
; CHECK-VERSION-NEXT:    br label [[INNER_LVER_ORIG:%.*]]
; CHECK-VERSION:       inner.lver.orig:
; CHECK-VERSION-NEXT:    [[INNER_IV_LVER_ORIG:%.*]] = phi i64 [ [[INNER_IV_NEXT_LVER_ORIG:%.*]], [[INNER_LVER_ORIG]] ], [ [[INIT]], [[INNER_PH_LVER_ORIG]] ]
; CHECK-VERSION-NEXT:    [[ARRAYIDX_LVER_ORIG:%.*]] = getelementptr inbounds float, ptr [[PTR]], i64 [[INNER_IV_LVER_ORIG]]
; CHECK-VERSION-NEXT:    [[TMP6:%.*]] = load i32, ptr [[ARRAYIDX_LVER_ORIG]], align 4
; CHECK-VERSION-NEXT:    [[ARRAYIDX3_LVER_ORIG:%.*]] = getelementptr inbounds float, ptr [[ADD_PTR]], i64 [[INNER_IV_LVER_ORIG]]
; CHECK-VERSION-NEXT:    store i32 [[TMP6]], ptr [[ARRAYIDX3_LVER_ORIG]], align 4
; CHECK-VERSION-NEXT:    [[INNER_IV_NEXT_LVER_ORIG]] = add nsw i64 [[INNER_IV_LVER_ORIG]], 1
; CHECK-VERSION-NEXT:    [[EC_1_LVER_ORIG:%.*]] = icmp eq i64 [[INNER_IV_NEXT_LVER_ORIG]], 0
; CHECK-VERSION-NEXT:    br i1 [[EC_1_LVER_ORIG]], label [[OUTER_LATCH_LOOPEXIT:%.*]], label [[INNER_LVER_ORIG]]
; CHECK-VERSION:       inner.ph:
; CHECK-VERSION-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[SCEVGEP1]], ptr align 4 [[SCEVGEP]], i64 [[TMP1]], i1 false)
; CHECK-VERSION-NEXT:    br label [[INNER:%.*]]
; CHECK-VERSION:       inner:
; CHECK-VERSION-NEXT:    [[INNER_IV:%.*]] = phi i64 [ [[INNER_IV_NEXT:%.*]], [[INNER]] ], [ [[INIT]], [[INNER_PH]] ]
; CHECK-VERSION-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[PTR]], i64 [[INNER_IV]]
; CHECK-VERSION-NEXT:    [[TMP7:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-VERSION-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds float, ptr [[ADD_PTR]], i64 [[INNER_IV]]
; CHECK-VERSION-NEXT:    [[INNER_IV_NEXT]] = add nsw i64 [[INNER_IV]], 1
; CHECK-VERSION-NEXT:    [[EC_1:%.*]] = icmp eq i64 [[INNER_IV_NEXT]], 0
; CHECK-VERSION-NEXT:    br i1 [[EC_1]], label [[OUTER_LATCH_LOOPEXIT5:%.*]], label [[INNER]]
; CHECK-VERSION:       outer.latch.loopexit:
; CHECK-VERSION-NEXT:    br label [[OUTER_LATCH]]
; CHECK-VERSION:       outer.latch.loopexit5:
; CHECK-VERSION-NEXT:    br label [[OUTER_LATCH]]
; CHECK-VERSION:       outer.latch:
; CHECK-VERSION-NEXT:    [[INC]] = add nuw nsw i32 [[J_0]], 1
; CHECK-VERSION-NEXT:    [[ADD]] = add nuw nsw i32 [[I_0]], [[INC]]
; CHECK-VERSION-NEXT:    [[EC_2:%.*]] = icmp eq i32 [[ADD]], 4000
; CHECK-VERSION-NEXT:    br i1 [[EC_2]], label [[EXIT:%.*]], label [[INNER_LVER_CHECK]]
; CHECK-VERSION:       exit:
; CHECK-VERSION-NEXT:    ret void
;
entry:
  br label %outer.header

outer.header:
  %j.0 = phi i32 [ 0, %entry ], [ %inc, %outer.latch ]
  %i.0 = phi i32 [ 0, %entry ], [ %add, %outer.latch ]
  %add.ptr = getelementptr inbounds float, ptr %ptr, i32 %i.0
  br label %inner

inner:
  %inner.iv = phi i64 [ %inner.iv.next, %inner ], [ %init, %outer.header ]
  %arrayidx = getelementptr inbounds float, ptr %ptr, i64 %inner.iv
  %0 = load i32, ptr %arrayidx, align 4
  %arrayidx3 = getelementptr inbounds float, ptr %add.ptr, i64 %inner.iv
  store i32 %0, ptr %arrayidx3, align 4
  %inner.iv.next = add nsw i64 %inner.iv, 1
  %ec.1 = icmp eq i64 %inner.iv.next, 0
  br i1 %ec.1, label %outer.latch, label %inner

outer.latch:
  %inc = add nuw nsw i32 %j.0, 1
  %add = add nuw nsw i32 %i.0, %inc
  %ec.2 = icmp eq i32 %add, 4000
  br i1 %ec.2, label %exit, label %outer.header

exit:
  ret void
}
