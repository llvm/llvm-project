; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=loop-idiom -S %s | FileCheck %s

define void @reuse_cast_1(ptr %ptr, i1 %c) {
; CHECK-LABEL: @reuse_cast_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_0:%.*]]
; CHECK:       loop.0:
; CHECK-NEXT:    [[TMP:%.*]] = load ptr, ptr [[PTR:%.*]], align 8
; CHECK-NEXT:    br i1 [[C:%.*]], label [[LOOP_2_PREHEADER:%.*]], label [[LOOP_1_PREHEADER:%.*]]
; CHECK:       loop.1.preheader:
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[TMP]], i8 0, i64 400, i1 false)
; CHECK-NEXT:    br label [[LOOP_1:%.*]]
; CHECK:       loop.2.preheader:
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.1:
; CHECK-NEXT:    [[IV_1:%.*]] = phi i64 [ [[IV_1_NEXT:%.*]], [[LOOP_1]] ], [ 0, [[LOOP_1_PREHEADER]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds float, ptr [[TMP]], i64 [[IV_1]]
; CHECK-NEXT:    [[IV_1_NEXT]] = add nuw nsw i64 [[IV_1]], 1
; CHECK-NEXT:    [[C_1:%.*]] = icmp ne i64 [[IV_1_NEXT]], 100
; CHECK-NEXT:    br i1 [[C_1]], label [[LOOP_1]], label [[LOOP_0_LATCH_LOOPEXIT1:%.*]]
; CHECK:       loop.2:
; CHECK-NEXT:    [[IV_2:%.*]] = phi i64 [ [[IV_2_NEXT:%.*]], [[LOOP_2]] ], [ 0, [[LOOP_2_PREHEADER]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds float, ptr [[TMP]], i64 [[IV_2]]
; CHECK-NEXT:    store float 0.000000e+00, ptr [[TMP10]], align 4
; CHECK-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[PTR]], align 8
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds float, ptr [[TMP11]], i64 [[IV_2]]
; CHECK-NEXT:    [[TMP13:%.*]] = load float, ptr [[TMP12]], align 4
; CHECK-NEXT:    [[IV_2_NEXT]] = add nuw nsw i64 [[IV_2]], 1
; CHECK-NEXT:    [[C_2:%.*]] = icmp ne i64 [[IV_2_NEXT]], 100
; CHECK-NEXT:    br i1 [[C_2]], label [[LOOP_2]], label [[LOOP_0_LATCH_LOOPEXIT:%.*]]
; CHECK:       loop.0.latch.loopexit:
; CHECK-NEXT:    br label [[LOOP_0_LATCH:%.*]]
; CHECK:       loop.0.latch.loopexit1:
; CHECK-NEXT:    br label [[LOOP_0_LATCH]]
; CHECK:       loop.0.latch:
; CHECK-NEXT:    [[C_0:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C_0]], label [[LOOP_0]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.0

loop.0:                                           ; preds = %loop.0.latch, %entry
  %tmp = load ptr, ptr %ptr, align 8
  br i1 %c, label %loop.2, label %loop.1

loop.1:                                           ; preds = %loop.1, %loop.0
  %iv.1 = phi i64 [ %iv.1.next, %loop.1 ], [ 0, %loop.0 ]
  %tmp4 = getelementptr inbounds float, ptr %tmp, i64 %iv.1
  store float 0.000000e+00, ptr %tmp4, align 4
  %iv.1.next = add nuw nsw i64 %iv.1, 1
  %c.1 = icmp ne i64 %iv.1.next, 100
  br i1 %c.1, label %loop.1, label %loop.0.latch

loop.2:                                           ; preds = %loop.2, %loop.0
  %iv.2 = phi i64 [ %iv.2.next, %loop.2 ], [ 0, %loop.0 ]
  %tmp10 = getelementptr inbounds float, ptr %tmp, i64 %iv.2
  store float 0.000000e+00, ptr %tmp10, align 4
  %tmp11 = load ptr, ptr %ptr, align 8
  %tmp12 = getelementptr inbounds float, ptr %tmp11, i64 %iv.2
  %tmp13 = load float, ptr %tmp12, align 4
  %iv.2.next = add nuw nsw i64 %iv.2, 1
  %c.2 = icmp ne i64 %iv.2.next, 100
  br i1 %c.2, label %loop.2, label %loop.0.latch

loop.0.latch:                                     ; preds = %loop.2, %loop.1
  %c.0 = call i1 @cond()
  br i1 %c.0, label %loop.0, label %end

end:                                              ; preds = %loop.0.latch
  ret void
}

declare i1 @cond()

declare void @use.i8(ptr)

declare void @use.i1(i1)

define void @reuse_cast_2(i32 %x, ptr %ptr.1.start) {
; CHECK-LABEL: @reuse_cast_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[STACK:%.*]] = alloca [2 x i32], align 4
; CHECK-NEXT:    [[C_0:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-NEXT:    call void @use.i8(ptr [[STACK]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[STACK]], ptr align 4 [[PTR_1_START:%.*]], i64 8, i1 false)
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_1:%.*]] = phi ptr [ [[PTR_1_START]], [[ENTRY]] ], [ [[PTR_1_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_2:%.*]] = phi ptr [ [[STACK]], [[ENTRY]] ], [ [[PTR_2_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[PTR_1_NEXT]] = getelementptr inbounds i32, ptr [[PTR_1]], i64 1
; CHECK-NEXT:    [[LV:%.*]] = load i32, ptr [[PTR_1]], align 4
; CHECK-NEXT:    [[PTR_2_NEXT]] = getelementptr inbounds i32, ptr [[PTR_2]], i64 1
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[C_1:%.*]] = icmp eq i32 [[IV]], 0
; CHECK-NEXT:    br i1 [[C_1]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    call void @use.i1(i1 [[C_0]])
; CHECK-NEXT:    ret void
;
entry:
  %stack = alloca [2 x i32], align 4
  %c.0 = icmp sgt i32 %x, 0
  call void @use.i8(ptr %stack)
  br label %loop

loop:                                             ; preds = %loop, %entry
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %ptr.1 = phi ptr [ %ptr.1.start, %entry ], [ %ptr.1.next, %loop ]
  %ptr.2 = phi ptr [ %stack, %entry ], [ %ptr.2.next, %loop ]
  %ptr.1.next = getelementptr inbounds i32, ptr %ptr.1, i64 1
  %lv = load i32, ptr %ptr.1, align 4
  %ptr.2.next = getelementptr inbounds i32, ptr %ptr.2, i64 1
  store i32 %lv, ptr %ptr.2, align 4
  %iv.next = add nuw nsw i32 %iv, 1
  %c.1 = icmp eq i32 %iv, 0
  br i1 %c.1, label %loop, label %exit

exit:                                             ; preds = %loop
  call void @use.i1(i1 %c.0)
  ret void
}
