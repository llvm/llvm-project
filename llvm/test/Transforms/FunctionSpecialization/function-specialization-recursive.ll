; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -function-specialization -inline -instcombine -S < %s | FileCheck %s

; TODO: this is a case that would be interesting to support, but we don't yet
; at the moment.

@Global = internal constant i32 1, align 4

define internal void @recursiveFunc(i32* nocapture readonly %arg) {
; CHECK-LABEL: @recursiveFunc(
; CHECK-NEXT:    [[TEMP:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[ARG_LOAD:%.*]] = load i32, i32* [[ARG:%.*]], align 4
; CHECK-NEXT:    [[ARG_CMP:%.*]] = icmp slt i32 [[ARG_LOAD]], 4
; CHECK-NEXT:    br i1 [[ARG_CMP]], label [[BLOCK6:%.*]], label [[RET_BLOCK:%.*]]
; CHECK:       block6:
; CHECK-NEXT:    call void @print_val(i32 [[ARG_LOAD]])
; CHECK-NEXT:    [[ARG_ADD:%.*]] = add nsw i32 [[ARG_LOAD]], 1
; CHECK-NEXT:    store i32 [[ARG_ADD]], i32* [[TEMP]], align 4
; CHECK-NEXT:    call void @recursiveFunc(i32* nonnull [[TEMP]])
; CHECK-NEXT:    br label [[RET_BLOCK]]
; CHECK:       ret.block:
; CHECK-NEXT:    ret void
;
  %temp = alloca i32, align 4
  %arg.load = load i32, i32* %arg, align 4
  %arg.cmp = icmp slt i32 %arg.load, 4
  br i1 %arg.cmp, label %block6, label %ret.block

block6:
  call void @print_val(i32 %arg.load)
  %arg.add = add nsw i32 %arg.load, 1
  store i32 %arg.add, i32* %temp, align 4
  call void @recursiveFunc(i32* nonnull %temp)
  br label %ret.block

ret.block:
  ret void
}

define i32 @main() {
; CHECK-LABEL: @main(
; CHECK-NEXT:    call void @recursiveFunc(i32* nonnull @Global)
; CHECK-NEXT:    ret i32 0
;
  call void @recursiveFunc(i32* nonnull @Global)
  ret i32 0
}

declare dso_local void @print_val(i32)
