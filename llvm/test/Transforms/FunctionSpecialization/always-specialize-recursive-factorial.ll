; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: -p --function-signature --include-generated-funcs
; RUN: opt -S --passes=always-specialize < %s | FileCheck %s
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define i32 @factorial(i32 alwaysspecialize %x) {
entry:
  %cmp = icmp ult i32 %x, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:
  br label %return

if.end:
  %sub = sub i32 %x, 1
  %call = call i32 @factorial(i32 %sub)
  %mul = mul i32 %x, %call
  br label %return

return:
  %retval.0 = phi i32 [ 1, %if.then ], [ %mul, %if.end ]
  ret i32 %retval.0
}

define i32 @factorial_driver() {
entry:
  %call = call i32 @factorial(i32 0)
  %call1 = call i32 @factorial(i32 1)
  %add = add i32 %call, %call1
  %call2 = call i32 @factorial(i32 2)
  %add3 = add i32 %add, %call2
  %call4 = call i32 @factorial(i32 3)
  %add5 = add i32 %add3, %call4
  %call6 = call i32 @factorial(i32 4)
  %add7 = add i32 %add5, %call6
  ret i32 %add7
}



; CHECK-LABEL: define {{[^@]+}}@factorial.spec
; CHECK-SAME: (i32 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 4, 2
; CHECK-NEXT:    br i1 false, label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 4, 1
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @factorial.spec.1(i32 3)
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 4, [[CALL]]
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 1, [[IF_THEN]] ], [ [[MUL]], [[IF_END]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
;
; CHECK-LABEL: define {{[^@]+}}@factorial.spec.1
; CHECK-SAME: (i32 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 3, 2
; CHECK-NEXT:    br i1 false, label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 3, 1
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @factorial.spec.2(i32 2)
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 3, [[CALL]]
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 1, [[IF_THEN]] ], [ [[MUL]], [[IF_END]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
;
; CHECK-LABEL: define {{[^@]+}}@factorial.spec.2
; CHECK-SAME: (i32 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 2, 2
; CHECK-NEXT:    br i1 false, label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 2, 1
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @factorial.spec.3(i32 1)
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 2, [[CALL]]
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 1, [[IF_THEN]] ], [ [[MUL]], [[IF_END]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
;
; CHECK-LABEL: define {{[^@]+}}@factorial.spec.3
; CHECK-SAME: (i32 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 1, 2
; CHECK-NEXT:    br i1 true, label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 1, 1
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @factorial.spec.4(i32 0)
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 1, [[CALL]]
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 1, [[IF_THEN]] ], [ [[CALL]], [[IF_END]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
;
; CHECK-LABEL: define {{[^@]+}}@factorial.spec.4
; CHECK-SAME: (i32 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 0, 2
; CHECK-NEXT:    br i1 true, label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 0, 1
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @factorial(i32 -1)
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 0, [[CALL]]
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 1, [[IF_THEN]] ], [ [[MUL]], [[IF_END]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
;
; CHECK-LABEL: define {{[^@]+}}@factorial
; CHECK-SAME: (i32 alwaysspecialize [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[X]], 2
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @factorial(i32 [[SUB]])
; CHECK-NEXT:    [[MUL:%.*]] = mul i32 [[X]], [[CALL]]
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 1, [[IF_THEN]] ], [ [[MUL]], [[IF_END]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
;
; CHECK-LABEL: define {{[^@]+}}@factorial_driver() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call i32 @factorial.spec.4(i32 0)
; CHECK-NEXT:    [[CALL1:%.*]] = call i32 @factorial.spec.3(i32 1)
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[CALL]], [[CALL1]]
; CHECK-NEXT:    [[CALL2:%.*]] = call i32 @factorial.spec.2(i32 2)
; CHECK-NEXT:    [[ADD3:%.*]] = add i32 [[ADD]], [[CALL2]]
; CHECK-NEXT:    [[CALL4:%.*]] = call i32 @factorial.spec.1(i32 3)
; CHECK-NEXT:    [[ADD5:%.*]] = add i32 [[ADD3]], [[CALL4]]
; CHECK-NEXT:    [[CALL6:%.*]] = call i32 @factorial.spec(i32 4)
; CHECK-NEXT:    [[ADD7:%.*]] = add i32 [[ADD5]], [[CALL6]]
; CHECK-NEXT:    ret i32 [[ADD7]]
;
