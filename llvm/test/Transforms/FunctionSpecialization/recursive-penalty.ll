; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; REQUIRES: asserts
; RUN: opt -passes="ipsccp<func-spec>,inline,instcombine,simplifycfg" -S \
; RUN:     -funcspec-min-function-size=23 -funcspec-max-iters=100 \
; RUN:     -debug-only=function-specialization < %s 2>&1 | FileCheck %s

; Make sure the number of specializations created are not
; linear to the number of iterations (funcspec-max-iters).

@Global = internal constant i32 1, align 4

define internal void @recursiveFunc(ptr readonly %arg) {
; CHECK-LABEL: define internal void @recursiveFunc(
; CHECK-SAME: ptr readonly [[ARG:%.*]]) {
; CHECK-NEXT:    [[TEMP:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[ARG_LOAD:%.*]] = load i32, ptr [[ARG]], align 4
; CHECK-NEXT:    [[ARG_CMP:%.*]] = icmp slt i32 [[ARG_LOAD]], 10000
; CHECK-NEXT:    br i1 [[ARG_CMP]], label %[[LOOP1:.*]], label %[[RET_BLOCK:.*]]
; CHECK:       [[LOOP1]]:
; CHECK-NEXT:    br label %[[LOOP2:.*]]
; CHECK:       [[LOOP2]]:
; CHECK-NEXT:    br label %[[LOOP3:.*]]
; CHECK:       [[LOOP3]]:
; CHECK-NEXT:    br label %[[LOOP4:.*]]
; CHECK:       [[LOOP4]]:
; CHECK-NEXT:    call void @print_val(i32 [[ARG_LOAD]])
; CHECK-NEXT:    [[ARG_ADD:%.*]] = add nsw i32 [[ARG_LOAD]], 1
; CHECK-NEXT:    store i32 [[ARG_ADD]], ptr [[TEMP]], align 4
; CHECK-NEXT:    call void @recursiveFunc(ptr nonnull [[TEMP]])
; CHECK-NEXT:    [[EXIT_COND1:%.*]] = call i1 @exit_cond()
; CHECK-NEXT:    br i1 [[EXIT_COND1]], label %[[LOOP4]], label %[[LOOP3_END:.*]]
; CHECK:       [[LOOP3_END]]:
; CHECK-NEXT:    [[EXIT_COND2:%.*]] = call i1 @exit_cond()
; CHECK-NEXT:    br i1 [[EXIT_COND2]], label %[[LOOP3]], label %[[LOOP2_END:.*]]
; CHECK:       [[LOOP2_END]]:
; CHECK-NEXT:    [[EXIT_COND3:%.*]] = call i1 @exit_cond()
; CHECK-NEXT:    br i1 [[EXIT_COND3]], label %[[LOOP2]], label %[[LOOP1_END:.*]]
; CHECK:       [[LOOP1_END]]:
; CHECK-NEXT:    [[EXIT_COND4:%.*]] = call i1 @exit_cond()
; CHECK-NEXT:    br i1 [[EXIT_COND4]], label %[[LOOP1]], label %[[RET_BLOCK]]
; CHECK:       [[RET_BLOCK]]:
; CHECK-NEXT:    ret void
;
  %temp = alloca i32, align 4
  %arg.load = load i32, ptr %arg, align 4
  %arg.cmp = icmp slt i32 %arg.load, 10000
  br i1 %arg.cmp, label %loop1, label %ret.block

loop1:
  br label %loop2

loop2:
  br label %loop3

loop3:
  br label %loop4

loop4:
  br label %block6

block6:
  call void @print_val(i32 %arg.load)
  %arg.add = add nsw i32 %arg.load, 1
  store i32 %arg.add, ptr %temp, align 4
  call void @recursiveFunc(ptr %temp)
  br label %loop4.end

loop4.end:
  %exit_cond1 = call i1 @exit_cond()
  br i1 %exit_cond1, label %loop4, label %loop3.end

loop3.end:
  %exit_cond2 = call i1 @exit_cond()
  br i1 %exit_cond2, label %loop3, label %loop2.end

loop2.end:
  %exit_cond3 = call i1 @exit_cond()
  br i1 %exit_cond3, label %loop2, label %loop1.end

loop1.end:
  %exit_cond4 = call i1 @exit_cond()
  br i1 %exit_cond4, label %loop1, label %ret.block

ret.block:
  ret void
}

define i32 @main() {
; CHECK-LABEL: define i32 @main() {
; CHECK-NEXT:    call void @recursiveFunc(ptr nonnull @Global)
; CHECK-NEXT:    ret i32 0
;
  call void @recursiveFunc(ptr @Global)
  ret i32 0
}

declare dso_local void @print_val(i32)
declare dso_local i1 @exit_cond()
