; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals all --version 5
; RUN: opt -passes='loop(simple-loop-unswitch<nontrivial>),verify<loops>' -simple-loop-unswitch-guards -S < %s | FileCheck %s
; RUN: opt -passes='simple-loop-unswitch<nontrivial>' -simple-loop-unswitch-guards -S < %s | FileCheck %s
; RUN: opt -passes='loop-mssa(simple-loop-unswitch<nontrivial>),verify<loops>' -simple-loop-unswitch-guards  -verify-memoryssa -verify-loop-info -S < %s | FileCheck %s

declare void @llvm.experimental.guard(i1, ...)

define void @test_simple_case(i1 %cond, i32 %N) !prof !0 {
; CHECK-LABEL: define void @test_simple_case(
; CHECK-SAME: i1 [[COND:%.*]], i32 [[N:%.*]]) !prof [[PROF0:![0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_SPLIT_US:.*]], label %[[ENTRY_SPLIT:.*]], !prof [[PROF1:![0-9]+]]
; CHECK:       [[ENTRY_SPLIT_US]]:
; CHECK-NEXT:    br label %[[LOOP_US:.*]]
; CHECK:       [[LOOP_US]]:
; CHECK-NEXT:    [[IV_US:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT_US]] ], [ [[IV_NEXT_US:%.*]], %[[GUARDED_US:.*]] ]
; CHECK-NEXT:    br label %[[GUARDED_US]]
; CHECK:       [[GUARDED_US]]:
; CHECK-NEXT:    [[IV_NEXT_US]] = add i32 [[IV_US]], 1
; CHECK-NEXT:    [[LOOP_COND_US:%.*]] = icmp slt i32 [[IV_NEXT_US]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_COND_US]], label %[[LOOP_US]], label %[[EXIT_SPLIT_US:.*]]
; CHECK:       [[EXIT_SPLIT_US]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    br label %[[DEOPT:.*]]
; CHECK:       [[DEOPT]]:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %exit

exit:
  ret void
}

define void @test_two_guards(i1 %cond1, i1 %cond2, i32 %N) {
; CHECK-LABEL: define void @test_two_guards(
; CHECK-SAME: i1 [[COND1:%.*]], i1 [[COND2:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND1]], label %[[ENTRY_SPLIT_US:.*]], label %[[ENTRY_SPLIT:.*]], !prof [[PROF1]]
; CHECK:       [[ENTRY_SPLIT_US]]:
; CHECK-NEXT:    br i1 [[COND2]], label %[[ENTRY_SPLIT_US_SPLIT_US:.*]], label %[[ENTRY_SPLIT_US_SPLIT:.*]], !prof [[PROF1]]
; CHECK:       [[ENTRY_SPLIT_US_SPLIT_US]]:
; CHECK-NEXT:    br label %[[LOOP_US_US:.*]]
; CHECK:       [[LOOP_US_US]]:
; CHECK-NEXT:    [[IV_US_US:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT_US_SPLIT_US]] ], [ [[IV_NEXT_US_US:%.*]], %[[GUARDED_US2:.*]] ]
; CHECK-NEXT:    br label %[[GUARDED_US_US:.*]]
; CHECK:       [[GUARDED_US_US]]:
; CHECK-NEXT:    br label %[[GUARDED_US2]]
; CHECK:       [[GUARDED_US2]]:
; CHECK-NEXT:    [[IV_NEXT_US_US]] = add i32 [[IV_US_US]], 1
; CHECK-NEXT:    [[LOOP_COND_US_US:%.*]] = icmp slt i32 [[IV_NEXT_US_US]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_COND_US_US]], label %[[LOOP_US_US]], label %[[EXIT_SPLIT_US_SPLIT_US:.*]]
; CHECK:       [[EXIT_SPLIT_US_SPLIT_US]]:
; CHECK-NEXT:    br label %[[EXIT_SPLIT_US:.*]]
; CHECK:       [[ENTRY_SPLIT_US_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP_US:.*]]
; CHECK:       [[LOOP_US]]:
; CHECK-NEXT:    br label %[[GUARDED_US:.*]]
; CHECK:       [[GUARDED_US]]:
; CHECK-NEXT:    br label %[[DEOPT1:.*]]
; CHECK:       [[DEOPT1]]:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       [[EXIT_SPLIT_US]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    br label %[[DEOPT:.*]]
; CHECK:       [[DEOPT]]:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond1) [ "deopt"() ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond2) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %exit

exit:
  ret void
}

define void @test_conditional_guards(i1 %cond, i32 %N) {
; CHECK-LABEL: define void @test_conditional_guards(
; CHECK-SAME: i1 [[COND:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[COND_FR:%.*]] = freeze i1 [[COND]]
; CHECK-NEXT:    br i1 [[COND_FR]], label %[[ENTRY_SPLIT_US:.*]], label %[[ENTRY_SPLIT:.*]], !prof [[PROF1]]
; CHECK:       [[ENTRY_SPLIT_US]]:
; CHECK-NEXT:    br label %[[LOOP_US:.*]]
; CHECK:       [[LOOP_US]]:
; CHECK-NEXT:    [[IV_US:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT_US]] ], [ [[IV_NEXT_US:%.*]], %[[BACKEDGE_US:.*]] ]
; CHECK-NEXT:    [[CONDITION_US:%.*]] = icmp eq i32 [[IV_US]], 123
; CHECK-NEXT:    br i1 [[CONDITION_US]], label %[[GUARD_US:.*]], label %[[BACKEDGE_US]]
; CHECK:       [[GUARD_US]]:
; CHECK-NEXT:    br label %[[GUARDED_US:.*]]
; CHECK:       [[BACKEDGE_US]]:
; CHECK-NEXT:    [[IV_NEXT_US]] = add i32 [[IV_US]], 1
; CHECK-NEXT:    [[LOOP_COND_US:%.*]] = icmp slt i32 [[IV_NEXT_US]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_COND_US]], label %[[LOOP_US]], label %[[EXIT_SPLIT_US:.*]]
; CHECK:       [[GUARDED_US]]:
; CHECK-NEXT:    br label %[[BACKEDGE_US]]
; CHECK:       [[EXIT_SPLIT_US]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[IV_NEXT:%.*]], %[[BACKEDGE:.*]] ]
; CHECK-NEXT:    [[CONDITION:%.*]] = icmp eq i32 [[IV]], 123
; CHECK-NEXT:    br i1 [[CONDITION]], label %[[GUARD:.*]], label %[[BACKEDGE]]
; CHECK:       [[GUARD]]:
; CHECK-NEXT:    br label %[[DEOPT:.*]]
; CHECK:       [[DEOPT]]:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       [[BACKEDGE]]:
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp slt i32 [[IV_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_COND]], label %[[LOOP]], label %[[EXIT_SPLIT:.*]]
; CHECK:       [[EXIT_SPLIT]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  %condition = icmp eq i32 %iv, 123
  br i1 %condition, label %guard, label %backedge

guard:
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  br label %backedge

backedge:
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %exit

exit:
  ret void
}

define void @test_nested_loop(i1 %cond, i32 %N, i1 %arg) {
; CHECK-LABEL: define void @test_nested_loop(
; CHECK-SAME: i1 [[COND:%.*]], i32 [[N:%.*]], i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[ENTRY_SPLIT:.*]], label %[[OUTER_LOOP_SPLIT:.*]], !prof [[PROF1]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br i1 [[ARG]], label %[[ENTRY_SPLIT_SPLIT_US:.*]], label %[[ENTRY_SPLIT_SPLIT:.*]]
; CHECK:       [[ENTRY_SPLIT_SPLIT_US]]:
; CHECK-NEXT:    br label %[[OUTER_LOOP_US:.*]]
; CHECK:       [[OUTER_LOOP_US]]:
; CHECK-NEXT:    br label %[[OUTER_LOOP_SPLIT_US_US:.*]]
; CHECK:       [[OUTER_BACKEDGE_US:.*]]:
; CHECK-NEXT:    br label %[[OUTER_LOOP_US]]
; CHECK:       [[OUTER_LOOP_SPLIT_US_US]]:
; CHECK-NEXT:    br label %[[LOOP_US_US:.*]]
; CHECK:       [[LOOP_US_US]]:
; CHECK-NEXT:    [[IV_US_US:%.*]] = phi i32 [ 0, %[[OUTER_LOOP_SPLIT_US_US]] ], [ [[IV_NEXT_US_US:%.*]], %[[GUARDED_US_US:.*]] ]
; CHECK-NEXT:    br label %[[GUARDED_US_US]]
; CHECK:       [[GUARDED_US_US]]:
; CHECK-NEXT:    [[IV_NEXT_US_US]] = add i32 [[IV_US_US]], 1
; CHECK-NEXT:    [[LOOP_COND_US_US:%.*]] = icmp slt i32 [[IV_NEXT_US_US]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_COND_US_US]], label %[[LOOP_US_US]], label %[[OUTER_BACKEDGE_SPLIT_US_US:.*]]
; CHECK:       [[OUTER_BACKEDGE_SPLIT_US_US]]:
; CHECK-NEXT:    br label %[[OUTER_BACKEDGE_US]]
; CHECK:       [[ENTRY_SPLIT_SPLIT]]:
; CHECK-NEXT:    br label %[[OUTER_LOOP:.*]]
; CHECK:       [[OUTER_LOOP]]:
; CHECK-NEXT:    br label %[[OUTER_LOOP_SPLIT_US:.*]]
; CHECK:       [[OUTER_LOOP_SPLIT_US]]:
; CHECK-NEXT:    br label %[[LOOP_US:.*]]
; CHECK:       [[LOOP_US]]:
; CHECK-NEXT:    [[IV_US:%.*]] = phi i32 [ 0, %[[OUTER_LOOP_SPLIT_US]] ], [ [[IV_NEXT_US:%.*]], %[[GUARDED_US:.*]] ]
; CHECK-NEXT:    br label %[[GUARDED_US]]
; CHECK:       [[GUARDED_US]]:
; CHECK-NEXT:    [[IV_NEXT_US]] = add i32 [[IV_US]], 1
; CHECK-NEXT:    [[LOOP_COND_US:%.*]] = icmp slt i32 [[IV_NEXT_US]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_COND_US]], label %[[LOOP_US]], label %[[OUTER_BACKEDGE_SPLIT_US:.*]]
; CHECK:       [[OUTER_BACKEDGE_SPLIT_US]]:
; CHECK-NEXT:    br label %[[OUTER_BACKEDGE:.*]]
; CHECK:       [[OUTER_LOOP_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    br label %[[DEOPT:.*]]
; CHECK:       [[DEOPT]]:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       [[OUTER_BACKEDGE]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;

entry:
  br label %outer_loop

outer_loop:
  br label %loop

loop:
  %iv = phi i32 [ 0, %outer_loop ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %outer_backedge

outer_backedge:
  br i1 %arg, label %outer_loop, label %exit

exit:
  ret void
}

define void @test_sibling_loops(i1 %cond1, i1 %cond2, i32 %N) {
; CHECK-LABEL: define void @test_sibling_loops(
; CHECK-SAME: i1 [[COND1:%.*]], i1 [[COND2:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND1]], label %[[ENTRY_SPLIT_US:.*]], label %[[ENTRY_SPLIT:.*]], !prof [[PROF1]]
; CHECK:       [[ENTRY_SPLIT_US]]:
; CHECK-NEXT:    br label %[[LOOP1_US:.*]]
; CHECK:       [[LOOP1_US]]:
; CHECK-NEXT:    [[IV1_US:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT_US]] ], [ [[IV1_NEXT_US:%.*]], %[[GUARDED_US:.*]] ]
; CHECK-NEXT:    br label %[[GUARDED_US]]
; CHECK:       [[GUARDED_US]]:
; CHECK-NEXT:    [[IV1_NEXT_US]] = add i32 [[IV1_US]], 1
; CHECK-NEXT:    [[LOOP1_COND_US:%.*]] = icmp slt i32 [[IV1_NEXT_US]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP1_COND_US]], label %[[LOOP1_US]], label %[[BETWEEN_SPLIT_US:.*]]
; CHECK:       [[BETWEEN_SPLIT_US]]:
; CHECK-NEXT:    br label %[[BETWEEN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP1:.*]]
; CHECK:       [[LOOP1]]:
; CHECK-NEXT:    br label %[[DEOPT:.*]]
; CHECK:       [[DEOPT]]:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       [[BETWEEN]]:
; CHECK-NEXT:    br i1 [[COND2]], label %[[BETWEEN_SPLIT_US2:.*]], label %[[BETWEEN_SPLIT:.*]], !prof [[PROF1]]
; CHECK:       [[BETWEEN_SPLIT_US2]]:
; CHECK-NEXT:    br label %[[LOOP2_US:.*]]
; CHECK:       [[LOOP2_US]]:
; CHECK-NEXT:    [[IV2_US:%.*]] = phi i32 [ 0, %[[BETWEEN_SPLIT_US2]] ], [ [[IV2_NEXT_US:%.*]], %[[GUARDED_US3:.*]] ]
; CHECK-NEXT:    br label %[[GUARDED_US3]]
; CHECK:       [[GUARDED_US3]]:
; CHECK-NEXT:    [[IV2_NEXT_US]] = add i32 [[IV2_US]], 1
; CHECK-NEXT:    [[LOOP2_COND_US:%.*]] = icmp slt i32 [[IV2_NEXT_US]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP2_COND_US]], label %[[LOOP2_US]], label %[[EXIT_SPLIT_US:.*]]
; CHECK:       [[EXIT_SPLIT_US]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[BETWEEN_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP2:.*]]
; CHECK:       [[LOOP2]]:
; CHECK-NEXT:    br label %[[DEOPT1:.*]]
; CHECK:       [[DEOPT1]]:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop1

loop1:
  %iv1 = phi i32 [ 0, %entry ], [ %iv1.next, %loop1 ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond1) [ "deopt"() ]
  %iv1.next = add i32 %iv1, 1
  %loop1.cond = icmp slt i32 %iv1.next, %N
  br i1 %loop1.cond, label %loop1, label %between

between:
  br label %loop2

loop2:
  %iv2 = phi i32 [ 0, %between ], [ %iv2.next, %loop2 ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond2) [ "deopt"() ]
  %iv2.next = add i32 %iv2, 1
  %loop2.cond = icmp slt i32 %iv2.next, %N
  br i1 %loop2.cond, label %loop2, label %exit

exit:
  ret void
}

; Check that we don't do anything because of cleanuppad.
define void @test_cleanuppad(i1 %cond, i32 %N) personality ptr @__CxxFrameHandler3 {
; CHECK-LABEL: define void @test_cleanuppad(
; CHECK-SAME: i1 [[COND:%.*]], i32 [[N:%.*]]) personality ptr @__CxxFrameHandler3 {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 [[COND]]) [ "deopt"() ]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    invoke void @may_throw(i32 [[IV]])
; CHECK-NEXT:            to label %[[LOOP]] unwind label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[CP:%.*]] = cleanuppad within none []
; CHECK-NEXT:    cleanupret from [[CP]] unwind to caller
;
entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  invoke void @may_throw(i32 %iv) to label %loop unwind label %exit

exit:
  %cp = cleanuppad within none []
  cleanupret from %cp unwind to caller

}

declare void @may_throw(i32 %i)
declare i32 @__CxxFrameHandler3(...)

!0 = !{!"function_entry_count", i32 10}
;.
; CHECK: [[PROF0]] = !{!"function_entry_count", i32 10}
; CHECK: [[PROF1]] = !{!"branch_weights", i32 1048575, i32 1}
;.
