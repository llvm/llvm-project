; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: -p --check-globals all --version 5
; RUN: opt -passes='loop(simple-loop-unswitch<nontrivial>),verify<loops>' -simple-loop-unswitch-guards -S < %s | FileCheck %s
; RUN: opt -passes='simple-loop-unswitch<nontrivial>' -simple-loop-unswitch-guards -S < %s | FileCheck %s
; RUN: opt -passes='loop-mssa(simple-loop-unswitch<nontrivial>),verify<loops>' -simple-loop-unswitch-guards  -verify-memoryssa -verify-loop-info -S < %s | FileCheck %s

declare void @llvm.experimental.guard(i1, ...)

define void @test_simple_case(i1 %cond, i32 %N) !prof !0 {
; CHECK-LABEL: define void @test_simple_case(i1 %cond, i32 %N) !prof !0 {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 %cond, label %entry.split.us, label %entry.split, !prof !1
; CHECK:       entry.split.us:
; CHECK-NEXT:    br label %loop.us
; CHECK:       loop.us:
; CHECK-NEXT:    %iv.us = phi i32 [ 0, %entry.split.us ], [ %iv.next.us, %guarded.us ]
; CHECK-NEXT:    br label %guarded.us
; CHECK:       guarded.us:
; CHECK-NEXT:    %iv.next.us = add i32 %iv.us, 1
; CHECK-NEXT:    %loop.cond.us = icmp slt i32 %iv.next.us, %N
; CHECK-NEXT:    br i1 %loop.cond.us, label %loop.us, label %exit.split.us
; CHECK:       exit.split.us:
; CHECK-NEXT:    br label %exit
; CHECK:       entry.split:
; CHECK-NEXT:    br label %loop
; CHECK:       loop:
; CHECK-NEXT:    br label %deopt
; CHECK:       deopt:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       exit:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %exit

exit:
  ret void
}

define void @test_two_guards(i1 %cond1, i1 %cond2, i32 %N) {
; CHECK-LABEL: define void @test_two_guards(i1 %cond1, i1 %cond2, i32 %N) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 %cond1, label %entry.split.us, label %entry.split, !prof !1
; CHECK:       entry.split.us:
; CHECK-NEXT:    br i1 %cond2, label %entry.split.us.split.us, label %entry.split.us.split, !prof !1
; CHECK:       entry.split.us.split.us:
; CHECK-NEXT:    br label %loop.us.us
; CHECK:       loop.us.us:
; CHECK-NEXT:    %iv.us.us = phi i32 [ 0, %entry.split.us.split.us ], [ %iv.next.us.us, %guarded.us2 ]
; CHECK-NEXT:    br label %guarded.us.us
; CHECK:       guarded.us.us:
; CHECK-NEXT:    br label %guarded.us2
; CHECK:       guarded.us2:
; CHECK-NEXT:    %iv.next.us.us = add i32 %iv.us.us, 1
; CHECK-NEXT:    %loop.cond.us.us = icmp slt i32 %iv.next.us.us, %N
; CHECK-NEXT:    br i1 %loop.cond.us.us, label %loop.us.us, label %exit.split.us.split.us
; CHECK:       exit.split.us.split.us:
; CHECK-NEXT:    br label %exit.split.us
; CHECK:       entry.split.us.split:
; CHECK-NEXT:    br label %loop.us
; CHECK:       loop.us:
; CHECK-NEXT:    br label %guarded.us
; CHECK:       guarded.us:
; CHECK-NEXT:    br label %deopt1
; CHECK:       deopt1:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       exit.split.us:
; CHECK-NEXT:    br label %exit
; CHECK:       entry.split:
; CHECK-NEXT:    br label %loop
; CHECK:       loop:
; CHECK-NEXT:    br label %deopt
; CHECK:       deopt:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       exit:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond1) [ "deopt"() ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond2) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %exit

exit:
  ret void
}

define void @test_conditional_guards(i1 %cond, i32 %N) {
; CHECK-LABEL: define void @test_conditional_guards(i1 %cond, i32 %N) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    %cond.fr = freeze i1 %cond
; CHECK-NEXT:    br i1 %cond.fr, label %entry.split.us, label %entry.split, !prof !1
; CHECK:       entry.split.us:
; CHECK-NEXT:    br label %loop.us
; CHECK:       loop.us:
; CHECK-NEXT:    %iv.us = phi i32 [ 0, %entry.split.us ], [ %iv.next.us, %backedge.us ]
; CHECK-NEXT:    %condition.us = icmp eq i32 %iv.us, 123
; CHECK-NEXT:    br i1 %condition.us, label %guard.us, label %backedge.us
; CHECK:       guard.us:
; CHECK-NEXT:    br label %guarded.us
; CHECK:       backedge.us:
; CHECK-NEXT:    %iv.next.us = add i32 %iv.us, 1
; CHECK-NEXT:    %loop.cond.us = icmp slt i32 %iv.next.us, %N
; CHECK-NEXT:    br i1 %loop.cond.us, label %loop.us, label %exit.split.us
; CHECK:       guarded.us:
; CHECK-NEXT:    br label %backedge.us
; CHECK:       exit.split.us:
; CHECK-NEXT:    br label %exit
; CHECK:       entry.split:
; CHECK-NEXT:    br label %loop
; CHECK:       loop:
; CHECK-NEXT:    %iv = phi i32 [ 0, %entry.split ], [ %iv.next, %backedge ]
; CHECK-NEXT:    %condition = icmp eq i32 %iv, 123
; CHECK-NEXT:    br i1 %condition, label %guard, label %backedge
; CHECK:       guard:
; CHECK-NEXT:    br label %deopt
; CHECK:       deopt:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       backedge:
; CHECK-NEXT:    %iv.next = add i32 %iv, 1
; CHECK-NEXT:    %loop.cond = icmp slt i32 %iv.next, %N
; CHECK-NEXT:    br i1 %loop.cond, label %loop, label %exit.split
; CHECK:       exit.split:
; CHECK-NEXT:    br label %exit
; CHECK:       exit:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  %condition = icmp eq i32 %iv, 123
  br i1 %condition, label %guard, label %backedge

guard:
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  br label %backedge

backedge:
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %exit

exit:
  ret void
}

define void @test_nested_loop(i1 %cond, i32 %N, i1 %arg) {
; CHECK-LABEL: define void @test_nested_loop(i1 %cond, i32 %N, i1 %arg) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 %cond, label %entry.split, label %outer_loop.split, !prof !1
; CHECK:       entry.split:
; CHECK-NEXT:    br i1 %arg, label %entry.split.split.us, label %entry.split.split
; CHECK:       entry.split.split.us:
; CHECK-NEXT:    br label %outer_loop.us
; CHECK:       outer_loop.us:
; CHECK-NEXT:    br label %outer_loop.split.us.us
; CHECK:       outer_backedge.us:
; CHECK-NEXT:    br label %outer_loop.us
; CHECK:       outer_loop.split.us.us:
; CHECK-NEXT:    br label %loop.us.us
; CHECK:       loop.us.us:
; CHECK-NEXT:    %iv.us.us = phi i32 [ 0, %outer_loop.split.us.us ], [ %iv.next.us.us, %guarded.us.us ]
; CHECK-NEXT:    br label %guarded.us.us
; CHECK:       guarded.us.us:
; CHECK-NEXT:    %iv.next.us.us = add i32 %iv.us.us, 1
; CHECK-NEXT:    %loop.cond.us.us = icmp slt i32 %iv.next.us.us, %N
; CHECK-NEXT:    br i1 %loop.cond.us.us, label %loop.us.us, label %outer_backedge.split.us.us
; CHECK:       outer_backedge.split.us.us:
; CHECK-NEXT:    br label %outer_backedge.us
; CHECK:       entry.split.split:
; CHECK-NEXT:    br label %outer_loop
; CHECK:       outer_loop:
; CHECK-NEXT:    br label %outer_loop.split.us
; CHECK:       outer_loop.split.us:
; CHECK-NEXT:    br label %loop.us
; CHECK:       loop.us:
; CHECK-NEXT:    %iv.us = phi i32 [ 0, %outer_loop.split.us ], [ %iv.next.us, %guarded.us ]
; CHECK-NEXT:    br label %guarded.us
; CHECK:       guarded.us:
; CHECK-NEXT:    %iv.next.us = add i32 %iv.us, 1
; CHECK-NEXT:    %loop.cond.us = icmp slt i32 %iv.next.us, %N
; CHECK-NEXT:    br i1 %loop.cond.us, label %loop.us, label %outer_backedge.split.us
; CHECK:       outer_backedge.split.us:
; CHECK-NEXT:    br label %outer_backedge
; CHECK:       outer_loop.split:
; CHECK-NEXT:    br label %loop
; CHECK:       loop:
; CHECK-NEXT:    br label %deopt
; CHECK:       deopt:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       outer_backedge:
; CHECK-NEXT:    br label %exit
; CHECK:       exit:
; CHECK-NEXT:    ret void
;

entry:
  br label %outer_loop

outer_loop:
  br label %loop

loop:
  %iv = phi i32 [ 0, %outer_loop ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp slt i32 %iv.next, %N
  br i1 %loop.cond, label %loop, label %outer_backedge

outer_backedge:
  br i1 %arg, label %outer_loop, label %exit

exit:
  ret void
}

define void @test_sibling_loops(i1 %cond1, i1 %cond2, i32 %N) {
; CHECK-LABEL: define void @test_sibling_loops(i1 %cond1, i1 %cond2, i32 %N) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 %cond1, label %entry.split.us, label %entry.split, !prof !1
; CHECK:       entry.split.us:
; CHECK-NEXT:    br label %loop1.us
; CHECK:       loop1.us:
; CHECK-NEXT:    %iv1.us = phi i32 [ 0, %entry.split.us ], [ %iv1.next.us, %guarded.us ]
; CHECK-NEXT:    br label %guarded.us
; CHECK:       guarded.us:
; CHECK-NEXT:    %iv1.next.us = add i32 %iv1.us, 1
; CHECK-NEXT:    %loop1.cond.us = icmp slt i32 %iv1.next.us, %N
; CHECK-NEXT:    br i1 %loop1.cond.us, label %loop1.us, label %between.split.us
; CHECK:       between.split.us:
; CHECK-NEXT:    br label %between
; CHECK:       entry.split:
; CHECK-NEXT:    br label %loop1
; CHECK:       loop1:
; CHECK-NEXT:    br label %deopt
; CHECK:       deopt:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       between:
; CHECK-NEXT:    br i1 %cond2, label %between.split.us2, label %between.split, !prof !1
; CHECK:       between.split.us2:
; CHECK-NEXT:    br label %loop2.us
; CHECK:       loop2.us:
; CHECK-NEXT:    %iv2.us = phi i32 [ 0, %between.split.us2 ], [ %iv2.next.us, %guarded.us3 ]
; CHECK-NEXT:    br label %guarded.us3
; CHECK:       guarded.us3:
; CHECK-NEXT:    %iv2.next.us = add i32 %iv2.us, 1
; CHECK-NEXT:    %loop2.cond.us = icmp slt i32 %iv2.next.us, %N
; CHECK-NEXT:    br i1 %loop2.cond.us, label %loop2.us, label %exit.split.us
; CHECK:       exit.split.us:
; CHECK-NEXT:    br label %exit
; CHECK:       between.split:
; CHECK-NEXT:    br label %loop2
; CHECK:       loop2:
; CHECK-NEXT:    br label %deopt1
; CHECK:       deopt1:
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 false) [ "deopt"() ]
; CHECK-NEXT:    unreachable
; CHECK:       exit:
; CHECK-NEXT:    ret void
;

entry:
  br label %loop1

loop1:
  %iv1 = phi i32 [ 0, %entry ], [ %iv1.next, %loop1 ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond1) [ "deopt"() ]
  %iv1.next = add i32 %iv1, 1
  %loop1.cond = icmp slt i32 %iv1.next, %N
  br i1 %loop1.cond, label %loop1, label %between

between:
  br label %loop2

loop2:
  %iv2 = phi i32 [ 0, %between ], [ %iv2.next, %loop2 ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond2) [ "deopt"() ]
  %iv2.next = add i32 %iv2, 1
  %loop2.cond = icmp slt i32 %iv2.next, %N
  br i1 %loop2.cond, label %loop2, label %exit

exit:
  ret void
}

; Check that we don't do anything because of cleanuppad.
define void @test_cleanuppad(i1 %cond, i32 %N) personality ptr @__CxxFrameHandler3 {
; CHECK-LABEL: define void @test_cleanuppad(i1 %cond, i32 %N) personality ptr @__CxxFrameHandler3 {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label %loop
; CHECK:       loop:
; CHECK-NEXT:    %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
; CHECK-NEXT:    %iv.next = add i32 %iv, 1
; CHECK-NEXT:    invoke void @may_throw(i32 %iv)
; CHECK-NEXT:            to label %loop unwind label %exit
; CHECK:       exit:
; CHECK-NEXT:    %cp = cleanuppad within none []
; CHECK-NEXT:    cleanupret from %cp unwind to caller
;
entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ "deopt"() ]
  %iv.next = add i32 %iv, 1
  invoke void @may_throw(i32 %iv) to label %loop unwind label %exit

exit:
  %cp = cleanuppad within none []
  cleanupret from %cp unwind to caller

}

declare void @may_throw(i32 %i)
declare i32 @__CxxFrameHandler3(...)

!0 = !{!"function_entry_count", i32 10}
;.
; CHECK: !0 = !{!"function_entry_count", i32 10}
; CHECK: !1 = !{!"branch_weights", i32 1048575, i32 1}
;.
