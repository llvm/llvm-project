; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes='simple-loop-unswitch<nontrivial>' -unswitch-threshold=15 -S < %s | FileCheck %s

declare void @foo1()
declare void @foo2()
declare void @foo3()

define void @test(i32 %n, i32 %x) {
; CHECK-LABEL: define void @test(
; CHECK-SAME: i32 [[N:%.*]], i32 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    switch i32 [[X]], label [[FOR_BODY_PREHEADER_SPLIT:%.*]] [
; CHECK-NEXT:      i32 1, label [[FOR_BODY_PREHEADER_SPLIT_US:%.*]]
; CHECK-NEXT:      i32 2, label [[FOR_BODY_PREHEADER_SPLIT_US1:%.*]]
; CHECK-NEXT:      i32 3, label [[FOR_BODY_PREHEADER_SPLIT_US8:%.*]]
; CHECK-NEXT:    ]
; CHECK:       for.body.preheader.split.us:
; CHECK-NEXT:    br label [[FOR_BODY_US:%.*]]
; CHECK:       for.body.us:
; CHECK-NEXT:    [[I_US:%.*]] = phi i32 [ [[INC_US:%.*]], [[FOR_INC_US:%.*]] ], [ 0, [[FOR_BODY_PREHEADER_SPLIT_US]] ]
; CHECK-NEXT:    br label [[SW_BB1_US:%.*]]
; CHECK:       sw.bb1.us:
; CHECK-NEXT:    call void @foo1()
; CHECK-NEXT:    br label [[FOR_INC_US]]
; CHECK:       for.inc.us:
; CHECK-NEXT:    [[INC_US]] = add nuw nsw i32 [[I_US]], 1
; CHECK-NEXT:    [[EXITCOND_NOT_US:%.*]] = icmp eq i32 [[INC_US]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_US]], label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT_US:%.*]], label [[FOR_BODY_US]]
; CHECK:       for.cond.cleanup.loopexit.split.us:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]]
; CHECK:       for.body.preheader.split.us1:
; CHECK-NEXT:    br label [[FOR_BODY_US2:%.*]]
; CHECK:       for.body.us2:
; CHECK-NEXT:    [[I_US3:%.*]] = phi i32 [ [[INC_US6:%.*]], [[FOR_INC_US5:%.*]] ], [ 0, [[FOR_BODY_PREHEADER_SPLIT_US1]] ]
; CHECK-NEXT:    br label [[SW_BB2_US:%.*]]
; CHECK:       sw.bb2.us:
; CHECK-NEXT:    call void @foo2()
; CHECK-NEXT:    br label [[SW_BB3_US4:%.*]]
; CHECK:       sw.bb3.us4:
; CHECK-NEXT:    call void @foo3()
; CHECK-NEXT:    br label [[FOR_INC_US5]]
; CHECK:       for.inc.us5:
; CHECK-NEXT:    [[INC_US6]] = add nuw nsw i32 [[I_US3]], 1
; CHECK-NEXT:    [[EXITCOND_NOT_US7:%.*]] = icmp eq i32 [[INC_US6]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_US7]], label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT_SPLIT_US:%.*]], label [[FOR_BODY_US2]]
; CHECK:       for.cond.cleanup.loopexit.split.split.us:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT:%.*]]
; CHECK:       for.body.preheader.split.us8:
; CHECK-NEXT:    br label [[FOR_BODY_US9:%.*]]
; CHECK:       for.body.us9:
; CHECK-NEXT:    [[I_US10:%.*]] = phi i32 [ [[INC_US13:%.*]], [[FOR_INC_US12:%.*]] ], [ 0, [[FOR_BODY_PREHEADER_SPLIT_US8]] ]
; CHECK-NEXT:    br label [[SW_BB3_US11:%.*]]
; CHECK:       sw.bb3.us11:
; CHECK-NEXT:    call void @foo3()
; CHECK-NEXT:    br label [[FOR_INC_US12]]
; CHECK:       for.inc.us12:
; CHECK-NEXT:    [[INC_US13]] = add nuw nsw i32 [[I_US10]], 1
; CHECK-NEXT:    [[EXITCOND_NOT_US14:%.*]] = icmp eq i32 [[INC_US13]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT_US14]], label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT_SPLIT_SPLIT_US:%.*]], label [[FOR_BODY_US9]]
; CHECK:       for.cond.cleanup.loopexit.split.split.split.us:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT_SPLIT:%.*]]
; CHECK:       for.body.preheader.split:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_INC:%.*]] ], [ 0, [[FOR_BODY_PREHEADER_SPLIT]] ]
; CHECK-NEXT:    br label [[FOR_INC]]
; CHECK:       for.inc:
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT_SPLIT_SPLIT:%.*]], label [[FOR_BODY]]
; CHECK:       for.cond.cleanup.loopexit.split.split.split:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT_SPLIT]]
; CHECK:       for.cond.cleanup.loopexit.split.split:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP_LOOPEXIT_SPLIT]]
; CHECK:       for.cond.cleanup.loopexit.split:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP_LOOPEXIT]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %i = phi i32 [ %inc, %for.inc ], [ 0, %entry ]
  switch i32 %x, label %for.inc [
  i32 1, label %sw.bb1
  i32 2, label %sw.bb2
  i32 3, label %sw.bb3
  ]

sw.bb1:
  call void @foo1()
  br label %for.inc

sw.bb2:
  call void @foo2()
  br label %sw.bb3

sw.bb3:
  call void @foo3()
  br label %for.inc

for.inc:
  %inc = add nuw nsw i32 %i, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}
