; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -p sccp -S | FileCheck %s

define i1 @result_le_count() {
; CHECK-LABEL: define i1 @result_le_count() {
; CHECK-NEXT:    ret i1 true
;
  %x = call i32 @llvm.experimental.get.vector.length(i32 3, i32 4, i1 false)
  %res = icmp ule i32 %x, 3
  ret i1 %res
}

define i1 @result_le_max_lanes(i32 %count) {
; CHECK-LABEL: define i1 @result_le_max_lanes(
; CHECK-SAME: i32 [[COUNT:%.*]]) {
; CHECK-NEXT:    [[X:%.*]] = call i32 @llvm.experimental.get.vector.length.i32(i32 [[COUNT]], i32 3, i1 false)
; CHECK-NEXT:    ret i1 true
;
  %x = call i32 @llvm.experimental.get.vector.length(i32 %count, i32 3, i1 false)
  %res = icmp ule i32 %x, 3
  ret i1 %res
}

define i1 @result_le_max_lanes_scalable(i32 %count) vscale_range(2, 4) {
; CHECK-LABEL: define i1 @result_le_max_lanes_scalable(
; CHECK-SAME: i32 [[COUNT:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[X:%.*]] = call i32 @llvm.experimental.get.vector.length.i32(i32 [[COUNT]], i32 4, i1 true)
; CHECK-NEXT:    ret i1 true
;
  %x = call i32 @llvm.experimental.get.vector.length(i32 %count, i32 4, i1 true)
  %res = icmp ule i32 %x, 16
  ret i1 %res
}

define i32 @count_le_max_lanes() {
; CHECK-LABEL: define i32 @count_le_max_lanes() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret i32 4
;
entry:
  br label %loop

loop:
  %iv = phi i32 [4, %entry], [%iv.next, %loop]
  %x = call i32 @llvm.experimental.get.vector.length(i32 %iv, i32 4, i1 false)
  %iv.next = sub i32 %iv, %x
  %ec = icmp eq i32 %iv.next, 0
  br i1 %ec, label %exit, label %loop

exit:
  ret i32 %x
}

; Can't simplify because %iv isn't <= max lanes.
define i32 @count_not_le_max_lanes() {
; CHECK-LABEL: define range(i32 0, 5) i32 @count_not_le_max_lanes() {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 6, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[X:%.*]] = call i32 @llvm.experimental.get.vector.length.i32(i32 [[IV]], i32 4, i1 false)
; CHECK-NEXT:    [[IV_NEXT]] = sub i32 [[IV]], [[X]]
; CHECK-NEXT:    [[EC:%.*]] = icmp eq i32 [[IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret i32 [[X]]
;
entry:
  br label %loop

loop:
  %iv = phi i32 [6, %entry], [%iv.next, %loop]
  %x = call i32 @llvm.experimental.get.vector.length(i32 %iv, i32 4, i1 false)
  %iv.next = sub i32 %iv, %x
  %ec = icmp eq i32 %iv.next, 0
  br i1 %ec, label %exit, label %loop

exit:
  ret i32 %x
}

define i32 @count_le_max_lanes_scalable_known() vscale_range(4, 8) {
; CHECK-LABEL: define i32 @count_le_max_lanes_scalable_known(
; CHECK-SAME: ) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret i32 16
;
entry:
  br label %loop

loop:
  %iv = phi i32 [16, %entry], [%iv.next, %loop]
  %x = call i32 @llvm.experimental.get.vector.length(i32 %iv, i32 4, i1 true)
  %iv.next = sub i32 %iv, %x
  %ec = icmp eq i32 %iv.next, 0
  br i1 %ec, label %exit, label %loop

exit:
  ret i32 %x
}

; Can't simplify because %iv isn't guaranteed <= max lanes.
define i32 @count_le_max_lanes_scalable_unknown() {
; CHECK-LABEL: define i32 @count_le_max_lanes_scalable_unknown() {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 16, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[X:%.*]] = call i32 @llvm.experimental.get.vector.length.i32(i32 [[IV]], i32 4, i1 true)
; CHECK-NEXT:    [[IV_NEXT]] = sub i32 [[IV]], [[X]]
; CHECK-NEXT:    [[EC:%.*]] = icmp eq i32 [[IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret i32 [[X]]
;
entry:
  br label %loop

loop:
  %iv = phi i32 [16, %entry], [%iv.next, %loop]
  %x = call i32 @llvm.experimental.get.vector.length(i32 %iv, i32 4, i1 true)
  %iv.next = sub i32 %iv, %x
  %ec = icmp eq i32 %iv.next, 0
  br i1 %ec, label %exit, label %loop

exit:
  ret i32 %x
}

define i1 @result_le_overflow() {
; CHECK-LABEL: define i1 @result_le_overflow() {
; CHECK-NEXT:    [[X:%.*]] = call i32 @llvm.experimental.get.vector.length.i64(i64 4294967296, i32 4, i1 false)
; CHECK-NEXT:    [[RES:%.*]] = icmp ule i32 [[X]], 3
; CHECK-NEXT:    ret i1 [[RES]]
;
  %x = call i32 @llvm.experimental.get.vector.length(i64 u0x100000000, i32 4, i1 false)
  %res = icmp ule i32 %x, 3
  ret i1 %res
}

; This test case was manually reduced from a downstream failure where the
; intrinsic call was constant folded to 4. Reproducing this exactly requires
; very specific visitation order. The reduction here was only able to show an
; incorrect result range of [4, 13) being calculated. The correct result range
; must contain [4, 4097).
define i32 @incorrect_result_range(i32 %x) vscale_range(16, 1024) {
; CHECK-LABEL: define range(i32 0, 4097) i32 @incorrect_result_range(
; CHECK-SAME: i32 [[X:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[OFFSET:%.*]] = phi i32 [ 1, %[[ENTRY]] ], [ [[OFFSET_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[ADD:%.*]] = add nuw nsw i32 [[OFFSET]], 3
; CHECK-NEXT:    [[LEN:%.*]] = call i32 @llvm.experimental.get.vector.length.i32(i32 [[ADD]], i32 4, i1 true)
; CHECK-NEXT:    [[OFFSET_NEXT]] = add nuw nsw i32 [[OFFSET]], 4
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 4
; CHECK-NEXT:    [[EC:%.*]] = icmp eq i32 [[IV_NEXT]], [[X]]
; CHECK-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret i32 [[LEN]]
;
entry:
  br label %loop

loop:
  %iv = phi i32 [0, %entry], [%iv.next, %loop]
  %offset = phi i32 [1, %entry], [%offset.next, %loop]
  %add = add nuw nsw i32 %offset, 3
  %len = call i32 @llvm.experimental.get.vector.length(i32 %add, i32 4, i1 true)
  %offset.next = add nuw nsw i32 %offset, 4
  %iv.next = add nuw nsw i32 %iv, 4
  %ec = icmp eq i32 %iv.next, %x
  br i1 %ec, label %exit, label %loop

exit:
  ret i32 %len
}
