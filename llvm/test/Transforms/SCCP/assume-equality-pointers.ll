; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=ipsccp -S | FileCheck %s

define ptr @assume_pointers_equality_maybe_different_provenance_1(ptr %x) {
; CHECK-LABEL: define ptr @assume_pointers_equality_maybe_different_provenance_1(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[X]], inttoptr (i64 12345678 to ptr)
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    ret ptr [[X]]
;
entry:
  %cmp = icmp eq ptr %x, inttoptr (i64 12345678 to ptr)
  call void @llvm.assume(i1 %cmp)
  ret ptr %x
}

define ptr @assume_pointers_equality_maybe_different_provenance_2(ptr %x, i1 %cond) {
; CHECK-LABEL: define ptr @assume_pointers_equality_maybe_different_provenance_2(
; CHECK-SAME: ptr [[X:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[X]], inttoptr (i64 12345678 to ptr)
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    br i1 [[COND]], label %[[NEXT:.*]], label %[[EXIT:.*]]
; CHECK:       [[NEXT]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[X]], %[[ENTRY]] ], [ inttoptr (i64 12345678 to ptr), %[[NEXT]] ]
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  %cmp = icmp eq ptr %x, inttoptr (i64 12345678 to ptr)
  call void @llvm.assume(i1 %cmp)
  br i1 %cond, label %next, label %exit

next:
  br label %exit

exit:
  %phi = phi ptr [ %x, %entry ], [ inttoptr (i64 12345678 to ptr), %next ]
  ret ptr %phi
}

define internal ptr @callee(ptr returned %p) memory(none) {
; CHECK-LABEL: define internal ptr @callee(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret ptr poison
;
entry:
  ret ptr %p
}

define ptr @assume_pointers_equality_maybe_different_provenance_3(ptr %x, i1 %cond) {
; CHECK-LABEL: define ptr @assume_pointers_equality_maybe_different_provenance_3(
; CHECK-SAME: ptr [[X:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[X]], inttoptr (i64 12345678 to ptr)
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    br i1 [[COND]], label %[[NEXT:.*]], label %[[EXIT:.*]]
; CHECK:       [[NEXT]]:
; CHECK-NEXT:    [[SEL:%.*]] = select i1 true, ptr [[X]], ptr inttoptr (i64 12345678 to ptr)
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[X]], %[[ENTRY]] ], [ [[SEL]], %[[NEXT]] ]
; CHECK-NEXT:    [[Q:%.*]] = call ptr @callee(ptr [[PHI]])
; CHECK-NEXT:    [[SEL2:%.*]] = select i1 [[COND]], ptr [[Q]], ptr [[X]]
; CHECK-NEXT:    ret ptr [[SEL2]]
;
entry:
  %cmp = icmp eq ptr %x, inttoptr (i64 12345678 to ptr)
  call void @llvm.assume(i1 %cmp)
  br i1 %cond, label %next, label %exit

next:
  %sel = select i1 %cond, ptr %x, ptr inttoptr (i64 12345678 to ptr)
  br label %exit

exit:
  %phi = phi ptr [ %x, %entry ], [ %sel, %next ]
  %q = call ptr @callee(ptr %phi)
  %sel2 = select i1 %cond, ptr %q, ptr %x
  ret ptr %sel2
}

declare void @llvm.assume(i1)
