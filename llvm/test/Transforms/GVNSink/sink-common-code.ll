; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -gvn-sink -simplifycfg -simplifycfg-require-and-preserve-domtree=1 -hoist-common-insts=true -simplifycfg-sink-common=false -S | FileCheck %s

define zeroext i1 @test1(i1 zeroext %flag, i32 %blksA, i32 %blksB, i32 %nblks) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[BLKSA:%.*]], [[NBLKS:%.*]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[NBLKS]], [[BLKSB:%.*]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ule i32 [[ADD]], [[BLKSA]]
; CHECK-NEXT:    [[CMP_SINK:%.*]] = select i1 [[FLAG:%.*]], i1 [[CMP]], i1 [[CMP2]]
; CHECK-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[CMP_SINK]] to i8
; CHECK-NEXT:    [[TOBOOL4:%.*]] = icmp ne i8 [[FROMBOOL1]], 0
; CHECK-NEXT:    ret i1 [[TOBOOL4]]
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %cmp = icmp uge i32 %blksA, %nblks
  %frombool1 = zext i1 %cmp to i8
  br label %if.end

if.else:
  %add = add i32 %nblks, %blksB
  %cmp2 = icmp ule i32 %add, %blksA
  %frombool3 = zext i1 %cmp2 to i8
  br label %if.end

if.end:
  %obeys.0 = phi i8 [ %frombool1, %if.then ], [ %frombool3, %if.else ]
  %tobool4 = icmp ne i8 %obeys.0, 0
  ret i1 %tobool4
}

define zeroext i1 @test2(i1 zeroext %flag, i32 %blksA, i32 %blksB, i32 %nblks) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[NBLKS:%.*]], [[BLKSB:%.*]]
; CHECK-NEXT:    [[NBLKS_SINK:%.*]] = select i1 [[FLAG:%.*]], i32 [[NBLKS]], i32 [[ADD]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[BLKSA:%.*]], [[NBLKS_SINK]]
; CHECK-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[CMP]] to i8
; CHECK-NEXT:    [[TOBOOL4:%.*]] = icmp ne i8 [[FROMBOOL1]], 0
; CHECK-NEXT:    ret i1 [[TOBOOL4]]
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %cmp = icmp uge i32 %blksA, %nblks
  %frombool1 = zext i1 %cmp to i8
  br label %if.end

if.else:
  %add = add i32 %nblks, %blksB
  %cmp2 = icmp uge i32 %blksA, %add
  %frombool3 = zext i1 %cmp2 to i8
  br label %if.end

if.end:
  %obeys.0 = phi i8 [ %frombool1, %if.then ], [ %frombool3, %if.else ]
  %tobool4 = icmp ne i8 %obeys.0, 0
  ret i1 %tobool4
}

declare i32 @foo(i32, i32) nounwind readnone

; FIXME: The test failes when the original order of the
; candidates with the same cost is preserved.
;
;define i32 @test3(i1 zeroext %flag, i32 %x, i32 %y) {
;entry:
;  br i1 %flag, label %if.then, label %if.else
;
;if.then:
;  %x0 = call i32 @foo(i32 %x, i32 0) nounwind readnone
;  %y0 = call i32 @foo(i32 %x, i32 1) nounwind readnone
;  br label %if.end
;
;if.else:
;  %x1 = call i32 @foo(i32 %y, i32 0) nounwind readnone
;  %y1 = call i32 @foo(i32 %y, i32 1) nounwind readnone
;  br label %if.end
;
;if.end:
;  %xx = phi i32 [ %x0, %if.then ], [ %x1, %if.else ]
;  %yy = phi i32 [ %y0, %if.then ], [ %y1, %if.else ]
;  %ret = add i32 %xx, %yy
;  ret i32 %ret
;}
;
; -CHECK-LABEL: test3
; -CHECK: select
; -CHECK: call
; -CHECK: call
; -CHECK: add
; -CHECK-NOT: br

define i32 @test4(i1 zeroext %flag, i32 %x, i32* %y) {
; CHECK-LABEL: @test4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[FLAG:%.*]], i32 5, i32 7
; CHECK-NEXT:    [[A:%.*]] = add i32 [[X:%.*]], [[DOT]]
; CHECK-NEXT:    store i32 [[A]], i32* [[Y:%.*]], align 4
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %a = add i32 %x, 5
  store i32 %a, i32* %y
  br label %if.end

if.else:
  %b = add i32 %x, 7
  store i32 %b, i32* %y
  br label %if.end

if.end:
  ret i32 1
}

define i32 @test5(i1 zeroext %flag, i32 %x, i32* %y) {
; CHECK-LABEL: @test5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[A:%.*]] = add i32 [[X:%.*]], 5
; CHECK-NEXT:    store volatile i32 [[A]], i32* [[Y:%.*]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[B:%.*]] = add i32 [[X]], 7
; CHECK-NEXT:    store i32 [[B]], i32* [[Y]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %a = add i32 %x, 5
  store volatile i32 %a, i32* %y
  br label %if.end

if.else:
  %b = add i32 %x, 7
  store i32 %b, i32* %y
  br label %if.end

if.end:
  ret i32 1
}

define i32 @test6(i1 zeroext %flag, i32 %x, i32* %y) {
; CHECK-LABEL: @test6(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[FLAG:%.*]], i32 5, i32 7
; CHECK-NEXT:    [[A:%.*]] = add i32 [[X:%.*]], [[DOT]]
; CHECK-NEXT:    store volatile i32 [[A]], i32* [[Y:%.*]], align 4
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %a = add i32 %x, 5
  store volatile i32 %a, i32* %y
  br label %if.end

if.else:
  %b = add i32 %x, 7
  store volatile i32 %b, i32* %y
  br label %if.end

if.end:
  ret i32 1
}

define i32 @test7(i1 zeroext %flag, i32 %x, i32* %y) {
; CHECK-LABEL: @test7(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[FLAG:%.*]], i32 5, i32 7
; CHECK-NEXT:    [[Z:%.*]] = load volatile i32, i32* [[Y:%.*]], align 4
; CHECK-NEXT:    [[A:%.*]] = add i32 [[Z]], [[DOT]]
; CHECK-NEXT:    store volatile i32 [[A]], i32* [[Y]], align 4
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %z = load volatile i32, i32* %y
  %a = add i32 %z, 5
  store volatile i32 %a, i32* %y
  br label %if.end

if.else:
  %w = load volatile i32, i32* %y
  %b = add i32 %w, 7
  store volatile i32 %b, i32* %y
  br label %if.end

if.end:
  ret i32 1
}

; The extra store in %if.then means %z and %w are not equivalent.
define i32 @test9(i1 zeroext %flag, i32 %x, i32* %y, i32* %p) {
; CHECK-LABEL: @test9(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store i32 7, i32* [[P:%.*]], align 4
; CHECK-NEXT:    [[Z:%.*]] = load volatile i32, i32* [[Y:%.*]], align 4
; CHECK-NEXT:    store i32 6, i32* [[P]], align 4
; CHECK-NEXT:    [[A:%.*]] = add i32 [[Z]], 5
; CHECK-NEXT:    store volatile i32 [[A]], i32* [[Y]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[W:%.*]] = load volatile i32, i32* [[Y]], align 4
; CHECK-NEXT:    [[B:%.*]] = add i32 [[W]], 7
; CHECK-NEXT:    store volatile i32 [[B]], i32* [[Y]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  store i32 7, i32* %p
  %z = load volatile i32, i32* %y
  store i32 6, i32* %p
  %a = add i32 %z, 5
  store volatile i32 %a, i32* %y
  br label %if.end

if.else:
  %w = load volatile i32, i32* %y
  %b = add i32 %w, 7
  store volatile i32 %b, i32* %y
  br label %if.end

if.end:
  ret i32 1
}

%struct.anon = type { i32, i32 }

; The GEP indexes a struct type so cannot have a variable last index.
define i32 @test10(i1 zeroext %flag, i32 %x, i32* %y, %struct.anon* %s) {
; CHECK-LABEL: @test10(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[DUMMY:%.*]] = add i32 [[X:%.*]], 5
; CHECK-NEXT:    [[GEPA:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], %struct.anon* [[S:%.*]], i32 0, i32 0
; CHECK-NEXT:    store volatile i32 [[X]], i32* [[GEPA]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[DUMMY1:%.*]] = add i32 [[X]], 6
; CHECK-NEXT:    [[GEPB:%.*]] = getelementptr inbounds [[STRUCT_ANON]], %struct.anon* [[S]], i32 0, i32 1
; CHECK-NEXT:    store volatile i32 [[X]], i32* [[GEPB]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %dummy = add i32 %x, 5
  %gepa = getelementptr inbounds %struct.anon, %struct.anon* %s, i32 0, i32 0
  store volatile i32 %x, i32* %gepa
  br label %if.end

if.else:
  %dummy1 = add i32 %x, 6
  %gepb = getelementptr inbounds %struct.anon, %struct.anon* %s, i32 0, i32 1
  store volatile i32 %x, i32* %gepb
  br label %if.end

if.end:
  ret i32 1
}

; The shufflevector's mask operand cannot be merged in a PHI.
define i32 @test11(i1 zeroext %flag, i32 %w, <2 x i32> %x, <2 x i32> %y) {
; CHECK-LABEL: @test11(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[DUMMY:%.*]] = add i32 [[W:%.*]], 5
; CHECK-NEXT:    [[SV1:%.*]] = shufflevector <2 x i32> [[X:%.*]], <2 x i32> [[Y:%.*]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[DUMMY1:%.*]] = add i32 [[W]], 6
; CHECK-NEXT:    [[SV2:%.*]] = shufflevector <2 x i32> [[X]], <2 x i32> [[Y]], <2 x i32> <i32 1, i32 0>
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[P:%.*]] = phi <2 x i32> [ [[SV1]], [[IF_THEN]] ], [ [[SV2]], [[IF_ELSE]] ]
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %dummy = add i32 %w, 5
  %sv1 = shufflevector <2 x i32> %x, <2 x i32> %y, <2 x i32> <i32 0, i32 1>
  br label %if.end

if.else:
  %dummy1 = add i32 %w, 6
  %sv2 = shufflevector <2 x i32> %x, <2 x i32> %y, <2 x i32> <i32 1, i32 0>
  br label %if.end

if.end:
  %p = phi <2 x i32> [ %sv1, %if.then ], [ %sv2, %if.else ]
  ret i32 1
}

; We can't common an intrinsic!
define i32 @test12(i1 zeroext %flag, i32 %w, i32 %x, i32 %y) {
; CHECK-LABEL: @test12(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[DUMMY:%.*]] = add i32 [[W:%.*]], 5
; CHECK-NEXT:    [[SV1:%.*]] = call i32 @llvm.ctlz.i32(i32 [[X:%.*]], i1 false)
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[DUMMY1:%.*]] = add i32 [[W]], 6
; CHECK-NEXT:    [[SV2:%.*]] = call i32 @llvm.cttz.i32(i32 [[X]], i1 false)
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[P:%.*]] = phi i32 [ [[SV1]], [[IF_THEN]] ], [ [[SV2]], [[IF_ELSE]] ]
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %dummy = add i32 %w, 5
  %sv1 = call i32 @llvm.ctlz.i32(i32 %x)
  br label %if.end

if.else:
  %dummy1 = add i32 %w, 6
  %sv2 = call i32 @llvm.cttz.i32(i32 %x)
  br label %if.end

if.end:
  %p = phi i32 [ %sv1, %if.then ], [ %sv2, %if.else ]
  ret i32 1
}

declare i32 @llvm.ctlz.i32(i32 %x) readnone
declare i32 @llvm.cttz.i32(i32 %x) readnone

; The TBAA metadata should be properly combined.
define i32 @test13(i1 zeroext %flag, i32 %x, i32* %y) {
; CHECK-LABEL: @test13(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[FLAG:%.*]], i32 5, i32 7
; CHECK-NEXT:    [[Z:%.*]] = load volatile i32, i32* [[Y:%.*]], align 4
; CHECK-NEXT:    [[A:%.*]] = add i32 [[Z]], [[DOT]]
; CHECK-NEXT:    store volatile i32 [[A]], i32* [[Y]], align 4, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %z = load volatile i32, i32* %y
  %a = add i32 %z, 5
  store volatile i32 %a, i32* %y, !tbaa !3
  br label %if.end

if.else:
  %w = load volatile i32, i32* %y
  %b = add i32 %w, 7
  store volatile i32 %b, i32* %y, !tbaa !4
  br label %if.end

if.end:
  ret i32 1
}

!0 = !{ !"an example type tree" }
!1 = !{ !"int", !0 }
!2 = !{ !"float", !0 }
!3 = !{ !"const float", !2, i64 0 }
!4 = !{ !"special float", !2, i64 1 }

; The call should be commoned.
define i32 @test13a(i1 zeroext %flag, i32 %w, i32 %x, i32 %y) {
; CHECK-LABEL: @test13a(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[X_Y:%.*]] = select i1 [[FLAG:%.*]], i32 [[X:%.*]], i32 [[Y:%.*]]
; CHECK-NEXT:    [[SV1:%.*]] = call i32 @bar(i32 [[X_Y]])
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %sv1 = call i32 @bar(i32 %x)
  br label %if.end

if.else:
  %sv2 = call i32 @bar(i32 %y)
  br label %if.end

if.end:
  %p = phi i32 [ %sv1, %if.then ], [ %sv2, %if.else ]
  ret i32 1
}
declare i32 @bar(i32)

; The load should be commoned.
define i32 @test14(i1 zeroext %flag, i32 %w, i32 %x, i32 %y, %struct.anon* %s) {
; CHECK-LABEL: @test14(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[DUMMY:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[DUMMY2:%.*]] = add i32 [[X]], 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi i32 [ 56, [[IF_THEN]] ], [ 57, [[IF_ELSE]] ]
; CHECK-NEXT:    [[GEPA:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], %struct.anon* [[S:%.*]], i32 0, i32 1
; CHECK-NEXT:    [[SV1:%.*]] = load i32, i32* [[GEPA]], align 4
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[SV1]], [[DOTSINK]]
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %dummy = add i32 %x, 1
  %gepa = getelementptr inbounds %struct.anon, %struct.anon* %s, i32 0, i32 1
  %sv1 = load i32, i32* %gepa
  %cmp1 = icmp eq i32 %sv1, 56
  br label %if.end

if.else:
  %dummy2 = add i32 %x, 4
  %gepb = getelementptr inbounds %struct.anon, %struct.anon* %s, i32 0, i32 1
  %sv2 = load i32, i32* %gepb
  %cmp2 = icmp eq i32 %sv2, 57
  br label %if.end

if.end:
  %p = phi i1 [ %cmp1, %if.then ], [ %cmp2, %if.else ]
  ret i32 1
}

; The load should be commoned.
define i32 @test15(i1 zeroext %flag, i32 %w, i32 %x, i32 %y, %struct.anon* %s) {
; CHECK-LABEL: @test15(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[DUMMY:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    [[GEPA:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], %struct.anon* [[S:%.*]], i32 0, i32 0
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[DUMMY2:%.*]] = add i32 [[X]], 4
; CHECK-NEXT:    [[GEPB:%.*]] = getelementptr inbounds [[STRUCT_ANON]], %struct.anon* [[S]], i32 0, i32 1
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[GEPA_SINK:%.*]] = phi i32* [ [[GEPA]], [[IF_THEN]] ], [ [[GEPB]], [[IF_ELSE]] ]
; CHECK-NEXT:    [[SV1:%.*]] = load i32, i32* [[GEPA_SINK]], align 4
; CHECK-NEXT:    [[EXT1:%.*]] = zext i32 [[SV1]] to i64
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[EXT1]], 56
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %dummy = add i32 %x, 1
  %gepa = getelementptr inbounds %struct.anon, %struct.anon* %s, i32 0, i32 0
  %sv1 = load i32, i32* %gepa
  %ext1 = zext i32 %sv1 to i64
  %cmp1 = icmp eq i64 %ext1, 56
  br label %if.end

if.else:
  %dummy2 = add i32 %x, 4
  %gepb = getelementptr inbounds %struct.anon, %struct.anon* %s, i32 0, i32 1
  %sv2 = load i32, i32* %gepb
  %ext2 = zext i32 %sv2 to i64
  %cmp2 = icmp eq i64 %ext2, 56
  br label %if.end

if.end:
  %p = phi i1 [ %cmp1, %if.then ], [ %cmp2, %if.else ]
  ret i32 1
}

define zeroext i1 @test_crash(i1 zeroext %flag, i32* %i4, i32* %m, i32* %n) {
; CHECK-LABEL: @test_crash(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[I4:%.*]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 [[TMP1]], -1
; CHECK-NEXT:    store i32 [[TMP2]], i32* [[I4]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* [[M:%.*]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32* [[N:%.*]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = add i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    store i32 [[TMP5]], i32* [[I4]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %tmp1 = load i32, i32* %i4
  %tmp2 = add i32 %tmp1, -1
  store i32 %tmp2, i32* %i4
  br label %if.end

if.else:
  %tmp3 = load i32, i32* %m
  %tmp4 = load i32, i32* %n
  %tmp5 = add i32 %tmp3, %tmp4
  store i32 %tmp5, i32* %i4
  br label %if.end

if.end:
  ret i1 true
}

define zeroext i1 @test16(i1 zeroext %flag, i1 zeroext %flag2, i32 %blksA, i32 %blksB, i32 %nblks) {
; CHECK-LABEL: @test16(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[BLKSA:%.*]], [[NBLKS:%.*]]
; CHECK-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[CMP]] to i8
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    br i1 [[FLAG2:%.*]], label [[IF_THEN2:%.*]], label [[IF_END]]
; CHECK:       if.then2:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[NBLKS]], [[BLKSB:%.*]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ule i32 [[ADD]], [[BLKSA]]
; CHECK-NEXT:    [[FROMBOOL3:%.*]] = zext i1 [[CMP2]] to i8
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[OBEYS_0:%.*]] = phi i8 [ [[FROMBOOL1]], [[IF_THEN]] ], [ [[FROMBOOL3]], [[IF_THEN2]] ], [ 0, [[IF_ELSE]] ]
; CHECK-NEXT:    [[TOBOOL4:%.*]] = icmp ne i8 [[OBEYS_0]], 0
; CHECK-NEXT:    ret i1 [[TOBOOL4]]
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %cmp = icmp uge i32 %blksA, %nblks
  %frombool1 = zext i1 %cmp to i8
  br label %if.end

if.else:
  br i1 %flag2, label %if.then2, label %if.end

if.then2:
  %add = add i32 %nblks, %blksB
  %cmp2 = icmp ule i32 %add, %blksA
  %frombool3 = zext i1 %cmp2 to i8
  br label %if.end

if.end:
  %obeys.0 = phi i8 [ %frombool1, %if.then ], [ %frombool3, %if.then2 ], [ 0, %if.else ]
  %tobool4 = icmp ne i8 %obeys.0, 0
  ret i1 %tobool4
}

define zeroext i1 @test16a(i1 zeroext %flag, i1 zeroext %flag2, i32 %blksA, i32 %blksB, i32 %nblks, i8* %p) {
; CHECK-LABEL: @test16a(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[BLKSA:%.*]], [[NBLKS:%.*]]
; CHECK-NEXT:    br label [[IF_END_GVNSINK_SPLIT:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    br i1 [[FLAG2:%.*]], label [[IF_THEN2:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then2:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[NBLKS]], [[BLKSB:%.*]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ule i32 [[ADD]], [[BLKSA]]
; CHECK-NEXT:    br label [[IF_END_GVNSINK_SPLIT]]
; CHECK:       if.end.gvnsink.split:
; CHECK-NEXT:    [[CMP_SINK:%.*]] = phi i1 [ [[CMP]], [[IF_THEN]] ], [ [[CMP2]], [[IF_THEN2]] ]
; CHECK-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[CMP_SINK]] to i8
; CHECK-NEXT:    [[B1:%.*]] = sext i8 [[FROMBOOL1]] to i32
; CHECK-NEXT:    [[B2:%.*]] = trunc i32 [[B1]] to i8
; CHECK-NEXT:    store i8 [[B2]], i8* [[P:%.*]], align 1
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %cmp = icmp uge i32 %blksA, %nblks
  %frombool1 = zext i1 %cmp to i8
  %b1 = sext i8 %frombool1 to i32
  %b2 = trunc i32 %b1 to i8
  store i8 %b2, i8* %p
  br label %if.end

if.else:
  br i1 %flag2, label %if.then2, label %if.end

if.then2:
  %add = add i32 %nblks, %blksB
  %cmp2 = icmp ule i32 %add, %blksA
  %frombool3 = zext i1 %cmp2 to i8
  %a1 = sext i8 %frombool3 to i32
  %a2 = trunc i32 %a1 to i8
  store i8 %a2, i8* %p
  br label %if.end

if.end:
  ret i1 true
}

; FIXME: we don't consider this profitable. We should
;  - Consider argument setup/return mov'ing for calls, like InlineCost does.
;  - Consider the removal of the %obeys.0 PHI (zero PHI movement overall)
define zeroext i1 @test17(i32 %flag, i32 %blksA, i32 %blksB, i32 %nblks) {
; CHECK-LABEL: @test17(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i32 [[FLAG:%.*]], label [[IF_END:%.*]] [
; CHECK-NEXT:    i32 0, label [[IF_THEN:%.*]]
; CHECK-NEXT:    i32 1, label [[IF_THEN2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       if.then:
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[BLKSA:%.*]], [[NBLKS:%.*]]
; CHECK-NEXT:    [[FROMBOOL1:%.*]] = call i8 @i1toi8(i1 [[CMP]])
; CHECK-NEXT:    [[A1:%.*]] = sext i8 [[FROMBOOL1]] to i32
; CHECK-NEXT:    [[A2:%.*]] = trunc i32 [[A1]] to i8
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.then2:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[NBLKS]], [[BLKSB:%.*]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ule i32 [[ADD]], [[BLKSA]]
; CHECK-NEXT:    [[FROMBOOL3:%.*]] = call i8 @i1toi8(i1 [[CMP2]])
; CHECK-NEXT:    [[B1:%.*]] = sext i8 [[FROMBOOL3]] to i32
; CHECK-NEXT:    [[B2:%.*]] = trunc i32 [[B1]] to i8
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[OBEYS_0:%.*]] = phi i8 [ [[A2]], [[IF_THEN]] ], [ [[B2]], [[IF_THEN2]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TOBOOL4:%.*]] = icmp ne i8 [[OBEYS_0]], 0
; CHECK-NEXT:    ret i1 [[TOBOOL4]]
;
entry:
  switch i32 %flag, label %if.end [
  i32 0, label %if.then
  i32 1, label %if.then2
  ]

if.then:
  %cmp = icmp uge i32 %blksA, %nblks
  %frombool1 = call i8 @i1toi8(i1 %cmp)
  %a1 = sext i8 %frombool1 to i32
  %a2 = trunc i32 %a1 to i8
  br label %if.end

if.then2:
  %add = add i32 %nblks, %blksB
  %cmp2 = icmp ule i32 %add, %blksA
  %frombool3 = call i8 @i1toi8(i1 %cmp2)
  %b1 = sext i8 %frombool3 to i32
  %b2 = trunc i32 %b1 to i8
  br label %if.end

if.end:
  %obeys.0 = phi i8 [ %a2, %if.then ], [ %b2, %if.then2 ], [ 0, %entry ]
  %tobool4 = icmp ne i8 %obeys.0, 0
  ret i1 %tobool4
}
declare i8 @i1toi8(i1)

define zeroext i1 @test18(i32 %flag, i32 %blksA, i32 %blksB, i32 %nblks) {
; CHECK-LABEL: @test18(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i32 [[FLAG:%.*]], label [[IF_THEN3:%.*]] [
; CHECK-NEXT:    i32 0, label [[IF_THEN:%.*]]
; CHECK-NEXT:    i32 1, label [[IF_THEN2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       if.then:
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[BLKSA:%.*]], [[NBLKS:%.*]]
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.then2:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[NBLKS]], [[BLKSB:%.*]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ule i32 [[ADD]], [[BLKSA]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.then3:
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[NBLKS]], [[BLKSA]]
; CHECK-NEXT:    [[CMP3:%.*]] = icmp ule i32 [[ADD2]], [[BLKSA]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[CMP3_SINK:%.*]] = phi i1 [ [[CMP3]], [[IF_THEN3]] ], [ [[CMP]], [[IF_THEN]] ], [ [[CMP2]], [[IF_THEN2]] ]
; CHECK-NEXT:    [[FROMBOOL4:%.*]] = zext i1 [[CMP3_SINK]] to i8
; CHECK-NEXT:    [[TOBOOL4:%.*]] = icmp ne i8 [[FROMBOOL4]], 0
; CHECK-NEXT:    ret i1 [[TOBOOL4]]
;
entry:
  switch i32 %flag, label %if.then3 [
  i32 0, label %if.then
  i32 1, label %if.then2
  ]

if.then:
  %cmp = icmp uge i32 %blksA, %nblks
  %frombool1 = zext i1 %cmp to i8
  br label %if.end

if.then2:
  %add = add i32 %nblks, %blksB
  %cmp2 = icmp ule i32 %add, %blksA
  %frombool3 = zext i1 %cmp2 to i8
  br label %if.end

if.then3:
  %add2 = add i32 %nblks, %blksA
  %cmp3 = icmp ule i32 %add2, %blksA
  %frombool4 = zext i1 %cmp3 to i8
  br label %if.end

if.end:
  %obeys.0 = phi i8 [ %frombool1, %if.then ], [ %frombool3, %if.then2 ], [ %frombool4, %if.then3 ]
  %tobool4 = icmp ne i8 %obeys.0, 0
  ret i1 %tobool4
}

; The phi is confusing - both add instructions are used by it, but
; not on their respective unconditional arcs. It should not be
; optimized.
define void @test_pr30292(i1 %cond, i1 %cond2, i32 %a, i32 %b) {
; CHECK-LABEL: @test_pr30292(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ADD1:%.*]] = add i32 [[A:%.*]], 1
; CHECK-NEXT:    br label [[SUCC:%.*]]
; CHECK:       two:
; CHECK-NEXT:    call void @g()
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[A]], 1
; CHECK-NEXT:    br label [[SUCC]]
; CHECK:       succ:
; CHECK-NEXT:    [[P:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD1]], [[SUCC]] ], [ [[ADD2]], [[TWO:%.*]] ]
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[TWO]], label [[SUCC]]
;
entry:
  %add1 = add i32 %a, 1
  br label %succ

one:
  br i1 %cond, label %two, label %succ

two:
  call void @g()
  %add2 = add i32 %a, 1
  br label %succ

succ:
  %p = phi i32 [ 0, %entry ], [ %add1, %one ], [ %add2, %two ]
  br label %one
}
declare void @g()

define zeroext i1 @test_pr30244(i1 zeroext %flag, i1 zeroext %flag2, i32 %blksA, i32 %blksB, i32 %nblks) {
; CHECK-LABEL: @test_pr30244(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[P:%.*]] = alloca i8, align 1
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[BLKSA:%.*]], [[NBLKS:%.*]]
; CHECK-NEXT:    br label [[IF_END_GVNSINK_SPLIT:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    br i1 [[FLAG2:%.*]], label [[IF_THEN2:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then2:
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[NBLKS]], [[BLKSB:%.*]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ule i32 [[ADD]], [[BLKSA]]
; CHECK-NEXT:    br label [[IF_END_GVNSINK_SPLIT]]
; CHECK:       if.end.gvnsink.split:
; CHECK-NEXT:    [[CMP_SINK:%.*]] = phi i1 [ [[CMP]], [[IF_THEN]] ], [ [[CMP2]], [[IF_THEN2]] ]
; CHECK-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[CMP_SINK]] to i8
; CHECK-NEXT:    store i8 [[FROMBOOL1]], i8* [[P]], align 1
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i1 true
;
entry:
  %p = alloca i8
  br i1 %flag, label %if.then, label %if.else

if.then:
  %cmp = icmp uge i32 %blksA, %nblks
  %frombool1 = zext i1 %cmp to i8
  store i8 %frombool1, i8* %p
  br label %if.end

if.else:
  br i1 %flag2, label %if.then2, label %if.end

if.then2:
  %add = add i32 %nblks, %blksB
  %cmp2 = icmp ule i32 %add, %blksA
  %frombool3 = zext i1 %cmp2 to i8
  store i8 %frombool3, i8* %p
  br label %if.end

if.end:
  ret i1 true
}

define i32 @test_pr30373a(i1 zeroext %flag, i32 %x, i32 %y) {
; CHECK-LABEL: @test_pr30373a(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[X0:%.*]] = call i32 @foo(i32 [[X:%.*]], i32 0) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[X1:%.*]] = call i32 @foo(i32 [[Y:%.*]], i32 0) #[[ATTR0]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[X_SINK:%.*]] = phi i32 [ [[X]], [[IF_THEN]] ], [ [[Y]], [[IF_ELSE]] ]
; CHECK-NEXT:    [[XX:%.*]] = phi i32 [ [[X0]], [[IF_THEN]] ], [ [[X1]], [[IF_ELSE]] ]
; CHECK-NEXT:    [[Y0:%.*]] = call i32 @foo(i32 [[X_SINK]], i32 1) #[[ATTR0]]
; CHECK-NEXT:    [[Z0:%.*]] = lshr i32 [[Y0]], 8
; CHECK-NEXT:    [[RET:%.*]] = add i32 [[XX]], [[Z0]]
; CHECK-NEXT:    ret i32 [[RET]]
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %x0 = call i32 @foo(i32 %x, i32 0) nounwind readnone
  %y0 = call i32 @foo(i32 %x, i32 1) nounwind readnone
  %z0 = lshr i32 %y0, 8
  br label %if.end

if.else:
  %x1 = call i32 @foo(i32 %y, i32 0) nounwind readnone
  %y1 = call i32 @foo(i32 %y, i32 1) nounwind readnone
  %z1 = lshr exact i32 %y1, 8
  br label %if.end

if.end:
  %xx = phi i32 [ %x0, %if.then ], [ %x1, %if.else ]
  %yy = phi i32 [ %z0, %if.then ], [ %z1, %if.else ]
  %ret = add i32 %xx, %yy
  ret i32 %ret
}

define i32 @test_pr30373b(i1 zeroext %flag, i32 %x, i32 %y) {
; CHECK-LABEL: @test_pr30373b(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[X0:%.*]] = call i32 @foo(i32 [[X:%.*]], i32 0) #[[ATTR0]]
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[X1:%.*]] = call i32 @foo(i32 [[Y:%.*]], i32 0) #[[ATTR0]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[X_SINK:%.*]] = phi i32 [ [[X]], [[IF_THEN]] ], [ [[Y]], [[IF_ELSE]] ]
; CHECK-NEXT:    [[XX:%.*]] = phi i32 [ [[X0]], [[IF_THEN]] ], [ [[X1]], [[IF_ELSE]] ]
; CHECK-NEXT:    [[Y0:%.*]] = call i32 @foo(i32 [[X_SINK]], i32 1) #[[ATTR0]]
; CHECK-NEXT:    [[Z0:%.*]] = lshr i32 [[Y0]], 8
; CHECK-NEXT:    [[RET:%.*]] = add i32 [[XX]], [[Z0]]
; CHECK-NEXT:    ret i32 [[RET]]
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %x0 = call i32 @foo(i32 %x, i32 0) nounwind readnone
  %y0 = call i32 @foo(i32 %x, i32 1) nounwind readnone
  %z0 = lshr exact i32 %y0, 8
  br label %if.end

if.else:
  %x1 = call i32 @foo(i32 %y, i32 0) nounwind readnone
  %y1 = call i32 @foo(i32 %y, i32 1) nounwind readnone
  %z1 = lshr i32 %y1, 8
  br label %if.end

if.end:
  %xx = phi i32 [ %x0, %if.then ], [ %x1, %if.else ]
  %yy = phi i32 [ %z0, %if.then ], [ %z1, %if.else ]
  %ret = add i32 %xx, %yy
  ret i32 %ret
}

define i32 @common_bitcast(i1 zeroext %flag, i32* %x) {
; CHECK-LABEL: @common_bitcast(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[FLAG:%.*]], float 2.000000e+00, float 1.000000e+00
; CHECK-NEXT:    [[A:%.*]] = bitcast i32* [[X:%.*]] to float*
; CHECK-NEXT:    store float [[DOT]], float* [[A]], align 4
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %a = bitcast i32* %x to float*
  store float 2.0, float* %a
  br label %if.end

if.else:
  %b = bitcast i32* %x to float*
  store float 1.0, float* %b
  br label %if.end

if.end:
  ret i32 1
}

define i32 @common_addrspacecast(i1 zeroext %flag, i32* %x) {
; CHECK-LABEL: @common_addrspacecast(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[FLAG:%.*]], i32 9, i32 10
; CHECK-NEXT:    [[A:%.*]] = addrspacecast i32* [[X:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 [[DOT]], i32 addrspace(1)* [[A]], align 4
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %a = addrspacecast i32* %x to i32 addrspace(1)*
  store i32 9, i32 addrspace(1)* %a
  br label %if.end

if.else:
  %b = addrspacecast i32* %x to i32 addrspace(1)*
  store i32 10, i32 addrspace(1)* %b
  br label %if.end

if.end:
  ret i32 1
}

; Don't merge different address spaces
define i32 @no_common_addrspacecast(i1 zeroext %flag, i32* %x) {
; CHECK-LABEL: @no_common_addrspacecast(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[A:%.*]] = addrspacecast i32* [[X:%.*]] to i32 addrspace(1)*
; CHECK-NEXT:    store i32 9, i32 addrspace(1)* [[A]], align 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[B:%.*]] = addrspacecast i32* [[X]] to i32 addrspace(3)*
; CHECK-NEXT:    store i32 10, i32 addrspace(3)* [[B]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %flag, label %if.then, label %if.else

if.then:
  %a = addrspacecast i32* %x to i32 addrspace(1)*
  store i32 9, i32 addrspace(1)* %a
  br label %if.end

if.else:
  %b = addrspacecast i32* %x to i32 addrspace(3)*
  store i32 10, i32 addrspace(3)* %b
  br label %if.end

if.end:
  ret i32 1
}

; CHECK: !0 = !{!1, !1, i64 0}
; CHECK: !1 = !{!"float", !2}
; CHECK: !2 = !{!"an example type tree"}
