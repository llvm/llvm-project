; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=jump-threading -jump-threading-threshold=3 < %s | FileCheck %s

; TODO: In this test case, only the stores in %join should cound towards
; the jump threading threshold, as everything else are free instructions.
define i32 @free_instructions(i1 %c, ptr %p) {
; CHECK-LABEL: @free_instructions(
; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF2:%.*]], label [[ELSE2:%.*]]
; CHECK:       if2:
; CHECK-NEXT:    store i32 -1, ptr [[P:%.*]], align 4
; CHECK-NEXT:    call void @llvm.experimental.noalias.scope.decl(metadata [[META0:![0-9]+]])
; CHECK-NEXT:    store i32 1, ptr [[P]], align 4, !noalias !0
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[P]], i64 32) ]
; CHECK-NEXT:    store i32 2, ptr [[P]], align 4
; CHECK-NEXT:    [[P32:%.*]] = call ptr @llvm.launder.invariant.group.p0(ptr [[P]])
; CHECK-NEXT:    store i32 3, ptr [[P32]], align 4, !invariant.group !3
; CHECK-NEXT:    ret i32 0
; CHECK:       else2:
; CHECK-NEXT:    store i32 -2, ptr [[P]], align 4
; CHECK-NEXT:    call void @llvm.experimental.noalias.scope.decl(metadata [[META4:![0-9]+]])
; CHECK-NEXT:    store i32 1, ptr [[P]], align 4, !noalias !4
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[P]], i64 32) ]
; CHECK-NEXT:    store i32 2, ptr [[P]], align 4
; CHECK-NEXT:    [[P3:%.*]] = call ptr @llvm.launder.invariant.group.p0(ptr [[P]])
; CHECK-NEXT:    store i32 3, ptr [[P3]], align 4, !invariant.group !3
; CHECK-NEXT:    ret i32 1
;
  br i1 %c, label %if, label %else

if:
  store i32 -1, ptr %p
  br label %join

else:
  store i32 -2, ptr %p
  br label %join

join:
  call void @llvm.experimental.noalias.scope.decl(metadata !0)
  store i32 1, ptr %p, !noalias !0
  call void @llvm.assume(i1 true) ["align"(ptr %p, i64 32)]
  store i32 2, ptr %p
  %p3 = call ptr @llvm.launder.invariant.group.p0(ptr %p)
  store i32 3, ptr %p3, !invariant.group !{}
  br i1 %c, label %if2, label %else2

if2:
  ret i32 0

else2:
  ret i32 1
}

declare void @llvm.assume(i1)
declare void @llvm.experimental.noalias.scope.decl(metadata)
declare ptr @llvm.launder.invariant.group.p0(ptr)

!0 = !{!1}
!1 = distinct !{!1, !2, !"scope"}
!2 = distinct !{!2, !"domain"}
