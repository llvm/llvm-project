; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=jump-threading < %s | FileCheck %s

; Jump threading would generate an intermediate BB `foo.thread` uncond to `succ`,
; with preds case0, case1, and case2.
; Theoretically, path case1/case0 -> foo.thread -> succ -> exit can be folded into case1/case0 -> exit.

define i64 @bar(i64 %0, i1 %1, i64 %num) {
; CHECK-LABEL: @bar(
; CHECK-NEXT:    switch i64 [[TMP0:%.*]], label [[EXIT2:%.*]] [
; CHECK-NEXT:      i64 0, label [[CASE0:%.*]]
; CHECK-NEXT:      i64 1, label [[CASE1:%.*]]
; CHECK-NEXT:      i64 2, label [[CASE2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       case0:
; CHECK-NEXT:    br i1 [[TMP1:%.*]], label [[SUCC:%.*]], label [[FOO_THREAD:%.*]]
; CHECK:       case1:
; CHECK-NEXT:    br i1 [[TMP1]], label [[SUCC]], label [[FOO_THREAD]]
; CHECK:       case2:
; CHECK-NEXT:    br i1 [[TMP1]], label [[EXIT2]], label [[EXIT2]]
; CHECK:       succ:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i64 [ [[NUM:%.*]], [[CASE1]] ], [ [[NUM]], [[CASE0]] ]
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq i64 [[PHI2]], 0
; CHECK-NEXT:    br i1 [[COND2]], label [[FOO_THREAD]], label [[EXIT2]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI25:%.*]] = phi i64 [ [[PHI2]], [[SUCC]] ], [ 0, [[CASE1]] ], [ 0, [[CASE0]] ]
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    ret i64 [[PHI25]]
; CHECK:       exit2:
; CHECK-NEXT:    ret i64 0
;
  switch i64 %0, label %foo [
  i64 0, label %case0
  i64 1, label %case1
  i64 2, label %case2
  ]

case0:                                            ; preds = %2
  br i1 %1, label %succ, label %foo

case1:                                            ; preds = %2
  br i1 %1, label %succ, label %foo

case2:
  br i1 %1, label %exit2, label %foo

foo:                                       ; preds = %case1, %case0, %2
  %phi1 = phi i64 [ 0, %case0 ], [ 0, %case1 ], [ 1, %case2 ], [ 10, %2 ]
  %cond1 = icmp ult i64 %phi1, 2
  br i1 %cond1, label %succ, label %exit2

succ:                               ; preds = %foo, %case1, %case0
  %phi2 = phi i64 [ %phi1, %foo ], [ %num, %case1 ], [ %num, %case0 ]
  %cond2 = icmp eq i64 %phi2, 0
  br i1 %cond2, label %exit, label %exit2

exit:
  call void @foo()
  ret i64 %phi2

exit2:
  ret i64 0
}

declare void @foo()
