; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -passes='require<domtree>,require<assumptions>,assume-simplify,verify' --enable-knowledge-retention -S %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

declare void @may_throw()

declare void @llvm.assume(i1 noundef) #0

define i32 @test1(i32* %arg, i32* %arg1, i32 %arg2, i32 %arg3) {
; CHECK-LABEL: define {{[^@]+}}@test1
; CHECK-SAME: (i32* nonnull dereferenceable(4) [[ARG:%.*]], i32* [[ARG1:%.*]], i32 [[ARG2:%.*]], i32 [[ARG3:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[I:%.*]] = icmp ne i32 [[ARG2]], 4
; CHECK-NEXT:    br i1 [[I]], label [[BB4:%.*]], label [[A:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    [[I5:%.*]] = add nsw i32 [[ARG3]], [[ARG2]]
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32* [[ARG]], i64 4), "align"(i32* [[ARG1]], i64 4), "nonnull"(i32* [[ARG1]]) ]
; CHECK-NEXT:    [[I6:%.*]] = load i32, i32* [[ARG]], align 4
; CHECK-NEXT:    [[I7:%.*]] = add nsw i32 [[I5]], [[I6]]
; CHECK-NEXT:    store i32 0, i32* [[ARG]], align 4
; CHECK-NEXT:    [[I8:%.*]] = load i32, i32* [[ARG1]], align 4
; CHECK-NEXT:    [[I9:%.*]] = add nsw i32 [[I7]], [[I8]]
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "dereferenceable"(i32* [[ARG1]], i64 4), "ignore"(i32* undef) ]
; CHECK-NEXT:    store i32 [[I9]], i32* [[ARG1]], align 4
; CHECK-NEXT:    br label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32* [[ARG]], i64 4), "ignore"(i32* undef, i64 4), "ignore"(i32* undef) ]
; CHECK-NEXT:    br label [[B]]
; CHECK:       B:
; CHECK-NEXT:    ret i32 0
;
bb:
  %i = icmp ne i32 %arg2, 4
  call void @llvm.assume(i1 true) [ "dereferenceable"(i32* %arg, i64 4), "nonnull"(i32* %arg) ]
  br i1 %i, label %bb4, label %A

bb4:                                              ; preds = %bb
  %i5 = add nsw i32 %arg3, %arg2
  call void @may_throw()
  %i6 = load i32, i32* %arg, align 4
  %i7 = add nsw i32 %i5, %i6
  store i32 0, i32* %arg, align 4
  call void @llvm.assume(i1 true) [ "align"(i32* %arg, i64 4), "dereferenceable"(i32* %arg, i64 4) ]
  %i8 = load i32, i32* %arg1, align 4
  %i9 = add nsw i32 %i7, %i8
  call void @llvm.assume(i1 true) [ "align"(i32* %arg1, i64 4), "nonnull"(i32* %arg1) ]
  call void @may_throw()
  call void @llvm.assume(i1 true) [ "dereferenceable"(i32* %arg1, i64 4), "nonnull"(i32* %arg1) ]
  store i32 %i9, i32* %arg1, align 4
  br label %B

A:                                                ; preds = %bb
  call void @llvm.assume(i1 true) [ "align"(i32* %arg, i64 4), "dereferenceable"(i32* %arg, i64 4), "nonnull"(i32* %arg) ]
  br label %B

B:                                                ; preds = %A, %bb4
  ret i32 0
}

define i32 @test2(i32** %arg, i32* %arg1, i32 %arg2, i32 %arg3) {
; CHECK-LABEL: define {{[^@]+}}@test2
; CHECK-SAME: (i32** [[ARG:%.*]], i32* nonnull align 4 dereferenceable(4) [[ARG1:%.*]], i32 [[ARG2:%.*]], i32 [[ARG3:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[I:%.*]] = getelementptr inbounds i32, i32* [[ARG1]], i64 0
; CHECK-NEXT:    [[I4:%.*]] = load i32, i32* [[I]], align 4
; CHECK-NEXT:    [[I5:%.*]] = icmp ne i32 [[I4]], 0
; CHECK-NEXT:    [[I6:%.*]] = getelementptr inbounds i32, i32* [[ARG1]], i64 0
; CHECK-NEXT:    br i1 [[I5]], label [[BB7:%.*]], label [[BB17:%.*]]
; CHECK:       bb7:
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32* [[I6]], i64 4), "dereferenceable"(i32* [[I6]], i64 4), "nonnull"(i32* [[I6]]) ]
; CHECK-NEXT:    [[I8:%.*]] = load i32, i32* [[I6]], align 4
; CHECK-NEXT:    [[I9:%.*]] = getelementptr inbounds i32, i32* [[ARG1]], i64 2
; CHECK-NEXT:    store i32 [[I8]], i32* [[I9]], align 4
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    [[I10:%.*]] = getelementptr inbounds i32*, i32** [[ARG]], i64 1
; CHECK-NEXT:    [[I11:%.*]] = load i32*, i32** [[I10]], align 8
; CHECK-NEXT:    [[I12:%.*]] = getelementptr inbounds i32, i32* [[I11]], i64 0
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "dereferenceable"(i32* [[ARG1]], i64 12), "align"(i32* [[I11]], i64 4), "dereferenceable"(i32* [[I11]], i64 4), "nonnull"(i32* [[I11]]) ]
; CHECK-NEXT:    [[I13:%.*]] = load i32, i32* [[I12]], align 4
; CHECK-NEXT:    [[I14:%.*]] = getelementptr inbounds i32*, i32** [[ARG]], i64 1
; CHECK-NEXT:    [[I15:%.*]] = load i32*, i32** [[I14]], align 8
; CHECK-NEXT:    [[I16:%.*]] = getelementptr inbounds i32, i32* [[I15]], i64 2
; CHECK-NEXT:    store i32 [[I13]], i32* [[I16]], align 4
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32** [[ARG]], i64 4), "dereferenceable"(i32** [[ARG]], i64 4), "nonnull"(i32** [[ARG]]) ]
; CHECK-NEXT:    br label [[BB33:%.*]]
; CHECK:       bb17:
; CHECK-NEXT:    [[I18:%.*]] = getelementptr inbounds i32*, i32** [[ARG]], i64 7
; CHECK-NEXT:    [[I19:%.*]] = load i32*, i32** [[I18]], align 8
; CHECK-NEXT:    [[I20:%.*]] = getelementptr inbounds i32, i32* [[I19]], i64 0
; CHECK-NEXT:    [[I21:%.*]] = load i32, i32* [[I20]], align 4
; CHECK-NEXT:    [[I22:%.*]] = icmp ne i32 [[I21]], 0
; CHECK-NEXT:    br i1 [[I22]], label [[BB23:%.*]], label [[BB31:%.*]]
; CHECK:       bb23:
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32** [[ARG]], i64 4), "dereferenceable"(i32** [[ARG]], i64 4), "nonnull"(i32** [[ARG]]) ]
; CHECK-NEXT:    [[I24:%.*]] = getelementptr inbounds i32*, i32** [[ARG]], i64 2
; CHECK-NEXT:    [[I25:%.*]] = load i32*, i32** [[I24]], align 8
; CHECK-NEXT:    [[I26:%.*]] = getelementptr inbounds i32, i32* [[I25]], i64 0
; CHECK-NEXT:    [[I27:%.*]] = load i32, i32* [[I26]], align 4
; CHECK-NEXT:    [[I28:%.*]] = getelementptr inbounds i32*, i32** [[ARG]], i64 2
; CHECK-NEXT:    [[I29:%.*]] = load i32*, i32** [[I28]], align 8
; CHECK-NEXT:    [[I30:%.*]] = getelementptr inbounds i32, i32* [[I29]], i64 2
; CHECK-NEXT:    store i32 [[I27]], i32* [[I30]], align 4
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    br label [[BB31]]
; CHECK:       bb31:
; CHECK-NEXT:    br label [[BB32:%.*]]
; CHECK:       bb32:
; CHECK-NEXT:    br label [[BB33]]
; CHECK:       bb33:
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(i32** [[ARG]], i64 4), "dereferenceable"(i32** [[ARG]], i64 4), "nonnull"(i32** [[ARG]]) ]
; CHECK-NEXT:    ret i32 0
;
bb:
  %i = getelementptr inbounds i32, i32* %arg1, i64 0
  %i4 = load i32, i32* %i, align 4
  %i5 = icmp ne i32 %i4, 0
  call void @llvm.assume(i1 true) [ "align"(i32* %arg1, i64 4), "dereferenceable"(i32* %arg1, i64 4) ]
  call void @llvm.assume(i1 true) [ "align"(i32* %arg1, i64 4), "nonnull"(i32* %arg1) ]
  %i6 = getelementptr inbounds i32, i32* %arg1, i64 0
  br i1 %i5, label %bb7, label %bb17

bb7:                                              ; preds = %bb
  call void @may_throw()
  call void @llvm.assume(i1 true) [ "align"(i32* %i6, i64 4), "dereferenceable"(i32* %i6, i64 4), "nonnull"(i32* %i6) ]
  %i8 = load i32, i32* %i6, align 4
  %i9 = getelementptr inbounds i32, i32* %arg1, i64 2
  store i32 %i8, i32* %i9, align 4
  call void @may_throw()
  call void @may_throw()
  call void @llvm.assume(i1 true) [ "align"(i32* %i9, i64 4), "dereferenceable"(i32* %i9, i64 4), "nonnull"(i32* %i9) ]
  %i10 = getelementptr inbounds i32*, i32** %arg, i64 1
  %i11 = load i32*, i32** %i10, align 8
  %i12 = getelementptr inbounds i32, i32* %i11, i64 0
  %i13 = load i32, i32* %i12, align 4
  call void @llvm.assume(i1 true) [ "align"(i32* %i12, i64 4), "dereferenceable"(i32* %i12, i64 4), "nonnull"(i32* %i12) ]
  %i14 = getelementptr inbounds i32*, i32** %arg, i64 1
  %i15 = load i32*, i32** %i14, align 8
  %i16 = getelementptr inbounds i32, i32* %i15, i64 2
  store i32 %i13, i32* %i16, align 4
  call void @may_throw()
  call void @llvm.assume(i1 true) [ "align"(i32** %arg, i64 4), "dereferenceable"(i32** %arg, i64 4), "nonnull"(i32** %arg) ]
  br label %bb33

bb17:                                             ; preds = %bb
  %i18 = getelementptr inbounds i32*, i32** %arg, i64 7
  %i19 = load i32*, i32** %i18, align 8
  %i20 = getelementptr inbounds i32, i32* %i19, i64 0
  %i21 = load i32, i32* %i20, align 4
  %i22 = icmp ne i32 %i21, 0
  br i1 %i22, label %bb23, label %bb31

bb23:                                             ; preds = %bb17
  call void @may_throw()
  call void @llvm.assume(i1 true) [ "align"(i32** %arg, i64 4), "dereferenceable"(i32** %arg, i64 4), "nonnull"(i32** %arg) ]
  %i24 = getelementptr inbounds i32*, i32** %arg, i64 2
  %i25 = load i32*, i32** %i24, align 8
  %i26 = getelementptr inbounds i32, i32* %i25, i64 0
  %i27 = load i32, i32* %i26, align 4
  %i28 = getelementptr inbounds i32*, i32** %arg, i64 2
  %i29 = load i32*, i32** %i28, align 8
  %i30 = getelementptr inbounds i32, i32* %i29, i64 2
  store i32 %i27, i32* %i30, align 4
  call void @may_throw()
  br label %bb31

bb31:                                             ; preds = %bb23, %bb17
  br label %bb32

bb32:                                             ; preds = %bb31
  br label %bb33

bb33:                                             ; preds = %bb32, %bb7
  call void @llvm.assume(i1 true) [ "align"(i32** %arg, i64 4), "dereferenceable"(i32** %arg, i64 4), "nonnull"(i32** %arg) ]
  ret i32 0
}

define i32 @test3(i32* nonnull %p, i32 %i) {
; CHECK-LABEL: define {{[^@]+}}@test3
; CHECK-SAME: (i32* nonnull [[P:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    ret i32 0
; CHECK:       B:
; CHECK-NEXT:    [[RET:%.*]] = load i32, i32* [[P]], align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
bb:
  %cond = icmp ne i32 %i, 0
  call void @llvm.assume(i1 true) [ "nonnull"(i32* %p) ]
  br i1 %cond, label %A, label %B

A:                                                ; preds = %bb
  ret i32 0

B:                                                ; preds = %bb
  %ret = load i32, i32* %p, align 4
  ret i32 %ret
}

define i32 @test4(i32* %p, i32 %i) {
; CHECK-LABEL: define {{[^@]+}}@test4
; CHECK-SAME: (i32* nonnull dereferenceable(32) [[P:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    ret i32 0
; CHECK:       B:
; CHECK-NEXT:    [[RET:%.*]] = load i32, i32* [[P]], align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
bb:
  %cond = icmp ne i32 %i, 0
  call void @llvm.assume(i1 true) [ "nonnull"(i32* %p), "dereferenceable"(i32* %p, i32 32) ]
  br i1 %cond, label %A, label %B

A:                                                ; preds = %bb
  ret i32 0

B:                                                ; preds = %bb
  %ret = load i32, i32* %p, align 4
  ret i32 %ret
}

define i32 @test4A(i32* %p, i32 %i) {
; CHECK-LABEL: define {{[^@]+}}@test4A
; CHECK-SAME: (i32* [[P:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(i32* [[P]]), "dereferenceable"(i32* [[P]], i32 32) ]
; CHECK-NEXT:    br i1 [[COND]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    ret i32 0
; CHECK:       B:
; CHECK-NEXT:    [[RET:%.*]] = load i32, i32* [[P]], align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
bb:
  call void @may_throw()
  %cond = icmp ne i32 %i, 0
  call void @llvm.assume(i1 true) [ "nonnull"(i32* %p), "dereferenceable"(i32* %p, i32 32) ]
  br i1 %cond, label %A, label %B

A:                                                ; preds = %bb
  ret i32 0

B:                                                ; preds = %bb
  %ret = load i32, i32* %p, align 4
  ret i32 %ret
}

define i32 @test5(i32* dereferenceable(64) %p, i32 %i) {
; CHECK-LABEL: define {{[^@]+}}@test5
; CHECK-SAME: (i32* nonnull dereferenceable(64) [[P:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    ret i32 0
; CHECK:       B:
; CHECK-NEXT:    [[RET:%.*]] = load i32, i32* [[P]], align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
bb:
  %cond = icmp ne i32 %i, 0
  call void @llvm.assume(i1 true) [ "nonnull"(i32* %p), "dereferenceable"(i32* %p, i32 32) ]
  br i1 %cond, label %A, label %B

A:                                                ; preds = %bb
  ret i32 0

B:                                                ; preds = %bb
  %ret = load i32, i32* %p, align 4
  ret i32 %ret
}

define i32 @test5A(i32* dereferenceable(8) %p, i32 %i) {
; CHECK-LABEL: define {{[^@]+}}@test5A
; CHECK-SAME: (i32* dereferenceable(32) [[P:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "cold"(), "ignore"(i32* undef, i32 32) ]
; CHECK-NEXT:    br i1 [[COND]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       A:
; CHECK-NEXT:    ret i32 0
; CHECK:       B:
; CHECK-NEXT:    [[RET:%.*]] = load i32, i32* [[P]], align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
bb:
  %cond = icmp ne i32 %i, 0
  call void @llvm.assume(i1 true) [ "cold"(), "dereferenceable"(i32* %p, i32 32) ]
  br i1 %cond, label %A, label %B

A:                                                ; preds = %bb
  ret i32 0

B:                                                ; preds = %bb
  %ret = load i32, i32* %p, align 4
  ret i32 %ret
}

define i32 @test6() {
; CHECK-LABEL: define {{[^@]+}}@test6() {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "cold"() ]
; CHECK-NEXT:    call void @may_throw()
; CHECK-NEXT:    ret i32 0
;
bb:
  call void @llvm.assume(i1 true) [ "cold"() ]
  call void @llvm.assume(i1 true) [ "cold"() ]
  call void @may_throw()
  call void @llvm.assume(i1 true) [ "cold"() ]
  ret i32 0
}

define i32 @test7(i32* %p) {
; CHECK-LABEL: define {{[^@]+}}@test7
; CHECK-SAME: (i32* align 4 dereferenceable(4) [[P:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[P1:%.*]] = bitcast i32* [[P]] to i8*
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "cold"(), "nonnull"(i32* [[P]]) ]
; CHECK-NEXT:    ret i32 0
;
bb:
  %p1 = bitcast i32* %p to i8*
  call void @llvm.assume(i1 true) [ "cold"() ]
  call void @llvm.assume(i1 true) [ "align"(i32* %p, i32 4) ]
  call void @llvm.assume(i1 true) [ "dereferenceable"(i32* %p, i32 4) ]
  call void @llvm.assume(i1 true) [ "align"(i8* %p1, i32 4), "nonnull"(i8* %p1) ]
  ret i32 0
}

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
