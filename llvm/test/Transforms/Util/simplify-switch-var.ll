; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes="simplify-switch-var,adce,instcombine,simplifycfg<switch-range-to-icmp>" %s 2>&1 < %s | FileCheck %s

;;;; ------------------------- getelementptr -------------------------
;;;; -------------------------- valid cases --------------------------
define i8 @gep_switch_consecutive_case_values(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_switch_consecutive_case_values(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 36
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 4
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP2]], i64 4
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], ptr [[TMP3]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[SPEC_SELECT]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 4
  %gep.1 = getelementptr i8, ptr %ptr, i64 20
  %gep.default = getelementptr i8, ptr %ptr, i64 36
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_switch_nonconsecutive_case_values(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_switch_nonconsecutive_case_values(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[TMP0]], 4
; CHECK-NEXT:    [[TMP2:%.*]] = sext i32 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP2]]
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 4, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 16, label %[[CASE_0]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[TMP3]], %[[CASE_0]] ], [ [[PTR]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 20
  %gep.1 = getelementptr i8, ptr %ptr, i64 68
  %gep.default = getelementptr i8, ptr %ptr, i64 0
  switch i32 %index, label %default [
  i32 4, label %case.0
  i32 16, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @negative_slope(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @negative_slope(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 3
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 160, [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = sext i32 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP2]]
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 4, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 16, label %[[CASE_0]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[TMP3]], %[[CASE_0]] ], [ [[PTR]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 128
  %gep.1 = getelementptr i8, ptr %ptr, i64 32
  %gep.default = getelementptr i8, ptr %ptr, i64 0
  switch i32 %index, label %default [
  i32 4, label %case.0
  i32 16, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_i32_sourceelementtype(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_i32_sourceelementtype(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 256
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 7
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP1]]
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], ptr [[TMP2]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[SPEC_SELECT]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i32, ptr %ptr, i64 0
  %gep.1 = getelementptr i32, ptr %ptr, i64 32
  %gep.default = getelementptr i32, ptr %ptr, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_diff_indices(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_diff_indices(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 64
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[TMP0]], 16
; CHECK-NEXT:    [[TMP2:%.*]] = sext i32 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP2]]
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], ptr [[TMP3]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[SPEC_SELECT]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr { ptr, i64, i32, i32 }, ptr %ptr, i64 0, i32 2 ; gep i8, i64 16
  %gep.1 = getelementptr i32, ptr %ptr, i64 5                           ; gep i8, i64 20
  %gep.default = getelementptr i8, ptr %ptr, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_multiple_cases_same_bb(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_multiple_cases_same_bb(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr i8, ptr [[PTR]], i64 32
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 64
; CHECK-NEXT:    [[DOTSINK:%.*]] = select i1 [[SWITCH]], ptr [[GEP_1]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i8, ptr %ptr, i64 32
  %gep.default = getelementptr i8, ptr %ptr, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.1
  i32 1, label %case.1
  ]

case.1:
  br label %switch.end

default:
  br label %switch.end

switch.end:
  %.sink = phi ptr [ %gep.1, %case.1 ], [ %gep.default, %default ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_with_outliers(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_with_outliers(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 160
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 5
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP1]]
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 0, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE_0]]
; CHECK-NEXT:      i32 2, label %[[CASE_0]]
; CHECK-NEXT:      i32 3, label %[[CASE_3:.*]]
; CHECK-NEXT:      i32 4, label %[[CASE_0]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_3]]:
; CHECK-NEXT:    [[GEP_3:%.*]] = getelementptr i8, ptr [[PTR]], i64 97
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[TMP2]], %[[CASE_0]] ], [ [[GEP_3]], %[[CASE_3]] ], [ [[GEP_DEFAULT]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i8, ptr %ptr, i64 32
  %gep.2 = getelementptr i8, ptr %ptr, i64 64
  %gep.3 = getelementptr i8, ptr %ptr, i64 97 ; outlier
  %gep.4 = getelementptr i8, ptr %ptr, i64 128
  %gep.default = getelementptr i8, ptr %ptr, i64 160
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  i32 2, label %case.2
  i32 3, label %case.3
  i32 4, label %case.4
  ]

case.4:
  br label %default

case.3:
  br label %default

case.2:
  br label %default

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.2, %case.2 ], [ %gep.3, %case.3 ], [ %gep.4, %case.4 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_diff_type(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_diff_type(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 64
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 7
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP1]]
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], ptr [[TMP2]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[SPEC_SELECT]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i32, ptr %ptr, i64 32
  %gep.default = getelementptr i8, ptr %ptr, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_default_case_bb(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_default_case_bb(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 5
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP1]]
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 64
; CHECK-NEXT:    [[DOTSINK:%.*]] = select i1 [[SWITCH]], ptr [[TMP2]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i8, ptr %ptr, i64 32
  %gep.default = getelementptr i8, ptr %ptr, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %switch.end

case.0:
  br label %switch.end

default:
  br label %switch.end

switch.end:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %default ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @non_gep_incoming_value(ptr %ptr0, ptr %ptr1, i32 %index) {
; CHECK-LABEL: define i8 @non_gep_incoming_value(
; CHECK-SAME: ptr [[PTR0:%.*]], ptr [[PTR1:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR0]], i64 64
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 5
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR0]], i64 [[TMP1]]
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 0, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE_0]]
; CHECK-NEXT:      i32 2, label %[[CASE_2:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_2]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[TMP2]], %[[CASE_0]] ], [ [[PTR1]], %[[CASE_2]] ], [ [[GEP_DEFAULT]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr0, i64 0
  %gep.1 = getelementptr i8, ptr %ptr0, i64 32
  %gep.default = getelementptr i8, ptr %ptr0, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  i32 2, label %case.2
  ]

case.2:
  br label %default

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %ptr1, %case.2 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @base_ptr_func_arg(ptr %ptr0, i32 %index) {
; CHECK-LABEL: define i8 @base_ptr_func_arg(
; CHECK-SAME: ptr [[PTR0:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR0]], i64 8
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR0]], i64 [[TMP1]]
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], ptr [[TMP2]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[SPEC_SELECT]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.1 = getelementptr i8, ptr %ptr0, i64 4
  %gep.default = getelementptr i8, ptr %ptr0, i64 8
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %ptr0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i32 @base_ptr_alloca(i32 %index) {
; CHECK-LABEL: define i32 @base_ptr_alloca(
; CHECK-SAME: i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOC1:%.*]] = alloca [4 x i32], align 4
; CHECK-NEXT:    store i32 16, ptr [[ALLOC1]], align 4
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds nuw i8, ptr [[ALLOC1]], i64 4
; CHECK-NEXT:    store i32 8, ptr [[GEP_1]], align 4
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr inbounds nuw i8, ptr [[ALLOC1]], i64 8
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[ALLOC1]], i64 [[TMP1]]
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], ptr [[TMP2]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[SPEC_SELECT]], align 1
; CHECK-NEXT:    ret i32 [[LOAD]]
;
.entry:
  %alloc = alloca i32, i32 4
  store i32 16, ptr %alloc
  %gep.1 = getelementptr i8, ptr %alloc, i64 4
  store i32 8, ptr %gep.1
  %gep.default = getelementptr i8, ptr %alloc, i64 8
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %alloc, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i32, ptr %.sink, align 1
  ret i32 %load
}

;;;; ------------------------- invalid cases -------------------------
define i8 @gep_nonconstant(ptr %ptr, i32 %index, i64 %nonconst) {
; CHECK-LABEL: define i8 @gep_nonconstant(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]], i64 [[NONCONST:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 64
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 0, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE_1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_1]]:
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[NONCONST]]
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[PTR]], %[[CASE_0]] ], [ [[GEP_1]], %[[CASE_1]] ], [ [[GEP_DEFAULT]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i8, ptr %ptr, i64 %nonconst
  %gep.default = getelementptr i8, ptr %ptr, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}



define i8 @gep_diff_base(ptr %ptr.0, ptr %ptr.1, i32 %index) {
; CHECK-LABEL: define i8 @gep_diff_base(
; CHECK-SAME: ptr [[PTR_0:%.*]], ptr [[PTR_1:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR_1]], i64 64
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 0, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE_1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_1]]:
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr i8, ptr [[PTR_1]], i64 32
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[PTR_0]], %[[CASE_0]] ], [ [[GEP_1]], %[[CASE_1]] ], [ [[GEP_DEFAULT]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr.0, i64 0
  %gep.1 = getelementptr i8, ptr %ptr.1, i64 32
  %gep.default = getelementptr i8, ptr %ptr.1, i64 64
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}




define i8 @gep_case_to_merge_bb(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_case_to_merge_bb(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 0, label %[[SWITCH_END:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE_1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_1]]:
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr i8, ptr [[PTR]], i64 32
; CHECK-NEXT:    br label %[[SWITCH_END]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 64
; CHECK-NEXT:    br label %[[SWITCH_END]]
; CHECK:       [[SWITCH_END]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[PTR]], [[DOTENTRY:%.*]] ], [ [[GEP_1]], %[[CASE_1]] ], [ [[GEP_DEFAULT]], %[[DEFAULT]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i8, ptr %ptr, i64 32
  %gep.default = getelementptr i8, ptr %ptr, i64 64
  switch i32 %index, label %default [
  i32 0, label %switch.end
  i32 1, label %case.1
  ]

case.1:
  br label %switch.end

default:
  br label %switch.end

switch.end:
  %.sink = phi ptr [ %gep.0, %.entry ], [ %gep.1, %case.1 ], [ %gep.default, %default ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

define i8 @gep_too_many_outliers(ptr %ptr, i32 %index) {
; CHECK-LABEL: define i8 @gep_too_many_outliers(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 128
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 0, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE_1:.*]]
; CHECK-NEXT:      i32 2, label %[[CASE_2:.*]]
; CHECK-NEXT:      i32 3, label %[[CASE_3:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_3]]:
; CHECK-NEXT:    [[GEP_3:%.*]] = getelementptr i8, ptr [[PTR]], i64 97
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_2]]:
; CHECK-NEXT:    [[GEP_2:%.*]] = getelementptr i8, ptr [[PTR]], i64 67
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_1]]:
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr i8, ptr [[PTR]], i64 31
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi ptr [ [[PTR]], %[[CASE_0]] ], [ [[GEP_1]], %[[CASE_1]] ], [ [[GEP_2]], %[[CASE_2]] ], [ [[GEP_3]], %[[CASE_3]] ], [ [[GEP_DEFAULT]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i8, ptr %ptr, i64 31 ; outlier
  %gep.2 = getelementptr i8, ptr %ptr, i64 67 ; outlier
  %gep.3 = getelementptr i8, ptr %ptr, i64 97 ; outlier
  %gep.default = getelementptr i8, ptr %ptr, i64 128
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  i32 2, label %case.2
  i32 3, label %case.3
  ]

case.3:
  br label %default

case.2:
  br label %default

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.2, %case.2 ], [ %gep.3, %case.3 ], [ %gep.default, %.entry ]
  %load = load i8, ptr %.sink, align 1
  ret i8 %load
}

;;;; ------------------------- test integer add -------------------------
;;;; -------------------------- valid cases -----------------------------
define i32 @add_consecutive_cases(i32 %base, i32 %index) {
; CHECK-LABEL: define i32 @add_consecutive_cases(
; CHECK-SAME: i32 [[BASE:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 2
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[SWITCH]], i32 [[TMP0]], i32 8
; CHECK-NEXT:    [[DOTSINK:%.*]] = add i32 [[BASE]], [[SPEC_SELECT]]
; CHECK-NEXT:    ret i32 [[DOTSINK]]
;
.entry:
  %add.0 = add i32 %base, 0
  %add.1 = add i32 %base, 4
  %add.default = add i32 %base, 8
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi i32 [ %add.0, %case.0 ], [ %add.1, %case.1 ], [ %add.default, %.entry ]
  ret i32 %.sink
}

define i32 @add_nonconsecutive_cases(i32 %base, i32 %index) {
; CHECK-LABEL: define i32 @add_nonconsecutive_cases(
; CHECK-SAME: i32 [[BASE:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[TMP0]], 8
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 4, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 16, label %[[CASE_0]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTPN:%.*]] = phi i32 [ [[TMP1]], %[[CASE_0]] ], [ 260, [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    [[DOTSINK:%.*]] = add i32 [[BASE]], [[DOTPN]]
; CHECK-NEXT:    ret i32 [[DOTSINK]]
;
.entry:
  %add.0 = add i32 %base, 16
  %add.1 = add i32 %base, 40
  %add.default = add i32 %base, 260
  switch i32 %index, label %default [
  i32 4, label %case.0
  i32 16, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi i32 [ %add.0, %case.0 ], [ %add.1, %case.1 ], [ %add.default, %.entry ]
  ret i32 %.sink
}

define i8 @gep_add_two_phis(ptr %ptr, i8 %base, i32 %index) {
; CHECK-LABEL: define i8 @gep_add_two_phis(
; CHECK-SAME: ptr [[PTR:%.*]], i8 [[BASE:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[GEP_DEFAULT:%.*]] = getelementptr i8, ptr [[PTR]], i64 64
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[INDEX]], 5
; CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[PTR]], i64 [[TMP1]]
; CHECK-NEXT:    [[INDEX_TR:%.*]] = trunc i32 [[INDEX]] to i8
; CHECK-NEXT:    [[TMP3:%.*]] = shl i8 [[INDEX_TR]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = trunc i32 [[INDEX]] to i8
; CHECK-NEXT:    [[TMP5:%.*]] = mul i8 [[TMP4]], 6
; CHECK-NEXT:    [[TMP6:%.*]] = add i8 [[TMP5]], 2
; CHECK-NEXT:    [[SWITCH:%.*]] = icmp ult i32 [[INDEX]], 2
; CHECK-NEXT:    [[DOTSINK_GEP:%.*]] = select i1 [[SWITCH]], ptr [[TMP2]], ptr [[GEP_DEFAULT]]
; CHECK-NEXT:    [[DOTPN:%.*]] = select i1 [[SWITCH]], i8 [[TMP3]], i8 8
; CHECK-NEXT:    [[DOTPN1:%.*]] = select i1 [[SWITCH]], i8 [[TMP6]], i8 14
; CHECK-NEXT:    [[SINK_ADD1:%.*]] = add i8 [[BASE]], [[DOTPN1]]
; CHECK-NEXT:    [[SINK_ADD0:%.*]] = add i8 [[BASE]], [[DOTPN]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[DOTSINK_GEP]], align 1
; CHECK-NEXT:    [[ADD_RESULT:%.*]] = add i8 [[SINK_ADD0]], [[SINK_ADD1]]
; CHECK-NEXT:    [[ADD_RESULT2:%.*]] = add i8 [[ADD_RESULT]], [[LOAD]]
; CHECK-NEXT:    ret i8 [[ADD_RESULT2]]
;
.entry:
  %gep.0 = getelementptr i8, ptr %ptr, i64 0
  %gep.1 = getelementptr i8, ptr %ptr, i64 32
  %gep.default = getelementptr i8, ptr %ptr, i64 64
  %add.00 = add i8 %base, 0
  %add.01 = add i8 %base, 4
  %add.default.0 = add i8 %base, 8
  %add.10 = add i8 %base, 2
  %add.11 = add i8 %base, 8
  %add.default.1 = add i8 %base, 14
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink.gep = phi ptr [ %gep.0, %case.0 ], [ %gep.1, %case.1 ], [ %gep.default, %.entry ]
  %sink.add0 = phi i8 [ %add.00, %case.0 ], [ %add.01, %case.1 ], [ %add.default.0, %.entry ]
  %sink.add1 = phi i8 [ %add.10, %case.0 ], [ %add.11, %case.1 ], [ %add.default.1, %.entry ]
  %load = load i8, ptr %.sink.gep, align 1
  %add.result = add i8 %sink.add0, %sink.add1
  %add.result2 = add i8 %add.result, %load
  ret i8 %add.result2
}

;;;; ------------------------- invalid cases ---------------------------
define i32 @add_diff_base(i32 %base.0, i32 %base.1, i32 %index) {
; CHECK-LABEL: define i32 @add_diff_base(
; CHECK-SAME: i32 [[BASE_0:%.*]], i32 [[BASE_1:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[ADD_DEFAULT:%.*]] = add i32 [[BASE_0]], 260
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 4, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 16, label %[[CASE_1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_1]]:
; CHECK-NEXT:    [[ADD_1:%.*]] = add i32 [[BASE_1]], 40
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    [[ADD_0:%.*]] = add i32 [[BASE_0]], 16
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi i32 [ [[ADD_0]], %[[CASE_0]] ], [ [[ADD_1]], %[[CASE_1]] ], [ [[ADD_DEFAULT]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[DOTSINK]]
;
.entry:
  %add.0 = add i32 %base.0, 16
  %add.1 = add i32 %base.1, 40
  %add.default = add i32 %base.0, 260
  switch i32 %index, label %default [
  i32 4, label %case.0
  i32 16, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi i32 [ %add.0, %case.0 ], [ %add.1, %case.1 ], [ %add.default, %.entry ]
  ret i32 %.sink
}

define float @add_floats(float %base, i32 %index) {
; CHECK-LABEL: define float @add_floats(
; CHECK-SAME: float [[BASE:%.*]], i32 [[INDEX:%.*]]) {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[ADD_DEFAULT:%.*]] = fadd float [[BASE]], 8.000000e+00
; CHECK-NEXT:    switch i32 [[INDEX]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 0, label %[[CASE_0:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE_1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE_1]]:
; CHECK-NEXT:    [[ADD_1:%.*]] = fadd float [[BASE]], 4.000000e+00
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE_0]]:
; CHECK-NEXT:    [[ADD_0:%.*]] = fadd float [[BASE]], 0.000000e+00
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi float [ [[ADD_0]], %[[CASE_0]] ], [ [[ADD_1]], %[[CASE_1]] ], [ [[ADD_DEFAULT]], [[DOTENTRY:%.*]] ]
; CHECK-NEXT:    ret float [[DOTSINK]]
;
.entry:
  %add.0 = fadd float %base, 0.0
  %add.1 = fadd float %base, 4.0
  %add.default = fadd float %base, 8.0
  switch i32 %index, label %default [
  i32 0, label %case.0
  i32 1, label %case.1
  ]

case.1:
  br label %default

case.0:
  br label %default

default:
  %.sink = phi float [ %add.0, %case.0 ], [ %add.1, %case.1 ], [ %add.default, %.entry ]
  ret float %.sink
}

