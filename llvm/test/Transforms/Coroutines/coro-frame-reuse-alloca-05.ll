; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; Tests that variables of different type with incompatible alignment in a Corotuine whose
; lifetime range is not overlapping each other re-use the same slot in CorotuineFrame.
; RUN: opt < %s -passes='cgscc(coro-split<reuse-storage>),simplifycfg,early-cse' -S | FileCheck %s


target datalayout = "e-m:e-p:64:64-i64:64-f80:128-n8:16:32:64-S128"

%"struct.task::promise_type" = type { i8 }
%struct.awaitable = type { i8 }
%struct.big_structure = type { [500 x i8] }
%struct.big_structure.2 = type { [400 x i8] }
declare ptr @malloc(i64)
declare void @consume(ptr)
declare void @consume.2(ptr)
define void @a(i1 zeroext %cond) presplitcoroutine {
; CHECK-LABEL: define void @a(
; CHECK-SAME: i1 zeroext [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.coro.id(i32 16, ptr nonnull null, ptr @a, ptr @a.resumers)
; CHECK-NEXT:    [[TMP1:%.*]] = call noalias nonnull ptr @llvm.coro.begin(token [[TMP0]], ptr null)
; CHECK-NEXT:    store ptr @a.resume, ptr [[TMP1]], align 8
; CHECK-NEXT:    [[DESTROY_ADDR:%.*]] = getelementptr inbounds i8, ptr [[TMP1]], i64 8
; CHECK-NEXT:    store ptr @a.destroy, ptr [[DESTROY_ADDR]], align 8
; CHECK-NEXT:    [[A_RELOAD_ADDR:%.*]] = getelementptr inbounds i8, ptr [[TMP1]], i64 32
; CHECK-NEXT:    br i1 [[COND]], label %[[IF_THEN:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    call void @consume(ptr nonnull [[A_RELOAD_ADDR]])
; CHECK-NEXT:    [[INDEX_ADDR4:%.*]] = getelementptr inbounds i8, ptr [[TMP1]], i64 17
; CHECK-NEXT:    store i1 false, ptr [[INDEX_ADDR4]], align 1
; CHECK-NEXT:    br label %[[AFTERCOROEND:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    call void @consume.2(ptr nonnull [[A_RELOAD_ADDR]])
; CHECK-NEXT:    [[INDEX_ADDR5:%.*]] = getelementptr inbounds i8, ptr [[TMP1]], i64 17
; CHECK-NEXT:    store i1 true, ptr [[INDEX_ADDR5]], align 1
; CHECK-NEXT:    br label %[[AFTERCOROEND]]
; CHECK:       [[AFTERCOROEND]]:
; CHECK-NEXT:    ret void
;
entry:
  %__promise = alloca %"struct.task::promise_type", align 1
  %a = alloca %struct.big_structure, align 32
  %ref.tmp7 = alloca %struct.awaitable, align 1
  %b = alloca %struct.big_structure.2, align 16
  %ref.tmp18 = alloca %struct.awaitable, align 1
  %0 = call token @llvm.coro.id(i32 16, ptr nonnull %__promise, ptr @a, ptr null)
  br label %init.ready
init.ready:
  %1 = call noalias nonnull ptr @llvm.coro.begin(token %0, ptr null)
  call void @llvm.lifetime.start.p0(ptr nonnull %__promise)
  br i1 %cond, label %if.then, label %if.else
if.then:
  call void @llvm.lifetime.start.p0(ptr nonnull %a)
  call void @consume(ptr nonnull %a)
  %save = call token @llvm.coro.save(ptr null)
  %suspend = call i8 @llvm.coro.suspend(token %save, i1 false)
  switch i8 %suspend, label %coro.ret [
  i8 0, label %await.ready
  i8 1, label %cleanup1
  ]
await.ready:
  call void @llvm.lifetime.end.p0(ptr nonnull %a)
  br label %cleanup1
if.else:
  call void @llvm.lifetime.start.p0(ptr nonnull %b)
  call void @consume.2(ptr nonnull %b)
  %save2 = call token @llvm.coro.save(ptr null)
  %suspend2 = call i8 @llvm.coro.suspend(token %save2, i1 false)
  switch i8 %suspend2, label %coro.ret [
  i8 0, label %await2.ready
  i8 1, label %cleanup2
  ]
await2.ready:
  call void @llvm.lifetime.end.p0(ptr nonnull %b)
  br label %cleanup2
cleanup1:
  call void @llvm.lifetime.end.p0(ptr nonnull %a)
  br label %cleanup
cleanup2:
  call void @llvm.lifetime.end.p0(ptr nonnull %b)
  br label %cleanup
cleanup:
  call ptr @llvm.coro.free(token %0, ptr %1)
  br label %coro.ret
coro.ret:
  call void @llvm.coro.end(ptr null, i1 false, token none)
  ret void
}

declare token @llvm.coro.id(i32, ptr readnone, ptr nocapture readonly, ptr)
declare i1 @llvm.coro.alloc(token) #3
declare i64 @llvm.coro.size.i64() #5
declare ptr @llvm.coro.begin(token, ptr writeonly) #3
declare token @llvm.coro.save(ptr) #3
declare ptr @llvm.coro.frame() #5
declare i8 @llvm.coro.suspend(token, i1) #3
declare ptr @llvm.coro.free(token, ptr nocapture readonly) #2
declare void @llvm.coro.end(ptr, i1, token) #3
declare void @llvm.lifetime.start.p0(ptr nocapture) #4
declare void @llvm.lifetime.end.p0(ptr nocapture) #4
