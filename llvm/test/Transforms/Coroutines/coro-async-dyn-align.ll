; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s  -O0 -S | FileCheck  %s

target datalayout = "p:64:64:64"

%async.task = type { i64 }
%async.actor = type { i64 }
%async.fp = type <{ i32, i32 }>

%async.ctxt = type { ptr, ptr }

; CHECK: %my_async_function.Frame = type { i64, [48 x i8], i64, i64, [16 x i8], ptr, i64, ptr }

@my_other_async_function_fp = external global <{ i32, i32 }>
declare void @my_other_async_function(ptr %async.ctxt)

@my_async_function_fp = constant <{ i32, i32 }>
  <{ i32 trunc (
  i64 sub (
  i64 ptrtoint (ptr @my_async_function to i64),
  i64 ptrtoint (ptr getelementptr inbounds (<{ i32, i32 }>, ptr @my_async_function_fp, i32 0, i32 1) to i64)
  )
  to i32),
  i32 32
}>

declare void @opaque(ptr)
declare ptr @llvm.coro.async.context.alloc(ptr, ptr)
declare void @llvm.coro.async.context.dealloc(ptr)
declare ptr @llvm.coro.async.resume()
declare token @llvm.coro.id.async(i32, i32, i32, ptr)
declare ptr @llvm.coro.begin(token, ptr)
declare void @llvm.coro.end.async(ptr, i1, ...)
declare void @llvm.coro.end(ptr, i1, token)
declare swiftcc void @asyncReturn(ptr)
declare swiftcc void @asyncSuspend(ptr)
declare {ptr} @llvm.coro.suspend.async(i32, ptr, ptr, ...)

define swiftcc void @my_async_function.my_other_async_function_fp.apply(ptr %fnPtr, ptr %async.ctxt) {
; CHECK-LABEL: define swiftcc void @my_async_function.my_other_async_function_fp.apply(
; CHECK-SAME: ptr [[FNPTR:%.*]], ptr [[ASYNC_CTXT:%.*]]) {
; CHECK-NEXT:    tail call swiftcc void [[FNPTR]](ptr [[ASYNC_CTXT]])
; CHECK-NEXT:    ret void
;
  tail call swiftcc void %fnPtr(ptr %async.ctxt)
  ret void
}

define ptr @__swift_async_resume_project_context(ptr %ctxt) {
; CHECK-LABEL: define ptr @__swift_async_resume_project_context(
; CHECK-SAME: ptr [[CTXT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[RESUME_CTXT:%.*]] = load ptr, ptr [[CTXT]], align 8
; CHECK-NEXT:    ret ptr [[RESUME_CTXT]]
;
entry:
  %resume_ctxt = load ptr, ptr %ctxt, align 8
  ret ptr %resume_ctxt
}



define swiftcc void @my_async_function(ptr swiftasync %async.ctxt) presplitcoroutine {
; CHECK-LABEL: define swiftcc void @my_async_function(
; CHECK-SAME: ptr swiftasync [[ASYNC_CTXT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ASYNC_CTX_FRAMEPTR:%.*]] = getelementptr inbounds i8, ptr [[ASYNC_CTXT]], i32 32
; CHECK-NEXT:    [[STACK:%.*]] = getelementptr inbounds [[MY_ASYNC_FUNCTION_FRAME:%.*]], ptr [[ASYNC_CTX_FRAMEPTR]], i32 0, i32 2
; CHECK-NEXT:    [[STACK2:%.*]] = getelementptr inbounds [[MY_ASYNC_FUNCTION_FRAME]], ptr [[ASYNC_CTX_FRAMEPTR]], i32 0, i32 6
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [[MY_ASYNC_FUNCTION_FRAME]], ptr [[ASYNC_CTX_FRAMEPTR]], i32 0, i32 3
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[TMP0]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = add i64 [[TMP1]], 31
; CHECK-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], -32
; CHECK-NEXT:    [[STACK3:%.*]] = inttoptr i64 [[TMP3]] to ptr
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [[MY_ASYNC_FUNCTION_FRAME]], ptr [[ASYNC_CTX_FRAMEPTR]], i32 0, i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[TMP4]] to i64
; CHECK-NEXT:    [[TMP6:%.*]] = add i64 [[TMP5]], 63
; CHECK-NEXT:    [[TMP7:%.*]] = and i64 [[TMP6]], -64
; CHECK-NEXT:    [[STACK4:%.*]] = inttoptr i64 [[TMP7]] to ptr
; CHECK-NEXT:    [[ASYNC_CTXT_SPILL_ADDR:%.*]] = getelementptr inbounds [[MY_ASYNC_FUNCTION_FRAME]], ptr [[ASYNC_CTX_FRAMEPTR]], i32 0, i32 5
; CHECK-NEXT:    store ptr [[ASYNC_CTXT]], ptr [[ASYNC_CTXT_SPILL_ADDR]], align 8
; CHECK-NEXT:    store i64 0, ptr [[STACK]], align 4
; CHECK-NEXT:    store i64 1, ptr [[STACK2]], align 4
; CHECK-NEXT:    store i64 2, ptr [[STACK3]], align 4
; CHECK-NEXT:    store i64 3, ptr [[STACK4]], align 4
; CHECK-NEXT:    [[CALLEE_CONTEXT:%.*]] = call ptr @llvm.coro.async.context.alloc(ptr null, ptr null)
; CHECK-NEXT:    [[CALLEE_CONTEXT_SPILL_ADDR:%.*]] = getelementptr inbounds [[MY_ASYNC_FUNCTION_FRAME]], ptr [[ASYNC_CTX_FRAMEPTR]], i32 0, i32 7
; CHECK-NEXT:    store ptr [[CALLEE_CONTEXT]], ptr [[CALLEE_CONTEXT_SPILL_ADDR]], align 8
; CHECK-NEXT:    [[CALLEE_CONTEXT_RETURN_TO_CALLER_ADDR:%.*]] = getelementptr inbounds [[ASYNC_CTXT]], ptr [[CALLEE_CONTEXT]], i32 0, i32 1
; CHECK-NEXT:    store ptr @my_async_functionTQ0_, ptr [[CALLEE_CONTEXT_RETURN_TO_CALLER_ADDR]], align 8
; CHECK-NEXT:    tail call swiftcc void @asyncSuspend(ptr [[CALLEE_CONTEXT]])
; CHECK-NEXT:    ret void
;
entry:
  %stack = alloca i64, align 8
  %stack2 = alloca i64, align 16
  %stack3 = alloca i64, align 32
  %stack4 = alloca i64, align 64

  %id = call token @llvm.coro.id.async(i32 32, i32 16, i32 0,
  ptr @my_async_function_fp)
  %hdl = call ptr @llvm.coro.begin(token %id, ptr null)
  store i64 0, ptr %stack
  store i64 1, ptr %stack2
  store i64 2, ptr %stack3
  store i64 3, ptr %stack4

  %callee_context = call ptr @llvm.coro.async.context.alloc(ptr null, ptr null)
  %callee_context.return_to_caller.addr = getelementptr inbounds %async.ctxt, ptr %callee_context, i32 0, i32 1
  %resume.func_ptr = call ptr @llvm.coro.async.resume()
  store ptr %resume.func_ptr, ptr %callee_context.return_to_caller.addr

  %res = call {ptr} (i32, ptr, ptr, ...) @llvm.coro.suspend.async(i32 0,
  ptr %resume.func_ptr,
  ptr @__swift_async_resume_project_context,
  ptr @my_async_function.my_other_async_function_fp.apply,
  ptr @asyncSuspend, ptr %callee_context)
  call void @opaque(ptr %stack)
  call void @opaque(ptr %stack2)
  call void @opaque(ptr %stack3)
  call void @opaque(ptr %stack4)
  call void @llvm.coro.async.context.dealloc(ptr %callee_context)
  tail call swiftcc void @asyncReturn(ptr %async.ctxt)
  call void (ptr, i1, ...) @llvm.coro.end.async(ptr %hdl, i1 0)
  unreachable
}
