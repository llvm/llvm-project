; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -S -debug %s 2>&1 | FileCheck %s
; RUN: opt -p loop-vectorize -force-vector-width=4 -force-vector-interleave=1 -handle-early-exits-in-scalar-tail -S -debug %s 2>&1 | FileCheck %s --check-prefix=EE-SCALAR

; REQUIRES: asserts

declare void @init(ptr)

define i64 @multi_exiting_to_different_exits_live_in_exit_values() {
; CHECK: multi_exiting_to_different_exits_live_in_exit_values
; CHECK-LABEL: VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT: Live-in vp<[[VF:%.+]]> = VF
; CHECK-NEXT: Live-in vp<[[VFxUF:%.+]]> = VF * UF
; CHECK-NEXT: Live-in vp<[[VTC:%.+]]> = vector-trip-count
; CHECK-NEXT: Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<entry>:
; CHECK-NEXT:   IR %src = alloca [128 x i32], align 4
; CHECK-NEXT:   IR call void @init(ptr %src)
; CHECK-NEXT: Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT: vector.ph:
; CHECK-NEXT: Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT: <x1> vector loop: {
; CHECK-NEXT:   vector.body:
; CHECK-NEXT:     EMIT vp<[[CAN_IV:%.+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:     vp<[[STEPS:%.+]]> = SCALAR-STEPS vp<[[CAN_IV]]>, ir<1>, vp<[[VF]]
; CHECK-NEXT:     CLONE ir<%gep.src> = getelementptr inbounds ir<%src>, vp<[[STEPS]]>
; CHECK-NEXT:     vp<[[VEC_PTR:%.+]]> = vector-pointer ir<%gep.src>
; CHECK-NEXT:     WIDEN ir<%l> = load vp<[[VEC_PTR]]>
; CHECK-NEXT:     WIDEN ir<%c.1> = icmp eq ir<%l>, ir<10>
; CHECK-NEXT:     EMIT vp<%index.next> = add nuw vp<[[CAN_IV]]>, vp<[[VFxUF]]>
; CHECK-NEXT:     EMIT vp<[[EA_TAKEN:%.+]]> = any-of ir<%c.1>
; CHECK-NEXT:     EMIT vp<[[LATCH_CMP:%.+]]> = icmp eq vp<%index.next>, vp<[[VTC]]>
; CHECK-NEXT:     EMIT vp<[[EC:%.+]]> = or vp<[[EA_TAKEN]]>, vp<[[LATCH_CMP]]>
; CHECK-NEXT:     EMIT branch-on-cond vp<[[EC]]>
; CHECK-NEXT:   No successors
; CHECK-NEXT: }
; CHECK-NEXT: Successor(s): middle.split
; CHECK-EMPTY:
; CHECK-NEXT: middle.split:
; CHECK-NEXT:   EMIT branch-on-cond vp<[[EA_TAKEN]]>
; CHECK-NEXT: Successor(s): vector.early.exit, middle.block
; CHECK-EMPTY:
; CHECK-NEXT: middle.block:
; CHECK-NEXT:   EMIT vp<[[MIDDLE_CMP:%.+]]> = icmp eq ir<128>, vp<[[VTC]]>
; CHECK-NEXT:   EMIT branch-on-cond vp<[[MIDDLE_CMP]]>
; CHECK-NEXT: Successor(s): ir-bb<e2>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<e2>:
; CHECK-NEXT:  IR %p2 = phi i64 [ 1, %loop.latch ] (extra operand: ir<1> from middle.block)
; CHECK-NEXT: No successors
; CHECK-EMPTY:
; CHECK-NEXT: vector.early.exit:
; CHECK-NEXT: Successor(s): ir-bb<e1>
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<e1>:
; CHECK-NEXT:   IR %p1 = phi i64 [ 0, %loop.header ] (extra operand: ir<0> from vector.early.exit)
; CHECK-NEXT: No successors
; CHECK-EMPTY:
; CHECK-NEXT: scalar.ph:
; CHECK-NEXT:   EMIT-SCALAR vp<[[RESUME:%.+]]> = phi [ vp<[[VTC]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT: ir-bb<loop.header>
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<loop.header>:
; CHECK-NEXT:   IR   %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ] (extra operand: vp<[[RESUME]]> from scalar.ph)
; CHECK:      No successors
; CHECK-NEXT: }

; EE-SCALAR-LABEL: multi_exiting_to_different_exits_live_in_exit_values
; EE-SCALAR: VPlan 'Initial VPlan for VF={4},UF>=1' {
; EE-SCALAR-NEXT: Live-in vp<%0> = VF
; EE-SCALAR-NEXT: Live-in vp<%1> = VF * UF
; EE-SCALAR-NEXT: Live-in vp<%2> = vector-trip-count
; EE-SCALAR-NEXT: Live-in ir<128> = original trip-count
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<entry>:
; EE-SCALAR-NEXT:   IR   %src = alloca [128 x i32], align 4
; EE-SCALAR-NEXT:   IR   call void @init(ptr %src)
; EE-SCALAR-NEXT: Successor(s): scalar.ph, vector.ph
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: vector.ph:
; EE-SCALAR-NEXT:   CLONE ir<%gep.src> = getelementptr inbounds ir<%src>, ir<0>
; EE-SCALAR-NEXT:   vp<%3> = vector-pointer ir<%gep.src>
; EE-SCALAR-NEXT:   WIDEN ir<%l> = load vp<%3>
; EE-SCALAR-NEXT:   WIDEN ir<%c.1> = icmp eq ir<%l>, ir<10>
; EE-SCALAR-NEXT:   EMIT vp<%4> = any-of ir<%c.1>
; EE-SCALAR-NEXT:   EMIT branch-on-cond vp<%4>
; EE-SCALAR-NEXT: Successor(s): scalar.ph, vector.ph.split
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: vector.ph.split:
; EE-SCALAR-NEXT: Successor(s): vector loop
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: <x1> vector loop: {
; EE-SCALAR-NEXT:   vector.body:
; EE-SCALAR-NEXT:     EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; EE-SCALAR-NEXT:     vp<%7> = SCALAR-STEPS vp<%6>, ir<1>, vp<%0>
; EE-SCALAR-NEXT:     EMIT vp<%index.next> = add nuw vp<%6>, vp<%1>
; EE-SCALAR-NEXT:     CLONE ir<%gep.src>.1 = getelementptr inbounds ir<%src>, vp<%index.next>
; EE-SCALAR-NEXT:     vp<%8> = vector-pointer ir<%gep.src>.1
; EE-SCALAR-NEXT:     EMIT vp<%uncountable.exit.mask> = active lane mask vp<%index.next>, vp<%2>, ir<1>
; EE-SCALAR-NEXT:     WIDEN ir<%l>.1 = load vp<%8>, vp<%uncountable.exit.mask>
; EE-SCALAR-NEXT:     WIDEN ir<%c.1>.1 = icmp eq ir<%l>.1, ir<10>
; EE-SCALAR-NEXT:     EMIT vp<%9> = any-of ir<%c.1>.1
; EE-SCALAR-NEXT:     EMIT vp<%10> = icmp eq vp<%index.next>, vp<%2>
; EE-SCALAR-NEXT:     EMIT vp<%11> = or vp<%9>, vp<%10>
; EE-SCALAR-NEXT:     EMIT branch-on-cond vp<%11>
; EE-SCALAR-NEXT:   No successors
; EE-SCALAR-NEXT: }
; EE-SCALAR-NEXT: Successor(s): middle.block
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: middle.block:
; EE-SCALAR-NEXT:   EMIT vp<%cmp.n> = icmp eq ir<128>, vp<%2>
; EE-SCALAR-NEXT:   EMIT vp<%13> = icmp eq vp<%index.next>, ir<128>
; EE-SCALAR-NEXT:   EMIT branch-on-cond vp<%13>
; EE-SCALAR-NEXT: Successor(s): ir-bb<e2>, scalar.ph
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<e2>:
; EE-SCALAR-NEXT:   IR   %p2 = phi i64 [ 1, %loop.latch ] (extra operand: ir<1> from middle.block)
; EE-SCALAR-NEXT: No successors
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: scalar.ph:
; EE-SCALAR-NEXT:   EMIT-SCALAR vp<%bc.resume.val> = phi [ vp<%index.next>, middle.block ], [ ir<0>, ir-bb<entry> ], [ ir<0>, vector.ph ]
; EE-SCALAR-NEXT: Successor(s): ir-bb<loop.header>
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<loop.header>:
; EE-SCALAR-NEXT:   IR   %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ] (extra operand: vp<%bc.resume.val> from scalar.ph)
; EE-SCALAR-NEXT:   IR   %gep.src = getelementptr inbounds i32, ptr %src, i64 %iv
; EE-SCALAR-NEXT:   IR   %l = load i32, ptr %gep.src, align 4
; EE-SCALAR-NEXT:   IR   %c.1 = icmp eq i32 %l, 10
; EE-SCALAR-NEXT: No successors
; EE-SCALAR-NEXT:}

entry:
  %src = alloca [128 x i32]
  call void @init(ptr %src)
  br label %loop.header

loop.header:
  %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ]
  %gep.src = getelementptr inbounds i32, ptr %src, i64 %iv
  %l = load i32, ptr %gep.src
  %c.1 = icmp eq i32 %l, 10
  br i1 %c.1, label %e1, label %loop.latch

loop.latch:
  %inc = add nuw i64 %iv, 1
  %c.2 = icmp eq i64 %inc, 128
  br i1 %c.2, label %e2, label %loop.header

e1:
  %p1 = phi i64 [ 0, %loop.header ]
  ret i64 %p1

e2:
  %p2 = phi i64 [ 1, %loop.latch ]
  ret i64 %p2
}

define i64 @multi_exiting_to_same_exit_live_in_exit_values() {
; CHECK: multi_exiting_to_same_exit_live_in_exit_values
; CHECK-LABEL: VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT: Live-in vp<[[VF:%.+]]> = VF
; CHECK-NEXT: Live-in vp<[[VFxUF:%.+]]> = VF * UF
; CHECK-NEXT: Live-in vp<[[VTC:%.+]]> = vector-trip-count
; CHECK-NEXT: Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<entry>:
; CHECK-NEXT:   IR %src = alloca [128 x i32], align 4
; CHECK-NEXT:   IR call void @init(ptr %src)
; CHECK-NEXT: Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT: vector.ph:
; CHECK-NEXT: Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT: <x1> vector loop: {
; CHECK-NEXT:   vector.body:
; CHECK-NEXT:     EMIT vp<[[CAN_IV:%.+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:     vp<[[STEPS:%.+]]> = SCALAR-STEPS vp<[[CAN_IV]]>, ir<1>, vp<[[VF]]>
; CHECK-NEXT:     CLONE ir<%gep.src> = getelementptr inbounds ir<%src>, vp<[[STEPS]]>
; CHECK-NEXT:     vp<[[VEC_PTR:%.+]]> = vector-pointer ir<%gep.src>
; CHECK-NEXT:     WIDEN ir<%l> = load vp<[[VEC_PTR]]>
; CHECK-NEXT:     WIDEN ir<%c.1> = icmp eq ir<%l>, ir<10>
; CHECK-NEXT:     EMIT vp<%index.next> = add nuw vp<[[CAN_IV]]>, vp<[[VFxUF]]>
; CHECK-NEXT:     EMIT vp<[[EA_TAKEN:%.+]]> = any-of ir<%c.1>
; CHECK-NEXT:     EMIT vp<[[LATCH_CMP:%.+]]> = icmp eq vp<%index.next>, vp<[[VTC]]>
; CHECK-NEXT:     EMIT vp<[[EC:%.+]]> = or vp<[[EA_TAKEN]]>, vp<[[LATCH_CMP]]>
; CHECK-NEXT:     EMIT branch-on-cond vp<[[EC]]>
; CHECK-NEXT:   No successors
; CHECK-NEXT: }
; CHECK-NEXT: Successor(s): middle.split
; CHECK-EMPTY:
; CHECK-NEXT: middle.split:
; CHECK-NEXT:   EMIT branch-on-cond vp<[[EA_TAKEN]]>
; CHECK-NEXT: Successor(s): vector.early.exit, middle.block
; CHECK-EMPTY:
; CHECK-NEXT: middle.block:
; CHECK-NEXT:   EMIT vp<[[MIDDLE_CMP:%.+]]> = icmp eq ir<128>, vp<[[VTC]]>
; CHECK-NEXT:   EMIT branch-on-cond vp<[[MIDDLE_CMP]]>
; CHECK-NEXT: Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT: vector.early.exit:
; CHECK-NEXT: Successor(s): ir-bb<exit>
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<exit>:
; CHECK-NEXT:   IR %p = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ] (extra operands: ir<1> from middle.block, ir<0> from vector.early.exit)
; CHECK-NEXT: No successors
; CHECK-EMPTY:
; CHECK-NEXT: scalar.ph:
; CHECK-NEXT:   EMIT-SCALAR vp<[[RESUME:%.+]]> = phi [ vp<[[VTC]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT: ir-bb<loop.header>
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<loop.header>:
; CHECK-NEXT:   IR   %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ] (extra operand: vp<[[RESUME]]> from scalar.ph)
; CHECK:      No successors
; CHECK-NEXT: }

; EE-SCALAR-LABEL: multi_exiting_to_same_exit_live_in_exit_values
; EE-SCALAR: VPlan 'Initial VPlan for VF={4},UF>=1' {
; EE-SCALAR-NEXT: Live-in vp<%0> = VF
; EE-SCALAR-NEXT: Live-in vp<%1> = VF * UF
; EE-SCALAR-NEXT: Live-in vp<%2> = vector-trip-count
; EE-SCALAR-NEXT: Live-in ir<128> = original trip-count
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<entry>:
; EE-SCALAR-NEXT:   IR   %src = alloca [128 x i32], align 4
; EE-SCALAR-NEXT:   IR   call void @init(ptr %src)
; EE-SCALAR-NEXT: Successor(s): scalar.ph, vector.ph
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: vector.ph:
; EE-SCALAR-NEXT:   CLONE ir<%gep.src> = getelementptr inbounds ir<%src>, ir<0>
; EE-SCALAR-NEXT:   vp<%3> = vector-pointer ir<%gep.src>
; EE-SCALAR-NEXT:   WIDEN ir<%l> = load vp<%3>
; EE-SCALAR-NEXT:   WIDEN ir<%c.1> = icmp eq ir<%l>, ir<10>
; EE-SCALAR-NEXT:   EMIT vp<%4> = any-of ir<%c.1>
; EE-SCALAR-NEXT:   EMIT branch-on-cond vp<%4>
; EE-SCALAR-NEXT: Successor(s): scalar.ph, vector.ph.split
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: vector.ph.split:
; EE-SCALAR-NEXT: Successor(s): vector loop
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: <x1> vector loop: {
; EE-SCALAR-NEXT:   vector.body:
; EE-SCALAR-NEXT:     EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; EE-SCALAR-NEXT:     vp<%7> = SCALAR-STEPS vp<%6>, ir<1>, vp<%0>
; EE-SCALAR-NEXT:     EMIT vp<%index.next> = add nuw vp<%6>, vp<%1>
; EE-SCALAR-NEXT:     CLONE ir<%gep.src>.1 = getelementptr inbounds ir<%src>, vp<%index.next>
; EE-SCALAR-NEXT:     vp<%8> = vector-pointer ir<%gep.src>.1
; EE-SCALAR-NEXT:     EMIT vp<%uncountable.exit.mask> = active lane mask vp<%index.next>, vp<%2>, ir<1>
; EE-SCALAR-NEXT:     WIDEN ir<%l>.1 = load vp<%8>, vp<%uncountable.exit.mask>
; EE-SCALAR-NEXT:     WIDEN ir<%c.1>.1 = icmp eq ir<%l>.1, ir<10>
; EE-SCALAR-NEXT:     EMIT vp<%9> = any-of ir<%c.1>.1
; EE-SCALAR-NEXT:     EMIT vp<%10> = icmp eq vp<%index.next>, vp<%2>
; EE-SCALAR-NEXT:     EMIT vp<%11> = or vp<%9>, vp<%10>
; EE-SCALAR-NEXT:     EMIT branch-on-cond vp<%11>
; EE-SCALAR-NEXT:   No successors
; EE-SCALAR-NEXT: }
; EE-SCALAR-NEXT: Successor(s): middle.block
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: middle.block:
; EE-SCALAR-NEXT:   EMIT vp<%cmp.n> = icmp eq ir<128>, vp<%2>
; EE-SCALAR-NEXT:   EMIT vp<%13> = icmp eq vp<%index.next>, ir<128>
; EE-SCALAR-NEXT:   EMIT branch-on-cond vp<%13>
; EE-SCALAR-NEXT: Successor(s): ir-bb<exit>, scalar.ph
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<exit>:
; EE-SCALAR-NEXT:   IR   %p = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ] (extra operand: ir<1> from middle.block)
; EE-SCALAR-NEXT: No successors
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: scalar.ph:
; EE-SCALAR-NEXT:   EMIT-SCALAR vp<%bc.resume.val> = phi [ vp<%index.next>, middle.block ], [ ir<0>, ir-bb<entry> ], [ ir<0>, vector.ph ]
; EE-SCALAR-NEXT: Successor(s): ir-bb<loop.header>
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<loop.header>:
; EE-SCALAR-NEXT:   IR   %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ] (extra operand: vp<%bc.resume.val> from scalar.ph)
; EE-SCALAR-NEXT:   IR   %gep.src = getelementptr inbounds i32, ptr %src, i64 %iv
; EE-SCALAR-NEXT:   IR   %l = load i32, ptr %gep.src, align 4
; EE-SCALAR-NEXT:   IR   %c.1 = icmp eq i32 %l, 10
; EE-SCALAR-NEXT: No successors
; EE-SCALAR-NEXT: }


entry:
  %src = alloca [128 x i32]
  call void @init(ptr %src)
  br label %loop.header

loop.header:
  %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ]
  %gep.src = getelementptr inbounds i32, ptr %src, i64 %iv
  %l = load i32, ptr %gep.src
  %c.1 = icmp eq i32 %l, 10
  br i1 %c.1, label %exit, label %loop.latch

loop.latch:
  %inc = add nuw i64 %iv, 1
  %c.2 = icmp eq i64 %inc, 128
  br i1 %c.2, label %exit, label %loop.header

exit:
  %p = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ]
  ret i64 %p
}

define i64 @multi_exiting_to_same_exit_live_in_exit_values_2() {
; CHECK: multi_exiting_to_same_exit_live_in_exit_values_2
; CHECK-LABEL: VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT: Live-in vp<[[VF:%.+]]> = VF
; CHECK-NEXT: Live-in vp<[[VFxUF:%.+]]> = VF * UF
; CHECK-NEXT: Live-in vp<[[VTC:%.+]]> = vector-trip-count
; CHECK-NEXT: Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<entry>:
; CHECK-NEXT:   IR %src = alloca [128 x i32], align 4
; CHECK-NEXT:   IR call void @init(ptr %src)
; CHECK-NEXT: Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT: vector.ph:
; CHECK-NEXT: Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT: <x1> vector loop: {
; CHECK-NEXT:   vector.body:
; CHECK-NEXT:     EMIT vp<[[CAN_IV:%.+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:     vp<[[STEPS:%.+]]> = SCALAR-STEPS vp<[[CAN_IV]]>, ir<1>, vp<[[VF]]>
; CHECK-NEXT:     CLONE ir<%gep.src> = getelementptr inbounds ir<%src>, vp<[[STEPS]]>
; CHECK-NEXT:     vp<[[VEC_PTR:%.+]]> = vector-pointer ir<%gep.src>
; CHECK-NEXT:     WIDEN ir<%l> = load vp<[[VEC_PTR]]>
; CHECK-NEXT:     WIDEN ir<%c.1> = icmp eq ir<%l>, ir<10>
; CHECK-NEXT:     EMIT vp<%index.next> = add nuw vp<[[CAN_IV]]>, vp<[[VFxUF]]>
; CHECK-NEXT:     EMIT vp<[[EA_TAKEN:%.+]]> = any-of ir<%c.1>
; CHECK-NEXT:     EMIT vp<[[LATCH_CMP:%.+]]> = icmp eq vp<%index.next>, vp<[[VTC]]>
; CHECK-NEXT:     EMIT vp<[[EC:%.+]]> = or vp<[[EA_TAKEN]]>, vp<[[LATCH_CMP]]>
; CHECK-NEXT:     EMIT branch-on-cond vp<[[EC]]>
; CHECK-NEXT:   No successors
; CHECK-NEXT: }
; CHECK-NEXT: Successor(s): middle.split
; CHECK-EMPTY:
; CHECK-NEXT: middle.split:
; CHECK-NEXT:   EMIT branch-on-cond vp<[[EA_TAKEN]]>
; CHECK-NEXT: Successor(s): vector.early.exit, middle.block
; CHECK-EMPTY:
; CHECK-NEXT: middle.block:
; CHECK-NEXT:   EMIT vp<[[MIDDLE_CMP:%.+]]> = icmp eq ir<128>, vp<[[VTC]]>
; CHECK-NEXT:   EMIT branch-on-cond vp<[[MIDDLE_CMP]]>
; CHECK-NEXT: Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT: vector.early.exit:
; CHECK-NEXT: Successor(s): ir-bb<exit>
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<exit>:
; CHECK-NEXT:   IR %p = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ] (extra operands: ir<1> from middle.block, ir<0> from vector.early.exit)
; CHECK-NEXT: No successors
; CHECK-EMPTY:
; CHECK-NEXT: scalar.ph:
; CHECK-NEXT:   EMIT-SCALAR vp<[[RESUME:%.+]]> = phi [ vp<[[VTC]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT: ir-bb<loop.header>
; CHECK-EMPTY:
; CHECK-NEXT: ir-bb<loop.header>:
; CHECK-NEXT:   IR   %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ] (extra operand: vp<[[RESUME]]> from scalar.ph)
; CHECK:      No successors
; CHECK-NEXT: }

; EE-SCALAR-LABEL: multi_exiting_to_same_exit_live_in_exit_values_2
; EE-SCALAR: VPlan 'Initial VPlan for VF={4},UF>=1' {
; EE-SCALAR-NEXT: Live-in vp<%0> = VF
; EE-SCALAR-NEXT: Live-in vp<%1> = VF * UF
; EE-SCALAR-NEXT: Live-in vp<%2> = vector-trip-count
; EE-SCALAR-NEXT: Live-in ir<128> = original trip-count
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<entry>:
; EE-SCALAR-NEXT:   IR   %src = alloca [128 x i32], align 4
; EE-SCALAR-NEXT:   IR   call void @init(ptr %src)
; EE-SCALAR-NEXT: Successor(s): scalar.ph, vector.ph
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: vector.ph:
; EE-SCALAR-NEXT:   CLONE ir<%gep.src> = getelementptr inbounds ir<%src>, ir<0>
; EE-SCALAR-NEXT:   vp<%3> = vector-pointer ir<%gep.src>
; EE-SCALAR-NEXT:   WIDEN ir<%l> = load vp<%3>
; EE-SCALAR-NEXT:   WIDEN ir<%c.1> = icmp eq ir<%l>, ir<10>
; EE-SCALAR-NEXT:   EMIT vp<%4> = any-of ir<%c.1>
; EE-SCALAR-NEXT:   EMIT branch-on-cond vp<%4>
; EE-SCALAR-NEXT: Successor(s): scalar.ph, vector.ph.split
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: vector.ph.split:
; EE-SCALAR-NEXT: Successor(s): vector loop
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: <x1> vector loop: {
; EE-SCALAR-NEXT:   vector.body:
; EE-SCALAR-NEXT:     EMIT vp<%6> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; EE-SCALAR-NEXT:     vp<%7> = SCALAR-STEPS vp<%6>, ir<1>, vp<%0>
; EE-SCALAR-NEXT:     EMIT vp<%index.next> = add nuw vp<%6>, vp<%1>
; EE-SCALAR-NEXT:     CLONE ir<%gep.src>.1 = getelementptr inbounds ir<%src>, vp<%index.next>
; EE-SCALAR-NEXT:     vp<%8> = vector-pointer ir<%gep.src>.1
; EE-SCALAR-NEXT:     EMIT vp<%uncountable.exit.mask> = active lane mask vp<%index.next>, vp<%2>, ir<1>
; EE-SCALAR-NEXT:     WIDEN ir<%l>.1 = load vp<%8>, vp<%uncountable.exit.mask>
; EE-SCALAR-NEXT:     WIDEN ir<%c.1>.1 = icmp eq ir<%l>.1, ir<10>
; EE-SCALAR-NEXT:     EMIT vp<%9> = any-of ir<%c.1>.1
; EE-SCALAR-NEXT:     EMIT vp<%10> = icmp eq vp<%index.next>, vp<%2>
; EE-SCALAR-NEXT:     EMIT vp<%11> = or vp<%9>, vp<%10>
; EE-SCALAR-NEXT:     EMIT branch-on-cond vp<%11>
; EE-SCALAR-NEXT:   No successors
; EE-SCALAR-NEXT: }
; EE-SCALAR-NEXT: Successor(s): middle.block
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: middle.block:
; EE-SCALAR-NEXT:   EMIT vp<%cmp.n> = icmp eq ir<128>, vp<%2>
; EE-SCALAR-NEXT:   EMIT vp<%13> = icmp eq vp<%index.next>, ir<128>
; EE-SCALAR-NEXT:   EMIT branch-on-cond vp<%13>
; EE-SCALAR-NEXT: Successor(s): ir-bb<exit>, scalar.ph
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<exit>:
; EE-SCALAR-NEXT:   IR   %p = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ] (extra operand: ir<1> from middle.block)
; EE-SCALAR-NEXT: No successors
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: scalar.ph:
; EE-SCALAR-NEXT:   EMIT-SCALAR vp<%bc.resume.val> = phi [ vp<%index.next>, middle.block ], [ ir<0>, ir-bb<entry> ], [ ir<0>, vector.ph ]
; EE-SCALAR-NEXT: Successor(s): ir-bb<loop.header>
; EE-SCALAR-EMPTY:
; EE-SCALAR-NEXT: ir-bb<loop.header>:
; EE-SCALAR-NEXT:   IR   %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ] (extra operand: vp<%bc.resume.val> from scalar.ph)
; EE-SCALAR-NEXT:   IR   %gep.src = getelementptr inbounds i32, ptr %src, i64 %iv
; EE-SCALAR-NEXT:   IR   %l = load i32, ptr %gep.src, align 4
; EE-SCALAR-NEXT:   IR   %c.1 = icmp eq i32 %l, 10
; EE-SCALAR-NEXT: No successors
; EE-SCALAR-NEXT:}

entry:
  %src = alloca [128 x i32]
  call void @init(ptr %src)
  br label %loop.header

loop.header:
  %iv = phi i64 [ %inc, %loop.latch ], [ 0, %entry ]
  %gep.src = getelementptr inbounds i32, ptr %src, i64 %iv
  %l = load i32, ptr %gep.src
  %c.1 = icmp eq i32 %l, 10
  br i1 %c.1, label %exit, label %loop.latch

loop.latch:
  %inc = add nuw i64 %iv, 1
  %c.2 = icmp eq i64 %inc, 128
  br i1 %c.2, label %exit, label %loop.header

exit:
  %p = phi i64 [ 0, %loop.header ], [ 1, %loop.latch ]
  ret i64 %p

; uselistorder directives
  uselistorder label %exit, { 1, 0 }
}
