; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --filter "(_)|(cos|exp[^e]|fmod|gamma|log|pow|sin|sqrt|tan)|(ret)" --version 2
; RUN: opt -vector-library=sleefgnuabi -passes=inject-tli-mappings,loop-vectorize -force-vector-interleave=1 -S < %s | FileCheck %s --check-prefix=NEON
; RUN: opt -mattr=+sve -vector-library=sleefgnuabi -passes=inject-tli-mappings,loop-vectorize -force-vector-interleave=1 -S < %s | FileCheck %s --check-prefix=SVE

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

declare double @acos(double)
declare float @acosf(float)

define void @acos_f64(double* nocapture %varray) {
; NEON-LABEL: define void @acos_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_acos(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @acos(double [[CONV:%.*]]) #[[ATTR0:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @acos_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0:[0-9]+]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_acos(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @acos(double [[CONV:%.*]]) #[[ATTR2:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @acos(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @acos_f32(float* nocapture %varray) {
; NEON-LABEL: define void @acos_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_acosf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @acosf(float [[CONV:%.*]]) #[[ATTR1:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @acos_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_acosf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @acosf(float [[CONV:%.*]]) #[[ATTR3:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @acosf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @asin(double)
declare float @asinf(float)

define void @asin_f64(double* nocapture %varray) {
; NEON-LABEL: define void @asin_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_asin(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @asin(double [[CONV:%.*]]) #[[ATTR2:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @asin_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_asin(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @asin(double [[CONV:%.*]]) #[[ATTR4:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @asin(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @asin_f32(float* nocapture %varray) {
; NEON-LABEL: define void @asin_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_asinf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @asinf(float [[CONV:%.*]]) #[[ATTR3:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @asin_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_asinf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @asinf(float [[CONV:%.*]]) #[[ATTR5:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @asinf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @atan(double)
declare float @atanf(float)

define void @atan_f64(double* nocapture %varray) {
; NEON-LABEL: define void @atan_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_atan(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @atan(double [[CONV:%.*]]) #[[ATTR4:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @atan_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_atan(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @atan(double [[CONV:%.*]]) #[[ATTR6:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @atan(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @atan_f32(float* nocapture %varray) {
; NEON-LABEL: define void @atan_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_atanf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @atanf(float [[CONV:%.*]]) #[[ATTR5:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @atan_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_atanf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @atanf(float [[CONV:%.*]]) #[[ATTR7:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @atanf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @atan2(double, double)
declare float @atan2f(float, float)

define void @atan2_f64(double* nocapture %varray) {
; NEON-LABEL: define void @atan2_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2vv_atan2(<2 x double> [[TMP1:%.*]], <2 x double> [[TMP1]])
; NEON:    [[CALL:%.*]] = tail call double @atan2(double [[CONV:%.*]], double [[CONV]]) #[[ATTR6:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @atan2_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxvv_atan2(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x double> [[TMP11]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @atan2(double [[CONV:%.*]], double [[CONV]]) #[[ATTR8:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @atan2(double %conv, double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @atan2_f32(float* nocapture %varray) {
; NEON-LABEL: define void @atan2_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4vv_atan2f(<4 x float> [[TMP1:%.*]], <4 x float> [[TMP1]])
; NEON:    [[CALL:%.*]] = tail call float @atan2f(float [[CONV:%.*]], float [[CONV]]) #[[ATTR7:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @atan2_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxvv_atan2f(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x float> [[TMP11]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @atan2f(float [[CONV:%.*]], float [[CONV]]) #[[ATTR9:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @atan2f(float %conv, float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @atanh(double)
declare float @atanhf(float)

define void @atanh_f64(double* nocapture %varray) {
; NEON-LABEL: define void @atanh_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_atanh(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @atanh(double [[CONV:%.*]]) #[[ATTR8:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @atanh_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_atanh(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @atanh(double [[CONV:%.*]]) #[[ATTR10:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @atanh(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @atanh_f32(float* nocapture %varray) {
; NEON-LABEL: define void @atanh_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_atanhf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @atanhf(float [[CONV:%.*]]) #[[ATTR9:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @atanh_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_atanhf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @atanhf(float [[CONV:%.*]]) #[[ATTR11:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @atanhf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @cos(double)
declare float @cosf(float)

define void @cos_f64(double* nocapture %varray) {
; NEON-LABEL: define void @cos_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_cos(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @cos(double [[CONV:%.*]]) #[[ATTR10:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @cos_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_cos(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @cos(double [[CONV:%.*]]) #[[ATTR12:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @cos(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @cos_f32(float* nocapture %varray) {
; NEON-LABEL: define void @cos_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_cosf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @cosf(float [[CONV:%.*]]) #[[ATTR11:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @cos_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_cosf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @cosf(float [[CONV:%.*]]) #[[ATTR13:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @cosf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @cosh(double)
declare float @coshf(float)

define void @cosh_f64(double* nocapture %varray) {
; NEON-LABEL: define void @cosh_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_cosh(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @cosh(double [[CONV:%.*]]) #[[ATTR12:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @cosh_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_cosh(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @cosh(double [[CONV:%.*]]) #[[ATTR14:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @cosh(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @cosh_f32(float* nocapture %varray) {
; NEON-LABEL: define void @cosh_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_coshf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @coshf(float [[CONV:%.*]]) #[[ATTR13:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @cosh_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_coshf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @coshf(float [[CONV:%.*]]) #[[ATTR15:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @coshf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @exp(double)
declare float @expf(float)

define void @exp_f64(double* nocapture %varray) {
; NEON-LABEL: define void @exp_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_exp(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @exp(double [[CONV:%.*]]) #[[ATTR14:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @exp_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_exp(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @exp(double [[CONV:%.*]]) #[[ATTR16:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @exp(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @exp_f32(float* nocapture %varray) {
; NEON-LABEL: define void @exp_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_expf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @expf(float [[CONV:%.*]]) #[[ATTR15:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @exp_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_expf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @expf(float [[CONV:%.*]]) #[[ATTR17:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @expf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @exp2(double)
declare float @exp2f(float)

define void @exp2_f64(double* nocapture %varray) {
; NEON-LABEL: define void @exp2_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_exp2(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @exp2(double [[CONV:%.*]]) #[[ATTR16:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @exp2_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_exp2(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @exp2(double [[CONV:%.*]]) #[[ATTR18:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @exp2(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @exp2_f32(float* nocapture %varray) {
; NEON-LABEL: define void @exp2_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_exp2f(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @exp2f(float [[CONV:%.*]]) #[[ATTR17:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @exp2_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_exp2f(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @exp2f(float [[CONV:%.*]]) #[[ATTR19:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @exp2f(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @exp10(double)
declare float @exp10f(float)

define void @exp10_f64(double* nocapture %varray) {
; NEON-LABEL: define void @exp10_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_exp10(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @exp10(double [[CONV:%.*]]) #[[ATTR18:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @exp10_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_exp10(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @exp10(double [[CONV:%.*]]) #[[ATTR20:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @exp10(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @exp10_f32(float* nocapture %varray) {
; NEON-LABEL: define void @exp10_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_exp10f(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @exp10f(float [[CONV:%.*]]) #[[ATTR19:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @exp10_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_exp10f(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @exp10f(float [[CONV:%.*]]) #[[ATTR21:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @exp10f(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

; There are no TLI mappings to fixed vector functions for fmod and fmodf.

declare double @fmod(double, double)
declare float @fmodf(float, float)

define void @fmod_f64(double* nocapture %varray) {
; NEON-LABEL: define void @fmod_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP3:%.*]] = tail call double @fmod(double [[TMP2:%.*]], double [[TMP2]]) #[[ATTR20:[0-9]+]]
; NEON:    [[TMP5:%.*]] = tail call double @fmod(double [[TMP4:%.*]], double [[TMP4]]) #[[ATTR20]]
; NEON:    [[CALL:%.*]] = tail call double @fmod(double [[CONV:%.*]], double [[CONV]]) #[[ATTR20]]
; NEON:    ret void
;
; SVE-LABEL: define void @fmod_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxvv_fmod(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x double> [[TMP11]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @fmod(double [[CONV:%.*]], double [[CONV]]) #[[ATTR22:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @fmod(double %conv, double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @fmod_f32(float* nocapture %varray) {
; NEON-LABEL: define void @fmod_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP3:%.*]] = tail call float @fmodf(float [[TMP2:%.*]], float [[TMP2]]) #[[ATTR21:[0-9]+]]
; NEON:    [[TMP5:%.*]] = tail call float @fmodf(float [[TMP4:%.*]], float [[TMP4]]) #[[ATTR21]]
; NEON:    [[CALL:%.*]] = tail call float @fmodf(float [[CONV:%.*]], float [[CONV]]) #[[ATTR21]]
; NEON:    ret void
;
; SVE-LABEL: define void @fmod_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxvv_fmodf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x float> [[TMP11]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @fmodf(float [[CONV:%.*]], float [[CONV]]) #[[ATTR23:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @fmodf(float %conv, float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @lgamma(double)
declare float @lgammaf(float)

define void @lgamma_f64(double* nocapture %varray) {
; NEON-LABEL: define void @lgamma_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_lgamma(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @lgamma(double [[CONV:%.*]]) #[[ATTR22:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @lgamma_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_lgamma(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @lgamma(double [[CONV:%.*]]) #[[ATTR24:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @lgamma(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @lgamma_f32(float* nocapture %varray) {
; NEON-LABEL: define void @lgamma_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_lgammaf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @lgammaf(float [[CONV:%.*]]) #[[ATTR23:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @lgamma_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_lgammaf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @lgammaf(float [[CONV:%.*]]) #[[ATTR25:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @lgammaf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @log10(double)
declare float @log10f(float)

define void @log10_f64(double* nocapture %varray) {
; NEON-LABEL: define void @log10_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_log10(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @log10(double [[CONV:%.*]]) #[[ATTR24:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @log10_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_log10(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @log10(double [[CONV:%.*]]) #[[ATTR26:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @log10(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @log10_f32(float* nocapture %varray) {
; NEON-LABEL: define void @log10_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_log10f(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @log10f(float [[CONV:%.*]]) #[[ATTR25:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @log10_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_log10f(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @log10f(float [[CONV:%.*]]) #[[ATTR27:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @log10f(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @log2(double)
declare float @log2f(float)

define void @log2_f64(double* nocapture %varray) {
; NEON-LABEL: define void @log2_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_log2(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @log2(double [[CONV:%.*]]) #[[ATTR26:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @log2_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_log2(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @log2(double [[CONV:%.*]]) #[[ATTR28:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @log2(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @log2_f32(float* nocapture %varray) {
; NEON-LABEL: define void @log2_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_log2f(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @log2f(float [[CONV:%.*]]) #[[ATTR27:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @log2_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_log2f(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @log2f(float [[CONV:%.*]]) #[[ATTR29:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @log2f(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @log(double)
declare float @logf(float)

define void @log_f64(double* nocapture %varray) {
; NEON-LABEL: define void @log_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_log(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @log(double [[CONV:%.*]]) #[[ATTR28:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @log_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_log(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @log(double [[CONV:%.*]]) #[[ATTR30:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @log(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @log_f32(float* nocapture %varray) {
; NEON-LABEL: define void @log_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_logf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @logf(float [[CONV:%.*]]) #[[ATTR29:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @log_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_logf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @logf(float [[CONV:%.*]]) #[[ATTR31:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @logf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @pow(double, double)
declare float @powf(float, float)

define void @pow_f64(double* nocapture %varray) {
; NEON-LABEL: define void @pow_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2vv_pow(<2 x double> [[TMP1:%.*]], <2 x double> [[TMP1]])
; NEON:    [[CALL:%.*]] = tail call double @pow(double [[CONV:%.*]], double [[CONV]]) #[[ATTR30:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @pow_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxvv_pow(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x double> [[TMP11]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @pow(double [[CONV:%.*]], double [[CONV]]) #[[ATTR32:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @pow(double %conv, double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @pow_f32(float* nocapture %varray) {
; NEON-LABEL: define void @pow_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4vv_powf(<4 x float> [[TMP1:%.*]], <4 x float> [[TMP1]])
; NEON:    [[CALL:%.*]] = tail call float @powf(float [[CONV:%.*]], float [[CONV]]) #[[ATTR31:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @pow_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxvv_powf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x float> [[TMP11]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @powf(float [[CONV:%.*]], float [[CONV]]) #[[ATTR33:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @powf(float %conv, float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @sin(double)
declare float @sinf(float)

define void @sin_f64(double* nocapture %varray) {
; NEON-LABEL: define void @sin_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_sin(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @sin(double [[CONV:%.*]]) #[[ATTR32:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @sin_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_sin(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @sin(double [[CONV:%.*]]) #[[ATTR34:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @sin(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @sin_f32(float* nocapture %varray) {
; NEON-LABEL: define void @sin_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_sinf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @sinf(float [[CONV:%.*]]) #[[ATTR33:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @sin_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_sinf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @sinf(float [[CONV:%.*]]) #[[ATTR35:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @sinf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @sinh(double)
declare float @sinhf(float)

define void @sinh_f64(double* nocapture %varray) {
; NEON-LABEL: define void @sinh_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_sinh(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @sinh(double [[CONV:%.*]]) #[[ATTR34:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @sinh_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_sinh(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @sinh(double [[CONV:%.*]]) #[[ATTR36:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @sinh(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @sinh_f32(float* nocapture %varray) {
; NEON-LABEL: define void @sinh_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_sinhf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @sinhf(float [[CONV:%.*]]) #[[ATTR35:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @sinh_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_sinhf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @sinhf(float [[CONV:%.*]]) #[[ATTR37:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @sinhf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @sqrt(double)
declare float @sqrtf(float)

define void @sqrt_f64(double* nocapture %varray) {
; NEON-LABEL: define void @sqrt_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_sqrt(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @sqrt(double [[CONV:%.*]]) #[[ATTR36:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @sqrt_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_sqrt(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @sqrt(double [[CONV:%.*]]) #[[ATTR38:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @sqrt(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @sqrt_f32(float* nocapture %varray) {
; NEON-LABEL: define void @sqrt_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_sqrtf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @sqrtf(float [[CONV:%.*]]) #[[ATTR37:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @sqrt_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_sqrtf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @sqrtf(float [[CONV:%.*]]) #[[ATTR39:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @sqrtf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @tan(double)
declare float @tanf(float)

define void @tan_f64(double* nocapture %varray) {
; NEON-LABEL: define void @tan_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_tan(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @tan(double [[CONV:%.*]]) #[[ATTR38:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @tan_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_tan(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @tan(double [[CONV:%.*]]) #[[ATTR40:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @tan(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @tan_f32(float* nocapture %varray) {
; NEON-LABEL: define void @tan_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_tanf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @tanf(float [[CONV:%.*]]) #[[ATTR39:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @tan_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_tanf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @tanf(float [[CONV:%.*]]) #[[ATTR41:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @tanf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @tanh(double)
declare float @tanhf(float)

define void @tanh_f64(double* nocapture %varray) {
; NEON-LABEL: define void @tanh_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_tanh(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @tanh(double [[CONV:%.*]]) #[[ATTR40:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @tanh_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_tanh(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @tanh(double [[CONV:%.*]]) #[[ATTR42:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @tanh(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @tanh_f32(float* nocapture %varray) {
; NEON-LABEL: define void @tanh_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_tanhf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @tanhf(float [[CONV:%.*]]) #[[ATTR41:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @tanh_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_tanhf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @tanhf(float [[CONV:%.*]]) #[[ATTR43:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @tanhf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

declare double @tgamma(double)
declare float @tgammaf(float)

define void @tgamma_f64(double* nocapture %varray) {
; NEON-LABEL: define void @tgamma_f64
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <2 x double> @_ZGVnN2v_tgamma(<2 x double> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call double @tgamma(double [[CONV:%.*]]) #[[ATTR42:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @tgamma_f64
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 2 x double> @_ZGVsMxv_tgamma(<vscale x 2 x double> [[TMP11:%.*]], <vscale x 2 x i1> shufflevector (<vscale x 2 x i1> insertelement (<vscale x 2 x i1> poison, i1 true, i64 0), <vscale x 2 x i1> poison, <vscale x 2 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call double @tgamma(double [[CONV:%.*]]) #[[ATTR44:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to double
  %call = tail call double @tgamma(double %conv)
  %arrayidx = getelementptr inbounds double, double* %varray, i64 %iv
  store double %call, double* %arrayidx, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}

define void @tgamma_f32(float* nocapture %varray) {
; NEON-LABEL: define void @tgamma_f32
; NEON-SAME: (ptr nocapture [[VARRAY:%.*]]) {
; NEON:    [[TMP2:%.*]] = call <4 x float> @_ZGVnN4v_tgammaf(<4 x float> [[TMP1:%.*]])
; NEON:    [[CALL:%.*]] = tail call float @tgammaf(float [[CONV:%.*]]) #[[ATTR43:[0-9]+]]
; NEON:    ret void
;
; SVE-LABEL: define void @tgamma_f32
; SVE-SAME: (ptr nocapture [[VARRAY:%.*]]) #[[ATTR0]] {
; SVE:    [[TMP12:%.*]] = call <vscale x 4 x float> @_ZGVsMxv_tgammaf(<vscale x 4 x float> [[TMP11:%.*]], <vscale x 4 x i1> shufflevector (<vscale x 4 x i1> insertelement (<vscale x 4 x i1> poison, i1 true, i64 0), <vscale x 4 x i1> poison, <vscale x 4 x i32> zeroinitializer))
; SVE:    [[CALL:%.*]] = tail call float @tgammaf(float [[CONV:%.*]]) #[[ATTR45:[0-9]+]]
; SVE:    ret void
;
  entry:
  br label %for.body

  for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %tmp = trunc i64 %iv to i32
  %conv = sitofp i32 %tmp to float
  %call = tail call float @tgammaf(float %conv)
  %arrayidx = getelementptr inbounds float, float* %varray, i64 %iv
  store float %call, float* %arrayidx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1000
  br i1 %exitcond, label %for.end, label %for.body

  for.end:
  ret void
}
