; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -p loop-vectorize -mtriple=aarch64-none-linux-gnu -S %s | FileCheck %s

target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-n32:64-S128-Fn32"

; Test cases for modeling interleave access costs.

; Function Attrs: vscale_range(2,2)
define void @test_masked_interleave(ptr noalias %A, ptr noalias %B, ptr noalias %C) #0 {
; CHECK-LABEL: define void @test_masked_interleave(
; CHECK-SAME: ptr noalias [[A:%.*]], ptr noalias [[B:%.*]], ptr noalias [[C:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP_HEADER:.*]]
; CHECK:       [[LOOP_HEADER]]:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[IV_1:%.*]] = or disjoint i64 [[IV]], 1
; CHECK-NEXT:    [[GEP_A_1:%.*]] = getelementptr i8, ptr [[A]], i64 [[IV_1]]
; CHECK-NEXT:    [[L_1:%.*]] = load i8, ptr [[GEP_A_1]], align 1
; CHECK-NEXT:    [[C_1:%.*]] = icmp eq i8 [[L_1]], 0
; CHECK-NEXT:    br i1 [[C_1]], label %[[THEN:.*]], label %[[LOOP_LATCH]]
; CHECK:       [[THEN]]:
; CHECK-NEXT:    [[IV_2:%.*]] = or disjoint i64 [[IV]], 2
; CHECK-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr i8, ptr [[A]], i64 [[IV_2]]
; CHECK-NEXT:    [[L_2:%.*]] = load i8, ptr [[ARRAYIDX7]], align 1
; CHECK-NEXT:    [[CONV8:%.*]] = zext i8 [[L_2]] to i32
; CHECK-NEXT:    [[SHL:%.*]] = shl i32 [[CONV8]], 2
; CHECK-NEXT:    [[ADD9:%.*]] = or disjoint i64 [[IV]], 1
; CHECK-NEXT:    [[ARRAYIDX10:%.*]] = getelementptr i8, ptr [[A]], i64 [[ADD9]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[ARRAYIDX10]], align 1
; CHECK-NEXT:    [[CONV11:%.*]] = zext i8 [[TMP0]] to i32
; CHECK-NEXT:    [[SHL12:%.*]] = shl i32 [[CONV11]], 2
; CHECK-NEXT:    [[OR:%.*]] = or i32 [[SHL12]], [[SHL]]
; CHECK-NEXT:    [[B2:%.*]] = getelementptr i8, ptr [[A]], i64 [[IV]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[B2]], align 1
; CHECK-NEXT:    [[CONV15:%.*]] = zext i8 [[TMP1]] to i32
; CHECK-NEXT:    [[OR16:%.*]] = or i32 [[OR]], [[CONV15]]
; CHECK-NEXT:    [[SHL17:%.*]] = shl i32 [[OR16]], 2
; CHECK-NEXT:    [[CONV19:%.*]] = trunc i64 [[IV]] to i32
; CHECK-NEXT:    [[ADD20:%.*]] = or i32 3, [[CONV19]]
; CHECK-NEXT:    [[DEST_0:%.*]] = or i32 [[SHL17]], [[ADD20]]
; CHECK-NEXT:    [[SHR:%.*]] = lshr i32 [[DEST_0]], 2
; CHECK-NEXT:    [[SHR26:%.*]] = lshr i32 [[CONV8]], 2
; CHECK-NEXT:    [[CONV27:%.*]] = trunc i32 [[SHR26]] to i8
; CHECK-NEXT:    store i8 [[CONV27]], ptr [[ARRAYIDX7]], align 1
; CHECK-NEXT:    [[SHR30:%.*]] = lshr i32 [[CONV8]], 5
; CHECK-NEXT:    [[CONV31:%.*]] = trunc i32 [[SHR30]] to i8
; CHECK-NEXT:    store i8 [[CONV31]], ptr [[C]], align 1
; CHECK-NEXT:    [[CONV34:%.*]] = trunc i32 [[SHR]] to i8
; CHECK-NEXT:    store i8 [[CONV34]], ptr [[B]], align 1
; CHECK-NEXT:    br label %[[LOOP_LATCH]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[IV_NEXT]] = add i64 [[IV]], 4
; CHECK-NEXT:    [[EC:%.*]] = icmp ugt i64 [[IV]], 1000
; CHECK-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i64 [ %iv.next, %loop.latch ], [ 0, %entry ]
  %iv.1 = or disjoint i64 %iv, 1
  %gep.A.1 = getelementptr i8, ptr %A, i64 %iv.1
  %l.1 = load i8, ptr %gep.A.1, align 1
  %c.1 = icmp eq i8 %l.1, 0
  br i1 %c.1, label %then, label %loop.latch

then:
  %iv.2 = or disjoint i64 %iv, 2
  %arrayidx7 = getelementptr i8, ptr %A, i64 %iv.2
  %l.2 = load i8, ptr %arrayidx7, align 1
  %conv8 = zext i8 %l.2 to i32
  %shl = shl i32 %conv8, 2
  %add9 = or disjoint i64 %iv, 1
  %arrayidx10 = getelementptr i8, ptr %A, i64 %add9
  %2 = load i8, ptr %arrayidx10, align 1
  %conv11 = zext i8 %2 to i32
  %shl12 = shl i32 %conv11, 2
  %or = or i32 %shl12, %shl
  %B2 = getelementptr i8, ptr %A, i64 %iv
  %3 = load i8, ptr %B2, align 1
  %conv15 = zext i8 %3 to i32
  %or16 = or i32 %or, %conv15
  %shl17 = shl i32 %or16, 2
  %conv19 = trunc i64 %iv to i32
  %add20 = or i32 3, %conv19
  %dest.0 = or i32 %shl17, %add20
  %shr = lshr i32 %dest.0, 2
  %shr26 = lshr i32 %conv8, 2
  %conv27 = trunc i32 %shr26 to i8
  store i8 %conv27, ptr %arrayidx7, align 1
  %shr30 = lshr i32 %conv8, 5
  %conv31 = trunc i32 %shr30 to i8
  store i8 %conv31, ptr %C, align 1
  %conv34 = trunc i32 %shr to i8
  store i8 %conv34, ptr %B, align 1
  br label %loop.latch

loop.latch:
  %iv.next = add i64 %iv, 4
  %ec = icmp ugt i64 %iv, 1000
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}

attributes #0 = { vscale_range(2,2) "target-cpu"="neoverse-512tvb" }
