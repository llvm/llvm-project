; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --filter-out-after "^scalar.ph" --version 5
; REQUIRES: asserts

; RUN: opt -passes=loop-vectorize -mtriple=arm64-apple-ios %s -S -debug -disable-output 2>&1 | FileCheck --check-prefix=CM %s
; RUN: opt -passes=loop-vectorize -force-vector-width=2 -force-vector-interleave=1 %s -S | FileCheck --check-prefix=FORCED %s

; Test case from PR41294.

; Check scalar cost for extractvalue. The constant and loop invariant operands are free,
; leaving cost 3 for scalarizing the result + 2 for executing the op with VF 2.

; CM: LV: Found uniform instruction:   %a = extractvalue { i64, i64 } %sv, 0
; CM: LV: Found uniform instruction:   %b = extractvalue { i64, i64 } %sv, 1

; Ensure the extractvalue + add instructions are hoisted out
; CM: vector.ph:
; CM:  CLONE ir<%a> = extractvalue ir<%sv>
; CM:  CLONE ir<%b> = extractvalue ir<%sv>
; CM:  WIDEN ir<%add> = add ir<%a>, ir<%b>
; CM:  Successor(s): vector loop

; CM: LV: Scalar loop costs: 5.

; Check that the extractvalue operands are actually free in vector code.

define void @test1(ptr %dst, {i64, i64} %sv) {
; FORCED-LABEL: define void @test1(
; FORCED-SAME: ptr [[DST:%.*]], { i64, i64 } [[SV:%.*]]) {
; FORCED-NEXT:  [[ENTRY:.*:]]
; FORCED-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; FORCED:       [[VECTOR_PH]]:
; FORCED-NEXT:    [[TMP0:%.*]] = extractvalue { i64, i64 } [[SV]], 0
; FORCED-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i64> poison, i64 [[TMP0]], i64 0
; FORCED-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT]], <2 x i64> poison, <2 x i32> zeroinitializer
; FORCED-NEXT:    [[TMP4:%.*]] = extractvalue { i64, i64 } [[SV]], 1
; FORCED-NEXT:    [[BROADCAST_SPLATINSERT1:%.*]] = insertelement <2 x i64> poison, i64 [[TMP4]], i64 0
; FORCED-NEXT:    [[BROADCAST_SPLAT2:%.*]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT1]], <2 x i64> poison, <2 x i32> zeroinitializer
; FORCED-NEXT:    [[TMP1:%.*]] = add <2 x i64> [[BROADCAST_SPLAT]], [[BROADCAST_SPLAT2]]
; FORCED-NEXT:    br label %[[VECTOR_BODY:.*]]
; FORCED:       [[VECTOR_BODY]]:
; FORCED-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; FORCED-NEXT:    [[TMP2:%.*]] = getelementptr i64, ptr [[DST]], i32 [[INDEX]]
; FORCED-NEXT:    store <2 x i64> [[TMP1]], ptr [[TMP2]], align 4
; FORCED-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 2
; FORCED-NEXT:    [[TMP3:%.*]] = icmp eq i32 [[INDEX_NEXT]], 1000
; FORCED-NEXT:    br i1 [[TMP3]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; FORCED:       [[MIDDLE_BLOCK]]:
; FORCED-NEXT:    br [[EXIT:label %.*]]
; FORCED:       [[SCALAR_PH]]:
;
entry:
  br label %loop.body

loop.body:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.body ]
  %a = extractvalue { i64, i64 } %sv, 0
  %b = extractvalue { i64, i64 } %sv, 1
  %addr = getelementptr i64, ptr %dst, i32 %iv
  %add = add i64 %a, %b
  store i64 %add, ptr %addr
  %iv.next = add nsw i32 %iv, 1
  %cond = icmp ne i32 %iv.next, 1000
  br i1 %cond, label %loop.body, label %exit

exit:
  ret void
}


; Similar to the test case above, but checks getVectorCallCost as well.
declare float @powf(float, float) readnone nounwind

; Ensure the extractvalue instructions are hoisted out
; CM-LABEL: Checking a loop in 'test_getVectorCallCost'
; CM: vector.ph:
; CM:  CLONE ir<%a> = extractvalue ir<%sv>
; CM:  CLONE ir<%b> = extractvalue ir<%sv>
; CM:  Successor(s): vector loop

; CM: LV: Scalar loop costs: 14.

define void @test_getVectorCallCost(ptr %dst, {float, float} %sv) {
; FORCED-LABEL: define void @test_getVectorCallCost(
; FORCED-SAME: ptr [[DST:%.*]], { float, float } [[SV:%.*]]) {
; FORCED-NEXT:  [[ENTRY:.*:]]
; FORCED-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; FORCED:       [[VECTOR_PH]]:
; FORCED-NEXT:    [[TMP0:%.*]] = extractvalue { float, float } [[SV]], 0
; FORCED-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x float> poison, float [[TMP0]], i64 0
; FORCED-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x float> [[BROADCAST_SPLATINSERT]], <2 x float> poison, <2 x i32> zeroinitializer
; FORCED-NEXT:    [[TMP4:%.*]] = extractvalue { float, float } [[SV]], 1
; FORCED-NEXT:    [[BROADCAST_SPLATINSERT1:%.*]] = insertelement <2 x float> poison, float [[TMP4]], i64 0
; FORCED-NEXT:    [[BROADCAST_SPLAT2:%.*]] = shufflevector <2 x float> [[BROADCAST_SPLATINSERT1]], <2 x float> poison, <2 x i32> zeroinitializer
; FORCED-NEXT:    br label %[[VECTOR_BODY:.*]]
; FORCED:       [[VECTOR_BODY]]:
; FORCED-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; FORCED-NEXT:    [[TMP1:%.*]] = getelementptr float, ptr [[DST]], i32 [[INDEX]]
; FORCED-NEXT:    [[TMP2:%.*]] = call <2 x float> @llvm.pow.v2f32(<2 x float> [[BROADCAST_SPLAT]], <2 x float> [[BROADCAST_SPLAT2]])
; FORCED-NEXT:    store <2 x float> [[TMP2]], ptr [[TMP1]], align 4
; FORCED-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 2
; FORCED-NEXT:    [[TMP3:%.*]] = icmp eq i32 [[INDEX_NEXT]], 1000
; FORCED-NEXT:    br i1 [[TMP3]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
; FORCED:       [[MIDDLE_BLOCK]]:
; FORCED-NEXT:    br [[EXIT:label %.*]]
; FORCED:       [[SCALAR_PH]]:
;
entry:
  br label %loop.body

loop.body:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.body ]
  %a = extractvalue { float, float } %sv, 0
  %b = extractvalue { float, float } %sv, 1
  %addr = getelementptr float, ptr %dst, i32 %iv
  %p = call float @powf(float %a, float %b)
  store float %p, ptr %addr
  %iv.next = add nsw i32 %iv, 1
  %cond = icmp ne i32 %iv.next, 1000
  br i1 %cond, label %loop.body, label %exit

exit:
  ret void
}
