; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; REQUIRES: asserts
; RUN: opt -loop-vectorize -force-ordered-reductions=true -force-vector-width=1 -S < %s -debug 2> %t.debug | FileCheck %s
; RUN: cat %t.debug | FileCheck %s --check-prefix=CHECK-DEBUG

target triple = "aarch64-unknown-linux-gnu"

; CHECK-DEBUG: LV: Not interleaving scalar ordered reductions.

define void @foo(float* noalias nocapture %dst, float* noalias nocapture readonly %src, i64 %M, i64 %N) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_BODY_US:%.*]]
; CHECK:       for.body.us:
; CHECK-NEXT:    [[I_023_US:%.*]] = phi i64 [ [[INC8_US:%.*]], [[FOR_COND3:%.*]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX_US:%.*]] = getelementptr inbounds float, float* [[DST:%.*]], i64 [[I_023_US]]
; CHECK-NEXT:    [[MUL_US:%.*]] = mul nsw i64 [[I_023_US]], [[N:%.*]]
; CHECK-NEXT:    br label [[FOR_BODY3_US:%.*]]
; CHECK:       for.body3.us:
; CHECK-NEXT:    [[TMP0:%.*]] = phi float [ 0.000000e+00, [[FOR_BODY_US]] ], [ [[ADD6_US:%.*]], [[FOR_BODY3_US]] ]
; CHECK-NEXT:    [[J_021_US:%.*]] = phi i64 [ 0, [[FOR_BODY_US]] ], [ [[INC_US:%.*]], [[FOR_BODY3_US]] ]
; CHECK-NEXT:    [[ADD_US:%.*]] = add nsw i64 [[J_021_US]], [[MUL_US]]
; CHECK-NEXT:    [[ARRAYIDX4_US:%.*]] = getelementptr inbounds float, float* [[SRC:%.*]], i64 [[ADD_US]]
; CHECK-NEXT:    [[TMP1:%.*]] = load float, float* [[ARRAYIDX4_US]], align 4
; CHECK-NEXT:    [[ADD6_US]] = fadd float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[INC_US]] = add nuw nsw i64 [[J_021_US]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INC_US]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND3]], label [[FOR_BODY3_US]]
; CHECK:       for.cond3:
; CHECK-NEXT:    [[ADD6_US_LCSSA:%.*]] = phi float [ [[ADD6_US]], [[FOR_BODY3_US]] ]
; CHECK-NEXT:    store float [[ADD6_US_LCSSA]], float* [[ARRAYIDX_US]], align 4
; CHECK-NEXT:    [[INC8_US]] = add nuw nsw i64 [[I_023_US]], 1
; CHECK-NEXT:    [[EXITCOND26_NOT:%.*]] = icmp eq i64 [[INC8_US]], [[M:%.*]]
; CHECK-NEXT:    br i1 [[EXITCOND26_NOT]], label [[EXIT:%.*]], label [[FOR_BODY_US]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;

entry:
  br label %for.body.us

for.body.us:                                      ; preds = %entry, %for.cond3
  %i.023.us = phi i64 [ %inc8.us, %for.cond3 ], [ 0, %entry ]
  %arrayidx.us = getelementptr inbounds float, float* %dst, i64 %i.023.us
  %mul.us = mul nsw i64 %i.023.us, %N
  br label %for.body3.us

for.body3.us:                                     ; preds = %for.body.us, %for.body3.us
  %0 = phi float [ 0.000000e+00, %for.body.us ], [ %add6.us, %for.body3.us ]
  %j.021.us = phi i64 [ 0, %for.body.us ], [ %inc.us, %for.body3.us ]
  %add.us = add nsw i64 %j.021.us, %mul.us
  %arrayidx4.us = getelementptr inbounds float, float* %src, i64 %add.us
  %1 = load float, float* %arrayidx4.us, align 4
  %add6.us = fadd float %1, %0
  %inc.us = add nuw nsw i64 %j.021.us, 1
  %exitcond.not = icmp eq i64 %inc.us, %N
  br i1 %exitcond.not, label %for.cond3, label %for.body3.us

for.cond3:                                        ; preds = %for.body3.us
  %add6.us.lcssa = phi float [ %add6.us, %for.body3.us ]
  store float %add6.us.lcssa, float* %arrayidx.us, align 4
  %inc8.us = add nuw nsw i64 %i.023.us, 1
  %exitcond26.not = icmp eq i64 %inc8.us, %M
  br i1 %exitcond26.not, label %exit, label %for.body.us

exit:                                             ; preds = %for.cond3
  ret void
}
