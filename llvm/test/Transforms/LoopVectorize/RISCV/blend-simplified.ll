; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --version 5
; RUN: opt < %s -S -p loop-vectorize | FileCheck %s

; VPlanTransforms::simplifyRecipes will simplify some of selects stemming from
; the blend recipe, which will cause a difference between the legacy and VPlan
; based cost models. Make sure we account for this simplifcation. This is
; extracted from sqlite3 in llvm-test-suite.

target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

define i64 @html_encode() #0 {
; CHECK-LABEL: define i64 @html_encode(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr null, align 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i8> poison, i8 [[TMP0]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i8> [[BROADCAST_SPLATINSERT]], <2 x i8> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i8> [[BROADCAST_SPLAT]], splat (i8 38)
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> zeroinitializer, <2 x i64> splat (i64 1)
; CHECK-NEXT:    [[TMP2:%.*]] = or <2 x i64> zeroinitializer, [[PREDPHI]]
; CHECK-NEXT:    br label %[[MIDDLE_BLOCK:.*]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[TMP3:%.*]] = extractelement <2 x i64> [[TMP2]], i32 1
; CHECK-NEXT:    br i1 true, label %[[FOR_END_LOOPEXIT:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ 2, %[[MIDDLE_BLOCK]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[SW_BB6:.*]]:
; CHECK-NEXT:    br label %[[FOR_INC:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[J_031:%.*]] = phi i64 [ [[INC12:%.*]], %[[FOR_INC]] ], [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr null, align 1
; CHECK-NEXT:    switch i8 [[TMP4]], label %[[FOR_INC]] [
; CHECK-NEXT:      i8 62, label %[[FOR_INC]]
; CHECK-NEXT:      i8 1, label %[[FOR_INC]]
; CHECK-NEXT:      i8 38, label %[[SW_BB6]]
; CHECK-NEXT:      i8 0, label %[[FOR_INC]]
; CHECK-NEXT:    ]
; CHECK:       [[FOR_INC]]:
; CHECK-NEXT:    [[DOTSINK:%.*]] = phi i64 [ 0, %[[SW_BB6]] ], [ 1, %[[FOR_BODY]] ], [ 1, %[[FOR_BODY]] ], [ 1, %[[FOR_BODY]] ], [ 1, %[[FOR_BODY]] ]
; CHECK-NEXT:    [[INC:%.*]] = or i64 0, [[DOTSINK]]
; CHECK-NEXT:    [[INC12]] = add i64 [[J_031]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[J_031]], 1
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_END_LOOPEXIT]], label %[[FOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[FOR_END_LOOPEXIT]]:
; CHECK-NEXT:    [[INC_LCSSA:%.*]] = phi i64 [ [[INC]], %[[FOR_INC]] ], [ [[TMP3]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    ret i64 [[INC_LCSSA]]
;
entry:
  br label %for.body

sw.bb6:                                           ; preds = %for.body
  br label %for.inc

for.body:                                         ; preds = %for.inc, %entry
  %j.031 = phi i64 [ %inc12, %for.inc ], [ 0, %entry ]
  %0 = load i8, ptr null, align 1
  switch i8 %0, label %for.inc [
  i8 62, label %for.inc
  i8 1, label %for.inc
  i8 38, label %sw.bb6
  i8 0, label %for.inc
  ]

for.inc:                                          ; preds = %for.body, %for.body, %for.body, %for.body, %sw.bb6
  %.sink = phi i64 [ 0, %sw.bb6 ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ], [ 1, %for.body ]
  %inc = or i64 0, %.sink
  %inc12 = add i64 %j.031, 1
  %exitcond.not = icmp eq i64 %j.031, 1
  br i1 %exitcond.not, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %for.inc
  ret i64 %inc
}

attributes #0 = { "target-features"="+v" }
