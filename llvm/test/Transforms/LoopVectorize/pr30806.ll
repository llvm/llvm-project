; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -loop-vectorize -S < %s 2>&1 | FileCheck %s

; Produced from test-case:
;
; void testGuardedInnerLoop(uint32_t *ptr, uint32_t denom, uint32_t numer, uint32_t outer_lim)
; {
;   for(uint32_t outer_i = 0; outer_i < outer_lim; ++outer_i) {
;     if (denom > 0) {
;       const uint32_t lim = numer / denom;
;
;       for (uint32_t i = 0; i < lim; ++i)
;         ptr[i] = 1;
;     }
;   }
; }


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1"
target triple = "x86_64-unknown-linux-gnu"

define void @testGuardedInnerLoop(i32* %ptr, i32 %denom, i32 %numer, i32 %outer_lim) {
; CHECK-LABEL: @testGuardedInnerLoop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[OUTER_LIM:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP1]], label [[EXIT:%.*]], label [[LOOP1_PREHEADER:%.*]]
; CHECK:       loop1.preheader:
; CHECK-NEXT:    br label [[LOOP1:%.*]]
; CHECK:       loop1:
; CHECK-NEXT:    [[OUTER_I:%.*]] = phi i32 [ [[INC1:%.*]], [[LOOP2_EXIT:%.*]] ], [ 0, [[LOOP1_PREHEADER]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[DENOM:%.*]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[TMP0]], [[NUMER:%.*]]
; CHECK-NEXT:    br i1 [[TMP1]], label [[LOOP2_PREHEADER:%.*]], label [[LOOP2_EXIT]]
; CHECK:       loop2.preheader:
; CHECK-NEXT:    [[LIM:%.*]] = udiv i32 [[NUMER]], [[DENOM]]
; CHECK-NEXT:    [[TMP2:%.*]] = zext i32 [[LIM]] to i64
; CHECK-NEXT:    [[UMAX:%.*]] = call i64 @llvm.umax.i64(i64 [[TMP2]], i64 1)
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[UMAX]], 8
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[UMAX]], 8
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[UMAX]], [[N_MOD_VF]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = add i64 [[INDEX]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = add i64 [[INDEX]], 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i32, i32* [[PTR:%.*]], i64 [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP4]]
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, i32* [[TMP5]], i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i32* [[TMP7]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> <i32 1, i32 1, i32 1, i32 1>, <4 x i32>* [[TMP8]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, i32* [[TMP5]], i32 4
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast i32* [[TMP9]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> <i32 1, i32 1, i32 1, i32 1>, <4 x i32>* [[TMP10]], align 4
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 8
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[UMAX]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], label [[LOOP2_EXIT_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[LOOP2_PREHEADER]] ]
; CHECK-NEXT:    br label [[LOOP2:%.*]]
; CHECK:       loop2:
; CHECK-NEXT:    [[INDVAR_LOOP2:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVAR_LOOP2_NEXT:%.*]], [[LOOP2]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[INDVAR_LOOP2]]
; CHECK-NEXT:    store i32 1, i32* [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INDVAR_LOOP2_NEXT]] = add nuw nsw i64 [[INDVAR_LOOP2]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i64 [[INDVAR_LOOP2_NEXT]], [[TMP2]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[LOOP2]], label [[LOOP2_EXIT_LOOPEXIT]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       loop2.exit.loopexit:
; CHECK-NEXT:    br label [[LOOP2_EXIT]]
; CHECK:       loop2.exit:
; CHECK-NEXT:    [[INC1]] = add nuw i32 [[OUTER_I]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC1]], [[OUTER_LIM]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[EXIT_LOOPEXIT:%.*]], label [[LOOP1]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %cmp1 = icmp eq i32 %outer_lim, 0
  br i1 %cmp1, label %exit, label %loop1.preheader

; Verify that a 'udiv' does not appear between the 'loop1.preheader' label, and
; whatever label comes next.
loop1.preheader:
  br label %loop1

loop1:
  %outer_i = phi i32 [ %inc1, %loop2.exit ], [ 0, %loop1.preheader ]
  %0 = add i32 %denom, -1
  %1 = icmp ult i32 %0, %numer
  br i1 %1, label %loop2.preheader, label %loop2.exit

; Verify that a 'udiv' does appear between the 'loop2.preheader' label, and
; whatever label comes next.
loop2.preheader:
  %lim = udiv i32 %numer, %denom
  %2 = zext i32 %lim to i64
  br label %loop2

loop2:
  %indvar.loop2 = phi i64 [ 0, %loop2.preheader ], [ %indvar.loop2.next, %loop2 ]
  %arrayidx = getelementptr inbounds i32, i32* %ptr, i64 %indvar.loop2
  store i32 1, i32* %arrayidx, align 4
  %indvar.loop2.next = add nuw nsw i64 %indvar.loop2, 1
  %cmp2 = icmp ult i64 %indvar.loop2.next, %2
  br i1 %cmp2, label %loop2, label %loop2.exit

loop2.exit:
  %inc1 = add nuw i32 %outer_i, 1
  %exitcond = icmp eq i32 %inc1, %outer_lim
  br i1 %exitcond, label %exit, label %loop1

exit:
  ret void
}
