; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=4 -S < %s | FileCheck %s --check-prefix=CHECK-OUTLOOP
; RUN: opt -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=4 -prefer-inloop-reductions -S < %s | FileCheck %s --check-prefix=CHECK-INLOOP

; Check that a VPBlendRecipe in the chain is handled correctly, i.e. there's
; another phi in between the recurrence phi and the select.

define i32 @select_icmp_switch(i32 %n, i32 %case, ptr %a, ptr %b, i32 %anyof) {
; CHECK-OUTLOOP-LABEL: define i32 @select_icmp_switch(
; CHECK-OUTLOOP-SAME: i32 [[N:%.*]], i32 [[CASE:%.*]], ptr [[A:%.*]], ptr [[B:%.*]], i32 [[ANYOF:%.*]]) {
; CHECK-OUTLOOP-NEXT:  [[ENTRY:.*]]:
; CHECK-OUTLOOP-NEXT:    [[CMP_SGT:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-OUTLOOP-NEXT:    br i1 [[CMP_SGT]], label %[[FOR_BODY_PREHEADER:.*]], label %[[FOR_END:.*]]
; CHECK-OUTLOOP:       [[FOR_BODY_PREHEADER]]:
; CHECK-OUTLOOP-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; CHECK-OUTLOOP-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], 4
; CHECK-OUTLOOP-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK-OUTLOOP:       [[VECTOR_PH]]:
; CHECK-OUTLOOP-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], 4
; CHECK-OUTLOOP-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; CHECK-OUTLOOP-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i32> poison, i32 [[CASE]], i64 0
; CHECK-OUTLOOP-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i32> [[BROADCAST_SPLATINSERT]], <4 x i32> poison, <4 x i32> zeroinitializer
; CHECK-OUTLOOP-NEXT:    [[TMP0:%.*]] = icmp eq <4 x i32> [[BROADCAST_SPLAT]], splat (i32 1)
; CHECK-OUTLOOP-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK-OUTLOOP:       [[VECTOR_BODY]]:
; CHECK-OUTLOOP-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-OUTLOOP-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i1> [ zeroinitializer, %[[VECTOR_PH]] ], [ [[PREDPHI:%.*]], %[[VECTOR_BODY]] ]
; CHECK-OUTLOOP-NEXT:    [[TMP1:%.*]] = add i64 [[INDEX]], 0
; CHECK-OUTLOOP-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[TMP1]]
; CHECK-OUTLOOP-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr [[TMP2]], i32 0
; CHECK-OUTLOOP-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i8>, ptr [[TMP3]], align 1
; CHECK-OUTLOOP-NEXT:    [[TMP4:%.*]] = icmp eq <4 x i8> [[WIDE_LOAD]], splat (i8 -1)
; CHECK-OUTLOOP-NEXT:    [[TMP5:%.*]] = xor <4 x i1> [[TMP4]], splat (i1 true)
; CHECK-OUTLOOP-NEXT:    [[TMP6:%.*]] = or <4 x i1> [[VEC_PHI]], [[TMP5]]
; CHECK-OUTLOOP-NEXT:    [[PREDPHI]] = select <4 x i1> [[TMP0]], <4 x i1> [[VEC_PHI]], <4 x i1> [[TMP6]]
; CHECK-OUTLOOP-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4
; CHECK-OUTLOOP-NEXT:    [[TMP7:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-OUTLOOP-NEXT:    br i1 [[TMP7]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK-OUTLOOP:       [[MIDDLE_BLOCK]]:
; CHECK-OUTLOOP-NEXT:    [[TMP8:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[PREDPHI]])
; CHECK-OUTLOOP-NEXT:    [[TMP9:%.*]] = freeze i1 [[TMP8]]
; CHECK-OUTLOOP-NEXT:    [[RDX_SELECT:%.*]] = select i1 [[TMP9]], i32 [[ANYOF]], i32 0
; CHECK-OUTLOOP-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; CHECK-OUTLOOP-NEXT:    br i1 [[CMP_N]], label %[[FOR_END_LOOPEXIT:.*]], label %[[SCALAR_PH]]
; CHECK-OUTLOOP:       [[SCALAR_PH]]:
; CHECK-OUTLOOP-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY_PREHEADER]] ]
; CHECK-OUTLOOP-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[RDX_SELECT]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY_PREHEADER]] ]
; CHECK-OUTLOOP-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-OUTLOOP:       [[FOR_BODY]]:
; CHECK-OUTLOOP-NEXT:    [[INDVARS:%.*]] = phi i64 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[INDVARS_NEXT:%.*]], %[[FOR_INC:.*]] ]
; CHECK-OUTLOOP-NEXT:    [[RDX_PHI:%.*]] = phi i32 [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ], [ [[RDX_PHI_NEXT:%.*]], %[[FOR_INC]] ]
; CHECK-OUTLOOP-NEXT:    [[A_ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[INDVARS]]
; CHECK-OUTLOOP-NEXT:    [[A_VALUE:%.*]] = load i8, ptr [[A_ARRAYIDX]], align 1
; CHECK-OUTLOOP-NEXT:    [[CMP_A:%.*]] = icmp eq i8 [[A_VALUE]], -1
; CHECK-OUTLOOP-NEXT:    switch i32 [[CASE]], label %[[SW_BB0:.*]] [
; CHECK-OUTLOOP-NEXT:      i32 0, label %[[SW_BB0]]
; CHECK-OUTLOOP-NEXT:      i32 1, label %[[SW_BB1:.*]]
; CHECK-OUTLOOP-NEXT:    ]
; CHECK-OUTLOOP:       [[SW_BB0]]:
; CHECK-OUTLOOP-NEXT:    [[SELECT_BB0:%.*]] = select i1 [[CMP_A]], i32 [[RDX_PHI]], i32 [[ANYOF]]
; CHECK-OUTLOOP-NEXT:    br label %[[FOR_INC]]
; CHECK-OUTLOOP:       [[SW_BB1]]:
; CHECK-OUTLOOP-NEXT:    br label %[[FOR_INC]]
; CHECK-OUTLOOP:       [[FOR_INC]]:
; CHECK-OUTLOOP-NEXT:    [[RDX_PHI_NEXT]] = phi i32 [ [[SELECT_BB0]], %[[SW_BB0]] ], [ [[RDX_PHI]], %[[SW_BB1]] ]
; CHECK-OUTLOOP-NEXT:    [[INDVARS_NEXT]] = add nuw nsw i64 [[INDVARS]], 1
; CHECK-OUTLOOP-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-OUTLOOP-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_END_LOOPEXIT]], label %[[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK-OUTLOOP:       [[FOR_END_LOOPEXIT]]:
; CHECK-OUTLOOP-NEXT:    [[RDX_PHI_NEXT_LCSSA:%.*]] = phi i32 [ [[RDX_PHI_NEXT]], %[[FOR_INC]] ], [ [[RDX_SELECT]], %[[MIDDLE_BLOCK]] ]
; CHECK-OUTLOOP-NEXT:    br label %[[FOR_END]]
; CHECK-OUTLOOP:       [[FOR_END]]:
; CHECK-OUTLOOP-NEXT:    [[SELECT_LCSSA:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[RDX_PHI_NEXT_LCSSA]], %[[FOR_END_LOOPEXIT]] ]
; CHECK-OUTLOOP-NEXT:    ret i32 [[SELECT_LCSSA]]
;
; CHECK-INLOOP-LABEL: define i32 @select_icmp_switch(
; CHECK-INLOOP-SAME: i32 [[N:%.*]], i32 [[CASE:%.*]], ptr [[A:%.*]], ptr [[B:%.*]], i32 [[ANYOF:%.*]]) {
; CHECK-INLOOP-NEXT:  [[ENTRY:.*]]:
; CHECK-INLOOP-NEXT:    [[CMP_SGT:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-INLOOP-NEXT:    br i1 [[CMP_SGT]], label %[[FOR_BODY_PREHEADER:.*]], label %[[FOR_END:.*]]
; CHECK-INLOOP:       [[FOR_BODY_PREHEADER]]:
; CHECK-INLOOP-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64
; CHECK-INLOOP-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], 4
; CHECK-INLOOP-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK-INLOOP:       [[VECTOR_PH]]:
; CHECK-INLOOP-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], 4
; CHECK-INLOOP-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; CHECK-INLOOP-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i32> poison, i32 [[CASE]], i64 0
; CHECK-INLOOP-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i32> [[BROADCAST_SPLATINSERT]], <4 x i32> poison, <4 x i32> zeroinitializer
; CHECK-INLOOP-NEXT:    [[TMP0:%.*]] = icmp eq <4 x i32> [[BROADCAST_SPLAT]], splat (i32 1)
; CHECK-INLOOP-NEXT:    [[TMP1:%.*]] = xor <4 x i1> [[TMP0]], splat (i1 true)
; CHECK-INLOOP-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK-INLOOP:       [[VECTOR_BODY]]:
; CHECK-INLOOP-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-INLOOP-NEXT:    [[VEC_PHI:%.*]] = phi i1 [ false, %[[VECTOR_PH]] ], [ [[TMP8:%.*]], %[[VECTOR_BODY]] ]
; CHECK-INLOOP-NEXT:    [[TMP2:%.*]] = add i64 [[INDEX]], 0
; CHECK-INLOOP-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[TMP2]]
; CHECK-INLOOP-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i8, ptr [[TMP3]], i32 0
; CHECK-INLOOP-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i8>, ptr [[TMP4]], align 1
; CHECK-INLOOP-NEXT:    [[TMP5:%.*]] = icmp eq <4 x i8> [[WIDE_LOAD]], splat (i8 -1)
; CHECK-INLOOP-NEXT:    [[TMP11:%.*]] = xor <4 x i1> [[TMP5]], splat (i1 true)
; CHECK-INLOOP-NEXT:    [[TMP6:%.*]] = select <4 x i1> [[TMP1]], <4 x i1> [[TMP11]], <4 x i1> zeroinitializer
; CHECK-INLOOP-NEXT:    [[TMP7:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP6]])
; CHECK-INLOOP-NEXT:    [[TMP8]] = or i1 [[TMP7]], [[VEC_PHI]]
; CHECK-INLOOP-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4
; CHECK-INLOOP-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-INLOOP-NEXT:    br i1 [[TMP9]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK-INLOOP:       [[MIDDLE_BLOCK]]:
; CHECK-INLOOP-NEXT:    [[TMP10:%.*]] = freeze i1 [[TMP8]]
; CHECK-INLOOP-NEXT:    [[RDX_SELECT:%.*]] = select i1 [[TMP10]], i32 [[ANYOF]], i32 0
; CHECK-INLOOP-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; CHECK-INLOOP-NEXT:    br i1 [[CMP_N]], label %[[FOR_END_LOOPEXIT:.*]], label %[[SCALAR_PH]]
; CHECK-INLOOP:       [[SCALAR_PH]]:
; CHECK-INLOOP-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY_PREHEADER]] ]
; CHECK-INLOOP-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[RDX_SELECT]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY_PREHEADER]] ]
; CHECK-INLOOP-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-INLOOP:       [[FOR_BODY]]:
; CHECK-INLOOP-NEXT:    [[INDVARS:%.*]] = phi i64 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[INDVARS_NEXT:%.*]], %[[FOR_INC:.*]] ]
; CHECK-INLOOP-NEXT:    [[RDX_PHI:%.*]] = phi i32 [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ], [ [[RDX_PHI_NEXT:%.*]], %[[FOR_INC]] ]
; CHECK-INLOOP-NEXT:    [[A_ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[INDVARS]]
; CHECK-INLOOP-NEXT:    [[A_VALUE:%.*]] = load i8, ptr [[A_ARRAYIDX]], align 1
; CHECK-INLOOP-NEXT:    [[CMP_A:%.*]] = icmp eq i8 [[A_VALUE]], -1
; CHECK-INLOOP-NEXT:    switch i32 [[CASE]], label %[[SW_BB0:.*]] [
; CHECK-INLOOP-NEXT:      i32 0, label %[[SW_BB0]]
; CHECK-INLOOP-NEXT:      i32 1, label %[[SW_BB1:.*]]
; CHECK-INLOOP-NEXT:    ]
; CHECK-INLOOP:       [[SW_BB0]]:
; CHECK-INLOOP-NEXT:    [[SELECT_BB0:%.*]] = select i1 [[CMP_A]], i32 [[RDX_PHI]], i32 [[ANYOF]]
; CHECK-INLOOP-NEXT:    br label %[[FOR_INC]]
; CHECK-INLOOP:       [[SW_BB1]]:
; CHECK-INLOOP-NEXT:    br label %[[FOR_INC]]
; CHECK-INLOOP:       [[FOR_INC]]:
; CHECK-INLOOP-NEXT:    [[RDX_PHI_NEXT]] = phi i32 [ [[SELECT_BB0]], %[[SW_BB0]] ], [ [[RDX_PHI]], %[[SW_BB1]] ]
; CHECK-INLOOP-NEXT:    [[INDVARS_NEXT]] = add nuw nsw i64 [[INDVARS]], 1
; CHECK-INLOOP-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-INLOOP-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_END_LOOPEXIT]], label %[[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK-INLOOP:       [[FOR_END_LOOPEXIT]]:
; CHECK-INLOOP-NEXT:    [[RDX_PHI_NEXT_LCSSA:%.*]] = phi i32 [ [[RDX_PHI_NEXT]], %[[FOR_INC]] ], [ [[RDX_SELECT]], %[[MIDDLE_BLOCK]] ]
; CHECK-INLOOP-NEXT:    br label %[[FOR_END]]
; CHECK-INLOOP:       [[FOR_END]]:
; CHECK-INLOOP-NEXT:    [[SELECT_LCSSA:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[RDX_PHI_NEXT_LCSSA]], %[[FOR_END_LOOPEXIT]] ]
; CHECK-INLOOP-NEXT:    ret i32 [[SELECT_LCSSA]]
;
entry:
  %cmp.sgt = icmp sgt i32 %n, 0
  br i1 %cmp.sgt, label %for.body.preheader, label %for.end

for.body.preheader:
  %wide.trip.count = zext i32 %n to i64
  br label %for.body

for.body:
  %indvars = phi i64 [ 0, %for.body.preheader ], [ %indvars.next, %for.inc ]
  %rdx.phi = phi i32 [ 0, %for.body.preheader ], [ %rdx.phi.next, %for.inc ]
  %a.arrayidx = getelementptr inbounds i8, ptr %a, i64 %indvars
  %a.value = load i8, ptr %a.arrayidx, align 1
  %cmp.a = icmp eq i8 %a.value, -1
  switch i32 %case, label %sw.bb0 [
  i32 0, label %sw.bb0
  i32 1, label %sw.bb1
  ]

sw.bb0:
  %select.bb0 = select i1 %cmp.a, i32 %rdx.phi, i32 %anyof
  br label %for.inc

sw.bb1:
  br label %for.inc

for.inc:
  %rdx.phi.next = phi i32 [ %select.bb0, %sw.bb0 ], [ %rdx.phi, %sw.bb1 ]
  %indvars.next = add nuw nsw i64 %indvars, 1
  %exitcond.not = icmp eq i64 %indvars.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  %select.lcssa = phi i32 [ %rdx.phi.next, %for.inc ], [ 0, %entry ]
  ret i32 %select.lcssa
}
;.
; CHECK-OUTLOOP: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK-OUTLOOP: [[META1]] = !{!"llvm.loop.isvectorized", i32 1}
; CHECK-OUTLOOP: [[META2]] = !{!"llvm.loop.unroll.runtime.disable"}
; CHECK-OUTLOOP: [[LOOP3]] = distinct !{[[LOOP3]], [[META2]], [[META1]]}
;.
; CHECK-INLOOP: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK-INLOOP: [[META1]] = !{!"llvm.loop.isvectorized", i32 1}
; CHECK-INLOOP: [[META2]] = !{!"llvm.loop.unroll.runtime.disable"}
; CHECK-INLOOP: [[LOOP3]] = distinct !{[[LOOP3]], [[META2]], [[META1]]}
;.
