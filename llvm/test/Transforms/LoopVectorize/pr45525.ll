; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -loop-vectorize -force-vector-width=4 -S | FileCheck %s

; Test case for PR45525. Checks that phi's with a single predecessor and a mask are supported.

define void @main(i1 %cond, i32* %arr) {
; CHECK-LABEL: @main(
; CHECK-NEXT:  bb.0:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i1> poison, i1 [[COND:%.*]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i1> [[BROADCAST_SPLATINSERT]], <4 x i1> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[INDEX]], 0
; CHECK-NEXT:    [[TMP1:%.*]] = mul <4 x i32> [[VEC_IND]], <i32 3, i32 3, i32 3, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = xor <4 x i1> [[BROADCAST_SPLAT]], <i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[TMP2]], <4 x i32> [[TMP1]], <4 x i32> <i32 7, i32 7, i32 7, i32 7>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, i32* [[ARR:%.*]], i32 [[TMP0]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, i32* [[TMP3]], i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32* [[TMP4]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> [[PREDPHI]], <4 x i32>* [[TMP5]], align 4
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 4
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <4 x i32> [[VEC_IND]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i32 [[INDEX_NEXT]], 32
; CHECK-NEXT:    br i1 [[TMP6]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 32, 32
; CHECK-NEXT:    br i1 [[CMP_N]], label [[BB_4:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ 32, [[MIDDLE_BLOCK]] ], [ 0, [[BB_0:%.*]] ]
; CHECK-NEXT:    br label [[BB_1:%.*]]
; CHECK:       bb.1:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[IV_NEXT:%.*]], [[BB_3:%.*]] ]
; CHECK-NEXT:    br i1 [[COND]], label [[BB_3]], label [[BB_2:%.*]]
; CHECK:       bb.2:
; CHECK-NEXT:    [[SINGLE_PRED:%.*]] = phi i32 [ [[IV]], [[BB_1]] ]
; CHECK-NEXT:    [[MULT:%.*]] = mul i32 [[SINGLE_PRED]], 3
; CHECK-NEXT:    br label [[BB_3]]
; CHECK:       bb.3:
; CHECK-NEXT:    [[STORED_VALUE:%.*]] = phi i32 [ 7, [[BB_1]] ], [ [[MULT]], [[BB_2]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32* [[ARR]], i32 [[IV]]
; CHECK-NEXT:    store i32 [[STORED_VALUE]], i32* [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[CONTINUE:%.*]] = icmp ult i32 [[IV_NEXT]], 32
; CHECK-NEXT:    br i1 [[CONTINUE]], label [[BB_1]], label [[BB_4]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       bb.4:
; CHECK-NEXT:    ret void
;
bb.0:
  br label %bb.1

bb.1:                                             ; preds = %bb.3, %bb.0
  %iv = phi i32 [ 0, %bb.0 ], [ %iv.next, %bb.3 ]
  br i1 %cond, label %bb.3, label %bb.2

bb.2:                                             ; preds = %bb.1
  %single.pred = phi i32 [ %iv, %bb.1 ]
  %mult = mul i32 %single.pred, 3
  br label %bb.3

bb.3:                                             ; preds = %bb.2, %bb.1
  %stored.value = phi i32 [ 7, %bb.1 ], [ %mult, %bb.2 ]
  %arrayidx = getelementptr inbounds i32, i32* %arr, i32 %iv
  store i32 %stored.value, i32* %arrayidx
  %iv.next = add i32 %iv, 1
  %continue = icmp ult i32 %iv.next, 32
  br i1 %continue, label %bb.1, label %bb.4

bb.4:                                             ; preds = %bb.3
  ret void
}
