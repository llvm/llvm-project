; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --filter-out-after "scalar.ph\:" --version 5
; RUN: opt < %s -passes=loop-vectorize -force-vector-width=4 -S | FileCheck %s

; Test case for PR45525. Checks that phi's with a single predecessor and a mask are supported.

define void @main(i1 %cond, ptr %arr) {
; CHECK-LABEL: define void @main(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[ARR:%.*]]) {
; CHECK-NEXT:  [[BB_0:.*:]]
; CHECK-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i1> poison, i1 [[COND]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i1> [[BROADCAST_SPLATINSERT]], <4 x i1> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = mul <4 x i32> [[VEC_IND]], splat (i32 3)
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[BROADCAST_SPLAT]], <4 x i32> splat (i32 7), <4 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[ARR]], i32 [[INDEX]]
; CHECK-NEXT:    store <4 x i32> [[PREDPHI]], ptr [[TMP1]], align 4
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 4
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <4 x i32> [[VEC_IND]], splat (i32 4)
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[INDEX_NEXT]], 32
; CHECK-NEXT:    br i1 [[TMP2]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    br [[BB_4:label %.*]]
; CHECK:       [[SCALAR_PH]]:
;
bb.0:
  br label %bb.1

bb.1:                                             ; preds = %bb.3, %bb.0
  %iv = phi i32 [ 0, %bb.0 ], [ %iv.next, %bb.3 ]
  br i1 %cond, label %bb.3, label %bb.2

bb.2:                                             ; preds = %bb.1
  %single.pred = phi i32 [ %iv, %bb.1 ]
  %mult = mul i32 %single.pred, 3
  br label %bb.3

bb.3:                                             ; preds = %bb.2, %bb.1
  %stored.value = phi i32 [ 7, %bb.1 ], [ %mult, %bb.2 ]
  %arrayidx = getelementptr inbounds i32, ptr %arr, i32 %iv
  store i32 %stored.value, ptr %arrayidx
  %iv.next = add i32 %iv, 1
  %continue = icmp ult i32 %iv.next, 32
  br i1 %continue, label %bb.1, label %bb.4

bb.4:                                             ; preds = %bb.3
  ret void
}
