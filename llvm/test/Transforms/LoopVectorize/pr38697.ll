; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=loop-vectorize -force-vector-width=2 -S < %s 2>&1 | FileCheck %s
; RUN: opt -passes=indvars -S < %s 2>&1 | FileCheck %s -check-prefix=INDVARCHECK

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Produced from test-case:
;
; void testCountIncrLoop(unsigned char *ptr, int lim, int count, int val)
; {
;   int inx = 0;
;   for (int outer_i = 0; outer_i < lim; ++outer_i) {
;     if (count > 0) { // At runtime, 'count' is 0, so the following code is dead.
;       int result = val;
;       int tmp = count;
;
;       while (tmp < 8) {
;         result += val >> tmp;
;         tmp += count;
;       }
;
;       ptr[inx++] = (unsigned char) result;
;     }
;   }
; }
;
; No explicit division appears in the input, but a division is generated during
; vectorization, and that division is a division-by-0 when the input 'count'
; is 0, so it cannot be hoisted above the guard of 'count > 0'.

; Verify that a 'udiv' does not appear in the 'loop1.preheader' block, and that
; a 'udiv' has been inserted at the top of the 'while.body.preheader' block.
define void @testCountIncrLoop(ptr %ptr, i32 %lim, i32 %count, i32 %val) mustprogress {
; CHECK-LABEL: define void @testCountIncrLoop(
; CHECK-SAME: ptr [[PTR:%.*]], i32 [[LIM:%.*]], i32 [[COUNT:%.*]], i32 [[VAL:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[LIM]], 0
; CHECK-NEXT:    br i1 [[CMP1]], label %[[LOOP1_PREHEADER:.*]], label %[[EXIT:.*]]
; CHECK:       [[LOOP1_PREHEADER]]:
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[COUNT]], 0
; CHECK-NEXT:    [[CMP4:%.*]] = icmp slt i32 [[COUNT]], 8
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[COUNT]], 1
; CHECK-NEXT:    [[SMAX:%.*]] = call i32 @llvm.smax.i32(i32 [[TMP0]], i32 8)
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[SMAX]], [[TMP0]]
; CHECK-NEXT:    [[UMIN:%.*]] = call i32 @llvm.umin.i32(i32 [[TMP1]], i32 1)
; CHECK-NEXT:    [[TMP2:%.*]] = sub i32 [[SMAX]], [[UMIN]]
; CHECK-NEXT:    [[TMP3:%.*]] = sub i32 [[TMP2]], [[TMP0]]
; CHECK-NEXT:    br label %[[LOOP1_BODY:.*]]
; CHECK:       [[LOOP1_BODY]]:
; CHECK-NEXT:    [[OUTER_I:%.*]] = phi i32 [ 0, %[[LOOP1_PREHEADER]] ], [ [[OUTER_I_1:%.*]], %[[LOOP1_INC:.*]] ]
; CHECK-NEXT:    [[INX_1:%.*]] = phi i32 [ 0, %[[LOOP1_PREHEADER]] ], [ [[INX_2:%.*]], %[[LOOP1_INC]] ]
; CHECK-NEXT:    br i1 [[CMP2]], label %[[WHILE_COND_PREHEADER:.*]], label %[[LOOP1_INC]]
; CHECK:       [[WHILE_COND_PREHEADER]]:
; CHECK-NEXT:    br i1 [[CMP4]], label %[[WHILE_BODY_PREHEADER:.*]], label %[[WHILE_END:.*]]
; CHECK:       [[WHILE_BODY_PREHEADER]]:
; CHECK-NEXT:    [[TMP4:%.*]] = udiv i32 [[TMP3]], [[COUNT]]
; CHECK-NEXT:    [[TMP5:%.*]] = add i32 [[UMIN]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = add i32 [[TMP5]], 1
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[TMP6]], 4
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[TMP6]], 4
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[TMP6]], [[N_MOD_VF]]
; CHECK-NEXT:    [[TMP7:%.*]] = mul i32 [[N_VEC]], [[COUNT]]
; CHECK-NEXT:    [[IND_END:%.*]] = add i32 [[COUNT]], [[TMP7]]
; CHECK-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[COUNT]], i64 0
; CHECK-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <2 x i32> [[DOTSPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[DOTSPLATINSERT1:%.*]] = insertelement <2 x i32> poison, i32 [[COUNT]], i64 0
; CHECK-NEXT:    [[DOTSPLAT2:%.*]] = shufflevector <2 x i32> [[DOTSPLATINSERT1]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP8:%.*]] = mul <2 x i32> <i32 0, i32 1>, [[DOTSPLAT2]]
; CHECK-NEXT:    [[INDUCTION:%.*]] = add <2 x i32> [[DOTSPLAT]], [[TMP8]]
; CHECK-NEXT:    [[TMP9:%.*]] = mul i32 [[COUNT]], 2
; CHECK-NEXT:    [[DOTSPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[TMP9]], i64 0
; CHECK-NEXT:    [[DOTSPLAT4:%.*]] = shufflevector <2 x i32> [[DOTSPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[VAL]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[VAL]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <2 x i32> [ [[INDUCTION]], %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP10]], %[[VECTOR_PH]] ], [ [[TMP13:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI6:%.*]] = phi <2 x i32> [ zeroinitializer, %[[VECTOR_PH]] ], [ [[TMP14:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[STEP_ADD:%.*]] = add <2 x i32> [[VEC_IND]], [[DOTSPLAT4]]
; CHECK-NEXT:    [[TMP11:%.*]] = ashr <2 x i32> [[BROADCAST_SPLAT]], [[VEC_IND]]
; CHECK-NEXT:    [[TMP12:%.*]] = ashr <2 x i32> [[BROADCAST_SPLAT]], [[STEP_ADD]]
; CHECK-NEXT:    [[TMP13]] = add <2 x i32> [[TMP11]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP14]] = add <2 x i32> [[TMP12]], [[VEC_PHI6]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 4
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <2 x i32> [[STEP_ADD]], [[DOTSPLAT4]]
; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP15]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP6]], [[N_VEC]]
; CHECK-NEXT:    [[BIN_RDX:%.*]] = add <2 x i32> [[TMP14]], [[TMP13]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[BIN_RDX]])
; CHECK-NEXT:    br i1 [[CMP_N]], label %[[WHILE_END_LOOPEXIT:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], %[[MIDDLE_BLOCK]] ], [ [[COUNT]], %[[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[VAL]], %[[WHILE_BODY_PREHEADER]] ], [ [[TMP16]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[WHILE_BODY:.*]]
; CHECK:       [[WHILE_BODY]]:
; CHECK-NEXT:    [[TMP:%.*]] = phi i32 [ [[ADD3:%.*]], %[[WHILE_BODY]] ], [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[RESULT_1:%.*]] = phi i32 [ [[ADD:%.*]], %[[WHILE_BODY]] ], [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[SHR:%.*]] = ashr i32 [[VAL]], [[TMP]]
; CHECK-NEXT:    [[ADD]] = add nsw i32 [[SHR]], [[RESULT_1]]
; CHECK-NEXT:    [[ADD3]] = add nsw i32 [[TMP]], [[COUNT]]
; CHECK-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[ADD3]], 8
; CHECK-NEXT:    br i1 [[CMP3]], label %[[WHILE_BODY]], label %[[WHILE_END_LOOPEXIT]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK:       [[WHILE_END_LOOPEXIT]]:
; CHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi i32 [ [[ADD]], %[[WHILE_BODY]] ], [ [[TMP16]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[WHILE_END]]
; CHECK:       [[WHILE_END]]:
; CHECK-NEXT:    [[RESULT_0_LCSSA:%.*]] = phi i32 [ [[VAL]], %[[WHILE_COND_PREHEADER]] ], [ [[ADD_LCSSA]], %[[WHILE_END_LOOPEXIT]] ]
; CHECK-NEXT:    [[CONV:%.*]] = trunc i32 [[RESULT_0_LCSSA]] to i8
; CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[INX_1]], 1
; CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[INX_1]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[IDXPROM]]
; CHECK-NEXT:    store i8 [[CONV]], ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    br label %[[LOOP1_INC]]
; CHECK:       [[LOOP1_INC]]:
; CHECK-NEXT:    [[INX_2]] = phi i32 [ [[INC]], %[[WHILE_END]] ], [ [[INX_1]], %[[LOOP1_BODY]] ]
; CHECK-NEXT:    [[OUTER_I_1]] = add nuw nsw i32 [[OUTER_I]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[OUTER_I_1]], [[LIM]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT_LOOPEXIT:.*]], label %[[LOOP1_BODY]]
; CHECK:       [[EXIT_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
; INDVARCHECK-LABEL: define void @testCountIncrLoop(
; INDVARCHECK-SAME: ptr [[PTR:%.*]], i32 [[LIM:%.*]], i32 [[COUNT:%.*]], i32 [[VAL:%.*]]) #[[ATTR0:[0-9]+]] {
; INDVARCHECK-NEXT:  [[ENTRY:.*:]]
; INDVARCHECK-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[LIM]], 0
; INDVARCHECK-NEXT:    br i1 [[CMP1]], label %[[LOOP1_PREHEADER:.*]], label %[[EXIT:.*]]
; INDVARCHECK:       [[LOOP1_PREHEADER]]:
; INDVARCHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[COUNT]], 0
; INDVARCHECK-NEXT:    [[CMP4:%.*]] = icmp slt i32 [[COUNT]], 8
; INDVARCHECK-NEXT:    br label %[[LOOP1_BODY:.*]]
; INDVARCHECK:       [[LOOP1_BODY]]:
; INDVARCHECK-NEXT:    [[OUTER_I:%.*]] = phi i32 [ 0, %[[LOOP1_PREHEADER]] ], [ [[OUTER_I_1:%.*]], %[[LOOP1_INC:.*]] ]
; INDVARCHECK-NEXT:    [[INX_1:%.*]] = phi i32 [ 0, %[[LOOP1_PREHEADER]] ], [ [[INX_2:%.*]], %[[LOOP1_INC]] ]
; INDVARCHECK-NEXT:    br i1 [[CMP2]], label %[[WHILE_COND_PREHEADER:.*]], label %[[LOOP1_INC]]
; INDVARCHECK:       [[WHILE_COND_PREHEADER]]:
; INDVARCHECK-NEXT:    br i1 [[CMP4]], label %[[WHILE_BODY_PREHEADER:.*]], label %[[WHILE_END:.*]]
; INDVARCHECK:       [[WHILE_BODY_PREHEADER]]:
; INDVARCHECK-NEXT:    br label %[[WHILE_BODY:.*]]
; INDVARCHECK:       [[WHILE_BODY]]:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = phi i32 [ [[ADD3:%.*]], %[[WHILE_BODY]] ], [ [[COUNT]], %[[WHILE_BODY_PREHEADER]] ]
; INDVARCHECK-NEXT:    [[RESULT_1:%.*]] = phi i32 [ [[ADD:%.*]], %[[WHILE_BODY]] ], [ [[VAL]], %[[WHILE_BODY_PREHEADER]] ]
; INDVARCHECK-NEXT:    [[SHR:%.*]] = ashr i32 [[VAL]], [[TMP]]
; INDVARCHECK-NEXT:    [[ADD]] = add nsw i32 [[SHR]], [[RESULT_1]]
; INDVARCHECK-NEXT:    [[ADD3]] = add nsw i32 [[TMP]], [[COUNT]]
; INDVARCHECK-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[ADD3]], 8
; INDVARCHECK-NEXT:    br i1 [[CMP3]], label %[[WHILE_BODY]], label %[[WHILE_END_LOOPEXIT:.*]]
; INDVARCHECK:       [[WHILE_END_LOOPEXIT]]:
; INDVARCHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi i32 [ [[ADD]], %[[WHILE_BODY]] ]
; INDVARCHECK-NEXT:    br label %[[WHILE_END]]
; INDVARCHECK:       [[WHILE_END]]:
; INDVARCHECK-NEXT:    [[RESULT_0_LCSSA:%.*]] = phi i32 [ [[VAL]], %[[WHILE_COND_PREHEADER]] ], [ [[ADD_LCSSA]], %[[WHILE_END_LOOPEXIT]] ]
; INDVARCHECK-NEXT:    [[CONV:%.*]] = trunc i32 [[RESULT_0_LCSSA]] to i8
; INDVARCHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[INX_1]], 1
; INDVARCHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[INX_1]] to i64
; INDVARCHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[IDXPROM]]
; INDVARCHECK-NEXT:    store i8 [[CONV]], ptr [[ARRAYIDX]], align 1
; INDVARCHECK-NEXT:    br label %[[LOOP1_INC]]
; INDVARCHECK:       [[LOOP1_INC]]:
; INDVARCHECK-NEXT:    [[INX_2]] = phi i32 [ [[INC]], %[[WHILE_END]] ], [ [[INX_1]], %[[LOOP1_BODY]] ]
; INDVARCHECK-NEXT:    [[OUTER_I_1]] = add nuw nsw i32 [[OUTER_I]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[OUTER_I_1]], [[LIM]]
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label %[[EXIT_LOOPEXIT:.*]], label %[[LOOP1_BODY]]
; INDVARCHECK:       [[EXIT_LOOPEXIT]]:
; INDVARCHECK-NEXT:    br label %[[EXIT]]
; INDVARCHECK:       [[EXIT]]:
; INDVARCHECK-NEXT:    ret void
;
entry:
  %cmp1 = icmp sgt i32 %lim, 0
  br i1 %cmp1, label %loop1.preheader, label %exit

loop1.preheader:                                  ; preds = %entry
  %cmp2 = icmp sgt i32 %count, 0
  %cmp4 = icmp slt i32 %count, 8
  br label %loop1.body

loop1.body:                                       ; preds = %loop1.inc, %loop1.preheader
  %outer_i = phi i32 [ 0, %loop1.preheader ], [ %outer_i.1, %loop1.inc ]
  %inx.1 = phi i32 [ 0, %loop1.preheader ], [ %inx.2, %loop1.inc ]
  br i1 %cmp2, label %while.cond.preheader, label %loop1.inc

while.cond.preheader:                             ; preds = %loop1.body
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.body, %while.cond.preheader
  %temp = phi i32 [ %add3, %while.body ], [ %count, %while.cond.preheader ]
  %result.1 = phi i32 [ %add, %while.body ], [ %val, %while.cond.preheader ]
  %shr = ashr i32 %val, %temp
  %add = add nsw i32 %shr, %result.1
  %add3 = add nsw i32 %temp, %count
  %cmp3 = icmp slt i32 %add3, 8
  br i1 %cmp3, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %while.cond.preheader
  %result.0.lcssa = phi i32 [ %val, %while.cond.preheader ], [ %add, %while.body ]
  %conv = trunc i32 %result.0.lcssa to i8
  %inc = add nsw i32 %inx.1, 1
  %idxprom = sext i32 %inx.1 to i64
  %arrayidx = getelementptr inbounds i8, ptr %ptr, i64 %idxprom
  store i8 %conv, ptr %arrayidx, align 1
  br label %loop1.inc

loop1.inc:                                        ; preds = %while.end, %loop1.body
  %inx.2 = phi i32 [ %inc, %while.end ], [ %inx.1, %loop1.body ]
  %outer_i.1 = add nuw nsw i32 %outer_i, 1
  %exitcond = icmp eq i32 %outer_i.1, %lim
  br i1 %exitcond, label %exit, label %loop1.body

exit:                                             ; preds = %loop1.inc, %entry
  ret void
}

; These next tests are all based on the following source code, with slight
; variations on the calculation of 'incr' (all of which are loop-invariant
; divisions, but only some of which can be safely hoisted):
;
; uint32_t foo(uint32_t *ptr, uint32_t start1, uint32_t start2) {
;   uint32_t counter1, counter2;
;   uint32_t val = start1;
;   for (counter1 = 1; counter1 < 100; ++counter1) {
;     uint32_t index = 0;
;     val += ptr[index];
;     for (counter2 = start2; counter2 < 10; ++counter2) {
;       // Division is loop invariant, and denominator is guaranteed non-zero:
;       // Safe to hoist it out of the inner loop.
;       uint32_t incr = 16 / counter1;
;       index += incr;
;       val += ptr[index];
;     }
;   }
;   return val;
; }

; This version is as written above, where 'incr' is '16/counter1', and it is
; guaranted that 'counter1' is always non-zero.  So it is safe to hoist the
; division from the inner loop to the preheader.
;
; Verify that the 'udiv' is hoisted to the preheader, and is not in the loop body.
define i32 @NonZeroDivHoist(ptr nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: define i32 @NonZeroDivHoist(
; CHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2]]
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END:.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ 1, %[[ENTRY]] ], [ [[INC9:%.*]], %[[FOR_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; CHECK:       [[FOR_BODY3_LR_PH]]:
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP1]]
; CHECK-NEXT:    [[IND_END1:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[PRED_LOAD_CONTINUE6:.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP2]], %[[VECTOR_PH]] ], [ [[TMP26:%.*]], %[[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP1]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT4]]
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <2 x i1> [[TMP3]], i32 0
; CHECK-NEXT:    br i1 [[TMP4]], label %[[PRED_LOAD_IF:.*]], label %[[PRED_LOAD_CONTINUE:.*]]
; CHECK:       [[PRED_LOAD_IF]]:
; CHECK-NEXT:    [[TMP5:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 0, [[TMP1]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[OFFSET_IDX]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP5]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i32 [[TMP8]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP10]], align 4
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x i32> poison, i32 [[TMP11]], i32 0
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE]]
; CHECK:       [[PRED_LOAD_CONTINUE]]:
; CHECK-NEXT:    [[TMP13:%.*]] = phi i32 [ poison, %[[VECTOR_BODY]] ], [ [[TMP5]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP14:%.*]] = phi <2 x i32> [ poison, %[[VECTOR_BODY]] ], [ [[TMP12]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = extractelement <2 x i1> [[TMP3]], i32 1
; CHECK-NEXT:    br i1 [[TMP15]], label %[[PRED_LOAD_IF5:.*]], label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_IF5]]:
; CHECK-NEXT:    [[TMP16:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP17:%.*]] = mul i32 1, [[TMP1]]
; CHECK-NEXT:    [[TMP18:%.*]] = add i32 [[OFFSET_IDX]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = add i32 [[TMP16]], [[TMP18]]
; CHECK-NEXT:    [[TMP20:%.*]] = zext i32 [[TMP19]] to i64
; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP20]]
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, ptr [[TMP21]], align 4
; CHECK-NEXT:    [[TMP23:%.*]] = insertelement <2 x i32> [[TMP14]], i32 [[TMP22]], i32 1
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_CONTINUE6]]:
; CHECK-NEXT:    [[TMP24:%.*]] = phi i32 [ poison, %[[PRED_LOAD_CONTINUE]] ], [ [[TMP16]], %[[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP25:%.*]] = phi <2 x i32> [ [[TMP14]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP23]], %[[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP26]] = add <2 x i32> [[TMP25]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP27:%.*]] = select <2 x i1> [[TMP3]], <2 x i32> [[TMP26]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP28:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP28]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[TMP29:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP27]])
; CHECK-NEXT:    br i1 true, label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL2:%.*]] = phi i32 [ [[IND_END1]], %[[MIDDLE_BLOCK]] ], [ [[START2]], %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[TMP29]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; CHECK:       [[FOR_BODY3]]:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[ADD4:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL2]], %[[SCALAR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TEMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TEMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP5:![0-9]+]]
; CHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ], [ [[TMP29]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_END]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label %[[FOR_COND]]
; CHECK:       [[FOR_END10]]:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: define i32 @NonZeroDivHoist(
; INDVARCHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; INDVARCHECK-NEXT:  [[ENTRY:.*]]:
; INDVARCHECK-NEXT:    br label %[[FOR_COND:.*]]
; INDVARCHECK:       [[FOR_COND]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_END:.*]] ], [ 1, %[[ENTRY]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END]] ]
; INDVARCHECK-NEXT:    [[EXITCOND4:%.*]] = icmp ne i64 [[INDVARS_IV]], 100
; INDVARCHECK-NEXT:    br i1 [[EXITCOND4]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; INDVARCHECK:       [[FOR_BODY]]:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; INDVARCHECK:       [[FOR_BODY3_LR_PH]]:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = udiv i64 16, [[INDVARS_IV]]
; INDVARCHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; INDVARCHECK:       [[FOR_BODY3]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], %[[FOR_BODY3]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], %[[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP0]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]]
; INDVARCHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label %[[FOR_END]]
; INDVARCHECK:       [[FOR_END]]:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label %[[FOR_COND]]
; INDVARCHECK:       [[FOR_END10]]:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ 1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %temp = load i32, ptr %ptr, align 4
  %add = add i32 %temp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 16, %counter1.0
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, ptr %ptr, i64 %idxprom5
  %temp1 = load i32, ptr %arrayidx6, align 4
  %add7 = add i32 %temp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}

; This version is identical to the above 'NonZeroDivHoist' case, except the
; outer ('counter1') loop starts at the unknown value of 'start1' rather than 1,
; and so it is illegal to hoist the division because if 'start1' is 0, hoisting
; it would incorrectly cause a divide-by-zero trap.
;
; Verify that the 'udiv' is not hoisted to the preheader, and it remains in the
; loop body.
define i32 @ZeroDivNoHoist(ptr nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: define i32 @ZeroDivNoHoist(
; CHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2]]
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END:.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[INC9:%.*]], %[[FOR_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; CHECK:       [[FOR_BODY3_LR_PH]]:
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP1]]
; CHECK-NEXT:    [[IND_END1:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[PRED_LOAD_CONTINUE6:.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP2]], %[[VECTOR_PH]] ], [ [[TMP26:%.*]], %[[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP1]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT4]]
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <2 x i1> [[TMP3]], i32 0
; CHECK-NEXT:    br i1 [[TMP4]], label %[[PRED_LOAD_IF:.*]], label %[[PRED_LOAD_CONTINUE:.*]]
; CHECK:       [[PRED_LOAD_IF]]:
; CHECK-NEXT:    [[TMP5:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 0, [[TMP1]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[OFFSET_IDX]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP5]], [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i32 [[TMP8]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP10]], align 4
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x i32> poison, i32 [[TMP11]], i32 0
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE]]
; CHECK:       [[PRED_LOAD_CONTINUE]]:
; CHECK-NEXT:    [[TMP13:%.*]] = phi i32 [ poison, %[[VECTOR_BODY]] ], [ [[TMP5]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP14:%.*]] = phi <2 x i32> [ poison, %[[VECTOR_BODY]] ], [ [[TMP12]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = extractelement <2 x i1> [[TMP3]], i32 1
; CHECK-NEXT:    br i1 [[TMP15]], label %[[PRED_LOAD_IF5:.*]], label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_IF5]]:
; CHECK-NEXT:    [[TMP16:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP17:%.*]] = mul i32 1, [[TMP1]]
; CHECK-NEXT:    [[TMP18:%.*]] = add i32 [[OFFSET_IDX]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = add i32 [[TMP16]], [[TMP18]]
; CHECK-NEXT:    [[TMP20:%.*]] = zext i32 [[TMP19]] to i64
; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP20]]
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, ptr [[TMP21]], align 4
; CHECK-NEXT:    [[TMP23:%.*]] = insertelement <2 x i32> [[TMP14]], i32 [[TMP22]], i32 1
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_CONTINUE6]]:
; CHECK-NEXT:    [[TMP24:%.*]] = phi i32 [ poison, %[[PRED_LOAD_CONTINUE]] ], [ [[TMP16]], %[[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP25:%.*]] = phi <2 x i32> [ [[TMP14]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP23]], %[[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP26]] = add <2 x i32> [[TMP25]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP27:%.*]] = select <2 x i1> [[TMP3]], <2 x i32> [[TMP26]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP28:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP28]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[TMP29:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP27]])
; CHECK-NEXT:    br i1 true, label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL2:%.*]] = phi i32 [ [[IND_END1]], %[[MIDDLE_BLOCK]] ], [ [[START2]], %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[TMP29]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; CHECK:       [[FOR_BODY3]]:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[ADD4:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL2]], %[[SCALAR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TEMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TEMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP7:![0-9]+]]
; CHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ], [ [[TMP29]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_END]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label %[[FOR_COND]]
; CHECK:       [[FOR_END10]]:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: define i32 @ZeroDivNoHoist(
; INDVARCHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; INDVARCHECK-NEXT:  [[ENTRY:.*]]:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[START1]] to i64
; INDVARCHECK-NEXT:    br label %[[FOR_COND:.*]]
; INDVARCHECK:       [[FOR_COND]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_END:.*]] ], [ [[TMP0]], %[[ENTRY]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END]] ]
; INDVARCHECK-NEXT:    [[INDVARS3:%.*]] = trunc i64 [[INDVARS_IV]] to i32
; INDVARCHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[INDVARS3]], 100
; INDVARCHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; INDVARCHECK:       [[FOR_BODY]]:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; INDVARCHECK:       [[FOR_BODY3_LR_PH]]:
; INDVARCHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; INDVARCHECK:       [[FOR_BODY3]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], %[[FOR_BODY3]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], %[[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = udiv i64 16, [[INDVARS_IV]]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP1]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TEMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TEMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]]
; INDVARCHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label %[[FOR_END]]
; INDVARCHECK:       [[FOR_END]]:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label %[[FOR_COND]]
; INDVARCHECK:       [[FOR_END10]]:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ %start1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %temp = load i32, ptr %ptr, align 4
  %add = add i32 %temp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 16, %counter1.0
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, ptr %ptr, i64 %idxprom5
  %temp1 = load i32, ptr %arrayidx6, align 4
  %add7 = add i32 %temp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}

; This version is has a clearly safe division by a non-zero constant (16).  The
; division is transformed to a logical-shift-right of 4, and it is safely
; hoisted.
;
; Verify that the division-operation is hoisted, and that it appears as a
; right-shift ('lshr') rather than an explicit division.
define i32 @DivBy16Hoist(ptr nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: define i32 @DivBy16Hoist(
; CHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2]]
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END:.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[INC9:%.*]], %[[FOR_END]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i32 [[COUNTER1_0]], 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; CHECK:       [[FOR_BODY3_LR_PH]]:
; CHECK-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP1]]
; CHECK-NEXT:    [[IND_END1:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[PRED_LOAD_CONTINUE6:.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP2]], %[[VECTOR_PH]] ], [ [[TMP24:%.*]], %[[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP1]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT4]]
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <2 x i1> [[TMP3]], i32 0
; CHECK-NEXT:    br i1 [[TMP4]], label %[[PRED_LOAD_IF:.*]], label %[[PRED_LOAD_CONTINUE:.*]]
; CHECK:       [[PRED_LOAD_IF]]:
; CHECK-NEXT:    [[TMP5:%.*]] = mul i32 0, [[TMP1]]
; CHECK-NEXT:    [[TMP6:%.*]] = add i32 [[OFFSET_IDX]], [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = udiv i32 [[COUNTER1_0]], 16
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i32 [[TMP8]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP10]], align 4
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x i32> poison, i32 [[TMP11]], i32 0
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE]]
; CHECK:       [[PRED_LOAD_CONTINUE]]:
; CHECK-NEXT:    [[TMP13:%.*]] = phi <2 x i32> [ poison, %[[VECTOR_BODY]] ], [ [[TMP12]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP14:%.*]] = extractelement <2 x i1> [[TMP3]], i32 1
; CHECK-NEXT:    br i1 [[TMP14]], label %[[PRED_LOAD_IF5:.*]], label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_IF5]]:
; CHECK-NEXT:    [[TMP15:%.*]] = mul i32 1, [[TMP1]]
; CHECK-NEXT:    [[TMP16:%.*]] = add i32 [[OFFSET_IDX]], [[TMP15]]
; CHECK-NEXT:    [[TMP17:%.*]] = udiv i32 [[COUNTER1_0]], 16
; CHECK-NEXT:    [[TMP18:%.*]] = add i32 [[TMP17]], [[TMP16]]
; CHECK-NEXT:    [[TMP19:%.*]] = zext i32 [[TMP18]] to i64
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP19]]
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[TMP20]], align 4
; CHECK-NEXT:    [[TMP22:%.*]] = insertelement <2 x i32> [[TMP13]], i32 [[TMP21]], i32 1
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_CONTINUE6]]:
; CHECK-NEXT:    [[TMP23:%.*]] = phi <2 x i32> [ [[TMP13]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP22]], %[[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP24]] = add <2 x i32> [[TMP23]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP25:%.*]] = select <2 x i1> [[TMP3]], <2 x i32> [[TMP24]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP26:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP26]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP8:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[TMP27:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP25]])
; CHECK-NEXT:    br i1 true, label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL2:%.*]] = phi i32 [ [[IND_END1]], %[[MIDDLE_BLOCK]] ], [ [[START2]], %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[TMP27]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; CHECK:       [[FOR_BODY3]]:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[ADD4:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL2]], %[[SCALAR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 [[COUNTER1_0]], 16
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TEMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TEMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP9:![0-9]+]]
; CHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ], [ [[TMP27]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_END]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label %[[FOR_COND]]
; CHECK:       [[FOR_END10]]:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: define i32 @DivBy16Hoist(
; INDVARCHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; INDVARCHECK-NEXT:  [[ENTRY:.*]]:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[START1]] to i64
; INDVARCHECK-NEXT:    br label %[[FOR_COND:.*]]
; INDVARCHECK:       [[FOR_COND]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_END:.*]] ], [ [[TMP0]], %[[ENTRY]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END]] ]
; INDVARCHECK-NEXT:    [[INDVARS3:%.*]] = trunc i64 [[INDVARS_IV]] to i32
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = lshr i64 [[INDVARS_IV]], 4
; INDVARCHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[INDVARS3]], 100
; INDVARCHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; INDVARCHECK:       [[FOR_BODY]]:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; INDVARCHECK:       [[FOR_BODY3_LR_PH]]:
; INDVARCHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; INDVARCHECK:       [[FOR_BODY3]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], %[[FOR_BODY3]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], %[[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP1]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TEMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TEMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]]
; INDVARCHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label %[[FOR_END]]
; INDVARCHECK:       [[FOR_END]]:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label %[[FOR_COND]]
; INDVARCHECK:       [[FOR_END10]]:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ %start1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %temp = load i32, ptr %ptr, align 4
  %add = add i32 %temp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 %counter1.0, 16
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, ptr %ptr, i64 %idxprom5
  %temp1 = load i32, ptr %arrayidx6, align 4
  %add7 = add i32 %temp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}

; This version is has a clearly safe division by a non-zero constant (17).  The
; division is safely hoisted, as it was in the 'DivBy16Hoist' verison, but here
; it remains a division, rather than being transformed to a right-shift.
;
; Verify that the division-operation is hoisted.
define i32 @DivBy17Hoist(ptr nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: define i32 @DivBy17Hoist(
; CHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2]]
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END:.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[INC9:%.*]], %[[FOR_END]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; CHECK:       [[FOR_BODY3_LR_PH]]:
; CHECK-NEXT:    br i1 false, label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP1]]
; CHECK-NEXT:    [[IND_END1:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[PRED_LOAD_CONTINUE6:.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP2]], %[[VECTOR_PH]] ], [ [[TMP24:%.*]], %[[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP1]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT4]]
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <2 x i1> [[TMP3]], i32 0
; CHECK-NEXT:    br i1 [[TMP4]], label %[[PRED_LOAD_IF:.*]], label %[[PRED_LOAD_CONTINUE:.*]]
; CHECK:       [[PRED_LOAD_IF]]:
; CHECK-NEXT:    [[TMP5:%.*]] = mul i32 0, [[TMP1]]
; CHECK-NEXT:    [[TMP6:%.*]] = add i32 [[OFFSET_IDX]], [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i32 [[TMP8]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP10]], align 4
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x i32> poison, i32 [[TMP11]], i32 0
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE]]
; CHECK:       [[PRED_LOAD_CONTINUE]]:
; CHECK-NEXT:    [[TMP13:%.*]] = phi <2 x i32> [ poison, %[[VECTOR_BODY]] ], [ [[TMP12]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP14:%.*]] = extractelement <2 x i1> [[TMP3]], i32 1
; CHECK-NEXT:    br i1 [[TMP14]], label %[[PRED_LOAD_IF5:.*]], label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_IF5]]:
; CHECK-NEXT:    [[TMP15:%.*]] = mul i32 1, [[TMP1]]
; CHECK-NEXT:    [[TMP16:%.*]] = add i32 [[OFFSET_IDX]], [[TMP15]]
; CHECK-NEXT:    [[TMP17:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[TMP18:%.*]] = add i32 [[TMP17]], [[TMP16]]
; CHECK-NEXT:    [[TMP19:%.*]] = zext i32 [[TMP18]] to i64
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[TMP19]]
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[TMP20]], align 4
; CHECK-NEXT:    [[TMP22:%.*]] = insertelement <2 x i32> [[TMP13]], i32 [[TMP21]], i32 1
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_CONTINUE6]]:
; CHECK-NEXT:    [[TMP23:%.*]] = phi <2 x i32> [ [[TMP13]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP22]], %[[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP24]] = add <2 x i32> [[TMP23]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP25:%.*]] = select <2 x i1> [[TMP3]], <2 x i32> [[TMP24]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP26:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP26]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP10:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[TMP27:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP25]])
; CHECK-NEXT:    br i1 true, label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], %[[MIDDLE_BLOCK]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL2:%.*]] = phi i32 [ [[IND_END1]], %[[MIDDLE_BLOCK]] ], [ [[START2]], %[[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[TMP27]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; CHECK:       [[FOR_BODY3]]:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ], [ [[ADD4:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL2]], %[[SCALAR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TEMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TEMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP11:![0-9]+]]
; CHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ], [ [[TMP27]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label %[[FOR_END]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label %[[FOR_COND]]
; CHECK:       [[FOR_END10]]:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: define i32 @DivBy17Hoist(
; INDVARCHECK-SAME: ptr nocapture readonly [[PTR:%.*]], i32 [[START1:%.*]], i32 [[START2:%.*]]) {
; INDVARCHECK-NEXT:  [[ENTRY:.*]]:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[START1]] to i64
; INDVARCHECK-NEXT:    br label %[[FOR_COND:.*]]
; INDVARCHECK:       [[FOR_COND]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_END:.*]] ], [ [[TMP0]], %[[ENTRY]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], %[[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], %[[FOR_END]] ]
; INDVARCHECK-NEXT:    [[INDVARS3:%.*]] = trunc i64 [[INDVARS_IV]] to i32
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = udiv i64 [[INDVARS_IV]], 17
; INDVARCHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[INDVARS3]], 100
; INDVARCHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END10:.*]]
; INDVARCHECK:       [[FOR_BODY]]:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, ptr [[PTR]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label %[[FOR_BODY3_LR_PH:.*]], label %[[FOR_END]]
; INDVARCHECK:       [[FOR_BODY3_LR_PH]]:
; INDVARCHECK-NEXT:    br label %[[FOR_BODY3:.*]]
; INDVARCHECK:       [[FOR_BODY3]]:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], %[[FOR_BODY3]] ], [ 0, %[[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], %[[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], %[[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP1]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TEMP1:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TEMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label %[[FOR_BODY3]], label %[[FOR_COND1_FOR_END_CRIT_EDGE:.*]]
; INDVARCHECK:       [[FOR_COND1_FOR_END_CRIT_EDGE]]:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], %[[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label %[[FOR_END]]
; INDVARCHECK:       [[FOR_END]]:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], %[[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], %[[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label %[[FOR_COND]]
; INDVARCHECK:       [[FOR_END10]]:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], %[[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ %start1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %temp = load i32, ptr %ptr, align 4
  %add = add i32 %temp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 %counter1.0, 17
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, ptr %ptr, i64 %idxprom5
  %temp1 = load i32, ptr %arrayidx6, align 4
  %add7 = add i32 %temp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}
;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.isvectorized", i32 1}
; CHECK: [[META2]] = !{!"llvm.loop.unroll.runtime.disable"}
; CHECK: [[LOOP3]] = distinct !{[[LOOP3]], [[META2]], [[META1]]}
; CHECK: [[LOOP4]] = distinct !{[[LOOP4]], [[META1]], [[META2]]}
; CHECK: [[LOOP5]] = distinct !{[[LOOP5]], [[META2]], [[META1]]}
; CHECK: [[LOOP6]] = distinct !{[[LOOP6]], [[META1]], [[META2]]}
; CHECK: [[LOOP7]] = distinct !{[[LOOP7]], [[META2]], [[META1]]}
; CHECK: [[LOOP8]] = distinct !{[[LOOP8]], [[META1]], [[META2]]}
; CHECK: [[LOOP9]] = distinct !{[[LOOP9]], [[META2]], [[META1]]}
; CHECK: [[LOOP10]] = distinct !{[[LOOP10]], [[META1]], [[META2]]}
; CHECK: [[LOOP11]] = distinct !{[[LOOP11]], [[META2]], [[META1]]}
;.
