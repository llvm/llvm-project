; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -loop-vectorize -force-vector-width=2 -S < %s 2>&1 | FileCheck %s
; RUN: opt -indvars -S < %s 2>&1 | FileCheck %s -check-prefix=INDVARCHECK

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Produced from test-case:
;
; void testCountIncrLoop(unsigned char *ptr, int lim, int count, int val)
; {
;   int inx = 0;
;   for (int outer_i = 0; outer_i < lim; ++outer_i) {
;     if (count > 0) { // At runtime, 'count' is 0, so the following code is dead.
;       int result = val;
;       int tmp = count;
;
;       while (tmp < 8) {
;         result += val >> tmp;
;         tmp += count;
;       }
;
;       ptr[inx++] = (unsigned char) result;
;     }
;   }
; }
;
; No explicit division appears in the input, but a division is generated during
; vectorization, and that division is a division-by-0 when the input 'count'
; is 0, so it cannot be hoisted above the guard of 'count > 0'.

; Verify that a 'udiv' does not appear in the 'loop1.preheader' block, and that
; a 'udiv' has been inserted at the top of the 'while.body.preheader' block.
define void @testCountIncrLoop(i8* %ptr, i32 %lim, i32 %count, i32 %val) mustprogress {
; CHECK-LABEL: @testCountIncrLoop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[LIM:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP1]], label [[LOOP1_PREHEADER:%.*]], label [[EXIT:%.*]]
; CHECK:       loop1.preheader:
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[COUNT:%.*]], 0
; CHECK-NEXT:    [[CMP4:%.*]] = icmp slt i32 [[COUNT]], 8
; CHECK-NEXT:    [[TMP0:%.*]] = shl i32 [[COUNT]], 1
; CHECK-NEXT:    [[SMAX:%.*]] = call i32 @llvm.smax.i32(i32 [[TMP0]], i32 8)
; CHECK-NEXT:    [[TMP1:%.*]] = sub i32 [[SMAX]], [[TMP0]]
; CHECK-NEXT:    [[UMIN:%.*]] = call i32 @llvm.umin.i32(i32 [[TMP1]], i32 1)
; CHECK-NEXT:    [[TMP2:%.*]] = sub i32 [[SMAX]], [[UMIN]]
; CHECK-NEXT:    [[TMP3:%.*]] = sub i32 [[TMP2]], [[TMP0]]
; CHECK-NEXT:    br label [[LOOP1_BODY:%.*]]
; CHECK:       loop1.body:
; CHECK-NEXT:    [[OUTER_I:%.*]] = phi i32 [ 0, [[LOOP1_PREHEADER]] ], [ [[OUTER_I_1:%.*]], [[LOOP1_INC:%.*]] ]
; CHECK-NEXT:    [[INX_1:%.*]] = phi i32 [ 0, [[LOOP1_PREHEADER]] ], [ [[INX_2:%.*]], [[LOOP1_INC]] ]
; CHECK-NEXT:    br i1 [[CMP2]], label [[WHILE_COND_PREHEADER:%.*]], label [[LOOP1_INC]]
; CHECK:       while.cond.preheader:
; CHECK-NEXT:    br i1 [[CMP4]], label [[WHILE_BODY_PREHEADER:%.*]], label [[WHILE_END:%.*]]
; CHECK:       while.body.preheader:
; CHECK-NEXT:    [[TMP4:%.*]] = udiv i32 [[TMP3]], [[COUNT]]
; CHECK-NEXT:    [[TMP5:%.*]] = add i32 [[UMIN]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = add i32 [[TMP5]], 1
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[TMP6]], 4
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[TMP6]], 4
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[TMP6]], [[N_MOD_VF]]
; CHECK-NEXT:    [[TMP7:%.*]] = mul i32 [[N_VEC]], [[COUNT]]
; CHECK-NEXT:    [[IND_END:%.*]] = add i32 [[COUNT]], [[TMP7]]
; CHECK-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[COUNT]], i32 0
; CHECK-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <2 x i32> [[DOTSPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[DOTSPLATINSERT1:%.*]] = insertelement <2 x i32> poison, i32 [[COUNT]], i32 0
; CHECK-NEXT:    [[DOTSPLAT2:%.*]] = shufflevector <2 x i32> [[DOTSPLATINSERT1]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP8:%.*]] = mul <2 x i32> <i32 0, i32 1>, [[DOTSPLAT2]]
; CHECK-NEXT:    [[INDUCTION:%.*]] = add <2 x i32> [[DOTSPLAT]], [[TMP8]]
; CHECK-NEXT:    [[TMP9:%.*]] = mul i32 [[COUNT]], 2
; CHECK-NEXT:    [[DOTSPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[TMP9]], i32 0
; CHECK-NEXT:    [[DOTSPLAT4:%.*]] = shufflevector <2 x i32> [[DOTSPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[VAL:%.*]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[VAL]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT7:%.*]] = insertelement <2 x i32> poison, i32 [[VAL]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT8:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT7]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <2 x i32> [ [[INDUCTION]], [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP10]], [[VECTOR_PH]] ], [ [[TMP13:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI6:%.*]] = phi <2 x i32> [ zeroinitializer, [[VECTOR_PH]] ], [ [[TMP14:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[STEP_ADD:%.*]] = add <2 x i32> [[VEC_IND]], [[DOTSPLAT4]]
; CHECK-NEXT:    [[TMP11:%.*]] = ashr <2 x i32> [[BROADCAST_SPLAT]], [[VEC_IND]]
; CHECK-NEXT:    [[TMP12:%.*]] = ashr <2 x i32> [[BROADCAST_SPLAT8]], [[STEP_ADD]]
; CHECK-NEXT:    [[TMP13]] = add <2 x i32> [[TMP11]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP14]] = add <2 x i32> [[TMP12]], [[VEC_PHI6]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 4
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <2 x i32> [[STEP_ADD]], [[DOTSPLAT4]]
; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP15]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[BIN_RDX:%.*]] = add <2 x i32> [[TMP14]], [[TMP13]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[BIN_RDX]])
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP6]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], label [[WHILE_END_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ [[COUNT]], [[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[VAL]], [[WHILE_BODY_PREHEADER]] ], [ [[TMP16]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[TMP:%.*]] = phi i32 [ [[ADD3:%.*]], [[WHILE_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]
; CHECK-NEXT:    [[RESULT_1:%.*]] = phi i32 [ [[ADD:%.*]], [[WHILE_BODY]] ], [ [[BC_MERGE_RDX]], [[SCALAR_PH]] ]
; CHECK-NEXT:    [[SHR:%.*]] = ashr i32 [[VAL]], [[TMP]]
; CHECK-NEXT:    [[ADD]] = add nsw i32 [[SHR]], [[RESULT_1]]
; CHECK-NEXT:    [[ADD3]] = add nsw i32 [[TMP]], [[COUNT]]
; CHECK-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[ADD3]], 8
; CHECK-NEXT:    br i1 [[CMP3]], label [[WHILE_BODY]], label [[WHILE_END_LOOPEXIT]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       while.end.loopexit:
; CHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi i32 [ [[ADD]], [[WHILE_BODY]] ], [ [[TMP16]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[WHILE_END]]
; CHECK:       while.end:
; CHECK-NEXT:    [[RESULT_0_LCSSA:%.*]] = phi i32 [ [[VAL]], [[WHILE_COND_PREHEADER]] ], [ [[ADD_LCSSA]], [[WHILE_END_LOOPEXIT]] ]
; CHECK-NEXT:    [[CONV:%.*]] = trunc i32 [[RESULT_0_LCSSA]] to i8
; CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[INX_1]], 1
; CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[INX_1]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8* [[PTR:%.*]], i64 [[IDXPROM]]
; CHECK-NEXT:    store i8 [[CONV]], i8* [[ARRAYIDX]], align 1
; CHECK-NEXT:    br label [[LOOP1_INC]]
; CHECK:       loop1.inc:
; CHECK-NEXT:    [[INX_2]] = phi i32 [ [[INC]], [[WHILE_END]] ], [ [[INX_1]], [[LOOP1_BODY]] ]
; CHECK-NEXT:    [[OUTER_I_1]] = add nuw nsw i32 [[OUTER_I]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[OUTER_I_1]], [[LIM]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[EXIT_LOOPEXIT:%.*]], label [[LOOP1_BODY]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
; INDVARCHECK-LABEL: @testCountIncrLoop(
; INDVARCHECK-NEXT:  entry:
; INDVARCHECK-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[LIM:%.*]], 0
; INDVARCHECK-NEXT:    br i1 [[CMP1]], label [[LOOP1_PREHEADER:%.*]], label [[EXIT:%.*]]
; INDVARCHECK:       loop1.preheader:
; INDVARCHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[COUNT:%.*]], 0
; INDVARCHECK-NEXT:    [[CMP4:%.*]] = icmp slt i32 [[COUNT]], 8
; INDVARCHECK-NEXT:    br label [[LOOP1_BODY:%.*]]
; INDVARCHECK:       loop1.body:
; INDVARCHECK-NEXT:    [[OUTER_I:%.*]] = phi i32 [ 0, [[LOOP1_PREHEADER]] ], [ [[OUTER_I_1:%.*]], [[LOOP1_INC:%.*]] ]
; INDVARCHECK-NEXT:    [[INX_1:%.*]] = phi i32 [ 0, [[LOOP1_PREHEADER]] ], [ [[INX_2:%.*]], [[LOOP1_INC]] ]
; INDVARCHECK-NEXT:    br i1 [[CMP2]], label [[WHILE_COND_PREHEADER:%.*]], label [[LOOP1_INC]]
; INDVARCHECK:       while.cond.preheader:
; INDVARCHECK-NEXT:    br i1 [[CMP4]], label [[WHILE_BODY_PREHEADER:%.*]], label [[WHILE_END:%.*]]
; INDVARCHECK:       while.body.preheader:
; INDVARCHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; INDVARCHECK:       while.body:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = phi i32 [ [[ADD3:%.*]], [[WHILE_BODY]] ], [ [[COUNT]], [[WHILE_BODY_PREHEADER]] ]
; INDVARCHECK-NEXT:    [[RESULT_1:%.*]] = phi i32 [ [[ADD:%.*]], [[WHILE_BODY]] ], [ [[VAL:%.*]], [[WHILE_BODY_PREHEADER]] ]
; INDVARCHECK-NEXT:    [[SHR:%.*]] = ashr i32 [[VAL]], [[TMP]]
; INDVARCHECK-NEXT:    [[ADD]] = add nsw i32 [[SHR]], [[RESULT_1]]
; INDVARCHECK-NEXT:    [[ADD3]] = add nsw i32 [[TMP]], [[COUNT]]
; INDVARCHECK-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[ADD3]], 8
; INDVARCHECK-NEXT:    br i1 [[CMP3]], label [[WHILE_BODY]], label [[WHILE_END_LOOPEXIT:%.*]]
; INDVARCHECK:       while.end.loopexit:
; INDVARCHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi i32 [ [[ADD]], [[WHILE_BODY]] ]
; INDVARCHECK-NEXT:    br label [[WHILE_END]]
; INDVARCHECK:       while.end:
; INDVARCHECK-NEXT:    [[RESULT_0_LCSSA:%.*]] = phi i32 [ [[VAL]], [[WHILE_COND_PREHEADER]] ], [ [[ADD_LCSSA]], [[WHILE_END_LOOPEXIT]] ]
; INDVARCHECK-NEXT:    [[CONV:%.*]] = trunc i32 [[RESULT_0_LCSSA]] to i8
; INDVARCHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[INX_1]], 1
; INDVARCHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[INX_1]] to i64
; INDVARCHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8* [[PTR:%.*]], i64 [[IDXPROM]]
; INDVARCHECK-NEXT:    store i8 [[CONV]], i8* [[ARRAYIDX]], align 1
; INDVARCHECK-NEXT:    br label [[LOOP1_INC]]
; INDVARCHECK:       loop1.inc:
; INDVARCHECK-NEXT:    [[INX_2]] = phi i32 [ [[INC]], [[WHILE_END]] ], [ [[INX_1]], [[LOOP1_BODY]] ]
; INDVARCHECK-NEXT:    [[OUTER_I_1]] = add nuw nsw i32 [[OUTER_I]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[OUTER_I_1]], [[LIM]]
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label [[EXIT_LOOPEXIT:%.*]], label [[LOOP1_BODY]]
; INDVARCHECK:       exit.loopexit:
; INDVARCHECK-NEXT:    br label [[EXIT]]
; INDVARCHECK:       exit:
; INDVARCHECK-NEXT:    ret void
;
entry:
  %cmp1 = icmp sgt i32 %lim, 0
  br i1 %cmp1, label %loop1.preheader, label %exit

loop1.preheader:                                  ; preds = %entry
  %cmp2 = icmp sgt i32 %count, 0
  %cmp4 = icmp slt i32 %count, 8
  br label %loop1.body

loop1.body:                                       ; preds = %loop1.inc, %loop1.preheader
  %outer_i = phi i32 [ 0, %loop1.preheader ], [ %outer_i.1, %loop1.inc ]
  %inx.1 = phi i32 [ 0, %loop1.preheader ], [ %inx.2, %loop1.inc ]
  br i1 %cmp2, label %while.cond.preheader, label %loop1.inc

while.cond.preheader:                             ; preds = %loop1.body
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.body, %while.cond.preheader
  %tmp = phi i32 [ %add3, %while.body ], [ %count, %while.cond.preheader ]
  %result.1 = phi i32 [ %add, %while.body ], [ %val, %while.cond.preheader ]
  %shr = ashr i32 %val, %tmp
  %add = add nsw i32 %shr, %result.1
  %add3 = add nsw i32 %tmp, %count
  %cmp3 = icmp slt i32 %add3, 8
  br i1 %cmp3, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %while.cond.preheader
  %result.0.lcssa = phi i32 [ %val, %while.cond.preheader ], [ %add, %while.body ]
  %conv = trunc i32 %result.0.lcssa to i8
  %inc = add nsw i32 %inx.1, 1
  %idxprom = sext i32 %inx.1 to i64
  %arrayidx = getelementptr inbounds i8, i8* %ptr, i64 %idxprom
  store i8 %conv, i8* %arrayidx, align 1
  br label %loop1.inc

loop1.inc:                                        ; preds = %while.end, %loop1.body
  %inx.2 = phi i32 [ %inc, %while.end ], [ %inx.1, %loop1.body ]
  %outer_i.1 = add nuw nsw i32 %outer_i, 1
  %exitcond = icmp eq i32 %outer_i.1, %lim
  br i1 %exitcond, label %exit, label %loop1.body

exit:                                             ; preds = %loop1.inc, %entry
  ret void
}

; These next tests are all based on the following source code, with slight
; variations on the calculation of 'incr' (all of which are loop-invariant
; divisions, but only some of which can be safely hoisted):
;
; uint32_t foo(uint32_t *ptr, uint32_t start1, uint32_t start2) {
;   uint32_t counter1, counter2;
;   uint32_t val = start1;
;   for (counter1 = 1; counter1 < 100; ++counter1) {
;     uint32_t index = 0;
;     val += ptr[index];
;     for (counter2 = start2; counter2 < 10; ++counter2) {
;       // Division is loop invariant, and denominator is guaranteed non-zero:
;       // Safe to hoist it out of the inner loop.
;       uint32_t incr = 16 / counter1;
;       index += incr;
;       val += ptr[index];
;     }
;   }
;   return val;
; }

; This version is as written above, where 'incr' is '16/counter1', and it is
; guaranted that 'counter1' is always non-zero.  So it is safe to hoist the
; division from the inner loop to the preheader.
;
; Verify that the 'udiv' is hoisted to the preheader, and is not in the loop body.
define i32 @NonZeroDivHoist(i32* nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: @NonZeroDivHoist(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2:%.*]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1:%.*]], [[ENTRY:%.*]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END:%.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ 1, [[ENTRY]] ], [ [[INC9:%.*]], [[FOR_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; CHECK:       for.body3.lr.ph:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP1]]
; CHECK-NEXT:    [[IND_END2:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[PRED_LOAD_CONTINUE6:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP2]], [[VECTOR_PH]] ], [ [[TMP27:%.*]], [[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP3]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT4]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[PRED_LOAD_IF:%.*]], label [[PRED_LOAD_CONTINUE:%.*]]
; CHECK:       pred.load.if:
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 0, [[TMP3]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[OFFSET_IDX]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, i32* [[TMP11]], align 4
; CHECK-NEXT:    [[TMP13:%.*]] = insertelement <2 x i32> poison, i32 [[TMP12]], i32 0
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE]]
; CHECK:       pred.load.continue:
; CHECK-NEXT:    [[TMP14:%.*]] = phi i32 [ poison, [[VECTOR_BODY]] ], [ [[TMP8]], [[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = phi <2 x i32> [ poison, [[VECTOR_BODY]] ], [ [[TMP13]], [[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP16:%.*]] = extractelement <2 x i1> [[TMP4]], i32 1
; CHECK-NEXT:    br i1 [[TMP16]], label [[PRED_LOAD_IF5:%.*]], label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.if5:
; CHECK-NEXT:    [[TMP17:%.*]] = mul i32 1, [[TMP3]]
; CHECK-NEXT:    [[TMP18:%.*]] = add i32 [[OFFSET_IDX]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP20:%.*]] = add i32 [[TMP19]], [[TMP18]]
; CHECK-NEXT:    [[TMP21:%.*]] = zext i32 [[TMP20]] to i64
; CHECK-NEXT:    [[TMP22:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP21]]
; CHECK-NEXT:    [[TMP23:%.*]] = load i32, i32* [[TMP22]], align 4
; CHECK-NEXT:    [[TMP24:%.*]] = insertelement <2 x i32> [[TMP15]], i32 [[TMP23]], i32 1
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.continue6:
; CHECK-NEXT:    [[TMP25:%.*]] = phi i32 [ poison, [[PRED_LOAD_CONTINUE]] ], [ [[TMP19]], [[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP26:%.*]] = phi <2 x i32> [ [[TMP15]], [[PRED_LOAD_CONTINUE]] ], [ [[TMP24]], [[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP27]] = add <2 x i32> [[TMP26]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP28:%.*]] = select <2 x i1> [[TMP4]], <2 x i32> [[TMP27]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP29:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP29]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP30:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP28]])
; CHECK-NEXT:    br i1 true, label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL1:%.*]] = phi i32 [ [[IND_END2]], [[MIDDLE_BLOCK]] ], [ [[START2]], [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[TMP30]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; CHECK:       for.body3:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[ADD4:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], [[SCALAR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL1]], [[SCALAR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP5:![0-9]+]]
; CHECK:       for.cond1.for.end_crit_edge:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ], [ [[TMP30]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end10:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: @NonZeroDivHoist(
; INDVARCHECK-NEXT:  entry:
; INDVARCHECK-NEXT:    br label [[FOR_COND:%.*]]
; INDVARCHECK:       for.cond:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_END:%.*]] ], [ 1, [[ENTRY:%.*]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1:%.*]], [[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END]] ]
; INDVARCHECK-NEXT:    [[EXITCOND4:%.*]] = icmp ne i64 [[INDVARS_IV]], 100
; INDVARCHECK-NEXT:    br i1 [[EXITCOND4]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; INDVARCHECK:       for.body:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2:%.*]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; INDVARCHECK:       for.body3.lr.ph:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = udiv i64 16, [[INDVARS_IV]]
; INDVARCHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; INDVARCHECK:       for.body3:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], [[FOR_BODY3]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], [[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP0]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]]
; INDVARCHECK:       for.cond1.for.end_crit_edge:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label [[FOR_END]]
; INDVARCHECK:       for.end:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label [[FOR_COND]]
; INDVARCHECK:       for.end10:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ 1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %tmp = load i32, i32* %ptr, align 4
  %add = add i32 %tmp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 16, %counter1.0
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, i32* %ptr, i64 %idxprom5
  %tmp1 = load i32, i32* %arrayidx6, align 4
  %add7 = add i32 %tmp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}

; This version is identical to the above 'NonZeroDivHoist' case, except the
; outer ('counter1') loop starts at the unknown value of 'start1' rather than 1,
; and so it is illegal to hoist the division because if 'start1' is 0, hoisting
; it would incorrectly cause a divide-by-zero trap.
;
; Verify that the 'udiv' is not hoisted to the preheader, and it remains in the
; loop body.
define i32 @ZeroDivNoHoist(i32* nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: @ZeroDivNoHoist(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2:%.*]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1:%.*]], [[ENTRY:%.*]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END:%.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ [[START1]], [[ENTRY]] ], [ [[INC9:%.*]], [[FOR_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; CHECK:       for.body3.lr.ph:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP1]]
; CHECK-NEXT:    [[IND_END2:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[PRED_LOAD_CONTINUE6:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP2]], [[VECTOR_PH]] ], [ [[TMP27:%.*]], [[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP3]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT4]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[PRED_LOAD_IF:%.*]], label [[PRED_LOAD_CONTINUE:%.*]]
; CHECK:       pred.load.if:
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 0, [[TMP3]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[OFFSET_IDX]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, i32* [[TMP11]], align 4
; CHECK-NEXT:    [[TMP13:%.*]] = insertelement <2 x i32> poison, i32 [[TMP12]], i32 0
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE]]
; CHECK:       pred.load.continue:
; CHECK-NEXT:    [[TMP14:%.*]] = phi i32 [ poison, [[VECTOR_BODY]] ], [ [[TMP8]], [[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = phi <2 x i32> [ poison, [[VECTOR_BODY]] ], [ [[TMP13]], [[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP16:%.*]] = extractelement <2 x i1> [[TMP4]], i32 1
; CHECK-NEXT:    br i1 [[TMP16]], label [[PRED_LOAD_IF5:%.*]], label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.if5:
; CHECK-NEXT:    [[TMP17:%.*]] = mul i32 1, [[TMP3]]
; CHECK-NEXT:    [[TMP18:%.*]] = add i32 [[OFFSET_IDX]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[TMP20:%.*]] = add i32 [[TMP19]], [[TMP18]]
; CHECK-NEXT:    [[TMP21:%.*]] = zext i32 [[TMP20]] to i64
; CHECK-NEXT:    [[TMP22:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP21]]
; CHECK-NEXT:    [[TMP23:%.*]] = load i32, i32* [[TMP22]], align 4
; CHECK-NEXT:    [[TMP24:%.*]] = insertelement <2 x i32> [[TMP15]], i32 [[TMP23]], i32 1
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.continue6:
; CHECK-NEXT:    [[TMP25:%.*]] = phi i32 [ poison, [[PRED_LOAD_CONTINUE]] ], [ [[TMP19]], [[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP26:%.*]] = phi <2 x i32> [ [[TMP15]], [[PRED_LOAD_CONTINUE]] ], [ [[TMP24]], [[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP27]] = add <2 x i32> [[TMP26]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP28:%.*]] = select <2 x i1> [[TMP4]], <2 x i32> [[TMP27]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP29:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP29]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP30:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP28]])
; CHECK-NEXT:    br i1 true, label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL1:%.*]] = phi i32 [ [[IND_END2]], [[MIDDLE_BLOCK]] ], [ [[START2]], [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[TMP30]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; CHECK:       for.body3:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[ADD4:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], [[SCALAR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL1]], [[SCALAR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 16, [[COUNTER1_0]]
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP7:![0-9]+]]
; CHECK:       for.cond1.for.end_crit_edge:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ], [ [[TMP30]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end10:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: @ZeroDivNoHoist(
; INDVARCHECK-NEXT:  entry:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[START1:%.*]] to i64
; INDVARCHECK-NEXT:    br label [[FOR_COND:%.*]]
; INDVARCHECK:       for.cond:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_END:%.*]] ], [ [[TMP0]], [[ENTRY:%.*]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], [[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END]] ]
; INDVARCHECK-NEXT:    [[INDVARS3:%.*]] = trunc i64 [[INDVARS_IV]] to i32
; INDVARCHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[INDVARS3]], 100
; INDVARCHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; INDVARCHECK:       for.body:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2:%.*]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; INDVARCHECK:       for.body3.lr.ph:
; INDVARCHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; INDVARCHECK:       for.body3:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], [[FOR_BODY3]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], [[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = udiv i64 16, [[INDVARS_IV]]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP1]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]]
; INDVARCHECK:       for.cond1.for.end_crit_edge:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label [[FOR_END]]
; INDVARCHECK:       for.end:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label [[FOR_COND]]
; INDVARCHECK:       for.end10:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ %start1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %tmp = load i32, i32* %ptr, align 4
  %add = add i32 %tmp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 16, %counter1.0
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, i32* %ptr, i64 %idxprom5
  %tmp1 = load i32, i32* %arrayidx6, align 4
  %add7 = add i32 %tmp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}

; This version is has a clearly safe division by a non-zero constant (16).  The
; division is transformed to a logical-shift-right of 4, and it is safely
; hoisted.
;
; Verify that the division-operation is hoisted, and that it appears as a
; right-shift ('lshr') rather than an explicit division.
define i32 @DivBy16Hoist(i32* nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: @DivBy16Hoist(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2:%.*]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1:%.*]], [[ENTRY:%.*]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END:%.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ [[START1]], [[ENTRY]] ], [ [[INC9:%.*]], [[FOR_END]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i32 [[COUNTER1_0]], 4
; CHECK-NEXT:    [[TMP2:%.*]] = lshr i32 [[COUNTER1_0]], 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; CHECK:       for.body3.lr.ph:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP2]]
; CHECK-NEXT:    [[IND_END2:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[PRED_LOAD_CONTINUE6:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP3]], [[VECTOR_PH]] ], [ [[TMP25:%.*]], [[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP1]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT4]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[PRED_LOAD_IF:%.*]], label [[PRED_LOAD_CONTINUE:%.*]]
; CHECK:       pred.load.if:
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 0, [[TMP1]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[OFFSET_IDX]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 [[COUNTER1_0]], 16
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, i32* [[TMP11]], align 4
; CHECK-NEXT:    [[TMP13:%.*]] = insertelement <2 x i32> poison, i32 [[TMP12]], i32 0
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE]]
; CHECK:       pred.load.continue:
; CHECK-NEXT:    [[TMP14:%.*]] = phi <2 x i32> [ poison, [[VECTOR_BODY]] ], [ [[TMP13]], [[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = extractelement <2 x i1> [[TMP4]], i32 1
; CHECK-NEXT:    br i1 [[TMP15]], label [[PRED_LOAD_IF5:%.*]], label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.if5:
; CHECK-NEXT:    [[TMP16:%.*]] = mul i32 1, [[TMP1]]
; CHECK-NEXT:    [[TMP17:%.*]] = add i32 [[OFFSET_IDX]], [[TMP16]]
; CHECK-NEXT:    [[TMP18:%.*]] = udiv i32 [[COUNTER1_0]], 16
; CHECK-NEXT:    [[TMP19:%.*]] = add i32 [[TMP18]], [[TMP17]]
; CHECK-NEXT:    [[TMP20:%.*]] = zext i32 [[TMP19]] to i64
; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP20]]
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, i32* [[TMP21]], align 4
; CHECK-NEXT:    [[TMP23:%.*]] = insertelement <2 x i32> [[TMP14]], i32 [[TMP22]], i32 1
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.continue6:
; CHECK-NEXT:    [[TMP24:%.*]] = phi <2 x i32> [ [[TMP14]], [[PRED_LOAD_CONTINUE]] ], [ [[TMP23]], [[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP25]] = add <2 x i32> [[TMP24]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP26:%.*]] = select <2 x i1> [[TMP4]], <2 x i32> [[TMP25]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP27]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP8:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP28:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP26]])
; CHECK-NEXT:    br i1 true, label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL1:%.*]] = phi i32 [ [[IND_END2]], [[MIDDLE_BLOCK]] ], [ [[START2]], [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[TMP28]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; CHECK:       for.body3:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[ADD4:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], [[SCALAR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL1]], [[SCALAR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 [[COUNTER1_0]], 16
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP9:![0-9]+]]
; CHECK:       for.cond1.for.end_crit_edge:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ], [ [[TMP28]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end10:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: @DivBy16Hoist(
; INDVARCHECK-NEXT:  entry:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[START1:%.*]] to i64
; INDVARCHECK-NEXT:    br label [[FOR_COND:%.*]]
; INDVARCHECK:       for.cond:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_END:%.*]] ], [ [[TMP0]], [[ENTRY:%.*]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], [[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END]] ]
; INDVARCHECK-NEXT:    [[INDVARS3:%.*]] = trunc i64 [[INDVARS_IV]] to i32
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = lshr i64 [[INDVARS_IV]], 4
; INDVARCHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[INDVARS3]], 100
; INDVARCHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; INDVARCHECK:       for.body:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2:%.*]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; INDVARCHECK:       for.body3.lr.ph:
; INDVARCHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; INDVARCHECK:       for.body3:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], [[FOR_BODY3]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], [[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP1]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]]
; INDVARCHECK:       for.cond1.for.end_crit_edge:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label [[FOR_END]]
; INDVARCHECK:       for.end:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label [[FOR_COND]]
; INDVARCHECK:       for.end10:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ %start1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %tmp = load i32, i32* %ptr, align 4
  %add = add i32 %tmp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 %counter1.0, 16
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, i32* %ptr, i64 %idxprom5
  %tmp1 = load i32, i32* %arrayidx6, align 4
  %add7 = add i32 %tmp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}

; This version is has a clearly safe division by a non-zero constant (17).  The
; division is safely hoisted, as it was in the 'DivBy16Hoist' verison, but here
; it remains a division, rather than being transformed to a right-shift.
;
; Verify that the division-operation is hoisted.
define i32 @DivBy17Hoist(i32* nocapture readonly %ptr, i32 %start1, i32 %start2) {
; CHECK-LABEL: @DivBy17Hoist(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = sub i32 10, [[START2:%.*]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1:%.*]], [[ENTRY:%.*]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END:%.*]] ]
; CHECK-NEXT:    [[COUNTER1_0:%.*]] = phi i32 [ [[START1]], [[ENTRY]] ], [ [[INC9:%.*]], [[FOR_END]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[TMP2:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[COUNTER1_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; CHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2]], 10
; CHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; CHECK:       for.body3.lr.ph:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[N_RND_UP:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[N_RND_UP]], 2
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[N_RND_UP]], [[N_MOD_VF]]
; CHECK-NEXT:    [[IND_END:%.*]] = mul i32 [[N_VEC]], [[TMP2]]
; CHECK-NEXT:    [[IND_END2:%.*]] = add i32 [[START2]], [[N_VEC]]
; CHECK-NEXT:    [[TRIP_COUNT_MINUS_1:%.*]] = sub i32 [[TMP0]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[TRIP_COUNT_MINUS_1]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> zeroinitializer, i32 [[ADD]], i32 0
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[PRED_LOAD_CONTINUE6:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ [[TMP3]], [[VECTOR_PH]] ], [ [[TMP25:%.*]], [[PRED_LOAD_CONTINUE6]] ]
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = mul i32 [[INDEX]], [[TMP1]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i32> poison, i32 [[INDEX]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT3]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VEC_IV:%.*]] = add <2 x i32> [[BROADCAST_SPLAT4]], <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ule <2 x i32> [[VEC_IV]], [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[PRED_LOAD_IF:%.*]], label [[PRED_LOAD_CONTINUE:%.*]]
; CHECK:       pred.load.if:
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 0, [[TMP1]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[OFFSET_IDX]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i32 [[TMP9]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, i32* [[TMP11]], align 4
; CHECK-NEXT:    [[TMP13:%.*]] = insertelement <2 x i32> poison, i32 [[TMP12]], i32 0
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE]]
; CHECK:       pred.load.continue:
; CHECK-NEXT:    [[TMP14:%.*]] = phi <2 x i32> [ poison, [[VECTOR_BODY]] ], [ [[TMP13]], [[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = extractelement <2 x i1> [[TMP4]], i32 1
; CHECK-NEXT:    br i1 [[TMP15]], label [[PRED_LOAD_IF5:%.*]], label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.if5:
; CHECK-NEXT:    [[TMP16:%.*]] = mul i32 1, [[TMP1]]
; CHECK-NEXT:    [[TMP17:%.*]] = add i32 [[OFFSET_IDX]], [[TMP16]]
; CHECK-NEXT:    [[TMP18:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[TMP19:%.*]] = add i32 [[TMP18]], [[TMP17]]
; CHECK-NEXT:    [[TMP20:%.*]] = zext i32 [[TMP19]] to i64
; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[TMP20]]
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, i32* [[TMP21]], align 4
; CHECK-NEXT:    [[TMP23:%.*]] = insertelement <2 x i32> [[TMP14]], i32 [[TMP22]], i32 1
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE6]]
; CHECK:       pred.load.continue6:
; CHECK-NEXT:    [[TMP24:%.*]] = phi <2 x i32> [ [[TMP14]], [[PRED_LOAD_CONTINUE]] ], [ [[TMP23]], [[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP25]] = add <2 x i32> [[TMP24]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP26:%.*]] = select <2 x i1> [[TMP4]], <2 x i32> [[TMP25]], <2 x i32> [[VEC_PHI]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2
; CHECK-NEXT:    [[TMP27:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP27]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP10:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP28:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP26]])
; CHECK-NEXT:    br i1 true, label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[IND_END]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL1:%.*]] = phi i32 [ [[IND_END2]], [[MIDDLE_BLOCK]] ], [ [[START2]], [[FOR_BODY3_LR_PH]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[TMP28]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; CHECK:       for.body3:
; CHECK-NEXT:    [[INDEX_027:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[ADD4:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[BC_MERGE_RDX]], [[SCALAR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[BC_RESUME_VAL1]], [[SCALAR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 [[COUNTER1_0]], 17
; CHECK-NEXT:    [[ADD4]] = add i32 [[DIV]], [[INDEX_027]]
; CHECK-NEXT:    [[IDXPROM5:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[IDXPROM5]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; CHECK-NEXT:    [[INC]] = add i32 [[COUNTER2_025]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[INC]], 10
; CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE]], !llvm.loop [[LOOP11:![0-9]+]]
; CHECK:       for.cond1.for.end_crit_edge:
; CHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ], [ [[TMP28]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[FOR_END]]
; CHECK:       for.end:
; CHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[INC9]] = add i32 [[COUNTER1_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.end10:
; CHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; CHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
; INDVARCHECK-LABEL: @DivBy17Hoist(
; INDVARCHECK-NEXT:  entry:
; INDVARCHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[START1:%.*]] to i64
; INDVARCHECK-NEXT:    br label [[FOR_COND:%.*]]
; INDVARCHECK:       for.cond:
; INDVARCHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_END:%.*]] ], [ [[TMP0]], [[ENTRY:%.*]] ]
; INDVARCHECK-NEXT:    [[VAL_0:%.*]] = phi i32 [ [[START1]], [[ENTRY]] ], [ [[VAL_1_LCSSA:%.*]], [[FOR_END]] ]
; INDVARCHECK-NEXT:    [[INDVARS3:%.*]] = trunc i64 [[INDVARS_IV]] to i32
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = udiv i64 [[INDVARS_IV]], 17
; INDVARCHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[INDVARS3]], 100
; INDVARCHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END10:%.*]]
; INDVARCHECK:       for.body:
; INDVARCHECK-NEXT:    [[TMP:%.*]] = load i32, i32* [[PTR:%.*]], align 4
; INDVARCHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP]], [[VAL_0]]
; INDVARCHECK-NEXT:    [[CMP224:%.*]] = icmp ult i32 [[START2:%.*]], 10
; INDVARCHECK-NEXT:    br i1 [[CMP224]], label [[FOR_BODY3_LR_PH:%.*]], label [[FOR_END]]
; INDVARCHECK:       for.body3.lr.ph:
; INDVARCHECK-NEXT:    br label [[FOR_BODY3:%.*]]
; INDVARCHECK:       for.body3:
; INDVARCHECK-NEXT:    [[INDVARS_IV1:%.*]] = phi i64 [ [[INDVARS_IV_NEXT2:%.*]], [[FOR_BODY3]] ], [ 0, [[FOR_BODY3_LR_PH]] ]
; INDVARCHECK-NEXT:    [[VAL_126:%.*]] = phi i32 [ [[ADD]], [[FOR_BODY3_LR_PH]] ], [ [[ADD7:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[COUNTER2_025:%.*]] = phi i32 [ [[START2]], [[FOR_BODY3_LR_PH]] ], [ [[INC:%.*]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT2]] = add nuw nsw i64 [[INDVARS_IV1]], [[TMP1]]
; INDVARCHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, i32* [[PTR]], i64 [[INDVARS_IV_NEXT2]]
; INDVARCHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* [[ARRAYIDX6]], align 4
; INDVARCHECK-NEXT:    [[ADD7]] = add i32 [[TMP1]], [[VAL_126]]
; INDVARCHECK-NEXT:    [[INC]] = add nuw nsw i32 [[COUNTER2_025]], 1
; INDVARCHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[INC]], 10
; INDVARCHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY3]], label [[FOR_COND1_FOR_END_CRIT_EDGE:%.*]]
; INDVARCHECK:       for.cond1.for.end_crit_edge:
; INDVARCHECK-NEXT:    [[SPLIT:%.*]] = phi i32 [ [[ADD7]], [[FOR_BODY3]] ]
; INDVARCHECK-NEXT:    br label [[FOR_END]]
; INDVARCHECK:       for.end:
; INDVARCHECK-NEXT:    [[VAL_1_LCSSA]] = phi i32 [ [[SPLIT]], [[FOR_COND1_FOR_END_CRIT_EDGE]] ], [ [[ADD]], [[FOR_BODY]] ]
; INDVARCHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; INDVARCHECK-NEXT:    br label [[FOR_COND]]
; INDVARCHECK:       for.end10:
; INDVARCHECK-NEXT:    [[VAL_0_LCSSA:%.*]] = phi i32 [ [[VAL_0]], [[FOR_COND]] ]
; INDVARCHECK-NEXT:    ret i32 [[VAL_0_LCSSA]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %val.0 = phi i32 [ %start1, %entry ], [ %val.1.lcssa, %for.end ]
  %counter1.0 = phi i32 [ %start1, %entry ], [ %inc9, %for.end ]
  %cmp = icmp ult i32 %counter1.0, 100
  br i1 %cmp, label %for.body, label %for.end10

for.body:                                         ; preds = %for.cond
  %tmp = load i32, i32* %ptr, align 4
  %add = add i32 %tmp, %val.0
  %cmp224 = icmp ult i32 %start2, 10
  br i1 %cmp224, label %for.body3.lr.ph, label %for.end

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.body3.lr.ph
  %index.027 = phi i32 [ 0, %for.body3.lr.ph ], [ %add4, %for.body3 ]
  %val.126 = phi i32 [ %add, %for.body3.lr.ph ], [ %add7, %for.body3 ]
  %counter2.025 = phi i32 [ %start2, %for.body3.lr.ph ], [ %inc, %for.body3 ]
  %div = udiv i32 %counter1.0, 17
  %add4 = add i32 %div, %index.027
  %idxprom5 = zext i32 %add4 to i64
  %arrayidx6 = getelementptr inbounds i32, i32* %ptr, i64 %idxprom5
  %tmp1 = load i32, i32* %arrayidx6, align 4
  %add7 = add i32 %tmp1, %val.126
  %inc = add i32 %counter2.025, 1
  %cmp2 = icmp ult i32 %inc, 10
  br i1 %cmp2, label %for.body3, label %for.cond1.for.end_crit_edge

for.cond1.for.end_crit_edge:                      ; preds = %for.body3
  %split = phi i32 [ %add7, %for.body3 ]
  br label %for.end

for.end:                                          ; preds = %for.cond1.for.end_crit_edge, %for.body
  %val.1.lcssa = phi i32 [ %split, %for.cond1.for.end_crit_edge ], [ %add, %for.body ]
  %inc9 = add i32 %counter1.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  %val.0.lcssa = phi i32 [ %val.0, %for.cond ]
  ret i32 %val.0.lcssa
}
