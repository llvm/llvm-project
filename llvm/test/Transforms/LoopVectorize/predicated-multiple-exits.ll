; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --version 6
; RUN: opt -S < %s -p loop-vectorize -force-vector-width=4 | FileCheck %s
;
@p1 = global [64 x i8] zeroinitializer
@p2 = global [64 x i8] zeroinitializer
@p3 = global [64 x i8] zeroinitializer

define i64 @diamond_with_2_early_exits() {
; CHECK-LABEL: define i64 @diamond_with_2_early_exits() {
; CHECK-NEXT:  [[LOOP_HEADER:.*]]:
; CHECK-NEXT:    br label %[[BLOCK_A:.*]]
; CHECK:       [[BLOCK_A]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ [[INDEX_NEXT:%.*]], %[[VECTOR_EARLY_EXIT_1:.*]] ], [ 0, %[[LOOP_HEADER]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @p1, i64 [[INDEX]]
; CHECK-NEXT:    [[LD1:%.*]] = load i8, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[CMP_A:%.*]] = icmp slt i8 [[LD1]], 0
; CHECK-NEXT:    br i1 [[CMP_A]], label %[[LOOP_END:.*]], label %[[LOOP_LATCH:.*]]
; CHECK:       [[LOOP_END]]:
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i8, ptr @p2, i64 [[INDEX]]
; CHECK-NEXT:    [[LD2:%.*]] = load i8, ptr [[GEP2]], align 1
; CHECK-NEXT:    [[EXT:%.*]] = zext i8 [[LD2]] to i64
; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i8 [[LD1]], [[LD2]]
; CHECK-NEXT:    br i1 [[TMP14]], label %[[VECTOR_EARLY_EXIT_0:.*]], label %[[VECTOR_EARLY_EXIT_1]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr @p3, i64 [[INDEX]]
; CHECK-NEXT:    [[LD3:%.*]] = load i8, ptr [[GEP3]], align 1
; CHECK-NEXT:    [[CMP_B:%.*]] = icmp eq i8 [[LD1]], [[LD3]]
; CHECK-NEXT:    br i1 [[CMP_B]], label %[[VECTOR_EARLY_EXIT_0]], label %[[VECTOR_EARLY_EXIT_1]]
; CHECK:       [[VECTOR_EARLY_EXIT_1]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDEX_NEXT]], 64
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[BLOCK_A]], label %[[VECTOR_EARLY_EXIT_0]]
; CHECK:       [[VECTOR_EARLY_EXIT_0]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ [[EXT]], %[[LOOP_END]] ], [ [[INDEX]], %[[LOOP_LATCH]] ], [ 0, %[[VECTOR_EARLY_EXIT_1]] ]
; CHECK-NEXT:    ret i64 [[RETVAL]]
;
entry:
  br label %loop.header

loop.header:
  %index = phi i64 [ %index.next, %loop.latch ], [ 0, %entry ]
  %gep1 = getelementptr inbounds i8, ptr @p1, i64 %index
  %ld1 = load i8, ptr %gep1, align 1
  %branch.cond = icmp slt i8 %ld1, 0
  br i1 %branch.cond, label %block.a, label %block.b

block.a:
  %gep2 = getelementptr inbounds i8, ptr @p2, i64 %index
  %ld2 = load i8, ptr %gep2, align 1
  %ext = zext i8 %ld2 to i64
  %cmp.a = icmp eq i8 %ld1, %ld2
  br i1 %cmp.a, label %loop.end, label %loop.latch

block.b:
  %gep3 = getelementptr inbounds i8, ptr @p3, i64 %index
  %ld3 = load i8, ptr %gep3, align 1
  %cmp.b = icmp eq i8 %ld1, %ld3
  br i1 %cmp.b, label %loop.end, label %loop.latch

loop.latch:
  %index.next = add i64 %index, 1
  %exitcond = icmp ne i64 %index.next, 64
  br i1 %exitcond, label %loop.header, label %loop.end

loop.end:
  %retval = phi i64 [ %ext, %block.a ], [ %index, %block.b ], [ 0, %loop.latch ]
  ret i64 %retval
}

@p4 = global [64 x i8] zeroinitializer

define i64 @three_early_exits() {
; CHECK-LABEL: define i64 @three_early_exits() {
; CHECK-NEXT:  [[VECTOR_PH:.*]]:
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX1:%.*]] = phi i64 [ [[INDEX_NEXT:%.*]], %[[VECTOR_EARLY_EXIT_2:.*]] ], [ 0, %[[VECTOR_PH]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @p1, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD1:%.*]] = load i8, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[TMP19:%.*]] = icmp slt i8 [[LD1]], -42
; CHECK-NEXT:    br i1 [[TMP19]], label %[[VECTOR_EARLY_EXIT_CHECK:.*]], label %[[VECTOR_BODY_INTERIM:.*]]
; CHECK:       [[VECTOR_BODY_INTERIM]]:
; CHECK-NEXT:    [[TMP21:%.*]] = icmp slt i8 [[LD1]], 42
; CHECK-NEXT:    br i1 [[TMP21]], label %[[VECTOR_EARLY_EXIT_0:.*]], label %[[VECTOR_EARLY_EXIT_CHECK_0:.*]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK]]:
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i8, ptr @p2, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD2:%.*]] = load i8, ptr [[GEP2]], align 1
; CHECK-NEXT:    [[TMP22:%.*]] = icmp eq i8 [[LD1]], [[LD2]]
; CHECK-NEXT:    br i1 [[TMP22]], label %[[VECTOR_EARLY_EXIT_1:.*]], label %[[VECTOR_EARLY_EXIT_2]]
; CHECK:       [[VECTOR_EARLY_EXIT_0]]:
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr @p3, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD3:%.*]] = load i8, ptr [[GEP3]], align 1
; CHECK-NEXT:    [[CMP_B:%.*]] = icmp eq i8 [[LD1]], [[LD3]]
; CHECK-NEXT:    br i1 [[CMP_B]], label %[[VECTOR_EARLY_EXIT_1]], label %[[VECTOR_EARLY_EXIT_2]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK_0]]:
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i8, ptr @p4, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD4:%.*]] = load i8, ptr [[GEP4]], align 1
; CHECK-NEXT:    [[CMP_C:%.*]] = icmp eq i8 [[LD1]], [[LD4]]
; CHECK-NEXT:    br i1 [[CMP_C]], label %[[VECTOR_EARLY_EXIT_1]], label %[[VECTOR_EARLY_EXIT_2]]
; CHECK:       [[VECTOR_EARLY_EXIT_2]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX1]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDEX_NEXT]], 64
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[VECTOR_BODY]], label %[[VECTOR_EARLY_EXIT_1]]
; CHECK:       [[VECTOR_EARLY_EXIT_1]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 1, %[[VECTOR_EARLY_EXIT_CHECK]] ], [ 2, %[[VECTOR_EARLY_EXIT_0]] ], [ 3, %[[VECTOR_EARLY_EXIT_CHECK_0]] ], [ 0, %[[VECTOR_EARLY_EXIT_2]] ]
; CHECK-NEXT:    ret i64 [[RETVAL]]
;
entry:
  br label %loop.header

loop.header:
  %index = phi i64 [ %index.next, %loop.latch ], [ 0, %entry ]
  %gep1 = getelementptr inbounds i8, ptr @p1, i64 %index
  %ld1 = load i8, ptr %gep1, align 1
  %cond.a = icmp slt i8 %ld1, -42
  br i1 %cond.a, label %block.a, label %check.b

check.b:
  %cond.b = icmp slt i8 %ld1, 42
  br i1 %cond.b, label %block.b, label %block.c

block.a:
  %gep2 = getelementptr inbounds i8, ptr @p2, i64 %index
  %ld2 = load i8, ptr %gep2, align 1
  %cmp.a = icmp eq i8 %ld1, %ld2
  br i1 %cmp.a, label %loop.end, label %loop.latch

block.b:
  %gep3 = getelementptr inbounds i8, ptr @p3, i64 %index
  %ld3 = load i8, ptr %gep3, align 1
  %cmp.b = icmp eq i8 %ld1, %ld3
  br i1 %cmp.b, label %loop.end, label %loop.latch

block.c:
  %gep4 = getelementptr inbounds i8, ptr @p4, i64 %index
  %ld4 = load i8, ptr %gep4, align 1
  %cmp.c = icmp eq i8 %ld1, %ld4
  br i1 %cmp.c, label %loop.end, label %loop.latch

loop.latch:
  %index.next = add i64 %index, 1
  %exitcond = icmp ne i64 %index.next, 64
  br i1 %exitcond, label %loop.header, label %loop.end

loop.end:
  %retval = phi i64 [ 1, %block.a ], [ 2, %block.b ], [ 3, %block.c ], [ 0, %loop.latch ]
  ret i64 %retval
}

define i64 @nested_diamond_inner_exits() {
; CHECK-LABEL: define i64 @nested_diamond_inner_exits() {
; CHECK-NEXT:  [[VECTOR_PH:.*]]:
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX1:%.*]] = phi i64 [ [[INDEX_NEXT:%.*]], %[[LOOP_END:.*]] ], [ 0, %[[VECTOR_PH]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @p1, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD1:%.*]] = load i8, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[TMP19:%.*]] = icmp slt i8 [[LD1]], 0
; CHECK-NEXT:    br i1 [[TMP19]], label %[[VECTOR_EARLY_EXIT_CHECK:.*]], label %[[VECTOR_BODY_INTERIM:.*]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK]]:
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i8, ptr @p2, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD2:%.*]] = load i8, ptr [[GEP2]], align 1
; CHECK-NEXT:    [[INNER_COND:%.*]] = icmp slt i8 [[LD2]], 0
; CHECK-NEXT:    br i1 [[INNER_COND]], label %[[BLOCK_A1:.*]], label %[[VECTOR_EARLY_EXIT_2:.*]]
; CHECK:       [[BLOCK_A1]]:
; CHECK-NEXT:    [[TMP21:%.*]] = icmp eq i8 [[LD1]], [[LD2]]
; CHECK-NEXT:    br i1 [[TMP21]], label %[[VECTOR_EARLY_EXIT_0:.*]], label %[[VECTOR_EARLY_EXIT_CHECK_0:.*]]
; CHECK:       [[VECTOR_EARLY_EXIT_2]]:
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr @p3, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD3:%.*]] = load i8, ptr [[GEP3]], align 1
; CHECK-NEXT:    [[CMP_A2:%.*]] = icmp eq i8 [[LD1]], [[LD3]]
; CHECK-NEXT:    br i1 [[CMP_A2]], label %[[VECTOR_EARLY_EXIT_0]], label %[[VECTOR_EARLY_EXIT_CHECK_0]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK_0]]:
; CHECK-NEXT:    br label %[[LOOP_END]]
; CHECK:       [[VECTOR_BODY_INTERIM]]:
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i8, ptr @p4, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD4:%.*]] = load i8, ptr [[GEP4]], align 1
; CHECK-NEXT:    [[CMP_B:%.*]] = icmp eq i8 [[LD1]], [[LD4]]
; CHECK-NEXT:    br i1 [[CMP_B]], label %[[VECTOR_EARLY_EXIT_0]], label %[[LOOP_END]]
; CHECK:       [[LOOP_END]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX1]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDEX_NEXT]], 64
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[VECTOR_BODY]], label %[[VECTOR_EARLY_EXIT_0]]
; CHECK:       [[VECTOR_EARLY_EXIT_0]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 1, %[[BLOCK_A1]] ], [ 2, %[[VECTOR_EARLY_EXIT_2]] ], [ 3, %[[VECTOR_BODY_INTERIM]] ], [ 0, %[[LOOP_END]] ]
; CHECK-NEXT:    ret i64 [[RETVAL]]
;
entry:
  br label %loop.header

loop.header:
  %index = phi i64 [ %index.next, %loop.latch ], [ 0, %entry ]
  %gep1 = getelementptr inbounds i8, ptr @p1, i64 %index
  %ld1 = load i8, ptr %gep1, align 1
  %outer.cond = icmp slt i8 %ld1, 0
  br i1 %outer.cond, label %block.a, label %block.b

block.a:
  %gep2 = getelementptr inbounds i8, ptr @p2, i64 %index
  %ld2 = load i8, ptr %gep2, align 1
  %inner.cond = icmp slt i8 %ld2, 0
  br i1 %inner.cond, label %block.a1, label %block.a2

block.a1:
  %cmp.a1 = icmp eq i8 %ld1, %ld2
  br i1 %cmp.a1, label %loop.end, label %join.a

block.a2:
  %gep3 = getelementptr inbounds i8, ptr @p3, i64 %index
  %ld3 = load i8, ptr %gep3, align 1
  %cmp.a2 = icmp eq i8 %ld1, %ld3
  br i1 %cmp.a2, label %loop.end, label %join.a

join.a:
  br label %loop.latch

block.b:
  %gep4 = getelementptr inbounds i8, ptr @p4, i64 %index
  %ld4 = load i8, ptr %gep4, align 1
  %cmp.b = icmp eq i8 %ld1, %ld4
  br i1 %cmp.b, label %loop.end, label %loop.latch

loop.latch:
  %index.next = add i64 %index, 1
  %exitcond = icmp ne i64 %index.next, 64
  br i1 %exitcond, label %loop.header, label %loop.end

loop.end:
  %retval = phi i64 [ 1, %block.a1 ], [ 2, %block.a2 ], [ 3, %block.b ], [ 0, %loop.latch ]
  ret i64 %retval
}

define i64 @chain_of_3_exits() {
; CHECK-LABEL: define i64 @chain_of_3_exits() {
; CHECK-NEXT:  [[VECTOR_PH:.*]]:
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX1:%.*]] = phi i64 [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY_INTERIM:.*]] ], [ 0, %[[VECTOR_PH]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @p1, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD1:%.*]] = load i8, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[TMP18:%.*]] = icmp slt i8 [[LD1]], 0
; CHECK-NEXT:    br i1 [[TMP18]], label %[[VECTOR_EARLY_EXIT_CHECK:.*]], label %[[VECTOR_BODY_INTERIM]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK]]:
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i8, ptr @p2, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD2:%.*]] = load i8, ptr [[GEP2]], align 1
; CHECK-NEXT:    [[TMP20:%.*]] = icmp eq i8 [[LD1]], [[LD2]]
; CHECK-NEXT:    br i1 [[TMP20]], label %[[VECTOR_EARLY_EXIT_0:.*]], label %[[VECTOR_EARLY_EXIT_CHECK_0:.*]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK_0]]:
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr @p3, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD3:%.*]] = load i8, ptr [[GEP3]], align 1
; CHECK-NEXT:    [[CMP_B:%.*]] = icmp eq i8 [[LD1]], [[LD3]]
; CHECK-NEXT:    br i1 [[CMP_B]], label %[[VECTOR_EARLY_EXIT_0]], label %[[VECTOR_EARLY_EXIT_1:.*]]
; CHECK:       [[VECTOR_EARLY_EXIT_1]]:
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i8, ptr @p4, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD4:%.*]] = load i8, ptr [[GEP4]], align 1
; CHECK-NEXT:    [[CMP_C:%.*]] = icmp eq i8 [[LD1]], [[LD4]]
; CHECK-NEXT:    br i1 [[CMP_C]], label %[[VECTOR_EARLY_EXIT_0]], label %[[VECTOR_BODY_INTERIM]]
; CHECK:       [[VECTOR_BODY_INTERIM]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX1]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDEX_NEXT]], 64
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[VECTOR_BODY]], label %[[VECTOR_EARLY_EXIT_0]]
; CHECK:       [[VECTOR_EARLY_EXIT_0]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 1, %[[VECTOR_EARLY_EXIT_CHECK]] ], [ 2, %[[VECTOR_EARLY_EXIT_CHECK_0]] ], [ 3, %[[VECTOR_EARLY_EXIT_1]] ], [ 0, %[[VECTOR_BODY_INTERIM]] ]
; CHECK-NEXT:    ret i64 [[RETVAL]]
;
entry:
  br label %loop.header

loop.header:
  %index = phi i64 [ %index.next, %loop.latch ], [ 0, %entry ]
  %gep1 = getelementptr inbounds i8, ptr @p1, i64 %index
  %ld1 = load i8, ptr %gep1, align 1
  %cond.a = icmp slt i8 %ld1, 0
  br i1 %cond.a, label %block.a, label %loop.latch

block.a:
  %gep2 = getelementptr inbounds i8, ptr @p2, i64 %index
  %ld2 = load i8, ptr %gep2, align 1
  %cmp.a = icmp eq i8 %ld1, %ld2
  br i1 %cmp.a, label %loop.end, label %block.b

block.b:
  %gep3 = getelementptr inbounds i8, ptr @p3, i64 %index
  %ld3 = load i8, ptr %gep3, align 1
  %cmp.b = icmp eq i8 %ld1, %ld3
  br i1 %cmp.b, label %loop.end, label %block.c

block.c:
  %gep4 = getelementptr inbounds i8, ptr @p4, i64 %index
  %ld4 = load i8, ptr %gep4, align 1
  %cmp.c = icmp eq i8 %ld1, %ld4
  br i1 %cmp.c, label %loop.end, label %loop.latch

loop.latch:
  %index.next = add i64 %index, 1
  %exitcond = icmp ne i64 %index.next, 64
  br i1 %exitcond, label %loop.header, label %loop.end

loop.end:
  %retval = phi i64 [ 1, %block.a ], [ 2, %block.b ], [ 3, %block.c ], [ 0, %loop.latch ]
  ret i64 %retval
}

define i64 @four_exits_2x2_diamond() {
; CHECK-LABEL: define i64 @four_exits_2x2_diamond() {
; CHECK-NEXT:  [[VECTOR_PH:.*]]:
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX1:%.*]] = phi i64 [ [[INDEX_NEXT:%.*]], %[[VECTOR_EARLY_EXIT_1:.*]] ], [ 0, %[[VECTOR_PH]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @p1, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD1:%.*]] = load i8, ptr [[TMP0]], align 1
; CHECK-NEXT:    [[TMP27:%.*]] = icmp slt i8 [[LD1]], 0
; CHECK-NEXT:    br i1 [[TMP27]], label %[[VECTOR_EARLY_EXIT_CHECK:.*]], label %[[VECTOR_BODY_INTERIM:.*]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK]]:
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i8, ptr @p2, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD2:%.*]] = load i8, ptr [[GEP2]], align 1
; CHECK-NEXT:    [[TMP29:%.*]] = icmp eq i8 [[LD1]], [[LD2]]
; CHECK-NEXT:    br i1 [[TMP29]], label %[[VECTOR_EARLY_EXIT_0:.*]], label %[[VECTOR_EARLY_EXIT_CHECK_0:.*]]
; CHECK:       [[VECTOR_BODY_INTERIM]]:
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr @p3, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD3:%.*]] = load i8, ptr [[GEP3]], align 1
; CHECK-NEXT:    [[CMP1B:%.*]] = icmp eq i8 [[LD1]], [[LD3]]
; CHECK-NEXT:    br i1 [[CMP1B]], label %[[VECTOR_EARLY_EXIT_0]], label %[[VECTOR_EARLY_EXIT_CHECK_0]]
; CHECK:       [[VECTOR_EARLY_EXIT_CHECK_0]]:
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i8, ptr @p4, i64 [[INDEX1]]
; CHECK-NEXT:    [[LD4:%.*]] = load i8, ptr [[GEP4]], align 1
; CHECK-NEXT:    [[TMP31:%.*]] = icmp slt i8 [[LD4]], 0
; CHECK-NEXT:    br i1 [[TMP31]], label %[[VECTOR_EARLY_EXIT_2:.*]], label %[[VECTOR_EARLY_EXIT_3:.*]]
; CHECK:       [[VECTOR_EARLY_EXIT_2]]:
; CHECK-NEXT:    [[CMP2A:%.*]] = icmp eq i8 [[LD1]], [[LD4]]
; CHECK-NEXT:    br i1 [[CMP2A]], label %[[VECTOR_EARLY_EXIT_0]], label %[[VECTOR_EARLY_EXIT_1]]
; CHECK:       [[VECTOR_EARLY_EXIT_3]]:
; CHECK-NEXT:    [[CMP2B:%.*]] = icmp ne i8 [[LD1]], [[LD4]]
; CHECK-NEXT:    br i1 [[CMP2B]], label %[[VECTOR_EARLY_EXIT_0]], label %[[VECTOR_EARLY_EXIT_1]]
; CHECK:       [[VECTOR_EARLY_EXIT_1]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX1]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDEX_NEXT]], 64
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[VECTOR_BODY]], label %[[VECTOR_EARLY_EXIT_0]]
; CHECK:       [[VECTOR_EARLY_EXIT_0]]:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i64 [ 1, %[[VECTOR_EARLY_EXIT_CHECK]] ], [ 2, %[[VECTOR_BODY_INTERIM]] ], [ 3, %[[VECTOR_EARLY_EXIT_2]] ], [ 4, %[[VECTOR_EARLY_EXIT_3]] ], [ 0, %[[VECTOR_EARLY_EXIT_1]] ]
; CHECK-NEXT:    ret i64 [[RETVAL]]
;
entry:
  br label %loop.header

loop.header:
  %index = phi i64 [ %index.next, %loop.latch ], [ 0, %entry ]
  %gep1 = getelementptr inbounds i8, ptr @p1, i64 %index
  %ld1 = load i8, ptr %gep1, align 1
  %cond1 = icmp slt i8 %ld1, 0
  br i1 %cond1, label %branch1.a, label %branch1.b

branch1.a:
  %gep2 = getelementptr inbounds i8, ptr @p2, i64 %index
  %ld2 = load i8, ptr %gep2, align 1
  %cmp1a = icmp eq i8 %ld1, %ld2
  br i1 %cmp1a, label %loop.end, label %branch2

branch1.b:
  %gep3 = getelementptr inbounds i8, ptr @p3, i64 %index
  %ld3 = load i8, ptr %gep3, align 1
  %cmp1b = icmp eq i8 %ld1, %ld3
  br i1 %cmp1b, label %loop.end, label %branch2

branch2:
  %gep4 = getelementptr inbounds i8, ptr @p4, i64 %index
  %ld4 = load i8, ptr %gep4, align 1
  %cond2 = icmp slt i8 %ld4, 0
  br i1 %cond2, label %branch2.a, label %branch2.b

branch2.a:
  %cmp2a = icmp eq i8 %ld1, %ld4
  br i1 %cmp2a, label %loop.end, label %loop.latch

branch2.b:
  %cmp2b = icmp ne i8 %ld1, %ld4
  br i1 %cmp2b, label %loop.end, label %loop.latch

loop.latch:
  %index.next = add i64 %index, 1
  %exitcond = icmp ne i64 %index.next, 64
  br i1 %exitcond, label %loop.header, label %loop.end

loop.end:
  %retval = phi i64 [ 1, %branch1.a ], [ 2, %branch1.b ], [ 3, %branch2.a ], [ 4, %branch2.b ], [ 0, %loop.latch ]
  ret i64 %retval
}
