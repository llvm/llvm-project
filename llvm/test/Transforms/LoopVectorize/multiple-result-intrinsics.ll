; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --filter "(:|sincos|frexp|modf|extract|store|with\.overflow)" --version 5
; RUN: opt -passes=loop-vectorize -force-vector-interleave=1 -force-vector-width=2 < %s -S -o - | FileCheck %s

define void @sincos_f32(ptr noalias %in, ptr noalias writeonly %out_a, ptr noalias writeonly %out_b) {
; CHECK-LABEL: define void @sincos_f32(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_A:%.*]], ptr noalias writeonly [[OUT_B:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[VECTOR_PH:.*:]]
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:    [[TMP3:%.*]] = call { <2 x float>, <2 x float> } @llvm.sincos.v2f32(<2 x float> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP4:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP3]], 0
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP3]], 1
; CHECK:    store <2 x float> [[TMP4]], ptr [[TMP7:%.*]], align 4
; CHECK:    store <2 x float> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %in, i64 %iv
  %in_val = load float, ptr %arrayidx, align 4
  %call = tail call { float, float } @llvm.sincos.f32(float %in_val)
  %extract_a = extractvalue { float, float } %call, 0
  %extract_b = extractvalue { float, float } %call, 1
  %arrayidx2 = getelementptr inbounds float, ptr %out_a, i64 %iv
  store float %extract_a, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds float, ptr %out_b, i64 %iv
  store float %extract_b, ptr %arrayidx4, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @sincos_f64(ptr noalias %in, ptr noalias writeonly %out_a, ptr noalias writeonly %out_b) {
; CHECK-LABEL: define void @sincos_f64(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_A:%.*]], ptr noalias writeonly [[OUT_B:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[VECTOR_PH:.*:]]
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:    [[TMP3:%.*]] = call { <2 x double>, <2 x double> } @llvm.sincos.v2f64(<2 x double> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP4:%.*]] = extractvalue { <2 x double>, <2 x double> } [[TMP3]], 0
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x double>, <2 x double> } [[TMP3]], 1
; CHECK:    store <2 x double> [[TMP4]], ptr [[TMP7:%.*]], align 8
; CHECK:    store <2 x double> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds double, ptr %in, i64 %iv
  %in_val = load double, ptr %arrayidx, align 8
  %call = tail call { double, double } @llvm.sincos.f64(double %in_val)
  %extract_a = extractvalue { double, double } %call, 0
  %extract_b = extractvalue { double, double } %call, 1
  %arrayidx2 = getelementptr inbounds double, ptr %out_a, i64 %iv
  store double %extract_a, ptr %arrayidx2, align 8
  %arrayidx4 = getelementptr inbounds double, ptr %out_b, i64 %iv
  store double %extract_b, ptr %arrayidx4, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @predicated_sincos(float %x, ptr noalias %in, ptr noalias writeonly %out_a, ptr noalias writeonly %out_b) {
; CHECK-LABEL: define void @predicated_sincos(
; CHECK-SAME: float [[X:%.*]], ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_A:%.*]], ptr noalias writeonly [[OUT_B:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[VECTOR_BODY:.*]]:
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_BODY]] ], [ [[INDEX_NEXT:%.*]], %[[IF_THEN1:.*]] ]
; CHECK:    [[TMP4:%.*]] = call { <2 x float>, <2 x float> } @llvm.sincos.v2f32(<2 x float> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP4]], 1
; CHECK:    [[TMP7:%.*]] = extractelement <2 x i1> [[TMP3:%.*]], i32 0
; CHECK:    br i1 [[TMP7]], label %[[PRED_STORE_IF:.*]], label %[[PRED_STORE_CONTINUE:.*]]
; CHECK:  [[PRED_STORE_IF]]:
; CHECK:    [[TMP9:%.*]] = extractelement <2 x float> [[TMP5]], i32 0
; CHECK:    store float [[TMP9]], ptr [[TMP8:%.*]], align 4
; CHECK:    [[TMP11:%.*]] = extractelement <2 x float> [[TMP6]], i32 0
; CHECK:    store float [[TMP11]], ptr [[TMP10:%.*]], align 4
; CHECK:    br label %[[PRED_STORE_CONTINUE]]
; CHECK:  [[PRED_STORE_CONTINUE]]:
; CHECK:    [[TMP12:%.*]] = extractelement <2 x i1> [[TMP3]], i32 1
; CHECK:    br i1 [[TMP12]], label %[[PRED_STORE_IF1:.*]], label %[[IF_THEN1]]
; CHECK:  [[PRED_STORE_IF1]]:
; CHECK:    [[TMP15:%.*]] = extractelement <2 x float> [[TMP5]], i32 1
; CHECK:    store float [[TMP15]], ptr [[TMP14:%.*]], align 4
; CHECK:    [[TMP17:%.*]] = extractelement <2 x float> [[TMP6]], i32 1
; CHECK:    store float [[TMP17]], ptr [[TMP16:%.*]], align 4
; CHECK:    br label %[[IF_THEN1]]
; CHECK:  [[IF_THEN1]]:
; CHECK:  [[IF_MERGE:.*:]]
; CHECK:  [[FOR_END:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ %iv.next, %if.merge ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds float, ptr %in, i64 %iv
  %in_val = load float, ptr %arrayidx, align 4
  %if_cond = fcmp olt float %in_val, %x
  br i1 %if_cond, label %if.then, label %if.merge

if.then:
  %call = tail call { float, float } @llvm.sincos.f32(float %in_val)
  %extract_a = extractvalue { float, float } %call, 0
  %extract_b = extractvalue { float, float } %call, 1
  %arrayidx2 = getelementptr inbounds float, ptr %out_a, i64 %iv
  store float %extract_a, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds float, ptr %out_b, i64 %iv
  store float %extract_b, ptr %arrayidx4, align 4
  br label %if.merge

if.merge:
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp slt i64 %iv.next, 1024
  br i1 %cond, label %for.body, label %for.end

for.end:
  ret void
}

define void @modf_f32(ptr noalias %in, ptr noalias writeonly %out_a, ptr noalias writeonly %out_b) {
; CHECK-LABEL: define void @modf_f32(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_A:%.*]], ptr noalias writeonly [[OUT_B:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[VECTOR_PH:.*:]]
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:    [[TMP3:%.*]] = call { <2 x float>, <2 x float> } @llvm.modf.v2f32(<2 x float> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP4:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP3]], 0
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP3]], 1
; CHECK:    store <2 x float> [[TMP4]], ptr [[TMP7:%.*]], align 4
; CHECK:    store <2 x float> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %in, i64 %iv
  %in_val = load float, ptr %arrayidx, align 4
  %call = tail call { float, float } @llvm.modf.f32(float %in_val)
  %extract_a = extractvalue { float, float } %call, 0
  %extract_b = extractvalue { float, float } %call, 1
  %arrayidx2 = getelementptr inbounds float, ptr %out_a, i64 %iv
  store float %extract_a, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds float, ptr %out_b, i64 %iv
  store float %extract_b, ptr %arrayidx4, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @modf_f64(ptr noalias %in, ptr noalias writeonly %out_a, ptr noalias writeonly %out_b) {
; CHECK-LABEL: define void @modf_f64(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_A:%.*]], ptr noalias writeonly [[OUT_B:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[VECTOR_PH:.*:]]
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:    [[TMP3:%.*]] = call { <2 x double>, <2 x double> } @llvm.modf.v2f64(<2 x double> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP4:%.*]] = extractvalue { <2 x double>, <2 x double> } [[TMP3]], 0
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x double>, <2 x double> } [[TMP3]], 1
; CHECK:    store <2 x double> [[TMP4]], ptr [[TMP7:%.*]], align 8
; CHECK:    store <2 x double> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds double, ptr %in, i64 %iv
  %in_val = load double, ptr %arrayidx, align 8
  %call = tail call { double, double } @llvm.modf.f64(double %in_val)
  %extract_a = extractvalue { double, double } %call, 0
  %extract_b = extractvalue { double, double } %call, 1
  %arrayidx2 = getelementptr inbounds double, ptr %out_a, i64 %iv
  store double %extract_a, ptr %arrayidx2, align 8
  %arrayidx4 = getelementptr inbounds double, ptr %out_b, i64 %iv
  store double %extract_b, ptr %arrayidx4, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @sincospi_f32(ptr noalias %in, ptr noalias writeonly %out_a, ptr noalias writeonly %out_b) {
; CHECK-LABEL: define void @sincospi_f32(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_A:%.*]], ptr noalias writeonly [[OUT_B:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[VECTOR_PH:.*:]]
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:    [[TMP3:%.*]] = call { <2 x float>, <2 x float> } @llvm.sincospi.v2f32(<2 x float> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP4:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP3]], 0
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x float>, <2 x float> } [[TMP3]], 1
; CHECK:    store <2 x float> [[TMP4]], ptr [[TMP7:%.*]], align 4
; CHECK:    store <2 x float> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %in, i64 %iv
  %in_val = load float, ptr %arrayidx, align 4
  %call = tail call { float, float } @llvm.sincospi.f32(float %in_val)
  %extract_a = extractvalue { float, float } %call, 0
  %extract_b = extractvalue { float, float } %call, 1
  %arrayidx2 = getelementptr inbounds float, ptr %out_a, i64 %iv
  store float %extract_a, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds float, ptr %out_b, i64 %iv
  store float %extract_b, ptr %arrayidx4, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @sincospi_f64(ptr noalias %in, ptr noalias writeonly %out_a, ptr noalias writeonly %out_b) {
; CHECK-LABEL: define void @sincospi_f64(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_A:%.*]], ptr noalias writeonly [[OUT_B:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[VECTOR_PH:.*:]]
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:    [[TMP3:%.*]] = call { <2 x double>, <2 x double> } @llvm.sincospi.v2f64(<2 x double> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP4:%.*]] = extractvalue { <2 x double>, <2 x double> } [[TMP3]], 0
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x double>, <2 x double> } [[TMP3]], 1
; CHECK:    store <2 x double> [[TMP4]], ptr [[TMP7:%.*]], align 8
; CHECK:    store <2 x double> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds double, ptr %in, i64 %iv
  %in_val = load double, ptr %arrayidx, align 8
  %call = tail call { double, double } @llvm.sincospi.f64(double %in_val)
  %extract_a = extractvalue { double, double } %call, 0
  %extract_b = extractvalue { double, double } %call, 1
  %arrayidx2 = getelementptr inbounds double, ptr %out_a, i64 %iv
  store double %extract_a, ptr %arrayidx2, align 8
  %arrayidx4 = getelementptr inbounds double, ptr %out_b, i64 %iv
  store double %extract_b, ptr %arrayidx4, align 8
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @frexp_f32(ptr noalias %in, ptr noalias writeonly %out_mantissa, ptr noalias writeonly %out_exponent) {
; CHECK-LABEL: define void @frexp_f32(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_MANTISSA:%.*]], ptr noalias writeonly [[OUT_EXPONENT:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
; CHECK:    [[TMP1:%.*]] = call { <2 x float>, <2 x i32> } @llvm.frexp.v2f32.v2i32(<2 x float> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP2:%.*]] = extractvalue { <2 x float>, <2 x i32> } [[TMP1]], 0
; CHECK:    [[TMP3:%.*]] = extractvalue { <2 x float>, <2 x i32> } [[TMP1]], 1
; CHECK:    store <2 x float> [[TMP2]], ptr [[TMP4:%.*]], align 4
; CHECK:    store <2 x i32> [[TMP3]], ptr [[TMP5:%.*]], align 4
; CHECK:  [[MIDDLE_BLOCK:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %in, i64 %iv
  %in_val = load float, ptr %arrayidx, align 4
  %call = tail call { float, i32 } @llvm.frexp.f32.i32(float %in_val)
  %mantissa = extractvalue { float, i32 } %call, 0
  %exponent = extractvalue { float, i32 } %call, 1
  %arrayidx2 = getelementptr inbounds float, ptr %out_mantissa, i64 %iv
  store float %mantissa, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, ptr %out_exponent, i64 %iv
  store i32 %exponent, ptr %arrayidx4, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @frexp_f64(ptr noalias %in, ptr noalias writeonly %out_mantissa, ptr noalias writeonly %out_exponent) {
; CHECK-LABEL: define void @frexp_f64(
; CHECK-SAME: ptr noalias [[IN:%.*]], ptr noalias writeonly [[OUT_MANTISSA:%.*]], ptr noalias writeonly [[OUT_EXPONENT:%.*]]) {
; CHECK:  [[ENTRY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[EXIT:.*:]]
; CHECK:    [[TMP1:%.*]] = call { <2 x double>, <2 x i32> } @llvm.frexp.v2f64.v2i32(<2 x double> [[WIDE_LOAD:%.*]])
; CHECK:    [[TMP2:%.*]] = extractvalue { <2 x double>, <2 x i32> } [[TMP1]], 0
; CHECK:    [[TMP3:%.*]] = extractvalue { <2 x double>, <2 x i32> } [[TMP1]], 1
; CHECK:    store <2 x double> [[TMP2]], ptr [[TMP4:%.*]], align 8
; CHECK:    store <2 x i32> [[TMP3]], ptr [[TMP5:%.*]], align 4
; CHECK:  [[MIDDLE_BLOCK:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx = getelementptr inbounds double, ptr %in, i64 %iv
  %in_val = load double, ptr %arrayidx, align 8
  %call = tail call { double, i32 } @llvm.frexp.f64.i32(double %in_val)
  %mantissa = extractvalue { double, i32 } %call, 0
  %exponent = extractvalue { double, i32 } %call, 1
  %arrayidx2 = getelementptr inbounds double, ptr %out_mantissa, i64 %iv
  store double %mantissa, ptr %arrayidx2, align 8
  %arrayidx4 = getelementptr inbounds i32, ptr %out_exponent, i64 %iv
  store i32 %exponent, ptr %arrayidx4, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @uadd_with_overflow_i32(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @uadd_with_overflow_i32(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i32>, <2 x i1> } @llvm.uadd.with.overflow.v2i32(<2 x i32> [[WIDE_LOAD:%.*]], <2 x i32> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i32> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i32, ptr %in_a, i64 %iv
  %val_a = load i32, ptr %arrayidx_a, align 4
  %arrayidx_b = getelementptr inbounds i32, ptr %in_b, i64 %iv
  %val_b = load i32, ptr %arrayidx_b, align 4
  %call = tail call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %val_a, i32 %val_b)
  %result = extractvalue { i32, i1 } %call, 0
  %overflow = extractvalue { i32, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i32, ptr %out_result, i64 %iv
  store i32 %result, ptr %arrayidx_result, align 4
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @uadd_with_overflow_i64(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @uadd_with_overflow_i64(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i64>, <2 x i1> } @llvm.uadd.with.overflow.v2i64(<2 x i64> [[WIDE_LOAD:%.*]], <2 x i64> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i64> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i64, ptr %in_a, i64 %iv
  %val_a = load i64, ptr %arrayidx_a, align 8
  %arrayidx_b = getelementptr inbounds i64, ptr %in_b, i64 %iv
  %val_b = load i64, ptr %arrayidx_b, align 8
  %call = tail call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %val_a, i64 %val_b)
  %result = extractvalue { i64, i1 } %call, 0
  %overflow = extractvalue { i64, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i64, ptr %out_result, i64 %iv
  store i64 %result, ptr %arrayidx_result, align 8
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @sadd_with_overflow_i32(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @sadd_with_overflow_i32(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i32>, <2 x i1> } @llvm.sadd.with.overflow.v2i32(<2 x i32> [[WIDE_LOAD:%.*]], <2 x i32> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i32> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i32, ptr %in_a, i64 %iv
  %val_a = load i32, ptr %arrayidx_a, align 4
  %arrayidx_b = getelementptr inbounds i32, ptr %in_b, i64 %iv
  %val_b = load i32, ptr %arrayidx_b, align 4
  %call = tail call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %val_a, i32 %val_b)
  %result = extractvalue { i32, i1 } %call, 0
  %overflow = extractvalue { i32, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i32, ptr %out_result, i64 %iv
  store i32 %result, ptr %arrayidx_result, align 4
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @sadd_with_overflow_i64(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @sadd_with_overflow_i64(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i64>, <2 x i1> } @llvm.sadd.with.overflow.v2i64(<2 x i64> [[WIDE_LOAD:%.*]], <2 x i64> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i64> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i64, ptr %in_a, i64 %iv
  %val_a = load i64, ptr %arrayidx_a, align 8
  %arrayidx_b = getelementptr inbounds i64, ptr %in_b, i64 %iv
  %val_b = load i64, ptr %arrayidx_b, align 8
  %call = tail call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %val_a, i64 %val_b)
  %result = extractvalue { i64, i1 } %call, 0
  %overflow = extractvalue { i64, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i64, ptr %out_result, i64 %iv
  store i64 %result, ptr %arrayidx_result, align 8
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @usub_with_overflow_i32(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @usub_with_overflow_i32(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i32>, <2 x i1> } @llvm.usub.with.overflow.v2i32(<2 x i32> [[WIDE_LOAD:%.*]], <2 x i32> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i32> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i32, ptr %in_a, i64 %iv
  %val_a = load i32, ptr %arrayidx_a, align 4
  %arrayidx_b = getelementptr inbounds i32, ptr %in_b, i64 %iv
  %val_b = load i32, ptr %arrayidx_b, align 4
  %call = tail call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %val_a, i32 %val_b)
  %result = extractvalue { i32, i1 } %call, 0
  %overflow = extractvalue { i32, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i32, ptr %out_result, i64 %iv
  store i32 %result, ptr %arrayidx_result, align 4
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @usub_with_overflow_i64(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @usub_with_overflow_i64(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i64>, <2 x i1> } @llvm.usub.with.overflow.v2i64(<2 x i64> [[WIDE_LOAD:%.*]], <2 x i64> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i64> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i64, ptr %in_a, i64 %iv
  %val_a = load i64, ptr %arrayidx_a, align 8
  %arrayidx_b = getelementptr inbounds i64, ptr %in_b, i64 %iv
  %val_b = load i64, ptr %arrayidx_b, align 8
  %call = tail call { i64, i1 } @llvm.usub.with.overflow.i64(i64 %val_a, i64 %val_b)
  %result = extractvalue { i64, i1 } %call, 0
  %overflow = extractvalue { i64, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i64, ptr %out_result, i64 %iv
  store i64 %result, ptr %arrayidx_result, align 8
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @ssub_with_overflow_i32(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @ssub_with_overflow_i32(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i32>, <2 x i1> } @llvm.ssub.with.overflow.v2i32(<2 x i32> [[WIDE_LOAD:%.*]], <2 x i32> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i32> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i32, ptr %in_a, i64 %iv
  %val_a = load i32, ptr %arrayidx_a, align 4
  %arrayidx_b = getelementptr inbounds i32, ptr %in_b, i64 %iv
  %val_b = load i32, ptr %arrayidx_b, align 4
  %call = tail call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 %val_a, i32 %val_b)
  %result = extractvalue { i32, i1 } %call, 0
  %overflow = extractvalue { i32, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i32, ptr %out_result, i64 %iv
  store i32 %result, ptr %arrayidx_result, align 4
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @ssub_with_overflow_i64(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @ssub_with_overflow_i64(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i64>, <2 x i1> } @llvm.ssub.with.overflow.v2i64(<2 x i64> [[WIDE_LOAD:%.*]], <2 x i64> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i64> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i64, ptr %in_a, i64 %iv
  %val_a = load i64, ptr %arrayidx_a, align 8
  %arrayidx_b = getelementptr inbounds i64, ptr %in_b, i64 %iv
  %val_b = load i64, ptr %arrayidx_b, align 8
  %call = tail call { i64, i1 } @llvm.ssub.with.overflow.i64(i64 %val_a, i64 %val_b)
  %result = extractvalue { i64, i1 } %call, 0
  %overflow = extractvalue { i64, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i64, ptr %out_result, i64 %iv
  store i64 %result, ptr %arrayidx_result, align 8
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @umul_with_overflow_i32(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @umul_with_overflow_i32(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i32>, <2 x i1> } @llvm.umul.with.overflow.v2i32(<2 x i32> [[WIDE_LOAD:%.*]], <2 x i32> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i32> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i32, ptr %in_a, i64 %iv
  %val_a = load i32, ptr %arrayidx_a, align 4
  %arrayidx_b = getelementptr inbounds i32, ptr %in_b, i64 %iv
  %val_b = load i32, ptr %arrayidx_b, align 4
  %call = tail call { i32, i1 } @llvm.umul.with.overflow.i32(i32 %val_a, i32 %val_b)
  %result = extractvalue { i32, i1 } %call, 0
  %overflow = extractvalue { i32, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i32, ptr %out_result, i64 %iv
  store i32 %result, ptr %arrayidx_result, align 4
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @umul_with_overflow_i64(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @umul_with_overflow_i64(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i64>, <2 x i1> } @llvm.umul.with.overflow.v2i64(<2 x i64> [[WIDE_LOAD:%.*]], <2 x i64> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i64> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i64, ptr %in_a, i64 %iv
  %val_a = load i64, ptr %arrayidx_a, align 8
  %arrayidx_b = getelementptr inbounds i64, ptr %in_b, i64 %iv
  %val_b = load i64, ptr %arrayidx_b, align 8
  %call = tail call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %val_a, i64 %val_b)
  %result = extractvalue { i64, i1 } %call, 0
  %overflow = extractvalue { i64, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i64, ptr %out_result, i64 %iv
  store i64 %result, ptr %arrayidx_result, align 8
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @smul_with_overflow_i32(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @smul_with_overflow_i32(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i32>, <2 x i1> } @llvm.smul.with.overflow.v2i32(<2 x i32> [[WIDE_LOAD:%.*]], <2 x i32> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i32>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i32> [[TMP5]], ptr [[TMP9:%.*]], align 4
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i32, ptr %in_a, i64 %iv
  %val_a = load i32, ptr %arrayidx_a, align 4
  %arrayidx_b = getelementptr inbounds i32, ptr %in_b, i64 %iv
  %val_b = load i32, ptr %arrayidx_b, align 4
  %call = tail call { i32, i1 } @llvm.smul.with.overflow.i32(i32 %val_a, i32 %val_b)
  %result = extractvalue { i32, i1 } %call, 0
  %overflow = extractvalue { i32, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i32, ptr %out_result, i64 %iv
  store i32 %result, ptr %arrayidx_result, align 4
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}

define void @smul_with_overflow_i64(ptr noalias %in_a, ptr noalias %in_b, ptr noalias writeonly %out_result, ptr noalias writeonly %out_overflow) {
; CHECK-LABEL: define void @smul_with_overflow_i64(
; CHECK-SAME: ptr noalias [[IN_A:%.*]], ptr noalias [[IN_B:%.*]], ptr noalias writeonly [[OUT_RESULT:%.*]], ptr noalias writeonly [[OUT_OVERFLOW:%.*]]) {
; CHECK:  [[VECTOR_BODY:.*:]]
; CHECK:  [[FOR_BODY:.*:]]
; CHECK:  [[VECTOR_BODY1:.*:]]
; CHECK:    [[TMP4:%.*]] = call { <2 x i64>, <2 x i1> } @llvm.smul.with.overflow.v2i64(<2 x i64> [[WIDE_LOAD:%.*]], <2 x i64> [[WIDE_LOAD1:%.*]])
; CHECK:    [[TMP5:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 0
; CHECK:    [[TMP6:%.*]] = extractvalue { <2 x i64>, <2 x i1> } [[TMP4]], 1
; CHECK:    store <2 x i64> [[TMP5]], ptr [[TMP9:%.*]], align 8
; CHECK:    store <2 x i8> [[TMP8:%.*]], ptr [[TMP7:%.*]], align 1
; CHECK:  [[EXIT:.*:]]
; CHECK:  [[EXIT1:.*:]]
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %arrayidx_a = getelementptr inbounds i64, ptr %in_a, i64 %iv
  %val_a = load i64, ptr %arrayidx_a, align 8
  %arrayidx_b = getelementptr inbounds i64, ptr %in_b, i64 %iv
  %val_b = load i64, ptr %arrayidx_b, align 8
  %call = tail call { i64, i1 } @llvm.smul.with.overflow.i64(i64 %val_a, i64 %val_b)
  %result = extractvalue { i64, i1 } %call, 0
  %overflow = extractvalue { i64, i1 } %call, 1
  %zext_overflow = zext i1 %overflow to i8
  %arrayidx_result = getelementptr inbounds i64, ptr %out_result, i64 %iv
  store i64 %result, ptr %arrayidx_result, align 8
  %arrayidx_overflow = getelementptr inbounds i8, ptr %out_overflow, i64 %iv
  store i8 %zext_overflow, ptr %arrayidx_overflow, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  ret void
}
