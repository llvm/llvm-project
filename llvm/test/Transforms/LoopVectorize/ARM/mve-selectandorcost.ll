; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -loop-vectorize -instcombine -simplifycfg < %s -S -o - | FileCheck %s --check-prefix=CHECK
; RUN: opt -loop-vectorize -debug-only=loop-vectorize -disable-output < %s 2>&1 | FileCheck %s --check-prefix=CHECK-COST
; REQUIRES: asserts

target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "thumbv8.1m.main-arm-none-eabi"

; CHECK-COST-LABEL: test
; CHECK-COST: LV: Found an estimated cost of 1 for VF 1 For instruction:   %or.cond = select i1 %cmp2, i1 true, i1 %cmp3
; CHECK-COST: LV: Found an estimated cost of 20 for VF 2 For instruction:   %or.cond = select i1 %cmp2, i1 true, i1 %cmp3
; CHECK-COST: LV: Found an estimated cost of 40 for VF 4 For instruction:   %or.cond = select i1 %cmp2, i1 true, i1 %cmp3

define float @test(float* nocapture readonly %pA, float* nocapture readonly %pB, i32 %blockSize) #0 {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT16:%.*]] = icmp eq i32 [[BLOCKSIZE:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP_NOT16]], label [[WHILE_END:%.*]], label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[PA_ADDR_020:%.*]] = phi float* [ [[INCDEC_PTR:%.*]], [[IF_END:%.*]] ], [ [[PA:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[PB_ADDR_019:%.*]] = phi float* [ [[INCDEC_PTR1:%.*]], [[IF_END]] ], [ [[PB:%.*]], [[ENTRY]] ]
; CHECK-NEXT:    [[BLOCKSIZE_ADDR_018:%.*]] = phi i32 [ [[DEC:%.*]], [[IF_END]] ], [ [[BLOCKSIZE]], [[ENTRY]] ]
; CHECK-NEXT:    [[ACCUM_017:%.*]] = phi float [ [[ACCUM_1:%.*]], [[IF_END]] ], [ 0.000000e+00, [[ENTRY]] ]
; CHECK-NEXT:    [[INCDEC_PTR]] = getelementptr inbounds float, float* [[PA_ADDR_020]], i32 1
; CHECK-NEXT:    [[TMP0:%.*]] = load float, float* [[PA_ADDR_020]], align 4
; CHECK-NEXT:    [[INCDEC_PTR1]] = getelementptr inbounds float, float* [[PB_ADDR_019]], i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = load float, float* [[PB_ADDR_019]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast une float [[TMP0]], 0.000000e+00
; CHECK-NEXT:    [[CMP3:%.*]] = fcmp fast une float [[TMP1]], 0.000000e+00
; CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[CMP2]], i1 true, i1 [[CMP3]]
; CHECK-NEXT:    br i1 [[OR_COND]], label [[IF_THEN:%.*]], label [[IF_END]]
; CHECK:       if.then:
; CHECK-NEXT:    [[TMP2:%.*]] = tail call fast float @llvm.fabs.f32(float [[TMP0]])
; CHECK-NEXT:    [[TMP3:%.*]] = tail call fast float @llvm.fabs.f32(float [[TMP1]])
; CHECK-NEXT:    [[ADD:%.*]] = fadd fast float [[TMP3]], [[TMP2]]
; CHECK-NEXT:    [[SUB:%.*]] = fsub fast float [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = tail call fast float @llvm.fabs.f32(float [[SUB]])
; CHECK-NEXT:    [[DIV:%.*]] = fdiv fast float [[TMP4]], [[ADD]]
; CHECK-NEXT:    [[ADD4:%.*]] = fadd fast float [[DIV]], [[ACCUM_017]]
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[ACCUM_1]] = phi float [ [[ADD4]], [[IF_THEN]] ], [ [[ACCUM_017]], [[WHILE_BODY]] ]
; CHECK-NEXT:    [[DEC]] = add i32 [[BLOCKSIZE_ADDR_018]], -1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[DEC]], 0
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[WHILE_END]], label [[WHILE_BODY]]
; CHECK:       while.end:
; CHECK-NEXT:    [[ACCUM_0_LCSSA:%.*]] = phi float [ 0.000000e+00, [[ENTRY]] ], [ [[ACCUM_1]], [[IF_END]] ]
; CHECK-NEXT:    ret float [[ACCUM_0_LCSSA]]
;
entry:
  %cmp.not16 = icmp eq i32 %blockSize, 0
  br i1 %cmp.not16, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %pA.addr.020 = phi float* [ %incdec.ptr, %if.end ], [ %pA, %entry ]
  %pB.addr.019 = phi float* [ %incdec.ptr1, %if.end ], [ %pB, %entry ]
  %blockSize.addr.018 = phi i32 [ %dec, %if.end ], [ %blockSize, %entry ]
  %accum.017 = phi float [ %accum.1, %if.end ], [ 0.000000e+00, %entry ]
  %incdec.ptr = getelementptr inbounds float, float* %pA.addr.020, i32 1
  %0 = load float, float* %pA.addr.020, align 4
  %incdec.ptr1 = getelementptr inbounds float, float* %pB.addr.019, i32 1
  %1 = load float, float* %pB.addr.019, align 4
  %cmp2 = fcmp fast une float %0, 0.000000e+00
  %cmp3 = fcmp fast une float %1, 0.000000e+00
  %or.cond = select i1 %cmp2, i1 true, i1 %cmp3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %2 = tail call fast float @llvm.fabs.f32(float %0)
  %3 = tail call fast float @llvm.fabs.f32(float %1)
  %add = fadd fast float %3, %2
  %sub = fsub fast float %0, %1
  %4 = tail call fast float @llvm.fabs.f32(float %sub)
  %div = fdiv fast float %4, %add
  %add4 = fadd fast float %div, %accum.017
  br label %if.end

if.end:                                           ; preds = %while.body, %if.then
  %accum.1 = phi float [ %add4, %if.then ], [ %accum.017, %while.body ]
  %dec = add i32 %blockSize.addr.018, -1
  %cmp.not = icmp eq i32 %dec, 0
  br i1 %cmp.not, label %while.end, label %while.body

while.end:                                        ; preds = %if.end, %entry
  %accum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %accum.1, %if.end ]
  ret float %accum.0.lcssa
}

declare float @llvm.fabs.f32(float)

attributes #0 = { "target-features"="+mve.fp" }
