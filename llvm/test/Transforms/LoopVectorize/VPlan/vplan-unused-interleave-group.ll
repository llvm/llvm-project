; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=loop-vectorize -S -force-vector-width=4 -enable-interleaved-mem-accesses=true -debug-only=loop-vectorize --disable-output < %s 2>&1 | FileCheck %s

; This test checks if an unused interleave group is removed by removeDeadRecipes.

%struct.foo = type { ptr, ptr }

define void @test_unused_interleave(ptr %src, i32 %length) {
; CHECK-LABEL: 'test_unused_interleave'
; CHECK:  VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<%length> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP2:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP2]]>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP1]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<%length>, vp<[[VP1]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<for.end>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<for.end>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<%bc.resume.val> = phi [ vp<[[VP1]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<for.body>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<for.body>:
; CHECK-NEXT:    IR   %iv = phi i32 [ %iv.next, %for.body ], [ 0, %entry ] (extra operand: vp<%bc.resume.val> from scalar.ph)
; CHECK-NEXT:    IR   %next19.i.i = getelementptr inbounds %struct.foo, ptr %src, i32 %iv, i32 0
; CHECK-NEXT:    IR   %load_p1 = load ptr, ptr %next19.i.i, align 4
; CHECK-NEXT:    IR   %arrayidx15.i.i1427 = getelementptr inbounds %struct.foo, ptr %src, i32 %iv
; CHECK-NEXT:    IR   %val.i.i = getelementptr inbounds %struct.foo, ptr %arrayidx15.i.i1427, i32 0, i32 1
; CHECK-NEXT:    IR   %load_p2 = load ptr, ptr %val.i.i, align 4
; CHECK-NEXT:    IR   %iv.next = add nuw nsw i32 %iv, 1
; CHECK-NEXT:    IR   %cond = icmp eq i32 %iv.next, %length
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %for.body

for.body:
  %iv = phi i32 [ %iv.next, %for.body ], [ 0, %entry ]
  %next19.i.i = getelementptr inbounds %struct.foo, ptr %src, i32 %iv, i32 0
  %load_p1 = load ptr, ptr %next19.i.i, align 4
  %arrayidx15.i.i1427 = getelementptr inbounds %struct.foo, ptr %src, i32 %iv
  %val.i.i = getelementptr inbounds %struct.foo, ptr %arrayidx15.i.i1427, i32 0, i32 1
  %load_p2 = load ptr, ptr %val.i.i, align 4
  %iv.next = add nuw nsw i32 %iv, 1
  %cond = icmp eq i32 %iv.next, %length
  br i1 %cond, label %for.end, label %for.body

for.end:
  ret void
}
