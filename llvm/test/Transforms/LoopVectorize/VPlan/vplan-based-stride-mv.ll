; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -p loop-vectorize -force-vector-width=4 -disable-output \
; RUN:     -vplan-print-after=scalarizeMemOpsWithIrregularTypes \
; RUN:     -enable-mem-access-versioning=false 2>&1 | FileCheck %s

define void @basic(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'basic'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_gep_scaled_stride(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'byte_gep_scaled_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%stride.x8> = mul ir<%stride>, ir<8>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride.x8>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %stride.x8 = mul i64 %stride, 8
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride.x8
; CHECK-NEXT:    IR   %gep.ld = getelementptr i8, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %stride.x8 = mul i64 %stride, 8
  %idx = mul i64 %iv, %stride.x8

  %gep.ld = getelementptr i8, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_gep_under_scaled_stride(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'byte_gep_under_scaled_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%stride.x8> = mul ir<%stride>, ir<4>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride.x8>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %stride.x8 = mul i64 %stride, 4
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride.x8
; CHECK-NEXT:    IR   %gep.ld = getelementptr i8, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %stride.x8 = mul i64 %stride, 4
  %idx = mul i64 %iv, %stride.x8

  %gep.ld = getelementptr i8, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_gep_over_scaled_stride(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'byte_gep_over_scaled_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%stride.x8> = mul ir<%stride>, ir<16>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride.x8>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %stride.x8 = mul i64 %stride, 16
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride.x8
; CHECK-NEXT:    IR   %gep.ld = getelementptr i8, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %stride.x8 = mul i64 %stride, 16
  %idx = mul i64 %iv, %stride.x8

  %gep.ld = getelementptr i8, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_gep_non_power_of_two_scaled_stride(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'byte_gep_non_power_of_two_scaled_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%stride.x8> = mul ir<%stride>, ir<11>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride.x8>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %stride.x8 = mul i64 %stride, 11
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride.x8
; CHECK-NEXT:    IR   %gep.ld = getelementptr i8, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %stride.x8 = mul i64 %stride, 11
  %idx = mul i64 %iv, %stride.x8

  %gep.ld = getelementptr i8, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_gep_nonscaled_stride(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'byte_gep_nonscaled_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i8, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i8, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_gep_negated_stride(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'byte_gep_negated_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%stride.neg> = sub ir<0>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride.neg>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %stride.neg = sub i64 0, %stride
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride.neg
; CHECK-NEXT:    IR   %gep.ld = getelementptr i8, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %stride.neg = sub i64 0, %stride
  %idx = mul i64 %iv, %stride.neg

  %gep.ld = getelementptr i8, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @shared_stride(ptr noalias %p.out, ptr %p0, ptr %p1, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'shared_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld0> = getelementptr ir<%p0>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%gep.ld1> = getelementptr ir<%p1>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld0> = load ir<%gep.ld0>
; CHECK-NEXT:      EMIT ir<%ld1> = load ir<%gep.ld1>
; CHECK-NEXT:      EMIT ir<%val> = add ir<%ld0>, ir<%ld1>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%val>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld0 = getelementptr i64, ptr %p0, i64 %idx
; CHECK-NEXT:    IR   %gep.ld1 = getelementptr i64, ptr %p1, i64 %idx
; CHECK-NEXT:    IR   %ld0 = load i64, ptr %gep.ld0, align 8
; CHECK-NEXT:    IR   %ld1 = load i64, ptr %gep.ld1, align 8
; CHECK-NEXT:    IR   %val = add i64 %ld0, %ld1
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %val, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld0 = getelementptr i64, ptr %p0, i64 %idx
  %gep.ld1 = getelementptr i64, ptr %p1, i64 %idx
  %ld0 = load i64, ptr %gep.ld0, align 8
  %ld1 = load i64, ptr %gep.ld1, align 8
  %val = add i64 %ld0, %ld1

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %val, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @dependent_strides(ptr noalias %p.out, ptr %p0, ptr %p1, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'dependent_strides'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%stride1> = add ir<%stride>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx0> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%idx1> = mul ir<%iv>, ir<%stride1>
; CHECK-NEXT:      EMIT ir<%gep.ld0> = getelementptr ir<%p0>, ir<%idx0>
; CHECK-NEXT:      EMIT ir<%gep.ld1> = getelementptr ir<%p1>, ir<%idx1>
; CHECK-NEXT:      EMIT ir<%ld0> = load ir<%gep.ld0>
; CHECK-NEXT:      EMIT ir<%ld1> = load ir<%gep.ld1>
; CHECK-NEXT:      EMIT ir<%val> = add ir<%ld0>, ir<%ld1>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%val>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %stride1 = add i64 %stride, 1
; CHECK-NEXT:    IR   %idx0 = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %idx1 = mul i64 %iv, %stride1
; CHECK-NEXT:    IR   %gep.ld0 = getelementptr i64, ptr %p0, i64 %idx0
; CHECK-NEXT:    IR   %gep.ld1 = getelementptr i64, ptr %p1, i64 %idx1
; CHECK-NEXT:    IR   %ld0 = load i64, ptr %gep.ld0, align 8
; CHECK-NEXT:    IR   %ld1 = load i64, ptr %gep.ld1, align 8
; CHECK-NEXT:    IR   %val = add i64 %ld0, %ld1
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %val, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %stride1 = add i64 %stride, 1
  %idx0 = mul i64 %iv, %stride
  %idx1 = mul i64 %iv, %stride1

  %gep.ld0 = getelementptr i64, ptr %p0, i64 %idx0
  %gep.ld1 = getelementptr i64, ptr %p1, i64 %idx1
  %ld0 = load i64, ptr %gep.ld0, align 8
  %ld1 = load i64, ptr %gep.ld1, align 8
  %val = add i64 %ld0, %ld1

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %val, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @dependent_strides_reverse_order(ptr noalias %p.out, ptr %p0, ptr %p1, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'dependent_strides_reverse_order'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%stride0> = add ir<%stride>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx0> = mul ir<%iv>, ir<%stride0>
; CHECK-NEXT:      EMIT ir<%idx1> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld0> = getelementptr ir<%p0>, ir<%idx0>
; CHECK-NEXT:      EMIT ir<%gep.ld1> = getelementptr ir<%p1>, ir<%idx1>
; CHECK-NEXT:      EMIT ir<%ld0> = load ir<%gep.ld0>
; CHECK-NEXT:      EMIT ir<%ld1> = load ir<%gep.ld1>
; CHECK-NEXT:      EMIT ir<%val> = add ir<%ld0>, ir<%ld1>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%val>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %stride0 = add i64 %stride, 1
; CHECK-NEXT:    IR   %idx0 = mul i64 %iv, %stride0
; CHECK-NEXT:    IR   %idx1 = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld0 = getelementptr i64, ptr %p0, i64 %idx0
; CHECK-NEXT:    IR   %gep.ld1 = getelementptr i64, ptr %p1, i64 %idx1
; CHECK-NEXT:    IR   %ld0 = load i64, ptr %gep.ld0, align 8
; CHECK-NEXT:    IR   %ld1 = load i64, ptr %gep.ld1, align 8
; CHECK-NEXT:    IR   %val = add i64 %ld0, %ld1
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %val, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %stride0 = add i64 %stride, 1
  %idx0 = mul i64 %iv, %stride0
  %idx1 = mul i64 %iv, %stride

  %gep.ld0 = getelementptr i64, ptr %p0, i64 %idx0
  %gep.ld1 = getelementptr i64, ptr %p1, i64 %idx1
  %ld0 = load i64, ptr %gep.ld0, align 8
  %ld1 = load i64, ptr %gep.ld1, align 8
  %val = add i64 %ld0, %ld1

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %val, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_dependent_byte_geps(ptr noalias %p.out, ptr %p0, ptr %p1, i64 %stride) {
;
; CHECK-LABEL: VPlan for loop in 'byte_dependent_byte_geps'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld0> = getelementptr ir<%p0>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld0> = load ir<%gep.ld0>
; CHECK-NEXT:      EMIT ir<%gep.ld1> = getelementptr ir<%p1>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld1> = load ir<%gep.ld1>
; CHECK-NEXT:      EMIT-SCALAR ir<%ld1.ext> = sext ir<%ld1> to i64
; CHECK-NEXT:      EMIT ir<%val> = add ir<%ld0>, ir<%ld1.ext>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%val>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld0 = getelementptr i8, ptr %p0, i64 %idx
; CHECK-NEXT:    IR   %ld0 = load i64, ptr %gep.ld0, align 8
; CHECK-NEXT:    IR   %gep.ld1 = getelementptr i8, ptr %p1, i64 %idx
; CHECK-NEXT:    IR   %ld1 = load i32, ptr %gep.ld1, align 8
; CHECK-NEXT:    IR   %ld1.ext = sext i32 %ld1 to i64
; CHECK-NEXT:    IR   %val = add i64 %ld0, %ld1.ext
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %val, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld0 = getelementptr i8, ptr %p0, i64 %idx
  %ld0 = load i64, ptr %gep.ld0, align 8

  %gep.ld1 = getelementptr i8, ptr %p1, i64 %idx
  %ld1 = load i32, ptr %gep.ld1, align 8
  %ld1.ext = sext i32 %ld1 to i64

  %val = add i64 %ld0, %ld1.ext

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %val, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @byte_dependent_byte_geps_reverse_order(ptr noalias %p.out, ptr %p0, ptr %p1, i64 %stride) {
;
; CHECK-LABEL: VPlan for loop in 'byte_dependent_byte_geps_reverse_order'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld1> = getelementptr ir<%p1>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld1> = load ir<%gep.ld1>
; CHECK-NEXT:      EMIT-SCALAR ir<%ld1.ext> = sext ir<%ld1> to i64
; CHECK-NEXT:      EMIT ir<%gep.ld0> = getelementptr ir<%p0>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld0> = load ir<%gep.ld0>
; CHECK-NEXT:      EMIT ir<%val> = add ir<%ld0>, ir<%ld1.ext>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%val>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld1 = getelementptr i8, ptr %p1, i64 %idx
; CHECK-NEXT:    IR   %ld1 = load i32, ptr %gep.ld1, align 8
; CHECK-NEXT:    IR   %ld1.ext = sext i32 %ld1 to i64
; CHECK-NEXT:    IR   %gep.ld0 = getelementptr i8, ptr %p0, i64 %idx
; CHECK-NEXT:    IR   %ld0 = load i64, ptr %gep.ld0, align 8
; CHECK-NEXT:    IR   %val = add i64 %ld0, %ld1.ext
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %val, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld1 = getelementptr i8, ptr %p1, i64 %idx
  %ld1 = load i32, ptr %gep.ld1, align 8
  %ld1.ext = sext i32 %ld1 to i64

  %gep.ld0 = getelementptr i8, ptr %p0, i64 %idx
  %ld0 = load i64, ptr %gep.ld0, align 8

  %val = add i64 %ld0, %ld1.ext

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %val, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}


define void @strided_interleave(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'strided_interleave'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld0> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%gep.ld1> = getelementptr ir<%gep.ld0>, ir<1>
; CHECK-NEXT:      EMIT ir<%ld0> = load ir<%gep.ld0>
; CHECK-NEXT:      EMIT ir<%ld1> = load ir<%gep.ld1>
; CHECK-NEXT:      EMIT ir<%val> = add ir<%ld0>, ir<%ld1>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%val>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld0 = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %gep.ld1 = getelementptr i64, ptr %gep.ld0, i61 1
; CHECK-NEXT:    IR   %ld0 = load i64, ptr %gep.ld0, align 8
; CHECK-NEXT:    IR   %ld1 = load i64, ptr %gep.ld1, align 8
; CHECK-NEXT:    IR   %val = add i64 %ld0, %ld1
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %val, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld0 = getelementptr i64, ptr %p, i64 %idx
  %gep.ld1 = getelementptr i64, ptr %gep.ld0, i61 1
  %ld0 = load i64, ptr %gep.ld0, align 8
  %ld1 = load i64, ptr %gep.ld1, align 8
  %val = add i64 %ld0, %ld1

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %val, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @in_loop_base(ptr noalias %p.out, ptr %p, i64 %stride, i64 %offset) {
; CHECK-LABEL: VPlan for loop in 'in_loop_base'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%iv.sdiv32> = sdiv ir<%iv>, ir<32>
; CHECK-NEXT:      EMIT ir<%mul> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%idx> = add ir<%mul>, ir<%offset>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %iv.sdiv32 = sdiv i64 %iv, 32
; CHECK-NEXT:    IR   %mul = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %idx = add i64 %mul, %offset
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %iv.sdiv32 = sdiv i64 %iv, 32

  %mul = mul i64 %iv, %stride
  %idx = add i64 %mul, %offset

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @non_invariant_uniform_base(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'non_invariant_uniform_base'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%iv.sdiv32> = sdiv ir<%iv>, ir<32>
; CHECK-NEXT:      EMIT ir<%mul> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%idx> = add ir<%mul>, ir<%iv.sdiv32>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %iv.sdiv32 = sdiv i64 %iv, 32
; CHECK-NEXT:    IR   %mul = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %idx = add i64 %mul, %iv.sdiv32
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %iv.sdiv32 = sdiv i64 %iv, 32

  %mul = mul i64 %iv, %stride
  %idx = add i64 %mul, %iv.sdiv32

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @non_invariant_uniform_stride(ptr noalias %p.out, ptr %p, ptr %p.uni) {
; CHECK-LABEL: VPlan for loop in 'non_invariant_uniform_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%iv.sdiv32> = sdiv ir<%iv>, ir<32>
; CHECK-NEXT:      EMIT ir<%gep.uni> = getelementptr ir<%p.uni>, ir<%iv.sdiv32>
; CHECK-NEXT:      EMIT ir<%stride> = load ir<%gep.uni>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %iv.sdiv32 = sdiv i64 %iv, 32
; CHECK-NEXT:    IR   %gep.uni = getelementptr i64, ptr %p.uni, i64 %iv.sdiv32
; CHECK-NEXT:    IR   %stride = load i64, ptr %gep.uni, align 4
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %iv.sdiv32 = sdiv i64 %iv, 32

  %gep.uni = getelementptr i64, ptr %p.uni, i64 %iv.sdiv32
  %stride = load i64, ptr %gep.uni

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

; Not valuable by itself, but as a basis for the subsequent test to ensure that
; non-constant trip count doesn't change anything by itself.
define void @non_constant_btc(ptr noalias %p.out, ptr %p, i64 %stride, i64 %n) {
; CHECK-LABEL: VPlan for loop in 'non_constant_btc'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  vp<[[VP3:%[0-9]+]]> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:    EMIT vp<[[VP3]]> = EXPAND SCEV (1 smax %n)
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<%n>
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP4]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq vp<[[VP3]]>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP8:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP8]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, %n
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, %n
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @stride_as_btc(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'stride_as_btc'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  vp<[[VP3:%[0-9]+]]> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:    EMIT vp<[[VP3]]> = EXPAND SCEV (1 smax %stride)
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<%stride>
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP4]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq vp<[[VP3]]>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP8:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP8]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, %stride
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, %stride
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @stride_dependent_btc(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'stride_dependent_btc'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  vp<[[VP3:%[0-9]+]]> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:    IR   %n = add i64 %stride, 1
; CHECK-NEXT:    EMIT vp<[[VP3]]> = EXPAND SCEV (1 smax (1 + %stride))
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<%n>
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP4]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq vp<[[VP3]]>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP8:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP8]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, %n
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  %n = add i64 %stride, 1
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, %n
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @actual_stride_not_in_ir(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'actual_stride_not_in_ir'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%base> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%base>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %base = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %base, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %base = getelementptr i64, ptr %p, i64 %idx
  %gep.ld = getelementptr i64, ptr %base, i64 %idx

  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @nd_array_last_idx(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'nd_array_last_idx'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<1>, ir<42>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr [256 x [256 x i64]], ptr %p, i64 1, i64 42, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr [256 x [256 x i64]], ptr %p, i64 1, i64 42, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @nd_array_non_last_idx(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'nd_array_non_last_idx'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<1>, ir<%idx>, ir<42>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr [256 x [256 x i64]], ptr %p, i64 1, i64 %idx, i64 42
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr [256 x [256 x i64]], ptr %p, i64 1, i64 %idx, i64 42
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @nd_array_multiple_idxs(ptr noalias %p.out, ptr %p, i64 %stride) {
; CHECK-LABEL: VPlan for loop in 'nd_array_multiple_idxs'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<1>, ir<%idx>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr [256 x [256 x i64]], ptr %p, i64 1, i64 %idx, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr [256 x [256 x i64]], ptr %p, i64 1, i64 %idx, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @sext_stride(ptr noalias %p.out, ptr %p, i32 %stride.i32) {
; CHECK-LABEL: VPlan for loop in 'sext_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT-SCALAR ir<%stride> = sext ir<%stride.i32> to i64
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %stride = sext i32 %stride.i32 to i64
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i64 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i64, ptr %p, i64 %idx
; CHECK-NEXT:    IR   %ld = load i64, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i64, ptr %p.out, i64 %iv
; CHECK-NEXT:    IR   store i64 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i64 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %stride = sext i32 %stride.i32 to i64
  %iv.next = add nsw i64 %iv, 1

  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @trunc_stride(ptr noalias %p.out, ptr %p, i64 %stride.i64) {
; CHECK-LABEL: VPlan for loop in 'trunc_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT-SCALAR ir<%stride> = trunc ir<%stride.i64> to i32
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i32 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %stride = trunc i64 %stride.i64 to i32
; CHECK-NEXT:    IR   %iv.next = add nsw i32 %iv, 1
; CHECK-NEXT:    IR   %idx = mul i32 %iv, %stride
; CHECK-NEXT:    IR   %gep.ld = getelementptr i32, ptr %p, i32 %idx
; CHECK-NEXT:    IR   %ld = load i32, ptr %gep.ld, align 8
; CHECK-NEXT:    IR   %gep.st = getelementptr i32, ptr %p.out, i32 %iv
; CHECK-NEXT:    IR   store i32 %ld, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i32 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %header ]
  %stride = trunc i64 %stride.i64 to i32
  %iv.next = add nsw i32 %iv, 1

  %idx = mul i32 %iv, %stride

  %gep.ld = getelementptr i32, ptr %p, i32 %idx
  %ld = load i32, ptr %gep.ld, align 8

  %gep.st = getelementptr i32, ptr %p.out, i32 %iv
  store i32 %ld, ptr %gep.st, align 8

  %exitcond = icmp slt i32 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @trunc_ext_stride(ptr noalias %p.out, ptr %p0, ptr %p1, i32 %stride) {
; CHECK-LABEL: VPlan for loop in 'trunc_ext_stride'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:    IR   %stride.trunc = trunc i32 %stride to i16
; CHECK-NEXT:    IR   %stride.ext = sext i32 %stride to i64
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT-SCALAR ir<%iv.trunc> = trunc ir<%iv> to i16
; CHECK-NEXT:      EMIT-SCALAR ir<%iv.ext> = sext ir<%iv> to i64
; CHECK-NEXT:      EMIT ir<%idx.trunc> = mul ir<%iv.trunc>, ir<%stride.trunc>
; CHECK-NEXT:      EMIT ir<%idx.ext> = mul ir<%iv.ext>, ir<%stride.ext>
; CHECK-NEXT:      EMIT ir<%gep.trunc> = getelementptr ir<%p0>, ir<%idx.trunc>
; CHECK-NEXT:      EMIT ir<%gep.ext> = getelementptr ir<%p0>, ir<%idx.ext>
; CHECK-NEXT:      EMIT ir<%ld.trunc> = load ir<%gep.trunc>
; CHECK-NEXT:      EMIT ir<%ld.ext> = load ir<%gep.ext>
; CHECK-NEXT:      EMIT ir<%val> = add ir<%ld.trunc>, ir<%ld.ext>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%val>, ir<%gep.st>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP7:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i32 [ 0, %entry ], [ %iv.next, %header ] (extra operand: vp<[[VP7]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i32 %iv, 1
; CHECK-NEXT:    IR   %iv.trunc = trunc i32 %iv to i16
; CHECK-NEXT:    IR   %iv.ext = sext i32 %iv to i64
; CHECK-NEXT:    IR   %idx.trunc = mul i16 %iv.trunc, %stride.trunc
; CHECK-NEXT:    IR   %idx.ext = mul i64 %iv.ext, %stride.ext
; CHECK-NEXT:    IR   %gep.trunc = getelementptr i32, ptr %p0, i16 %idx.trunc
; CHECK-NEXT:    IR   %gep.ext = getelementptr i32, ptr %p0, i64 %idx.ext
; CHECK-NEXT:    IR   %ld.trunc = load i32, ptr %gep.trunc, align 4
; CHECK-NEXT:    IR   %ld.ext = load i32, ptr %gep.ext, align 4
; CHECK-NEXT:    IR   %val = add i32 %ld.trunc, %ld.ext
; CHECK-NEXT:    IR   %gep.st = getelementptr i32, ptr %p.out, i32 %iv
; CHECK-NEXT:    IR   store i32 %val, ptr %gep.st, align 8
; CHECK-NEXT:    IR   %exitcond = icmp slt i32 %iv.next, 128
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  %stride.trunc = trunc i32 %stride to i16
  %stride.ext = sext i32 %stride to i64
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i32 %iv, 1

  %iv.trunc = trunc i32 %iv to i16
  %iv.ext = sext i32 %iv to i64

  %idx.trunc = mul i16 %iv.trunc, %stride.trunc
  %idx.ext = mul i64 %iv.ext, %stride.ext

  %gep.trunc = getelementptr i32, ptr %p0, i16 %idx.trunc
  %gep.ext = getelementptr i32, ptr %p0, i64 %idx.ext

  %ld.trunc = load i32, ptr %gep.trunc, align 4
  %ld.ext = load i32, ptr %gep.ext, align 4

  %val = add i32 %ld.trunc, %ld.ext

  %gep.st = getelementptr i32, ptr %p.out, i32 %iv
  store i32 %val, ptr %gep.st, align 8

  %exitcond = icmp slt i32 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

define void @basic_masked(ptr noalias %p.out, ptr %p, i64 %stride, i64 %x) {
; CHECK-LABEL: VPlan for loop in 'basic_masked'
; CHECK:  VPlan ' for UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<128> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nsw ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT ir<%c> = icmp sge ir<%iv>, ir<%x>
; CHECK-NEXT:    Successor(s): if
; CHECK-EMPTY:
; CHECK-NEXT:    if:
; CHECK-NEXT:      EMIT ir<%idx> = mul ir<%iv>, ir<%stride>, ir<%c>
; CHECK-NEXT:      EMIT ir<%gep.ld> = getelementptr ir<%p>, ir<%idx>
; CHECK-NEXT:      EMIT ir<%ld> = load ir<%gep.ld>, ir<%c>
; CHECK-NEXT:      EMIT ir<%gep.st> = getelementptr ir<%p.out>, ir<%iv>
; CHECK-NEXT:      EMIT store ir<%ld>, ir<%gep.st>, ir<%c>
; CHECK-NEXT:    Successor(s): latch
; CHECK-EMPTY:
; CHECK-NEXT:    latch:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%c>
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = or ir<%c>, vp<[[VP4]]>
; CHECK-NEXT:      EMIT ir<%exitcond> = icmp sge ir<%iv.next>, ir<128>, vp<[[VP5]]>
; CHECK-NEXT:      EMIT vp<[[VP6:%[0-9]+]]> = not ir<%exitcond>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq ir<128>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP9:%[0-9]+]]> = phi [ ir<%iv>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<header>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<header>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ] (extra operand: vp<[[VP9]]> from scalar.ph)
; CHECK-NEXT:    IR   %iv.next = add nsw i64 %iv, 1
; CHECK-NEXT:    IR   %c = icmp sge i64 %iv, %x
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %iv.next = add nsw i64 %iv, 1
  %c = icmp sge i64 %iv, %x
  br i1 %c, label %if, label %latch

if:
  %idx = mul i64 %iv, %stride

  %gep.ld = getelementptr i64, ptr %p, i64 %idx
  %ld = load i64, ptr %gep.ld, align 8

  %gep.st = getelementptr i64, ptr %p.out, i64 %iv
  store i64 %ld, ptr %gep.st, align 8
  br label %latch

latch:
  %exitcond = icmp slt i64 %iv.next, 128
  br i1 %exitcond, label %header, label %exit

exit:
  ret void
}

; Keep this in sync with the same under LoopVectorize/
