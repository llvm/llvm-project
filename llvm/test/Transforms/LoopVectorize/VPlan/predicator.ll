; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -disable-output < %s -p loop-vectorize -vplan-print-after=introduceMasksAndLinearize -vplan-print-vector-region-scope 2>&1 | FileCheck %s

define void @diamond_phi(ptr %a) {
; CHECK-LABEL: VPlan for loop in 'diamond_phi'
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nuw nsw ir<0>, ir<1>, vp<[[VP0:%[0-9]+]]>
; CHECK-NEXT:      EMIT ir<%gep> = getelementptr ir<%a>, ir<%iv>
; CHECK-NEXT:      EMIT ir<%c0> = icmp sle ir<%iv>, ir<0>
; CHECK-NEXT:    Successor(s): bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%c0>
; CHECK-NEXT:      EMIT ir<%add2> = add ir<%iv>, ir<2>, vp<[[VP4]]>
; CHECK-NEXT:    Successor(s): bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1:
; CHECK-NEXT:      EMIT ir<%add1> = add ir<%iv>, ir<1>, ir<%c0>
; CHECK-NEXT:    Successor(s): bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4:
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = or vp<[[VP4]]>, ir<%c0>
; CHECK-NEXT:      BLEND ir<%phi4> = ir<%add2>/vp<[[VP4]]> ir<%add1>/ir<%c0>
; CHECK-NEXT:      EMIT store ir<%phi4>, ir<%gep>, vp<[[VP5]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nuw nsw ir<%iv>, ir<1>, vp<[[VP5]]>
; CHECK-NEXT:      EMIT ir<%ec> = icmp eq ir<%iv.next>, ir<128>, vp<[[VP5]]>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1:%[0-9]+]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2:%[0-9]+]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
;
entry:
  br label %bb0

bb0:
;          bb0
;         /  \
;       bb1  bb2
;         \  /
;          bb4
; TODO: bb4 should be unmasked.
  %iv = phi i64 [0, %entry], [%iv.next, %bb4]
  %gep = getelementptr i64, ptr %a, i64 %iv
  %c0 = icmp sle i64 %iv, 0
  br i1 %c0, label %bb1, label %bb2

bb1:
  %add1 = add i64 %iv, 1
  br label %bb4

bb2:
  %add2 = add i64 %iv, 2
  br label %bb4

bb4:
  %phi4 = phi i64 [%add1, %bb1], [%add2, %bb2]
  store i64 %phi4, ptr %gep
  %iv.next = add nsw nuw i64 %iv, 1
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %bb0

exit:
  ret void
}

define void @mask_reuse(ptr %a) {
; CHECK-LABEL: VPlan for loop in 'mask_reuse'
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nuw nsw ir<0>, ir<1>, vp<[[VP0:%[0-9]+]]>
; CHECK-NEXT:      EMIT ir<%gep> = getelementptr ir<%a>, ir<%iv>
; CHECK-NEXT:      EMIT ir<%c0> = icmp sle ir<%iv>, ir<0>
; CHECK-NEXT:      EMIT ir<%add0> = add ir<%iv>, ir<0>
; CHECK-NEXT:    Successor(s): bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1:
; CHECK-NEXT:      EMIT ir<%add1> = add ir<%iv>, ir<1>, ir<%c0>
; CHECK-NEXT:      EMIT ir<%c1> = icmp sle ir<%iv>, ir<1>, ir<%c0>
; CHECK-NEXT:    Successor(s): bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = logical-and ir<%c0>, ir<%c1>
; CHECK-NEXT:      EMIT ir<%add2> = add ir<%iv>, ir<2>, vp<[[VP4]]>
; CHECK-NEXT:    Successor(s): bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3:
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = not ir<%c1>
; CHECK-NEXT:      EMIT vp<[[VP6:%[0-9]+]]> = logical-and ir<%c0>, vp<[[VP5]]>
; CHECK-NEXT:      EMIT vp<[[VP7:%[0-9]+]]> = or vp<[[VP4]]>, vp<[[VP6]]>
; CHECK-NEXT:      BLEND ir<%phi3> = ir<%add2>/vp<[[VP4]]> ir<%add1>/vp<[[VP6]]>
; CHECK-NEXT:      EMIT ir<%add3> = add ir<%iv>, ir<3>, vp<[[VP7]]>
; CHECK-NEXT:    Successor(s): bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4:
; CHECK-NEXT:      EMIT vp<[[VP8:%[0-9]+]]> = not ir<%c0>
; CHECK-NEXT:      EMIT vp<[[VP9:%[0-9]+]]> = or vp<[[VP7]]>, vp<[[VP8]]>
; CHECK-NEXT:      BLEND ir<%phi4> = ir<%add3>/vp<[[VP7]]> ir<%iv>/vp<[[VP8]]>
; CHECK-NEXT:      EMIT store ir<%phi4>, ir<%gep>, vp<[[VP9]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nuw nsw ir<%iv>, ir<1>, vp<[[VP9]]>
; CHECK-NEXT:      EMIT ir<%ec> = icmp eq ir<%iv.next>, ir<128>, vp<[[VP9]]>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1:%[0-9]+]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2:%[0-9]+]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
;
entry:
  br label %bb0

bb0:
;         bb0:
;         / \
;      bb1   \
;       /\    \
;     bb2 |   |
;      \  |   |
;       bb3  /
;         \ /
;         bb4
; TODO: bb3 can reuse bb1's mask and bb4 should be unmasked.
  %iv = phi i64 [0, %entry], [%iv.next, %bb4]
  %gep = getelementptr i64, ptr %a, i64 %iv
  %c0 = icmp sle i64 %iv, 0
  %add0 = add i64 %iv, 0
  br i1 %c0, label %bb1, label %bb4

bb1:
  %add1 = add i64 %iv, 1
  %c1 = icmp sle i64 %iv, 1
  br i1 %c1, label %bb2, label %bb3

bb2:
  %add2 = add i64 %iv, 2
  br label %bb3

bb3:
  %phi3 = phi i64 [%add1, %bb1], [%add2, %bb2]
  %add3 = add i64 %iv, 3
  br label %bb4

bb4:
  %phi4 = phi i64 [%add3, %bb3], [%add0, %bb0]
  store i64 %phi4, ptr %gep
  %iv.next = add nsw nuw i64 %iv, 1
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %bb0

exit:
  ret void
}

define void @optimized_mask(ptr %a) {
; CHECK-LABEL: VPlan for loop in 'optimized_mask'
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nuw nsw ir<0>, ir<1>, vp<[[VP0:%[0-9]+]]>
; CHECK-NEXT:      EMIT ir<%gep> = getelementptr ir<%a>, ir<%iv>
; CHECK-NEXT:      EMIT ir<%c0> = icmp sle ir<%iv>, ir<0>
; CHECK-NEXT:    Successor(s): bb6
; CHECK-EMPTY:
; CHECK-NEXT:    bb6:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%c0>
; CHECK-NEXT:      EMIT ir<%add6> = add ir<%iv>, ir<6>, vp<[[VP4]]>
; CHECK-NEXT:      EMIT ir<%c6> = icmp sle ir<%iv>, ir<6>, vp<[[VP4]]>
; CHECK-NEXT:    Successor(s): bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1:
; CHECK-NEXT:      EMIT ir<%add1> = add ir<%iv>, ir<1>, ir<%c0>
; CHECK-NEXT:      EMIT ir<%c1> = icmp sle ir<%iv>, ir<1>, ir<%c0>
; CHECK-NEXT:    Successor(s): bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3:
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = not ir<%c1>
; CHECK-NEXT:      EMIT vp<[[VP6:%[0-9]+]]> = logical-and ir<%c0>, vp<[[VP5]]>
; CHECK-NEXT:      EMIT ir<%add3> = add ir<%iv>, ir<3>, vp<[[VP6]]>
; CHECK-NEXT:      EMIT ir<%c3> = icmp sle ir<%iv>, ir<3>, vp<[[VP6]]>
; CHECK-NEXT:    Successor(s): bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2:
; CHECK-NEXT:      EMIT vp<[[VP7:%[0-9]+]]> = logical-and ir<%c0>, ir<%c1>
; CHECK-NEXT:      EMIT ir<%add2> = add ir<%iv>, ir<2>, vp<[[VP7]]>
; CHECK-NEXT:    Successor(s): bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4:
; CHECK-NEXT:      EMIT vp<[[VP8:%[0-9]+]]> = logical-and vp<[[VP6]]>, ir<%c3>
; CHECK-NEXT:      EMIT vp<[[VP9:%[0-9]+]]> = or vp<[[VP8]]>, vp<[[VP7]]>
; CHECK-NEXT:      BLEND ir<%phi4> = ir<%add3>/vp<[[VP8]]> ir<%add2>/vp<[[VP7]]>
; CHECK-NEXT:      EMIT ir<%add4> = add ir<%iv>, ir<4>, vp<[[VP9]]>
; CHECK-NEXT:    Successor(s): bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5:
; CHECK-NEXT:      EMIT vp<[[VP10:%[0-9]+]]> = logical-and vp<[[VP4]]>, ir<%c6>
; CHECK-NEXT:      EMIT vp<[[VP11:%[0-9]+]]> = or vp<[[VP10]]>, vp<[[VP9]]>
; CHECK-NEXT:      EMIT vp<[[VP12:%[0-9]+]]> = not ir<%c3>
; CHECK-NEXT:      EMIT vp<[[VP13:%[0-9]+]]> = logical-and vp<[[VP6]]>, vp<[[VP12]]>
; CHECK-NEXT:      EMIT vp<[[VP14:%[0-9]+]]> = or vp<[[VP11]]>, vp<[[VP13]]>
; CHECK-NEXT:      BLEND ir<%phi5> = ir<%add6>/vp<[[VP10]]> ir<%add4>/vp<[[VP9]]> ir<%add3>/vp<[[VP13]]>
; CHECK-NEXT:      EMIT ir<%add5> = add ir<%iv>, ir<5>, vp<[[VP14]]>
; CHECK-NEXT:    Successor(s): bb7
; CHECK-EMPTY:
; CHECK-NEXT:    bb7:
; CHECK-NEXT:      EMIT vp<[[VP15:%[0-9]+]]> = not ir<%c6>
; CHECK-NEXT:      EMIT vp<[[VP16:%[0-9]+]]> = logical-and vp<[[VP4]]>, vp<[[VP15]]>
; CHECK-NEXT:      EMIT vp<[[VP17:%[0-9]+]]> = or vp<[[VP16]]>, vp<[[VP14]]>
; CHECK-NEXT:      BLEND ir<%phi7> = ir<%add6>/vp<[[VP16]]> ir<%add5>/vp<[[VP14]]>
; CHECK-NEXT:      EMIT store ir<%phi7>, ir<%gep>, vp<[[VP17]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nuw nsw ir<%iv>, ir<1>, vp<[[VP17]]>
; CHECK-NEXT:      EMIT ir<%ec> = icmp eq ir<%iv.next>, ir<128>, vp<[[VP17]]>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1:%[0-9]+]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2:%[0-9]+]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
;
entry:
  br label %bb0

bb0:
;               bb0:
;              /   \
;             /     \
;          bb1       bb6
;          /  \      / |
;        bb2  bb3   /  /
;          \  /|   /  /
;           bb4|  /  /
;            \ | /  /
;             bb5  /
;               \ /
;               bb7
; TODO: bb5's mask shouldn't depend on c1/c3.
  %iv = phi i64 [0, %entry], [%iv.next, %bb7]
  %gep = getelementptr i64, ptr %a, i64 %iv
  %c0 = icmp sle i64 %iv, 0
  br i1 %c0, label %bb1, label %bb6

bb1:
  %add1 = add i64 %iv, 1
  %c1 = icmp sle i64 %iv, 1
  br i1 %c1, label %bb2, label %bb3

bb2:
  %add2 = add i64 %iv, 2
  br label %bb4

bb3:
  %add3 = add i64 %iv, 3
  %c3 = icmp sle i64 %iv, 3
  br i1 %c3, label %bb4, label %bb5

bb4:
  %phi4 = phi i64 [%add2, %bb2], [%add3, %bb3]
  %add4 = add i64 %iv, 4
  br label %bb5

bb5:
  %phi5 = phi i64 [%add4, %bb4], [%add3, %bb3], [%add6, %bb6]
  %add5 = add i64 %iv, 5
  br label %bb7

bb6:
  %add6 = add i64 %iv, 6
  %c6 = icmp sle i64 %iv, 6
  br i1 %c6, label %bb5, label %bb7

bb7:
  %phi7 = phi i64 [%add5, %bb5], [%add6, %bb6]
  store i64 %phi7, ptr %gep
  %iv.next = add nsw nuw i64 %iv, 1
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %bb0

exit:
  ret void
}

define void @switch(ptr %a) {
; CHECK-LABEL: VPlan for loop in 'switch'
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION nuw nsw ir<0>, ir<1>, vp<[[VP0:%[0-9]+]]>
; CHECK-NEXT:      EMIT ir<%gep> = getelementptr ir<%a>, ir<%iv>
; CHECK-NEXT:      EMIT ir<%c0> = icmp sle ir<%iv>, ir<0>
; CHECK-NEXT:      EMIT ir<%add0> = add ir<%iv>, ir<0>
; CHECK-NEXT:    Successor(s): bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = not ir<%c0>
; CHECK-NEXT:      EMIT ir<%add2> = add ir<%iv>, ir<2>, vp<[[VP4]]>
; CHECK-NEXT:      EMIT ir<%c2> = icmp sle ir<%iv>, ir<2>, vp<[[VP4]]>
; CHECK-NEXT:    Successor(s): bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1:
; CHECK-NEXT:      EMIT ir<%add1> = add ir<%iv>, ir<1>, ir<%c0>
; CHECK-NEXT:    Successor(s): bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3:
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = logical-and vp<[[VP4]]>, ir<%c2>
; CHECK-NEXT:      EMIT vp<[[VP6:%[0-9]+]]> = icmp eq ir<%iv>, ir<1>
; CHECK-NEXT:      EMIT vp<[[VP7:%[0-9]+]]> = icmp eq ir<%iv>, ir<2>
; CHECK-NEXT:      EMIT vp<[[VP8:%[0-9]+]]> = icmp eq ir<%iv>, ir<3>
; CHECK-NEXT:      EMIT vp<[[VP9:%[0-9]+]]> = logical-and ir<%c0>, vp<[[VP6]]>
; CHECK-NEXT:      EMIT vp<[[VP10:%[0-9]+]]> = or vp<[[VP7]]>, vp<[[VP8]]>
; CHECK-NEXT:      EMIT vp<[[VP11:%[0-9]+]]> = logical-and ir<%c0>, vp<[[VP10]]>
; CHECK-NEXT:      EMIT vp<[[VP12:%[0-9]+]]> = or vp<[[VP9]]>, vp<[[VP11]]>
; CHECK-NEXT:      EMIT vp<[[VP13:%[0-9]+]]> = not vp<[[VP12]]>
; CHECK-NEXT:      EMIT vp<[[VP14:%[0-9]+]]> = logical-and ir<%c0>, vp<[[VP13]]>
; CHECK-NEXT:      EMIT vp<[[VP15:%[0-9]+]]> = or vp<[[VP5]]>, vp<[[VP11]]>
; CHECK-NEXT:      BLEND ir<%phi3> = ir<%add2>/vp<[[VP5]]> ir<%add1>/vp<[[VP11]]> ir<%add1>/vp<[[VP11]]>
; CHECK-NEXT:      EMIT ir<%add3> = add ir<%iv>, ir<3>, vp<[[VP15]]>
; CHECK-NEXT:    Successor(s): bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4:
; CHECK-NEXT:      EMIT ir<%add4> = add ir<%iv>, ir<4>, vp<[[VP9]]>
; CHECK-NEXT:    Successor(s): bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5:
; CHECK-NEXT:      EMIT vp<[[VP16:%[0-9]+]]> = or vp<[[VP9]]>, vp<[[VP15]]>
; CHECK-NEXT:      EMIT vp<[[VP17:%[0-9]+]]> = not ir<%c2>
; CHECK-NEXT:      EMIT vp<[[VP18:%[0-9]+]]> = logical-and vp<[[VP4]]>, vp<[[VP17]]>
; CHECK-NEXT:      EMIT vp<[[VP19:%[0-9]+]]> = or vp<[[VP16]]>, vp<[[VP18]]>
; CHECK-NEXT:      EMIT vp<[[VP20:%[0-9]+]]> = or vp<[[VP19]]>, vp<[[VP14]]>
; CHECK-NEXT:      BLEND ir<%phi5> = ir<%add4>/vp<[[VP9]]> ir<%add3>/vp<[[VP15]]> ir<%add2>/vp<[[VP18]]> ir<%add1>/vp<[[VP14]]>
; CHECK-NEXT:      EMIT store ir<%phi5>, ir<%gep>, vp<[[VP20]]>
; CHECK-NEXT:      EMIT ir<%iv.next> = add nuw nsw ir<%iv>, ir<1>, vp<[[VP20]]>
; CHECK-NEXT:      EMIT ir<%ec> = icmp eq ir<%iv.next>, ir<128>, vp<[[VP20]]>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1:%[0-9]+]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2:%[0-9]+]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
;
entry:
  br label %bb0

bb0:
;         bb0:
;         / \
;      bb1-+ bb2
;     / | \| /\
;     \bb4 bb3|
;      \ \ | /
;       +>bb5
; Test for blends at switch destinations, including multiple edges from switch
; to a single block (bb3).
  %iv = phi i64 [0, %entry], [%iv.next, %bb5]
  %gep = getelementptr i64, ptr %a, i64 %iv
  %c0 = icmp sle i64 %iv, 0
  %add0 = add i64 %iv, 0
  br i1 %c0, label %bb1, label %bb2

bb1:
  %add1 = add i64 %iv, 1
  switch i64 %iv, label %bb5 [
    i64 1, label %bb4
    i64 2, label %bb3
    i64 3, label %bb3
  ]

bb2:
  %add2 = add i64 %iv, 2
  %c2 = icmp sle i64 %iv, 2
  br i1 %c2, label %bb3, label %bb5

bb3:
  %phi3 = phi i64 [%add1, %bb1], [%add1, %bb1], [%add2, %bb2]
  %add3 = add i64 %iv, 3
  br label %bb5

bb4:
  %add4 = add i64 %iv, 4
  br label %bb5

bb5:
  %phi5 = phi i64 [%add1, %bb1], [%add2, %bb2], [%add3, %bb3], [%add4, %bb4]
  store i64 %phi5, ptr %gep
  %iv.next = add nsw nuw i64 %iv, 1
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %bb0

exit:
  ret void
}
