; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=loop-vectorize -mattr=+sve2 -force-partial-aliasing-vectorization -prefer-predicate-over-epilogue=predicate-dont-vectorize -disable-output -vplan-print-after="printFinalVPlan$" -S %s 2>&1 | FileCheck --check-prefixes=FINAL %s

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

define void @alias_mask(ptr noalias %a, ptr %b, ptr %c, i32 %n) {
; FINAL-LABEL: VPlan for loop in 'alias_mask'
; FINAL:  VPlan 'Final VPlan for VF={vscale x 1,vscale x 2,vscale x 4,vscale x 8,vscale x 16},UF={1}' {
; FINAL-NEXT:  Live-in ir<%wide.trip.count> = original trip-count
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<for.body.preheader>:
; FINAL-NEXT:    IR   %wide.trip.count = zext nneg i32 %n to i64
; FINAL-NEXT:  Successor(s): vector.min.vf.check
; FINAL-EMPTY:
; FINAL-NEXT:  vector.min.vf.check:
; FINAL-NEXT:    EMIT-SCALAR vp<[[VP2:%[0-9]+]]> = inttoptr ir<%b2> to ptr
; FINAL-NEXT:    EMIT-SCALAR vp<[[VP3:%[0-9]+]]> = inttoptr ir<%c1> to ptr
; FINAL-NEXT:    WIDEN-INTRINSIC vp<[[VP4:%[0-9]+]]> = call llvm.loop.dependence.war.mask(vp<[[VP2]]>, vp<[[VP3]]>, ir<1>)
; FINAL-NEXT:    EMIT vp<[[VP5:%[0-9]+]]> = num-active-lanes vp<[[VP4]]>
; FINAL-NEXT:    EMIT vp<%cmp.vf> = icmp ult vp<[[VP5]]>, ir<2>
; FINAL-NEXT:    EMIT branch-on-cond vp<%cmp.vf>
; FINAL-NEXT:  Successor(s): ir-bb<scalar.ph>, vector.ph
; FINAL-EMPTY:
; FINAL-NEXT:  vector.ph:
; FINAL-NEXT:    EMIT vp<[[VP7:%[0-9]+]]> = TC > VF ? TC - VF : 0 ir<%wide.trip.count>, vp<[[VP5]]>
; FINAL-NEXT:    EMIT vp<%active.lane.mask.entry> = active lane mask ir<0>, ir<%wide.trip.count>, ir<1>
; FINAL-NEXT:  Successor(s): vector.body
; FINAL-EMPTY:
; FINAL-NEXT:  vector.body:
; FINAL-NEXT:    EMIT-SCALAR vp<%index> = phi [ ir<0>, vector.ph ], [ vp<%index.next>, vector.body ]
; FINAL-NEXT:    ACTIVE-LANE-MASK-PHI vp<[[VP8:%[0-9]+]]> = phi vp<%active.lane.mask.entry>, vp<%active.lane.mask.next>
; FINAL-NEXT:    EMIT vp<[[VP9:%[0-9]+]]> = and vp<[[VP8]]>, vp<[[VP4]]>
; FINAL-NEXT:    CLONE ir<%arrayidx> = getelementptr inbounds ir<%a>, vp<%index>
; FINAL-NEXT:    WIDEN ir<%0> = load ir<%arrayidx>, vp<[[VP9]]>
; FINAL-NEXT:    CLONE ir<%arrayidx2> = getelementptr inbounds ir<%b>, vp<%index>
; FINAL-NEXT:    WIDEN ir<%1> = load ir<%arrayidx2>, vp<[[VP9]]>
; FINAL-NEXT:    WIDEN ir<%add> = add ir<%1>, ir<%0>
; FINAL-NEXT:    CLONE ir<%arrayidx6> = getelementptr inbounds ir<%c>, vp<%index>
; FINAL-NEXT:    WIDEN store ir<%arrayidx6>, ir<%add>, vp<[[VP9]]>
; FINAL-NEXT:    EMIT vp<%index.next> = add vp<%index>, vp<[[VP5]]>
; FINAL-NEXT:    EMIT vp<%active.lane.mask.next> = active lane mask vp<%index>, vp<[[VP7]]>, ir<1>
; FINAL-NEXT:    EMIT vp<[[VP10:%[0-9]+]]> = not vp<%active.lane.mask.next>
; FINAL-NEXT:    EMIT branch-on-cond vp<[[VP10]]>
; FINAL-NEXT:  Successor(s): middle.block, vector.body
; FINAL-EMPTY:
; FINAL-NEXT:  middle.block:
; FINAL-NEXT:  Successor(s): ir-bb<for.cond.cleanup.loopexit>
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<for.cond.cleanup.loopexit>:
; FINAL-NEXT:  No successors
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<scalar.ph>:
; FINAL-NEXT:  Successor(s): ir-bb<for.body>
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<for.body>:
; FINAL-NEXT:    IR   %indvars.iv = phi i64 [ 0, %scalar.ph ], [ %indvars.iv.next, %for.body ] (extra operand: ir<0> from ir-bb<scalar.ph>)
; FINAL-NEXT:    IR   %arrayidx = getelementptr inbounds i8, ptr %a, i64 %indvars.iv
; FINAL-NEXT:    IR   %0 = load i8, ptr %arrayidx, align 1
; FINAL-NEXT:    IR   %arrayidx2 = getelementptr inbounds i8, ptr %b, i64 %indvars.iv
; FINAL-NEXT:    IR   %1 = load i8, ptr %arrayidx2, align 1
; FINAL-NEXT:    IR   %add = add i8 %1, %0
; FINAL-NEXT:    IR   %arrayidx6 = getelementptr inbounds i8, ptr %c, i64 %indvars.iv
; FINAL-NEXT:    IR   store i8 %add, ptr %arrayidx6, align 1
; FINAL-NEXT:    IR   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
; FINAL-NEXT:    IR   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
; FINAL-NEXT:  No successors
; FINAL-NEXT:  }
;
entry:
  %cmp11 = icmp sgt i32 %n, 0
  br i1 %cmp11, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %n to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i8, ptr %a, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds i8, ptr %b, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx2, align 1
  %add = add i8 %1, %0
  %arrayidx6 = getelementptr inbounds i8, ptr %c, i64 %indvars.iv
  store i8 %add, ptr %arrayidx6, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}
