; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=loop-vectorize -force-vector-width=2 -force-partial-aliasing-vectorization -prefer-predicate-over-epilogue=predicate-dont-vectorize -disable-output -vplan-print-after="printFinalVPlan$" -S %s 2>&1 | FileCheck --check-prefixes=FINAL %s

define void @alias_mask(ptr noalias %a, ptr %b, ptr %c, i32 %n) {
; FINAL-LABEL: VPlan for loop in 'alias_mask'
; FINAL:  VPlan 'Final VPlan for VF={2},UF={1}' {
; FINAL-NEXT:  Live-in ir<%wide.trip.count> = original trip-count
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<for.body.preheader>:
; FINAL-NEXT:    IR   %wide.trip.count = zext nneg i32 %n to i64
; FINAL-NEXT:  Successor(s): vector.min.vf.check
; FINAL-EMPTY:
; FINAL-NEXT:  vector.min.vf.check:
; FINAL-NEXT:    EMIT-SCALAR vp<[[VP2:%[0-9]+]]> = inttoptr ir<%b2> to ptr
; FINAL-NEXT:    EMIT-SCALAR vp<[[VP3:%[0-9]+]]> = inttoptr ir<%c1> to ptr
; FINAL-NEXT:    WIDEN-INTRINSIC vp<[[VP4:%[0-9]+]]> = call llvm.loop.dependence.war.mask(vp<[[VP2]]>, vp<[[VP3]]>, ir<1>)
; FINAL-NEXT:    EMIT vp<[[VP5:%[0-9]+]]> = num-active-lanes vp<[[VP4]]>
; FINAL-NEXT:    EMIT vp<%cmp.vf> = icmp ult vp<[[VP5]]>, ir<2>
; FINAL-NEXT:    EMIT branch-on-cond vp<%cmp.vf>
; FINAL-NEXT:  Successor(s): ir-bb<scalar.ph>, vector.ph
; FINAL-EMPTY:
; FINAL-NEXT:  vector.ph:
; FINAL-NEXT:    EMIT vp<[[VP7:%[0-9]+]]> = sub vp<[[VP5]]>, ir<1>
; FINAL-NEXT:    EMIT vp<%n.rnd.up> = add ir<%wide.trip.count>, vp<[[VP7]]>
; FINAL-NEXT:    EMIT vp<%n.mod.vf> = urem vp<%n.rnd.up>, vp<[[VP5]]>
; FINAL-NEXT:    EMIT vp<%n.vec> = sub vp<%n.rnd.up>, vp<%n.mod.vf>
; FINAL-NEXT:    EMIT vp<%trip.count.minus.1> = sub ir<%wide.trip.count>, ir<1>
; FINAL-NEXT:    EMIT vp<[[VP8:%[0-9]+]]> = broadcast vp<%trip.count.minus.1>
; FINAL-NEXT:    EMIT vp<[[VP9:%[0-9]+]]> = step-vector i64
; FINAL-NEXT:    EMIT vp<[[VP10:%[0-9]+]]> = broadcast vp<[[VP5]]>
; FINAL-NEXT:  Successor(s): vector.body
; FINAL-EMPTY:
; FINAL-NEXT:  vector.body:
; FINAL-NEXT:    EMIT-SCALAR vp<%index> = phi [ ir<0>, vector.ph ], [ vp<%index.next>, for.body.2 ]
; FINAL-NEXT:    WIDEN-PHI ir<%indvars.iv> = phi [ vp<[[VP9]]>, vector.ph ], [ vp<%vec.ind.next>, for.body.2 ]
; FINAL-NEXT:    EMIT vp<[[VP11:%[0-9]+]]> = icmp ule ir<%indvars.iv>, vp<[[VP8]]>
; FINAL-NEXT:    EMIT vp<[[VP12:%[0-9]+]]> = and vp<[[VP11]]>, vp<[[VP4]]>
; FINAL-NEXT:  Successor(s): pred.store
; FINAL-EMPTY:
; FINAL-NEXT:  <xVFxUF> pred.store: {
; FINAL-NEXT:    pred.store.entry:
; FINAL-NEXT:      BRANCH-ON-MASK vp<[[VP12]]>
; FINAL-NEXT:    Successor(s): pred.store.if, pred.store.continue
; FINAL-EMPTY:
; FINAL-NEXT:    pred.store.if:
; FINAL-NEXT:      vp<[[VP13:%[0-9]+]]> = SCALAR-STEPS vp<%index>, ir<1>, vp<[[VP5]]>
; FINAL-NEXT:      REPLICATE ir<%arrayidx> = getelementptr inbounds ir<%a>, vp<[[VP13]]>
; FINAL-NEXT:      REPLICATE ir<%0> = load ir<%arrayidx>
; FINAL-NEXT:      REPLICATE ir<%arrayidx2> = getelementptr inbounds ir<%b>, vp<[[VP13]]>
; FINAL-NEXT:      REPLICATE ir<%1> = load ir<%arrayidx2>
; FINAL-NEXT:      REPLICATE ir<%arrayidx6> = getelementptr inbounds ir<%c>, vp<[[VP13]]>
; FINAL-NEXT:      REPLICATE ir<%add> = add ir<%1>, ir<%0>
; FINAL-NEXT:      REPLICATE store ir<%add>, ir<%arrayidx6>
; FINAL-NEXT:    Successor(s): pred.store.continue
; FINAL-EMPTY:
; FINAL-NEXT:    pred.store.continue:
; FINAL-NEXT:    No successors
; FINAL-NEXT:  }
; FINAL-NEXT:  Successor(s): for.body.2
; FINAL-EMPTY:
; FINAL-NEXT:  for.body.2:
; FINAL-NEXT:    EMIT vp<%index.next> = add nuw vp<%index>, vp<[[VP5]]>
; FINAL-NEXT:    EMIT vp<%vec.ind.next> = add ir<%indvars.iv>, vp<[[VP10]]>
; FINAL-NEXT:    EMIT vp<[[VP14:%[0-9]+]]> = icmp eq vp<%index.next>, vp<%n.vec>
; FINAL-NEXT:    EMIT branch-on-cond vp<[[VP14]]>
; FINAL-NEXT:  Successor(s): middle.block, vector.body
; FINAL-EMPTY:
; FINAL-NEXT:  middle.block:
; FINAL-NEXT:  Successor(s): ir-bb<for.cond.cleanup.loopexit>
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<for.cond.cleanup.loopexit>:
; FINAL-NEXT:  No successors
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<scalar.ph>:
; FINAL-NEXT:  Successor(s): ir-bb<for.body>
; FINAL-EMPTY:
; FINAL-NEXT:  ir-bb<for.body>:
; FINAL-NEXT:    IR   %indvars.iv = phi i64 [ 0, %scalar.ph ], [ %indvars.iv.next, %for.body ] (extra operand: ir<0> from ir-bb<scalar.ph>)
; FINAL-NEXT:    IR   %arrayidx = getelementptr inbounds i8, ptr %a, i64 %indvars.iv
; FINAL-NEXT:    IR   %0 = load i8, ptr %arrayidx, align 1
; FINAL-NEXT:    IR   %arrayidx2 = getelementptr inbounds i8, ptr %b, i64 %indvars.iv
; FINAL-NEXT:    IR   %1 = load i8, ptr %arrayidx2, align 1
; FINAL-NEXT:    IR   %add = add i8 %1, %0
; FINAL-NEXT:    IR   %arrayidx6 = getelementptr inbounds i8, ptr %c, i64 %indvars.iv
; FINAL-NEXT:    IR   store i8 %add, ptr %arrayidx6, align 1
; FINAL-NEXT:    IR   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
; FINAL-NEXT:    IR   %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
; FINAL-NEXT:  No successors
; FINAL-NEXT:  }
;
entry:
  %cmp11 = icmp sgt i32 %n, 0
  br i1 %cmp11, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %n to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i8, ptr %a, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds i8, ptr %b, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx2, align 1
  %add = add i8 %1, %0
  %arrayidx6 = getelementptr inbounds i8, ptr %c, i64 %indvars.iv
  store i8 %add, ptr %arrayidx6, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}
