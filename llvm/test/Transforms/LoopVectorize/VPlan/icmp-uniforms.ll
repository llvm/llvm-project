; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=loop-vectorize,instcombine -force-vector-width=4 -force-vector-interleave=1 -vplan-print-after="optimize$" -disable-output -print-after=instcombine 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-i128:128-n32:64-S128"

; CHECK-LABEL: more_than_one_use
;
; PR30627. Check that a compare instruction with more than one use is not
; recognized as uniform and is vectorized.
;
; CHECK-NOT: Found uniform instruction: %cond = icmp slt i64 %i.next, %n
;
define i32 @more_than_one_use(ptr %a, i64 %n) {
; CHECK:  VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  vp<[[VP3:%[0-9]+]]> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:    EMIT vp<[[VP3]]> = EXPAND SCEV (1 smax %n)
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    EMIT vp<[[VP4:%[0-9]+]]> = reduction-start-vector ir<0>, ir<0>, ir<1>
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%i> = WIDEN-INDUCTION nuw nsw ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      WIDEN-REDUCTION-PHI ir<%r> = phi vp<[[VP4]]>, ir<%tmp3>
; CHECK-NEXT:      WIDEN ir<%i.next> = add nuw nsw ir<%i>, ir<1>
; CHECK-NEXT:      WIDEN ir<%cond> = icmp slt ir<%i.next>, ir<%n>
; CHECK-NEXT:      WIDEN ir<%tmp0> = select ir<%cond>, ir<%i.next>, ir<0>
; CHECK-NEXT:      REPLICATE ir<%tmp1> = getelementptr inbounds ir<%a>, ir<%tmp0>
; CHECK-NEXT:      REPLICATE ir<%tmp2> = load ir<%tmp1>
; CHECK-NEXT:      WIDEN ir<%tmp3> = add ir<%r>, ir<%tmp2>
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP5]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<[[VP7:%[0-9]+]]> = compute-reduction-result (add) ir<%tmp3>
; CHECK-NEXT:    EMIT vp<%cmp.n> = icmp eq vp<[[VP3]]>, vp<[[VP2]]>
; CHECK-NEXT:    EMIT branch-on-cond vp<%cmp.n>
; CHECK-NEXT:  Successor(s): ir-bb<for.end>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<for.end>:
; CHECK-NEXT:    IR   %tmp4 = phi i32 [ %tmp3, %for.body ] (extra operand: vp<[[VP7]]> from middle.block)
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<%bc.resume.val> = phi [ vp<[[VP2]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:    EMIT-SCALAR vp<%bc.merge.rdx> = phi [ vp<[[VP7]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<for.body>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<for.body>:
; CHECK-NEXT:    IR   %i = phi i64 [ %i.next, %for.body ], [ 0, %entry ] (extra operand: vp<%bc.resume.val> from scalar.ph)
; CHECK-NEXT:    IR   %r = phi i32 [ %tmp3, %for.body ], [ 0, %entry ] (extra operand: vp<%bc.merge.rdx> from scalar.ph)
; CHECK-NEXT:    IR   %i.next = add nuw nsw i64 %i, 1
; CHECK-NEXT:    IR   %cond = icmp slt i64 %i.next, %n
; CHECK-NEXT:    IR   %tmp0 = select i1 %cond, i64 %i.next, i64 0
; CHECK-NEXT:    IR   %tmp1 = getelementptr inbounds i32, ptr %a, i64 %tmp0
; CHECK-NEXT:    IR   %tmp2 = load i32, ptr %tmp1, align 8
; CHECK-NEXT:    IR   %tmp3 = add i32 %r, %tmp2
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
; CHECK:     vector.body
; CHECK:       %[[I:.+]] = add nuw nsw <4 x i64> %vec.ind, splat (i64 1)
; CHECK:       icmp slt <4 x i64> %[[I]], %broadcast.splat
; CHECK:       br i1 {{.*}}, label %middle.block, label %vector.body
entry:
  br label %for.body

for.body:
  %i = phi i64 [ %i.next, %for.body ], [ 0, %entry ]
  %r = phi i32 [ %tmp3, %for.body ], [ 0, %entry ]
  %i.next = add nuw nsw i64 %i, 1
  %cond = icmp slt i64 %i.next, %n
  %tmp0 = select i1 %cond, i64 %i.next, i64 0
  %tmp1 = getelementptr inbounds i32, ptr %a, i64 %tmp0
  %tmp2 = load i32, ptr %tmp1, align 8
  %tmp3 = add i32 %r, %tmp2
  br i1 %cond, label %for.body, label %for.end

for.end:
  %tmp4 = phi i32 [ %tmp3, %for.body ]
  ret i32 %tmp4
}

; Check for crash exposed by D76992.
define void @test(ptr %ptr) {
; CHECK-LABEL: 'test'
; CHECK:  VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in vp<[[VP3:%[0-9]+]]> = backedge-taken count
; CHECK-NEXT:  Live-in ir<14> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP4:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      ir<%iv> = WIDEN-INDUCTION ir<0>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      EMIT vp<[[VP5:%[0-9]+]]> = icmp ule ir<%iv>, vp<[[VP3]]>
; CHECK-NEXT:      WIDEN ir<%cond0> = icmp ult ir<%iv>, ir<13>
; CHECK-NEXT:      WIDEN ir<%s> = select ir<%cond0>, ir<10>, ir<20>
; CHECK-NEXT:    Successor(s): pred.store
; CHECK-EMPTY:
; CHECK-NEXT:    <xVFxUF> pred.store: {
; CHECK-NEXT:      pred.store.entry:
; CHECK-NEXT:        BRANCH-ON-MASK vp<[[VP5]]>
; CHECK-NEXT:      Successor(s): pred.store.if, pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.if:
; CHECK-NEXT:        vp<[[VP6:%[0-9]+]]> = SCALAR-STEPS vp<[[VP4]]>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:        REPLICATE ir<%gep> = getelementptr inbounds ir<%ptr>, vp<[[VP6]]>
; CHECK-NEXT:        REPLICATE store ir<%s>, ir<%gep>
; CHECK-NEXT:      Successor(s): pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.continue:
; CHECK-NEXT:      No successors
; CHECK-NEXT:    }
; CHECK-NEXT:    Successor(s): loop.0
; CHECK-EMPTY:
; CHECK-NEXT:    loop.0:
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP4]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT branch-on-count vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:  Successor(s): ir-bb<exit>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<%bc.resume.val> = phi [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<loop>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<loop>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ] (extra operand: vp<%bc.resume.val> from scalar.ph)
; CHECK-NEXT:    IR   %cond0 = icmp ult i64 %iv, 13
; CHECK-NEXT:    IR   %s = select i1 %cond0, i32 10, i32 20
; CHECK-NEXT:    IR   %gep = getelementptr inbounds i32, ptr %ptr, i64 %iv
; CHECK-NEXT:    IR   store i32 %s, ptr %gep, align 4
; CHECK-NEXT:    IR   %iv.next = add nuw nsw i64 %iv, 1
; CHECK-NEXT:    IR   %exitcond = icmp eq i64 %iv.next, 14
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %loop

loop:                       ; preds = %loop, %entry
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %cond0 = icmp ult i64 %iv, 13
  %s = select i1 %cond0, i32 10, i32 20
  %gep = getelementptr inbounds i32, ptr %ptr, i64 %iv
  store i32 %s, ptr %gep
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 14
  br i1 %exitcond, label %exit, label %loop

exit:
  ret void
}
