; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --filter-out-after "^scalar.ph" --version 6
; RUN: opt -S -p loop-vectorize -force-vector-width=1 -force-vector-interleave=2 < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-Fn32"

declare i64 @llvm.objectsize.i64.p0(ptr, i1 immarg, i1 immarg, i1 immarg) #0

define void @foo(ptr align 8 dereferenceable(120) %p, i1 %flag) local_unnamed_addr #1 {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: ptr align 8 dereferenceable(120) [[P:%.*]], i1 [[FLAG:%.*]]) local_unnamed_addr #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[FLAG]], label %[[LOOP_1_LR_PH:.*]], [[EXIT:label %.*]]
; CHECK:       [[LOOP_1_LR_PH]]:
; CHECK-NEXT:    [[INV_PTR:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i64 24
; CHECK-NEXT:    [[INV_PTR2:%.*]] = getelementptr inbounds nuw i8, ptr [[P]], i64 40
; CHECK-NEXT:    [[INV_PTR_PROMOTED:%.*]] = load ptr, ptr [[INV_PTR]], align 8
; CHECK-NEXT:    [[INV_PTR2_PROMOTED:%.*]] = load i32, ptr [[INV_PTR2]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = mul i32 [[INV_PTR2_PROMOTED]], 1431655765
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[TMP0]], 1431655767
; CHECK-NEXT:    [[TMP2:%.*]] = zext i32 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = add nuw nsw i64 [[TMP2]], 1
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ule i64 [[TMP3]], 2
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[TMP3]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[N_MOD_VF]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 2, i64 [[N_MOD_VF]]
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[DOTCAST:%.*]] = trunc i64 [[N_VEC]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = mul i32 [[DOTCAST]], 3
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[INV_PTR2_PROMOTED]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = mul i64 [[N_VEC]], 128
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr null, i64 [[TMP8]]
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VECTOR_RECUR:%.*]] = phi ptr [ [[INV_PTR_PROMOTED]], %[[VECTOR_PH]] ], [ [[NEXT_GEP3:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[DOTCAST1:%.*]] = trunc i64 [[INDEX]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = mul i32 [[DOTCAST1]], 3
; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = add i32 [[INV_PTR2_PROMOTED]], [[TMP10]]
; CHECK-NEXT:    [[TMP11:%.*]] = add i32 [[OFFSET_IDX]], 3
; CHECK-NEXT:    [[OFFSET_IDX2:%.*]] = mul i64 [[INDEX]], 128
; CHECK-NEXT:    [[TMP12:%.*]] = add i64 [[OFFSET_IDX2]], 128
; CHECK-NEXT:    [[NEXT_GEP:%.*]] = getelementptr i8, ptr null, i64 [[OFFSET_IDX2]]
; CHECK-NEXT:    [[NEXT_GEP3]] = getelementptr i8, ptr null, i64 [[TMP12]]
; CHECK-NEXT:    store ptr [[VECTOR_RECUR]], ptr [[NEXT_GEP]], align 8
; CHECK-NEXT:    store ptr [[NEXT_GEP]], ptr [[NEXT_GEP3]], align 8
; CHECK-NEXT:    store ptr [[NEXT_GEP3]], ptr [[INV_PTR]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = add i32 [[TMP11]], 3
; CHECK-NEXT:    store i32 [[TMP13]], ptr [[INV_PTR2]], align 8
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2
; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP14]], label %[[LOOP_1:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[LOOP_1]]:
; CHECK-NEXT:    br label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
;
entry:
  br i1 %flag, label %loop.1.lr.ph, label %exit

loop.1.lr.ph:                                     ; preds = %entry
  %inv_ptr = getelementptr inbounds nuw i8, ptr %p, i64 24
  %inv_ptr2 = getelementptr inbounds nuw i8, ptr %p, i64 40
  %inv_ptr.promoted = load ptr, ptr %inv_ptr, align 8
  %inv_ptr2.promoted = load i32, ptr %inv_ptr2, align 8
  br label %loop.1

loop.1:                                           ; preds = %loop.5, %loop.1.lr.ph
  %load23 = phi i32 [ %inv_ptr2.promoted, %loop.1.lr.ph ], [ %sadd_val, %loop.5 ]
  %load12 = phi ptr [ %inv_ptr.promoted, %loop.1.lr.ph ], [ %phi_ptr1, %loop.5 ]
  %phi_ptr1 = phi ptr [ null, %loop.1.lr.ph ], [ %phi_ptr_next, %loop.5 ]
  %phi_ptr_next = getelementptr i8, ptr %phi_ptr1, i64 128
  store ptr %load12, ptr %phi_ptr1, align 8
  br label %loop.3

loop.3:                                           ; preds = %loop.1
  store ptr %phi_ptr1, ptr %inv_ptr, align 8
  %sadd_val = add i32 %load23, 3
  %sadd_ov = icmp eq i32 %sadd_val, 8
  br i1 %sadd_ov, label %loop.4, label %loop.5

loop.4:                                           ; preds = %loop.3
  store volatile i32 0, ptr %p, align 4
  unreachable

loop.5:                                           ; preds = %loop.3
  store i32 %sadd_val, ptr %inv_ptr2, align 8
  br label %loop.1

exit:                                             ; preds = %entry
  ret void
}

attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #1 = { nocallback nocreateundeforpoison nofree nosync nounwind speculatable willreturn memory(none) }
;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.isvectorized", i32 1}
; CHECK: [[META2]] = !{!"llvm.loop.unroll.runtime.disable"}
;.
