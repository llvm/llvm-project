; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s  -loop-vectorize -force-vector-interleave=1 -force-vector-width=4 -dce -instcombine -S
; RUN: opt < %s -debugify -loop-vectorize -S | FileCheck %s --check-prefix=DEBUGLOC

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"

@a = common global i8 0, align 1
@b = common global i8 0, align 1

define void @f() nounwind uwtable ssp {
; Check that the induction phis and adds have debug location.
;
; DEBUGLOC-LABEL: @f(
; DEBUGLOC-NEXT:  scalar.ph:
; DEBUGLOC-NEXT:    store i8 0, i8* inttoptr (i64 1 to i8*), align 1, !dbg [[DBG22:![0-9]+]]
; DEBUGLOC-NEXT:    [[TMP0:%.*]] = load i8, i8* @a, align 1, !dbg [[DBG23:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8 [[TMP0]], metadata [[META9:![0-9]+]], metadata !DIExpression()), !dbg [[DBG23]]
; DEBUGLOC-NEXT:    br i1 false, label [[SCALAR_PH1:%.*]], label [[VECTOR_PH:%.*]], !dbg [[DBG24:![0-9]+]]
; DEBUGLOC:       vector.ph:
; DEBUGLOC-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i8> poison, i8 [[TMP0]], i32 0, !dbg [[DBG24]]
; DEBUGLOC-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i8> [[BROADCAST_SPLATINSERT]], <4 x i8> poison, <4 x i32> zeroinitializer, !dbg [[DBG24]]
; DEBUGLOC-NEXT:    br label [[VECTOR_BODY:%.*]], !dbg [[DBG24]]
; DEBUGLOC:       vector.body:
; DEBUGLOC-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; DEBUGLOC-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i8> [ <i8 0, i8 1, i8 1, i8 1>, [[VECTOR_PH]] ], [ [[TMP3:%.*]], [[VECTOR_BODY]] ]
; DEBUGLOC-NEXT:    [[VEC_IND:%.*]] = phi <4 x i8> [ undef, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ], !dbg [[DBG25:![0-9]+]]
; DEBUGLOC-NEXT:    [[TMP1:%.*]] = icmp ne <4 x i8> [[VEC_IND]], zeroinitializer, !dbg [[DBG26:![0-9]+]]
; DEBUGLOC-NEXT:    [[TMP2:%.*]] = select <4 x i1> [[TMP1]], <4 x i8> [[VEC_IND]], <4 x i8> [[BROADCAST_SPLAT]], !dbg [[DBG27:![0-9]+]]
; DEBUGLOC-NEXT:    [[TMP3]] = mul <4 x i8> [[VEC_PHI]], [[TMP2]], !dbg [[DBG28:![0-9]+]]
; DEBUGLOC-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 4
; DEBUGLOC-NEXT:    [[VEC_IND_NEXT]] = add <4 x i8> [[VEC_IND]], <i8 4, i8 4, i8 4, i8 4>, !dbg [[DBG25]]
; DEBUGLOC-NEXT:    [[TMP4:%.*]] = icmp eq i32 [[INDEX_NEXT]], 16
; DEBUGLOC-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP29:![0-9]+]]
; DEBUGLOC:       middle.block:
; DEBUGLOC-NEXT:    [[TMP5:%.*]] = call i8 @llvm.vector.reduce.mul.v4i8(<4 x i8> [[TMP3]]), !dbg [[DBG31:![0-9]+]]
; DEBUGLOC-NEXT:    [[CMP_N:%.*]] = icmp eq i32 16, 16, !dbg [[DBG31]]
; DEBUGLOC-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH1]], !dbg [[DBG31]]
; DEBUGLOC:       scalar.ph1:
; DEBUGLOC-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i8 [ undef, [[MIDDLE_BLOCK]] ], [ undef, [[SCALAR_PH:%.*]] ], !dbg [[DBG25]]
; DEBUGLOC-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i8 [ 0, [[SCALAR_PH]] ], [ [[TMP5]], [[MIDDLE_BLOCK]] ]
; DEBUGLOC-NEXT:    br label [[FOR_BODY:%.*]], !dbg [[DBG24]]
; DEBUGLOC:       for.body:
; DEBUGLOC-NEXT:    [[MUL16:%.*]] = phi i8 [ [[BC_MERGE_RDX]], [[SCALAR_PH1]] ], [ [[MUL:%.*]], [[FOR_BODY]] ], !dbg [[DBG32:![0-9]+]]
; DEBUGLOC-NEXT:    [[C_015:%.*]] = phi i8 [ [[BC_RESUME_VAL]], [[SCALAR_PH1]] ], [ [[CONV8:%.*]], [[FOR_BODY]] ], !dbg [[DBG25]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8 [[MUL16]], metadata [[META11:![0-9]+]], metadata !DIExpression()), !dbg [[DBG32]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8 [[C_015]], metadata [[META12:![0-9]+]], metadata !DIExpression()), !dbg [[DBG25]]
; DEBUGLOC-NEXT:    [[CONV2:%.*]] = sext i8 [[C_015]] to i32, !dbg [[DBG33:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32 [[CONV2]], metadata [[META13:![0-9]+]], metadata !DIExpression()), !dbg [[DBG33]]
; DEBUGLOC-NEXT:    [[TOBOOL:%.*]] = icmp ne i8 [[C_015]], 0, !dbg [[DBG26]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i1 [[TOBOOL]], metadata [[META15:![0-9]+]], metadata !DIExpression()), !dbg [[DBG26]]
; DEBUGLOC-NEXT:    [[DOTSINK:%.*]] = select i1 [[TOBOOL]], i8 [[C_015]], i8 [[TMP0]], !dbg [[DBG27]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8 [[DOTSINK]], metadata [[META16:![0-9]+]], metadata !DIExpression()), !dbg [[DBG27]]
; DEBUGLOC-NEXT:    [[MUL]] = mul i8 [[MUL16]], [[DOTSINK]], !dbg [[DBG28]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8 [[MUL]], metadata [[META17:![0-9]+]], metadata !DIExpression()), !dbg [[DBG28]]
; DEBUGLOC-NEXT:    [[ADD:%.*]] = add nsw i32 [[CONV2]], 1, !dbg [[DBG34:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32 [[ADD]], metadata [[META18:![0-9]+]], metadata !DIExpression()), !dbg [[DBG34]]
; DEBUGLOC-NEXT:    [[CONV8]] = trunc i32 [[ADD]] to i8, !dbg [[DBG35:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i8 [[CONV8]], metadata [[META19:![0-9]+]], metadata !DIExpression()), !dbg [[DBG35]]
; DEBUGLOC-NEXT:    [[SEXT:%.*]] = shl i32 [[ADD]], 24, !dbg [[DBG36:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i32 [[SEXT]], metadata [[META20:![0-9]+]], metadata !DIExpression()), !dbg [[DBG36]]
; DEBUGLOC-NEXT:    [[PHITMP14:%.*]] = icmp slt i32 [[SEXT]], 268435456, !dbg [[DBG37:![0-9]+]]
; DEBUGLOC-NEXT:    call void @llvm.dbg.value(metadata i1 [[PHITMP14]], metadata [[META21:![0-9]+]], metadata !DIExpression()), !dbg [[DBG37]]
; DEBUGLOC-NEXT:    br i1 [[PHITMP14]], label [[FOR_BODY]], label [[FOR_END]], !dbg [[DBG31]], !llvm.loop [[LOOP38:![0-9]+]]
; DEBUGLOC:       for.end:
; DEBUGLOC-NEXT:    [[MUL_LCSSA:%.*]] = phi i8 [ [[MUL]], [[FOR_BODY]] ], [ [[TMP5]], [[MIDDLE_BLOCK]] ], !dbg [[DBG28]]
; DEBUGLOC-NEXT:    store i8 [[MUL_LCSSA]], i8* @b, align 1, !dbg [[DBG40:![0-9]+]]
; DEBUGLOC-NEXT:    ret void, !dbg [[DBG41:![0-9]+]]
;

scalar.ph:
  store i8 0, i8* inttoptr (i64 1 to i8*), align 1
  %0 = load i8, i8* @a, align 1
  br label %for.body

for.body:
  %mul16 = phi i8 [ 0, %scalar.ph ], [ %mul, %for.body ]              ; <------- i8 induction var.
  %c.015 = phi i8 [ undef, %scalar.ph ], [ %conv8, %for.body ]
  %conv2 = sext i8 %c.015 to i32
  %tobool = icmp ne i8 %c.015, 0
  %.sink = select i1 %tobool, i8 %c.015, i8 %0
  %mul = mul i8 %mul16, %.sink
  %add = add nsw i32 %conv2, 1
  %conv8 = trunc i32 %add to i8
  %sext = shl i32 %add, 24
  %phitmp14 = icmp slt i32 %sext, 268435456
  br i1 %phitmp14, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  store i8 %mul, i8* @b, align 1
  ret void
}

; Check that the location of the new phi comes from %c.015 = phi i8
