; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --version 6
; RUN: opt -S -passes=loop-vectorize -force-vector-width=4 -force-vector-interleave=1 \
; RUN:   -enable-interleaved-mem-accesses=true < %s | FileCheck %s

; Make sure the vectorizer can handle this loop: The strided load is only used
; by the loop's exit condition, which is not vectorized, and is therefore
; considered uniform while also forming an interleave group.

%0 = type { ptr, i32 }

@0 = internal unnamed_addr constant [59 x %0] [%0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 {ptr null, i32 258}, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer, %0 zeroinitializer, %0 zeroinitializer,
%0 zeroinitializer], align 8

define dso_local void @test_dead_load(i32 %arg) {
; CHECK-LABEL: define dso_local void @test_dead_load(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:  [[BB1:.*:]]
; CHECK-NEXT:    br label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i64 [[INDEX_NEXT]], 52
; CHECK-NEXT:    br i1 [[TMP0]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    br label %[[SCALAR_PH:.*]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    br label %[[BB2:.*]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    [[TMP:%.*]] = phi ptr [ [[TMP6:%.*]], %[[BB2]] ], [ getelementptr (i8, ptr @[[GLOB0:[0-9]+]], i64 832), %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[TMP0]], ptr [[TMP]], i64 0, i32 1
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 8
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[TMP4]], 258
; CHECK-NEXT:    [[TMP6]] = getelementptr inbounds [[TMP0]], ptr [[TMP]], i64 1
; CHECK-NEXT:    br i1 [[TMP5]], label %[[BB65:.*]], label %[[BB2]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK:       [[BB65]]:
; CHECK-NEXT:    unreachable
;
bb1:
  br label %bb2

bb2:
  %tmp = phi ptr [ %tmp6, %bb2 ], [ @0, %bb1 ]
  %tmp3 = getelementptr inbounds %0, ptr %tmp, i64 0, i32 1
  %tmp4 = load i32, ptr %tmp3, align 8
  %tmp5 = icmp eq i32 %tmp4, 258
  %tmp6 = getelementptr inbounds %0, ptr %tmp, i64 1
  br i1 %tmp5, label %bb65, label %bb2

bb65:
  unreachable
}
