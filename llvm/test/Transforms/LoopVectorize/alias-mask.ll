; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --filter-out-after "^scalar.ph:" --version 5
; RUN: opt -S -force-partial-aliasing-vectorization -force-vector-width=2 -passes=loop-vectorize  %s | FileCheck %s
; RUN: opt -S -force-partial-aliasing-vectorization -force-vector-interleave=2 -force-vector-width=2 -passes=loop-vectorize  %s | FileCheck %s
; RUN: opt -S -force-partial-aliasing-vectorization -epilogue-vectorization-force-VF=2 -force-vector-interleave=2 -force-vector-width=2 -passes=loop-vectorize  %s | FileCheck %s

; Note: -force-vector-interleave and -epilogue-vectorization-force-VF does not
; change the results as alias-masking is not supported with interleaving or
; epilogue vectorization.

define void @alias_mask(ptr noalias %a, ptr %b, ptr %c, i64 %n) {
; CHECK-LABEL: define void @alias_mask(
; CHECK-SAME: ptr noalias [[A:%.*]], ptr [[B:%.*]], ptr [[C:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[B3:%.*]] = ptrtoaddr ptr [[B]] to i64
; CHECK-NEXT:    [[C2:%.*]] = ptrtoaddr ptr [[C]] to i64
; CHECK-NEXT:    [[CMP11:%.*]] = icmp sgt i64 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP11]], label %[[FOR_BODY_PREHEADER:.*]], [[EXIT:label %.*]]
; CHECK:       [[FOR_BODY_PREHEADER]]:
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 2
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_MIN_VF_CHECK:.*]]
; CHECK:       [[VECTOR_MIN_VF_CHECK]]:
; CHECK-NEXT:    [[TMP12:%.*]] = inttoptr i64 [[B3]] to ptr
; CHECK-NEXT:    [[TMP9:%.*]] = inttoptr i64 [[C2]] to ptr
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x i1> @llvm.loop.dependence.war.mask.v2i1(ptr [[TMP12]], ptr [[TMP9]], i64 1)
; CHECK-NEXT:    [[TMP3:%.*]] = zext <2 x i1> [[TMP2]] to <2 x i32>
; CHECK-NEXT:    [[TMP11:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP3]])
; CHECK-NEXT:    [[NUM_ACTIVE_LANES:%.*]] = zext i32 [[TMP11]] to i64
; CHECK-NEXT:    [[CMP_VF:%.*]] = icmp ult i64 [[NUM_ACTIVE_LANES]], 2
; CHECK-NEXT:    br i1 [[CMP_VF]], label %[[SCALAR_PH]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N]], [[NUM_ACTIVE_LANES]]
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX1:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[PRED_STORE_CONTINUE6:.*]] ]
; CHECK-NEXT:    [[INDEX:%.*]] = add i64 [[INDEX1]], 0
; CHECK-NEXT:    [[TMP6:%.*]] = add i64 [[INDEX1]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <2 x i1> [[TMP2]], i32 0
; CHECK-NEXT:    br i1 [[TMP8]], label %[[PRED_LOAD_IF:.*]], label %[[PRED_LOAD_CONTINUE:.*]]
; CHECK:       [[PRED_LOAD_IF]]:
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[INDEX]]
; CHECK-NEXT:    [[TMP28:%.*]] = load i8, ptr [[TMP7]], align 1
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x i8> poison, i8 [[TMP28]], i32 0
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i8, ptr [[B]], i64 [[INDEX]]
; CHECK-NEXT:    [[TMP33:%.*]] = load i8, ptr [[TMP13]], align 1
; CHECK-NEXT:    [[TMP34:%.*]] = insertelement <2 x i8> poison, i8 [[TMP33]], i32 0
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE]]
; CHECK:       [[PRED_LOAD_CONTINUE]]:
; CHECK-NEXT:    [[TMP14:%.*]] = phi <2 x i8> [ poison, %[[VECTOR_BODY]] ], [ [[TMP10]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP35:%.*]] = phi <2 x i8> [ poison, %[[VECTOR_BODY]] ], [ [[TMP34]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP36:%.*]] = extractelement <2 x i1> [[TMP2]], i32 1
; CHECK-NEXT:    br i1 [[TMP36]], label %[[PRED_LOAD_IF3:.*]], label %[[PRED_LOAD_CONTINUE4:.*]]
; CHECK:       [[PRED_LOAD_IF3]]:
; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[TMP6]]
; CHECK-NEXT:    [[TMP18:%.*]] = load i8, ptr [[TMP17]], align 1
; CHECK-NEXT:    [[TMP19:%.*]] = insertelement <2 x i8> [[TMP14]], i8 [[TMP18]], i32 1
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds i8, ptr [[B]], i64 [[TMP6]]
; CHECK-NEXT:    [[TMP21:%.*]] = load i8, ptr [[TMP20]], align 1
; CHECK-NEXT:    [[TMP22:%.*]] = insertelement <2 x i8> [[TMP35]], i8 [[TMP21]], i32 1
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE4]]
; CHECK:       [[PRED_LOAD_CONTINUE4]]:
; CHECK-NEXT:    [[TMP23:%.*]] = phi <2 x i8> [ [[TMP14]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP19]], %[[PRED_LOAD_IF3]] ]
; CHECK-NEXT:    [[TMP24:%.*]] = phi <2 x i8> [ [[TMP35]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP22]], %[[PRED_LOAD_IF3]] ]
; CHECK-NEXT:    [[TMP25:%.*]] = select <2 x i1> [[TMP2]], <2 x i8> [[TMP23]], <2 x i8> splat (i8 1)
; CHECK-NEXT:    [[TMP26:%.*]] = sdiv <2 x i8> [[TMP24]], [[TMP25]]
; CHECK-NEXT:    [[TMP27:%.*]] = extractelement <2 x i1> [[TMP2]], i32 0
; CHECK-NEXT:    br i1 [[TMP27]], label %[[PRED_STORE_IF:.*]], label %[[PRED_STORE_CONTINUE:.*]]
; CHECK:       [[PRED_STORE_IF]]:
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i8, ptr [[C]], i64 [[INDEX]]
; CHECK-NEXT:    [[TMP29:%.*]] = extractelement <2 x i8> [[TMP26]], i32 0
; CHECK-NEXT:    store i8 [[TMP29]], ptr [[TMP15]], align 1
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE]]
; CHECK:       [[PRED_STORE_CONTINUE]]:
; CHECK-NEXT:    [[TMP30:%.*]] = extractelement <2 x i1> [[TMP2]], i32 1
; CHECK-NEXT:    br i1 [[TMP30]], label %[[PRED_STORE_IF5:.*]], label %[[PRED_STORE_CONTINUE6]]
; CHECK:       [[PRED_STORE_IF5]]:
; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr inbounds i8, ptr [[C]], i64 [[TMP6]]
; CHECK-NEXT:    [[TMP32:%.*]] = extractelement <2 x i8> [[TMP26]], i32 1
; CHECK-NEXT:    store i8 [[TMP32]], ptr [[TMP31]], align 1
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE6]]
; CHECK:       [[PRED_STORE_CONTINUE6]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX1]], [[NUM_ACTIVE_LANES]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP16]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], [[EXIT_LOOPEXIT:label %.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
;

entry:
  %cmp11 = icmp sgt i64 %n, 0
  br i1 %cmp11, label %for.body, label %exit

for.body:                                         ; preds = %for.body.preheader, %for.body
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.body ]
  %gep.a = getelementptr inbounds i8, ptr %a, i64 %iv
  %load.a = load i8, ptr %gep.a, align 1
  %gep.b = getelementptr inbounds i8, ptr %b, i64 %iv
  %load.b = load i8, ptr %gep.b, align 1
  %div = sdiv i8 %load.b, %load.a
  %gep.c = getelementptr inbounds i8, ptr %c, i64 %iv
  store i8 %div, ptr %gep.c, align 1
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, %n
  br i1 %exitcond.not, label %exit, label %for.body

exit:                                 ; preds = %for.body, %entry
  ret void
}

; Checks using a scalar outside the loop, with requires extracting the last
; active element.
define i8 @alias_masking_exit_value(ptr %ptrA, ptr %ptrB) {
; CHECK-LABEL: define i8 @alias_masking_exit_value(
; CHECK-SAME: ptr [[PTRA:%.*]], ptr [[PTRB:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[PTRA2:%.*]] = ptrtoaddr ptr [[PTRA]] to i64
; CHECK-NEXT:    [[PTRB1:%.*]] = ptrtoaddr ptr [[PTRB]] to i64
; CHECK-NEXT:    br label %[[VECTOR_MIN_VF_CHECK:.*]]
; CHECK:       [[VECTOR_MIN_VF_CHECK]]:
; CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[PTRA2]] to ptr
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr i64 [[PTRB1]] to ptr
; CHECK-NEXT:    [[TMP4:%.*]] = call <2 x i1> @llvm.loop.dependence.war.mask.v2i1(ptr [[TMP2]], ptr [[TMP3]], i64 1)
; CHECK-NEXT:    [[TMP5:%.*]] = zext <2 x i1> [[TMP4]] to <2 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP5]])
; CHECK-NEXT:    [[NUM_ACTIVE_LANES:%.*]] = zext i32 [[TMP6]] to i64
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i64 [[NUM_ACTIVE_LANES]] to i32
; CHECK-NEXT:    [[CMP_VF:%.*]] = icmp ult i32 [[TMP7]], 2
; CHECK-NEXT:    br i1 [[CMP_VF]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[TMP9:%.*]] = trunc i32 [[TMP7]] to i8
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i8> poison, i8 [[TMP9]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i8> [[BROADCAST_SPLATINSERT]], <2 x i8> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX1:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[PRED_STORE_CONTINUE6:.*]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <2 x i8> [ <i8 0, i8 1>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[PRED_STORE_CONTINUE6]] ]
; CHECK-NEXT:    [[INDEX:%.*]] = add i32 [[INDEX1]], 0
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[INDEX1]], 1
; CHECK-NEXT:    [[TMP21:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-NEXT:    br i1 [[TMP21]], label %[[PRED_LOAD_IF:.*]], label %[[PRED_LOAD_CONTINUE:.*]]
; CHECK:       [[PRED_LOAD_IF]]:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i8, ptr [[PTRA]], i32 [[INDEX]]
; CHECK-NEXT:    [[TMP29:%.*]] = load i8, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x i8> poison, i8 [[TMP29]], i32 0
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE]]
; CHECK:       [[PRED_LOAD_CONTINUE]]:
; CHECK-NEXT:    [[TMP13:%.*]] = phi <2 x i8> [ poison, %[[VECTOR_BODY]] ], [ [[TMP12]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP14:%.*]] = extractelement <2 x i1> [[TMP4]], i32 1
; CHECK-NEXT:    br i1 [[TMP14]], label %[[PRED_LOAD_IF3:.*]], label %[[PRED_LOAD_CONTINUE4:.*]]
; CHECK:       [[PRED_LOAD_IF3]]:
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i8, ptr [[PTRA]], i32 [[TMP8]]
; CHECK-NEXT:    [[TMP16:%.*]] = load i8, ptr [[TMP15]], align 1
; CHECK-NEXT:    [[TMP17:%.*]] = insertelement <2 x i8> [[TMP13]], i8 [[TMP16]], i32 1
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE4]]
; CHECK:       [[PRED_LOAD_CONTINUE4]]:
; CHECK-NEXT:    [[TMP18:%.*]] = phi <2 x i8> [ [[TMP13]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP17]], %[[PRED_LOAD_IF3]] ]
; CHECK-NEXT:    [[TMP19:%.*]] = add <2 x i8> [[VEC_IND]], [[TMP18]]
; CHECK-NEXT:    [[TMP20:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-NEXT:    br i1 [[TMP20]], label %[[PRED_STORE_IF:.*]], label %[[PRED_STORE_CONTINUE:.*]]
; CHECK:       [[PRED_STORE_IF]]:
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i8, ptr [[PTRB]], i32 [[INDEX]]
; CHECK-NEXT:    [[TMP22:%.*]] = extractelement <2 x i8> [[TMP19]], i32 0
; CHECK-NEXT:    store i8 [[TMP22]], ptr [[TMP11]], align 1
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE]]
; CHECK:       [[PRED_STORE_CONTINUE]]:
; CHECK-NEXT:    [[TMP23:%.*]] = extractelement <2 x i1> [[TMP4]], i32 1
; CHECK-NEXT:    br i1 [[TMP23]], label %[[PRED_STORE_IF5:.*]], label %[[PRED_STORE_CONTINUE6]]
; CHECK:       [[PRED_STORE_IF5]]:
; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr inbounds i8, ptr [[PTRB]], i32 [[TMP8]]
; CHECK-NEXT:    [[TMP25:%.*]] = extractelement <2 x i8> [[TMP19]], i32 1
; CHECK-NEXT:    store i8 [[TMP25]], ptr [[TMP24]], align 1
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE6]]
; CHECK:       [[PRED_STORE_CONTINUE6]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX1]], [[TMP7]]
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <2 x i8> [[VEC_IND]], [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[TMP26:%.*]] = icmp eq i32 [[INDEX_NEXT]], 1000
; CHECK-NEXT:    br i1 [[TMP26]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[TMP27:%.*]] = xor <2 x i1> [[TMP4]], splat (i1 true)
; CHECK-NEXT:    [[FIRST_INACTIVE_LANE:%.*]] = call i64 @llvm.experimental.cttz.elts.i64.v2i1(<2 x i1> [[TMP27]], i1 false)
; CHECK-NEXT:    [[LAST_ACTIVE_LANE:%.*]] = sub i64 [[FIRST_INACTIVE_LANE]], 1
; CHECK-NEXT:    [[TMP28:%.*]] = extractelement <2 x i8> [[TMP19]], i64 [[LAST_ACTIVE_LANE]]
; CHECK-NEXT:    br [[EXIT:label %.*]]
; CHECK:       [[SCALAR_PH]]:
;
entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %gepA = getelementptr inbounds i8, ptr %ptrA, i32 %iv
  %gepB = getelementptr inbounds i8, ptr %ptrB, i32 %iv
  %loadA = load i8, ptr %gepA
  %iv.trunc = trunc i32 %iv to i8
  %add = add i8 %iv.trunc, %loadA
  store i8 %add, ptr %gepB
  %iv.next = add nsw i32 %iv, 1
  %ec = icmp eq i32 %iv.next, 1000
  br i1 %ec, label %exit, label %loop

exit:
  %exit.value = phi i8 [ %add, %loop ]
  ret i8 %exit.value
}

;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.isvectorized", i32 1}
; CHECK: [[META2]] = !{!"llvm.loop.unroll.runtime.disable"}
; CHECK: [[LOOP4]] = distinct !{[[LOOP4]], [[META1]], [[META2]]}
;.
