; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=loop-vectorize -force-vector-width=2 -S | FileCheck %s

define void @d() {
; CHECK-LABEL: define void @d() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[I7:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[I3:%.*]] = load float, ptr null, align 4
; CHECK-NEXT:    [[I4:%.*]] = getelementptr float, ptr @d, i64 [[I]]
; CHECK-NEXT:    [[I5:%.*]] = tail call i1 @llvm.is.fpclass.f32(float 0.000000e+00, i32 0)
; CHECK-NEXT:    [[I6:%.*]] = select i1 [[I5]], float 0.000000e+00, float 0.000000e+00
; CHECK-NEXT:    store float [[I6]], ptr [[I4]], align 4
; CHECK-NEXT:    [[I7]] = add i64 [[I]], 1
; CHECK-NEXT:    [[I8:%.*]] = icmp eq i64 [[I7]], 0
; CHECK-NEXT:    br i1 [[I8]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i7, %loop ]
  %i3 = load float, ptr null, align 4
  %i4 = getelementptr float, ptr @d, i64 %i
  %i5 = tail call i1 @llvm.is.fpclass.f32(float 0.0, i32 0)
  %i6 = select i1 %i5, float 0.0, float 0.0
  store float %i6, ptr %i4, align 4
  %i7 = add i64 %i, 1
  %i8 = icmp eq i64 %i7, 0
  br i1 %i8, label %exit, label %loop

exit:
  ret void
}

declare i1 @llvm.is.fpclass.f32(float, i32 immarg)
