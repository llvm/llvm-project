; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=loop-vectorize -mtriple=aarch64-unknown-linux-gnu -S | FileCheck %s --check-prefix=AARCH64
; RUN: opt < %s -passes=loop-vectorize -mtriple=x86_64-unknown-linux-gnu -S | FileCheck %s --check-prefix=X86_64

; Testcase extraÃ­do de ElemAttribute.cpp
; Foca no loop while.body que copia elementos i16

target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"

; This test introduces a case where a memory induction variable
; stops vectorization. This test will be updated when hoisting loads
; for this memory induction variable and vectorization is possible.
define void @test_copy_loop(ptr %theFirst, ptr %theLast, ptr %dest_base, ptr %m_size_ptr) {
; AARCH64-LABEL: define void @test_copy_loop(
; AARCH64-SAME: ptr [[THEFIRST:%.*]], ptr [[THELAST:%.*]], ptr [[DEST_BASE:%.*]], ptr [[M_SIZE_PTR:%.*]]) {
; AARCH64-NEXT:  [[ENTRY:.*:]]
; AARCH64-NEXT:    [[TMP0:%.*]] = load i64, ptr [[M_SIZE_PTR]], align 8
; AARCH64-NEXT:    [[ADD_PTR_I:%.*]] = getelementptr inbounds nuw i16, ptr [[DEST_BASE]], i64 [[TMP0]]
; AARCH64-NEXT:    [[CMP_NOT:%.*]] = icmp eq ptr [[THEFIRST]], [[THELAST]]
; AARCH64-NEXT:    br i1 [[CMP_NOT]], label %[[CLEANUP:.*]], label %[[WHILE_BODY_PREHEADER:.*]]
; AARCH64:       [[WHILE_BODY_PREHEADER]]:
; AARCH64-NEXT:    br label %[[WHILE_BODY:.*]]
; AARCH64:       [[WHILE_BODY]]:
; AARCH64-NEXT:    [[THEFIRST_ADDR_0112:%.*]] = phi ptr [ [[INCDEC_PTR9:%.*]], %[[WHILE_BODY]] ], [ [[THEFIRST]], %[[WHILE_BODY_PREHEADER]] ]
; AARCH64-NEXT:    [[THEPOINTER_0111:%.*]] = phi ptr [ [[INCDEC_PTR:%.*]], %[[WHILE_BODY]] ], [ [[ADD_PTR_I]], %[[WHILE_BODY_PREHEADER]] ]
; AARCH64-NEXT:    [[TMP1:%.*]] = load i16, ptr [[THEFIRST_ADDR_0112]], align 2
; AARCH64-NEXT:    store i16 [[TMP1]], ptr [[THEPOINTER_0111]], align 2
; AARCH64-NEXT:    [[INCDEC_PTR]] = getelementptr inbounds nuw i8, ptr [[THEPOINTER_0111]], i64 2
; AARCH64-NEXT:    [[TMP2:%.*]] = load i64, ptr [[M_SIZE_PTR]], align 8
; AARCH64-NEXT:    [[INC:%.*]] = add i64 [[TMP2]], 1
; AARCH64-NEXT:    store i64 [[INC]], ptr [[M_SIZE_PTR]], align 8
; AARCH64-NEXT:    [[INCDEC_PTR9]] = getelementptr inbounds nuw i8, ptr [[THEFIRST_ADDR_0112]], i64 2
; AARCH64-NEXT:    [[CMP7_NOT:%.*]] = icmp eq ptr [[INCDEC_PTR9]], [[THELAST]]
; AARCH64-NEXT:    br i1 [[CMP7_NOT]], label %[[CLEANUP_LOOPEXIT:.*]], label %[[WHILE_BODY]]
; AARCH64:       [[CLEANUP_LOOPEXIT]]:
; AARCH64-NEXT:    br label %[[CLEANUP]]
; AARCH64:       [[CLEANUP]]:
; AARCH64-NEXT:    ret void
;
; X86_64-LABEL: define void @test_copy_loop(
; X86_64-SAME: ptr [[THEFIRST:%.*]], ptr [[THELAST:%.*]], ptr [[DEST_BASE:%.*]], ptr [[M_SIZE_PTR:%.*]]) {
; X86_64-NEXT:  [[ENTRY:.*:]]
; X86_64-NEXT:    [[TMP0:%.*]] = load i64, ptr [[M_SIZE_PTR]], align 8
; X86_64-NEXT:    [[ADD_PTR_I:%.*]] = getelementptr inbounds nuw i16, ptr [[DEST_BASE]], i64 [[TMP0]]
; X86_64-NEXT:    [[CMP_NOT:%.*]] = icmp eq ptr [[THEFIRST]], [[THELAST]]
; X86_64-NEXT:    br i1 [[CMP_NOT]], label %[[CLEANUP:.*]], label %[[WHILE_BODY_PREHEADER:.*]]
; X86_64:       [[WHILE_BODY_PREHEADER]]:
; X86_64-NEXT:    br label %[[WHILE_BODY:.*]]
; X86_64:       [[WHILE_BODY]]:
; X86_64-NEXT:    [[THEFIRST_ADDR_0112:%.*]] = phi ptr [ [[INCDEC_PTR9:%.*]], %[[WHILE_BODY]] ], [ [[THEFIRST]], %[[WHILE_BODY_PREHEADER]] ]
; X86_64-NEXT:    [[THEPOINTER_0111:%.*]] = phi ptr [ [[INCDEC_PTR:%.*]], %[[WHILE_BODY]] ], [ [[ADD_PTR_I]], %[[WHILE_BODY_PREHEADER]] ]
; X86_64-NEXT:    [[TMP1:%.*]] = load i16, ptr [[THEFIRST_ADDR_0112]], align 2
; X86_64-NEXT:    store i16 [[TMP1]], ptr [[THEPOINTER_0111]], align 2
; X86_64-NEXT:    [[INCDEC_PTR]] = getelementptr inbounds nuw i8, ptr [[THEPOINTER_0111]], i64 2
; X86_64-NEXT:    [[TMP2:%.*]] = load i64, ptr [[M_SIZE_PTR]], align 8
; X86_64-NEXT:    [[INC:%.*]] = add i64 [[TMP2]], 1
; X86_64-NEXT:    store i64 [[INC]], ptr [[M_SIZE_PTR]], align 8
; X86_64-NEXT:    [[INCDEC_PTR9]] = getelementptr inbounds nuw i8, ptr [[THEFIRST_ADDR_0112]], i64 2
; X86_64-NEXT:    [[CMP7_NOT:%.*]] = icmp eq ptr [[INCDEC_PTR9]], [[THELAST]]
; X86_64-NEXT:    br i1 [[CMP7_NOT]], label %[[CLEANUP_LOOPEXIT:.*]], label %[[WHILE_BODY]]
; X86_64:       [[CLEANUP_LOOPEXIT]]:
; X86_64-NEXT:    br label %[[CLEANUP]]
; X86_64:       [[CLEANUP]]:
; X86_64-NEXT:    ret void
;

entry:
  %0 = load i64, ptr %m_size_ptr, align 8
  %add.ptr.i = getelementptr inbounds nuw i16, ptr %dest_base, i64 %0
  %cmp.not = icmp eq ptr %theFirst, %theLast
  br i1 %cmp.not, label %cleanup, label %while.body.preheader

while.body.preheader:
  br label %while.body

while.body:
  %theFirst.addr.0112 = phi ptr [ %incdec.ptr9, %while.body ], [ %theFirst, %while.body.preheader ]
  %thePointer.0111 = phi ptr [ %incdec.ptr, %while.body ], [ %add.ptr.i, %while.body.preheader ]
  %1 = load i16, ptr %theFirst.addr.0112, align 2
  store i16 %1, ptr %thePointer.0111, align 2
  %incdec.ptr = getelementptr inbounds nuw i8, ptr %thePointer.0111, i64 2
  %2 = load i64, ptr %m_size_ptr, align 8
  %inc = add i64 %2, 1
  store i64 %inc, ptr %m_size_ptr, align 8
  %incdec.ptr9 = getelementptr inbounds nuw i8, ptr %theFirst.addr.0112, i64 2
  %cmp7.not = icmp eq ptr %incdec.ptr9, %theLast
  br i1 %cmp7.not, label %cleanup.loopexit, label %while.body

cleanup.loopexit:
  br label %cleanup

cleanup:
  ret void
}
