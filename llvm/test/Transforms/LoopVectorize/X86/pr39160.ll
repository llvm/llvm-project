; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --version 6
; RUN: opt -passes=loop-vectorize -S < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1"
target triple = "x86_64-unknown-linux-gnu"

; Make sure that we can compile the test without crash.

define i32 @foo(ptr addrspace(1) %p) {
; CHECK-LABEL: define i32 @foo(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[OUTER:.*]]
; CHECK:       [[OUTER]]:
; CHECK-NEXT:    [[INDVAR:%.*]] = phi i32 [ [[INDVAR_NEXT:%.*]], %[[OUTER_LATCH:.*]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 2, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[OUTER_LATCH]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[INDVAR]], 1
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[TMP0]], 8
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[TMP0]], 8
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i32 [[TMP0]], [[N_MOD_VF]]
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 1, [[N_VEC]]
; CHECK-NEXT:    [[TMP2:%.*]] = mul i32 [[N_VEC]], 2
; CHECK-NEXT:    [[TMP3:%.*]] = add i32 6, [[TMP2]]
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i32> [ zeroinitializer, %[[VECTOR_PH]] ], [ [[TMP4:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI1:%.*]] = phi <4 x i32> [ zeroinitializer, %[[VECTOR_PH]] ], [ [[TMP5:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <4 x i32> [ <i32 6, i32 8, i32 10, i32 12>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[VECTOR_BODY]] ]
; CHECK-NEXT:    [[STEP_ADD:%.*]] = add <4 x i32> [[VEC_IND]], splat (i32 8)
; CHECK-NEXT:    [[TMP4]] = or <4 x i32> [[VEC_PHI]], [[VEC_IND]]
; CHECK-NEXT:    [[TMP5]] = or <4 x i32> [[VEC_PHI1]], [[STEP_ADD]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 8
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <4 x i32> [[STEP_ADD]], splat (i32 8)
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP6]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[BIN_RDX:%.*]] = or <4 x i32> [[TMP5]], [[TMP4]]
; CHECK-NEXT:    [[TMP7:%.*]] = call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> [[BIN_RDX]])
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP0]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], label %[[OUTER_LATCH]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i32 [ [[TMP7]], %[[MIDDLE_BLOCK]] ], [ 0, %[[OUTER]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ [[TMP1]], %[[MIDDLE_BLOCK]] ], [ 1, %[[OUTER]] ]
; CHECK-NEXT:    [[BC_RESUME_VAL2:%.*]] = phi i32 [ [[TMP3]], %[[MIDDLE_BLOCK]] ], [ 6, %[[OUTER]] ]
; CHECK-NEXT:    br label %[[INNER:.*]]
; CHECK:       [[INNER]]:
; CHECK-NEXT:    [[TMP8:%.*]] = phi i32 [ [[TMP10:%.*]], %[[INNER]] ], [ [[BC_MERGE_RDX]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[A:%.*]] = phi i32 [ [[TMP11:%.*]], %[[INNER]] ], [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[B:%.*]] = phi i32 [ [[TMP9:%.*]], %[[INNER]] ], [ [[BC_RESUME_VAL2]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[TMP9]] = add i32 [[B]], 2
; CHECK-NEXT:    [[TMP10]] = or i32 [[TMP8]], [[B]]
; CHECK-NEXT:    [[TMP11]] = add nuw nsw i32 [[A]], 1
; CHECK-NEXT:    [[TMP12:%.*]] = zext i32 [[TMP11]] to i64
; CHECK-NEXT:    [[TMP13:%.*]] = icmp ugt i64 [[IV]], [[TMP12]]
; CHECK-NEXT:    br i1 [[TMP13]], label %[[INNER]], label %[[OUTER_LATCH]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK:       [[OUTER_LATCH]]:
; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi i32 [ [[TMP10]], %[[INNER]] ], [ [[TMP7]], %[[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    store atomic i32 [[DOTLCSSA]], ptr addrspace(1) [[P]] unordered, align 4
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ugt i64 [[IV]], 63
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i32 [[INDVAR]], 1
; CHECK-NEXT:    br i1 [[TMP14]], label %[[EXIT:.*]], label %[[OUTER]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret i32 0
;

entry:
  br label %outer

outer:                                            ; preds = %outer_latch, %entry
  %iv = phi i64 [ 2, %entry ], [ %iv.next, %outer_latch ]
  br label %inner

inner:                                            ; preds = %inner, %outer
  %0 = phi i32 [ %2, %inner ], [ 0, %outer ]
  %a = phi i32 [ %3, %inner ], [ 1, %outer ]
  %b = phi i32 [ %1, %inner ], [ 6, %outer ]
  %1 = add i32 %b, 2
  %2 = or i32 %0, %b
  %3 = add nuw nsw i32 %a, 1
  %4 = zext i32 %3 to i64
  %5 = icmp ugt i64 %iv, %4
  br i1 %5, label %inner, label %outer_latch

outer_latch:                                      ; preds = %inner
  store atomic i32 %2, ptr addrspace(1) %p unordered, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %6 = icmp ugt i64 %iv, 63
  br i1 %6, label %exit, label %outer

exit:                                             ; preds = %outer_latch
  ret i32 0
}
