; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals none --filter-out-after "scalar.ph:" --version 6
; RUN: opt -p loop-vectorize -S %s | FileCheck --check-prefixes=COST %s
; RUN: opt -p loop-vectorize -force-vector-width=2 -force-vector-interleave=1 -S %s | FileCheck --check-prefixes=FORCED %s

target triple = "x86_64-apple-macosx10.7.0"

@x = common global [1024 x x86_fp80] zeroinitializer, align 16

define void @example() {
; COST-LABEL: define void @example() {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP:.*]]
; COST:       [[LOOP]]:
; COST-NEXT:    [[IV:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
; COST-NEXT:    [[CONV:%.*]] = sitofp i64 [[IV]] to x86_fp80
; COST-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [1024 x x86_fp80], ptr @x, i64 0, i64 [[IV]]
; COST-NEXT:    store x86_fp80 [[CONV]], ptr [[ARRAYIDX]], align 16
; COST-NEXT:    [[IV_NEXT]] = add i64 [[IV]], 1
; COST-NEXT:    [[IV_TRUNC:%.*]] = trunc i64 [[IV_NEXT]] to i32
; COST-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[IV_TRUNC]], 1024
; COST-NEXT:    br i1 [[EXITCOND]], label %[[EXIT:.*]], label %[[LOOP]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @example() {
; FORCED-NEXT:  [[ENTRY:.*:]]
; FORCED-NEXT:    br label %[[VECTOR_PH:.*]]
; FORCED:       [[VECTOR_PH]]:
; FORCED-NEXT:    br label %[[VECTOR_BODY:.*]]
; FORCED:       [[VECTOR_BODY]]:
; FORCED-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; FORCED-NEXT:    [[VEC_IND:%.*]] = phi <2 x i64> [ <i64 0, i64 1>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[VECTOR_BODY]] ]
; FORCED-NEXT:    [[TMP0:%.*]] = add i64 [[INDEX]], 0
; FORCED-NEXT:    [[TMP1:%.*]] = add i64 [[INDEX]], 1
; FORCED-NEXT:    [[TMP2:%.*]] = sitofp <2 x i64> [[VEC_IND]] to <2 x x86_fp80>
; FORCED-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [1024 x x86_fp80], ptr @x, i64 0, i64 [[TMP0]]
; FORCED-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [1024 x x86_fp80], ptr @x, i64 0, i64 [[TMP1]]
; FORCED-NEXT:    [[TMP5:%.*]] = extractelement <2 x x86_fp80> [[TMP2]], i32 0
; FORCED-NEXT:    store x86_fp80 [[TMP5]], ptr [[TMP3]], align 16
; FORCED-NEXT:    [[TMP6:%.*]] = extractelement <2 x x86_fp80> [[TMP2]], i32 1
; FORCED-NEXT:    store x86_fp80 [[TMP6]], ptr [[TMP4]], align 16
; FORCED-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2
; FORCED-NEXT:    [[VEC_IND_NEXT]] = add <2 x i64> [[VEC_IND]], splat (i64 2)
; FORCED-NEXT:    [[TMP7:%.*]] = icmp eq i64 [[INDEX_NEXT]], 1024
; FORCED-NEXT:    br i1 [[TMP7]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; FORCED:       [[MIDDLE_BLOCK]]:
; FORCED-NEXT:    br [[EXIT:label %.*]]
; FORCED:       [[SCALAR_PH:.*:]]
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %conv = sitofp i64 %iv to x86_fp80
  %arrayidx = getelementptr inbounds [1024 x x86_fp80], ptr @x, i64 0, i64 %iv
  store x86_fp80 %conv, ptr %arrayidx, align 16
  %iv.next = add i64 %iv, 1
  %iv.trunc = trunc i64 %iv.next to i32
  %exitcond = icmp eq i32 %iv.trunc, 1024
  br i1 %exitcond, label %exit, label %loop

exit:
  ret void
}

define void @test_replicating_store_x86_fp80_cost(i32 %n, ptr %dst) #0 {
; COST-LABEL: define void @test_replicating_store_x86_fp80_cost(
; COST-SAME: i32 [[N:%.*]], ptr [[DST:%.*]]) #[[ATTR0:[0-9]+]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP:.*]]
; COST:       [[LOOP]]:
; COST-NEXT:    [[IV:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[IV_NEXT:%.*]], %[[LOOP]] ]
; COST-NEXT:    [[TMP22:%.*]] = zext i32 [[IV]] to i64
; COST-NEXT:    [[TMP23:%.*]] = getelementptr x86_fp80, ptr [[DST]], i64 [[TMP22]]
; COST-NEXT:    store x86_fp80 0xK00000000000000000000, ptr [[TMP23]], align 16
; COST-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; COST-NEXT:    [[EC:%.*]] = icmp ugt i32 [[IV]], [[N]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @test_replicating_store_x86_fp80_cost(
; FORCED-SAME: i32 [[N:%.*]], ptr [[DST:%.*]]) #[[ATTR0:[0-9]+]] {
; FORCED-NEXT:  [[ENTRY:.*:]]
; FORCED-NEXT:    [[TMP0:%.*]] = add i32 [[N]], 2
; FORCED-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[TMP0]], 2
; FORCED-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_SCEVCHECK:.*]]
; FORCED:       [[VECTOR_SCEVCHECK]]:
; FORCED-NEXT:    [[TMP1:%.*]] = zext i32 [[N]] to i64
; FORCED-NEXT:    [[TMP2:%.*]] = add nuw nsw i64 [[TMP1]], 1
; FORCED-NEXT:    [[TMP3:%.*]] = icmp ugt i64 [[TMP2]], 4294967295
; FORCED-NEXT:    br i1 [[TMP3]], label %[[SCALAR_PH]], label %[[VECTOR_PH:.*]]
; FORCED:       [[VECTOR_PH]]:
; FORCED-NEXT:    [[N_MOD_VF:%.*]] = urem i32 [[TMP0]], 2
; FORCED-NEXT:    [[N_VEC:%.*]] = sub i32 [[TMP0]], [[N_MOD_VF]]
; FORCED-NEXT:    br label %[[VECTOR_BODY:.*]]
; FORCED:       [[VECTOR_BODY]]:
; FORCED-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[VECTOR_BODY]] ]
; FORCED-NEXT:    [[VEC_IND:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[VECTOR_BODY]] ]
; FORCED-NEXT:    [[TMP4:%.*]] = zext <2 x i32> [[VEC_IND]] to <2 x i64>
; FORCED-NEXT:    [[TMP5:%.*]] = extractelement <2 x i64> [[TMP4]], i32 0
; FORCED-NEXT:    [[TMP6:%.*]] = getelementptr x86_fp80, ptr [[DST]], i64 [[TMP5]]
; FORCED-NEXT:    [[TMP7:%.*]] = extractelement <2 x i64> [[TMP4]], i32 1
; FORCED-NEXT:    [[TMP8:%.*]] = getelementptr x86_fp80, ptr [[DST]], i64 [[TMP7]]
; FORCED-NEXT:    store x86_fp80 0xK00000000000000000000, ptr [[TMP6]], align 16
; FORCED-NEXT:    store x86_fp80 0xK00000000000000000000, ptr [[TMP8]], align 16
; FORCED-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 2
; FORCED-NEXT:    [[VEC_IND_NEXT]] = add <2 x i32> [[VEC_IND]], splat (i32 2)
; FORCED-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]
; FORCED-NEXT:    br i1 [[TMP9]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]
; FORCED:       [[MIDDLE_BLOCK]]:
; FORCED-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP0]], [[N_VEC]]
; FORCED-NEXT:    br i1 [[CMP_N]], [[EXIT:label %.*]], label %[[SCALAR_PH]]
; FORCED:       [[SCALAR_PH]]:
;
entry:
  br label %loop

loop:                            ; preds = %loop, %entry
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.ext = zext i32 %iv to i64
  %gep.dst = getelementptr x86_fp80, ptr %dst, i64 %iv.ext
  store x86_fp80 0xK00000000000000000000, ptr %gep.dst, align 16
  %iv.next = add i32 %iv, 1
  %ec = icmp ugt i32 %iv, %n
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

attributes #0 = { "target-cpu"="skylake-avx512" }
