; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=loop-vectorize -mtriple=x86_64-unknown-linux-gnu -S < %s | FileCheck %s

; The test checks that there is no assert caused by issue described in PR35432

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = common local_unnamed_addr global [192 x [192 x i32]] zeroinitializer, align 16

define i32 @main(ptr %ptr) {
; CHECK-LABEL: @main(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[S:%.*]] = alloca i16, align 2
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[I]])
; CHECK-NEXT:    store i32 0, ptr [[I]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[S]])
; CHECK-NEXT:    [[CALL:%.*]] = call i32 (ptr, ...) @goo(ptr nonnull [[I]])
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[STOREMERGE6:%.*]] = trunc i32 [[TMP0]] to i16
; CHECK-NEXT:    store i16 [[STOREMERGE6]], ptr [[S]], align 2
; CHECK-NEXT:    [[CONV17:%.*]] = and i32 [[TMP0]], 65472
; CHECK-NEXT:    [[CMP8:%.*]] = icmp eq i32 [[CONV17]], 0
; CHECK-NEXT:    br i1 [[CMP8]], label [[FOR_BODY_LR_PH:%.*]], label [[FOR_END12:%.*]]
; CHECK:       for.body.lr.ph:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[STOREMERGE_IN9:%.*]] = phi i32 [ [[TMP0]], [[FOR_BODY_LR_PH]] ], [ [[ADD:%.*]], [[FOR_INC9:%.*]] ]
; CHECK-NEXT:    [[CONV52:%.*]] = and i32 [[STOREMERGE_IN9]], 255
; CHECK-NEXT:    [[CMP63:%.*]] = icmp ult i32 [[TMP0]], [[CONV52]]
; CHECK-NEXT:    br i1 [[CMP63]], label [[FOR_BODY8_LR_PH:%.*]], label [[FOR_INC9]]
; CHECK:       for.body8.lr.ph:
; CHECK-NEXT:    [[CONV3:%.*]] = trunc i32 [[STOREMERGE_IN9]] to i8
; CHECK-NEXT:    [[DOTPROMOTED:%.*]] = load i32, ptr @a, align 16
; CHECK-NEXT:    br label [[FOR_BODY8:%.*]]
; CHECK:       for.body8:
; CHECK-NEXT:    [[INC5:%.*]] = phi i32 [ [[DOTPROMOTED]], [[FOR_BODY8_LR_PH]] ], [ [[INC:%.*]], [[FOR_BODY8]] ]
; CHECK-NEXT:    [[C_04:%.*]] = phi i8 [ [[CONV3]], [[FOR_BODY8_LR_PH]] ], [ [[DEC:%.*]], [[FOR_BODY8]] ]
; CHECK-NEXT:    [[INC]] = add i32 [[INC5]], 1
; CHECK-NEXT:    [[DEC]] = add i8 [[C_04]], -1
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[INC]]
; CHECK-NEXT:    store i32 0, ptr [[GEP]], align 4
; CHECK-NEXT:    [[CONV5:%.*]] = zext i8 [[DEC]] to i32
; CHECK-NEXT:    [[CMP6:%.*]] = icmp ult i32 [[TMP0]], [[CONV5]]
; CHECK-NEXT:    br i1 [[CMP6]], label [[FOR_BODY8]], label [[FOR_COND4_FOR_INC9_CRIT_EDGE:%.*]]
; CHECK:       for.cond4.for.inc9_crit_edge:
; CHECK-NEXT:    [[INC_LCSSA:%.*]] = phi i32 [ [[INC]], [[FOR_BODY8]] ]
; CHECK-NEXT:    store i32 [[INC_LCSSA]], ptr @a, align 16
; CHECK-NEXT:    br label [[FOR_INC9]]
; CHECK:       for.inc9:
; CHECK-NEXT:    [[CONV10:%.*]] = and i32 [[STOREMERGE_IN9]], 65535
; CHECK-NEXT:    [[ADD]] = add nuw nsw i32 [[CONV10]], 1
; CHECK-NEXT:    [[CONV1:%.*]] = and i32 [[ADD]], 65472
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[CONV1]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_FOR_END12_CRIT_EDGE:%.*]]
; CHECK:       for.cond.for.end12_crit_edge:
; CHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi i32 [ [[ADD]], [[FOR_INC9]] ]
; CHECK-NEXT:    [[STOREMERGE:%.*]] = trunc i32 [[ADD_LCSSA]] to i16
; CHECK-NEXT:    store i16 [[STOREMERGE]], ptr [[S]], align 2
; CHECK-NEXT:    br label [[FOR_END12]]
; CHECK:       for.end12:
; CHECK-NEXT:    [[CALL13:%.*]] = call i32 (ptr, ...) @foo(ptr nonnull [[S]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[S]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[I]])
; CHECK-NEXT:    ret i32 0
;
entry:
  %i = alloca i32, align 4
  %s = alloca i16, align 2
  call void @llvm.lifetime.start.p0(ptr nonnull %i) #3
  store i32 0, ptr %i, align 4
  call void @llvm.lifetime.start.p0(ptr nonnull %s) #3
  %call = call i32 (ptr, ...) @goo(ptr nonnull %i) #3
  %0 = load i32, ptr %i, align 4
  %storemerge6 = trunc i32 %0 to i16
  store i16 %storemerge6, ptr %s, align 2
  %conv17 = and i32 %0, 65472
  %cmp8 = icmp eq i32 %conv17, 0
  br i1 %cmp8, label %for.body.lr.ph, label %for.end12

for.body.lr.ph:                                   ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc9
  %storemerge.in9 = phi i32 [ %0, %for.body.lr.ph ], [ %add, %for.inc9 ]
  %conv52 = and i32 %storemerge.in9, 255
  %cmp63 = icmp ult i32 %0, %conv52
  br i1 %cmp63, label %for.body8.lr.ph, label %for.inc9

for.body8.lr.ph:                                  ; preds = %for.body
  %conv3 = trunc i32 %storemerge.in9 to i8
  %.promoted = load i32, ptr @a, align 16
  br label %for.body8

for.body8:                                        ; preds = %for.body8.lr.ph, %for.body8
  %inc5 = phi i32 [ %.promoted, %for.body8.lr.ph ], [ %inc, %for.body8 ]
  %c.04 = phi i8 [ %conv3, %for.body8.lr.ph ], [ %dec, %for.body8 ]
  %inc = add i32 %inc5, 1
  %dec = add i8 %c.04, -1
  %gep = getelementptr inbounds i32, ptr %ptr, i32 %inc
  store i32 0, ptr %gep
  %conv5 = zext i8 %dec to i32
  %cmp6 = icmp ult i32 %0, %conv5
  br i1 %cmp6, label %for.body8, label %for.cond4.for.inc9_crit_edge

for.cond4.for.inc9_crit_edge:                     ; preds = %for.body8
  %inc.lcssa = phi i32 [ %inc, %for.body8 ]
  store i32 %inc.lcssa, ptr @a, align 16
  br label %for.inc9

for.inc9:                                         ; preds = %for.cond4.for.inc9_crit_edge, %for.body
  %conv10 = and i32 %storemerge.in9, 65535
  %add = add nuw nsw i32 %conv10, 1
  %conv1 = and i32 %add, 65472
  %cmp = icmp eq i32 %conv1, 0
  br i1 %cmp, label %for.body, label %for.cond.for.end12_crit_edge

for.cond.for.end12_crit_edge:                     ; preds = %for.inc9
  %add.lcssa = phi i32 [ %add, %for.inc9 ]
  %storemerge = trunc i32 %add.lcssa to i16
  store i16 %storemerge, ptr %s, align 2
  br label %for.end12

for.end12:                                        ; preds = %for.cond.for.end12_crit_edge, %entry
  %call13 = call i32 (ptr, ...) @foo(ptr nonnull %s) #3
  call void @llvm.lifetime.end.p0(ptr nonnull %s) #3
  call void @llvm.lifetime.end.p0(ptr nonnull %i) #3
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0(ptr nocapture) #1

declare i32 @goo(...) local_unnamed_addr #2

declare i32 @foo(...) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0(ptr nocapture) #1
