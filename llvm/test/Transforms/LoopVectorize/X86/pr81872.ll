; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -passes=loop-vectorize < %s | FileCheck %s
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; PR 81872 explains the issue.

; If we vectorize, we have a miscompile where array IV and thereby value stored in (arr[99],
; arr[98]) is calculated incorrectly since disjoint or was only disjoint because
; of dominating conditions. Dropping the disjoint to avoid poison still changes
; the behaviour since now the or is no longer equivalent to the add.
;
define void @test(ptr noundef align 8 dereferenceable_or_null(16) %arr) #0 {
; CHECK-LABEL: define void @test(
; CHECK-SAME: ptr noundef align 8 dereferenceable_or_null(16) [[ARR:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  bb5:
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       loop.header:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 99, [[BB5:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP_LATCH:%.*]] ]
; CHECK-NEXT:    [[AND:%.*]] = and i64 [[IV]], 1
; CHECK-NEXT:    [[ICMP17:%.*]] = icmp eq i64 [[AND]], 0
; CHECK-NEXT:    br i1 [[ICMP17]], label [[BB18:%.*]], label [[LOOP_LATCH]], !prof [[PROF0:![0-9]+]]
; CHECK:       bb18:
; CHECK-NEXT:    [[OR:%.*]] = or disjoint i64 [[IV]], 1
; CHECK-NEXT:    [[GETELEMENTPTR19:%.*]] = getelementptr inbounds i64, ptr [[ARR]], i64 [[OR]]
; CHECK-NEXT:    store i64 1, ptr [[GETELEMENTPTR19]], align 8
; CHECK-NEXT:    br label [[LOOP_LATCH]]
; CHECK:       loop.latch:
; CHECK-NEXT:    [[IV_NEXT]] = add nsw i64 [[IV]], -1
; CHECK-NEXT:    [[ICMP22:%.*]] = icmp eq i64 [[IV_NEXT]], 90
; CHECK-NEXT:    br i1 [[ICMP22]], label [[BB6:%.*]], label [[VECTOR_BODY]], !prof [[PROF1:![0-9]+]]
; CHECK:       bb6:
; CHECK-NEXT:    ret void
;
bb5:
  br label %loop.header

loop.header:                                             ; preds = %loop.latch, %bb8
  %iv = phi i64 [ 99, %bb5 ], [ %iv.next, %loop.latch ]
  %and = and i64 %iv, 1
  %icmp17 = icmp eq i64 %and, 0
  br i1 %icmp17, label %bb18, label %loop.latch, !prof !21

bb18:                                             ; preds = %loop.header
  %or = or disjoint i64 %iv, 1
  %getelementptr19 = getelementptr inbounds i64, ptr %arr, i64 %or
  store i64 1, ptr %getelementptr19, align 8
  br label %loop.latch

loop.latch:                                             ; preds = %bb18, %loop.header
  %iv.next = add nsw i64 %iv, -1
  %icmp22 = icmp eq i64 %iv.next, 90
  br i1 %icmp22, label %bb6, label %loop.header, !prof !22

bb6:
  ret void
}

attributes #0 = {"target-cpu"="haswell" "target-features"="+avx2" }

!4 = !{}
!10 = !{i32 1}
!16 = !{i64 864}
!17 = !{i64 8}
!21 = !{!"branch_weights", i32 1, i32 1}
!22 = !{!"branch_weights", i32 1, i32 95}


;.
; CHECK: [[PROF0]] = !{!"branch_weights", i32 1, i32 1}
; CHECK: [[PROF1]] = !{!"branch_weights", i32 1, i32 95}
;.
