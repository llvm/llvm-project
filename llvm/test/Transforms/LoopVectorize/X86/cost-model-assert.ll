; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=loop-vectorize -S | FileCheck %s

; This is a bugpoint reduction of a test from PR43582:
; https://bugs.llvm.org/show_bug.cgi?id=43582

; ...but it's over-simplifying the underlying question:
; TODO: Should this be vectorized rather than allowing the backend to load combine?
;       The original code is a bswap pattern.

target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-w64-windows-gnu"

define void @cff_index_load_offsets(i1 %cond, i8 %x, ptr %p) #0 {
; CHECK-LABEL: define void @cff_index_load_offsets(
; CHECK-SAME: i1 [[COND:%.*]], i8 [[X:%.*]], ptr [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[IF_THEN:.*]], label %[[EXIT:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    br label %[[FOR_BODY68:.*]]
; CHECK:       [[FOR_BODY68]]:
; CHECK-NEXT:    [[P_359:%.*]] = phi ptr [ [[ADD_PTR86:%.*]], %[[FOR_BODY68]] ], [ null, %[[IF_THEN]] ]
; CHECK-NEXT:    [[CONV70:%.*]] = zext i8 [[X]] to i32
; CHECK-NEXT:    [[SHL71:%.*]] = shl nuw i32 [[CONV70]], 24
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[P]], align 1, !tbaa [[CHAR_TBAA1:![0-9]+]]
; CHECK-NEXT:    [[CONV73:%.*]] = zext i8 [[TMP0]] to i32
; CHECK-NEXT:    [[SHL74:%.*]] = shl nuw nsw i32 [[CONV73]], 16
; CHECK-NEXT:    [[OR75:%.*]] = or i32 [[SHL74]], [[SHL71]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr undef, align 1, !tbaa [[CHAR_TBAA1]]
; CHECK-NEXT:    [[SHL78:%.*]] = shl nuw nsw i32 undef, 8
; CHECK-NEXT:    [[OR79:%.*]] = or i32 [[OR75]], [[SHL78]]
; CHECK-NEXT:    [[CONV81:%.*]] = zext i8 [[TMP1]] to i32
; CHECK-NEXT:    [[OR83:%.*]] = or i32 [[OR79]], [[CONV81]]
; CHECK-NEXT:    store i32 [[OR83]], ptr undef, align 4, !tbaa [[LONG_TBAA4:![0-9]+]]
; CHECK-NEXT:    [[ADD_PTR86]] = getelementptr inbounds i8, ptr [[P_359]], i64 4
; CHECK-NEXT:    [[CMP66:%.*]] = icmp ult ptr [[ADD_PTR86]], undef
; CHECK-NEXT:    br i1 [[CMP66]], label %[[FOR_BODY68]], label %[[SW_EPILOG:.*]]
; CHECK:       [[SW_EPILOG]]:
; CHECK-NEXT:    unreachable
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %cond, label %if.then, label %Exit

if.then:                                          ; preds = %entry
  br label %for.body68

for.body68:                                       ; preds = %for.body68, %if.then
  %p.359 = phi ptr [ %add.ptr86, %for.body68 ], [ null, %if.then ]
  %conv70 = zext i8 %x to i32
  %shl71 = shl nuw i32 %conv70, 24
  %0 = load i8, ptr %p, align 1, !tbaa !1
  %conv73 = zext i8 %0 to i32
  %shl74 = shl nuw nsw i32 %conv73, 16
  %or75 = or i32 %shl74, %shl71
  %1 = load i8, ptr undef, align 1, !tbaa !1
  %shl78 = shl nuw nsw i32 undef, 8
  %or79 = or i32 %or75, %shl78
  %conv81 = zext i8 %1 to i32
  %or83 = or i32 %or79, %conv81
  store i32 %or83, ptr undef, align 4, !tbaa !4
  %add.ptr86 = getelementptr inbounds i8, ptr %p.359, i64 4
  %cmp66 = icmp ult ptr %add.ptr86, undef
  br i1 %cmp66, label %for.body68, label %sw.epilog

sw.epilog:                                        ; preds = %for.body68
  unreachable

Exit:                                             ; preds = %entry
  ret void
}

attributes #0 = { "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = !{!"clang version 10.0.0 (https://github.com/llvm/llvm-project.git 0fedc26a0dc0066f3968b9fea6a4e1f746c8d5a4)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"omnipotent char", !3, i64 0}
!3 = !{!"Simple C/C++ TBAA"}
!4 = !{!5, !5, i64 0}
!5 = !{!"long", !2, i64 0}
;.
; CHECK: [[CHAR_TBAA1]] = !{[[META2:![0-9]+]], [[META2]], i64 0}
; CHECK: [[META2]] = !{!"omnipotent char", [[META3:![0-9]+]], i64 0}
; CHECK: [[META3]] = !{!"Simple C/C++ TBAA"}
; CHECK: [[LONG_TBAA4]] = !{[[META5:![0-9]+]], [[META5]], i64 0}
; CHECK: [[META5]] = !{!"long", [[META2]], i64 0}
;.
