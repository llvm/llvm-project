; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -p loop-vectorize -mtriple=x86_64-apple-macosx -mcpu=skylake-avx512 -force-vector-interleave=1 -S %s | FileCheck --check-prefixes=COST %s
; RUN: opt -p loop-vectorize -mtriple=x86_64-apple-macosx -mcpu=skylake-avx512 -force-vector-width=4 -force-vector-interleave=2 -S %s | FileCheck --check-prefixes=FORCED %s

define void @switch_default_to_latch_common_dest(ptr %start, ptr %end) {
; COST-LABEL: define void @switch_default_to_latch_common_dest(
; COST-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0:[0-9]+]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP_HEADER:.*]]
; COST:       [[LOOP_HEADER]]:
; COST-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; COST-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; COST-NEXT:    switch i64 [[L]], label %[[LOOP_LATCH]] [
; COST-NEXT:      i64 -12, label %[[IF_THEN:.*]]
; COST-NEXT:      i64 13, label %[[IF_THEN]]
; COST-NEXT:    ]
; COST:       [[IF_THEN]]:
; COST-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[LOOP_LATCH]]:
; COST-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; COST-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @switch_default_to_latch_common_dest(
; FORCED-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0:[0-9]+]] {
; FORCED-NEXT:  [[ENTRY:.*]]:
; FORCED-NEXT:    br label %[[LOOP_HEADER:.*]]
; FORCED:       [[LOOP_HEADER]]:
; FORCED-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; FORCED-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    switch i64 [[L]], label %[[LOOP_LATCH]] [
; FORCED-NEXT:      i64 -12, label %[[IF_THEN:.*]]
; FORCED-NEXT:      i64 13, label %[[IF_THEN]]
; FORCED-NEXT:    ]
; FORCED:       [[IF_THEN]]:
; FORCED-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[LOOP_LATCH]]:
; FORCED-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; FORCED-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; FORCED-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; FORCED:       [[EXIT]]:
; FORCED-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %l = load i64, ptr %ptr.iv, align 1
  switch i64 %l, label %loop.latch [
  i64 -12, label %if.then
  i64 13, label %if.then
  ]

if.then:
  store i64 42, ptr %ptr.iv, align 1
  br label %loop.latch

loop.latch:
  %ptr.iv.next = getelementptr inbounds i64, ptr %ptr.iv, i64 1
  %ec = icmp eq ptr %ptr.iv.next, %end
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}

define void @switch_all_dests_distinct(ptr %start, ptr %end) {
; COST-LABEL: define void @switch_all_dests_distinct(
; COST-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP_HEADER:.*]]
; COST:       [[LOOP_HEADER]]:
; COST-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; COST-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; COST-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; COST-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; COST-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; COST-NEXT:      i64 0, label %[[IF_THEN_3:.*]]
; COST-NEXT:    ]
; COST:       [[IF_THEN_1]]:
; COST-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[IF_THEN_2]]:
; COST-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[IF_THEN_3]]:
; COST-NEXT:    store i64 1, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[DEFAULT]]:
; COST-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[LOOP_LATCH]]:
; COST-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; COST-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @switch_all_dests_distinct(
; FORCED-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; FORCED-NEXT:  [[ENTRY:.*]]:
; FORCED-NEXT:    br label %[[LOOP_HEADER:.*]]
; FORCED:       [[LOOP_HEADER]]:
; FORCED-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; FORCED-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; FORCED-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; FORCED-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; FORCED-NEXT:      i64 0, label %[[IF_THEN_3:.*]]
; FORCED-NEXT:    ]
; FORCED:       [[IF_THEN_1]]:
; FORCED-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[IF_THEN_2]]:
; FORCED-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[IF_THEN_3]]:
; FORCED-NEXT:    store i64 1, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[DEFAULT]]:
; FORCED-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[LOOP_LATCH]]:
; FORCED-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; FORCED-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; FORCED-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; FORCED:       [[EXIT]]:
; FORCED-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %l = load i64, ptr %ptr.iv, align 1
  switch i64 %l, label %default [
  i64 -12, label %if.then.1
  i64 13, label %if.then.2
  i64 0, label %if.then.3
  ]

if.then.1:
  store i64 42, ptr %ptr.iv, align 1
  br label %loop.latch

if.then.2:
  store i64 0, ptr %ptr.iv, align 1
  br label %loop.latch

if.then.3:
  store i64 1, ptr %ptr.iv, align 1
  br label %loop.latch

default:
  store i64 2, ptr %ptr.iv, align 1
  br label %loop.latch

loop.latch:
  %ptr.iv.next = getelementptr inbounds i64, ptr %ptr.iv, i64 1
  %ec = icmp eq ptr %ptr.iv.next, %end
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}


define void @switch_multiple_common_dests(ptr %start, ptr %end) {
; COST-LABEL: define void @switch_multiple_common_dests(
; COST-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP_HEADER:.*]]
; COST:       [[LOOP_HEADER]]:
; COST-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; COST-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; COST-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; COST-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; COST-NEXT:      i64 0, label %[[IF_THEN_1]]
; COST-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; COST-NEXT:      i64 14, label %[[IF_THEN_2]]
; COST-NEXT:      i64 15, label %[[IF_THEN_2]]
; COST-NEXT:    ]
; COST:       [[IF_THEN_1]]:
; COST-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[IF_THEN_2]]:
; COST-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[DEFAULT]]:
; COST-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[LOOP_LATCH]]:
; COST-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; COST-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @switch_multiple_common_dests(
; FORCED-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; FORCED-NEXT:  [[ENTRY:.*]]:
; FORCED-NEXT:    br label %[[LOOP_HEADER:.*]]
; FORCED:       [[LOOP_HEADER]]:
; FORCED-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; FORCED-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; FORCED-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; FORCED-NEXT:      i64 0, label %[[IF_THEN_1]]
; FORCED-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; FORCED-NEXT:      i64 14, label %[[IF_THEN_2]]
; FORCED-NEXT:      i64 15, label %[[IF_THEN_2]]
; FORCED-NEXT:    ]
; FORCED:       [[IF_THEN_1]]:
; FORCED-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[IF_THEN_2]]:
; FORCED-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[DEFAULT]]:
; FORCED-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[LOOP_LATCH]]:
; FORCED-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; FORCED-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; FORCED-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; FORCED:       [[EXIT]]:
; FORCED-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %l = load i64, ptr %ptr.iv, align 1
  switch i64 %l, label %default [
  i64 -12, label %if.then.1
  i64 0, label %if.then.1
  i64 13, label %if.then.2
  i64 14, label %if.then.2
  i64 15, label %if.then.2
  ]

if.then.1:
  store i64 42, ptr %ptr.iv, align 1
  br label %loop.latch

if.then.2:
  store i64 0, ptr %ptr.iv, align 1
  br label %loop.latch

default:
  store i64 2, ptr %ptr.iv, align 1
  br label %loop.latch

loop.latch:
  %ptr.iv.next = getelementptr inbounds i64, ptr %ptr.iv, i64 1
  %ec = icmp eq ptr %ptr.iv.next, %end
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}

define void @switch4_default_common_dest_with_case(ptr %start, ptr %end) {
; COST-LABEL: define void @switch4_default_common_dest_with_case(
; COST-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP_HEADER:.*]]
; COST:       [[LOOP_HEADER]]:
; COST-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; COST-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; COST-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; COST-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; COST-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; COST-NEXT:      i64 0, label %[[DEFAULT]]
; COST-NEXT:    ]
; COST:       [[IF_THEN_1]]:
; COST-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[IF_THEN_2]]:
; COST-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[DEFAULT]]:
; COST-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[LOOP_LATCH]]:
; COST-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; COST-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @switch4_default_common_dest_with_case(
; FORCED-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; FORCED-NEXT:  [[ENTRY:.*]]:
; FORCED-NEXT:    br label %[[LOOP_HEADER:.*]]
; FORCED:       [[LOOP_HEADER]]:
; FORCED-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; FORCED-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; FORCED-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; FORCED-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; FORCED-NEXT:      i64 0, label %[[DEFAULT]]
; FORCED-NEXT:    ]
; FORCED:       [[IF_THEN_1]]:
; FORCED-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[IF_THEN_2]]:
; FORCED-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[DEFAULT]]:
; FORCED-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[LOOP_LATCH]]:
; FORCED-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; FORCED-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; FORCED-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; FORCED:       [[EXIT]]:
; FORCED-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %l = load i64, ptr %ptr.iv, align 1
  switch i64 %l, label %default [
  i64 -12, label %if.then.1
  i64 13, label %if.then.2
  i64 0, label %default
  ]

if.then.1:
  store i64 42, ptr %ptr.iv, align 1
  br label %loop.latch

if.then.2:
  store i64 0, ptr %ptr.iv, align 1
  br label %loop.latch

default:
  store i64 2, ptr %ptr.iv, align 1
  br label %loop.latch

loop.latch:
  %ptr.iv.next = getelementptr inbounds i64, ptr %ptr.iv, i64 1
  %ec = icmp eq ptr %ptr.iv.next, %end
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}

define void @switch_under_br_default_common_dest_with_case(ptr %start, ptr %end, i64 %x) {
; COST-LABEL: define void @switch_under_br_default_common_dest_with_case(
; COST-SAME: ptr [[START:%.*]], ptr [[END:%.*]], i64 [[X:%.*]]) #[[ATTR0]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP_HEADER:.*]]
; COST:       [[LOOP_HEADER]]:
; COST-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; COST-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; COST-NEXT:    [[C:%.*]] = icmp ule i64 [[L]], [[X]]
; COST-NEXT:    br i1 [[C]], label %[[THEN:.*]], label %[[LOOP_LATCH]]
; COST:       [[THEN]]:
; COST-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; COST-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; COST-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; COST-NEXT:      i64 0, label %[[DEFAULT]]
; COST-NEXT:    ]
; COST:       [[IF_THEN_1]]:
; COST-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[IF_THEN_2]]:
; COST-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[DEFAULT]]:
; COST-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[LOOP_LATCH]]:
; COST-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; COST-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @switch_under_br_default_common_dest_with_case(
; FORCED-SAME: ptr [[START:%.*]], ptr [[END:%.*]], i64 [[X:%.*]]) #[[ATTR0]] {
; FORCED-NEXT:  [[ENTRY:.*]]:
; FORCED-NEXT:    br label %[[LOOP_HEADER:.*]]
; FORCED:       [[LOOP_HEADER]]:
; FORCED-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; FORCED-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    [[C:%.*]] = icmp ule i64 [[L]], [[X]]
; FORCED-NEXT:    br i1 [[C]], label %[[THEN:.*]], label %[[LOOP_LATCH]]
; FORCED:       [[THEN]]:
; FORCED-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; FORCED-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; FORCED-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; FORCED-NEXT:      i64 0, label %[[DEFAULT]]
; FORCED-NEXT:    ]
; FORCED:       [[IF_THEN_1]]:
; FORCED-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[IF_THEN_2]]:
; FORCED-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[DEFAULT]]:
; FORCED-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[LOOP_LATCH]]:
; FORCED-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; FORCED-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; FORCED-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; FORCED:       [[EXIT]]:
; FORCED-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %l = load i64, ptr %ptr.iv, align 1
  %c = icmp ule i64 %l, %x
  br i1 %c, label %then, label %loop.latch

then:
  switch i64 %l, label %default [
  i64 -12, label %if.then.1
  i64 13, label %if.then.2
  i64 0, label %default
  ]

if.then.1:
  store i64 42, ptr %ptr.iv, align 1
  br label %loop.latch

if.then.2:
  store i64 0, ptr %ptr.iv, align 1
  br label %loop.latch

default:
  store i64 2, ptr %ptr.iv, align 1
  br label %loop.latch

loop.latch:
  %ptr.iv.next = getelementptr inbounds i64, ptr %ptr.iv, i64 1
  %ec = icmp eq ptr %ptr.iv.next, %end
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}

define void @br_under_switch_default_common_dest_with_case(ptr %start, ptr %end, i64 %x) {
; COST-LABEL: define void @br_under_switch_default_common_dest_with_case(
; COST-SAME: ptr [[START:%.*]], ptr [[END:%.*]], i64 [[X:%.*]]) #[[ATTR0]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP_HEADER:.*]]
; COST:       [[LOOP_HEADER]]:
; COST-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; COST-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; COST-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; COST-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; COST-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; COST-NEXT:      i64 0, label %[[DEFAULT]]
; COST-NEXT:    ]
; COST:       [[IF_THEN_1]]:
; COST-NEXT:    [[C:%.*]] = icmp ule i64 [[L]], [[X]]
; COST-NEXT:    br i1 [[C]], label %[[THEN:.*]], label %[[IF_THEN_2]]
; COST:       [[THEN]]:
; COST-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[DEFAULT]]
; COST:       [[IF_THEN_2]]:
; COST-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[DEFAULT]]:
; COST-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[LOOP_LATCH]]:
; COST-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; COST-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @br_under_switch_default_common_dest_with_case(
; FORCED-SAME: ptr [[START:%.*]], ptr [[END:%.*]], i64 [[X:%.*]]) #[[ATTR0]] {
; FORCED-NEXT:  [[ENTRY:.*]]:
; FORCED-NEXT:    br label %[[LOOP_HEADER:.*]]
; FORCED:       [[LOOP_HEADER]]:
; FORCED-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; FORCED-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    switch i64 [[L]], label %[[DEFAULT:.*]] [
; FORCED-NEXT:      i64 -12, label %[[IF_THEN_1:.*]]
; FORCED-NEXT:      i64 13, label %[[IF_THEN_2:.*]]
; FORCED-NEXT:      i64 0, label %[[DEFAULT]]
; FORCED-NEXT:    ]
; FORCED:       [[IF_THEN_1]]:
; FORCED-NEXT:    [[C:%.*]] = icmp ule i64 [[L]], [[X]]
; FORCED-NEXT:    br i1 [[C]], label %[[THEN:.*]], label %[[IF_THEN_2]]
; FORCED:       [[THEN]]:
; FORCED-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[DEFAULT]]
; FORCED:       [[IF_THEN_2]]:
; FORCED-NEXT:    store i64 0, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[DEFAULT]]:
; FORCED-NEXT:    store i64 2, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[LOOP_LATCH]]:
; FORCED-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; FORCED-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; FORCED-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; FORCED:       [[EXIT]]:
; FORCED-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %l = load i64, ptr %ptr.iv, align 1
  switch i64 %l, label %default [
  i64 -12, label %if.then.1
  i64 13, label %if.then.2
  i64 0, label %default
  ]

if.then.1:
  %c = icmp ule i64 %l, %x
  br i1 %c, label %then, label %if.then.2

then:
  store i64 42, ptr %ptr.iv, align 1
  br label %default

if.then.2:
  store i64 0, ptr %ptr.iv, align 1
  br label %loop.latch

default:
  store i64 2, ptr %ptr.iv, align 1
  br label %loop.latch

loop.latch:
  %ptr.iv.next = getelementptr inbounds i64, ptr %ptr.iv, i64 1
  %ec = icmp eq ptr %ptr.iv.next, %end
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}

define void @large_number_of_cases(ptr %start, ptr %end) {
; COST-LABEL: define void @large_number_of_cases(
; COST-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; COST-NEXT:  [[ENTRY:.*]]:
; COST-NEXT:    br label %[[LOOP_HEADER:.*]]
; COST:       [[LOOP_HEADER]]:
; COST-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; COST-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; COST-NEXT:    switch i64 [[L]], label %[[LOOP_LATCH]] [
; COST-NEXT:      i64 1, label %[[IF_THEN:.*]]
; COST-NEXT:      i64 3, label %[[IF_THEN]]
; COST-NEXT:      i64 11, label %[[IF_THEN]]
; COST-NEXT:      i64 99, label %[[IF_THEN]]
; COST-NEXT:      i64 213, label %[[IF_THEN]]
; COST-NEXT:      i64 238, label %[[IF_THEN]]
; COST-NEXT:      i64 513, label %[[IF_THEN]]
; COST-NEXT:      i64 791, label %[[IF_THEN]]
; COST-NEXT:      i64 899, label %[[IF_THEN]]
; COST-NEXT:    ]
; COST:       [[IF_THEN]]:
; COST-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; COST-NEXT:    br label %[[LOOP_LATCH]]
; COST:       [[LOOP_LATCH]]:
; COST-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; COST-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; COST-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; COST:       [[EXIT]]:
; COST-NEXT:    ret void
;
; FORCED-LABEL: define void @large_number_of_cases(
; FORCED-SAME: ptr [[START:%.*]], ptr [[END:%.*]]) #[[ATTR0]] {
; FORCED-NEXT:  [[ENTRY:.*]]:
; FORCED-NEXT:    br label %[[LOOP_HEADER:.*]]
; FORCED:       [[LOOP_HEADER]]:
; FORCED-NEXT:    [[PTR_IV:%.*]] = phi ptr [ [[START]], %[[ENTRY]] ], [ [[PTR_IV_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; FORCED-NEXT:    [[L:%.*]] = load i64, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    switch i64 [[L]], label %[[LOOP_LATCH]] [
; FORCED-NEXT:      i64 1, label %[[IF_THEN:.*]]
; FORCED-NEXT:      i64 3, label %[[IF_THEN]]
; FORCED-NEXT:      i64 11, label %[[IF_THEN]]
; FORCED-NEXT:      i64 99, label %[[IF_THEN]]
; FORCED-NEXT:      i64 213, label %[[IF_THEN]]
; FORCED-NEXT:      i64 238, label %[[IF_THEN]]
; FORCED-NEXT:      i64 513, label %[[IF_THEN]]
; FORCED-NEXT:      i64 791, label %[[IF_THEN]]
; FORCED-NEXT:      i64 899, label %[[IF_THEN]]
; FORCED-NEXT:    ]
; FORCED:       [[IF_THEN]]:
; FORCED-NEXT:    store i64 42, ptr [[PTR_IV]], align 1
; FORCED-NEXT:    br label %[[LOOP_LATCH]]
; FORCED:       [[LOOP_LATCH]]:
; FORCED-NEXT:    [[PTR_IV_NEXT]] = getelementptr inbounds i64, ptr [[PTR_IV]], i64 1
; FORCED-NEXT:    [[EC:%.*]] = icmp eq ptr [[PTR_IV_NEXT]], [[END]]
; FORCED-NEXT:    br i1 [[EC]], label %[[EXIT:.*]], label %[[LOOP_HEADER]]
; FORCED:       [[EXIT]]:
; FORCED-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %ptr.iv = phi ptr [ %start, %entry ], [ %ptr.iv.next, %loop.latch ]
  %l = load i64, ptr %ptr.iv, align 1
  switch i64 %l, label %loop.latch [
  i64 1, label %if.then
  i64 3, label %if.then
  i64 11, label %if.then
  i64 99, label %if.then
  i64 213, label %if.then
  i64 238, label %if.then
  i64 513, label %if.then
  i64 791, label %if.then
  i64 899, label %if.then
  ]

if.then:
  store i64 42, ptr %ptr.iv, align 1
  br label %loop.latch

loop.latch:
  %ptr.iv.next = getelementptr inbounds i64, ptr %ptr.iv, i64 1
  %ec = icmp eq ptr %ptr.iv.next, %end
  br i1 %ec, label %exit, label %loop.header

exit:
  ret void
}

