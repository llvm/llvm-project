; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=loop-vectorize,instcombine,simplifycfg -force-vector-width=4 -force-vector-interleave=1 -experimental-olv-in-classic-vect < %s | FileCheck %s

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"

;;; Effectively the inner two loops of:
; for (size_t i = 0; i < N; i++) {
;   #pragma clang loop vectorize(enable)
;   for (size_t j = 0; j < N; j++) {
;     float a = 0.;
;     for (size_t k = 0; k < N; k++)
;       a += B[i][k] * C[k][j];
;     A[i][j] = a;
;   }
; }
define void @foo(i64 %N, i64 %M, ptr noalias %A, ptr readonly %B, ptr readonly %C) {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i64 [[N:%.*]], i64 [[M:%.*]], ptr noalias [[A:%.*]], ptr readonly [[B:%.*]], ptr readonly [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 4
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[N]], -4
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[LOOP_LATCH9:.*]] ]
; CHECK-NEXT:    br label %[[INNER_LOOP1:.*]]
; CHECK:       [[INNER_LOOP1]]:
; CHECK-NEXT:    [[TMP2:%.*]] = phi <4 x i64> [ zeroinitializer, %[[VECTOR_BODY]] ], [ [[BROADCAST_SPLAT12:%.*]], %[[INNER_LOOP1]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x float> [ zeroinitializer, %[[VECTOR_BODY]] ], [ [[TMP6:%.*]], %[[INNER_LOOP1]] ]
; CHECK-NEXT:    [[VEC_PHI3:%.*]] = phi <4 x i1> [ splat (i1 true), %[[VECTOR_BODY]] ], [ [[TMP15:%.*]], %[[INNER_LOOP1]] ]
; CHECK-NEXT:    [[VEC_PHI4:%.*]] = phi <4 x float> [ poison, %[[VECTOR_BODY]] ], [ [[TMP9:%.*]], %[[INNER_LOOP1]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = extractelement <4 x i64> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds float, ptr [[B]], i64 [[TMP3]]
; CHECK-NEXT:    [[TMP14:%.*]] = load float, ptr [[TMP20]], align 4, !llvm.access.group [[ACC_GRP0:![0-9]+]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x float> poison, float [[TMP14]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x float> [[BROADCAST_SPLATINSERT]], <4 x float> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <4 x i64> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = mul i64 [[TMP7]], [[M]]
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr float, ptr [[C]], i64 [[TMP4]]
; CHECK-NEXT:    [[TMP18:%.*]] = getelementptr float, ptr [[TMP8]], i64 [[INDEX]]
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x float>, ptr [[TMP18]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP5:%.*]] = fmul <4 x float> [[BROADCAST_SPLAT]], [[WIDE_LOAD]]
; CHECK-NEXT:    [[TMP6]] = fadd <4 x float> [[VEC_PHI]], [[TMP5]]
; CHECK-NEXT:    [[TMP9]] = select <4 x i1> [[VEC_PHI3]], <4 x float> [[TMP6]], <4 x float> [[VEC_PHI4]]
; CHECK-NEXT:    [[TMP19:%.*]] = extractelement <4 x i64> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP21:%.*]] = add nuw nsw i64 [[TMP19]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT11:%.*]] = insertelement <4 x i64> poison, i64 [[TMP21]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT12]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT11]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP12:%.*]] = icmp eq i64 [[TMP21]], [[M]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT5:%.*]] = insertelement <4 x i1> poison, i1 [[TMP12]], i64 0
; CHECK-NEXT:    [[TMP13:%.*]] = xor <4 x i1> [[BROADCAST_SPLATINSERT5]], <i1 true, i1 poison, i1 poison, i1 poison>
; CHECK-NEXT:    [[TMP22:%.*]] = shufflevector <4 x i1> [[TMP13]], <4 x i1> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP15]] = select <4 x i1> [[VEC_PHI3]], <4 x i1> [[TMP22]], <4 x i1> zeroinitializer
; CHECK-NEXT:    [[TMP16:%.*]] = bitcast <4 x i1> [[TMP15]] to i4
; CHECK-NEXT:    [[DOTNOT:%.*]] = icmp eq i4 [[TMP16]], 0
; CHECK-NEXT:    br i1 [[DOTNOT]], label %[[LOOP_LATCH9]], label %[[INNER_LOOP1]]
; CHECK:       [[LOOP_LATCH9]]:
; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[INDEX]]
; CHECK-NEXT:    store <4 x float> [[TMP9]], ptr [[TMP17]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP10]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP1:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], label %[[EXIT:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], %[[MIDDLE_BLOCK]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    br label %[[LOOP_HEADER:.*]]
; CHECK:       [[LOOP_HEADER]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ [[I_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    br label %[[INNER_LOOP:.*]]
; CHECK:       [[INNER_LOOP]]:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[J_NEXT:%.*]], %[[INNER_LOOP]] ], [ 0, %[[LOOP_HEADER]] ]
; CHECK-NEXT:    [[A_PHI:%.*]] = phi float [ [[A_NEXT:%.*]], %[[INNER_LOOP]] ], [ 0.000000e+00, %[[LOOP_HEADER]] ]
; CHECK-NEXT:    [[B_ADDR:%.*]] = getelementptr inbounds nuw float, ptr [[B]], i64 [[J]]
; CHECK-NEXT:    [[B_LOAD:%.*]] = load float, ptr [[B_ADDR]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[JXM:%.*]] = mul i64 [[J]], [[M]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr float, ptr [[C]], i64 [[JXM]]
; CHECK-NEXT:    [[C_ADDR:%.*]] = getelementptr float, ptr [[TMP11]], i64 [[I]]
; CHECK-NEXT:    [[C_LOAD:%.*]] = load float, ptr [[C_ADDR]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[MUL:%.*]] = fmul float [[B_LOAD]], [[C_LOAD]]
; CHECK-NEXT:    [[A_NEXT]] = fadd float [[A_PHI]], [[MUL]]
; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[INNER_EXITCOND:%.*]] = icmp eq i64 [[J_NEXT]], [[M]]
; CHECK-NEXT:    br i1 [[INNER_EXITCOND]], label %[[LOOP_LATCH]], label %[[INNER_LOOP]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[A_ADDR:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[I]]
; CHECK-NEXT:    store float [[A_NEXT]], ptr [[A_ADDR]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[LOOP_EXITCOND:%.*]] = icmp eq i64 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_EXITCOND]], label %[[EXIT]], label %[[LOOP_HEADER]], !llvm.loop [[LOOP5:![0-9]+]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %i = phi i64 [ %i.next, %loop.latch ], [ 0, %entry ]
  br label %inner.loop

inner.loop:
  %j = phi i64 [ %j.next, %inner.loop ], [ 0, %loop.header ]
  %a.phi = phi float [ %a.next, %inner.loop ], [ 0.0, %loop.header ]
  %b.addr = getelementptr inbounds float, ptr %B, i64 %j
  %b.load = load float, ptr %b.addr, align 4, !llvm.access.group !3
  %jxM = mul i64 %j, %M
  %jxMpi = add i64 %jxM, %i
  %c.addr = getelementptr inbounds float, ptr %C, i64 %jxMpi
  %c.load = load float, ptr %c.addr, align 4, !llvm.access.group !3
  %mul = fmul float %b.load, %c.load
  %a.next = fadd float %a.phi, %mul
  %j.next = add nuw nsw i64 %j, 1
  %inner.exitcond = icmp eq i64 %j.next, %M
  br i1 %inner.exitcond, label %loop.latch, label %inner.loop

loop.latch:
  %a.lcssa = phi float [ %a.next, %inner.loop ]
  %a.addr = getelementptr inbounds float, ptr %A, i64 %i
  store float %a.lcssa, ptr %a.addr, align 4, !llvm.access.group !3
  %i.next = add nuw nsw i64 %i, 1
  %loop.exitcond = icmp eq i64 %i.next, %N
  br i1 %loop.exitcond, label %exit, label %loop.header, !llvm.loop !0

exit:
  ret void
}

;;; Effectively the inner two loops of:
; for (size_t i = 0; i < N; i++) {
;   #pragma clang loop vectorize(enable)
;   for (size_t j = 0; j < N; j++) {
;     float a = 0.;
;     for (size_t k = 0; k < j; k++)
;       a += B[i][k] * C[k][j];
;     A[i][j] = a;
;   }
; }
;;; Note that the inner loop's trip-count depends on the outer loop.
define void @bar(i64 %N, i64 %M, ptr noalias %A, ptr readonly %B, ptr readonly %C) {
; CHECK-LABEL: define void @bar(
; CHECK-SAME: i64 [[N:%.*]], i64 [[M:%.*]], ptr noalias [[A:%.*]], ptr readonly [[B:%.*]], ptr readonly [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 4
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_VEC1:%.*]] = and i64 [[N]], -4
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[M]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[N_VEC:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT1:%.*]], %[[LOOP_LATCH3:.*]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[LOOP_LATCH3]] ]
; CHECK-NEXT:    br label %[[INNER_LOOP1:.*]]
; CHECK:       [[INNER_LOOP1]]:
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i64> [ zeroinitializer, %[[VECTOR_BODY]] ], [ [[BROADCAST_SPLAT6:%.*]], %[[INNER_LOOP1]] ]
; CHECK-NEXT:    [[VEC_PHI3:%.*]] = phi <4 x float> [ zeroinitializer, %[[VECTOR_BODY]] ], [ [[TMP44:%.*]], %[[INNER_LOOP1]] ]
; CHECK-NEXT:    [[INDEX:%.*]] = extractelement <4 x i64> [[VEC_PHI]], i64 0
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds float, ptr [[B]], i64 [[INDEX]]
; CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr [[TMP0]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x float> poison, float [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = mul <4 x i64> [[VEC_PHI]], [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[TMP6:%.*]] = add <4 x i64> [[TMP5]], [[VEC_IND]]
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <4 x i64> [[TMP6]], i64 0
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[C]], i64 [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = extractelement <4 x i64> [[TMP6]], i64 1
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds float, ptr [[C]], i64 [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = extractelement <4 x i64> [[TMP6]], i64 2
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds float, ptr [[C]], i64 [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = extractelement <4 x i64> [[TMP6]], i64 3
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds float, ptr [[C]], i64 [[TMP13]]
; CHECK-NEXT:    [[TMP15:%.*]] = load float, ptr [[TMP8]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP16:%.*]] = load float, ptr [[TMP10]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP17:%.*]] = load float, ptr [[TMP12]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP18:%.*]] = load float, ptr [[TMP14]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP19:%.*]] = insertelement <4 x float> poison, float [[TMP15]], i64 0
; CHECK-NEXT:    [[TMP20:%.*]] = insertelement <4 x float> [[TMP19]], float [[TMP16]], i64 1
; CHECK-NEXT:    [[TMP21:%.*]] = insertelement <4 x float> [[TMP20]], float [[TMP17]], i64 2
; CHECK-NEXT:    [[TMP41:%.*]] = insertelement <4 x float> [[TMP21]], float [[TMP18]], i64 3
; CHECK-NEXT:    [[TMP43:%.*]] = fmul <4 x float> [[TMP4]], [[TMP41]]
; CHECK-NEXT:    [[TMP44]] = fadd <4 x float> [[VEC_PHI3]], [[TMP43]]
; CHECK-NEXT:    [[TMP25:%.*]] = extractelement <4 x i64> [[VEC_PHI]], i64 0
; CHECK-NEXT:    [[INDEX_NEXT:%.*]] = add nuw nsw i64 [[TMP25]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT5:%.*]] = insertelement <4 x i64> poison, i64 [[INDEX_NEXT]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT6]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT5]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP51:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP51]], label %[[LOOP_LATCH3]], label %[[INNER_LOOP1]]
; CHECK:       [[LOOP_LATCH3]]:
; CHECK-NEXT:    [[TMP28:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[N_VEC]]
; CHECK-NEXT:    store <4 x float> [[TMP44]], ptr [[TMP28]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[INDEX_NEXT1]] = add nuw i64 [[N_VEC]], 4
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <4 x i64> [[VEC_IND]], splat (i64 4)
; CHECK-NEXT:    [[TMP29:%.*]] = icmp eq i64 [[INDEX_NEXT1]], [[N_VEC1]]
; CHECK-NEXT:    br i1 [[TMP29]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC1]]
; CHECK-NEXT:    br i1 [[CMP_N]], label %[[EXIT:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC1]], %[[MIDDLE_BLOCK]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    br label %[[LOOP_HEADER:.*]]
; CHECK:       [[LOOP_HEADER]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ [[I_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    br label %[[INNER_LOOP:.*]]
; CHECK:       [[INNER_LOOP]]:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[J_NEXT:%.*]], %[[INNER_LOOP]] ], [ 0, %[[LOOP_HEADER]] ]
; CHECK-NEXT:    [[A_PHI:%.*]] = phi float [ [[A_NEXT:%.*]], %[[INNER_LOOP]] ], [ 0.000000e+00, %[[LOOP_HEADER]] ]
; CHECK-NEXT:    [[B_ADDR:%.*]] = getelementptr inbounds nuw float, ptr [[B]], i64 [[J]]
; CHECK-NEXT:    [[B_LOAD:%.*]] = load float, ptr [[B_ADDR]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[JXM:%.*]] = mul i64 [[J]], [[M]]
; CHECK-NEXT:    [[TMP52:%.*]] = getelementptr float, ptr [[C]], i64 [[JXM]]
; CHECK-NEXT:    [[C_ADDR:%.*]] = getelementptr float, ptr [[TMP52]], i64 [[I]]
; CHECK-NEXT:    [[C_LOAD:%.*]] = load float, ptr [[C_ADDR]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[MUL:%.*]] = fmul float [[B_LOAD]], [[C_LOAD]]
; CHECK-NEXT:    [[A_NEXT]] = fadd float [[A_PHI]], [[MUL]]
; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[INNER_EXITCOND:%.*]] = icmp eq i64 [[J_NEXT]], [[I]]
; CHECK-NEXT:    br i1 [[INNER_EXITCOND]], label %[[LOOP_LATCH]], label %[[INNER_LOOP]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[A_ADDR:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[I]]
; CHECK-NEXT:    store float [[A_NEXT]], ptr [[A_ADDR]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[LOOP_EXITCOND:%.*]] = icmp eq i64 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_EXITCOND]], label %[[EXIT]], label %[[LOOP_HEADER]], !llvm.loop [[LOOP7:![0-9]+]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %i = phi i64 [ %i.next, %loop.latch ], [ 0, %entry ]
  br label %inner.loop

inner.loop:
  %j = phi i64 [ %j.next, %inner.loop ], [ 0, %loop.header ]
  %a.phi = phi float [ %a.next, %inner.loop ], [ 0.0, %loop.header ]
  %b.addr = getelementptr inbounds float, ptr %B, i64 %j
  %b.load = load float, ptr %b.addr, align 4, !llvm.access.group !3
  %jxM = mul i64 %j, %M
  %jxMpi = add i64 %jxM, %i
  %c.addr = getelementptr inbounds float, ptr %C, i64 %jxMpi
  %c.load = load float, ptr %c.addr, align 4, !llvm.access.group !3
  %mul = fmul float %b.load, %c.load
  %a.next = fadd float %a.phi, %mul
  %j.next = add nuw nsw i64 %j, 1
  %inner.exitcond = icmp eq i64 %j.next, %i
  br i1 %inner.exitcond, label %loop.latch, label %inner.loop

loop.latch:
  %a.lcssa = phi float [ %a.next, %inner.loop ]
  %a.addr = getelementptr inbounds float, ptr %A, i64 %i
  store float %a.lcssa, ptr %a.addr, align 4, !llvm.access.group !3
  %i.next = add nuw nsw i64 %i, 1
  %loop.exitcond = icmp eq i64 %i.next, %N
  br i1 %loop.exitcond, label %exit, label %loop.header, !llvm.loop !0

exit:
  ret void
}

;;; Effectively something like:
; #pragma clang loop vectorize(enable)
; for (long i = 0; i < N; i++) {
;   long a = A[i];
;   long j = 0;
;   if (a > 0) {
;     do {
;       a -= B[j];
;       j++;
;     } while (a > 0);
;   }
;   A[i] = a + j;
; }
;;; Note that the inner loop is behind a branch, so the start value of the inner
;;; loop mask phi must be corespondingly. The induction of the inner loop is used
;;; for a uniform memory accesses and as live-out, so the vectorized code should
;;; contain two phis for it (one scalar and one widened).
;;; Also, in this example, the inner loop backedge is the first successor of the
;;; the latch terminator, not the second one as is assumed by VPlan.
define void @baz(i64 %N, i64 %M, ptr noalias %A, ptr readonly %B) {
; CHECK-LABEL: define void @baz(
; CHECK-SAME: i64 [[N:%.*]], i64 [[M:%.*]], ptr noalias [[A:%.*]], ptr readonly [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 4
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[N]], -4
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[LOOP_LATCH_LOOPEXIT9:.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[INDEX]]
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i64>, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp sgt <4 x i64> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    br label %[[INNER_LOOP1:.*]]
; CHECK:       [[INNER_LOOP1]]:
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i64> [ zeroinitializer, %[[VECTOR_BODY]] ], [ [[BROADCAST_SPLAT:%.*]], %[[PRED_LOAD_CONTINUE8:.*]] ]
; CHECK-NEXT:    [[VEC_PHI2:%.*]] = phi <4 x i64> [ zeroinitializer, %[[VECTOR_BODY]] ], [ [[TMP20:%.*]], %[[PRED_LOAD_CONTINUE8]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i64> [[VEC_PHI]], i64 0
; CHECK-NEXT:    [[A_ADDR:%.*]] = getelementptr inbounds i64, ptr [[B]], i64 [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x i1> [[TMP1]], i64 0
; CHECK-NEXT:    br i1 [[TMP4]], label %[[PRED_LOAD_IF:.*]], label %[[PRED_LOAD_CONTINUE:.*]]
; CHECK:       [[PRED_LOAD_IF]]:
; CHECK-NEXT:    [[A_LOAD:%.*]] = load i64, ptr [[A_ADDR]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <4 x i64> poison, i64 [[A_LOAD]], i64 0
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE]]
; CHECK:       [[PRED_LOAD_CONTINUE]]:
; CHECK-NEXT:    [[TMP7:%.*]] = phi <4 x i64> [ poison, %[[INNER_LOOP1]] ], [ [[TMP6]], %[[PRED_LOAD_IF]] ]
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <4 x i1> [[TMP1]], i64 1
; CHECK-NEXT:    br i1 [[TMP8]], label %[[PRED_LOAD_IF3:.*]], label %[[PRED_LOAD_CONTINUE4:.*]]
; CHECK:       [[PRED_LOAD_IF3]]:
; CHECK-NEXT:    [[TMP9:%.*]] = load i64, ptr [[A_ADDR]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <4 x i64> [[TMP7]], i64 [[TMP9]], i64 1
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE4]]
; CHECK:       [[PRED_LOAD_CONTINUE4]]:
; CHECK-NEXT:    [[TMP11:%.*]] = phi <4 x i64> [ [[TMP7]], %[[PRED_LOAD_CONTINUE]] ], [ [[TMP10]], %[[PRED_LOAD_IF3]] ]
; CHECK-NEXT:    [[TMP12:%.*]] = extractelement <4 x i1> [[TMP1]], i64 2
; CHECK-NEXT:    br i1 [[TMP12]], label %[[PRED_LOAD_IF5:.*]], label %[[PRED_LOAD_CONTINUE6:.*]]
; CHECK:       [[PRED_LOAD_IF5]]:
; CHECK-NEXT:    [[TMP13:%.*]] = load i64, ptr [[A_ADDR]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP14:%.*]] = insertelement <4 x i64> [[TMP11]], i64 [[TMP13]], i64 2
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE6]]
; CHECK:       [[PRED_LOAD_CONTINUE6]]:
; CHECK-NEXT:    [[TMP15:%.*]] = phi <4 x i64> [ [[TMP11]], %[[PRED_LOAD_CONTINUE4]] ], [ [[TMP14]], %[[PRED_LOAD_IF5]] ]
; CHECK-NEXT:    [[TMP16:%.*]] = extractelement <4 x i1> [[TMP1]], i64 3
; CHECK-NEXT:    br i1 [[TMP16]], label %[[PRED_LOAD_IF7:.*]], label %[[PRED_LOAD_CONTINUE8]]
; CHECK:       [[PRED_LOAD_IF7]]:
; CHECK-NEXT:    [[TMP17:%.*]] = load i64, ptr [[A_ADDR]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP18:%.*]] = insertelement <4 x i64> [[TMP15]], i64 [[TMP17]], i64 3
; CHECK-NEXT:    br label %[[PRED_LOAD_CONTINUE8]]
; CHECK:       [[PRED_LOAD_CONTINUE8]]:
; CHECK-NEXT:    [[TMP19:%.*]] = phi <4 x i64> [ [[TMP15]], %[[PRED_LOAD_CONTINUE6]] ], [ [[TMP18]], %[[PRED_LOAD_IF7]] ]
; CHECK-NEXT:    [[TMP20]] = sub <4 x i64> [[VEC_PHI2]], [[TMP19]]
; CHECK-NEXT:    [[TMP21:%.*]] = extractelement <4 x i64> [[VEC_PHI]], i64 0
; CHECK-NEXT:    [[TMP22:%.*]] = add nuw nsw i64 [[TMP21]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[TMP22]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP23:%.*]] = extractelement <4 x i64> [[TMP20]], i64 0
; CHECK-NEXT:    [[TMP24:%.*]] = icmp slt i64 [[TMP23]], 1
; CHECK-NEXT:    br i1 [[TMP24]], label %[[LOOP_LATCH_LOOPEXIT9]], label %[[INNER_LOOP1]]
; CHECK:       [[LOOP_LATCH_LOOPEXIT9]]:
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[TMP1]], <4 x i64> [[TMP20]], <4 x i64> [[WIDE_LOAD]]
; CHECK-NEXT:    store <4 x i64> [[PREDPHI]], ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4
; CHECK-NEXT:    [[TMP25:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP25]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP8:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], label %[[EXIT:.*]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], %[[MIDDLE_BLOCK]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    br label %[[LOOP_HEADER:.*]]
; CHECK:       [[LOOP_HEADER]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ [[I_NEXT:%.*]], %[[LOOP_LATCH:.*]] ], [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[A_ADDR1:%.*]] = getelementptr inbounds i64, ptr [[A]], i64 [[I]]
; CHECK-NEXT:    [[A_LOAD1:%.*]] = load i64, ptr [[A_ADDR1]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[A_IS_POSITIVE:%.*]] = icmp sgt i64 [[A_LOAD1]], 0
; CHECK-NEXT:    br i1 [[A_IS_POSITIVE]], label %[[INNER_LOOP:.*]], label %[[LOOP_LATCH]]
; CHECK:       [[INNER_LOOP]]:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[J_NEXT:%.*]], %[[INNER_LOOP]] ], [ 0, %[[LOOP_HEADER]] ]
; CHECK-NEXT:    [[A_PHI:%.*]] = phi i64 [ [[A_NEXT:%.*]], %[[INNER_LOOP]] ], [ 0, %[[LOOP_HEADER]] ]
; CHECK-NEXT:    [[B_ADDR:%.*]] = getelementptr inbounds nuw i64, ptr [[B]], i64 [[J]]
; CHECK-NEXT:    [[B_LOAD:%.*]] = load i64, ptr [[B_ADDR]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[A_NEXT]] = sub i64 [[A_PHI]], [[B_LOAD]]
; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[A_IS_STILL_POSITIVE:%.*]] = icmp sgt i64 [[A_NEXT]], 0
; CHECK-NEXT:    br i1 [[A_IS_STILL_POSITIVE]], label %[[INNER_LOOP]], label %[[LOOP_LATCH]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[A_RES:%.*]] = phi i64 [ [[A_LOAD1]], %[[LOOP_HEADER]] ], [ [[A_NEXT]], %[[INNER_LOOP]] ]
; CHECK-NEXT:    store i64 [[A_RES]], ptr [[A_ADDR1]], align 8, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[LOOP_EXITCOND:%.*]] = icmp eq i64 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[LOOP_EXITCOND]], label %[[EXIT]], label %[[LOOP_HEADER]], !llvm.loop [[LOOP9:![0-9]+]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop.header

loop.header:
  %i = phi i64 [ %i.next, %loop.latch ], [ 0, %entry ]
  %a.addr = getelementptr inbounds i64, ptr %A, i64 %i
  %a.load = load i64, ptr %a.addr, align 8, !llvm.access.group !3
  %a.is.positive = icmp sgt i64 %a.load, 0
  br i1 %a.is.positive, label %inner.loop, label %loop.latch

inner.loop:
  %j = phi i64 [ %j.next, %inner.loop ], [ 0, %loop.header ]
  %a.phi = phi i64 [ %a.next, %inner.loop ], [ 0, %loop.header ]
  %b.addr = getelementptr inbounds i64, ptr %B, i64 %j
  %b.load = load i64, ptr %b.addr, align 8, !llvm.access.group !3
  %a.next = sub i64 %a.phi, %b.load
  %j.next = add nuw nsw i64 %j, 1
  %a.is.still.positive = icmp sgt i64 %a.next, 0
  br i1 %a.is.still.positive, label %inner.loop, label %loop.latch

loop.latch:
  %a.res = phi i64 [ %a.load, %loop.header ], [ %a.next, %inner.loop ]
  store i64 %a.res, ptr %a.addr, align 8, !llvm.access.group !3
  %i.next = add nuw nsw i64 %i, 1
  %loop.exitcond = icmp eq i64 %i.next, %N
  br i1 %loop.exitcond, label %exit, label %loop.header, !llvm.loop !0

exit:
  ret void
}

;;; Triple-loop nest with the outer-most one beeing vectorized.
; #pragma clang loop vectorize(enable)
; for (size_t i = 0; i < N; i++)
;   for (size_t j = 0; j < M; j++)
;     for (size_t k = 0; k < L; k++)
;       A[k][i] += B[i][k];
define void @quuz(i64 %N, i64 %M, i64 %L, ptr noalias %A, ptr readonly %B) {
; CHECK-LABEL: define void @quuz(
; CHECK-SAME: i64 [[N:%.*]], i64 [[M:%.*]], i64 [[L:%.*]], ptr noalias [[A:%.*]], ptr readonly [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[N_IS_ZERO:%.*]] = icmp eq i64 [[N]], 0
; CHECK-NEXT:    br i1 [[N_IS_ZERO]], label %[[EXIT:.*]], label %[[OUTER_LOOP_PREHEADER:.*]]
; CHECK:       [[OUTER_LOOP_PREHEADER]]:
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[N]], 4
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label %[[SCALAR_PH:.*]], label %[[VECTOR_PH:.*]]
; CHECK:       [[VECTOR_PH]]:
; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[N]], -4
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[M]], i64 0
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne <4 x i64> [[BROADCAST_SPLATINSERT]], zeroinitializer
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <4 x i1> [[TMP0]], <4 x i1> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT1:%.*]] = insertelement <4 x i64> poison, i64 [[L]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT2:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT1]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT8:%.*]] = insertelement <4 x i64> poison, i64 [[N]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT9:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT8]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VECTOR_BODY:.*]]
; CHECK:       [[VECTOR_BODY]]:
; CHECK-NEXT:    [[TMP28:%.*]] = phi i64 [ 0, %[[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], %[[OUTER_LATCH_LOOPEXIT25:.*]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, %[[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], %[[OUTER_LATCH_LOOPEXIT25]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = mul <4 x i64> [[VEC_IND]], [[BROADCAST_SPLAT2]]
; CHECK-NEXT:    br label %[[MIDDLE_LOOP3:.*]]
; CHECK:       [[MIDDLE_LOOP3]]:
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i64> [ zeroinitializer, %[[VECTOR_BODY]] ], [ [[BROADCAST_SPLAT27:%.*]], %[[MIDDLE_LATCH_LOOPEXIT20:.*]] ]
; CHECK-NEXT:    [[VEC_PHI4:%.*]] = phi <4 x i1> [ [[TMP7]], %[[VECTOR_BODY]] ], [ [[TMP65:%.*]], %[[MIDDLE_LATCH_LOOPEXIT20]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <4 x i64> [[BROADCAST_SPLAT2]], zeroinitializer
; CHECK-NEXT:    [[TMP4:%.*]] = select <4 x i1> [[VEC_PHI4]], <4 x i1> [[TMP3]], <4 x i1> zeroinitializer
; CHECK-NEXT:    br label %[[INNER_LOOP5:.*]]
; CHECK:       [[INNER_LOOP5]]:
; CHECK-NEXT:    [[VEC_PHI6:%.*]] = phi <4 x i64> [ zeroinitializer, %[[MIDDLE_LOOP3]] ], [ [[BROADCAST_SPLAT29:%.*]], %[[PRED_STORE_CONTINUE15:.*]] ]
; CHECK-NEXT:    [[VEC_PHI7:%.*]] = phi <4 x i1> [ [[TMP4]], %[[MIDDLE_LOOP3]] ], [ [[TMP58:%.*]], %[[PRED_STORE_CONTINUE15]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = mul <4 x i64> [[VEC_PHI6]], [[BROADCAST_SPLAT9]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x i1> [[VEC_PHI7]], i64 0
; CHECK-NEXT:    br i1 [[TMP6]], label %[[PRED_STORE_IF:.*]], label %[[PRED_STORE_CONTINUE:.*]]
; CHECK:       [[PRED_STORE_IF]]:
; CHECK-NEXT:    [[TMP29:%.*]] = getelementptr float, ptr [[A]], i64 [[TMP28]]
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <4 x i64> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr float, ptr [[TMP29]], i64 [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[TMP9]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP32:%.*]] = extractelement <4 x i64> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP33:%.*]] = getelementptr float, ptr [[B]], i64 [[TMP32]]
; CHECK-NEXT:    [[INDEX:%.*]] = extractelement <4 x i64> [[VEC_PHI6]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr float, ptr [[TMP33]], i64 [[INDEX]]
; CHECK-NEXT:    [[TMP15:%.*]] = load float, ptr [[TMP1]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP16:%.*]] = fadd float [[TMP10]], [[TMP15]]
; CHECK-NEXT:    store float [[TMP16]], ptr [[TMP9]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE]]
; CHECK:       [[PRED_STORE_CONTINUE]]:
; CHECK-NEXT:    [[TMP17:%.*]] = extractelement <4 x i1> [[VEC_PHI7]], i64 1
; CHECK-NEXT:    br i1 [[TMP17]], label %[[PRED_STORE_IF10:.*]], label %[[PRED_STORE_CONTINUE11:.*]]
; CHECK:       [[PRED_STORE_IF10]]:
; CHECK-NEXT:    [[TMP18:%.*]] = or disjoint i64 [[TMP28]], 1
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr float, ptr [[A]], i64 [[TMP18]]
; CHECK-NEXT:    [[TMP20:%.*]] = extractelement <4 x i64> [[TMP5]], i64 1
; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr float, ptr [[TMP19]], i64 [[TMP20]]
; CHECK-NEXT:    [[TMP22:%.*]] = load float, ptr [[TMP21]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP23:%.*]] = extractelement <4 x i64> [[TMP2]], i64 1
; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr float, ptr [[B]], i64 [[TMP23]]
; CHECK-NEXT:    [[TMP25:%.*]] = extractelement <4 x i64> [[VEC_PHI6]], i64 1
; CHECK-NEXT:    [[TMP26:%.*]] = getelementptr float, ptr [[TMP24]], i64 [[TMP25]]
; CHECK-NEXT:    [[TMP27:%.*]] = load float, ptr [[TMP26]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP67:%.*]] = fadd float [[TMP22]], [[TMP27]]
; CHECK-NEXT:    store float [[TMP67]], ptr [[TMP21]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE11]]
; CHECK:       [[PRED_STORE_CONTINUE11]]:
; CHECK-NEXT:    [[TMP68:%.*]] = extractelement <4 x i1> [[VEC_PHI7]], i64 2
; CHECK-NEXT:    br i1 [[TMP68]], label %[[PRED_STORE_IF12:.*]], label %[[PRED_STORE_CONTINUE13:.*]]
; CHECK:       [[PRED_STORE_IF12]]:
; CHECK-NEXT:    [[TMP30:%.*]] = or disjoint i64 [[TMP28]], 2
; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr float, ptr [[A]], i64 [[TMP30]]
; CHECK-NEXT:    [[TMP69:%.*]] = extractelement <4 x i64> [[TMP5]], i64 2
; CHECK-NEXT:    [[TMP70:%.*]] = getelementptr float, ptr [[TMP31]], i64 [[TMP69]]
; CHECK-NEXT:    [[TMP34:%.*]] = load float, ptr [[TMP70]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP35:%.*]] = extractelement <4 x i64> [[TMP2]], i64 2
; CHECK-NEXT:    [[TMP36:%.*]] = getelementptr float, ptr [[B]], i64 [[TMP35]]
; CHECK-NEXT:    [[TMP37:%.*]] = extractelement <4 x i64> [[VEC_PHI6]], i64 2
; CHECK-NEXT:    [[TMP38:%.*]] = getelementptr float, ptr [[TMP36]], i64 [[TMP37]]
; CHECK-NEXT:    [[TMP39:%.*]] = load float, ptr [[TMP38]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP40:%.*]] = fadd float [[TMP34]], [[TMP39]]
; CHECK-NEXT:    store float [[TMP40]], ptr [[TMP70]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE13]]
; CHECK:       [[PRED_STORE_CONTINUE13]]:
; CHECK-NEXT:    [[TMP41:%.*]] = extractelement <4 x i1> [[VEC_PHI7]], i64 3
; CHECK-NEXT:    br i1 [[TMP41]], label %[[PRED_STORE_IF14:.*]], label %[[PRED_STORE_CONTINUE15]]
; CHECK:       [[PRED_STORE_IF14]]:
; CHECK-NEXT:    [[TMP42:%.*]] = or disjoint i64 [[TMP28]], 3
; CHECK-NEXT:    [[TMP43:%.*]] = getelementptr float, ptr [[A]], i64 [[TMP42]]
; CHECK-NEXT:    [[TMP44:%.*]] = extractelement <4 x i64> [[TMP5]], i64 3
; CHECK-NEXT:    [[TMP45:%.*]] = getelementptr float, ptr [[TMP43]], i64 [[TMP44]]
; CHECK-NEXT:    [[TMP46:%.*]] = load float, ptr [[TMP45]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP47:%.*]] = extractelement <4 x i64> [[TMP2]], i64 3
; CHECK-NEXT:    [[TMP48:%.*]] = getelementptr float, ptr [[B]], i64 [[TMP47]]
; CHECK-NEXT:    [[TMP49:%.*]] = extractelement <4 x i64> [[VEC_PHI6]], i64 3
; CHECK-NEXT:    [[TMP50:%.*]] = getelementptr float, ptr [[TMP48]], i64 [[TMP49]]
; CHECK-NEXT:    [[TMP51:%.*]] = load float, ptr [[TMP50]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[TMP52:%.*]] = fadd float [[TMP46]], [[TMP51]]
; CHECK-NEXT:    store float [[TMP52]], ptr [[TMP45]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    br label %[[PRED_STORE_CONTINUE15]]
; CHECK:       [[PRED_STORE_CONTINUE15]]:
; CHECK-NEXT:    [[TMP71:%.*]] = extractelement <4 x i64> [[VEC_PHI6]], i64 0
; CHECK-NEXT:    [[TMP54:%.*]] = add nuw nsw i64 [[TMP71]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT28:%.*]] = insertelement <4 x i64> poison, i64 [[TMP54]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT29]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT28]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP55:%.*]] = icmp eq i64 [[TMP54]], [[L]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT16:%.*]] = insertelement <4 x i1> poison, i1 [[TMP55]], i64 0
; CHECK-NEXT:    [[TMP56:%.*]] = xor <4 x i1> [[BROADCAST_SPLATINSERT16]], <i1 true, i1 poison, i1 poison, i1 poison>
; CHECK-NEXT:    [[TMP57:%.*]] = shufflevector <4 x i1> [[TMP56]], <4 x i1> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP58]] = select <4 x i1> [[VEC_PHI7]], <4 x i1> [[TMP57]], <4 x i1> zeroinitializer
; CHECK-NEXT:    [[TMP59:%.*]] = bitcast <4 x i1> [[TMP58]] to i4
; CHECK-NEXT:    [[DOTNOT:%.*]] = icmp eq i4 [[TMP59]], 0
; CHECK-NEXT:    br i1 [[DOTNOT]], label %[[MIDDLE_LATCH_LOOPEXIT20]], label %[[INNER_LOOP5]]
; CHECK:       [[MIDDLE_LATCH_LOOPEXIT20]]:
; CHECK-NEXT:    [[TMP60:%.*]] = extractelement <4 x i64> [[VEC_PHI]], i64 0
; CHECK-NEXT:    [[TMP61:%.*]] = add nuw nsw i64 [[TMP60]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT26:%.*]] = insertelement <4 x i64> poison, i64 [[TMP61]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT27]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT26]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP62:%.*]] = icmp eq i64 [[TMP61]], [[M]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT21:%.*]] = insertelement <4 x i1> poison, i1 [[TMP62]], i64 0
; CHECK-NEXT:    [[TMP63:%.*]] = xor <4 x i1> [[BROADCAST_SPLATINSERT21]], <i1 true, i1 poison, i1 poison, i1 poison>
; CHECK-NEXT:    [[TMP64:%.*]] = shufflevector <4 x i1> [[TMP63]], <4 x i1> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP65]] = select <4 x i1> [[VEC_PHI4]], <4 x i1> [[TMP64]], <4 x i1> zeroinitializer
; CHECK-NEXT:    [[TMP66:%.*]] = bitcast <4 x i1> [[TMP65]] to i4
; CHECK-NEXT:    [[DOTNOT30:%.*]] = icmp eq i4 [[TMP66]], 0
; CHECK-NEXT:    br i1 [[DOTNOT30]], label %[[OUTER_LATCH_LOOPEXIT25]], label %[[MIDDLE_LOOP3]]
; CHECK:       [[OUTER_LATCH_LOOPEXIT25]]:
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[TMP28]], 4
; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <4 x i64> [[VEC_IND]], splat (i64 4)
; CHECK-NEXT:    [[TMP53:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP53]], label %[[MIDDLE_BLOCK:.*]], label %[[VECTOR_BODY]], !llvm.loop [[LOOP10:![0-9]+]]
; CHECK:       [[MIDDLE_BLOCK]]:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], label %[[EXIT]], label %[[SCALAR_PH]]
; CHECK:       [[SCALAR_PH]]:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], %[[MIDDLE_BLOCK]] ], [ 0, %[[OUTER_LOOP_PREHEADER]] ]
; CHECK-NEXT:    br label %[[OUTER_LOOP:.*]]
; CHECK:       [[OUTER_LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ [[I_NEXT:%.*]], %[[OUTER_LATCH:.*]] ], [ [[BC_RESUME_VAL]], %[[SCALAR_PH]] ]
; CHECK-NEXT:    [[A_INV_GEP:%.*]] = getelementptr float, ptr [[A]], i64 [[I]]
; CHECK-NEXT:    [[I_X_L:%.*]] = mul i64 [[I]], [[L]]
; CHECK-NEXT:    [[B_INV_GEP:%.*]] = getelementptr float, ptr [[B]], i64 [[I_X_L]]
; CHECK-NEXT:    [[M_IS_ZERO:%.*]] = icmp eq i64 [[M]], 0
; CHECK-NEXT:    br i1 [[M_IS_ZERO]], label %[[OUTER_LATCH]], label %[[MIDDLE_LOOP:.*]]
; CHECK:       [[MIDDLE_LOOP]]:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[J_NEXT:%.*]], %[[MIDDLE_LATCH:.*]] ], [ 0, %[[OUTER_LOOP]] ]
; CHECK-NEXT:    [[L_IS_ZERO:%.*]] = icmp eq i64 [[L]], 0
; CHECK-NEXT:    br i1 [[L_IS_ZERO]], label %[[MIDDLE_LATCH]], label %[[INNER_LOOP:.*]]
; CHECK:       [[INNER_LOOP]]:
; CHECK-NEXT:    [[K:%.*]] = phi i64 [ [[K_NEXT:%.*]], %[[INNER_LOOP]] ], [ 0, %[[MIDDLE_LOOP]] ]
; CHECK-NEXT:    [[K_X_N:%.*]] = mul i64 [[K]], [[N]]
; CHECK-NEXT:    [[A_GEP:%.*]] = getelementptr float, ptr [[A_INV_GEP]], i64 [[K_X_N]]
; CHECK-NEXT:    [[B_GEP:%.*]] = getelementptr float, ptr [[B_INV_GEP]], i64 [[K]]
; CHECK-NEXT:    [[A_LOAD:%.*]] = load float, ptr [[A_GEP]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[B_LOAD:%.*]] = load float, ptr [[B_GEP]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[RES:%.*]] = fadd float [[A_LOAD]], [[B_LOAD]]
; CHECK-NEXT:    store float [[RES]], ptr [[A_GEP]], align 4, !llvm.access.group [[ACC_GRP0]]
; CHECK-NEXT:    [[K_NEXT]] = add nuw nsw i64 [[K]], 1
; CHECK-NEXT:    [[INNER_EXITCOND:%.*]] = icmp eq i64 [[K_NEXT]], [[L]]
; CHECK-NEXT:    br i1 [[INNER_EXITCOND]], label %[[MIDDLE_LATCH]], label %[[INNER_LOOP]]
; CHECK:       [[MIDDLE_LATCH]]:
; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[MIDDLE_EXITCOND:%.*]] = icmp eq i64 [[J_NEXT]], [[M]]
; CHECK-NEXT:    br i1 [[MIDDLE_EXITCOND]], label %[[OUTER_LATCH]], label %[[MIDDLE_LOOP]]
; CHECK:       [[OUTER_LATCH]]:
; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[OUTER_EXITCOND:%.*]] = icmp eq i64 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[OUTER_EXITCOND]], label %[[EXIT]], label %[[OUTER_LOOP]], !llvm.loop [[LOOP11:![0-9]+]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %N.is.zero = icmp eq i64 %N, 0
  br i1 %N.is.zero, label %exit, label %outer.loop

outer.loop:
  %i = phi i64 [ %i.next, %outer.latch ], [ 0, %entry ]
  %a.inv.gep = getelementptr float, ptr %A, i64 %i
  %i.x.L = mul i64 %i, %L
  %b.inv.gep = getelementptr float, ptr %B, i64 %i.x.L
  %M.is.zero = icmp eq i64 %M, 0
  br i1 %M.is.zero, label %outer.latch, label %middle.loop

middle.loop:
  %j = phi i64 [ %j.next, %middle.latch ], [ 0, %outer.loop ]
  %L.is.zero = icmp eq i64 %L, 0
  br i1 %L.is.zero, label %middle.latch, label %inner.loop

inner.loop:
  %k = phi i64 [ %k.next, %inner.loop ], [ 0, %middle.loop ]
  %k.x.N = mul i64 %k, %N
  %a.gep = getelementptr float, ptr %a.inv.gep, i64 %k.x.N
  %b.gep = getelementptr float, ptr %b.inv.gep, i64 %k
  %a.load = load float, ptr %a.gep, align 4, !llvm.access.group !3
  %b.load = load float, ptr %b.gep, align 4, !llvm.access.group !3
  %res = fadd float %a.load, %b.load
  store float %res, ptr %a.gep, align 4, !llvm.access.group !3
  %k.next = add nuw nsw i64 %k, 1
  %inner.exitcond = icmp eq i64 %k.next, %L
  br i1 %inner.exitcond, label %middle.latch, label %inner.loop

middle.latch:
  %j.next = add nuw nsw i64 %j, 1
  %middle.exitcond = icmp eq i64 %j.next, %M
  br i1 %middle.exitcond, label %outer.latch, label %middle.loop

outer.latch:
  %i.next = add nuw nsw i64 %i, 1
  %outer.exitcond = icmp eq i64 %i.next, %N
  br i1 %outer.exitcond, label %exit, label %outer.loop, !llvm.loop !0

exit:
  ret void
}

!0 = distinct !{!0, !1, !2}
!1 = !{!"llvm.loop.vectorize.enable", i1 true}
!2 = !{!"llvm.loop.parallel_accesses", !3}
!3 = distinct !{}
;.
; CHECK: [[ACC_GRP0]] = distinct !{}
; CHECK: [[LOOP1]] = distinct !{[[LOOP1]], [[META2:![0-9]+]], [[META3:![0-9]+]], [[META4:![0-9]+]]}
; CHECK: [[META2]] = !{!"llvm.loop.parallel_accesses", [[ACC_GRP0]]}
; CHECK: [[META3]] = !{!"llvm.loop.isvectorized", i32 1}
; CHECK: [[META4]] = !{!"llvm.loop.unroll.runtime.disable"}
; CHECK: [[LOOP5]] = distinct !{[[LOOP5]], [[META2]], [[META4]], [[META3]]}
; CHECK: [[LOOP6]] = distinct !{[[LOOP6]], [[META2]], [[META3]], [[META4]]}
; CHECK: [[LOOP7]] = distinct !{[[LOOP7]], [[META2]], [[META4]], [[META3]]}
; CHECK: [[LOOP8]] = distinct !{[[LOOP8]], [[META2]], [[META3]], [[META4]]}
; CHECK: [[LOOP9]] = distinct !{[[LOOP9]], [[META2]], [[META4]], [[META3]]}
; CHECK: [[LOOP10]] = distinct !{[[LOOP10]], [[META2]], [[META3]], [[META4]]}
; CHECK: [[LOOP11]] = distinct !{[[LOOP11]], [[META2]], [[META4]], [[META3]]}
;.
