; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=loop-vectorize -force-vector-width=4 -S | FileCheck %s


; Test cases below are reduced (and slightly modified) reproducers based on a
; problem seen when compiling a C program like this:
;
;    #include <stdint.h>
;    #include <stdio.h>
;
;    int y = 0;
;    int b = 1;
;    int d = 1;
;
;    int main() {
;      #pragma clang loop vectorize_width(4)
;      for (int i = 0; i < 3; ++i) {
;        b = (y == 0) ? d : (d / y);
;      }
;
;      if (b == 1)
;        printf("GOOD!\n");
;      else
;        printf("BAD!\n");
;    }
;
; When compiled+executed using
;    build-all/bin/clang -O1 lv-bug.c && ./a.out
; the result is "GOOD!"
;
; When compiled+executed using
;    build-all/bin/clang -O1 lv-bug.c -fvectorize && ./a.out
; the result is "BAD!"


; This test case miscompiled with clang 8.0.0 (see PR43166), now we get
;   loop not vectorized: Cannot fold tail by masking in the presence of live outs.
; instead.
define i64 @test1(i64 %y) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[Y:%.*]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq <4 x i64> [[BROADCAST_SPLAT]], zeroinitializer
; CHECK-NEXT:    [[TMP1:%.*]] = xor <4 x i64> splat (i64 3), [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[TMP0]], <4 x i64> splat (i64 77), <4 x i64> [[TMP1]]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.experimental.cttz.elts.i64.v4i1(<4 x i1> <i1 false, i1 false, i1 false, i1 true>, i1 true)
; CHECK-NEXT:    [[TMP4:%.*]] = sub i64 [[TMP3]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i64> [[PREDPHI]], i64 [[TMP4]]
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i64 [[TMP5]]
;
entry:
  br label %for.body

for.body:
  %i = phi i32 [ 0, %entry ], [ %inc, %cond.end ]
  %cmp = icmp eq i64 %y, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:
  %div = xor i64 3, %y
  br label %cond.end

cond.end:
  %cond = phi i64 [ %div, %cond.false ], [ 77, %for.body ]
  %inc = add nuw nsw i32 %i, 1
  %exitcond = icmp eq i32 %inc, 3
  br i1 %exitcond, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret i64 %cond
}

; This test case miscompiled with clang 8.0.0 (see PR43166), now we get
;   loop not vectorized: Cannot fold tail by masking in the presence of live outs.
; instead.
define i64 @test2(i64 %y) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[Y:%.*]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq <4 x i64> [[BROADCAST_SPLAT]], zeroinitializer
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[TMP0]], <4 x i64> splat (i64 77), <4 x i64> splat (i64 55)
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.experimental.cttz.elts.i64.v4i1(<4 x i1> <i1 false, i1 false, i1 false, i1 true>, i1 true)
; CHECK-NEXT:    [[TMP3:%.*]] = sub i64 [[TMP2]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x i64> [[PREDPHI]], i64 [[TMP3]]
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i64 [[TMP4]]
;
entry:
  br label %for.body

for.body:
  %i = phi i32 [ 0, %entry ], [ %inc, %cond.end ]
  %cmp = icmp eq i64 %y, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:
  br label %cond.end

cond.end:
  %cond = phi i64 [ 55, %cond.false ], [ 77, %for.body ]
  %inc = add nuw nsw i32 %i, 1
  %exitcond = icmp eq i32 %inc, 3
  br i1 %exitcond, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret i64 %cond
}

; This test case miscompiled with clang 8.0.0 (see PR43166), now we get
;   loop not vectorized: Cannot fold tail by masking in the presence of live outs.
; instead.
define i32 @test3(i64 %y) {
; CHECK-LABEL: @test3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i64> poison, i64 [[Y:%.*]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i64> [[BROADCAST_SPLATINSERT]], <4 x i64> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq <4 x i64> [[BROADCAST_SPLAT]], zeroinitializer
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[TMP0]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x i32> splat (i32 55)
; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.experimental.cttz.elts.i64.v4i1(<4 x i1> <i1 false, i1 false, i1 false, i1 true>, i1 true)
; CHECK-NEXT:    [[TMP3:%.*]] = sub i64 [[TMP2]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x i32> [[PREDPHI]], i64 [[TMP3]]
; CHECK-NEXT:    br label [[COND_END:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i32 [[TMP4]]
;
entry:
  br label %for.body

for.body:
  %i = phi i32 [ 0, %entry ], [ %inc, %cond.end ]
  %cmp = icmp eq i64 %y, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:
  br label %cond.end

cond.end:
  %cond = phi i32 [ 55, %cond.false ], [ %i, %for.body ]
  %inc = add nuw nsw i32 %i, 1
  %exitcond = icmp eq i32 %inc, 3
  br i1 %exitcond, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret i32 %cond
}
