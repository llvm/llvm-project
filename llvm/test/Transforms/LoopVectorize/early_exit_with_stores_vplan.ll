; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -p loop-vectorize -enable-early-exit-vectorization-with-side-effects -force-vector-width=4 -disable-output -vplan-print-after="optimize$" %s 2>&1 | FileCheck %s

; REQUIRES: asserts

define void @loop_contains_store_condition_load_has_single_user(ptr dereferenceable(40) noalias %array, ptr align 2 dereferenceable(40) readonly %pred) {
; CHECK-LABEL: VPlan for loop in 'loop_contains_store_condition_load_has_single_user'
; CHECK:  VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<20> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      vp<[[VP4:%[0-9]+]]> = SCALAR-STEPS vp<[[VP3]]>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      REPLICATE ir<%st.addr> = getelementptr inbounds nuw ir<%array>, vp<[[VP4]]>
; CHECK-NEXT:      CLONE ir<%ee.addr> = getelementptr inbounds nuw ir<%pred>, vp<[[VP4]]>
; CHECK-NEXT:      vp<[[VP5:%[0-9]+]]> = vector-pointer inbounds nuw ir<%ee.addr>
; CHECK-NEXT:      WIDEN ir<%ee.val> = load vp<[[VP5]]>
; CHECK-NEXT:      WIDEN ir<%ee.cond> = icmp sgt ir<%ee.val>, ir<500>
; CHECK-NEXT:      EMIT vp<[[VP6:%[0-9]+]]> = first-active-lane ir<%ee.cond>
; CHECK-NEXT:      EMIT vp<%uncountable.exit.mask> = active lane mask ir<0>, vp<[[VP6]]>, ir<1>
; CHECK-NEXT:    Successor(s): pred.load
; CHECK-EMPTY:
; CHECK-NEXT:    <xVFxUF> pred.load: {
; CHECK-NEXT:      pred.load.entry:
; CHECK-NEXT:        BRANCH-ON-MASK vp<%uncountable.exit.mask>
; CHECK-NEXT:      Successor(s): pred.load.if, pred.load.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.load.if:
; CHECK-NEXT:        REPLICATE ir<%data> = load ir<%st.addr> (S->V)
; CHECK-NEXT:      Successor(s): pred.load.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.load.continue:
; CHECK-NEXT:        PHI-PREDICATED-INSTRUCTION vp<[[VP7:%[0-9]+]]> = ir<%data>
; CHECK-NEXT:      No successors
; CHECK-NEXT:    }
; CHECK-NEXT:    Successor(s): for.body.0
; CHECK-EMPTY:
; CHECK-NEXT:    for.body.0:
; CHECK-NEXT:      WIDEN ir<%inc> = add nsw vp<[[VP7]]>, ir<1>
; CHECK-NEXT:    Successor(s): pred.store
; CHECK-EMPTY:
; CHECK-NEXT:    <xVFxUF> pred.store: {
; CHECK-NEXT:      pred.store.entry:
; CHECK-NEXT:        BRANCH-ON-MASK vp<%uncountable.exit.mask>
; CHECK-NEXT:      Successor(s): pred.store.if, pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.if:
; CHECK-NEXT:        REPLICATE store ir<%inc>, ir<%st.addr>
; CHECK-NEXT:      Successor(s): pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.continue:
; CHECK-NEXT:      No successors
; CHECK-NEXT:    }
; CHECK-NEXT:    Successor(s): for.body.1
; CHECK-EMPTY:
; CHECK-NEXT:    for.body.1:
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT vp<[[VP8:%[0-9]+]]> = any-of ir<%ee.cond>
; CHECK-NEXT:      EMIT vp<[[VP9:%[0-9]+]]> = icmp eq vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:      EMIT vp<[[VP10:%[0-9]+]]> = or vp<[[VP8]]>, vp<[[VP9]]>
; CHECK-NEXT:      EMIT branch-on-cond vp<[[VP10]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<[[VP12:%[0-9]+]]> = add vp<[[VP3]]>, vp<[[VP6]]>
; CHECK-NEXT:    EMIT vp<[[VP13:%[0-9]+]]> = icmp eq vp<[[VP12]]>, ir<20>
; CHECK-NEXT:    EMIT branch-on-cond vp<[[VP13]]>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP15:%[0-9]+]]> = phi [ vp<[[VP12]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<for.body>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<for.body>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.inc ] (extra operand: vp<[[VP15]]> from scalar.ph)
; CHECK-NEXT:    IR   %st.addr = getelementptr inbounds nuw i16, ptr %array, i64 %iv
; CHECK-NEXT:    IR   %data = load i16, ptr %st.addr, align 2
; CHECK-NEXT:    IR   %inc = add nsw i16 %data, 1
; CHECK-NEXT:    IR   store i16 %inc, ptr %st.addr, align 2
; CHECK-NEXT:    IR   %ee.addr = getelementptr inbounds nuw i16, ptr %pred, i64 %iv
; CHECK-NEXT:    IR   %ee.val = load i16, ptr %ee.addr, align 2
; CHECK-NEXT:    IR   %ee.cond = icmp sgt i16 %ee.val, 500
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.inc ]
  %st.addr = getelementptr inbounds nuw i16, ptr %array, i64 %iv
  %data = load i16, ptr %st.addr, align 2
  %inc = add nsw i16 %data, 1
  store i16 %inc, ptr %st.addr, align 2
  %ee.addr = getelementptr inbounds nuw i16, ptr %pred, i64 %iv
  %ee.val = load i16, ptr %ee.addr, align 2
  %ee.cond = icmp sgt i16 %ee.val, 500
  br i1 %ee.cond, label %exit, label %for.inc

for.inc:
  %iv.next = add nuw nsw i64 %iv, 1
  %counted.cond = icmp eq i64 %iv.next, 20
  br i1 %counted.cond, label %exit, label %for.body

exit:
  ret void
}

define void @loop_contains_store_after_uncountable_exit(ptr dereferenceable(40) noalias %array, ptr align 2 dereferenceable(40) readonly %pred) {
; CHECK-LABEL: VPlan for loop in 'loop_contains_store_after_uncountable_exit'
; CHECK:  VPlan 'Initial VPlan for VF={4},UF>=1' {
; CHECK-NEXT:  Live-in vp<[[VP0:%[0-9]+]]> = VF
; CHECK-NEXT:  Live-in vp<[[VP1:%[0-9]+]]> = VF * UF
; CHECK-NEXT:  Live-in vp<[[VP2:%[0-9]+]]> = vector-trip-count
; CHECK-NEXT:  Live-in ir<20> = original trip-count
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<entry>:
; CHECK-NEXT:  Successor(s): scalar.ph, vector.ph
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:  Successor(s): vector loop
; CHECK-EMPTY:
; CHECK-NEXT:  <x1> vector loop: {
; CHECK-NEXT:    vector.body:
; CHECK-NEXT:      EMIT vp<[[VP3:%[0-9]+]]> = CANONICAL-INDUCTION ir<0>, vp<%index.next>
; CHECK-NEXT:      vp<[[VP4:%[0-9]+]]> = SCALAR-STEPS vp<[[VP3]]>, ir<1>, vp<[[VP0]]>
; CHECK-NEXT:      CLONE ir<%ee.addr> = getelementptr inbounds nuw ir<%pred>, vp<[[VP4]]>
; CHECK-NEXT:      vp<[[VP5:%[0-9]+]]> = vector-pointer inbounds nuw ir<%ee.addr>
; CHECK-NEXT:      WIDEN ir<%ee.val> = load vp<[[VP5]]>
; CHECK-NEXT:      WIDEN ir<%ee.cond> = icmp sgt ir<%ee.val>, ir<500>
; CHECK-NEXT:      EMIT vp<[[VP6:%[0-9]+]]> = first-active-lane ir<%ee.cond>
; CHECK-NEXT:      EMIT vp<%uncountable.exit.mask> = active lane mask ir<0>, vp<[[VP6]]>, ir<1>
; CHECK-NEXT:      REPLICATE ir<%st.addr> = getelementptr inbounds nuw ir<%array>, vp<[[VP4]]>
; CHECK-NEXT:    Successor(s): pred.load
; CHECK-EMPTY:
; CHECK-NEXT:    <xVFxUF> pred.load: {
; CHECK-NEXT:      pred.load.entry:
; CHECK-NEXT:        BRANCH-ON-MASK vp<%uncountable.exit.mask>
; CHECK-NEXT:      Successor(s): pred.load.if, pred.load.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.load.if:
; CHECK-NEXT:        REPLICATE ir<%data> = load ir<%st.addr> (S->V)
; CHECK-NEXT:      Successor(s): pred.load.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.load.continue:
; CHECK-NEXT:        PHI-PREDICATED-INSTRUCTION vp<[[VP7:%[0-9]+]]> = ir<%data>
; CHECK-NEXT:      No successors
; CHECK-NEXT:    }
; CHECK-NEXT:    Successor(s): for.inc.0
; CHECK-EMPTY:
; CHECK-NEXT:    for.inc.0:
; CHECK-NEXT:      WIDEN ir<%inc> = add nsw vp<[[VP7]]>, ir<1>
; CHECK-NEXT:    Successor(s): pred.store
; CHECK-EMPTY:
; CHECK-NEXT:    <xVFxUF> pred.store: {
; CHECK-NEXT:      pred.store.entry:
; CHECK-NEXT:        BRANCH-ON-MASK vp<%uncountable.exit.mask>
; CHECK-NEXT:      Successor(s): pred.store.if, pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.if:
; CHECK-NEXT:        REPLICATE store ir<%inc>, ir<%st.addr>
; CHECK-NEXT:      Successor(s): pred.store.continue
; CHECK-EMPTY:
; CHECK-NEXT:      pred.store.continue:
; CHECK-NEXT:      No successors
; CHECK-NEXT:    }
; CHECK-NEXT:    Successor(s): for.inc.1
; CHECK-EMPTY:
; CHECK-NEXT:    for.inc.1:
; CHECK-NEXT:      EMIT vp<%index.next> = add nuw vp<[[VP3]]>, vp<[[VP1]]>
; CHECK-NEXT:      EMIT vp<[[VP8:%[0-9]+]]> = any-of ir<%ee.cond>
; CHECK-NEXT:      EMIT vp<[[VP9:%[0-9]+]]> = icmp eq vp<%index.next>, vp<[[VP2]]>
; CHECK-NEXT:      EMIT vp<[[VP10:%[0-9]+]]> = or vp<[[VP8]]>, vp<[[VP9]]>
; CHECK-NEXT:      EMIT branch-on-cond vp<[[VP10]]>
; CHECK-NEXT:    No successors
; CHECK-NEXT:  }
; CHECK-NEXT:  Successor(s): middle.block
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    EMIT vp<[[VP12:%[0-9]+]]> = add vp<[[VP3]]>, vp<[[VP6]]>
; CHECK-NEXT:    EMIT vp<[[VP13:%[0-9]+]]> = icmp eq vp<[[VP12]]>, ir<20>
; CHECK-NEXT:    EMIT branch-on-cond vp<[[VP13]]>
; CHECK-NEXT:  Successor(s): ir-bb<exit>, scalar.ph
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<exit>:
; CHECK-NEXT:  No successors
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    EMIT-SCALAR vp<[[VP15:%[0-9]+]]> = phi [ vp<[[VP12]]>, middle.block ], [ ir<0>, ir-bb<entry> ]
; CHECK-NEXT:  Successor(s): ir-bb<for.body>
; CHECK-EMPTY:
; CHECK-NEXT:  ir-bb<for.body>:
; CHECK-NEXT:    IR   %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.inc ] (extra operand: vp<[[VP15]]> from scalar.ph)
; CHECK-NEXT:    IR   %ee.addr = getelementptr inbounds nuw i16, ptr %pred, i64 %iv
; CHECK-NEXT:    IR   %ee.val = load i16, ptr %ee.addr, align 2
; CHECK-NEXT:    IR   %ee.cond = icmp sgt i16 %ee.val, 500
; CHECK-NEXT:  No successors
; CHECK-NEXT:  }
;
entry:
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.inc ]
  %ee.addr = getelementptr inbounds nuw i16, ptr %pred, i64 %iv
  %ee.val = load i16, ptr %ee.addr, align 2
  %ee.cond = icmp sgt i16 %ee.val, 500
  br i1 %ee.cond, label %exit, label %for.inc

for.inc:
  %st.addr = getelementptr inbounds nuw i16, ptr %array, i64 %iv
  %data = load i16, ptr %st.addr, align 2
  %inc = add nsw i16 %data, 1
  store i16 %inc, ptr %st.addr, align 2
  %iv.next = add nuw nsw i64 %iv, 1
  %counted.cond = icmp eq i64 %iv.next, 20
  br i1 %counted.cond, label %exit, label %for.body

exit:
  ret void
}
