; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s  -loop-vectorize -S | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:1"
target triple = "x86_64-unknown-linux-gnu"

; This cannot be correctly vectorized with type i1.
define i8 @test_01(i8 %c) #0 {
; CHECK-LABEL: @test_01(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[ACCUM_PLUS_LCSSA:%.*]] = phi i8 [ [[ACCUM_PLUS:%.*]], [[LOOP]] ]
; CHECK-NEXT:    ret i8 [[ACCUM_PLUS_LCSSA]]
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi i8 [ [[C:%.*]], [[ENTRY:%.*]] ], [ [[ACCUM_PLUS]], [[LOOP]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 1, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ACCUM_AND:%.*]] = and i8 [[ACCUM_PHI]], 1
; CHECK-NEXT:    [[ACCUM_PLUS]] = add nuw nsw i8 [[ACCUM_AND]], 3
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ugt i32 [[IV]], 191
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
;

entry:
  br label %loop

exit:                                           ; preds = %loop
  ret i8 %accum.plus

loop:                                            ; preds = %loop, %entry
  %accum.phi = phi i8 [ %c, %entry ], [ %accum.plus, %loop ]
  %iv = phi i32 [ 1, %entry ], [ %iv.next, %loop ]
  %accum.and = and i8 %accum.phi, 1
  %accum.plus = add nuw nsw i8 %accum.and, 3
  %iv.next = add nuw nsw i32 %iv, 1
  %cond = icmp ugt i32 %iv, 191
  br i1 %cond, label %exit, label %loop
}

; TODO: This can be vectorized with type i1 because the result is not used.
define void @test_02(i8 %c) #0 {
; CHECK-LABEL: @test_02(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[LCSSA:%.*]] = phi i8 [ [[ACCUM_PLUS:%.*]], [[LOOP]] ]
; CHECK-NEXT:    ret void
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi i8 [ [[C:%.*]], [[ENTRY:%.*]] ], [ [[ACCUM_PLUS]], [[LOOP]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 1, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ACCUM_AND:%.*]] = and i8 [[ACCUM_PHI]], 1
; CHECK-NEXT:    [[ACCUM_PLUS]] = add nuw nsw i8 [[ACCUM_AND]], 3
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ugt i32 [[IV]], 191
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
;

entry:
  br label %loop

exit:                                           ; preds = %loop
  %lcssa = phi i8 [ %accum.plus, %loop ]
  ret void

loop:                                            ; preds = %loop, %entry
  %accum.phi = phi i8 [ %c, %entry ], [ %accum.plus, %loop ]
  %iv = phi i32 [ 1, %entry ], [ %iv.next, %loop ]
  %accum.and = and i8 %accum.phi, 1
  %accum.plus = add nuw nsw i8 %accum.and, 3
  %iv.next = add nuw nsw i32 %iv, 1
  %cond = icmp ugt i32 %iv, 191
  br i1 %cond, label %exit, label %loop
}

; This can be vectorized with type i1 because the result is truncated properly.
define i1 @test_03(i8 %c) #0 {
; CHECK-LABEL: @test_03(
; CHECK-NEXT:  iter.check:
; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_SCALAR_PH:%.*]], label [[VECTOR_MAIN_LOOP_ITER_CHECK:%.*]]
; CHECK:       vector.main.loop.iter.check:
; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <16 x i8> zeroinitializer, i8 [[C:%.*]], i32 0
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <16 x i8> [ [[TMP0]], [[VECTOR_PH]] ], [ [[TMP7:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI1:%.*]] = phi <16 x i8> [ zeroinitializer, [[VECTOR_PH]] ], [ [[TMP9:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = and <16 x i8> [[VEC_PHI]], <i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <16 x i8> [[VEC_PHI1]], <i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1>
; CHECK-NEXT:    [[TMP3:%.*]] = add <16 x i8> [[TMP1]], <i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3>
; CHECK-NEXT:    [[TMP4:%.*]] = add <16 x i8> [[TMP2]], <i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3>
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 32
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[INDEX_NEXT]], 192
; CHECK-NEXT:    [[TMP6:%.*]] = trunc <16 x i8> [[TMP3]] to <16 x i1>
; CHECK-NEXT:    [[TMP7]] = zext <16 x i1> [[TMP6]] to <16 x i8>
; CHECK-NEXT:    [[TMP8:%.*]] = trunc <16 x i8> [[TMP4]] to <16 x i1>
; CHECK-NEXT:    [[TMP9]] = zext <16 x i1> [[TMP8]] to <16 x i8>
; CHECK-NEXT:    br i1 [[TMP5]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP10:%.*]] = trunc <16 x i8> [[TMP7]] to <16 x i1>
; CHECK-NEXT:    [[TMP11:%.*]] = trunc <16 x i8> [[TMP9]] to <16 x i1>
; CHECK-NEXT:    [[BIN_RDX:%.*]] = add <16 x i1> [[TMP11]], [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = call i1 @llvm.vector.reduce.add.v16i1(<16 x i1> [[BIN_RDX]])
; CHECK-NEXT:    [[TMP13:%.*]] = zext i1 [[TMP12]] to i8
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 192, 192
; CHECK-NEXT:    br i1 [[CMP_N]], label [[EXIT:%.*]], label [[VEC_EPILOG_ITER_CHECK:%.*]]
; CHECK:       vec.epilog.iter.check:
; CHECK-NEXT:    br i1 true, label [[VEC_EPILOG_SCALAR_PH]], label [[VEC_EPILOG_PH]]
; CHECK:       vec.epilog.ph:
; CHECK-NEXT:    [[BC_MERGE_RDX:%.*]] = phi i8 [ [[C]], [[VECTOR_MAIN_LOOP_ITER_CHECK]] ], [ [[TMP13]], [[VEC_EPILOG_ITER_CHECK]] ]
; CHECK-NEXT:    [[VEC_EPILOG_RESUME_VAL:%.*]] = phi i32 [ 192, [[VEC_EPILOG_ITER_CHECK]] ], [ 0, [[VECTOR_MAIN_LOOP_ITER_CHECK]] ]
; CHECK-NEXT:    [[TMP14:%.*]] = insertelement <8 x i8> zeroinitializer, i8 [[BC_MERGE_RDX]], i32 0
; CHECK-NEXT:    br label [[VEC_EPILOG_VECTOR_BODY:%.*]]
; CHECK:       vec.epilog.vector.body:
; CHECK-NEXT:    [[INDEX3:%.*]] = phi i32 [ [[VEC_EPILOG_RESUME_VAL]], [[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT5:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI4:%.*]] = phi <8 x i8> [ [[TMP14]], [[VEC_EPILOG_PH]] ], [ [[TMP19:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = and <8 x i8> [[VEC_PHI4]], <i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1, i8 1>
; CHECK-NEXT:    [[TMP16:%.*]] = add <8 x i8> [[TMP15]], <i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3>
; CHECK-NEXT:    [[INDEX_NEXT5]] = add nuw i32 [[INDEX3]], 8
; CHECK-NEXT:    [[TMP17:%.*]] = icmp eq i32 [[INDEX_NEXT5]], 192
; CHECK-NEXT:    [[TMP18:%.*]] = trunc <8 x i8> [[TMP16]] to <8 x i1>
; CHECK-NEXT:    [[TMP19]] = zext <8 x i1> [[TMP18]] to <8 x i8>
; CHECK-NEXT:    br i1 [[TMP17]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       vec.epilog.middle.block:
; CHECK-NEXT:    [[TMP20:%.*]] = trunc <8 x i8> [[TMP19]] to <8 x i1>
; CHECK-NEXT:    [[TMP21:%.*]] = call i1 @llvm.vector.reduce.add.v8i1(<8 x i1> [[TMP20]])
; CHECK-NEXT:    [[TMP22:%.*]] = zext i1 [[TMP21]] to i8
; CHECK-NEXT:    [[CMP_N2:%.*]] = icmp eq i32 192, 192
; CHECK-NEXT:    br i1 [[CMP_N2]], label [[EXIT_LOOPEXIT:%.*]], label [[VEC_EPILOG_SCALAR_PH]]
; CHECK:       vec.epilog.scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ 193, [[VEC_EPILOG_MIDDLE_BLOCK]] ], [ 193, [[VEC_EPILOG_ITER_CHECK]] ], [ 1, [[ITER_CHECK:%.*]] ]
; CHECK-NEXT:    [[BC_MERGE_RDX6:%.*]] = phi i8 [ [[C]], [[ITER_CHECK]] ], [ [[TMP13]], [[VEC_EPILOG_ITER_CHECK]] ], [ [[TMP22]], [[VEC_EPILOG_MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    [[ACCUM_PLUS_LCSSA:%.*]] = phi i8 [ [[ACCUM_PLUS:%.*]], [[LOOP]] ], [ [[TMP22]], [[VEC_EPILOG_MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[LCSSA:%.*]] = phi i8 [ [[TMP13]], [[MIDDLE_BLOCK]] ], [ [[ACCUM_PLUS_LCSSA]], [[EXIT_LOOPEXIT]] ]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i8 [[LCSSA]] to i1
; CHECK-NEXT:    ret i1 [[TRUNC]]
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi i8 [ [[BC_MERGE_RDX6]], [[VEC_EPILOG_SCALAR_PH]] ], [ [[ACCUM_PLUS]], [[LOOP]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[VEC_EPILOG_SCALAR_PH]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ACCUM_AND:%.*]] = and i8 [[ACCUM_PHI]], 1
; CHECK-NEXT:    [[ACCUM_PLUS]] = add nuw nsw i8 [[ACCUM_AND]], 3
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ugt i32 [[IV]], 191
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT_LOOPEXIT]], label [[LOOP]], !llvm.loop [[LOOP4:![0-9]+]]
;

entry:
  br label %loop

exit:                                           ; preds = %loop
  %lcssa = phi i8 [ %accum.plus, %loop ]
  %trunc = trunc i8 %lcssa to i1
  ret i1 %trunc

loop:                                            ; preds = %loop, %entry
  %accum.phi = phi i8 [ %c, %entry ], [ %accum.plus, %loop ]
  %iv = phi i32 [ 1, %entry ], [ %iv.next, %loop ]
  %accum.and = and i8 %accum.phi, 1
  %accum.plus = add nuw nsw i8 %accum.and, 3
  %iv.next = add nuw nsw i32 %iv, 1
  %cond = icmp ugt i32 %iv, 191
  br i1 %cond, label %exit, label %loop
}

; This cannot be vectorized with type i1 because the result is truncated to a
; wrong type.
; TODO: It can also be vectorized with type i32 (or maybe i4?)
define i4 @test_04(i8 %c) #0 {
; CHECK-LABEL: @test_04(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[LCSSA:%.*]] = phi i8 [ [[ACCUM_PLUS:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i8 [[LCSSA]] to i4
; CHECK-NEXT:    ret i4 [[TRUNC]]
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi i8 [ [[C:%.*]], [[ENTRY:%.*]] ], [ [[ACCUM_PLUS]], [[LOOP]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 1, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[ACCUM_AND:%.*]] = and i8 [[ACCUM_PHI]], 1
; CHECK-NEXT:    [[ACCUM_PLUS]] = add nuw nsw i8 [[ACCUM_AND]], 3
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ugt i32 [[IV]], 191
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
;

entry:
  br label %loop

exit:                                           ; preds = %loop
  %lcssa = phi i8 [ %accum.plus, %loop ]
  %trunc = trunc i8 %lcssa to i4
  ret i4 %trunc

loop:                                            ; preds = %loop, %entry
  %accum.phi = phi i8 [ %c, %entry ], [ %accum.plus, %loop ]
  %iv = phi i32 [ 1, %entry ], [ %iv.next, %loop ]
  %accum.and = and i8 %accum.phi, 1
  %accum.plus = add nuw nsw i8 %accum.and, 3
  %iv.next = add nuw nsw i32 %iv, 1
  %cond = icmp ugt i32 %iv, 191
  br i1 %cond, label %exit, label %loop
}
