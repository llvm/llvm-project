; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes='lower-switch,unify-loop-exits' -S | FileCheck %s

define void @nested(i1 %PredB3, i1 %PredB4, i1 %PredA4, i1 %PredA3, i32 %X, i32 %Y, i32 %Z) {
; CHECK-LABEL: @nested(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[A1:%.*]]
; CHECK:       A1:
; CHECK-NEXT:    br label [[B1:%.*]]
; CHECK:       B1:
; CHECK-NEXT:    br label [[B2:%.*]]
; CHECK:       B2:
; CHECK-NEXT:    [[X_INC:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    br label [[B3:%.*]]
; CHECK:       B3:
; CHECK-NEXT:    br i1 [[PREDB3:%.*]], label [[B4:%.*]], label [[LOOP_EXIT_GUARD1:%.*]]
; CHECK:       B4:
; CHECK-NEXT:    br i1 [[PREDB4:%.*]], label [[B1]], label [[LOOP_EXIT_GUARD1]]
; CHECK:       A2:
; CHECK-NEXT:    br label [[A4:%.*]]
; CHECK:       A3:
; CHECK-NEXT:    br label [[A4]]
; CHECK:       A4:
; CHECK-NEXT:    [[A4_PHI:%.*]] = phi i32 [ [[Y:%.*]], [[A3:%.*]] ], [ [[X_INC_MOVED:%.*]], [[A2:%.*]] ]
; CHECK-NEXT:    br i1 [[PREDA4:%.*]], label [[LOOP_EXIT_GUARD:%.*]], label [[A5:%.*]]
; CHECK:       A5:
; CHECK-NEXT:    br i1 [[PREDA3:%.*]], label [[LOOP_EXIT_GUARD]], label [[A1]]
; CHECK:       C:
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[EXIT_PHI:%.*]] = phi i32 [ [[Z:%.*]], [[C:%.*]] ], [ [[EXIT_PHI_MOVED:%.*]], [[LOOP_EXIT_GUARD]] ]
; CHECK-NEXT:    ret void
; CHECK:       loop.exit.guard:
; CHECK-NEXT:    [[EXIT_PHI_MOVED]] = phi i32 [ poison, [[A4]] ], [ [[A4_PHI]], [[A5]] ]
; CHECK-NEXT:    [[GUARD_C:%.*]] = phi i1 [ true, [[A4]] ], [ false, [[A5]] ]
; CHECK-NEXT:    br i1 [[GUARD_C]], label [[C]], label [[EXIT]]
; CHECK:       loop.exit.guard1:
; CHECK-NEXT:    [[X_INC_MOVED]] = phi i32 [ [[X_INC]], [[B3]] ], [ [[X_INC]], [[B4]] ]
; CHECK-NEXT:    [[GUARD_A3:%.*]] = phi i1 [ true, [[B3]] ], [ false, [[B4]] ]
; CHECK-NEXT:    br i1 [[GUARD_A3]], label [[A3]], label [[A2]]
;
entry:
  br label %A1

A1:
  br label %B1

B1:
  br label %B2

B2:
  %X.inc = add i32 %X, 1
  br label %B3

B3:
  br i1 %PredB3, label %B4, label %A3

B4:
  br i1 %PredB4, label %B1, label %A2

A2:
  br label %A4

A3:
  br label %A4

A4:
  %A4.phi = phi i32 [%Y, %A3], [%X.inc, %A2]
  br i1 %PredA4, label %C, label %A5

A5:
  br i1 %PredA3, label %exit, label %A1

C:
  br label %exit

exit:
  %exit.phi = phi i32 [%A4.phi, %A5], [%Z, %C]
  ret void
}

define void @nested_callbr(i1 %PredB3, i1 %PredB4, i1 %PredA4, i1 %PredA3, i32 %X, i32 %Y, i32 %Z) {
; CHECK-LABEL: @nested_callbr(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[A1:%.*]]
; CHECK:       A1:
; CHECK-NEXT:    br label [[B1:%.*]]
; CHECK:       B1:
; CHECK-NEXT:    br label [[B2:%.*]]
; CHECK:       B2:
; CHECK-NEXT:    [[X_INC:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    br label [[B3:%.*]]
; CHECK:       B3:
; CHECK-NEXT:    callbr void asm "", "r,!i"(i1 [[PREDB3:%.*]])
; CHECK-NEXT:            to label [[B4:%.*]] [label %B3.target.A3]
; CHECK:       B4:
; CHECK-NEXT:    callbr void asm "", "r,!i"(i1 [[PREDB4:%.*]])
; CHECK-NEXT:            to label [[B1]] [label %B4.target.A2]
; CHECK:       A2:
; CHECK-NEXT:    br label [[A4:%.*]]
; CHECK:       A3:
; CHECK-NEXT:    br label [[A4]]
; CHECK:       A4:
; CHECK-NEXT:    [[A4_PHI:%.*]] = phi i32 [ [[Y:%.*]], [[A3:%.*]] ], [ [[X_INC_MOVED:%.*]], [[A2:%.*]] ]
; CHECK-NEXT:    callbr void asm "", "r,!i"(i1 [[PREDA4:%.*]])
; CHECK-NEXT:            to label [[A4_TARGET_C:%.*]] [label %A5]
; CHECK:       A5:
; CHECK-NEXT:    callbr void asm "", "r,!i"(i1 [[PREDA3:%.*]])
; CHECK-NEXT:            to label [[A5_TARGET_EXIT:%.*]] [label %A1]
; CHECK:       C:
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[EXIT_PHI:%.*]] = phi i32 [ [[Z:%.*]], [[C:%.*]] ], [ [[EXIT_PHI_MOVED:%.*]], [[LOOP_EXIT_GUARD:%.*]] ]
; CHECK-NEXT:    ret void
; CHECK:       A4.target.C:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD]]
; CHECK:       A5.target.exit:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD]]
; CHECK:       loop.exit.guard:
; CHECK-NEXT:    [[EXIT_PHI_MOVED]] = phi i32 [ poison, [[A4_TARGET_C]] ], [ [[A4_PHI]], [[A5_TARGET_EXIT]] ]
; CHECK-NEXT:    [[GUARD_C:%.*]] = phi i1 [ true, [[A4_TARGET_C]] ], [ false, [[A5_TARGET_EXIT]] ]
; CHECK-NEXT:    br i1 [[GUARD_C]], label [[C]], label [[EXIT]]
; CHECK:       B3.target.A3:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD1:%.*]]
; CHECK:       B4.target.A2:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD1]]
; CHECK:       loop.exit.guard1:
; CHECK-NEXT:    [[X_INC_MOVED]] = phi i32 [ [[X_INC]], [[B3_TARGET_A3:%.*]] ], [ [[X_INC]], [[B4_TARGET_A2:%.*]] ]
; CHECK-NEXT:    [[GUARD_A3:%.*]] = phi i1 [ true, [[B3_TARGET_A3]] ], [ false, [[B4_TARGET_A2]] ]
; CHECK-NEXT:    br i1 [[GUARD_A3]], label [[A3]], label [[A2]]
;
entry:
  br label %A1

A1:
  br label %B1

B1:
  br label %B2

B2:
  %X.inc = add i32 %X, 1
  br label %B3

B3:
  callbr void asm "", "r,!i"(i1 %PredB3) to label %B4 [label %A3]

B4:
  callbr void asm "", "r,!i"(i1 %PredB4) to label %B1 [label %A2]

A2:
  br label %A4

A3:
  br label %A4

A4:
  %A4.phi = phi i32 [%Y, %A3], [%X.inc, %A2]
  callbr void asm "", "r,!i"(i1 %PredA4) to label %C [label %A5]

A5:
  callbr void asm "", "r,!i"(i1 %PredA3) to label %exit [label %A1]

C:
  br label %exit

exit:
  %exit.phi = phi i32 [%A4.phi, %A5], [%Z, %C]
  ret void
}

; Here, the newly created target loop that connects b to r1 needs to be part of
; the parent loop (the outer loop b participates in). Otherwise, it will be
; regarded as an additional loop entry point to this outer loop.
define void @nested_callbr_multiple_exits() {
; CHECK-LABEL: @nested_callbr_multiple_exits(
; CHECK-NEXT:    br label [[A:%.*]]
; CHECK:       a:
; CHECK-NEXT:    callbr void asm "", ""()
; CHECK-NEXT:            to label [[B:%.*]] []
; CHECK:       b:
; CHECK-NEXT:    callbr void asm "", "!i"()
; CHECK-NEXT:            to label [[C:%.*]] [label %b.target.b.target.r1]
; CHECK:       c:
; CHECK-NEXT:    callbr void asm "", "!i"()
; CHECK-NEXT:            to label [[C_TARGET_E:%.*]] [label %b]
; CHECK:       e:
; CHECK-NEXT:    callbr void asm "", "!i"()
; CHECK-NEXT:            to label [[A]] [label %e.target.r2]
; CHECK:       r1:
; CHECK-NEXT:    ret void
; CHECK:       r2:
; CHECK-NEXT:    ret void
; CHECK:       b.target.r1:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD:%.*]]
; CHECK:       e.target.r2:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD]]
; CHECK:       loop.exit.guard:
; CHECK-NEXT:    [[GUARD_R1:%.*]] = phi i1 [ true, [[B_TARGET_R1:%.*]] ], [ false, [[E_TARGET_R2:%.*]] ]
; CHECK-NEXT:    br i1 [[GUARD_R1]], label [[R1:%.*]], label [[R2:%.*]]
; CHECK:       b.target.b.target.r1:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD1:%.*]]
; CHECK:       c.target.e:
; CHECK-NEXT:    br label [[LOOP_EXIT_GUARD1]]
; CHECK:       loop.exit.guard1:
; CHECK-NEXT:    [[GUARD_B_TARGET_R1:%.*]] = phi i1 [ true, [[B_TARGET_B_TARGET_R1:%.*]] ], [ false, [[C_TARGET_E]] ]
; CHECK-NEXT:    br i1 [[GUARD_B_TARGET_R1]], label [[B_TARGET_R1]], label [[E:%.*]]
;
  br label %a
a:
  callbr void asm "", ""() to label %b []
b:
  callbr void asm "", "!i"() to label %c [label %r1]
c:
  callbr void asm "", "!i"() to label %e [label %b]
e:
  callbr void asm "", "!i"() to label %a [label %r2]
r1:
  ret void
r2:
  ret void
}
