; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -S -passes=instcombine | FileCheck %s

; ctpop(~i & (i - 1)) -> bitwidth - cttz(i, false)
define i8 @ctlz_to_sub_bw_cttz(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call range(i8 0, 9) i8 @llvm.cttz.i8(i8 [[A0]], i1 false)
; CHECK-NEXT:    [[CLZ:%.*]] = sub nuw nsw i8 8, [[TMP1]]
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, -1
  %not = xor i8 %a0, -1
  %and = and i8 %dec, %not
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 false)
  ret i8 %clz
}

define i8 @ctlz_to_sub_bw_cttz_poison(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz_poison(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call range(i8 0, 9) i8 @llvm.cttz.i8(i8 [[A0]], i1 false)
; CHECK-NEXT:    [[CLZ:%.*]] = sub nuw nsw i8 8, [[TMP1]]
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, -1
  %not = xor i8 %a0, -1
  %and = and i8 %dec, %not
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 true)
  ret i8 %clz
}

define i8 @ctlz_to_sub_bw_cttz_different_add(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz_different_add(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[DEC:%.*]] = add i8 [[A0]], 1
; CHECK-NEXT:    [[NOT:%.*]] = xor i8 [[A0]], -1
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[DEC]], [[NOT]]
; CHECK-NEXT:    [[CLZ:%.*]] = tail call range(i8 0, 9) i8 @llvm.ctlz.i8(i8 [[AND]], i1 false)
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, 1
  %not = xor i8 %a0, -1
  %and = and i8 %dec, %not
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 false)
  ret i8 %clz
}

define i8 @ctlz_to_sub_bw_cttz_different_xor(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz_different_xor(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[DEC:%.*]] = add i8 [[A0]], -1
; CHECK-NEXT:    [[NOT:%.*]] = xor i8 [[A0]], 1
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[DEC]], [[NOT]]
; CHECK-NEXT:    [[CLZ:%.*]] = tail call range(i8 0, 9) i8 @llvm.ctlz.i8(i8 [[AND]], i1 false)
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, -1
  %not = xor i8 %a0, 1
  %and = and i8 %dec, %not
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 false)
  ret i8 %clz
}

declare void @use(i8)

define i8 @ctlz_to_sub_bw_cttz_multi_use_dec(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz_multi_use_dec(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[DEC:%.*]] = add i8 [[A0]], -1
; CHECK-NEXT:    call void @use(i8 [[DEC]])
; CHECK-NEXT:    [[TMP1:%.*]] = call range(i8 0, 9) i8 @llvm.cttz.i8(i8 [[A0]], i1 false)
; CHECK-NEXT:    [[CLZ:%.*]] = sub nuw nsw i8 8, [[TMP1]]
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, -1
  call void @use(i8 %dec)
  %not = xor i8 %a0, -1
  %and = and i8 %dec, %not
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 false)
  ret i8 %clz
}

define i8 @ctlz_to_sub_bw_cttz_multi_use_not(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz_multi_use_not(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[NOT:%.*]] = xor i8 [[A0]], -1
; CHECK-NEXT:    call void @use(i8 [[NOT]])
; CHECK-NEXT:    [[TMP1:%.*]] = call range(i8 0, 9) i8 @llvm.cttz.i8(i8 [[A0]], i1 false)
; CHECK-NEXT:    [[CLZ:%.*]] = sub nuw nsw i8 8, [[TMP1]]
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, -1
  %not = xor i8 %a0, -1
  call void @use(i8 %not)
  %and = and i8 %dec, %not
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 false)
  ret i8 %clz
}

define i8 @ctlz_to_sub_bw_cttz_multi_use_and(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz_multi_use_and(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[DEC:%.*]] = add i8 [[A0]], -1
; CHECK-NEXT:    [[NOT:%.*]] = xor i8 [[A0]], -1
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[DEC]], [[NOT]]
; CHECK-NEXT:    call void @use(i8 [[AND]])
; CHECK-NEXT:    [[CLZ:%.*]] = tail call range(i8 0, 9) i8 @llvm.ctlz.i8(i8 [[AND]], i1 false)
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, -1
  %not = xor i8 %a0, -1
  %and = and i8 %dec, %not
  call void @use(i8 %and)
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 false)
  ret i8 %clz
}

define i8 @ctlz_to_sub_bw_cttz_commute_and(i8 %a0) {
; CHECK-LABEL: define i8 @ctlz_to_sub_bw_cttz_commute_and(
; CHECK-SAME: i8 [[A0:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call range(i8 0, 9) i8 @llvm.cttz.i8(i8 [[A0]], i1 false)
; CHECK-NEXT:    [[CLZ:%.*]] = sub nuw nsw i8 8, [[TMP1]]
; CHECK-NEXT:    ret i8 [[CLZ]]
;
  %dec = add i8 %a0, -1
  %not = xor i8 %a0, -1
  %and = and i8 %not, %dec
  %clz = tail call i8 @llvm.ctlz.i8(i8 %and, i1 false)
  ret i8 %clz
}

define <2 x i8> @ctlz_to_sub_bw_cttz_vec_splat(<2 x i8> %a0) {
; CHECK-LABEL: define <2 x i8> @ctlz_to_sub_bw_cttz_vec_splat(
; CHECK-SAME: <2 x i8> [[A0:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call range(i8 0, 9) <2 x i8> @llvm.cttz.v2i8(<2 x i8> [[A0]], i1 false)
; CHECK-NEXT:    [[CLZ:%.*]] = sub nuw nsw <2 x i8> splat (i8 8), [[TMP1]]
; CHECK-NEXT:    ret <2 x i8> [[CLZ]]
;
  %dec = add <2 x i8> %a0, <i8 -1, i8 -1>
  %not = xor <2 x i8> %a0, <i8 -1, i8 -1>
  %and = and <2 x i8> %dec, %not
  %clz = tail call <2 x i8>@llvm.ctlz.v2i8(<2 x i8> %and, i1 false)
  ret <2 x i8> %clz
}
