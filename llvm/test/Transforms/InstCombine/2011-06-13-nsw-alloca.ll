; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -opaque-pointers=0 -S -passes=instcombine < %s | FileCheck %s
target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32"
target triple = "i386-apple-darwin10.0.0"

define void @fu1(i32 %parm) #0 {
; CHECK-LABEL: define void @fu1
; CHECK-SAME: (i32 [[PARM:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[PTR:%.*]] = alloca double*, align 4
; CHECK-NEXT:    store i32 [[PARM]], i32* [[I]], align 4
; CHECK-NEXT:    store double* null, double** [[PTR]], align 4
; CHECK-NEXT:    [[I2_NOT:%.*]] = icmp eq i32 [[PARM]], 0
; CHECK-NEXT:    br i1 [[I2_NOT]], label [[BB9:%.*]], label [[BB3:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    [[I4:%.*]] = load i32, i32* [[I]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[I4]], 256
; CHECK-NEXT:    [[I7:%.*]] = alloca double, i32 [[TMP0]], align 1
; CHECK-NEXT:    store double* [[I7]], double** [[PTR]], align 4
; CHECK-NEXT:    br label [[BB9]]
; CHECK:       bb9:
; CHECK-NEXT:    [[I10:%.*]] = load double*, double** [[PTR]], align 4
; CHECK-NEXT:    call void @bar(double* [[I10]]) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    ret void
;
bb:
  %i = alloca i32, align 4

  %ptr = alloca double*, align 4
  store i32 %parm, i32* %i, align 4
  store double* null, double** %ptr, align 4
  %i1 = load i32, i32* %i, align 4
  %i2 = icmp ne i32 %i1, 0
  br i1 %i2, label %bb3, label %bb9

bb3:                                              ; preds = %bb
  %i4 = load i32, i32* %i, align 4
  %i5 = shl nuw i32 %i4, 3
  ; With "nuw", the alloca and its bitcast can be fused:
  %i6 = add nuw i32 %i5, 2048

  %i7 = alloca i8, i32 %i6, align 1
  %i8 = bitcast i8* %i7 to double*
  store double* %i8, double** %ptr, align 4
  br label %bb9

bb9:                                              ; preds = %bb3, %bb
  %i10 = load double*, double** %ptr, align 4
  call void @bar(double* %i10)
  ret void
}

declare void @bar(double*)

define void @fu2(i32 %parm) #0 {
; CHECK-LABEL: define void @fu2
; CHECK-SAME: (i32 [[PARM:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[PTR:%.*]] = alloca double*, align 4
; CHECK-NEXT:    store i32 [[PARM]], i32* [[I]], align 4
; CHECK-NEXT:    store double* null, double** [[PTR]], align 4
; CHECK-NEXT:    [[I2_NOT:%.*]] = icmp eq i32 [[PARM]], 0
; CHECK-NEXT:    br i1 [[I2_NOT]], label [[BB9:%.*]], label [[BB3:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    [[I4:%.*]] = load i32, i32* [[I]], align 4
; CHECK-NEXT:    [[I5:%.*]] = shl nuw i32 [[I4]], 3
; CHECK-NEXT:    [[I6:%.*]] = add i32 [[I5]], 2048
; CHECK-NEXT:    [[I7:%.*]] = alloca i8, i32 [[I6]], align 1
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast double** [[PTR]] to i8**
; CHECK-NEXT:    store i8* [[I7]], i8** [[TMP0]], align 4
; CHECK-NEXT:    br label [[BB9]]
; CHECK:       bb9:
; CHECK-NEXT:    [[I10:%.*]] = load double*, double** [[PTR]], align 4
; CHECK-NEXT:    call void @bar(double* [[I10]]) #[[ATTR1]]
; CHECK-NEXT:    ret void
;
bb:
  %i = alloca i32, align 4
  %ptr = alloca double*, align 4
  store i32 %parm, i32* %i, align 4
  store double* null, double** %ptr, align 4
  %i1 = load i32, i32* %i, align 4
  %i2 = icmp ne i32 %i1, 0
  br i1 %i2, label %bb3, label %bb9

bb3:                                              ; preds = %bb
  %i4 = load i32, i32* %i, align 4
  %i5 = mul nuw i32 %i4, 8
  ; Without "nuw", the alloca and its bitcast cannot be fused:
  %i6 = add i32 %i5, 2048
  %i7 = alloca i8, i32 %i6, align 1

  %i8 = bitcast i8* %i7 to double*
  store double* %i8, double** %ptr, align 4
  br label %bb9

bb9:                                              ; preds = %bb3, %bb
  %i10 = load double*, double** %ptr, align 4
  call void @bar(double* %i10)
  ret void
}

attributes #0 = { nounwind ssp }
