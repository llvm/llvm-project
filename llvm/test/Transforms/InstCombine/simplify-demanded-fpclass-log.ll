; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

declare nofpclass(qnan inf norm sub zero) float @returns_snan()

; -> qnan, canonicalizing
define nofpclass(inf norm sub zero) float @ret_nofpclass_only_nan__log(float %unknown) {
; CHECK-LABEL: define nofpclass(inf zero sub norm) float @ret_nofpclass_only_nan__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    ret float 0x7FF8000000000000
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

; -> +0
define nofpclass(nan inf norm sub) float @ret_nofpclass_only_zero__log(float %unknown) {
; CHECK-LABEL: define nofpclass(nan inf sub norm) float @ret_nofpclass_only_zero__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

; -> +0
define nofpclass(nan inf norm sub nzero) float @ret_nofpclass_only_pzero__log(float %unknown) {
; CHECK-LABEL: define nofpclass(nan inf nzero sub norm) float @ret_nofpclass_only_pzero__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

; -> pinf
define nofpclass(nan ninf norm sub zero) float @ret_nofpclass_only_pinf__log(float %unknown) {
; CHECK-LABEL: define nofpclass(nan ninf zero sub norm) float @ret_nofpclass_only_pinf__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    ret float 0x7FF0000000000000
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

; -> ninf
define nofpclass(nan pinf norm sub zero) float @ret_nofpclass_only_ninf__log(float %unknown) {
; CHECK-LABEL: define nofpclass(nan pinf zero sub norm) float @ret_nofpclass_only_ninf__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    ret float 0xFFF0000000000000
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

; log cannot return -0, -> poison
define nofpclass(nan inf norm sub pzero) float @ret_nofpclass_only_nzero__log(float %unknown) {
; CHECK-LABEL: define nofpclass(nan inf pzero sub norm) float @ret_nofpclass_only_nzero__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    ret float poison
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

define nofpclass(nan norm sub zero) float @ret_nofpclass_only_inf__log(float %unknown) {
; CHECK-LABEL: define nofpclass(nan zero sub norm) float @ret_nofpclass_only_inf__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan float @llvm.log.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

define nofpclass(norm sub zero) float @ret_nofpclass_only_inf_nan__log(float %unknown) {
; CHECK-LABEL: define nofpclass(zero sub norm) float @ret_nofpclass_only_inf_nan__log(
; CHECK-SAME: float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call float @llvm.log.f32(float %unknown)
  ret float %result
}

; Return implies argument cannot be 0, fold to just log
define nofpclass(ninf) float @ret_nofpclass_ninf_log(i1 %cond, float %x, float nofpclass(inf norm sub) %zero) {
; CHECK-LABEL: define nofpclass(ninf) float @ret_nofpclass_ninf_log(
; CHECK-SAME: i1 [[COND:%.*]], float [[X:%.*]], float nofpclass(inf sub norm) [[ZERO:%.*]]) {
; CHECK-NEXT:    [[SELECT:%.*]] = select i1 [[COND]], float [[ZERO]], float [[X]]
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log.f32(float [[SELECT]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float %zero, float %x
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

; -> only log
define nofpclass(pinf) float @ret_nofpclass_pinf_log_select_inf_or_unknown(i1 %cond, float %unknown) {
; CHECK-LABEL: define nofpclass(pinf) float @ret_nofpclass_pinf_log_select_inf_or_unknown(
; CHECK-SAME: i1 [[COND:%.*]], float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float 0x7ff0000000000000, float %unknown
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

; Check log2 is handled, -> only log2
define nofpclass(pinf) float @ret_nofpclass_pinf_log2_select_inf_or_unknown(i1 %cond, float %unknown) {
; CHECK-LABEL: define nofpclass(pinf) float @ret_nofpclass_pinf_log2_select_inf_or_unknown(
; CHECK-SAME: i1 [[COND:%.*]], float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log2.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float 0x7ff0000000000000, float %unknown
  %result = call float @llvm.log2.f32(float %select)
  ret float %result
}

; Check log10 is handled, -> only log10
define nofpclass(pinf) float @ret_nofpclass_pinf_log10_select_inf_or_unknown(i1 %cond, float %unknown) {
; CHECK-LABEL: define nofpclass(pinf) float @ret_nofpclass_pinf_log10_select_inf_or_unknown(
; CHECK-SAME: i1 [[COND:%.*]], float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log10.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float 0x7ff0000000000000, float %unknown
  %result = call float @llvm.log10.f32(float %select)
  ret float %result
}

; -> only log
define nofpclass(ninf norm zero) float @ret_nofpclass_nan_or_sub__log_select__finite_positive__unknown(i1 %cond, float nofpclass(inf nnorm nsub nan) %must.be.finite.positive, float %unknown) {
; CHECK-LABEL: define nofpclass(ninf zero norm) float @ret_nofpclass_nan_or_sub__log_select__finite_positive__unknown(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(nan inf nsub nnorm) [[MUST_BE_FINITE_POSITIVE:%.*]], float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float %must.be.finite.positive, float %unknown
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

; Cannot fold out due to subnormal input on first argument
define nofpclass(ninf norm zero) float @ret_nofpclass_nan_or_sub__log_select__finite_positive_or_sub__unknown(i1 %cond, float nofpclass(inf nnorm nan) %must.be.finite.positive.or.sub, float %unknown) {
; CHECK-LABEL: define nofpclass(ninf zero norm) float @ret_nofpclass_nan_or_sub__log_select__finite_positive_or_sub__unknown(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(nan inf nnorm) [[MUST_BE_FINITE_POSITIVE_OR_SUB:%.*]], float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[SELECT:%.*]] = select i1 [[COND]], float [[MUST_BE_FINITE_POSITIVE_OR_SUB]], float [[UNKNOWN]]
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log.f32(float [[SELECT]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float %must.be.finite.positive.or.sub, float %unknown
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

; Fold out select
define nofpclass(pinf nan norm zero) float @ret_ninf_or_sub__log_select__pinf_or_sub_orzero__else_not0__ieee(i1 %cond, float nofpclass(ninf norm nan) %must.be.pinf.or.sub.or.zero, float nofpclass(zero) %not.zero) {
; CHECK-LABEL: define nofpclass(nan pinf zero norm) float @ret_ninf_or_sub__log_select__pinf_or_sub_orzero__else_not0__ieee(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(nan ninf norm) [[MUST_BE_PINF_OR_SUB_OR_ZERO:%.*]], float nofpclass(zero) [[NOT_ZERO:%.*]]) {
; CHECK-NEXT:    ret float 0xFFF0000000000000
;
  %select = select i1 %cond, float %must.be.pinf.or.sub.or.zero, float %not.zero
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

define nofpclass(pinf nan norm zero) float @ret_ninf_or_sub__log_select__pinf_or_sub_orzero__else_not0__daz(i1 %cond, float nofpclass(ninf norm nan) %must.be.pinf.or.sub.or.zero, float nofpclass(zero) %not.zero) #0 {
; CHECK-LABEL: define nofpclass(nan pinf zero norm) float @ret_ninf_or_sub__log_select__pinf_or_sub_orzero__else_not0__daz(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(nan ninf norm) [[MUST_BE_PINF_OR_SUB_OR_ZERO:%.*]], float nofpclass(zero) [[NOT_ZERO:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    ret float 0xFFF0000000000000
;
  %select = select i1 %cond, float %must.be.pinf.or.sub.or.zero, float %not.zero
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

define nofpclass(pinf nan norm zero) float @ret_ninf_or_sub__log_select__pinf_or_sub_orzero__else_not0__dynamic(i1 %cond, float nofpclass(ninf norm nan) %must.be.pinf.or.sub.or.zero, float nofpclass(zero) %not.zero) #1 {
; CHECK-LABEL: define nofpclass(nan pinf zero norm) float @ret_ninf_or_sub__log_select__pinf_or_sub_orzero__else_not0__dynamic(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(nan ninf norm) [[MUST_BE_PINF_OR_SUB_OR_ZERO:%.*]], float nofpclass(zero) [[NOT_ZERO:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    ret float 0xFFF0000000000000
;
  %select = select i1 %cond, float %must.be.pinf.or.sub.or.zero, float %not.zero
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

; Fold to select unknown
define nofpclass(inf nan pnorm sub zero) float @ret_only_nnorm__log__select_unknown_or_infnan(i1 %cond, float %unknown, float nofpclass(norm sub zero) %b) {
; CHECK-LABEL: define nofpclass(nan inf zero sub pnorm) float @ret_only_nnorm__log__select_unknown_or_infnan(
; CHECK-SAME: i1 [[COND:%.*]], float [[UNKNOWN:%.*]], float nofpclass(zero sub norm) [[B:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan ninf float @llvm.log.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float %unknown, float %b
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

; Fold to select unknown
define nofpclass(inf nan nnorm sub zero) float @ret_only_pnorm__log__select_unknown_or_infnan(i1 %cond, float %unknown, float nofpclass(norm sub zero) %b) {
; CHECK-LABEL: define nofpclass(nan inf zero sub nnorm) float @ret_only_pnorm__log__select_unknown_or_infnan(
; CHECK-SAME: i1 [[COND:%.*]], float [[UNKNOWN:%.*]], float nofpclass(zero sub norm) [[B:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan ninf float @llvm.log.f32(float [[UNKNOWN]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float %unknown, float %b
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

define nofpclass(nan inf norm) float @ret_only_zero_sub__log__select_pnormnan_or_unknown(i1 %cond, float nofpclass(inf sub zero nnorm) %pnorm.or.nan, float %b) {
; CHECK-LABEL: define nofpclass(nan inf norm) float @ret_only_zero_sub__log__select_pnormnan_or_unknown(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(inf zero sub nnorm) [[PNORM_OR_NAN:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %select = select i1 %cond, float %pnorm.or.nan, float %b
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

define nofpclass(nan inf norm) float @ret_only_zero_sub__log__select_nnormnan_or_unknown(i1 %cond, float nofpclass(inf sub zero pnorm) %nnorm.or.nan, float %b) {
; CHECK-LABEL: define nofpclass(nan inf norm) float @ret_only_zero_sub__log__select_nnormnan_or_unknown(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(inf zero sub pnorm) [[NNORM_OR_NAN:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %select = select i1 %cond, float %nnorm.or.nan, float %b
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

; Keep select, 0 result implies it could be 1
define nofpclass(inf norm sub) float @ret_only_zero_nan__log__select_maybe_pnorm__else_negative_or_zero(i1 %cond, float nofpclass(nan inf sub zero nnorm) %maybe.pnorm, float nofpclass(nan pinf pnorm psub) %negative.or.zero) {
; CHECK-LABEL: define nofpclass(inf sub norm) float @ret_only_zero_nan__log__select_maybe_pnorm__else_negative_or_zero(
; CHECK-SAME: i1 [[COND:%.*]], float nofpclass(nan inf zero sub nnorm) [[MAYBE_PNORM:%.*]], float nofpclass(nan pinf psub pnorm) [[NEGATIVE_OR_ZERO:%.*]]) {
; CHECK-NEXT:    [[SELECT:%.*]] = select i1 [[COND]], float [[MAYBE_PNORM]], float [[NEGATIVE_OR_ZERO]]
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log.f32(float [[SELECT]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %select = select i1 %cond, float %maybe.pnorm, float %negative.or.zero
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

define nofpclass(snan) float @ret_no_snan__log__no_pinf_inputs(float nofpclass(pinf) %x) {
; CHECK-LABEL: define nofpclass(snan) float @ret_no_snan__log__no_pinf_inputs(
; CHECK-SAME: float nofpclass(pinf) [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

; Cannot infer flags. A nan output could still be produced by a -inf
; input.
define nofpclass(pinf) float @ret_no_pinf__log(float %x) {
; CHECK-LABEL: define nofpclass(pinf) float @ret_no_pinf__log(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

define nofpclass(ninf) float @ret_no_ninf__log(float %x) {
; CHECK-LABEL: define nofpclass(ninf) float @ret_no_ninf__log(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

; Infer nnan (not ninf)
define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log(float %x) {
; CHECK-LABEL: define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

; Infer nnan and ninf
define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log_no_zero(float nofpclass(zero) %x) {
; CHECK-LABEL: define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log_no_zero(
; CHECK-SAME: float nofpclass(zero) [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan ninf contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

; Infer nnan (not ninf)
define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log_no_zero__daz(float nofpclass(zero) %x) #0 {
; CHECK-LABEL: define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log_no_zero__daz(
; CHECK-SAME: float nofpclass(zero) [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

; Infer nnan and ninf
define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log_no_zero_or_sub__daz(float nofpclass(zero sub) %x) #0 {
; CHECK-LABEL: define nofpclass(nan pinf) float @ret_no_pinf_no_nan__log_no_zero_or_sub__daz(
; CHECK-SAME: float nofpclass(zero sub) [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan ninf contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

; Infer nnan (not ninf)
define nofpclass(nan) float @ret_no_nan__log__no_pinf_inputs(float nofpclass(pinf) %x) {
; CHECK-LABEL: define nofpclass(nan) float @ret_no_nan__log__no_pinf_inputs(
; CHECK-SAME: float nofpclass(pinf) [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

; Infer nnan (not ninf)
define nofpclass(nan) float @ret_no_nan__log__no_inf_inputs(float nofpclass(inf) %x) {
; CHECK-LABEL: define nofpclass(nan) float @ret_no_nan__log__no_inf_inputs(
; CHECK-SAME: float nofpclass(inf) [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan contract float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call contract float @llvm.log.f32(float %x)
  ret float %result
}

define nofpclass(inf nan) float @add_flags_log__drop_noundef(float nofpclass(inf nan) %x) {
; CHECK-LABEL: define nofpclass(nan inf) float @add_flags_log__drop_noundef(
; CHECK-SAME: float nofpclass(nan inf) [[X:%.*]]) {
; CHECK-NEXT:    [[RESULT:%.*]] = call nnan ninf float @llvm.log.f32(float [[X]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %result = call noundef float @llvm.log.f32(float noundef %x), !unknown.md !0
  ret float %result
}

define nofpclass(snan) float @qnan_result_demands_snan_src(i1 %cond, float %unknown) {
; CHECK-LABEL: define nofpclass(snan) float @qnan_result_demands_snan_src(
; CHECK-SAME: i1 [[COND:%.*]], float [[UNKNOWN:%.*]]) {
; CHECK-NEXT:    [[SNAN:%.*]] = call float @returns_snan()
; CHECK-NEXT:    [[SELECT:%.*]] = select i1 [[COND]], float [[SNAN]], float [[UNKNOWN]]
; CHECK-NEXT:    [[RESULT:%.*]] = call float @llvm.log.f32(float [[SELECT]])
; CHECK-NEXT:    ret float [[RESULT]]
;
  %snan = call float @returns_snan()
  %select = select i1 %cond, float %snan, float %unknown
  %result = call float @llvm.log.f32(float %select)
  ret float %result
}

attributes #0 = { denormal_fpenv(preservesign) }
attributes #1 = { denormal_fpenv(dynamic) }

!0 = !{}


