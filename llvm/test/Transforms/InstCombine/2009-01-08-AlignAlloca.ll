; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; rdar://6480438
target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128"
target triple = "i386-apple-darwin9.6"
  %struct.Key = type { { i32, i32 } }
  %struct.anon = type <{ i8, [3 x i8], i32 }>

define i32 @bar(i64 %key_token2) nounwind {
; CHECK-LABEL: @bar(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IOSPEC:%.*]] = alloca [[STRUCT_KEY:%.*]], align 8
; CHECK-NEXT:    [[RET:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 0, ptr [[IOSPEC]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds { i32, i32 }, ptr [[IOSPEC]], i32 0, i32 1
; CHECK-NEXT:    store i32 0, ptr [[TMP0]], align 4
; CHECK-NEXT:    store i64 [[KEY_TOKEN2:%.*]], ptr [[IOSPEC]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 (...) @foo(ptr nonnull byval([[STRUCT_KEY]]) align 4 [[IOSPEC]], ptr nonnull [[RET]]) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[RET]], align 4
; CHECK-NEXT:    ret i32 [[TMP2]]
;
entry:
  %iospec = alloca %struct.Key		; <ptr> [#uses=3]
  %ret = alloca i32		; <ptr> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32		; <i32> [#uses=0]
  %0 = getelementptr %struct.Key, ptr %iospec, i32 0, i32 0		; <ptr> [#uses=2]
  %1 = getelementptr { i32, i32 }, ptr %0, i32 0, i32 0		; <ptr> [#uses=1]
  store i32 0, ptr %1, align 4
  %2 = getelementptr { i32, i32 }, ptr %0, i32 0, i32 1		; <ptr> [#uses=1]
  store i32 0, ptr %2, align 4
  %3 = getelementptr %struct.Key, ptr %iospec, i32 0, i32 0		; <ptr> [#uses=1]
  store i64 %key_token2, ptr %3, align 4
  %4 = call i32 (...) @foo(ptr byval(%struct.Key) align 4 %iospec, ptr %ret) nounwind		; <i32> [#uses=0]
  %5 = load i32, ptr %ret, align 4		; <i32> [#uses=1]
  ret i32 %5
}

declare i32 @foo(...)
