; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes='instcombine<no-verify-fixpoint>' -S | FileCheck %s

; Given a pattern like:
;   %old_cmp1 = icmp sgt i32 %x, C2
;   %old_replacement = sext i1 %old_cmp1 to i32
;   %old_cmp0 = icmp ult i32 %x, C0
;   %r = select i1 %old_cmp0, i32 %x, i32 %old_replacement
; it can be rewriten as more canonical pattern:
;   %new_cmp2 = icmp sge i32 %x, C0
;   %new_clamped_low = smax i32 %target_low, i32 %x
;   %r = select i1 %new_cmp2, i32 -1, i32 %new_clamped_low
; Iff 0 s<= C2 s<= C0
; Also, ULT predicate can also be UGE; or UGT iff C0 != -1 (+invert result)
; Also, SLT predicate can also be SGE; or SGT iff C2 != INT_MAX (+invert res.)

;-------------------------------------------------------------------------------

; clamp-like max case, can be optimized with max
define i32 @clamp_max_sgt(i32 %x) {
; CHECK-LABEL: @clamp_max_sgt(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[X:%.*]], 256
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-NEXT:    [[COND:%.*]] = sext i1 [[CMP2]] to i32
; CHECK-NEXT:    [[COND3:%.*]] = select i1 [[OR_COND]], i32 [[X]], i32 [[COND]]
; CHECK-NEXT:    ret i32 [[COND3]]
;
  %or.cond = icmp ult i32 %x, 256
  %cmp2 = icmp sgt i32 %x, 0
  %cond = sext i1 %cmp2 to i32
  %cond3 = select i1 %or.cond, i32 %x, i32 %cond
  ret i32 %cond3
}

; clamp-like max case with vector, can be optimized with max
define <2 x i32> @clamp_max_sgt_vec(<2 x i32> %x) {
; CHECK-LABEL: @clamp_max_sgt_vec(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult <2 x i32> [[X:%.*]], <i32 100, i32 256>
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt <2 x i32> [[X]], <i32 98, i32 254>
; CHECK-NEXT:    [[COND:%.*]] = sext <2 x i1> [[CMP2]] to <2 x i32>
; CHECK-NEXT:    [[COND3:%.*]] = select <2 x i1> [[OR_COND]], <2 x i32> [[X]], <2 x i32> [[COND]]
; CHECK-NEXT:    ret <2 x i32> [[COND3]]
;
  %or.cond = icmp ult <2 x i32> %x, <i32 100, i32 256>
  %cmp2 = icmp sgt <2 x i32> %x, <i32 98, i32 254>
  %cond = sext <2 x i1> %cmp2 to <2 x i32>
  %cond3 = select <2 x i1> %or.cond, <2 x i32> %x, <2 x i32> %cond
  ret <2 x i32> %cond3
}

; Not clamp-like vector
define <2 x i32> @clamp_max_vec(<2 x i32> %x) {
; CHECK-LABEL: @clamp_max_vec(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult <2 x i32> [[X:%.*]], <i32 100, i32 256>
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt <2 x i32> [[X]], <i32 128, i32 0>
; CHECK-NEXT:    [[COND:%.*]] = sext <2 x i1> [[CMP2]] to <2 x i32>
; CHECK-NEXT:    [[COND3:%.*]] = select <2 x i1> [[OR_COND]], <2 x i32> [[X]], <2 x i32> [[COND]]
; CHECK-NEXT:    ret <2 x i32> [[COND3]]
;
  %or.cond = icmp ult <2 x i32> %x, <i32 100, i32 256>
  %cmp2 = icmp sgt <2 x i32> %x, <i32 128, i32 0>
  %cond = sext <2 x i1> %cmp2 to <2 x i32>
  %cond3 = select <2 x i1> %or.cond, <2 x i32> %x, <2 x i32> %cond
  ret <2 x i32> %cond3
}

; clamp-like max case, can be optimized with max
define i32 @clamp_max_sgt_neg1(i32 %x) {
; CHECK-LABEL: @clamp_max_sgt_neg1(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[X:%.*]], 256
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[X]], -1
; CHECK-NEXT:    [[COND:%.*]] = sext i1 [[CMP2]] to i32
; CHECK-NEXT:    [[COND3:%.*]] = select i1 [[OR_COND]], i32 [[X]], i32 [[COND]]
; CHECK-NEXT:    ret i32 [[COND3]]
;
  %or.cond = icmp ult i32 %x, 256
  %cmp2 = icmp sgt i32 %x, -1
  %cond = sext i1 %cmp2 to i32
  %cond3 = select i1 %or.cond, i32 %x, i32 %cond
  ret i32 %cond3
}

; clamp-like max case, can be optimized with max
define i32 @clamp_max_sge(i32 %x) {
; CHECK-LABEL: @clamp_max_sge(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[X:%.*]], 256
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[X]], -1
; CHECK-NEXT:    [[COND:%.*]] = sext i1 [[CMP2]] to i32
; CHECK-NEXT:    [[COND3:%.*]] = select i1 [[OR_COND]], i32 [[X]], i32 [[COND]]
; CHECK-NEXT:    ret i32 [[COND3]]
;
  %or.cond = icmp ult i32 %x, 256
  %cmp2 = icmp sge i32 %x, 0
  %cond = sext i1 %cmp2 to i32
  %cond3 = select i1 %or.cond, i32 %x, i32 %cond
  ret i32 %cond3
}

; Don't support SLT cases, need to select 0 as the low value, -1 as high value
define i32 @clamp_max_slt(i32 %x) {
; CHECK-LABEL: @clamp_max_slt(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[X:%.*]], 256
; CHECK-NEXT:    [[COND:%.*]] = ashr i32 [[X]], 31
; CHECK-NEXT:    [[COND3:%.*]] = select i1 [[OR_COND]], i32 [[X]], i32 [[COND]]
; CHECK-NEXT:    ret i32 [[COND3]]
;
  %or.cond = icmp ult i32 %x, 256
  %cmp2 = icmp slt i32 %x, 0
  %cond = sext i1 %cmp2 to i32
  %cond3 = select i1 %or.cond, i32 %x, i32 %cond
  ret i32 %cond3
}

; Don't support SLE cases, need to select 0 as the low value, -1 as high value
define i32 @clamp_max_sle(i32 %x) {
; CHECK-LABEL: @clamp_max_sle(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[X:%.*]], 256
; CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i32 [[X]], 1
; CHECK-NEXT:    [[COND:%.*]] = sext i1 [[CMP2]] to i32
; CHECK-NEXT:    [[COND3:%.*]] = select i1 [[OR_COND]], i32 [[X]], i32 [[COND]]
; CHECK-NEXT:    ret i32 [[COND3]]
;
  %or.cond = icmp ult i32 %x, 256
  %cmp2 = icmp sle i32 %x, 0
  %cond = sext i1 %cmp2 to i32
  %cond3 = select i1 %or.cond, i32 %x, i32 %cond
  ret i32 %cond3
}

; Not selecting between 0, x, and -1, so can't be optimized with max
; Select between 0, x, and 1
define i32 @clamp_max_bad_values(i32 %x) {
; CHECK-LABEL: @clamp_max_bad_values(
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[X:%.*]], 256
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-NEXT:    [[COND:%.*]] = zext i1 [[CMP2]] to i32
; CHECK-NEXT:    [[COND3:%.*]] = select i1 [[OR_COND]], i32 [[X]], i32 [[COND]]
; CHECK-NEXT:    ret i32 [[COND3]]
;
  %or.cond = icmp ult i32 %x, 256
  %cmp2 = icmp sgt i32 %x, 0
  %cond = zext i1 %cmp2 to i32
  %cond3 = select i1 %or.cond, i32 %x, i32 %cond
  ret i32 %cond3
}

; Boundaries of range are not 0 and x (x is some positive integer)
define i32 @clamp_max_offset(i32 %x) {
; CHECK-LABEL: @clamp_max_offset(
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[X:%.*]], -10
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[TMP1]], 246
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[X]], 10
; CHECK-NEXT:    [[COND:%.*]] = sext i1 [[CMP2]] to i32
; CHECK-NEXT:    [[COND3:%.*]] = select i1 [[OR_COND]], i32 [[X]], i32 [[COND]]
; CHECK-NEXT:    ret i32 [[COND3]]
;
  %1 = add i32 %x, -10
  %or.cond = icmp ult i32 %1, 246
  %cmp2 = icmp sgt i32 %x, 10
  %cond = sext i1 %cmp2 to i32
  %cond3 = select i1 %or.cond, i32 %x, i32 %cond
  ret i32 %cond3
}
