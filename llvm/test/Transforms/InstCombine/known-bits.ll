; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

define void @test_shl(i1 %x) {
; CHECK-LABEL: @test_shl(
; CHECK-NEXT:    call void @sink(i8 0)
; CHECK-NEXT:    ret void
;
  %y = zext i1 %x to i8
  %z = shl i8 64, %y
  %a = and i8 %z, 1
  call void @sink(i8 %a)
  ret void
}

define void @test_lshr(i1 %x) {
; CHECK-LABEL: @test_lshr(
; CHECK-NEXT:    call void @sink(i8 0)
; CHECK-NEXT:    ret void
;
  %y = zext i1 %x to i8
  %z = lshr i8 64, %y
  %a = and i8 %z, 1
  call void @sink(i8 %a)
  ret void
}

define void @test_ashr(i1 %x) {
; CHECK-LABEL: @test_ashr(
; CHECK-NEXT:    call void @sink(i8 0)
; CHECK-NEXT:    ret void
;
  %y = zext i1 %x to i8
  %z = ashr i8 -16, %y
  %a = and i8 %z, 3
  call void @sink(i8 %a)
  ret void
}

define void @test_udiv(i8 %x) {
; CHECK-LABEL: @test_udiv(
; CHECK-NEXT:    call void @sink(i8 0)
; CHECK-NEXT:    ret void
;
  %y = udiv i8 10, %x
  %z = and i8 %y, 64
  call void @sink(i8 %z)
  ret void
}

define i8 @test_cond(i8 %x) {
; CHECK-LABEL: @test_cond(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[AND]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    ret i8 -4
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp eq i8 %and, 0
  br i1 %cmp, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_inv(i8 %x) {
; CHECK-LABEL: @test_cond_inv(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i8 [[AND]], 0
; CHECK-NEXT:    call void @use(i1 [[CMP]])
; CHECK-NEXT:    br i1 [[CMP]], label [[EXIT:%.*]], label [[IF:%.*]]
; CHECK:       if:
; CHECK-NEXT:    ret i8 -4
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp ne i8 %and, 0
  call void @use(i1 %cmp)
  br i1 %cmp, label %exit, label %if

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_and(i8 %x, i1 %c) {
; CHECK-LABEL: @test_cond_and(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[AND]], 0
; CHECK-NEXT:    [[COND:%.*]] = and i1 [[CMP]], [[C:%.*]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    ret i8 -4
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp eq i8 %and, 0
  %cond = and i1 %cmp, %c
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}


define i8 @test_cond_and_bothways(i8 %x) {
; CHECK-LABEL: @test_cond_and_bothways(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 91
; CHECK-NEXT:    [[CMP0:%.*]] = icmp ne i8 [[AND]], 24
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[COND:%.*]] = and i1 [[CMP0]], [[CMP1]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[OR1:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR1]]
; CHECK:       exit:
; CHECK-NEXT:    ret i8 -4
;
  %and = and i8 %x, 91
  %cmp0 = icmp ne i8 %and, 24
  %cmp1 = icmp ne i8 %x, 0
  %cond = and i1 %cmp0, %cmp1
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_or_bothways(i8 %x) {
; CHECK-LABEL: @test_cond_or_bothways(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 91
; CHECK-NEXT:    [[CMP0:%.*]] = icmp eq i8 [[AND]], 24
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i8 [[X]], 0
; CHECK-NEXT:    [[COND:%.*]] = or i1 [[CMP0]], [[CMP1]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    ret i8 -4
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 91
  %cmp0 = icmp eq i8 %and, 24
  %cmp1 = icmp eq i8 %x, 0
  %cond = or i1 %cmp0, %cmp1
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}



define i8 @test_cond_and_commuted(i8 %x, i1 %c1, i1 %c2) {
; CHECK-LABEL: @test_cond_and_commuted(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[AND]], 0
; CHECK-NEXT:    [[C3:%.*]] = and i1 [[C1:%.*]], [[C2:%.*]]
; CHECK-NEXT:    [[COND:%.*]] = and i1 [[C3]], [[CMP]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    ret i8 -4
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp eq i8 %and, 0
  %c3 = and i1 %c1, %c2
  %cond = and i1 %c3, %cmp
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_logical_and(i8 %x, i1 %c) {
; CHECK-LABEL: @test_cond_logical_and(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[AND]], 0
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP]], i1 [[C:%.*]], i1 false
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    ret i8 -4
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp eq i8 %and, 0
  %cond = select i1 %cmp, i1 %c, i1 false
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_or_invalid(i8 %x, i1 %c) {
; CHECK-LABEL: @test_cond_or_invalid(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[AND]], 0
; CHECK-NEXT:    [[COND:%.*]] = or i1 [[CMP]], [[C:%.*]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[OR1:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR1]]
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp eq i8 %and, 0
  %cond = or i1 %cmp, %c
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_inv_or(i8 %x, i1 %c) {
; CHECK-LABEL: @test_cond_inv_or(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i8 [[AND]], 0
; CHECK-NEXT:    [[COND:%.*]] = or i1 [[CMP]], [[C:%.*]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[OR1:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR1]]
; CHECK:       exit:
; CHECK-NEXT:    ret i8 -4
;
  %and = and i8 %x, 3
  %cmp = icmp ne i8 %and, 0
  %cond = or i1 %cmp, %c
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_inv_logical_or(i8 %x, i1 %c) {
; CHECK-LABEL: @test_cond_inv_logical_or(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 [[AND]], 0
; CHECK-NEXT:    [[COND:%.*]] = select i1 [[CMP_NOT]], i1 [[C:%.*]], i1 false
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    ret i8 -4
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp ne i8 %and, 0
  %cond = select i1 %cmp, i1 false, i1 %c
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i8 @test_cond_inv_and_invalid(i8 %x, i1 %c) {
; CHECK-LABEL: @test_cond_inv_and_invalid(
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i8 [[AND]], 0
; CHECK-NEXT:    [[COND:%.*]] = and i1 [[CMP]], [[C:%.*]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[EXIT:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[OR1:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR1]]
; CHECK:       exit:
; CHECK-NEXT:    [[OR2:%.*]] = or i8 [[X]], -4
; CHECK-NEXT:    ret i8 [[OR2]]
;
  %and = and i8 %x, 3
  %cmp = icmp ne i8 %and, 0
  %cond = and i1 %cmp, %c
  br i1 %cond, label %if, label %exit

if:
  %or1 = or i8 %x, -4
  ret i8 %or1

exit:
  %or2 = or i8 %x, -4
  ret i8 %or2
}

define i32 @test_icmp_trunc1(i32 %x){
; CHECK-LABEL: @test_icmp_trunc1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[Y:%.*]] = trunc i32 [[X:%.*]] to i16
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i16 [[Y]], 7
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i32 7
; CHECK:       else:
; CHECK-NEXT:    ret i32 0
;
entry:
  %y = trunc i32 %x to i16
  %cmp = icmp eq i16 %y, 7
  br i1 %cmp, label %then, label %else
then:
  %z = and i32 %x, 15
  ret i32 %z
else:
  ret i32 0
}

define i32 @test_icmp_trunc_assume(i32 %x){
; CHECK-LABEL: @test_icmp_trunc_assume(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[Y:%.*]] = trunc i32 [[X:%.*]] to i16
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i16 [[Y]], 7
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    ret i32 7
;
entry:
  %y = trunc i32 %x to i16
  %cmp = icmp eq i16 %y, 7
  call void @llvm.assume(i1 %cmp)
  %z = and i32 %x, 15
  ret i32 %z
}

define i64 @test_icmp_trunc2(i64 %x) {
; CHECK-LABEL: @test_icmp_trunc2(
; CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[X:%.*]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[CONV]], 12
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[SEXT:%.*]] = and i64 [[X]], 2147483647
; CHECK-NEXT:    ret i64 [[SEXT]]
; CHECK:       if.else:
; CHECK-NEXT:    ret i64 0
;
  %conv = trunc i64 %x to i32
  %cmp = icmp sgt i32 %conv, 12
  br i1 %cmp, label %if.then, label %if.else

if.then:
  %sext = shl i64 %x, 32
  %ret = ashr exact i64 %sext, 32
  ret i64 %ret
if.else:
  ret i64 0
}

define i64 @test_icmp_trunc3(i64 %n) {
; CHECK-LABEL: @test_icmp_trunc3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[N:%.*]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[CONV]], 96
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[RET:%.*]] = and i64 [[N]], 127
; CHECK-NEXT:    ret i64 [[RET]]
; CHECK:       if.else:
; CHECK-NEXT:    ret i64 0
;
entry:
  %conv = trunc i64 %n to i32
  %cmp = icmp ult i32 %conv, 96
  br i1 %cmp, label %if.then, label %if.else

if.then:
  %ret = and i64 %n, 4294967295
  ret i64 %ret

if.else:
  ret i64 0
}

define i8 @test_icmp_trunc4(i64 %n) {
; CHECK-LABEL: @test_icmp_trunc4(
; CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[N:%.*]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[CONV]], 10
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[CONV2:%.*]] = trunc i64 [[N]] to i8
; CHECK-NEXT:    [[ADD:%.*]] = or disjoint i8 [[CONV2]], 48
; CHECK-NEXT:    ret i8 [[ADD]]
; CHECK:       if.else:
; CHECK-NEXT:    ret i8 0
;
  %conv = trunc i64 %n to i32
  %cmp = icmp ult i32 %conv, 10
  br i1 %cmp, label %if.then, label %if.else

if.then:
  %conv2 = trunc i64 %n to i8
  %add = add i8 %conv2, 48
  ret i8 %add

if.else:
  ret i8 0
}

define i64 @test_icmp_trunc5(i64 %n) {
; CHECK-LABEL: @test_icmp_trunc5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SHR:%.*]] = ashr i64 [[N:%.*]], 47
; CHECK-NEXT:    [[CONV1:%.*]] = trunc i64 [[SHR]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[CONV1]], -13
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[TMP0:%.*]] = and i64 [[SHR]], 15
; CHECK-NEXT:    [[NOT:%.*]] = xor i64 [[TMP0]], 15
; CHECK-NEXT:    ret i64 [[NOT]]
; CHECK:       if.else:
; CHECK-NEXT:    ret i64 13
;
entry:
  %shr = ashr i64 %n, 47
  %conv1 = trunc i64 %shr to i32
  %cmp = icmp ugt i32 %conv1, -13
  br i1 %cmp, label %if.then, label %if.else

if.then:
  %and = and i64 %shr, 4294967295
  %not = xor i64 %and, 4294967295
  ret i64 %not

if.else:
  ret i64 13
}

declare void @use(i1)
declare void @sink(i8)
