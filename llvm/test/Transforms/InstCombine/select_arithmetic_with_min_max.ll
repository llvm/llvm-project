; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; These tests check folding of a select and min/max feeding
; the same binary operation. When min/max can be expressed
; as a select with the same condition as in another select,
; the binary op might be applied to the operands of the selects.

define void @test_umax1(i32 %V, ptr %m1, ptr %m2) {
; CHECK-LABEL: @test_umax1(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[V:%.*]], 0
; CHECK-NEXT:    [[UMAX:%.*]] = call i32 @llvm.umax.i32(i32 [[V]], i32 1)
; CHECK-NEXT:    [[OP:%.*]] = select i1 [[CMP]], i32 8, i32 0
; CHECK-NEXT:    store i32 [[UMAX]], ptr [[M1:%.*]], align 4
; CHECK-NEXT:    store i32 [[OP]], ptr [[M2:%.*]], align 4
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %V, 0
; %umax = select i1 %cmp, i32 1, i32 %V
  %umax = call i32 @llvm.umax.i32(i32 %V, i32 1)
  %select = select i1 %cmp, i32 9, i32 %V
  %op = sub i32 %select, %umax
  store i32 %umax, ptr %m1
  store i32 %op, ptr %m2
  ret void
}

define void @test_umax2(i32 %V, ptr %m1, ptr %m2) {
; CHECK-LABEL: @test_umax2(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[V:%.*]], 0
; CHECK-NEXT:    [[UMAX:%.*]] = call i32 @llvm.umax.i32(i32 [[V]], i32 1)
; CHECK-NEXT:    [[OP:%.*]] = select i1 [[CMP]], i32 8, i32 0
; CHECK-NEXT:    store i32 [[UMAX]], ptr [[M1:%.*]], align 4
; CHECK-NEXT:    store i32 [[OP]], ptr [[M2:%.*]], align 4
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 0, %V
; %umax = select i1 %cmp, i32 1, i32 %V
  %umax = call i32 @llvm.umax.i32(i32 1, i32 %V)
  %select = select i1 %cmp, i32 9, i32 %V
  %op = sub i32 %select, %umax
  store i32 %umax, ptr %m1
  store i32 %op, ptr %m2
  ret void
}

define void @test_umin(i16 %V, ptr %m1, ptr %m2) {
; CHECK-LABEL: @test_umin(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i16 [[V:%.*]], -1
; CHECK-NEXT:    [[UMIN:%.*]] = call i16 @llvm.umin.i16(i16 [[V]], i16 -2)
; CHECK-NEXT:    [[OP:%.*]] = select i1 [[CMP]], i16 4, i16 0
; CHECK-NEXT:    store i16 [[UMIN]], ptr [[M1:%.*]], align 2
; CHECK-NEXT:    store i16 [[OP]], ptr [[M2:%.*]], align 2
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i16 %V, 65535
; %umin = select i1 %cmp, i16 65534, i16 %V
  %umin = call i16 @llvm.umin.i16(i16 %V, i16 65534)
  %select = select i1 %cmp, i16 65530, i16 %V
  %op = sub i16 %umin, %select
  store i16 %umin, ptr %m1
  store i16 %op, ptr %m2
  ret void
}

define void @test_smax(i8 %V, ptr %m1, ptr %m2) {
; CHECK-LABEL: @test_smax(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[V:%.*]], -128
; CHECK-NEXT:    [[SMAX:%.*]] = call i8 @llvm.smax.i8(i8 [[V]], i8 -127)
; CHECK-NEXT:    [[OP:%.*]] = select i1 [[CMP]], i8 -128, i8 0
; CHECK-NEXT:    store i8 [[SMAX]], ptr [[M1:%.*]], align 1
; CHECK-NEXT:    store i8 [[OP]], ptr [[M2:%.*]], align 1
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i8 %V, -128
; %smax = select i1 %cmp, i8 -127, i8 %V
  %smax = call i8 @llvm.smax.i8(i8 -127, i8 %V)
  %select = select i1 %cmp, i8 1, i8 %V
  %op = sub i8 %smax, %select
  store i8 %smax, ptr %m1
  store i8 %op, ptr %m2
  ret void
}

define void @test_smin(i8 %V, ptr %m1, ptr %m2) {
; CHECK-LABEL: @test_smin(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[V:%.*]], 127
; CHECK-NEXT:    [[SMIN:%.*]] = call i8 @llvm.smin.i8(i8 [[V]], i8 126)
; CHECK-NEXT:    [[OP:%.*]] = select i1 [[CMP]], i8 6, i8 0
; CHECK-NEXT:    store i8 [[SMIN]], ptr [[M1:%.*]], align 1
; CHECK-NEXT:    store i8 [[OP]], ptr [[M2:%.*]], align 1
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i8 %V, 127
; %smin = select i1 %cmp, i8 126, i8 %V
  %smin = call i8 @llvm.smin.i8(i8 %V, i8 126)
  %select = select i1 %cmp, i8 120, i8 %V
  %op = sub i8 %smin, %select
  store i8 %smin, ptr %m1
  store i8 %op, ptr %m2
  ret void
}

declare i32 @llvm.umax.i32(i32, i32)
declare i16 @llvm.umin.i16(i16, i16)
declare i8 @llvm.smax.i8(i8, i8)
declare i8 @llvm.smin.i8(i8, i8)
