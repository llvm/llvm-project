; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

define float @maximumnum_f32_1_maximumnum_val_p0(float %x) {
; CHECK-LABEL: define float @maximumnum_f32_1_maximumnum_val_p0(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float 1.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.maximumnum.f32(float %x, float 0.0)
  %z = call float @llvm.maximumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @maximumnum_f32_1_maximumnum_p0_val_fast(float %x) {
; CHECK-LABEL: define float @maximumnum_f32_1_maximumnum_p0_val_fast(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float 1.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.maximumnum.f32(float 0.0, float %x)
  %z = call fast float @llvm.maximumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @maximumnum_f32_1_maximumnum_p0_val_fmf1(float %x) {
; CHECK-LABEL: define float @maximumnum_f32_1_maximumnum_p0_val_fmf1(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call nnan float @llvm.maximumnum.f32(float [[X]], float 1.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call nnan float @llvm.maximumnum.f32(float 0.0, float %x)
  %z = call nnan ninf float @llvm.maximumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @maximumnum_f32_1_maximumnum_p0_val_fmf2(float %x) {
; CHECK-LABEL: define float @maximumnum_f32_1_maximumnum_p0_val_fmf2(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call ninf float @llvm.maximumnum.f32(float [[X]], float 1.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call nnan ninf float @llvm.maximumnum.f32(float 0.0, float %x)
  %z = call ninf float @llvm.maximumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @maximumnum_f32_1_maximumnum_p0_val_fmf3(float %x) {
; CHECK-LABEL: define float @maximumnum_f32_1_maximumnum_p0_val_fmf3(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call nnan ninf float @llvm.maximumnum.f32(float [[X]], float 1.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call ninf nnan float @llvm.maximumnum.f32(float 0.0, float %x)
  %z = call ninf nnan float @llvm.maximumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @maximumnum_f32_p0_maximumnum_val_n0(float %x) {
; CHECK-LABEL: define float @maximumnum_f32_p0_maximumnum_val_n0(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.maximumnum.f32(float %x, float -0.0)
  %z = call float @llvm.maximumnum.f32(float %y, float 0.0)
  ret float %z
}

define float @maximumnum_f32_1_maximumnum_p0_val(float %x) {
; CHECK-LABEL: define float @maximumnum_f32_1_maximumnum_p0_val(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float 1.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.maximumnum.f32(float 0.0, float %x)
  %z = call float @llvm.maximumnum.f32(float %y, float 1.0)
  ret float %z
}

define <2 x float> @maximumnum_f32_1_maximumnum_val_p0_val_v2f32(<2 x float> %x) {
; CHECK-LABEL: define <2 x float> @maximumnum_f32_1_maximumnum_val_p0_val_v2f32(
; CHECK-SAME: <2 x float> [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call <2 x float> @llvm.maximumnum.v2f32(<2 x float> [[X]], <2 x float> splat (float 1.000000e+00))
; CHECK-NEXT:    ret <2 x float> [[Z]]
;
  %y = call <2 x float> @llvm.maximumnum.v2f32(<2 x float> %x, <2 x float> zeroinitializer)
  %z = call <2 x float> @llvm.maximumnum.v2f32(<2 x float> %y, <2 x float> splat (float 1.0))
  ret <2 x float> %z
}

define float @maximumnum4(float %x, float %y, float %z, float %w) {
; CHECK-LABEL: define float @maximumnum4(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], float [[Z:%.*]], float [[W:%.*]]) {
; CHECK-NEXT:    [[A:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[B:%.*]] = call float @llvm.maximumnum.f32(float [[Z]], float [[W]])
; CHECK-NEXT:    [[C:%.*]] = call float @llvm.maximumnum.f32(float [[A]], float [[B]])
; CHECK-NEXT:    ret float [[C]]
;
  %a = call float @llvm.maximumnum.f32(float %x, float %y)
  %b = call float @llvm.maximumnum.f32(float %z, float %w)
  %c = call float @llvm.maximumnum.f32(float %a, float %b)
  ret float %c
}

; PR37404 - https://bugs.llvm.org/show_bug.cgi?id=37404

define <2 x float> @maximumnum_neg_neg(<2 x float> %x, <2 x float> %y) {
; CHECK-LABEL: define <2 x float> @maximumnum_neg_neg(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.minimumnum.v2f32(<2 x float> [[X]], <2 x float> [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg <2 x float> [[TMP1]]
; CHECK-NEXT:    ret <2 x float> [[R]]
;
  %negx = fsub <2 x float> splat (float -0.0), %x
  %negy = fsub <2 x float> splat (float -0.0), %y
  %r = call <2 x float> @llvm.maximumnum.v2f32(<2 x float> %negx, <2 x float> %negy)
  ret <2 x float> %r
}

; FMF is not required, but it should be propagated from the intrinsic (not the fnegs).

define float @maximumnum_neg_neg_vec_fmf(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_neg_neg_vec_fmf(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call fast float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg fast float [[TMP1]]
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fsub arcp float -0.0, %x
  %negy = fsub afn float -0.0, %y
  %r = call fast float @llvm.maximumnum.f32(float %negx, float %negy)
  ret float %r
}

define float @maximumnum_unary_neg_neg_vec_fmf(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_unary_neg_neg_vec_fmf(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call fast float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg fast float [[TMP1]]
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg arcp float %x
  %negy = fneg afn float %y
  %r = call fast float @llvm.maximumnum.f32(float %negx, float %negy)
  ret float %r
}

; 1 extra use of an intermediate value should still allow the fold,
; but 2 would require more instructions than we started with.

declare void @use(float)
define float @maximumnum_neg_neg_extra_use_x(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_neg_neg_extra_use_x(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg float [[X]]
; CHECK-NEXT:    [[TMP1:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg float [[TMP1]]
; CHECK-NEXT:    call void @use(float [[NEGX]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fsub float -0.0, %x
  %negy = fsub float -0.0, %y
  %r = call float @llvm.maximumnum.f32(float %negx, float %negy)
  call void @use(float %negx)
  ret float %r
}

define float @maximumnum_unary_neg_neg_extra_use_x(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_unary_neg_neg_extra_use_x(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg float [[X]]
; CHECK-NEXT:    [[TMP1:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg float [[TMP1]]
; CHECK-NEXT:    call void @use(float [[NEGX]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg float %x
  %negy = fneg float %y
  %r = call float @llvm.maximumnum.f32(float %negx, float %negy)
  call void @use(float %negx)
  ret float %r
}

define float @maximumnum_neg_neg_extra_use_y(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_neg_neg_extra_use_y(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGY:%.*]] = fneg float [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg float [[TMP1]]
; CHECK-NEXT:    call void @use(float [[NEGY]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fsub float -0.0, %x
  %negy = fsub float -0.0, %y
  %r = call float @llvm.maximumnum.f32(float %negx, float %negy)
  call void @use(float %negy)
  ret float %r
}

define float @maximumnum_unary_neg_neg_extra_use_y(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_unary_neg_neg_extra_use_y(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGY:%.*]] = fneg float [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg float [[TMP1]]
; CHECK-NEXT:    call void @use(float [[NEGY]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg float %x
  %negy = fneg float %y
  %r = call float @llvm.maximumnum.f32(float %negx, float %negy)
  call void @use(float %negy)
  ret float %r
}

define float @maximumnum_neg_neg_extra_use_x_and_y(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_neg_neg_extra_use_x_and_y(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg float [[X]]
; CHECK-NEXT:    [[NEGY:%.*]] = fneg float [[Y]]
; CHECK-NEXT:    [[R:%.*]] = call float @llvm.maximumnum.f32(float [[NEGX]], float [[NEGY]])
; CHECK-NEXT:    call void @use(float [[NEGX]])
; CHECK-NEXT:    call void @use(float [[NEGY]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fsub float -0.0, %x
  %negy = fsub float -0.0, %y
  %r = call float @llvm.maximumnum.f32(float %negx, float %negy)
  call void @use(float %negx)
  call void @use(float %negy)
  ret float %r
}

define float @maximumnum_unary_neg_neg_extra_use_x_and_y(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_unary_neg_neg_extra_use_x_and_y(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg float [[X]]
; CHECK-NEXT:    [[NEGY:%.*]] = fneg float [[Y]]
; CHECK-NEXT:    [[R:%.*]] = call float @llvm.maximumnum.f32(float [[NEGX]], float [[NEGY]])
; CHECK-NEXT:    call void @use(float [[NEGX]])
; CHECK-NEXT:    call void @use(float [[NEGY]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg float %x
  %negy = fneg float %y
  %r = call float @llvm.maximumnum.f32(float %negx, float %negy)
  call void @use(float %negx)
  call void @use(float %negy)
  ret float %r
}

define float @maximumnum_reduce_precision(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_reduce_precision(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[TRUNC:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  %maximumnum = call double @llvm.maximumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %maximumnum to float
  ret float %trunc
}

define float @maximumnum_reduce_precision_fmf(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_reduce_precision_fmf(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[TRUNC:%.*]] = call nnan float @llvm.maximumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  %maximumnum = call nnan double @llvm.maximumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %maximumnum to float
  ret float %trunc
}

define float @maximumnum_reduce_precision_multi_use_0(float %x, float %y, ptr %p) {
; CHECK-LABEL: define float @maximumnum_reduce_precision_multi_use_0(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = fpext float [[X]] to double
; CHECK-NEXT:    store double [[X_EXT]], ptr [[P]], align 8
; CHECK-NEXT:    [[TRUNC:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  store double %x.ext, ptr %p
  %maximumnum = call double @llvm.maximumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %maximumnum to float
  ret float %trunc
}

define float @reduce_precision_multi_use_1(float %x, float %y, ptr %p) {
; CHECK-LABEL: define float @reduce_precision_multi_use_1(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:    [[Y_EXT1:%.*]] = fpext float [[Y]] to double
; CHECK-NEXT:    store double [[Y_EXT1]], ptr [[P]], align 8
; CHECK-NEXT:    [[TRUNC:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  store double %y.ext, ptr %p
  %maximumnum = call double @llvm.maximumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %maximumnum to float
  ret float %trunc
}

define float @maximumnum_reduce_precision_multi_use_2(float %x, float %y, ptr %p, ptr %p2) {
; CHECK-LABEL: define float @maximumnum_reduce_precision_multi_use_2(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], ptr [[P:%.*]], ptr [[P2:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = fpext float [[X]] to double
; CHECK-NEXT:    [[Y_EXT:%.*]] = fpext float [[Y]] to double
; CHECK-NEXT:    store double [[X_EXT]], ptr [[P]], align 8
; CHECK-NEXT:    store double [[Y_EXT]], ptr [[P2]], align 8
; CHECK-NEXT:    [[MAXIMUMNUM:%.*]] = call double @llvm.maximumnum.f64(double [[X_EXT]], double [[Y_EXT]])
; CHECK-NEXT:    [[TRUNC:%.*]] = fptrunc double [[MAXIMUMNUM]] to float
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  store double %x.ext, ptr %p
  store double %y.ext, ptr %p2
  %maximumnum = call double @llvm.maximumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %maximumnum to float
  ret float %trunc
}

define float @maximumnum_negated_op(float %x) {
; CHECK-LABEL: define float @maximumnum_negated_op(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[R:%.*]] = call float @llvm.fabs.f32(float [[X]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg float %x
  %r = call float @llvm.maximumnum.f32(float %negx, float %x)
  ret float %r
}

define <2 x double> @maximumnum_negated_op_fmf_commute_vec(<2 x double> %x) {
; CHECK-LABEL: define <2 x double> @maximumnum_negated_op_fmf_commute_vec(
; CHECK-SAME: <2 x double> [[X:%.*]]) {
; CHECK-NEXT:    [[R:%.*]] = call nnan ninf nsz <2 x double> @llvm.fabs.v2f64(<2 x double> [[X]])
; CHECK-NEXT:    ret <2 x double> [[R]]
;
  %negx = fneg <2 x double> %x
  %r = call nsz nnan ninf <2 x double> @llvm.maximumnum.v2f64(<2 x double> %x, <2 x double> %negx)
  ret <2 x double> %r
}

define float @maximumnum_negated_op_extra_use(float %x) {
; CHECK-LABEL: define float @maximumnum_negated_op_extra_use(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg float [[X]]
; CHECK-NEXT:    call void @use(float [[NEGX]])
; CHECK-NEXT:    [[R:%.*]] = call float @llvm.fabs.f32(float [[X]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg float %x
  call void @use(float %negx)
  %r = call float @llvm.maximumnum.f32(float %negx, float %x)
  ret float %r
}

define float @maximumnum_negated_op_extra_use_comm(float %x) {
; CHECK-LABEL: define float @maximumnum_negated_op_extra_use_comm(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg float [[X]]
; CHECK-NEXT:    call void @use(float [[NEGX]])
; CHECK-NEXT:    [[R:%.*]] = call float @llvm.fabs.f32(float [[X]])
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg float %x
  call void @use(float %negx)
  %r = call float @llvm.maximumnum.f32(float %x, float %negx)
  ret float %r
}
