; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes='instcombine<no-verify-fixpoint>' -S | FileCheck %s

; This is a fuzzer-generated test that would assert because
; we'd get into foldAndOfICmps() without running InstSimplify
; on an 'and' that should have been killed. It's not obvious
; why, but removing anything hides the bug, hence the long test.

define void @simplify_before_foldAndOfICmps(ptr %p, ptr %A8) {
; CHECK-LABEL: @simplify_before_foldAndOfICmps(
; CHECK-NEXT:    [[L7:%.*]] = load i16, ptr [[A8:%.*]], align 2
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i16 [[L7]], -1
; CHECK-NEXT:    [[B11:%.*]] = zext i1 [[TMP1]] to i16
; CHECK-NEXT:    [[TMP2:%.*]] = zext i1 [[TMP1]] to i64
; CHECK-NEXT:    [[G4:%.*]] = getelementptr i16, ptr [[A8]], i64 [[TMP2]]
; CHECK-NEXT:    [[L2:%.*]] = load i16, ptr [[G4]], align 2
; CHECK-NEXT:    [[L4:%.*]] = load i16, ptr [[A8]], align 2
; CHECK-NEXT:    [[B21:%.*]] = sdiv i16 [[L7]], [[L4]]
; CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP1]], i16 [[B21]], i16 0
; CHECK-NEXT:    [[B18:%.*]] = sub i16 0, [[TMP5]]
; CHECK-NEXT:    [[C11:%.*]] = icmp ugt i16 [[L2]], [[B11]]
; CHECK-NEXT:    [[B20:%.*]] = and i16 [[L7]], [[L2]]
; CHECK-NEXT:    [[C5:%.*]] = icmp sgt i16 [[B21]], [[L2]]
; CHECK-NEXT:    [[C12:%.*]] = icmp ule i16 [[B21]], [[L2]]
; CHECK-NEXT:    [[C10:%.*]] = icmp slt i16 [[B20]], 0
; CHECK-NEXT:    [[B29:%.*]] = srem i16 [[L4]], [[B18]]
; CHECK-NEXT:    [[B15:%.*]] = xor i1 [[C10]], [[C11]]
; CHECK-NEXT:    [[TMP6:%.*]] = and i1 [[C12]], [[B15]]
; CHECK-NEXT:    [[C6:%.*]] = xor i1 [[TMP6]], true
; CHECK-NEXT:    [[B33:%.*]] = or i16 [[B29]], [[L4]]
; CHECK-NEXT:    [[C3:%.*]] = and i1 [[C5]], [[C6]]
; CHECK-NEXT:    [[C4:%.*]] = and i1 [[C3]], [[C11]]
; CHECK-NEXT:    [[TMP4:%.*]] = xor i1 [[C11]], true
; CHECK-NEXT:    [[C18:%.*]] = or i1 [[C10]], [[TMP4]]
; CHECK-NEXT:    [[TMP3:%.*]] = sext i1 [[C4]] to i64
; CHECK-NEXT:    [[G26:%.*]] = getelementptr i1, ptr null, i64 [[TMP3]]
; CHECK-NEXT:    store i16 [[B33]], ptr [[P:%.*]], align 2
; CHECK-NEXT:    store i1 [[C18]], ptr [[P]], align 1
; CHECK-NEXT:    store ptr [[G26]], ptr [[P]], align 8
; CHECK-NEXT:    ret void
;
  %L7 = load i16, ptr %A8
  %G21 = getelementptr i16, ptr %A8, i8 -1
  %B11 = udiv i16 %L7, -1
  %G4 = getelementptr i16, ptr %A8, i16 %B11
  %L2 = load i16, ptr %G4
  %L = load i16, ptr %G4
  %B23 = mul i16 %B11, %B11
  %L4 = load i16, ptr %A8
  %B21 = sdiv i16 %L7, %L4
  %B7 = sub i16 0, %B21
  %B18 = mul i16 %B23, %B7
  %C10 = icmp ugt i16 %L, %B11
  %B20 = and i16 %L7, %L2
  %B1 = mul i1 %C10, true
  %C5 = icmp sle i16 %B21, %L
  %C11 = icmp ule i16 %B21, %L
  %C7 = icmp slt i16 %B20, 0
  %B29 = srem i16 %L4, %B18
  %B15 = add i1 %C7, %C10
  %B19 = add i1 %C11, %B15
  %C6 = icmp sge i1 %C11, %B19
  %B33 = or i16 %B29, %L4
  %C13 = icmp uge i1 %C5, %B1
  %C3 = icmp ult i1 %C13, %C6
  store i16 undef, ptr %G21
  %C18 = icmp ule i1 %C10, %C7
  %G26 = getelementptr i1, ptr null, i1 %C3
  store i16 %B33, ptr %p
  store i1 %C18, ptr %p
  store ptr %G26, ptr %p
  ret void
}
