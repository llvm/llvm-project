; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

define float @minimumnum_f32_1_minimumnum_val_p0(float %x) {
; CHECK-LABEL: define float @minimumnum_f32_1_minimumnum_val_p0(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.minimumnum.f32(float %x, float 0.0)
  %z = call float @llvm.minimumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @minimumnum_f32_1_minimumnum_p0_val_fast(float %x) {
; CHECK-LABEL: define float @minimumnum_f32_1_minimumnum_p0_val_fast(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.minimumnum.f32(float 0.0, float %x)
  %z = call fast float @llvm.minimumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @minimumnum_f32_1_minimumnum_p0_val_fmf1(float %x) {
; CHECK-LABEL: define float @minimumnum_f32_1_minimumnum_p0_val_fmf1(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call nnan float @llvm.minimumnum.f32(float [[X]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call nsz nnan float @llvm.minimumnum.f32(float 0.0, float %x)
  %z = call nnan ninf float @llvm.minimumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @minimumnum_f32_1_minimumnum_p0_val_fmf2(float %x) {
; CHECK-LABEL: define float @minimumnum_f32_1_minimumnum_p0_val_fmf2(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call ninf float @llvm.minimumnum.f32(float [[X]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call nnan ninf float @llvm.minimumnum.f32(float 0.0, float %x)
  %z = call nsz ninf float @llvm.minimumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @minimumnum_f32_1_minimumnum_p0_val_fmf3(float %x) {
; CHECK-LABEL: define float @minimumnum_f32_1_minimumnum_p0_val_fmf3(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call nnan ninf nsz float @llvm.minimumnum.f32(float [[X]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call nsz ninf nnan float @llvm.minimumnum.f32(float 0.0, float %x)
  %z = call nsz ninf nnan float @llvm.minimumnum.f32(float %y, float 1.0)
  ret float %z
}

define float @minimumnum_f32_p0_minimumnum_val_n0(float %x) {
; CHECK-LABEL: define float @minimumnum_f32_p0_minimumnum_val_n0(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float -0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.minimumnum.f32(float %x, float -0.0)
  %z = call float @llvm.minimumnum.f32(float %y, float 0.0)
  ret float %z
}

define float @minimumnum_f32_1_minimumnum_p0_val(float %x) {
; CHECK-LABEL: define float @minimumnum_f32_1_minimumnum_p0_val(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[Z]]
;
  %y = call float @llvm.minimumnum.f32(float 0.0, float %x)
  %z = call float @llvm.minimumnum.f32(float %y, float 1.0)
  ret float %z
}

define <2 x float> @minimumnum_f32_1_minimumnum_val_p0_val_v2f32(<2 x float> %x) {
; CHECK-LABEL: define <2 x float> @minimumnum_f32_1_minimumnum_val_p0_val_v2f32(
; CHECK-SAME: <2 x float> [[X:%.*]]) {
; CHECK-NEXT:    [[Z:%.*]] = call <2 x float> @llvm.minimumnum.v2f32(<2 x float> [[X]], <2 x float> zeroinitializer)
; CHECK-NEXT:    ret <2 x float> [[Z]]
;
  %y = call <2 x float> @llvm.minimumnum.v2f32(<2 x float> %x, <2 x float> zeroinitializer)
  %z = call <2 x float> @llvm.minimumnum.v2f32(<2 x float> %y, <2 x float> splat (float 1.0))
  ret <2 x float> %z
}

define float @minimumnum4(float %x, float %y, float %z, float %w) {
; CHECK-LABEL: define float @minimumnum4(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], float [[Z:%.*]], float [[W:%.*]]) {
; CHECK-NEXT:    [[A:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[B:%.*]] = call float @llvm.minimumnum.f32(float [[Z]], float [[W]])
; CHECK-NEXT:    [[C:%.*]] = call float @llvm.minimumnum.f32(float [[A]], float [[B]])
; CHECK-NEXT:    ret float [[C]]
;
  %a = call float @llvm.minimumnum.f32(float %x, float %y)
  %b = call float @llvm.minimumnum.f32(float %z, float %w)
  %c = call float @llvm.minimumnum.f32(float %a, float %b)
  ret float %c
}

define float @minimumnum_x_maximumnum_x_y(float %x, float %y) {
; CHECK-LABEL: define float @minimumnum_x_maximumnum_x_y(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[A:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[B:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[A]])
; CHECK-NEXT:    ret float [[B]]
;
  %a = call float @llvm.maximumnum.f32(float %x, float %y)
  %b = call float @llvm.minimumnum.f32(float %x, float %a)
  ret float %b
}

define float @maximumnum_x_minimumnum_x_y(float %x, float %y) {
; CHECK-LABEL: define float @maximumnum_x_minimumnum_x_y(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[A:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    [[B:%.*]] = call float @llvm.maximumnum.f32(float [[X]], float [[A]])
; CHECK-NEXT:    ret float [[B]]
;
  %a = call float @llvm.minimumnum.f32(float %x, float %y)
  %b = call float @llvm.maximumnum.f32(float %x, float %a)
  ret float %b
}

; PR37405 - https://bugs.llvm.org/show_bug.cgi?id=37405

define double @minimumnum_neg_neg(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_neg_neg(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call double @llvm.maximumnum.f64(double [[X]], double [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg double [[TMP1]]
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fsub double -0.0, %x
  %negy = fsub double -0.0, %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  ret double %r
}

define double @minimumnum_unary_neg_neg(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_unary_neg_neg(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call double @llvm.maximumnum.f64(double [[X]], double [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg double [[TMP1]]
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fneg double %x
  %negy = fneg double %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  ret double %r
}

; FMF is not required, but it should be propagated from the intrinsic (not the fnegs).
; Also, make sure this works with vectors.

define <2 x double> @minimumnum_neg_neg_vec_fmf(<2 x double> %x, <2 x double> %y) {
; CHECK-LABEL: define <2 x double> @minimumnum_neg_neg_vec_fmf(
; CHECK-SAME: <2 x double> [[X:%.*]], <2 x double> [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call nnan ninf <2 x double> @llvm.maximumnum.v2f64(<2 x double> [[X]], <2 x double> [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg nnan ninf <2 x double> [[TMP1]]
; CHECK-NEXT:    ret <2 x double> [[R]]
;
  %negx = fsub reassoc <2 x double> splat (double -0.0), %x
  %negy = fsub fast <2 x double> splat (double -0.0), %y
  %r = call nnan ninf <2 x double> @llvm.minimumnum.v2f64(<2 x double> %negx, <2 x double> %negy)
  ret <2 x double> %r
}

define <2 x double> @minimumnum_unary_neg_neg_vec_fmf(<2 x double> %x, <2 x double> %y) {
; CHECK-LABEL: define <2 x double> @minimumnum_unary_neg_neg_vec_fmf(
; CHECK-SAME: <2 x double> [[X:%.*]], <2 x double> [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call nnan ninf <2 x double> @llvm.maximumnum.v2f64(<2 x double> [[X]], <2 x double> [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg nnan ninf <2 x double> [[TMP1]]
; CHECK-NEXT:    ret <2 x double> [[R]]
;
  %negx = fneg reassoc <2 x double> %x
  %negy = fneg fast <2 x double> %y
  %r = call nnan ninf <2 x double> @llvm.minimumnum.v2f64(<2 x double> %negx, <2 x double> %negy)
  ret <2 x double> %r
}

; 1 extra use of an intermediate value should still allow the fold,
; but 2 would require more instructions than we started with.

declare void @use(double)
define double @minimumnum_neg_neg_extra_use_x(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_neg_neg_extra_use_x(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg double [[X]]
; CHECK-NEXT:    [[TMP1:%.*]] = call double @llvm.maximumnum.f64(double [[X]], double [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg double [[TMP1]]
; CHECK-NEXT:    call void @use(double [[NEGX]])
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fsub double -0.0, %x
  %negy = fsub double -0.0, %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  call void @use(double %negx)
  ret double %r
}

define double @minimumnum_unary_neg_neg_extra_use_x(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_unary_neg_neg_extra_use_x(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg double [[X]]
; CHECK-NEXT:    [[TMP1:%.*]] = call double @llvm.maximumnum.f64(double [[X]], double [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg double [[TMP1]]
; CHECK-NEXT:    call void @use(double [[NEGX]])
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fneg double %x
  %negy = fneg double %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  call void @use(double %negx)
  ret double %r
}

define double @minimumnum_neg_neg_extra_use_y(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_neg_neg_extra_use_y(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGY:%.*]] = fneg double [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = call double @llvm.maximumnum.f64(double [[X]], double [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg double [[TMP1]]
; CHECK-NEXT:    call void @use(double [[NEGY]])
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fsub double -0.0, %x
  %negy = fsub double -0.0, %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  call void @use(double %negy)
  ret double %r
}

define double @minimumnum_unary_neg_neg_extra_use_y(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_unary_neg_neg_extra_use_y(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGY:%.*]] = fneg double [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = call double @llvm.maximumnum.f64(double [[X]], double [[Y]])
; CHECK-NEXT:    [[R:%.*]] = fneg double [[TMP1]]
; CHECK-NEXT:    call void @use(double [[NEGY]])
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fneg double %x
  %negy = fneg double %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  call void @use(double %negy)
  ret double %r
}

define double @minimumnum_neg_neg_extra_use_x_and_y(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_neg_neg_extra_use_x_and_y(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg double [[X]]
; CHECK-NEXT:    [[NEGY:%.*]] = fneg double [[Y]]
; CHECK-NEXT:    [[R:%.*]] = call double @llvm.minimumnum.f64(double [[NEGX]], double [[NEGY]])
; CHECK-NEXT:    call void @use(double [[NEGX]])
; CHECK-NEXT:    call void @use(double [[NEGY]])
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fsub double -0.0, %x
  %negy = fsub double -0.0, %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  call void @use(double %negx)
  call void @use(double %negy)
  ret double %r
}

define double @minimumnum_unary_neg_neg_extra_use_x_and_y(double %x, double %y) {
; CHECK-LABEL: define double @minimumnum_unary_neg_neg_extra_use_x_and_y(
; CHECK-SAME: double [[X:%.*]], double [[Y:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg double [[X]]
; CHECK-NEXT:    [[NEGY:%.*]] = fneg double [[Y]]
; CHECK-NEXT:    [[R:%.*]] = call double @llvm.minimumnum.f64(double [[NEGX]], double [[NEGY]])
; CHECK-NEXT:    call void @use(double [[NEGX]])
; CHECK-NEXT:    call void @use(double [[NEGY]])
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fneg double %x
  %negy = fneg double %y
  %r = call double @llvm.minimumnum.f64(double %negx, double %negy)
  call void @use(double %negx)
  call void @use(double %negy)
  ret double %r
}

define float @minimumnum_reduce_precision(float %x, float %y) {
; CHECK-LABEL: define float @minimumnum_reduce_precision(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[TRUNC:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  %minimumnum = call double @llvm.minimumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_reduce_precision_fmf(float %x, float %y) {
; CHECK-LABEL: define float @minimumnum_reduce_precision_fmf(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]]) {
; CHECK-NEXT:    [[TRUNC:%.*]] = call nnan float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  %minimumnum = call nnan double @llvm.minimumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_reduce_precision_multi_use_0(float %x, float %y, ptr %p) {
; CHECK-LABEL: define float @minimumnum_reduce_precision_multi_use_0(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = fpext float [[X]] to double
; CHECK-NEXT:    store double [[X_EXT]], ptr [[P]], align 8
; CHECK-NEXT:    [[TRUNC:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  store double %x.ext, ptr %p
  %minimumnum = call double @llvm.minimumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_reduce_precision_multi_use_1(float %x, float %y, ptr %p) {
; CHECK-LABEL: define float @minimumnum_reduce_precision_multi_use_1(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:    [[Y_EXT:%.*]] = fpext float [[Y]] to double
; CHECK-NEXT:    store double [[Y_EXT]], ptr [[P]], align 8
; CHECK-NEXT:    [[TRUNC:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float [[Y]])
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  store double %y.ext, ptr %p
  %minimumnum = call double @llvm.minimumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_reduce_precision_multi_use_2(float %x, float %y, ptr %p, ptr %p2) {
; CHECK-LABEL: define float @minimumnum_reduce_precision_multi_use_2(
; CHECK-SAME: float [[X:%.*]], float [[Y:%.*]], ptr [[P:%.*]], ptr [[P2:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = fpext float [[X]] to double
; CHECK-NEXT:    [[Y_EXT:%.*]] = fpext float [[Y]] to double
; CHECK-NEXT:    store double [[X_EXT]], ptr [[P]], align 8
; CHECK-NEXT:    store double [[Y_EXT]], ptr [[P2]], align 8
; CHECK-NEXT:    [[MINIMUMNUM:%.*]] = call double @llvm.minimumnum.f64(double [[X_EXT]], double [[Y_EXT]])
; CHECK-NEXT:    [[TRUNC:%.*]] = fptrunc double [[MINIMUMNUM]] to float
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %y.ext = fpext float %y to double
  store double %x.ext, ptr %p
  store double %y.ext, ptr %p2
  %minimumnum = call double @llvm.minimumnum.f64(double %x.ext, double %y.ext)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_reduce_precision_const(float %x) {
; CHECK-LABEL: define float @minimumnum_reduce_precision_const(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[TRUNC:%.*]] = call float @llvm.minimumnum.f32(float [[X]], float 1.000000e+00)
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %minimumnum = call double @llvm.minimumnum.f64(double %x.ext, double 1.0)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_reduce_precision_const_not_lossless(float %x) {
; CHECK-LABEL: define float @minimumnum_reduce_precision_const_not_lossless(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = fpext float [[X]] to double
; CHECK-NEXT:    [[MINIMUMNUM:%.*]] = call double @llvm.minimumnum.f64(double [[X_EXT]], double 1.000000e-01)
; CHECK-NEXT:    [[TRUNC:%.*]] = fptrunc double [[MINIMUMNUM]] to float
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  %minimumnum = call double @llvm.minimumnum.f64(double %x.ext, double 0.1)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_reduce_precision_const_multi_use(float %x) {
; CHECK-LABEL: define float @minimumnum_reduce_precision_const_multi_use(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = fpext float [[X]] to double
; CHECK-NEXT:    call void @use(double [[X_EXT]])
; CHECK-NEXT:    [[MINIMUMNUM:%.*]] = call double @llvm.minimumnum.f64(double [[X_EXT]], double 1.000000e+00)
; CHECK-NEXT:    [[TRUNC:%.*]] = fptrunc double [[MINIMUMNUM]] to float
; CHECK-NEXT:    ret float [[TRUNC]]
;
  %x.ext = fpext float %x to double
  call void @use(double %x.ext)
  %minimumnum = call double @llvm.minimumnum.f64(double %x.ext, double 1.0)
  %trunc = fptrunc double %minimumnum to float
  ret float %trunc
}

define float @minimumnum_negated_op(float %x) {
; CHECK-LABEL: define float @minimumnum_negated_op(
; CHECK-SAME: float [[X:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call float @llvm.fabs.f32(float [[X]])
; CHECK-NEXT:    [[R:%.*]] = fneg float [[TMP1]]
; CHECK-NEXT:    ret float [[R]]
;
  %negx = fneg float %x
  %r = call float @llvm.minimumnum.f32(float %x, float %negx)
  ret float %r
}

define <2 x double> @minimumnum_negated_op_fmf_commute_vec(<2 x double> %x) {
; CHECK-LABEL: define <2 x double> @minimumnum_negated_op_fmf_commute_vec(
; CHECK-SAME: <2 x double> [[X:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call nnan ninf nsz <2 x double> @llvm.fabs.v2f64(<2 x double> [[X]])
; CHECK-NEXT:    [[R:%.*]] = fneg nnan ninf nsz <2 x double> [[TMP1]]
; CHECK-NEXT:    ret <2 x double> [[R]]
;
  %negx = fneg <2 x double> %x
  %r = call nsz nnan ninf <2 x double> @llvm.minimumnum.v2f64(<2 x double> %negx, <2 x double> %x)
  ret <2 x double> %r
}

define double @minimumnum_negated_op_extra_use(double %x) {
; CHECK-LABEL: define double @minimumnum_negated_op_extra_use(
; CHECK-SAME: double [[X:%.*]]) {
; CHECK-NEXT:    [[NEGX:%.*]] = fneg double [[X]]
; CHECK-NEXT:    call void @use(double [[NEGX]])
; CHECK-NEXT:    [[R:%.*]] = call double @llvm.minimumnum.f64(double [[NEGX]], double [[X]])
; CHECK-NEXT:    ret double [[R]]
;
  %negx = fneg double %x
  call void @use(double %negx)
  %r = call double @llvm.minimumnum.f64(double %negx, double %x)
  ret double %r
}
