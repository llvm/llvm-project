; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; Test for GitHub issue #176554
; InstCombine should fold range comparisons even when the logical-and
; uses bitwise 'and' instead of 'select' form.

; This is the buggy pattern that was not being optimized:
;   %cmp1 = icmp ugt i32 %y, 65535
;   %sel11 = and i1 %cond, %cmp1  ; <-- and instead of select
;   %cmp2 = icmp ult i32 %y, 1114112
;   %sel2 = select i1 %sel11, i1 %cmp2, i1 false
;
; Should be optimized to a single range check.

define i1 @test_and_form(i1 %cond, i32 %y) {
; CHECK-LABEL: @test_and_form(
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[Y:%.*]], -65536
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[TMP1]], 1048576
; CHECK-NEXT:    [[SEL2:%.*]] = and i1 [[COND:%.*]], [[TMP2]]
; CHECK-NEXT:    ret i1 [[SEL2]]
;
  %cmp1 = icmp ugt i32 %y, 65535
  %sel11 = and i1 %cond, %cmp1
  %cmp2 = icmp ult i32 %y, 1114112
  %sel2 = select i1 %sel11, i1 %cmp2, i1 false
  ret i1 %sel2
}

; Reference: the canonical select form that already works
define i1 @test_select_form(i1 %cond, i32 %y) {
; CHECK-LABEL: @test_select_form(
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[Y:%.*]], -65536
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[TMP1]], 1048576
; CHECK-NEXT:    [[SEL2:%.*]] = select i1 [[COND:%.*]], i1 [[TMP2]], i1 false
; CHECK-NEXT:    ret i1 [[SEL2]]
;
  %cmp1 = icmp ugt i32 %y, 65535
  %sel1 = select i1 %cond, i1 %cmp1, i1 false
  %cmp2 = icmp ult i32 %y, 1114112
  %sel2 = select i1 %sel1, i1 %cmp2, i1 false
  ret i1 %sel2
}

; Test with the icmp on the other side of the and
define i1 @test_and_form_swapped(i1 %cond, i32 %y) {
; CHECK-LABEL: @test_and_form_swapped(
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[Y:%.*]], -65536
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[TMP1]], 1048576
; CHECK-NEXT:    [[SEL2:%.*]] = and i1 [[TMP2]], [[COND:%.*]]
; CHECK-NEXT:    ret i1 [[SEL2]]
;
  %cmp1 = icmp ugt i32 %y, 65535
  %sel11 = and i1 %cmp1, %cond  ; swapped operands
  %cmp2 = icmp ult i32 %y, 1114112
  %sel2 = select i1 %sel11, i1 %cmp2, i1 false
  ret i1 %sel2
}

; Test logical-or form: select (or A, cmp1), true, cmp2
define i1 @test_or_form(i1 %cond, i32 %y) {
; CHECK-LABEL: @test_or_form(
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[Y:%.*]], -1114112
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[TMP1]], -1048576
; CHECK-NEXT:    [[SEL2:%.*]] = or i1 [[COND:%.*]], [[TMP2]]
; CHECK-NEXT:    ret i1 [[SEL2]]
;
  %cmp1 = icmp ugt i32 %y, 1114111
  %sel11 = or i1 %cond, %cmp1
  %cmp2 = icmp ult i32 %y, 65536
  %sel2 = select i1 %sel11, i1 true, i1 %cmp2
  ret i1 %sel2
}

; Test bitwise and reassociation: (cond & cmp1) & cmp2
define i1 @test_bitwise_and(i1 %cond, i32 %y) {
; CHECK-LABEL: @test_bitwise_and(
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[Y:%.*]], -65536
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[TMP1]], 1048576
; CHECK-NEXT:    [[SEL2:%.*]] = and i1 [[COND:%.*]], [[TMP2]]
; CHECK-NEXT:    ret i1 [[SEL2]]
;
  %cmp1 = icmp ugt i32 %y, 65535
  %sel11 = and i1 %cond, %cmp1
  %cmp2 = icmp ult i32 %y, 1114112
  %sel2 = and i1 %sel11, %cmp2
  ret i1 %sel2
}

; Test bitwise or reassociation: (cond | cmp1) | cmp2
define i1 @test_bitwise_or(i1 %cond, i32 %y) {
; CHECK-LABEL: @test_bitwise_or(
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[Y:%.*]], -1114112
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[TMP1]], -1048576
; CHECK-NEXT:    [[SEL2:%.*]] = or i1 [[COND:%.*]], [[TMP2]]
; CHECK-NEXT:    ret i1 [[SEL2]]
;
  %cmp1 = icmp ugt i32 %y, 1114111
  %sel11 = or i1 %cond, %cmp1
  %cmp2 = icmp ult i32 %y, 65536
  %sel2 = or i1 %sel11, %cmp2
  ret i1 %sel2
}


; Negative test: different values in the icmps should not be folded
define i1 @test_and_form_different_values(i1 %cond, i32 %y, i32 %z) {
; CHECK-LABEL: @test_and_form_different_values(
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ugt i32 [[Y:%.*]], 65535
; CHECK-NEXT:    [[SEL11:%.*]] = and i1 [[COND:%.*]], [[CMP1]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[Z:%.*]], 1114112
; CHECK-NEXT:    [[SEL2:%.*]] = select i1 [[SEL11]], i1 [[CMP2]], i1 false
; CHECK-NEXT:    ret i1 [[SEL2]]
;
  %cmp1 = icmp ugt i32 %y, 65535
  %sel11 = and i1 %cond, %cmp1
  %cmp2 = icmp ult i32 %z, 1114112  ; different value!
  %sel2 = select i1 %sel11, i1 %cmp2, i1 false
  ret i1 %sel2
}

