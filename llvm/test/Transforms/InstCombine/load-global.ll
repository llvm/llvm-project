; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

@arr2 = constant [2 x i32] [i32 0, i32 1], align 4
@arr2_mutable = global [4 x i32] [i32 0, i32 0, i32 1, i32 1], align 4
@arr2_external = external constant [4 x i32], align 4
@arr2_uniform = constant [2 x i32] [i32 1, i32 1], align 4
@arr2_undef = constant [2 x i32] [i32 1, i32 undef], align 4
@arr3 = constant [3 x i32] [i32 0, i32 1, i32 1], align 4
@arr3_alt = constant [3 x i32] [i32 1, i32 0, i32 1], align 4
@arr3_uniform = constant [3 x i32] [i32 1, i32 1, i32 1], align 4
@arr3_var = constant [3 x i32] [i32 0, i32 3, i32 4], align 4
@arr4_multimap = constant [4 x i32] [i32 0, i32 0, i32 1, i32 1], align 4

define i32 @fold_arr2(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne i64 [[X]], 0
; CHECK-NEXT:    [[VAL:%.*]] = zext i1 [[TMP0]] to i32
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr2_uniform(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_uniform(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 1
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2_uniform, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr3(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr3(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne i64 [[X]], 0
; CHECK-NEXT:    [[VAL:%.*]] = zext i1 [[TMP0]] to i32
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [3 x i32], ptr @arr3, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr3_alt(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr3_alt(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne i64 [[X]], 1
; CHECK-NEXT:    [[VAL:%.*]] = zext i1 [[TMP0]] to i32
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [3 x i32], ptr @arr3_alt, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr3_uniform(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr3_uniform(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 1
;
entry:
  %arrayidx = getelementptr [3 x i32], ptr @arr3_uniform, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

; TODO: Handle ptradd pattern
define i32 @fold_arr2_i8(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_i8(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[OFFSET:%.*]] = shl nuw nsw i64 [[X]], 2
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr i8, ptr @arr2, i64 [[OFFSET]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %offset = mul nsw nuw i64 %x, 4
  %arrayidx = getelementptr i8, ptr @arr2, i64 %offset
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

; TODO: can be folded into x < 3 ? 0 : 1
define i32 @fold_arr4_multimap(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr4_multimap(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [4 x i32], ptr @arr4_multimap, i64 0, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [4 x i32], ptr @arr4_multimap, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

; negative tests

define i32 @fold_arr2_mutable(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_mutable(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [2 x i32], ptr @arr2_mutable, i64 0, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2_mutable, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr2_external(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_external(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [2 x i32], ptr @arr2_external, i64 0, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2_external, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr2_volatile(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_volatile(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [2 x i32], ptr @arr2, i64 0, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load volatile i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2, i64 0, i64 %x
  %val = load volatile i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr2_mismatch_type1(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_mismatch_type1(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [2 x i8], ptr @arr2, i64 0, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i8], ptr @arr2, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i8 @fold_arr2_mismatch_type2(i64 %x) {
; CHECK-LABEL: define i8 @fold_arr2_mismatch_type2(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ne i64 [[X]], 0
; CHECK-NEXT:    [[VAL:%.*]] = zext i1 [[TMP0]] to i8
; CHECK-NEXT:    ret i8 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2, i64 0, i64 %x
  %val = load i8, ptr %arrayidx, align 4
  ret i8 %val
}

define i32 @fold_arr2_bad_gep1(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_bad_gep1(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [2 x i32], ptr @arr2, i64 1, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2, i64 1, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr2_bad_gep2(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_bad_gep2(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 0
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2, i64 0
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr3_var(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr3_var(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [3 x i32], ptr @arr3_var, i64 0, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [3 x i32], ptr @arr3_var, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}

define i32 @fold_arr2_undef(i64 %x) {
; CHECK-LABEL: define i32 @fold_arr2_undef(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr [2 x i32], ptr @arr2_undef, i64 0, i64 [[X]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
entry:
  %arrayidx = getelementptr [2 x i32], ptr @arr2_undef, i64 0, i64 %x
  %val = load i32, ptr %arrayidx, align 4
  ret i32 %val
}
