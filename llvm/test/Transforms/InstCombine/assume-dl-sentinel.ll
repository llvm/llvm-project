; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck --check-prefixes=CHECK,DEFAULT %s
; RUN: opt < %s -passes=instcombine -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S | FileCheck --check-prefixes=CHECK-DL,DEFAULT-DL %s
; RUN: opt < %s -passes=instcombine --enable-knowledge-retention -S | FileCheck --check-prefixes=CHECK,BUNDLES %s
; RUN: opt < %s -passes=instcombine --enable-knowledge-retention -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S | FileCheck --check-prefixes=CHECK-DL,BUNDLES-DL %s

; RUN: opt < %s -passes=instcombine -S --try-experimental-debuginfo-iterators | FileCheck --check-prefixes=CHECK,DEFAULT %s
; RUN: opt < %s -passes=instcombine -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S --try-experimental-debuginfo-iterators | FileCheck --check-prefixes=CHECK-DL,DEFAULT-DL %s
; RUN: opt < %s -passes=instcombine --enable-knowledge-retention -S --try-experimental-debuginfo-iterators | FileCheck --check-prefixes=CHECK,BUNDLES %s
; RUN: opt < %s -passes=instcombine --enable-knowledge-retention -data-layout=z0:1-z2:neg1-z3:neg1-z5:neg1 -S --try-experimental-debuginfo-iterators | FileCheck --check-prefixes=CHECK-DL,BUNDLES-DL %s

target triple = "x86_64-unknown-linux-gnu"

declare void @llvm.assume(i1) #1
declare void @escape(ptr %a)

; Check that the assume has not been removed:

define i1 @nonnull1(ptr %a) {
; CHECK-LABEL: @nonnull1(
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8, !nonnull [[META6:![0-9]+]], !noundef [[META6]]
; CHECK-NEXT:    tail call void @escape(ptr nonnull [[LOAD]])
; CHECK-NEXT:    ret i1 false
;
; CHECK-DL-LABEL: @nonnull1(
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    tail call void @escape(ptr nonnull [[LOAD]])
; CHECK-DL-NEXT:    ret i1 false
;
  %load = load ptr, ptr %a
  %cmp = icmp ne ptr %load, null
  tail call void @llvm.assume(i1 %cmp)
  tail call void @escape(ptr %load)
  %rval = icmp eq ptr %load, null
  ret i1 %rval
}

; Make sure the above canonicalization does not trigger
; if the assume is control dependent on something else

define i1 @nonnull3(ptr %a, i1 %control) {
; FIXME: in the BUNDLES version we could duplicate the load and keep the assume nonnull.
; DEFAULT-LABEL: @nonnull3(
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ne ptr [[LOAD]], null
; DEFAULT-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; DEFAULT:       taken:
; DEFAULT-NEXT:    tail call void @llvm.assume(i1 [[CMP]])
; DEFAULT-NEXT:    ret i1 false
; DEFAULT:       not_taken:
; DEFAULT-NEXT:    [[RVAL_2:%.*]] = icmp sgt ptr [[LOAD]], null
; DEFAULT-NEXT:    ret i1 [[RVAL_2]]
;
; CHECK-DL-LABEL: @nonnull3(
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK-DL:       taken:
; CHECK-DL-NEXT:    ret i1 false
; CHECK-DL:       not_taken:
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    [[RVAL_2:%.*]] = icmp sgt ptr [[LOAD]], null
; CHECK-DL-NEXT:    ret i1 [[RVAL_2]]
;
; BUNDLES-LABEL: @nonnull3(
; BUNDLES-NEXT:  entry:
; BUNDLES-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; BUNDLES:       taken:
; BUNDLES-NEXT:    ret i1 false
; BUNDLES:       not_taken:
; BUNDLES-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; BUNDLES-NEXT:    [[RVAL_2:%.*]] = icmp sgt ptr [[LOAD]], null
; BUNDLES-NEXT:    ret i1 [[RVAL_2]]
;
entry:
  %load = load ptr, ptr %a
  %cmp = icmp ne ptr %load, null
  br i1 %control, label %taken, label %not_taken
taken:
  tail call void @llvm.assume(i1 %cmp)
  %rval = icmp eq ptr %load, null
  ret i1 %rval
not_taken:
  %rval.2 = icmp sgt ptr %load, null
  ret i1 %rval.2
}

; Make sure the above canonicalization does not trigger
; if the path from the load to the assume is potentially
; interrupted by an exception being thrown

define i1 @nonnull4(ptr %a) {
; DEFAULT-LABEL: @nonnull4(
; DEFAULT-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; DEFAULT-NEXT:    tail call void @escape(ptr [[LOAD]])
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ne ptr [[LOAD]], null
; DEFAULT-NEXT:    tail call void @llvm.assume(i1 [[CMP]])
; DEFAULT-NEXT:    ret i1 false
;
; CHECK-DL-LABEL: @nonnull4(
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    tail call void @escape(ptr nonnull [[LOAD]])
; CHECK-DL-NEXT:    ret i1 false
;
; BUNDLES-LABEL: @nonnull4(
; BUNDLES-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; BUNDLES-NEXT:    tail call void @escape(ptr [[LOAD]])
; BUNDLES-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(ptr [[LOAD]]) ]
; BUNDLES-NEXT:    ret i1 false
;
  %load = load ptr, ptr %a
  ;; This call may throw!
  tail call void @escape(ptr %load)
  %cmp = icmp ne ptr %load, null
  tail call void @llvm.assume(i1 %cmp)
  %rval = icmp eq ptr %load, null
  ret i1 %rval
}
define i1 @nonnull5(ptr %a) {
; CHECK-LABEL: @nonnull5(
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-NEXT:    tail call void @escape(ptr [[LOAD]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt ptr [[LOAD]], null
; CHECK-NEXT:    tail call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    ret i1 false
;
; CHECK-DL-LABEL: @nonnull5(
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    tail call void @escape(ptr nonnull [[LOAD]])
; CHECK-DL-NEXT:    [[CMP:%.*]] = icmp slt ptr [[LOAD]], null
; CHECK-DL-NEXT:    tail call void @llvm.assume(i1 [[CMP]])
; CHECK-DL-NEXT:    ret i1 false
;
  %load = load ptr, ptr %a
  ;; This call may throw!
  tail call void @escape(ptr %load)
  %integral = ptrtoint ptr %load to i64
  %cmp = icmp slt i64 %integral, 0
  tail call void @llvm.assume(i1 %cmp) ; %load has at least highest bit set
  %rval = icmp eq ptr %load, null
  ret i1 %rval
}

define i1 @nonnull3A(ptr %a, i1 %control) {
; DEFAULT-LABEL: @nonnull3A(
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; DEFAULT-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; DEFAULT:       taken:
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ne ptr [[LOAD]], null
; DEFAULT-NEXT:    call void @llvm.assume(i1 [[CMP]])
; DEFAULT-NEXT:    ret i1 [[CMP]]
; DEFAULT:       not_taken:
; DEFAULT-NEXT:    [[RVAL_2:%.*]] = icmp sgt ptr [[LOAD]], null
; DEFAULT-NEXT:    ret i1 [[RVAL_2]]
;
; CHECK-DL-LABEL: @nonnull3A(
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK-DL:       taken:
; CHECK-DL-NEXT:    ret i1 true
; CHECK-DL:       not_taken:
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    [[RVAL_2:%.*]] = icmp sgt ptr [[LOAD]], null
; CHECK-DL-NEXT:    ret i1 [[RVAL_2]]
;
; BUNDLES-LABEL: @nonnull3A(
; BUNDLES-NEXT:  entry:
; BUNDLES-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; BUNDLES:       taken:
; BUNDLES-NEXT:    ret i1 true
; BUNDLES:       not_taken:
; BUNDLES-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; BUNDLES-NEXT:    [[RVAL_2:%.*]] = icmp sgt ptr [[LOAD]], null
; BUNDLES-NEXT:    ret i1 [[RVAL_2]]
;
entry:
  %load = load ptr, ptr %a
  %cmp = icmp ne ptr %load, null
  br i1 %control, label %taken, label %not_taken
taken:
  call void @llvm.assume(i1 %cmp)
  ret i1 %cmp
not_taken:
  call void @llvm.assume(i1 %cmp)
  %rval.2 = icmp sgt ptr %load, null
  ret i1 %rval.2
}

define i1 @nonnull3B(ptr %a, i1 %control) {
; CHECK-LABEL: @nonnull3B(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK:       taken:
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne ptr [[LOAD]], null
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]]) [ "nonnull"(ptr [[LOAD]]) ]
; CHECK-NEXT:    ret i1 [[CMP]]
; CHECK:       not_taken:
; CHECK-NEXT:    ret i1 [[CONTROL]]
;
; CHECK-DL-LABEL: @nonnull3B(
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK-DL:       taken:
; CHECK-DL-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(ptr [[LOAD]]) ]
; CHECK-DL-NEXT:    ret i1 true
; CHECK-DL:       not_taken:
; CHECK-DL-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(ptr [[LOAD]]) ]
; CHECK-DL-NEXT:    ret i1 [[CONTROL]]
;
entry:
  %load = load ptr, ptr %a
  %cmp = icmp ne ptr %load, null
  br i1 %control, label %taken, label %not_taken
taken:
  call void @llvm.assume(i1 %cmp) ["nonnull"(ptr %load)]
  ret i1 %cmp
not_taken:
  call void @llvm.assume(i1 %cmp) ["nonnull"(ptr %load)]
  ret i1 %control
}

declare i1 @tmp1(i1)

define i1 @nonnull3C(ptr %a, i1 %control) {
; CHECK-LABEL: @nonnull3C(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK:       taken:
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne ptr [[LOAD]], null
; CHECK-NEXT:    [[CMP2:%.*]] = call i1 @tmp1(i1 [[CMP]])
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret i1 [[CMP2]]
; CHECK:       not_taken:
; CHECK-NEXT:    ret i1 [[CONTROL]]
;
; CHECK-DL-LABEL: @nonnull3C(
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK-DL:       taken:
; CHECK-DL-NEXT:    [[CMP2:%.*]] = call i1 @tmp1(i1 true)
; CHECK-DL-NEXT:    br label [[EXIT:%.*]]
; CHECK-DL:       exit:
; CHECK-DL-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(ptr [[LOAD]]) ]
; CHECK-DL-NEXT:    ret i1 [[CMP2]]
; CHECK-DL:       not_taken:
; CHECK-DL-NEXT:    ret i1 [[CONTROL]]
;
entry:
  %load = load ptr, ptr %a
  %cmp = icmp ne ptr %load, null
  br i1 %control, label %taken, label %not_taken
taken:
  %cmp2 = call i1 @tmp1(i1 %cmp)
  br label %exit
exit:
  ; FIXME: this shouldn't be dropped because it is still dominated by the new position of %load
  call void @llvm.assume(i1 %cmp) ["nonnull"(ptr %load)]
  ret i1 %cmp2
not_taken:
  call void @llvm.assume(i1 %cmp)
  ret i1 %control
}

define i1 @nonnull3D(ptr %a, i1 %control) {
; CHECK-LABEL: @nonnull3D(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK:       taken:
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne ptr [[LOAD]], null
; CHECK-NEXT:    [[CMP2:%.*]] = call i1 @tmp1(i1 [[CMP]])
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret i1 [[CMP2]]
; CHECK:       not_taken:
; CHECK-NEXT:    ret i1 [[CONTROL]]
;
; CHECK-DL-LABEL: @nonnull3D(
; CHECK-DL-NEXT:  entry:
; CHECK-DL-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-DL-NEXT:    br i1 [[CONTROL:%.*]], label [[TAKEN:%.*]], label [[NOT_TAKEN:%.*]]
; CHECK-DL:       taken:
; CHECK-DL-NEXT:    [[CMP2:%.*]] = call i1 @tmp1(i1 true)
; CHECK-DL-NEXT:    br label [[EXIT:%.*]]
; CHECK-DL:       exit:
; CHECK-DL-NEXT:    ret i1 [[CMP2]]
; CHECK-DL:       not_taken:
; CHECK-DL-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(ptr [[LOAD]]) ]
; CHECK-DL-NEXT:    ret i1 [[CONTROL]]
;
entry:
  %load = load ptr, ptr %a
  %cmp = icmp ne ptr %load, null
  br i1 %control, label %taken, label %not_taken
taken:
  %cmp2 = call i1 @tmp1(i1 %cmp)
  br label %exit
exit:
  ret i1 %cmp2
not_taken:
  call void @llvm.assume(i1 %cmp) ["nonnull"(ptr %load)]
  ret i1 %control
}

declare void @llvm.dbg.value(metadata, metadata, metadata)

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!5, !6, !7, !8}

!0 = distinct !DICompileUnit(language: DW_LANG_C, file: !3, producer: "Me", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: null, retainedTypes: null, imports: null)
!1 = !DILocalVariable(name: "", arg: 1, scope: !2, file: null, line: 1, type: null)
!2 = distinct !DISubprogram(name: "debug", linkageName: "debug", scope: null, file: null, line: 0, type: null, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: true, unit: !0)
!3 = !DIFile(filename: "consecutive-fences.ll", directory: "")
!5 = !{i32 2, !"Dwarf Version", i32 4}
!6 = !{i32 2, !"Debug Info Version", i32 3}
!7 = !{i32 1, !"wchar_size", i32 4}
!8 = !{i32 7, !"PIC Level", i32 2}
!9 = !DILocation(line: 0, column: 0, scope: !2)


attributes #0 = { nounwind uwtable }
attributes #1 = { nounwind }

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; BUNDLES-DL: {{.*}}
; DEFAULT-DL: {{.*}}
