; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; Checks that the return value is 0.

; `%i8` can be folded to -1, so `%arg1` can be folded to undef.
; First, we can try to expand `%i13 = and i8 %i9, %i12` to `%i13 = L1(%arg1(undef) and %i12) or (-1 and %i12)`.
; Then, we can try to expand `L1(%arg1(undef) and %i12)` to `(%arg1(undef) and %i7) xor (%arg1(undef) and -1)`.
; However, for `%arg1(undef) and %i7`, `%arg1(undef)` is folded to 0, while for `%arg1(undef) and -1`, it cannot be folded to undef.

define i8 @foo(i1 %arg, i8 %arg1) {
; CHECK-LABEL: define i8 @foo(
; CHECK-SAME: i1 [[ARG:%.*]], i8 [[ARG1:%.*]]) {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    br label %[[BB2:.*]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    br i1 true, label %[[BB15:.*]], label %[[BB2]]
; CHECK:       [[BB15]]:
; CHECK-NEXT:    ret i8 0
;
bb:
  br label %bb2

bb2:
  %i = phi i8 [ -128, %bb ], [ %arg1, %bb2 ] ; #x80 (128, -128)
  %i3 = phi i8 [ 0, %bb ], [ 1, %bb2 ] ; #x00 (0)
  %i4 = phi i8 [ 1, %bb ], [ %arg1, %bb2 ] ; #x01 (1)
  %i5 = xor i8 %i3, 1 ; #x01 (1)
  %i6 = ashr i8 %i4, %i5 ; #x00 (0)
  %i7 = and i8 %i, -128 ; #x80 (128, -128)
  %i8 = xor i8 %i6, -1 ; #xff (255, -1)
  %i9 = or i8 %i8, %arg1 ; #xff (255, -1)
  %i10 = and i8 %i8, 7 ; #x07 (7)
  %i11 = shl i8 %i9, %i10 ; #x80 (128, -128)
  %i12 = xor i8 %i7, -1 ; #x7f (127)
  %i13 = and i8 %i9, %i12 ; #x7f (127) ; Cannot be -1.
  %i14 = or i1 %arg, true ; #x1 (1)
  br i1 %i14, label %bb15, label %bb2

bb15:
  %i16 = and i8 %i13, %i11 ; #x00 (0)
  ret i8 %i16
}
