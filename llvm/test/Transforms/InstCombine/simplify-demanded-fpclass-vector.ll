; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

declare <2 x float> @extern_vec()
declare <2 x float> @extern_vec_func(<2 x float>)
; can't fold to fneg(fabs(x))
define nofpclass(pinf pnorm psub pzero) <2 x float> @ret_nofpclass_nopositives_copysign_vec(<2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(pinf pzero psub pnorm) <2 x float> @ret_nofpclass_nopositives_copysign_vec(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call <2 x float> @llvm.copysign.v2f32(<2 x float> [[X]], <2 x float> [[UNKNOWN_SIGN]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %x, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; can fold to fneg(fabs(x))
define nofpclass(pinf pnorm psub pzero) <2 x float> @ret_nofpclass_nopositives_copysign_nnan_flag_vec(<2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(pinf pzero psub pnorm) <2 x float> @ret_nofpclass_nopositives_copysign_nnan_flag_vec(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call nnan <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    [[COPYSIGN:%.*]] = fneg nnan <2 x float> [[TMP1]]
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %copysign = call nnan <2 x float> @llvm.copysign.v2f32(<2 x float> %x, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; can fold to fneg(fabs(x)), finitely-bounded no-positives variant
define nofpclass(pnorm psub pzero) <2 x float> @ret_nofpclass_nopositive_finites_copysign_nnan_ninf_flag_vec(<2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(pzero psub pnorm) <2 x float> @ret_nofpclass_nopositive_finites_copysign_nnan_ninf_flag_vec(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call nnan ninf <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    [[COPYSIGN:%.*]] = fneg nnan ninf <2 x float> [[TMP1]]
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %copysign = call nnan ninf <2 x float> @llvm.copysign.v2f32(<2 x float> %x, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; can't fold to fneg(fabs(x)) (nonan variant)
define nofpclass(nan pinf pnorm psub pzero) <2 x float> @ret_nofpclass_nopositives_nonan_copysign_vec(<2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(nan pinf pzero psub pnorm) <2 x float> @ret_nofpclass_nopositives_nonan_copysign_vec(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    [[COPYSIGN:%.*]] = fneg <2 x float> [[TMP1]]
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %x, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; can't fold to fabs(x)
define nofpclass(ninf nnorm nsub nzero) <2 x float> @ret_nofpclass_nonegatives_copysign_vec(<2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(ninf nzero nsub nnorm) <2 x float> @ret_nofpclass_nonegatives_copysign_vec(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call <2 x float> @llvm.copysign.v2f32(<2 x float> [[X]], <2 x float> [[UNKNOWN_SIGN]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %x, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; can fold to fabs(x)
define nofpclass(ninf nnorm nsub nzero) <2 x float> @ret_nofpclass_nonegatives_copysign_nnan_flag_vec(<2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(ninf nzero nsub nnorm) <2 x float> @ret_nofpclass_nonegatives_copysign_nnan_flag_vec(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call nnan <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %copysign = call nnan <2 x float> @llvm.copysign.v2f32(<2 x float> %x, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; can fold to fabs(x) (nonan variant)
define nofpclass(nan ninf nnorm nsub nzero) <2 x float> @ret_nofpclass_nonegatives_nonan_copysign_vec(<2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(nan ninf nzero nsub nnorm) <2 x float> @ret_nofpclass_nonegatives_nonan_copysign_vec(
; CHECK-SAME: <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %x, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; nopositives + fabs(sign) + select pinf: can fold to fabs(x)
define nofpclass(pinf pnorm psub pzero) <2 x float> @ret_nofpclass_nopositives__copysign_fabs_select_pinf_rhs_vec(<2 x i1> %cond, <2 x float> %x, <2 x float> %sign) {
; CHECK-LABEL: define nofpclass(pinf pzero psub pnorm) <2 x float> @ret_nofpclass_nopositives__copysign_fabs_select_pinf_rhs_vec(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[X:%.*]], <2 x float> [[SIGN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    ret <2 x float> [[TMP1]]
;
  %select = select <2 x i1> %cond,
  <2 x float> %x,
  <2 x float> <float 0x7FF0000000000000, float 0x7FF0000000000000>
  %fabs.sign = call <2 x float> @llvm.fabs.v2f32(<2 x float> %sign)
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %select, <2 x float> %fabs.sign)
  ret <2 x float> %copysign
}

; no negatives, no inf: can fold to copysign(x, unknown.sign)
define nofpclass(inf nnorm nsub nzero) <2 x float> @ret_nofpclass_no_negatives_noinf__copysign_unknown_select_pinf_rhs_vec(<2 x i1> %cond, <2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(inf nzero nsub nnorm) <2 x float> @ret_nofpclass_no_negatives_noinf__copysign_unknown_select_pinf_rhs_vec(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call <2 x float> @llvm.copysign.v2f32(<2 x float> [[X]], <2 x float> [[UNKNOWN_SIGN]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %select = select <2 x i1> %cond,
  <2 x float> %x,
  <2 x float> <float 0x7FF0000000000000, float 0x7FF0000000000000>
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %select, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; no positives, no inf: can fold to copysign(x, unknown.sign)
define nofpclass(inf pnorm psub pzero) <2 x float> @ret_nofpclass_no_positives_noinf__copysign_unknown_select_pinf_rhs_vec(<2 x i1> %cond, <2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(inf pzero psub pnorm) <2 x float> @ret_nofpclass_no_positives_noinf__copysign_unknown_select_pinf_rhs_vec(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call <2 x float> @llvm.copysign.v2f32(<2 x float> [[X]], <2 x float> [[UNKNOWN_SIGN]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %select = select <2 x i1> %cond,
  <2 x float> %x,
  <2 x float> <float 0x7FF0000000000000, float 0x7FF0000000000000>
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %select, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; Can't fold because it could have nan payload bits (no negatives case)
define nofpclass(ninf nnorm nsub nzero) <2 x float> @ret_nofpclass_no_negatives__copysign_unknown_select_pinf_rhs_vec(<2 x i1> %cond, <2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(ninf nzero nsub nnorm) <2 x float> @ret_nofpclass_no_negatives__copysign_unknown_select_pinf_rhs_vec(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[SELECT:%.*]] = select <2 x i1> [[COND]], <2 x float> [[X]], <2 x float> splat (float 0x7FF0000000000000)
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call <2 x float> @llvm.copysign.v2f32(<2 x float> [[SELECT]], <2 x float> [[UNKNOWN_SIGN]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %select = select <2 x i1> %cond,
  <2 x float> %x,
  <2 x float> <float 0x7FF0000000000000, float 0x7FF0000000000000>
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %select, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; Can't fold because it could be nan (no positives case)
define nofpclass(pinf pnorm psub pzero) <2 x float> @ret_nofpclass_no_positives__copysign_unknown_select_pinf_rhs_vec(<2 x i1> %cond, <2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(pinf pzero psub pnorm) <2 x float> @ret_nofpclass_no_positives__copysign_unknown_select_pinf_rhs_vec(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[SELECT:%.*]] = select <2 x i1> [[COND]], <2 x float> [[X]], <2 x float> splat (float 0x7FF0000000000000)
; CHECK-NEXT:    [[COPYSIGN:%.*]] = call <2 x float> @llvm.copysign.v2f32(<2 x float> [[SELECT]], <2 x float> [[UNKNOWN_SIGN]])
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %select = select <2 x i1> %cond,
  <2 x float> %x,
  <2 x float> <float 0x7FF0000000000000, float 0x7FF0000000000000>
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %select, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; Could fold to copysign with constant (no negatives, nonan)
define nofpclass(nan ninf nnorm nsub nzero) <2 x float> @ret_nofpclass_no_negatives_nonan__copysign_unknown_select_pinf_rhs_vec(<2 x i1> %cond, <2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(nan ninf nzero nsub nnorm) <2 x float> @ret_nofpclass_no_negatives_nonan__copysign_unknown_select_pinf_rhs_vec(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    [[COPYSIGN:%.*]] = select <2 x i1> [[COND]], <2 x float> [[TMP1]], <2 x float> splat (float 0x7FF0000000000000)
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %select = select <2 x i1> %cond,
  <2 x float> %x,
  <2 x float> <float 0x7FF0000000000000, float 0x7FF0000000000000>
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %select, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; Could fold to copysign(x) with constant (no positives, nonan)
define nofpclass(nan pinf pnorm psub pzero) <2 x float> @ret_nofpclass_no_positives_nonan__copysign_unknown_select_pinf_rhs_vec(<2 x i1> %cond, <2 x float> %x, <2 x float> %unknown.sign) {
; CHECK-LABEL: define nofpclass(nan pinf pzero psub pnorm) <2 x float> @ret_nofpclass_no_positives_nonan__copysign_unknown_select_pinf_rhs_vec(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[X:%.*]], <2 x float> [[UNKNOWN_SIGN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.fabs.v2f32(<2 x float> [[X]])
; CHECK-NEXT:    [[DOTNEG:%.*]] = fneg <2 x float> [[TMP1]]
; CHECK-NEXT:    [[COPYSIGN:%.*]] = select <2 x i1> [[COND]], <2 x float> [[DOTNEG]], <2 x float> splat (float 0xFFF0000000000000)
; CHECK-NEXT:    ret <2 x float> [[COPYSIGN]]
;
  %select = select <2 x i1> %cond,
  <2 x float> %x,
  <2 x float> <float 0x7FF0000000000000, float 0x7FF0000000000000>
  %copysign = call <2 x float> @llvm.copysign.v2f32(<2 x float> %select, <2 x float> %unknown.sign)
  ret <2 x float> %copysign
}

; should fold to -inf splat
define nofpclass(pinf) <2 x float> @vec_ret_nofpclass_pinf__nofpclass_call_only_inf(<2 x i1> %cond, <2 x float> %y) {
; CHECK-LABEL: define nofpclass(pinf) <2 x float> @vec_ret_nofpclass_pinf__nofpclass_call_only_inf(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[MUST_BE_INF:%.*]] = call nofpclass(nan zero sub norm) <2 x float> @extern_vec()
; CHECK-NEXT:    ret <2 x float> splat (float 0xFFF0000000000000)
;
entry:
  %must.be.inf = call nofpclass(nan zero sub norm) <2 x float> @extern_vec()
  ret <2 x float> %must.be.inf
}

; should fold to +inf splat
define nofpclass(ninf) <2 x float> @vec_ret_nofpclass_ninf__nofpclass_call_only_inf(<2 x i1> %cond, <2 x float> %y) {
; CHECK-LABEL: define nofpclass(ninf) <2 x float> @vec_ret_nofpclass_ninf__nofpclass_call_only_inf(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[MUST_BE_INF:%.*]] = call nofpclass(nan zero sub norm) <2 x float> @extern_vec()
; CHECK-NEXT:    ret <2 x float> splat (float 0x7FF0000000000000)
;
entry:
  %must.be.inf = call nofpclass(nan zero sub norm) <2 x float> @extern_vec()
  ret <2 x float> %must.be.inf
}

; should fold to +0 splat
define nofpclass(nzero) <2 x float> @vec_ret_nofpclass_nzero__nofpclass_call_only_zero(<2 x i1> %cond, <2 x float> %y) {
; CHECK-LABEL: define nofpclass(nzero) <2 x float> @vec_ret_nofpclass_nzero__nofpclass_call_only_zero(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[MUST_BE_ZERO:%.*]] = call nofpclass(nan inf sub norm) <2 x float> @extern_vec()
; CHECK-NEXT:    ret <2 x float> zeroinitializer
;
entry:
  %must.be.zero = call nofpclass(nan inf sub norm) <2 x float> @extern_vec()
  ret <2 x float> %must.be.zero
}

; should fold to -0 splat
define nofpclass(pzero) <2 x float> @vec_ret_nofpclass_pzero__nofpclass_call_only_zero(<2 x i1> %cond, <2 x float> %y) {
; CHECK-LABEL: define nofpclass(pzero) <2 x float> @vec_ret_nofpclass_pzero__nofpclass_call_only_zero(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[MUST_BE_ZERO:%.*]] = call nofpclass(nan inf sub norm) <2 x float> @extern_vec()
; CHECK-NEXT:    ret <2 x float> splat (float -0.000000e+00)
;
entry:
  %must.be.zero = call nofpclass(nan inf sub norm) <2 x float> @extern_vec()
  ret <2 x float> %must.be.zero
}

; should keep payloads, not canonicalize
define nofpclass(qnan) <2 x float> @vec_ret_nofpclass_qnan__nofpclass_call_only_nan(<2 x i1> %cond, <2 x float> %y) {
; CHECK-LABEL: define nofpclass(qnan) <2 x float> @vec_ret_nofpclass_qnan__nofpclass_call_only_nan(
; CHECK-SAME: <2 x i1> [[COND:%.*]], <2 x float> [[Y:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[MUST_BE_NAN:%.*]] = call nofpclass(inf zero sub norm) <2 x float> @extern_vec()
; CHECK-NEXT:    ret <2 x float> [[MUST_BE_NAN]]
;
entry:
  %must.be.nan = call nofpclass(inf zero sub norm) <2 x float> @extern_vec()
  ret <2 x float> %must.be.nan
}


