; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

;   load(addrspacecast(select(A, B))) --> select(load(addrspacecast(A)), load(addrspacecast(B)))

define i32 @load_addrspacecast_select_alloca(i1 %cond) !prof !0 {
; CHECK-LABEL: @load_addrspacecast_select_alloca(
; CHECK-NEXT:    [[RESULT:%.*]] = select i1 [[COND:%.*]], i32 42, i32 100, !prof [[PROF1:![0-9]+]]
; CHECK-NEXT:    ret i32 [[RESULT]]
;
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store i32 42, ptr %a, align 4
  store i32 100, ptr %b, align 4
  %sel = select i1 %cond, ptr %a, ptr %b, !prof !1
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load i32, ptr addrspace(5) %cast, align 4
  ret i32 %load
}

define <2 x i32> @load_addrspacecast_select_alloca_vec(i1 %cond) {
; CHECK-LABEL: @load_addrspacecast_select_alloca_vec(
; CHECK-NEXT:    [[RESULT:%.*]] = select i1 [[COND:%.*]], <2 x i32> <i32 42, i32 43>, <2 x i32> <i32 100, i32 101>
; CHECK-NEXT:    ret <2 x i32> [[RESULT]]
;
  %a = alloca <2 x i32>, align 8
  %b = alloca <2 x i32>, align 8
  store <2 x i32> <i32 42, i32 43>, ptr %a, align 8
  store <2 x i32> <i32 100, i32 101>, ptr %b, align 8
  %sel = select i1 %cond, ptr %a, ptr %b
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load <2 x i32>, ptr addrspace(5) %cast, align 8
  ret <2 x i32> %load
}

; Negative tests:


define i32 @load_addrspacecast_select_multi_use(i1 %cond, ptr %out) {
; CHECK-LABEL: @load_addrspacecast_select_multi_use(
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 42, ptr [[A]], align 4
; CHECK-NEXT:    store i32 100, ptr [[B]], align 4
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND:%.*]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[CAST:%.*]] = addrspacecast ptr [[SEL]] to ptr addrspace(5)
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr addrspace(5) [[CAST]], align 4
; CHECK-NEXT:    store ptr [[SEL]], ptr [[OUT:%.*]], align 8
; CHECK-NEXT:    ret i32 [[LOAD]]
;
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store i32 42, ptr %a, align 4
  store i32 100, ptr %b, align 4
  %sel = select i1 %cond, ptr %a, ptr %b
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load i32, ptr addrspace(5) %cast, align 4
  ; Extra use of the select prevents transformation
  store ptr %sel, ptr %out, align 8
  ret i32 %load
}

define i32 @load_addrspacecast_multi_use(i1 %cond, ptr addrspace(5) %out) {
; CHECK-LABEL: @load_addrspacecast_multi_use(
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 42, ptr [[A]], align 4
; CHECK-NEXT:    store i32 100, ptr [[B]], align 4
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND:%.*]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[CAST:%.*]] = addrspacecast ptr [[SEL]] to ptr addrspace(5)
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr addrspace(5) [[CAST]], align 4
; CHECK-NEXT:    store ptr addrspace(5) [[CAST]], ptr addrspace(5) [[OUT:%.*]], align 8
; CHECK-NEXT:    ret i32 [[LOAD]]
;
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store i32 42, ptr %a, align 4
  store i32 100, ptr %b, align 4
  %sel = select i1 %cond, ptr %a, ptr %b
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load i32, ptr addrspace(5) %cast, align 4
  ; Extra use of the cast prevents transformation
  store ptr addrspace(5) %cast, ptr addrspace(5) %out, align 8
  ret i32 %load
}

define i32 @load_addrspacecast_select_on_args(i1 %cond, ptr %a, ptr %b) {
; CHECK-LABEL: @load_addrspacecast_select_on_args(
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND:%.*]], ptr [[A:%.*]], ptr [[B:%.*]]
; CHECK-NEXT:    [[CAST:%.*]] = addrspacecast ptr [[SEL]] to ptr addrspace(5)
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr addrspace(5) [[CAST]], align 4
; CHECK-NEXT:    ret i32 [[LOAD]]
;
  %sel = select i1 %cond, ptr %a, ptr %b
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load i32, ptr addrspace(5) %cast, align 4
  ret i32 %load
}

; dereferenceable is not enough to trigger the transformation
define i32 @load_addrspacecast_select_on_args_dereferenceable(i1 %cond, ptr dereferenceable(4) %a, ptr dereferenceable(4) %b) {
; CHECK-LABEL: @load_addrspacecast_select_on_args_dereferenceable(
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND:%.*]], ptr [[A:%.*]], ptr [[B:%.*]]
; CHECK-NEXT:    [[CAST:%.*]] = addrspacecast ptr [[SEL]] to ptr addrspace(5)
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr addrspace(5) [[CAST]], align 4
; CHECK-NEXT:    ret i32 [[LOAD]]
;
  %sel = select i1 %cond, ptr %a, ptr %b
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load i32, ptr addrspace(5) %cast, align 4
  ret i32 %load
}

define i32 @load_addrspacecast_select_volatile(i1 %cond) {
; CHECK-LABEL: @load_addrspacecast_select_volatile(
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 42, ptr [[A]], align 4
; CHECK-NEXT:    store i32 100, ptr [[B]], align 4
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND:%.*]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[CAST:%.*]] = addrspacecast ptr [[SEL]] to ptr addrspace(5)
; CHECK-NEXT:    [[LOAD:%.*]] = load volatile i32, ptr addrspace(5) [[CAST]], align 4
; CHECK-NEXT:    ret i32 [[LOAD]]
;
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store i32 42, ptr %a, align 4
  store i32 100, ptr %b, align 4
  %sel = select i1 %cond, ptr %a, ptr %b
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load volatile i32, ptr addrspace(5) %cast, align 4
  ret i32 %load
}

define i32 @load_addrspacecast_select_atomic(i1 %cond) {
; CHECK-LABEL: @load_addrspacecast_select_atomic(
; CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 42, ptr [[A]], align 4
; CHECK-NEXT:    store i32 100, ptr [[B]], align 4
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND:%.*]], ptr [[A]], ptr [[B]]
; CHECK-NEXT:    [[CAST:%.*]] = addrspacecast ptr [[SEL]] to ptr addrspace(5)
; CHECK-NEXT:    [[LOAD:%.*]] = load atomic i32, ptr addrspace(5) [[CAST]] seq_cst, align 4
; CHECK-NEXT:    ret i32 [[LOAD]]
;
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store i32 42, ptr %a, align 4
  store i32 100, ptr %b, align 4
  %sel = select i1 %cond, ptr %a, ptr %b
  %cast = addrspacecast ptr %sel to ptr addrspace(5)
  %load = load atomic i32, ptr addrspace(5) %cast seq_cst, align 4
  ret i32 %load
}

!0 = !{!"function_entry_count", i64 1000}
!1 = !{!"branch_weights", i32 2, i32 3}
;.
; CHECK: [[META0:![0-9]+]] = !{!"function_entry_count", i64 1000}
; CHECK: [[PROF1]] = !{!"branch_weights", i32 2, i32 3}
;.
