; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; Basic test cases
define i1 @icmp_eq(i1 %x, i1 %y) {
; CHECK-LABEL: define i1 @icmp_eq(
; CHECK-SAME: i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = xor i1 [[Y]], true
; CHECK-NEXT:    [[RESULT:%.*]] = and i1 [[X]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i1 %x to i32
  %y.ext = zext i1 %y to i32
  %shl = shl i32 %x.ext, %y.ext
  %result = icmp eq i32 %shl, 1
  ret i1 %result
}

define i1 @icmp_ne(i1 %x, i1 %y) {
; CHECK-LABEL: define i1 @icmp_ne(
; CHECK-SAME: i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = xor i1 [[X]], true
; CHECK-NEXT:    [[RESULT:%.*]] = or i1 [[Y]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i1 %x to i32
  %y.ext = zext i1 %y to i32
  %shl = shl i32 %x.ext, %y.ext
  %result = icmp ne i32 %shl, 1
  ret i1 %result
}

define i1 @icmp_eq_comm(i1 %x, i1 %y) {
; CHECK-LABEL: define i1 @icmp_eq_comm(
; CHECK-SAME: i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = xor i1 [[Y]], true
; CHECK-NEXT:    [[RESULT:%.*]] = and i1 [[X]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i1 %x to i32
  %y.ext = zext i1 %y to i32
  %shl = shl i32 %x.ext, %y.ext
  %result = icmp eq i32 1, %shl
  ret i1 %result
}

define i1 @icmp_ne_comm(i1 %x, i1 %y) {
; CHECK-LABEL: define i1 @icmp_ne_comm(
; CHECK-SAME: i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = xor i1 [[X]], true
; CHECK-NEXT:    [[RESULT:%.*]] = or i1 [[Y]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i1 %x to i32
  %y.ext = zext i1 %y to i32
  %shl = shl i32 %x.ext, %y.ext
  %result = icmp ne i32 1, %shl
  ret i1 %result
}

; Different zext target bit width
define i1 @icmp_eq_64(i1 %x, i1 %y) {
; CHECK-LABEL: define i1 @icmp_eq_64(
; CHECK-SAME: i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = xor i1 [[Y]], true
; CHECK-NEXT:    [[RESULT:%.*]] = and i1 [[X]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i1 %x to i64
  %y.ext = zext i1 %y to i64
  %shl = shl i64 %x.ext, %y.ext
  %result = icmp eq i64 %shl, 1
  ret i1 %result
}

define i1 @icmp_ne_64(i1 %x, i1 %y) {
; CHECK-LABEL: define i1 @icmp_ne_64(
; CHECK-SAME: i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = xor i1 [[X]], true
; CHECK-NEXT:    [[RESULT:%.*]] = or i1 [[Y]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i1 %x to i64
  %y.ext = zext i1 %y to i64
  %shl = shl i64 %x.ext, %y.ext
  %result = icmp ne i64 %shl, 1
  ret i1 %result
}

; Negative test: Comparing against 3, not 1
define i1 @icmp_eq_zero_negative(i1 %x, i1 %y) {
; CHECK-LABEL: define i1 @icmp_eq_zero_negative(
; CHECK-SAME: i1 [[X:%.*]], i1 [[Y:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = zext i1 [[X]] to i32
; CHECK-NEXT:    [[Y_EXT:%.*]] = zext i1 [[Y]] to i32
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw i32 [[X_EXT]], [[Y_EXT]]
; CHECK-NEXT:    [[RESULT:%.*]] = icmp eq i32 [[SHL]], 3
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i1 %x to i32
  %y.ext = zext i1 %y to i32
  %shl = shl i32 %x.ext, %y.ext
  %result = icmp eq i32 %shl, 3
  ret i1 %result
}

; Negative test: Non-i1 source type
define i1 @icmp_eq_non_i1_negative(i8 %x, i8 %y) {
; CHECK-LABEL: define i1 @icmp_eq_non_i1_negative(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[X_EXT:%.*]] = zext i8 [[X]] to i32
; CHECK-NEXT:    [[Y_EXT:%.*]] = zext nneg i8 [[Y]] to i32
; CHECK-NEXT:    [[SHL:%.*]] = shl i32 [[X_EXT]], [[Y_EXT]]
; CHECK-NEXT:    [[RESULT:%.*]] = icmp eq i32 [[SHL]], 1
; CHECK-NEXT:    ret i1 [[RESULT]]
;
  %x.ext = zext i8 %x to i32
  %y.ext = zext i8 %y to i32
  %shl = shl i32 %x.ext, %y.ext
  %result = icmp eq i32 %shl, 1
  ret i1 %result
}
