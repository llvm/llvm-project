; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

; --------------------------------------------------------------------
; llvm.is.fpclass
; --------------------------------------------------------------------

; FIXME: Should this really be immarg?
; define i1 @test_class_undef_mask_f32(float %x) {
;   %val = call i1 @llvm.is.fpclass.f32(float %x, i32 undef)
;   ret i1 %val
; }

define i1 @test_class_over_max_mask_f32(float %x) {
; CHECK-LABEL: @test_class_over_max_mask_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 1025)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float %x, i32 1025)
  ret i1 %val
}

define i1 @test_class_no_mask_f32(float %x) {
; CHECK-LABEL: @test_class_no_mask_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 0)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float %x, i32 0)
  ret i1 %val
}

define i1 @test_class_full_mask_f32(float %x) {
; CHECK-LABEL: @test_class_full_mask_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 1023)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float %x, i32 1023)
  ret i1 %val
}

define i1 @test_class_undef_no_mask_f32() {
; CHECK-LABEL: @test_class_undef_no_mask_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float undef, i32 0)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float undef, i32 0)
  ret i1 %val
}

define i1 @test_class_undef_full_mask_f32() {
; CHECK-LABEL: @test_class_undef_full_mask_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float undef, i32 1023)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float undef, i32 1023)
  ret i1 %val
}

define i1 @test_class_poison_no_mask_f32() {
; CHECK-LABEL: @test_class_poison_no_mask_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float poison, i32 0)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float poison, i32 0)
  ret i1 %val
}

define i1 @test_class_poison_full_mask_f32() {
; CHECK-LABEL: @test_class_poison_full_mask_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float poison, i32 1023)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float poison, i32 1023)
  ret i1 %val
}

define i1 @test_class_undef_val_f32() {
; CHECK-LABEL: @test_class_undef_val_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float undef, i32 4)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float undef, i32 4)
  ret i1 %val
}

define i1 @test_class_poison_val_f32() {
; CHECK-LABEL: @test_class_poison_val_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float poison, i32 4)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float poison, i32 4)
  ret i1 %val
}

; FIXME: Should this really be immarg?
; define i1 @test_class_undef_undef_f32() {
;   %val = call i1 @llvm.is.fpclass.f32(float undef, i32 undef)
;   ret i1 %val
; }

; FIXME: Should this really be immarg?
; define i1 @test_class_var_mask_f32(float %x, i32 %mask) {
;   %val = call i1 @llvm.is.fpclass.f32(float %x, i32 %mask)
;   ret i1 %val
; }

define i1 @test_class_isnan_f32(float %x) {
; CHECK-LABEL: @test_class_isnan_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 3)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float %x, i32 3)
  ret i1 %val
}

define i1 @test_class_isnan_f32_strict(float %x) {
; CHECK-LABEL: @test_class_isnan_f32_strict(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 3) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float %x, i32 3) strictfp
  ret i1 %val
}

define i1 @test_class_is_p0_n0_f32(float %x) {
; CHECK-LABEL: @test_class_is_p0_n0_f32(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 96)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float %x, i32 96)
  ret i1 %val
}

define i1 @test_class_is_p0_n0_f32_strict(float %x) {
; CHECK-LABEL: @test_class_is_p0_n0_f32_strict(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 96) #[[ATTR1]]
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f32(float %x, i32 96) strictfp
  ret i1 %val
}

define i1 @test_constant_class_snan_test_snan_f64() {
; CHECK-LABEL: @test_constant_class_snan_test_snan_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000001, i32 1)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000001, i32 1)
  ret i1 %val
}

define i1 @test_constant_class_qnan_test_qnan_f64() {
; CHECK-LABEL: @test_constant_class_qnan_test_qnan_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 2)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 2)
  ret i1 %val
}

define i1 @test_constant_class_qnan_test_snan_f64() {
; CHECK-LABEL: @test_constant_class_qnan_test_snan_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 1)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 1)
  ret i1 %val
}

define i1 @test_constant_class_ninf_test_ninf_f64() {
; CHECK-LABEL: @test_constant_class_ninf_test_ninf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0xFFF0000000000000, i32 4)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0xFFF0000000000000, i32 4)
  ret i1 %val
}

define i1 @test_constant_class_pinf_test_ninf_f64() {
; CHECK-LABEL: @test_constant_class_pinf_test_ninf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000000, i32 4)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000000, i32 4)
  ret i1 %val
}

define i1 @test_constant_class_qnan_test_ninf_f64() {
; CHECK-LABEL: @test_constant_class_qnan_test_ninf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 4)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 4)
  ret i1 %val
}

define i1 @test_constant_class_snan_test_ninf_f64() {
; CHECK-LABEL: @test_constant_class_snan_test_ninf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000001, i32 4)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000001, i32 4)
  ret i1 %val
}

define i1 @test_constant_class_nnormal_test_nnormal_f64() {
; CHECK-LABEL: @test_constant_class_nnormal_test_nnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double -1.000000e+00, i32 8)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double -1.0, i32 8)
  ret i1 %val
}

define i1 @test_constant_class_pnormal_test_nnormal_f64() {
; CHECK-LABEL: @test_constant_class_pnormal_test_nnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 1.000000e+00, i32 8)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 1.0, i32 8)
  ret i1 %val
}

define i1 @test_constant_class_nsubnormal_test_nsubnormal_f64() {
; CHECK-LABEL: @test_constant_class_nsubnormal_test_nsubnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x800FFFFFFFFFFFFF, i32 16)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x800fffffffffffff, i32 16)
  ret i1 %val
}

define i1 @test_constant_class_psubnormal_test_nsubnormal_f64() {
; CHECK-LABEL: @test_constant_class_psubnormal_test_nsubnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0xFFFFFFFFFFFFF, i32 16)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x000fffffffffffff, i32 16)
  ret i1 %val
}

define i1 @test_constant_class_nzero_test_nzero_f64() {
; CHECK-LABEL: @test_constant_class_nzero_test_nzero_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double -0.000000e+00, i32 32)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double -0.0, i32 32)
  ret i1 %val
}

define i1 @test_constant_class_pzero_test_nzero_f64() {
; CHECK-LABEL: @test_constant_class_pzero_test_nzero_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0.000000e+00, i32 32)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0.0, i32 32)
  ret i1 %val
}

define i1 @test_constant_class_pzero_test_pzero_f64() {
; CHECK-LABEL: @test_constant_class_pzero_test_pzero_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0.000000e+00, i32 64)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0.0, i32 64)
  ret i1 %val
}

define i1 @test_constant_class_nzero_test_pzero_f64() {
; CHECK-LABEL: @test_constant_class_nzero_test_pzero_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double -0.000000e+00, i32 64)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double -0.0, i32 64)
  ret i1 %val
}

define i1 @test_constant_class_psubnormal_test_psubnormal_f64() {
; CHECK-LABEL: @test_constant_class_psubnormal_test_psubnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0xFFFFFFFFFFFFF, i32 128)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x000fffffffffffff, i32 128)
  ret i1 %val
}

define i1 @test_constant_class_nsubnormal_test_psubnormal_f64() {
; CHECK-LABEL: @test_constant_class_nsubnormal_test_psubnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x800FFFFFFFFFFFFF, i32 128)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x800fffffffffffff, i32 128)
  ret i1 %val
}

define i1 @test_constant_class_pnormal_test_pnormal_f64() {
; CHECK-LABEL: @test_constant_class_pnormal_test_pnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 1.000000e+00, i32 256)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 1.0, i32 256)
  ret i1 %val
}

define i1 @test_constant_class_nnormal_test_pnormal_f64() {
; CHECK-LABEL: @test_constant_class_nnormal_test_pnormal_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double -1.000000e+00, i32 256)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double -1.0, i32 256)
  ret i1 %val
}

define i1 @test_constant_class_pinf_test_pinf_f64() {
; CHECK-LABEL: @test_constant_class_pinf_test_pinf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000000, i32 512)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000000, i32 512)
  ret i1 %val
}

define i1 @test_constant_class_ninf_test_pinf_f64() {
; CHECK-LABEL: @test_constant_class_ninf_test_pinf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0xFFF0000000000000, i32 512)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0xFFF0000000000000, i32 512)
  ret i1 %val
}

define i1 @test_constant_class_qnan_test_pinf_f64() {
; CHECK-LABEL: @test_constant_class_qnan_test_pinf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 512)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF8000000000000, i32 512)
  ret i1 %val
}

define i1 @test_constant_class_snan_test_pinf_f64() {
; CHECK-LABEL: @test_constant_class_snan_test_pinf_f64(
; CHECK-NEXT:    [[VAL:%.*]] = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000001, i32 512)
; CHECK-NEXT:    ret i1 [[VAL]]
;
  %val = call i1 @llvm.is.fpclass.f64(double 0x7FF0000000000001, i32 512)
  ret i1 %val
}

define i1 @test_class_is_snan_nnan_src(float %x) {
; CHECK-LABEL: @test_class_is_snan_nnan_src(
; CHECK-NEXT:    [[NNAN:%.*]] = fadd nnan float [[X:%.*]], 1.000000e+00
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[NNAN]], i32 1)
; CHECK-NEXT:    ret i1 [[CLASS]]
;
  %nnan = fadd nnan float %x, 1.0
  %class = call i1 @llvm.is.fpclass.f32(float %nnan, i32 1)
  ret i1 %class
}

define i1 @test_class_is_qnan_nnan_src(float %x) {
; CHECK-LABEL: @test_class_is_qnan_nnan_src(
; CHECK-NEXT:    [[NNAN:%.*]] = fadd nnan float [[X:%.*]], 1.000000e+00
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[NNAN]], i32 2)
; CHECK-NEXT:    ret i1 [[CLASS]]
;
  %nnan = fadd nnan float %x, 1.0
  %class = call i1 @llvm.is.fpclass.f32(float %nnan, i32 2)
  ret i1 %class
}

define i1 @test_class_is_nan_nnan_src(float %x) {
; CHECK-LABEL: @test_class_is_nan_nnan_src(
; CHECK-NEXT:    [[NNAN:%.*]] = fadd nnan float [[X:%.*]], 1.000000e+00
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[NNAN]], i32 3)
; CHECK-NEXT:    ret i1 [[CLASS]]
;
  %nnan = fadd nnan float %x, 1.0
  %class = call i1 @llvm.is.fpclass.f32(float %nnan, i32 3)
  ret i1 %class
}

define i1 @test_class_is_nan_other_nnan_src(float %x) {
; CHECK-LABEL: @test_class_is_nan_other_nnan_src(
; CHECK-NEXT:    [[NNAN:%.*]] = fadd nnan float [[X:%.*]], 1.000000e+00
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[NNAN]], i32 267)
; CHECK-NEXT:    ret i1 [[CLASS]]
;
  %nnan = fadd nnan float %x, 1.0
  %class = call i1 @llvm.is.fpclass.f32(float %nnan, i32 267)
  ret i1 %class
}

; --------------------------------------------------------------------
; Negation of llvm.is.fpclass
; --------------------------------------------------------------------

define i1 @test_class_not_is_nan(float %x) {
; CHECK-LABEL: @test_class_not_is_nan(
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 3)
; CHECK-NEXT:    [[NOT:%.*]] = xor i1 [[CLASS]], true
; CHECK-NEXT:    ret i1 [[NOT]]
;
  %class = call i1 @llvm.is.fpclass.f32(float %x, i32 3)
  %not = xor i1 %class, true
  ret i1 %not
}

define i1 @test_class_not_is_nan_multi_use(float %x, ptr %ptr) {
; CHECK-LABEL: @test_class_not_is_nan_multi_use(
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 3)
; CHECK-NEXT:    store i1 [[CLASS]], ptr [[PTR:%.*]], align 1
; CHECK-NEXT:    [[NOT:%.*]] = xor i1 [[CLASS]], true
; CHECK-NEXT:    ret i1 [[NOT]]
;
  %class = call i1 @llvm.is.fpclass.f32(float %x, i32 3)
  store i1 %class, ptr %ptr
  %not = xor i1 %class, true
  ret i1 %not
}

define i1 @test_class_not_is_inf_nan(float %x) {
; CHECK-LABEL: @test_class_not_is_inf_nan(
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 519)
; CHECK-NEXT:    [[NOT:%.*]] = xor i1 [[CLASS]], true
; CHECK-NEXT:    ret i1 [[NOT]]
;
  %class = call i1 @llvm.is.fpclass.f32(float %x, i32 519)
  %not = xor i1 %class, true
  ret i1 %not
}

define i1 @test_class_not_is_normal(float %x) {
; CHECK-LABEL: @test_class_not_is_normal(
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 264)
; CHECK-NEXT:    [[NOT:%.*]] = xor i1 [[CLASS]], true
; CHECK-NEXT:    ret i1 [[NOT]]
;
  %class = call i1 @llvm.is.fpclass.f32(float %x, i32 264)
  %not = xor i1 %class, true
  ret i1 %not
}

define i1 @test_class_xor_false(float %x) {
; CHECK-LABEL: @test_class_xor_false(
; CHECK-NEXT:    [[CLASS:%.*]] = call i1 @llvm.is.fpclass.f32(float [[X:%.*]], i32 33)
; CHECK-NEXT:    ret i1 [[CLASS]]
;
  %class = call i1 @llvm.is.fpclass.f32(float %x, i32 33)
  %not = xor i1 %class, false
  ret i1 %not
}

define <2 x i1> @test_class_not_vector(<2 x float> %x) {
; CHECK-LABEL: @test_class_not_vector(
; CHECK-NEXT:    [[CLASS:%.*]] = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> [[X:%.*]], i32 33)
; CHECK-NEXT:    [[NOT:%.*]] = xor <2 x i1> [[CLASS]], <i1 true, i1 true>
; CHECK-NEXT:    ret <2 x i1> [[NOT]]
;
  %class = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> %x, i32 33)
  %not = xor <2 x i1> %class, <i1 true, i1 true>
  ret <2 x i1> %not
}

define <2 x i1> @test_class_xor_vector(<2 x float> %x) {
; CHECK-LABEL: @test_class_xor_vector(
; CHECK-NEXT:    [[CLASS:%.*]] = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> [[X:%.*]], i32 33)
; CHECK-NEXT:    [[NOT:%.*]] = xor <2 x i1> [[CLASS]], <i1 true, i1 false>
; CHECK-NEXT:    ret <2 x i1> [[NOT]]
;
  %class = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> %x, i32 33)
  %not = xor <2 x i1> %class, <i1 true, i1 false>
  ret <2 x i1> %not
}

; --------------------------------------------------------------------
; or llvm.is.fpclass, llvm.is.fpclass
; --------------------------------------------------------------------

define i1 @test_fold_or_class_f32_0(float %a) {
; CHECK-LABEL: @test_fold_or_class_f32_0(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 1)
; CHECK-NEXT:    [[CLASS1:%.*]] = fcmp uno float [[A]], 0.000000e+00
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    ret i1 [[OR]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 1)
  %class1 = fcmp uno float %a, 0.000000e+00
  %or = or i1 %class0, %class1
  ret i1 %or
}

define i1 @test_fold_or3_class_f32_0(float %a) {
; CHECK-LABEL: @test_fold_or3_class_f32_0(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 1)
; CHECK-NEXT:    [[CLASS1:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 2)
; CHECK-NEXT:    [[CLASS2:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 4)
; CHECK-NEXT:    [[OR_0:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    [[OR_1:%.*]] = or i1 [[OR_0]], [[CLASS2]]
; CHECK-NEXT:    ret i1 [[OR_1]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 1)
  %class1 = call i1 @llvm.is.fpclass.f32(float %a, i32 2)
  %class2 = call i1 @llvm.is.fpclass.f32(float %a, i32 4)
  %or.0 = or i1 %class0, %class1
  %or.1 = or i1 %or.0, %class2
  ret i1 %or.1
}

define i1 @test_fold_or_all_tests_class_f32_0(float %a) {
; CHECK-LABEL: @test_fold_or_all_tests_class_f32_0(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 1)
; CHECK-NEXT:    [[CLASS1:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 2)
; CHECK-NEXT:    [[CLASS2:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 4)
; CHECK-NEXT:    [[CLASS3:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 8)
; CHECK-NEXT:    [[CLASS4:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 16)
; CHECK-NEXT:    [[CLASS5:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 32)
; CHECK-NEXT:    [[CLASS6:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 64)
; CHECK-NEXT:    [[CLASS7:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 128)
; CHECK-NEXT:    [[CLASS8:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 256)
; CHECK-NEXT:    [[CLASS9:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 512)
; CHECK-NEXT:    [[OR_0:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    [[OR_1:%.*]] = or i1 [[OR_0]], [[CLASS2]]
; CHECK-NEXT:    [[OR_2:%.*]] = or i1 [[OR_1]], [[CLASS3]]
; CHECK-NEXT:    [[OR_3:%.*]] = or i1 [[OR_2]], [[CLASS4]]
; CHECK-NEXT:    [[OR_4:%.*]] = or i1 [[OR_3]], [[CLASS5]]
; CHECK-NEXT:    [[OR_5:%.*]] = or i1 [[OR_4]], [[CLASS6]]
; CHECK-NEXT:    [[OR_6:%.*]] = or i1 [[OR_5]], [[CLASS7]]
; CHECK-NEXT:    [[OR_7:%.*]] = or i1 [[OR_6]], [[CLASS8]]
; CHECK-NEXT:    [[OR_8:%.*]] = or i1 [[OR_7]], [[CLASS9]]
; CHECK-NEXT:    ret i1 [[OR_8]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 1)
  %class1 = call i1 @llvm.is.fpclass.f32(float %a, i32 2)
  %class2 = call i1 @llvm.is.fpclass.f32(float %a, i32 4)
  %class3 = call i1 @llvm.is.fpclass.f32(float %a, i32 8)
  %class4 = call i1 @llvm.is.fpclass.f32(float %a, i32 16)
  %class5 = call i1 @llvm.is.fpclass.f32(float %a, i32 32)
  %class6 = call i1 @llvm.is.fpclass.f32(float %a, i32 64)
  %class7 = call i1 @llvm.is.fpclass.f32(float %a, i32 128)
  %class8 = call i1 @llvm.is.fpclass.f32(float %a, i32 256)
  %class9 = call i1 @llvm.is.fpclass.f32(float %a, i32 512)
  %or.0 = or i1 %class0, %class1
  %or.1 = or i1 %or.0, %class2
  %or.2 = or i1 %or.1, %class3
  %or.3 = or i1 %or.2, %class4
  %or.4 = or i1 %or.3, %class5
  %or.5 = or i1 %or.4, %class6
  %or.6 = or i1 %or.5, %class7
  %or.7 = or i1 %or.6, %class8
  %or.8 = or i1 %or.7, %class9
  ret i1 %or.8
}

define i1 @test_fold_or_class_f32_1(float %a) {
; CHECK-LABEL: @test_fold_or_class_f32_1(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 4)
; CHECK-NEXT:    [[CLASS1:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 8)
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    ret i1 [[OR]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 4)
  %class1 = call i1 @llvm.is.fpclass.f32(float %a, i32 8)
  %or = or i1 %class0, %class1
  ret i1 %or
}

define i1 @test_no_fold_or_class_f32_multi_use0(float %a, ptr %ptr) {
; CHECK-LABEL: @test_no_fold_or_class_f32_multi_use0(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 4)
; CHECK-NEXT:    store i1 [[CLASS0]], ptr [[PTR:%.*]], align 1
; CHECK-NEXT:    [[CLASS1:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 8)
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    ret i1 [[OR]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 4)
  store i1 %class0, ptr %ptr
  %class1 = call i1 @llvm.is.fpclass.f32(float %a, i32 8)
  %or = or i1 %class0, %class1
  ret i1 %or
}

define i1 @test_no_fold_or_class_f32_multi_use1(float %a, ptr %ptr) {
; CHECK-LABEL: @test_no_fold_or_class_f32_multi_use1(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 4)
; CHECK-NEXT:    [[CLASS1:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 8)
; CHECK-NEXT:    store i1 [[CLASS1]], ptr [[PTR:%.*]], align 1
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    ret i1 [[OR]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 4)
  %class1 = call i1 @llvm.is.fpclass.f32(float %a, i32 8)
  store i1 %class1, ptr %ptr
  %or = or i1 %class0, %class1
  ret i1 %or
}

define i1 @test_fold_or_class_f32_2(float %a) {
; CHECK-LABEL: @test_fold_or_class_f32_2(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 7)
; CHECK-NEXT:    [[CLASS1:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A]], i32 7)
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    ret i1 [[OR]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 7)
  %class1 = call i1 @llvm.is.fpclass.f32(float %a, i32 7)
  %or = or i1 %class0, %class1
  ret i1 %or
}

define i1 @test_no_fold_or_class_f32_0(float %a, float %b) {
; CHECK-LABEL: @test_no_fold_or_class_f32_0(
; CHECK-NEXT:    [[CLASS0:%.*]] = call i1 @llvm.is.fpclass.f32(float [[A:%.*]], i32 4)
; CHECK-NEXT:    [[CLASS1:%.*]] = call i1 @llvm.is.fpclass.f32(float [[B:%.*]], i32 8)
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    ret i1 [[OR]]
;
  %class0 = call i1 @llvm.is.fpclass.f32(float %a, i32 4)
  %class1 = call i1 @llvm.is.fpclass.f32(float %b, i32 8)
  %or = or i1 %class0, %class1
  ret i1 %or
}

define <2 x i1> @test_fold_or_class_v2f32(<2 x float> %a) {
; CHECK-LABEL: @test_fold_or_class_v2f32(
; CHECK-NEXT:    [[CLASS0:%.*]] = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> [[A:%.*]], i32 4)
; CHECK-NEXT:    [[CLASS1:%.*]] = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> [[A]], i32 8)
; CHECK-NEXT:    [[OR:%.*]] = or <2 x i1> [[CLASS0]], [[CLASS1]]
; CHECK-NEXT:    ret <2 x i1> [[OR]]
;
  %class0 = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> %a, i32 4)
  %class1 = call <2 x i1> @llvm.is.fpclass.v2f32(<2 x float> %a, i32 8)
  %or = or <2 x i1> %class0, %class1
  ret <2 x i1> %or
}

declare i1 @llvm.is.fpclass.f32(float, i32 immarg)
declare i1 @llvm.is.fpclass.f64(double, i32 immarg)
declare <2 x i1> @llvm.is.fpclass.v2f32(<2 x float>, i32 immarg)
