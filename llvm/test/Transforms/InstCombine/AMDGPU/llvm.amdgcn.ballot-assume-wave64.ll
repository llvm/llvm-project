; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -mtriple=amdgcn-amd-amdhsa -mattr=+wavefrontsize64 -passes=instcombine -S | FileCheck %s
;
; Wave64-specific tests for ballot-assume optimizations.
; - ballot.i64 should optimize (captures all 64 lanes)
; - ballot.i32 should NOT optimize (captures only lanes [0:31])

declare void @llvm.assume(i1)
declare i64 @llvm.amdgcn.ballot.i64(i1)
declare i32 @llvm.amdgcn.ballot.i32(i1)

; ============================================================================
; POSITIVE CASES: ballot.i64 on wave64
; ============================================================================

; Test 1: assume(ballot.i64(cmp) == -1) on wave64 -> cmp replaced with true
define amdgpu_kernel void @wave64_ballot_i64_all_lanes(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_all_lanes(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 %ballot, -1
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 2: assume(ballot.i64(cmp) == 0) on wave64 -> cmp replaced with false
define amdgpu_kernel void @wave64_ballot_i64_no_lanes(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_no_lanes(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[NONE:%.*]] = icmp eq i64 [[BALLOT]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[NONE]])
; CHECK-NEXT:    br i1 false, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %none = icmp eq i64 %ballot, 0
  call void @llvm.assume(i1 %none)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 3: assume(ballot.i64(cmp) == ballot.i64(true)) on wave64 -> cmp replaced with true
define amdgpu_kernel void @wave64_ballot_i64_exec_mask(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_exec_mask(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[EXEC:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], [[EXEC]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %exec = call i64 @llvm.amdgcn.ballot.i64(i1 true)
  %all = icmp eq i64 %ballot, %exec
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 4: Only dominated uses are replaced -> use_after replaced with true
define amdgpu_kernel void @wave64_ballot_i64_dominance(i32 %x, i32 %y, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_dominance(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BRANCH_COND:%.*]] = icmp sgt i32 [[Y:%.*]], 5
; CHECK-NEXT:    br i1 [[BRANCH_COND]], label [[BEFORE_ASSUME:%.*]], label [[AFTER_ASSUME:%.*]]
; CHECK:       before_assume:
; CHECK-NEXT:    [[USE_BEFORE:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    store i32 [[USE_BEFORE]], ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    ret void
; CHECK:       after_assume:
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    [[OUT2:%.*]] = getelementptr i8, ptr addrspace(1) [[OUT]], i64 4
; CHECK-NEXT:    store i32 1, ptr addrspace(1) [[OUT2]], align 4
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %branch_cond = icmp sgt i32 %y, 5
  br i1 %branch_cond, label %before_assume, label %after_assume

before_assume:
  %use_before = zext i1 %cmp to i32
  store i32 %use_before, ptr addrspace(1) %out
  ret void

after_assume:
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 %ballot, -1
  call void @llvm.assume(i1 %all)
  %use_after = zext i1 %cmp to i32
  %out2 = getelementptr i32, ptr addrspace(1) %out, i64 1
  store i32 %use_after, ptr addrspace(1) %out2
  ret void
}

; Test 5: Swapped operands in icmp -> cmp replaced with true
define amdgpu_kernel void @wave64_ballot_i64_swapped(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_swapped(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 -1, %ballot  ; swapped operands
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 6: Swapped ballot operands in exec mask comparison -> cmp replaced with true
define amdgpu_kernel void @wave64_ballot_i64_exec_mask_swapped(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_exec_mask_swapped(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[EXEC:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[EXEC]], [[BALLOT]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %exec = call i64 @llvm.amdgcn.ballot.i64(i1 true)
  %all = icmp eq i64 %exec, %ballot  ; swapped
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 7: Multiple uses of cmp after assume -> uses 1 & 2 replaced with true
define amdgpu_kernel void @wave64_ballot_i64_multiple_uses(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_multiple_uses(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    store i32 1, ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    [[OUT2:%.*]] = getelementptr i8, ptr addrspace(1) [[OUT]], i64 4
; CHECK-NEXT:    store i32 10, ptr addrspace(1) [[OUT2]], align 4
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %all = icmp eq i64 %ballot, -1
  call void @llvm.assume(i1 %all)
  %use1 = zext i1 %cmp to i32
  store i32 %use1, ptr addrspace(1) %out
  %use2 = select i1 %cmp, i32 10, i32 20
  %out2 = getelementptr i32, ptr addrspace(1) %out, i64 1
  store i32 %use2, ptr addrspace(1) %out2
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 8: Multiple uses with exec mask -> uses 1 & 2 replaced with true
define amdgpu_kernel void @wave64_ballot_i64_exec_mask_multiple_uses(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_exec_mask_multiple_uses(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[EXEC:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i64 [[BALLOT]], [[EXEC]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    store i32 1, ptr addrspace(1) [[OUT:%.*]], align 4
; CHECK-NEXT:    [[OUT2:%.*]] = getelementptr i8, ptr addrspace(1) [[OUT]], i64 4
; CHECK-NEXT:    store i32 10, ptr addrspace(1) [[OUT2]], align 4
; CHECK-NEXT:    br i1 true, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %exec = call i64 @llvm.amdgcn.ballot.i64(i1 true)
  %all = icmp eq i64 %ballot, %exec
  call void @llvm.assume(i1 %all)
  %use1 = zext i1 %cmp to i32
  store i32 %use1, ptr addrspace(1) %out
  %use2 = select i1 %cmp, i32 10, i32 20
  %out2 = getelementptr i32, ptr addrspace(1) %out, i64 1
  store i32 %use2, ptr addrspace(1) %out2
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 9: ballot(cmp) == ballot(false) -> cmp replaced with false
define amdgpu_kernel void @wave64_ballot_i64_false(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_false(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i64 [[BALLOT]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[MATCHES]])
; CHECK-NEXT:    br i1 false, label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %not_exec = call i64 @llvm.amdgcn.ballot.i64(i1 false)
  %matches = icmp eq i64 %ballot, %not_exec
  call void @llvm.assume(i1 %matches)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; ============================================================================
; NEGATIVE CASES: ballot.i64 on wave64
; ============================================================================

; Test 10: assume(ballot != -1) -> no transformation (requires icmp eq)
define amdgpu_kernel void @wave64_ballot_i64_ne_negative(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_ne_negative(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[NOT_ALL:%.*]] = icmp ne i64 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[NOT_ALL]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %not_all = icmp ne i64 %ballot, -1
  call void @llvm.assume(i1 %not_all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 11: assume(ballot != 0) -> no transformation (requires icmp eq)
define amdgpu_kernel void @wave64_ballot_i64_ne_zero_negative(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_ne_zero_negative(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[SOME:%.*]] = icmp ne i64 [[BALLOT]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[SOME]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %some = icmp ne i64 %ballot, 0
  call void @llvm.assume(i1 %some)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 12: Constant mask (other than -1/0) -> no transformation
define amdgpu_kernel void @wave64_ballot_i64_constant_mask(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_constant_mask(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i64 [[BALLOT]], 255
; CHECK-NEXT:    call void @llvm.assume(i1 [[MATCHES]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %matches = icmp eq i64 %ballot, 255  ; partial mask
  call void @llvm.assume(i1 %matches)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 13: Runtime mask value -> no transformation
define amdgpu_kernel void @wave64_ballot_i64_arbitrary_mask(i32 %x, i64 %mask, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i64_arbitrary_mask(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 [[CMP]])
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i64 [[BALLOT]], [[MASK:%.*]]
; CHECK-NEXT:    call void @llvm.assume(i1 [[MATCHES]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i64 @llvm.amdgcn.ballot.i64(i1 %cmp)
  %matches = icmp eq i64 %ballot, %mask
  call void @llvm.assume(i1 %matches)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; ============================================================================
; NEGATIVE CASES: ballot.i32 on wave64
; ============================================================================

; Test 14: assume(ballot.i32 == -1) on wave64 -> no transformation
define amdgpu_kernel void @wave64_ballot_i32_negative(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i32_negative(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 [[CMP]])
; CHECK-NEXT:    [[ALL:%.*]] = icmp eq i32 [[BALLOT]], -1
; CHECK-NEXT:    call void @llvm.assume(i1 [[ALL]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i32 @llvm.amdgcn.ballot.i32(i1 %cmp)
  %all = icmp eq i32 %ballot, -1
  call void @llvm.assume(i1 %all)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}

; Test 15: assume(ballot.i32 == 0) on wave64 -> no transformation
define amdgpu_kernel void @wave64_ballot_i32_zero_negative(i32 %x, ptr addrspace(1) %out) {
; CHECK-LABEL: @wave64_ballot_i32_zero_negative(
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-NEXT:    [[BALLOT:%.*]] = call i32 @llvm.amdgcn.ballot.i32(i1 [[CMP]])
; CHECK-NEXT:    [[NONE:%.*]] = icmp eq i32 [[BALLOT]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[NONE]])
; CHECK-NEXT:    br i1 [[CMP]], label [[FOO:%.*]], label [[BAR:%.*]]
; CHECK:       foo:
; CHECK-NEXT:    ret void
; CHECK:       bar:
; CHECK-NEXT:    ret void
;
  %cmp = icmp eq i32 %x, 0
  %ballot = call i32 @llvm.amdgcn.ballot.i32(i1 %cmp)
  %none = icmp eq i32 %ballot, 0
  call void @llvm.assume(i1 %none)
  br i1 %cmp, label %foo, label %bar

foo:
  ret void
bar:
  ret void
}
