; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=amdgcn-- -mcpu=gfx1030 -passes=instcombine -S < %s | FileCheck %s

; The readfirstlane version of this test covers all the interesting cases of the
; shared logic. This testcase focuses on permlane64 specific pitfalls.

; test unary

define float @hoist_fneg_f32(float %arg) {
; CHECK-LABEL: define float @hoist_fneg_f32(
; CHECK-SAME: float [[ARG:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = call float @llvm.amdgcn.readfirstlane.f32(float [[ARG]])
; CHECK-NEXT:    [[RFL:%.*]] = fneg float [[TMP0]]
; CHECK-NEXT:    ret float [[RFL]]
;
bb:
  %val = fneg float %arg
  %pl = call float @llvm.amdgcn.readfirstlane.f32(float %val)
  ret float %pl
}

define double @hoist_fneg_f64(double %arg) {
; CHECK-LABEL: define double @hoist_fneg_f64(
; CHECK-SAME: double [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = call double @llvm.amdgcn.readfirstlane.f64(double [[ARG]])
; CHECK-NEXT:    [[RFL:%.*]] = fneg double [[TMP0]]
; CHECK-NEXT:    ret double [[RFL]]
;
bb:
  %val = fneg double %arg
  %pl = call double @llvm.amdgcn.readfirstlane.f64(double %val)
  ret double %pl
}

; test casts

define i32 @hoist_trunc(i64 %arg) {
; CHECK-LABEL: define i32 @hoist_trunc(
; CHECK-SAME: i64 [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[RFL:%.*]] = call i64 @llvm.amdgcn.readfirstlane.i64(i64 [[ARG]])
; CHECK-NEXT:    [[TMP0:%.*]] = trunc i64 [[RFL]] to i32
; CHECK-NEXT:    ret i32 [[TMP0]]
;
bb:
  %val = trunc i64 %arg to i32
  %pl = call i32 @llvm.amdgcn.readfirstlane.i32(i32 %val)
  ret i32 %pl
}

define i64 @hoist_zext(i32 %arg) {
; CHECK-LABEL: define i64 @hoist_zext(
; CHECK-SAME: i32 [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[RFL:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[ARG]])
; CHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[RFL]] to i64
; CHECK-NEXT:    ret i64 [[TMP0]]
;
bb:
  %val = zext i32 %arg to i64
  %pl = call i64 @llvm.amdgcn.readfirstlane.i64(i64 %val)
  ret i64 %pl
}

; test binary i32

define i32 @hoist_add_i32(i32 %arg) {
; CHECK-LABEL: define i32 @hoist_add_i32(
; CHECK-SAME: i32 [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[VAL:%.*]] = add i32 [[ARG]], 16777215
; CHECK-NEXT:    [[RFL:%.*]] = call i32 @llvm.amdgcn.permlane64.i32(i32 [[VAL]])
; CHECK-NEXT:    ret i32 [[RFL]]
;
bb:
  %val = add i32 %arg, 16777215
  %pl = call i32 @llvm.amdgcn.permlane64.i32(i32 %val)
  ret i32 %pl
}

define float @hoist_fadd_f32(float %arg) {
; CHECK-LABEL: define float @hoist_fadd_f32(
; CHECK-SAME: float [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[BB:.*:]]
; CHECK-NEXT:    [[VAL:%.*]] = fadd float [[ARG]], 1.280000e+02
; CHECK-NEXT:    [[RFL:%.*]] = call float @llvm.amdgcn.permlane64.f32(float [[VAL]])
; CHECK-NEXT:    ret float [[RFL]]
;
bb:
  %val = fadd float %arg, 128.0
  %pl = call float @llvm.amdgcn.permlane64.f32(float %val)
  ret float %pl
}

; test cases where hoisting isn't possible

define float @cross_block_hoisting(i1 %cond, float %arg) {
; CHECK-LABEL: define float @cross_block_hoisting(
; CHECK-SAME: i1 [[COND:%.*]], float [[ARG:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[BB:.*]]:
; CHECK-NEXT:    [[VAL:%.*]] = fneg float [[ARG]]
; CHECK-NEXT:    br i1 [[COND]], label %[[THEN:.*]], label %[[END:.*]]
; CHECK:       [[THEN]]:
; CHECK-NEXT:    [[RFL:%.*]] = call float @llvm.amdgcn.permlane64.f32(float [[VAL]])
; CHECK-NEXT:    br label %[[END]]
; CHECK:       [[END]]:
; CHECK-NEXT:    [[RES:%.*]] = phi float [ [[RFL]], %[[THEN]] ], [ [[VAL]], %[[BB]] ]
; CHECK-NEXT:    ret float [[RES]]
;
bb:
  %val = fneg float %arg
  br i1 %cond, label %then, label %end

then:
  %pl = call float @llvm.amdgcn.permlane64.f32(float %val)
  br label %end

end:
  %res = phi float [%pl, %then], [%val, %bb]
  ret float %res
}

; test that convergence tokens are preserved

define float @hoist_preserves_convergence_token(i1 %cond, float %arg) convergent {
; CHECK-LABEL: define float @hoist_preserves_convergence_token(
; CHECK-SAME: i1 [[COND:%.*]], float [[ARG:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[BB:.*]]:
; CHECK-NEXT:    [[ENTRY:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    br i1 [[COND]], label %[[THEN:.*]], label %[[END:.*]]
; CHECK:       [[THEN]]:
; CHECK-NEXT:    [[RFL:%.*]] = call float @llvm.amdgcn.permlane64.f32(float [[ARG]]) [ "convergencectrl"(token [[ENTRY]]) ]
; CHECK-NEXT:    [[TMP0:%.*]] = fneg float [[RFL]]
; CHECK-NEXT:    br label %[[END]]
; CHECK:       [[END]]:
; CHECK-NEXT:    [[RES:%.*]] = phi float [ [[TMP0]], %[[THEN]] ], [ [[ARG]], %[[BB]] ]
; CHECK-NEXT:    ret float [[RES]]
;
bb:
  %entry = call token @llvm.experimental.convergence.entry()
  br i1 %cond, label %then, label %end

then:
  %val = fneg float %arg
  %pl = call float @llvm.amdgcn.permlane64.f32(float %val) [ "convergencectrl"(token %entry)]
  br label %end

end:
  %res = phi float [%pl, %then], [%arg, %bb]
  ret float %res
}
