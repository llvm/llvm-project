; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -O1 -S -o - %s | FileCheck %s
; REQUIRES: amdgpu-registered-target

target triple = "amdgcn-amd-amdhsa"

%"doube_double" = type { double, double}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg)

; Function Attrs: convergent mustprogress norecurse nounwind sanitize_address uwtable
define amdgpu_kernel void @_test(ptr addrspace(4) noundef byref(%"doube_double") align 8 %0) #0  {
; CHECK-LABEL: define amdgpu_kernel void @_test(
; CHECK-SAME: ptr addrspace(4) noundef readonly byref([[DOUBE_DOUBLE:%.*]]) align 8 captures(none) [[TMP0:%.*]]) local_unnamed_addr #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[ALPHA_UNION:%.*]] = addrspacecast ptr addrspace(4) [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr addrspace(5) null, align 2147483648
; CHECK-NEXT:    [[LOADEDV:%.*]] = trunc i8 [[TMP1]] to i1
; CHECK-NEXT:    br i1 [[LOADEDV]], label %[[COND_END:.*]], label %[[COND_FALSE:.*]]
; CHECK:       [[COND_FALSE]]:
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr addrspace(4) [[TMP0]], align 8
; CHECK-NEXT:    br label %[[COND_END]]
; CHECK:       [[COND_END]]:
; CHECK-NEXT:    [[COND1:%.*]] = phi ptr [ [[TMP2]], %[[COND_FALSE]] ], [ [[ALPHA_UNION]], %[[ENTRY]] ]
; CHECK-NEXT:    tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) poison, ptr noundef nonnull align 8 dereferenceable(16) [[COND1]], i64 16, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %coerce = alloca %"doube_double", align 8, addrspace(5)
  %alpha_union = addrspacecast ptr addrspace(5) %coerce to ptr
  %is_host_mode.addr.ascast = addrspacecast ptr addrspace(5) null to ptr
  call void @llvm.memcpy.p0.p4.i64(ptr align 8 %alpha_union, ptr addrspace(4) align 8 %0, i64 16, i1 false)
  %1 = load i8, ptr %is_host_mode.addr.ascast, align 1
  %loadedv = trunc i8 %1 to i1
  br i1 %loadedv, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr %alpha_union, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %entry
  %cond = phi ptr [ %2, %cond.false ], [ %alpha_union, %entry ]
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 poison, ptr align 8 %cond, i64 16, i1 false)
  ret void
}

attributes #0 = { convergent mustprogress norecurse nounwind sanitize_address uwtable "amdgpu-flat-work-group-size"="1,128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="gfx90a" "target-features"="+16-bit-insts,+atomic-buffer-global-pk-add-f16-insts,+atomic-fadd-rtn-insts,+ci-insts,+dl-insts,+dot1-insts,+dot10-insts,+dot2-insts,+dot3-insts,+dot4-insts,+dot5-insts,+dot6-insts,+dot7-insts,+dpp,+gfx8-insts,+gfx9-insts,+gfx90a-insts,+mai-insts,+s-memrealtime,+s-memtime-inst,+wavefrontsize64,+xnack" "uniform-work-group-size"="true" }
