; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

target datalayout = "n32:64"

define i1 @or_icmp_2(i32 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_2(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TYPE]], 6
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[TYPE]], 0
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; CHECK-NEXT:    ret i1 [[OR_COND]]
;
entry:
  %cmp = icmp eq i32 %type, 6
  %cmp1 = icmp eq i32 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  ret i1 %or.cond
}

define i1 @or_icmp_3(i32 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_3(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i32 [[TYPE]] to i16
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i16 -32703, [[SWITCH_CAST]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i16 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[TYPE]], 16
; CHECK-NEXT:    [[OR_COND1:%.*]] = select i1 [[TMP0]], i1 [[SWITCH_MASKED]], i1 false
; CHECK-NEXT:    ret i1 [[OR_COND1]]
;
entry:
  %cmp = icmp eq i32 %type, 6
  %cmp1 = icmp eq i32 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i32 %type, 15
  %or.cond1 = or i1 %cmp2, %or.cond
  ret i1 %or.cond1
}

; Don't currently handle a single non-equal
define i1 @or_icmp_extra(i32 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_extra(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[TYPE]], -7
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP0]], -6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  %cmp = icmp ugt i32 %type, 6
  %cmp1 = icmp eq i32 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i32 %type, 15
  %or.cond1 = or i1 %cmp2, %or.cond
  ret i1 %or.cond1
}

define i1 @and_icmp_all_neq(i32 noundef %type) {
; CHECK-LABEL: define i1 @and_icmp_all_neq(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i32 [[TYPE]] to i16
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i16 32702, [[SWITCH_CAST]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i16 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i32 [[TYPE]], 15
; CHECK-NEXT:    [[AND_COND1:%.*]] = select i1 [[TMP0]], i1 true, i1 [[SWITCH_MASKED]]
; CHECK-NEXT:    ret i1 [[AND_COND1]]
;
entry:
  %cmp = icmp ne i32 %type, 6
  %cmp1 = icmp ne i32 %type, 0
  %and.cond = and i1 %cmp, %cmp1
  %cmp2 = icmp ne i32 %type, 15
  %and.cond1 = and i1 %cmp2, %and.cond
  ret i1 %and.cond1
}

define i1 @and_icmp_ugt(i32 noundef %type) {
; CHECK-LABEL: define i1 @and_icmp_ugt(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i32 [[TYPE]] to i23
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i23 4157440, [[SWITCH_CAST]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i23 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i32 [[TYPE]], 22
; CHECK-NEXT:    [[AND_COND1:%.*]] = select i1 [[TMP0]], i1 true, i1 [[SWITCH_MASKED]]
; CHECK-NEXT:    ret i1 [[AND_COND1]]
;
entry:
  %cmp = icmp ne i32 %type, 22
  %cmp1 = icmp ugt i32 %type, 11
  %and.cond = and i1 %cmp, %cmp1
  %cmp2 = icmp ne i32 %type, 15
  %and.cond1 = and i1 %cmp2, %and.cond
  ret i1 %and.cond1
}

define i1 @or_icmp_ltu(i32 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_ltu(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i32 [[TYPE]] to i16
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i16 -32689, [[SWITCH_CAST]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i16 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[TYPE]], 16
; CHECK-NEXT:    [[OR_COND1:%.*]] = select i1 [[TMP0]], i1 [[SWITCH_MASKED]], i1 false
; CHECK-NEXT:    ret i1 [[OR_COND1]]
;
entry:
  %cmp = icmp eq i32 %type, 6
  %cmp1 = icmp ult i32 %type, 4
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i32 %type, 15
  %or.cond1 = or i1 %cmp2, %or.cond
  ret i1 %or.cond1
}

define i1 @or_icmp_7(i32 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_7(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i32 -1878900663, [[TYPE]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i32 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[TYPE]], 32
; CHECK-NEXT:    [[OR_COND1:%.*]] = select i1 [[TMP0]], i1 [[SWITCH_MASKED]], i1 false
; CHECK-NEXT:    ret i1 [[OR_COND1]]
;
entry:
  %cmp = icmp eq i32 %type, 6
  %cmp1 = icmp eq i32 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i32 %type, 17
  %or.cond1 = or i1 %cmp2, %or.cond
  %cmp3 = icmp eq i32 %type, 3
  %or.cond2 = or i1 %cmp3, %or.cond1
  %cmp4 = icmp eq i32 %type, 31
  %or.cond3 = or i1 %cmp4, %or.cond2
  %cmp5 = icmp eq i32 %type, 14
  %or.cond4 = or i1 %cmp5, %or.cond3
  %cmp6 = icmp eq i32 %type, 28
  %or.cond5 = or i1 %cmp6, %or.cond4
  ret i1 %or.cond5
}

; Cannot optimize since Imm > XLen
define i1 @or_icmp_gte_64(i32 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_gte_64(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TYPE]], 6
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[TYPE]], 64
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; CHECK-NEXT:    ret i1 [[OR_COND]]
;
entry:
  %cmp = icmp eq i32 %type, 6
  %cmp1 = icmp eq i32 %type, 64
  %or.cond = or i1 %cmp, %cmp1
  ret i1 %or.cond
}

; Cannot optimize since %type has multiple uses
define i32 @or_icmp_multiple_uses(i32 noundef %type) {
; CHECK-LABEL: define i32 @or_icmp_multiple_uses(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[TYPE]], 6
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[TYPE]], 0
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    [[CMP_EXT:%.*]] = zext i1 [[CMP1]] to i32
; CHECK-NEXT:    [[OR_COND_EXT:%.*]] = zext i1 [[OR_COND]] to i32
; CHECK-NEXT:    [[ADD:%.*]] = add nuw nsw i32 [[CMP_EXT]], [[OR_COND_EXT]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
entry:
  %cmp = icmp eq i32 %type, 6
  %cmp1 = icmp eq i32 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp.ext = zext i1 %cmp to i32
  %or.cond.ext = zext i1 %or.cond to i32
  %add = add i32 %cmp.ext, %or.cond.ext
  ret i32 %add
}

; Cannot optimize since not == comparison
define i1 @or_icmp_not_eq(i32 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_not_eq(
; CHECK-SAME: i32 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[TYPE]], -7
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ult i32 [[TMP0]], -5
; CHECK-NEXT:    ret i1 [[CMP1]]
;
entry:
  %cmp = icmp ugt i32 %type, 6
  %cmp1 = icmp ult i32 %type, 2
  %or.cond = or i1 %cmp, %cmp1
  ret i1 %or.cond
}

define i1 @or_icmp_i64(i64 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_i64(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i64 [[TYPE]] to i16
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i16 -32703, [[SWITCH_CAST]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i16 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i64 [[TYPE]], 16
; CHECK-NEXT:    [[OR_COND1:%.*]] = select i1 [[TMP0]], i1 [[SWITCH_MASKED]], i1 false
; CHECK-NEXT:    ret i1 [[OR_COND1]]
;
entry:
  %cmp = icmp eq i64 %type, 6
  %cmp1 = icmp eq i64 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i64 %type, 15
  %or.cond1 = or i1 %cmp2, %or.cond
  ret i1 %or.cond1
}

; Cannot optimize since not the same value being compared
define i1 @or_icmp_specific(i64 noundef %type, i64 noundef %type1, i64 noundef %type2) {
; CHECK-LABEL: define i1 @or_icmp_specific(
; CHECK-SAME: i64 noundef [[TYPE:%.*]], i64 noundef [[TYPE1:%.*]], i64 noundef [[TYPE2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TYPE]], 6
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[TYPE1]], 0
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i64 [[TYPE]], 15
; CHECK-NEXT:    [[OR_COND1:%.*]] = or i1 [[CMP2]], [[OR_COND]]
; CHECK-NEXT:    ret i1 [[OR_COND1]]
;
entry:
  %cmp = icmp eq i64 %type, 6
  %cmp1 = icmp eq i64 %type1, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i64 %type, 15
  %or.cond1 = or i1 %cmp2, %or.cond
  ret i1 %or.cond1
}

; Cannot optimize since %type can be un-def
define i1 @or_icmp_undef(i64 %type) {
; CHECK-LABEL: define i1 @or_icmp_undef(
; CHECK-SAME: i64 [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TYPE]], 6
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[TYPE]], 0
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i64 [[TYPE]], 15
; CHECK-NEXT:    [[OR_COND1:%.*]] = or i1 [[CMP2]], [[OR_COND]]
; CHECK-NEXT:    ret i1 [[OR_COND1]]
;
entry:
  %cmp = icmp eq i64 %type, 6
  %cmp1 = icmp eq i64 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i64 %type, 15
  %or.cond1 = or i1 %cmp2, %or.cond
  ret i1 %or.cond1
}

define i1 @or_icmp_expand(i64 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_expand(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i64 [[TYPE]] to i36
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i36 -34359738341, [[SWITCH_CAST]]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i36 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TYPE]], 36
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %type.t = trunc i64 %type to i7
  %shr = lshr i7 27, %type.t
  %cmp = icmp ult i64 %type, 7
  %trunc = trunc i7 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i64 %type, 35
  %or.cond = or i1 %and, %cmp1
  ret i1 %or.cond
}

define i1 @and_icmp_expand(i64 noundef %type) {
; CHECK-LABEL: define i1 @and_icmp_expand(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i64 [[TYPE]] to i36
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i36 34359738340, [[SWITCH_CAST]]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i36 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i64 [[TYPE]], 35
; CHECK-NEXT:    [[AND_COND:%.*]] = select i1 [[TMP0]], i1 true, i1 [[TRUNC]]
; CHECK-NEXT:    ret i1 [[AND_COND]]
;
entry:
  %type.t = trunc i64 %type to i7
  %shr = lshr i7 27, %type.t
  %cmp = icmp ult i64 %type, 7
  %trunc = trunc i7 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp ne i64 %type, 35
  %not = xor i1 %and, true
  %and.cond = and i1 %not, %cmp1
  ret i1 %and.cond
}

; Can't mix existing IsEq sequence and new !IsEq sequence
define i1 @and_icmp_no_expand(i64 noundef %type) {
; CHECK-LABEL: define i1 @and_icmp_no_expand(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TYPE_T:%.*]] = trunc i64 [[TYPE]] to i7
; CHECK-NEXT:    [[SHR:%.*]] = lshr i7 27, [[TYPE_T]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TYPE]], 7
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i7 [[SHR]] to i1
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %type.t = trunc i64 %type to i7
  %shr = lshr i7 27, %type.t
  %cmp = icmp ult i64 %type, 7
  %trunc = trunc i7 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp ne i64 %type, 35
  %and.cond = and i1 %and, %cmp1
  ret i1 %and.cond
}

; Can't mix existing !IsEq sequence and new IsEq sequence
define i1 @or_icmp_no_expand(i64 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_no_expand(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[TYPE]], 35
; CHECK-NEXT:    ret i1 [[CMP1]]
;
entry:
  %type.t = trunc i64 %type to i7
  %shr = lshr i7 27, %type.t
  %cmp = icmp ult i64 %type, 7
  %trunc = trunc i7 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i64 %type, 35
  %not = xor i1 %and, true
  %or.cond = and i1 %not, %cmp1
  ret i1 %or.cond
}

; Cannot optimize bounds check smaller than largest BitMap bit
define i1 @or_icmp_expand_small_bounds(i64 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_expand_small_bounds(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TYPE_T:%.*]] = trunc i64 [[TYPE]] to i7
; CHECK-NEXT:    [[SHR:%.*]] = lshr i7 27, [[TYPE_T]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TYPE]], 3
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i7 [[SHR]] to i1
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[TYPE]], 35
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[AND]], [[CMP1]]
; CHECK-NEXT:    ret i1 [[OR_COND]]
;
entry:
  %type.t = trunc i64 %type to i7
  %shr = lshr i7 27, %type.t
  %cmp = icmp ult i64 %type, 3
  %trunc = trunc i7 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i64 %type, 35
  %or.cond = or i1 %and, %cmp1
  ret i1 %or.cond
}

; Cannot optimize bounds check larger than XLen
define i1 @or_icmp_expand_large_bounds(i64 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_expand_large_bounds(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SHR:%.*]] = lshr i64 65, [[TYPE]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TYPE]], 65
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i64 [[SHR]] to i1
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[TYPE]], 35
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[AND]], [[CMP1]]
; CHECK-NEXT:    ret i1 [[OR_COND]]
;
entry:
  %shr = lshr i64 65, %type
  %cmp = icmp ult i64 %type, 65
  %trunc = trunc i64 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i64 %type, 35
  %or.cond = or i1 %and, %cmp1
  ret i1 %or.cond
}

define i1 @or_icmp_expand_trunc_type_shr(i128 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_expand_trunc_type_shr(
; CHECK-SAME: i128 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i128 [[TYPE]] to i36
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i36 -34359738303, [[SWITCH_CAST]]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i36 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i128 [[TYPE]], 36
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %type.t = trunc i128 %type to i64
  %shr = lshr i64 65, %type.t
  %cmp = icmp ult i128 %type, 64
  %trunc = trunc i64 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i128 %type, 35
  %or.cond = or i1 %and, %cmp1
  ret i1 %or.cond
}

define i1 @or_icmp_expand_zext_cmp(i64 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_expand_zext_cmp(
; CHECK-SAME: i64 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i64 [[TYPE]] to i36
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i36 -34359738303, [[SWITCH_CAST]]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i36 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TYPE]], 36
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %type.e = zext i64 %type to i128
  %shr = lshr i64 65, %type
  %cmp = icmp ult i128 %type.e, 64
  %trunc = trunc i64 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i64 %type, 35
  %or.cond = or i1 %and, %cmp1
  ret i1 %or.cond
}

define i1 @or_icmp_i128(i128 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_i128(
; CHECK-SAME: i128 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i128 [[TYPE]] to i16
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i16 -32703, [[SWITCH_CAST]]
; CHECK-NEXT:    [[SWITCH_MASKED:%.*]] = trunc i16 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i128 [[TYPE]], 16
; CHECK-NEXT:    [[OR_COND1:%.*]] = select i1 [[TMP0]], i1 [[SWITCH_MASKED]], i1 false
; CHECK-NEXT:    ret i1 [[OR_COND1]]
;
entry:
  %cmp = icmp eq i128 %type, 6
  %cmp1 = icmp eq i128 %type, 0
  %or.cond = or i1 %cmp, %cmp1
  %cmp2 = icmp eq i128 %type, 15
  %or.cond1 = or i1 %cmp2, %or.cond
  ret i1 %or.cond1
}

define i1 @or_icmp_expand_128(i128 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_expand_128(
; CHECK-SAME: i128 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SWITCH_CAST:%.*]] = trunc i128 [[TYPE]] to i36
; CHECK-NEXT:    [[SWITCH_DOWNSHIFT:%.*]] = lshr i36 -34359738303, [[SWITCH_CAST]]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i36 [[SWITCH_DOWNSHIFT]] to i1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i128 [[TYPE]], 36
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    ret i1 [[AND]]
;
entry:
  %type.t = trunc i128 %type to i64
  %shr = lshr i64 65, %type.t
  %cmp = icmp ult i128 %type, 64
  %trunc = trunc i64 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i128 %type, 35
  %or.cond = or i1 %and, %cmp1
  ret i1 %or.cond
}

; Cannot optimize BitMap larger than XLen
define i1 @or_icmp_expand_large_bitmap(i128 noundef %type) {
; CHECK-LABEL: define i1 @or_icmp_expand_large_bitmap(
; CHECK-SAME: i128 noundef [[TYPE:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SHR:%.*]] = lshr i128 73786976294838206465, [[TYPE]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i128 [[TYPE]], 128
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i128 [[SHR]] to i1
; CHECK-NEXT:    [[AND:%.*]] = select i1 [[CMP]], i1 [[TRUNC]], i1 false
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i128 [[TYPE]], 35
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[AND]], [[CMP1]]
; CHECK-NEXT:    ret i1 [[OR_COND]]
;
entry:
  %shr = lshr i128 73786976294838206465, %type
  %cmp = icmp ult i128 %type, 128
  %trunc = trunc i128 %shr to i1
  %and = select i1 %cmp, i1 %trunc, i1 false
  %cmp1 = icmp eq i128 %type, 35
  %or.cond = or i1 %and, %cmp1
  ret i1 %or.cond
}
