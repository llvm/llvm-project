; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes='require<loops>,instcombine' -opaque-pointers -S | FileCheck %s

; Constant-indexed GEP instructions in a chain of GEP instructions should be
; swapped to the end whenever such transformation is valid. This allows them to
; be merged.


; The constant-indexed GEP instruction should be swapped to the end, even
; without merging.
; result = (((i32*) p + a) + b) + 1
define ptr @basic(ptr %p, i64 %a, i64 %b) {
; CHECK-LABEL: @basic(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i32, ptr [[P:%.*]], i64 [[A:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr [[TMP1]], i64 [[B:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i32, ptr [[TMP2]], i64 1
; CHECK-NEXT:    ret ptr [[TMP3]]
;
  %1 = getelementptr inbounds i32, ptr %p, i64 1
  %2 = getelementptr inbounds i32, ptr %1, i64 %a
  %3 = getelementptr inbounds i32, ptr %2, i64 %b
  ret ptr %3
}

; GEP with the last index being a constant should also be swapped.
define ptr @partialConstant1(ptr %p, i64 %a, i64 %b) {
; CHECK-LABEL: @partialConstant1(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i32, ptr [[P:%.*]], i64 [[B:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr [4 x i32], ptr [[TMP1]], i64 [[A:%.*]], i64 1
; CHECK-NEXT:    ret ptr [[TMP2]]
;
  %1 = getelementptr inbounds [4 x i32], ptr %p, i64 %a, i64 1
  %2 = getelementptr inbounds i32, ptr %1, i64 %b
  ret ptr %2
}

; Negative test. GEP should not be swapped if the last index is not a constant.
define ptr @partialConstant2(ptr %p, i64 %a, i64 %b) {
; CHECK-LABEL: @partialConstant2(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [4 x i32], ptr [[P:%.*]], i64 1, i64 [[A:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 [[B:%.*]]
; CHECK-NEXT:    ret ptr [[TMP2]]
;
  %1 = getelementptr inbounds [4 x i32], ptr %p, i64 1, i64 %a
  %2 = getelementptr inbounds i32, ptr %1, i64 %b
  ret ptr %2
}

; Constant-indexed GEP are merged after swapping.
; result = ((i32*) p + a) + 3
define ptr @merge(ptr %p, i64 %a) {
; CHECK-LABEL: @merge(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i32, ptr [[P:%.*]], i64 [[A:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr [[TMP1]], i64 3
; CHECK-NEXT:    ret ptr [[TMP2]]
;
  %1 = getelementptr inbounds i32, ptr %p, i64 1
  %2 = getelementptr inbounds i32, ptr %1, i64 %a
  %3 = getelementptr inbounds i32, ptr %2, i64 2
  ret ptr %3
}

; Multiple constant-indexed GEP. Note that the first two cannot be merged at
; first, but after the second and third are merged, the result can be merged
; with the first one on the next pass.
; result = (<3 x i32>*) ((i16*) ((i8*) ptr + a) + (a * b)) + 9
define ptr @nested(ptr %p, i64 %a, i64 %b) {
; CHECK-LABEL: @nested(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[P:%.*]], i64 [[A:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = mul i64 [[A]], [[B:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i16, ptr [[TMP1]], i64 [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr <3 x i32>, ptr [[TMP3]], i64 10
; CHECK-NEXT:    ret ptr [[TMP4]]
;
  %1 = getelementptr inbounds <3 x i32>, ptr %p, i64 1
  %2 = getelementptr inbounds i8, ptr %1, i64 %a
  %3 = mul i64 %a, %b
  %4 = getelementptr inbounds <5 x i32>, ptr %2, i64 4
  %5 = getelementptr inbounds i16, ptr %4, i64 %3
  %6 = getelementptr inbounds <4 x i32>, ptr %5, i64 1
  ret ptr %6
}

; It is valid to swap if the source operand of the first GEP has multiple uses.
define ptr @multipleUses1(ptr %p) {
; CHECK-LABEL: @multipleUses1(
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[P:%.*]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr [[P]], i64 [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i32, ptr [[TMP2]], i64 1
; CHECK-NEXT:    ret ptr [[TMP3]]
;
  %1 = getelementptr inbounds i32, ptr %p, i64 1
  %2 = ptrtoint ptr %p to i64
  %3 = getelementptr inbounds i32, ptr %1, i64 %2
  ret ptr %3
}

; Negative test. It is not valid to swap if the first GEP has multiple uses.
define ptr @multipleUses2(ptr %p) {
; CHECK-LABEL: @multipleUses2(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[P:%.*]], i64 1
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 [[TMP2]]
; CHECK-NEXT:    ret ptr [[TMP3]]
;
  %1 = getelementptr inbounds i32, ptr %p, i64 1
  %2 = ptrtoint ptr %1 to i64
  %3 = getelementptr inbounds i32, ptr %1, i64 %2
  ret ptr %3
}

; Negative test. LICM should take priority over canonicalization, so the first
; GEP should not be swapped, even if it contains a constant index.
define i64 @licm(ptr %p) {
; CHECK-LABEL: @licm(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[ADD:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i64, ptr [[P:%.*]], i64 4
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i64, ptr [[P1]], i64 [[I]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i64, ptr [[P2]], align 4
; CHECK-NEXT:    [[ADD]] = add nsw i64 [[SUM]], [[LOAD]]
; CHECK-NEXT:    [[INEXT]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[I]], 1000000
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_END:%.*]], label [[FOR_BODY]]
; CHECK:       for.end:
; CHECK-NEXT:    ret i64 [[ADD]]
;
entry:
  br label %for.body

for.body:
  %i = phi i64 [ 0, %entry ], [ %inext, %for.body ]
  %sum = phi i64 [ 0, %entry ], [ %add, %for.body ]
  %p1 = getelementptr i64, ptr %p, i64 4
  %p2 = getelementptr i64, ptr %p1, i64 %i
  %load = load i64, ptr %p2
  %add = add nsw i64 %sum, %load
  %inext = add nuw nsw i64 %i, 1
  %exitcond = icmp eq i64 %i, 1000000
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  ret i64 %add
}
