; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

define i1 @SwitchTest(i32 %x, i32 %y) {
; CHECK-LABEL: define i1 @SwitchTest
; CHECK-SAME: (i32 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i32 [[X]], label [[BB1:%.*]] [
; CHECK-NEXT:    i32 0, label [[BB2:%.*]]
; CHECK-NEXT:    i32 1, label [[BB3:%.*]]
; CHECK-NEXT:    ]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i32 [[Y]], 1
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i1 [ false, [[ENTRY:%.*]] ], [ [[TMP0]], [[BB1]] ]
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    [[PHI2:%.*]] = phi i1 [ [[PHI1]], [[BB2]] ], [ false, [[ENTRY]] ]
; CHECK-NEXT:    ret i1 [[PHI2]]
;
entry:
  switch i32 %x, label %bb1 [
  i32 0, label %bb2
  i32 1, label %bb3
  ]

bb1:
  br label %bb2

bb2:
  %phi1 = phi i32 [ 1, %entry ], [ %y, %bb1 ]
  br label %bb3

bb3:
  %phi2 = phi i32 [ %phi1, %bb2 ], [ 0, %entry ]
  %cmp = icmp ugt i32 %phi2, 1
  ret i1 %cmp
}

; Test case derived from:
; llvm-test-suite/MultiSource/Benchmarks/MiBench/consumer-typeset/z10.c
define i1 @BranchTest(i1 %c, i1 %c1, i1 %c2, i1 %c3, i1 %c4) {
; CHECK-LABEL: define i1 @BranchTest
; CHECK-SAME: (i1 [[C:%.*]], i1 [[C1:%.*]], i1 [[C2:%.*]], i1 [[C3:%.*]], i1 [[C4:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C]], label [[SW_EPILOG:%.*]], label [[COND_FALSE:%.*]]
; CHECK:       cond.false:
; CHECK-NEXT:    br i1 [[C1]], label [[SW_EPILOG]], label [[COND_FALSE2:%.*]]
; CHECK:       cond.false2:
; CHECK-NEXT:    br i1 [[C2]], label [[SW_EPILOG]], label [[COND_FALSE3:%.*]]
; CHECK:       cond.false3:
; CHECK-NEXT:    br i1 [[C3]], label [[SW_BB:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.end:
; CHECK-NEXT:    br label [[SW_BB]]
; CHECK:       sw.bb:
; CHECK-NEXT:    br label [[SW_EPILOG]]
; CHECK:       sw.epilog:
; CHECK-NEXT:    ret i1 [[C]]
;
entry:
  br i1 %c, label %sw.epilog, label %cond.false

cond.false:
  br i1 %c1, label %sw.epilog, label %cond.false2

cond.false2:
  br i1 %c2, label %sw.epilog, label %cond.false3

cond.false3:
  br i1 %c3, label %sw.bb, label %cond.end

cond.end:
  %cond = select i1 %c4, i32 127, i32 126
  br label %sw.bb

sw.bb:
  %cond2 = phi i32 [ %cond, %cond.end ], [ 128, %cond.false3 ]
  br label %sw.epilog

sw.epilog:
  %cond3 = phi i32 [ %cond2, %sw.bb ], [ 134, %cond.false2 ], [ 2, %cond.false ], [ 1, %entry ]
  %cmp  = icmp ult i32 %cond3, 2
  ret i1 %cmp
}
