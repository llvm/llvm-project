; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -passes=instcombine < %s | FileCheck %s

define half @fp16_reduce(<8 x half> %a) {
; CHECK-LABEL: define half @fp16_reduce(
; CHECK-SAME: <8 x half> [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CONV21:%.*]] = call half @llvm.vector.reduce.fadd.v8f16(half 0xH8000, <8 x half> [[A]])
; CHECK-NEXT:    ret half [[CONV21]]
;
entry:
  %vecext = extractelement <8 x half> %a, i64 0
  %conv = fpext half %vecext to float
  %vecext1 = extractelement <8 x half> %a, i64 1
  %conv2 = fpext half %vecext1 to float
  %add = fadd float %conv, %conv2
  %vecext3 = extractelement <8 x half> %a, i64 2
  %conv4 = fpext half %vecext3 to float
  %add5 = fadd float %add, %conv4
  %vecext6 = extractelement <8 x half> %a, i64 3
  %conv7 = fpext half %vecext6 to float
  %add8 = fadd float %add5, %conv7
  %vecext9 = extractelement <8 x half> %a, i64 4
  %conv10 = fpext half %vecext9 to float
  %add11 = fadd float %add8, %conv10
  %vecext12 = extractelement <8 x half> %a, i64 5
  %conv13 = fpext half %vecext12 to float
  %add14 = fadd float %add11, %conv13
  %vecext15 = extractelement <8 x half> %a, i64 6
  %conv16 = fpext half %vecext15 to float
  %add17 = fadd float %add14, %conv16
  %vecext18 = extractelement <8 x half> %a, i64 7
  %conv19 = fpext half %vecext18 to float
  %add20 = fadd float %add17, %conv19
  %conv21 = fptrunc float %add20 to half
  ret half %conv21
}

define float @fp32_reduce(<4 x float> %a) {
; CHECK-LABEL: define float @fp32_reduce(
; CHECK-SAME: <4 x float> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD8:%.*]] = call float @llvm.vector.reduce.fadd.v4f32(float -0.000000e+00, <4 x float> [[A]])
; CHECK-NEXT:    ret float [[ADD8]]
;
  %vecext = extractelement <4 x float> %a, i64 0
  %vecext1 = extractelement <4 x float> %a, i64 1
  %add = fadd float %vecext, %vecext1
  %vecext3 = extractelement <4 x float> %a, i64 2
  %add5 = fadd float %add, %vecext3
  %vecext6 = extractelement <4 x float> %a, i64 3
  %add8 = fadd float %add5, %vecext6
  ret float %add8
}

define double @float64_reduce(<2 x double> %a) {
; CHECK-LABEL: define double @float64_reduce(
; CHECK-SAME: <2 x double> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = call double @llvm.vector.reduce.fadd.v2f64(double -0.000000e+00, <2 x double> [[A]])
; CHECK-NEXT:    ret double [[ADD]]
;
  %vecext = extractelement <2 x double> %a, i64 0
  %vecext1 = extractelement <2 x double> %a, i64 1
  %add = fadd double %vecext, %vecext1
  ret double %add
}

define float @fp32_reduce_fast(<4 x float> %a) {
; CHECK-LABEL: define float @fp32_reduce_fast(
; CHECK-SAME: <4 x float> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD8:%.*]] = call fast float @llvm.vector.reduce.fadd.v4f32(float -0.000000e+00, <4 x float> [[A]])
; CHECK-NEXT:    ret float [[ADD8]]
;
  %vecext = extractelement <4 x float> %a, i64 0
  %vecext1 = extractelement <4 x float> %a, i64 1
  %add = fadd fast float %vecext, %vecext1
  %vecext3 = extractelement <4 x float> %a, i64 2
  %add5 = fadd fast float %add, %vecext3
  %vecext6 = extractelement <4 x float> %a, i64 3
  %add8 = fadd fast float %add5, %vecext6
  ret float %add8
}

define float @fp32_reduce_mixed_fmf(<4 x float> %a) {
; CHECK-LABEL: define float @fp32_reduce_mixed_fmf(
; CHECK-SAME: <4 x float> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD8:%.*]] = call nsz float @llvm.vector.reduce.fadd.v4f32(float -0.000000e+00, <4 x float> [[A]])
; CHECK-NEXT:    ret float [[ADD8]]
;
  %vecext = extractelement <4 x float> %a, i64 0
  %vecext1 = extractelement <4 x float> %a, i64 1
  %add = fadd fast float %vecext, %vecext1
  %vecext3 = extractelement <4 x float> %a, i64 2
  %add5 = fadd nsz float %add, %vecext3
  %vecext6 = extractelement <4 x float> %a, i64 3
  %add8 = fadd fast float %add5, %vecext6
  ret float %add8
}

; Negative test: the lanes must be added in-order.
define float @fp32_reduce_out_of_order(<4 x float> %a) {
; CHECK-LABEL: define float @fp32_reduce_out_of_order(
; CHECK-SAME: <4 x float> [[A:%.*]]) {
; CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x float> [[A]], i64 0
; CHECK-NEXT:    [[VECEXT1:%.*]] = extractelement <4 x float> [[A]], i64 2
; CHECK-NEXT:    [[ADD:%.*]] = fadd float [[VECEXT]], [[VECEXT1]]
; CHECK-NEXT:    [[VECEXT3:%.*]] = extractelement <4 x float> [[A]], i64 1
; CHECK-NEXT:    [[ADD5:%.*]] = fadd float [[ADD]], [[VECEXT3]]
; CHECK-NEXT:    [[VECEXT6:%.*]] = extractelement <4 x float> [[A]], i64 3
; CHECK-NEXT:    [[ADD8:%.*]] = fadd float [[ADD5]], [[VECEXT6]]
; CHECK-NEXT:    ret float [[ADD8]]
;
  %vecext = extractelement <4 x float> %a, i64 0
  %vecext1 = extractelement <4 x float> %a, i64 2
  %add = fadd float %vecext, %vecext1
  %vecext3 = extractelement <4 x float> %a, i64 1
  %add5 = fadd float %add, %vecext3
  %vecext6 = extractelement <4 x float> %a, i64 3
  %add8 = fadd float %add5, %vecext6
  ret float %add8
}

define double @float64_reduce_multiple_use_of_last_add(<2 x double> %a) {
; CHECK-LABEL: define double @float64_reduce_multiple_use_of_last_add(
; CHECK-SAME: <2 x double> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = call double @llvm.vector.reduce.fadd.v2f64(double -0.000000e+00, <2 x double> [[A]])
; CHECK-NEXT:    [[SUB:%.*]] = fadd double [[ADD]], -1.000000e+00
; CHECK-NEXT:    ret double [[SUB]]
;
  %vecext = extractelement <2 x double> %a, i64 0
  %vecext1 = extractelement <2 x double> %a, i64 1
  %add = fadd double %vecext, %vecext1
  %sub = fsub double %add, 1.0
  ret double %sub
}

; Negative test: multiple users of an intermediate value.
define float @fp32_reduce_multiple_use_of_intermediate_value(<4 x float> %a) {
; CHECK-LABEL: define float @fp32_reduce_multiple_use_of_intermediate_value(
; CHECK-SAME: <4 x float> [[A:%.*]]) {
; CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x float> [[A]], i64 0
; CHECK-NEXT:    [[VECEXT1:%.*]] = extractelement <4 x float> [[A]], i64 1
; CHECK-NEXT:    [[ADD:%.*]] = fadd float [[VECEXT]], [[VECEXT1]]
; CHECK-NEXT:    [[VECEXT3:%.*]] = extractelement <4 x float> [[A]], i64 2
; CHECK-NEXT:    [[ADD5:%.*]] = fadd float [[ADD]], [[VECEXT3]]
; CHECK-NEXT:    [[VECEXT6:%.*]] = extractelement <4 x float> [[A]], i64 3
; CHECK-NEXT:    [[ADD8:%.*]] = fadd float [[ADD5]], [[VECEXT6]]
; CHECK-NEXT:    [[RES:%.*]] = fadd float [[ADD8]], [[ADD5]]
; CHECK-NEXT:    ret float [[RES]]
;
  %vecext = extractelement <4 x float> %a, i64 0
  %vecext1 = extractelement <4 x float> %a, i64 1
  %add = fadd float %vecext, %vecext1
  %vecext3 = extractelement <4 x float> %a, i64 2
  %add5 = fadd float %add, %vecext3
  %vecext6 = extractelement <4 x float> %a, i64 3
  %add8 = fadd float %add5, %vecext6
  %res = fadd float %add8, %add5
  ret float %res
}

; Negative test: final fptrunc does not match element type
define float @fp16_reduce_mismatched_fptruc(<8 x half> %a) {
; CHECK-LABEL: define float @fp16_reduce_mismatched_fptruc(
; CHECK-SAME: <8 x half> [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <8 x half> [[A]], i64 0
; CHECK-NEXT:    [[VECEXT1:%.*]] = extractelement <8 x half> [[A]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = fpext half [[VECEXT]] to float
; CHECK-NEXT:    [[TMP1:%.*]] = fpext half [[VECEXT1]] to float
; CHECK-NEXT:    [[RES:%.*]] = fadd float [[TMP0]], [[TMP1]]
; CHECK-NEXT:    ret float [[RES]]
;
entry:
  %vecext = extractelement <8 x half> %a, i64 0
  %conv = fpext half %vecext to double
  %vecext1 = extractelement <8 x half> %a, i64 1
  %conv2 = fpext half %vecext1 to double
  %add = fadd double %conv, %conv2
  %res = fptrunc double %add to float
  ret float %res
}
