; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

define i32 @test_smin(i32 %arg0, i32 %arg1) {
; CHECK-LABEL: define i32 @test_smin(
; CHECK-SAME: i32 [[ARG0:%.*]], i32 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = icmp slt i32 [[ARG0]], [[ARG1]]
; CHECK-NEXT:    [[V3:%.*]] = zext i1 [[TMP1]] to i32
; CHECK-NEXT:    ret i32 [[V3]]
;
  %v0 = tail call i32 @llvm.smin.i32(i32 %arg0, i32 %arg1)
  %v1 = add nsw i32 %arg0, 1
  %v2 = tail call i32 @llvm.smin.i32(i32 %v1, i32 %arg1)
  %v3 = sub i32 %v2, %v0
  ret i32 %v3
}

define i32 @test_umin(i32 %arg0, i32 %arg1) {
; CHECK-LABEL: define i32 @test_umin(
; CHECK-SAME: i32 [[ARG0:%.*]], i32 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[ARG0]], [[ARG1]]
; CHECK-NEXT:    [[V3:%.*]] = zext i1 [[TMP1]] to i32
; CHECK-NEXT:    ret i32 [[V3]]
;
  %v0 = tail call i32 @llvm.umin.i32(i32 %arg0, i32 %arg1)
  %v1 = add nuw i32 %arg0, 1
  %v2 = tail call i32 @llvm.umin.i32(i32 %v1, i32 %arg1)
  %v3 = sub i32 %v2, %v0
  ret i32 %v3
}

define i1 @test_smin_i1(i1 %arg0, i1 %arg1) {
; CHECK-LABEL: define i1 @test_smin_i1(
; CHECK-SAME: i1 [[ARG0:%.*]], i1 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[V0:%.*]] = or i1 [[ARG0]], [[ARG1]]
; CHECK-NEXT:    [[V3:%.*]] = xor i1 [[V0]], true
; CHECK-NEXT:    ret i1 [[V3]]
;
  %v0 = tail call i1 @llvm.smin.i1(i1 %arg0, i1 %arg1)
  %v1 = add nsw i1 %arg0, 1
  %v2 = tail call i1 @llvm.smin.i1(i1 %v1, i1 %arg1)
  %v3 = sub i1 %v2, %v0
  ret i1 %v3
}

declare void @use(i2)

define i2 @test_smin_use_operands(i2 %arg0, i2 %arg1) {
; CHECK-LABEL: define i2 @test_smin_use_operands(
; CHECK-SAME: i2 [[ARG0:%.*]], i2 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[V0:%.*]] = tail call i2 @llvm.smin.i2(i2 [[ARG0]], i2 [[ARG1]])
; CHECK-NEXT:    [[V1:%.*]] = add nsw i2 [[ARG0]], 1
; CHECK-NEXT:    [[V2:%.*]] = tail call i2 @llvm.smin.i2(i2 [[V1]], i2 [[ARG1]])
; CHECK-NEXT:    [[V3:%.*]] = sub i2 [[V2]], [[V0]]
; CHECK-NEXT:    call void @use(i2 [[V2]])
; CHECK-NEXT:    call void @use(i2 [[V0]])
; CHECK-NEXT:    ret i2 [[V3]]
;
  %v0 = tail call i2 @llvm.smin.i2(i2 %arg0, i2 %arg1)
  %v1 = add nsw i2 %arg0, 1
  %v2 = tail call i2 @llvm.smin.i2(i2 %v1, i2 %arg1)
  %v3 = sub i2 %v2, %v0
  call void @use(i2 %v2)
  call void @use(i2 %v0)
  ret i2 %v3
}

define i2 @test_smin_use_operand(i2 %arg0, i2 %arg1) {
; CHECK-LABEL: define i2 @test_smin_use_operand(
; CHECK-SAME: i2 [[ARG0:%.*]], i2 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = add nsw i2 [[ARG0]], 1
; CHECK-NEXT:    [[V2:%.*]] = tail call i2 @llvm.smin.i2(i2 [[V1]], i2 [[ARG1]])
; CHECK-NEXT:    [[TMP1:%.*]] = icmp slt i2 [[ARG0]], [[ARG1]]
; CHECK-NEXT:    [[V3:%.*]] = zext i1 [[TMP1]] to i2
; CHECK-NEXT:    call void @use(i2 [[V2]])
; CHECK-NEXT:    ret i2 [[V3]]
;
  %v0 = tail call i2 @llvm.smin.i2(i2 %arg0, i2 %arg1)
  %v1 = add nsw i2 %arg0, 1
  %v2 = tail call i2 @llvm.smin.i2(i2 %v1, i2 %arg1)
  %v3 = sub i2 %v2, %v0
  call void @use(i2 %v2)
  ret i2 %v3
}

define i32 @test_smin_missing_nsw(i32 %arg0, i32 %arg1) {
; CHECK-LABEL: define i32 @test_smin_missing_nsw(
; CHECK-SAME: i32 [[ARG0:%.*]], i32 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[V0:%.*]] = tail call i32 @llvm.smin.i32(i32 [[ARG0]], i32 [[ARG1]])
; CHECK-NEXT:    [[V1:%.*]] = add i32 [[ARG0]], 1
; CHECK-NEXT:    [[V2:%.*]] = tail call i32 @llvm.smin.i32(i32 [[V1]], i32 [[ARG1]])
; CHECK-NEXT:    [[V3:%.*]] = sub i32 [[V2]], [[V0]]
; CHECK-NEXT:    ret i32 [[V3]]
;
  %v0 = tail call i32 @llvm.smin.i32(i32 %arg0, i32 %arg1)
  %v1 = add i32 %arg0, 1
  %v2 = tail call i32 @llvm.smin.i32(i32 %v1, i32 %arg1)
  %v3 = sub i32 %v2, %v0
  ret i32 %v3
}

define i32 @test_umin_missing_nuw(i32 %arg0, i32 %arg1) {
; CHECK-LABEL: define i32 @test_umin_missing_nuw(
; CHECK-SAME: i32 [[ARG0:%.*]], i32 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[V0:%.*]] = tail call i32 @llvm.umin.i32(i32 [[ARG0]], i32 [[ARG1]])
; CHECK-NEXT:    [[V1:%.*]] = add i32 [[ARG0]], 1
; CHECK-NEXT:    [[V2:%.*]] = tail call i32 @llvm.umin.i32(i32 [[V1]], i32 [[ARG1]])
; CHECK-NEXT:    [[V3:%.*]] = sub i32 [[V2]], [[V0]]
; CHECK-NEXT:    ret i32 [[V3]]
;
  %v0 = tail call i32 @llvm.umin.i32(i32 %arg0, i32 %arg1)
  %v1 = add i32 %arg0, 1
  %v2 = tail call i32 @llvm.umin.i32(i32 %v1, i32 %arg1)
  %v3 = sub i32 %v2, %v0
  ret i32 %v3
}

@tmp = external global i32

define i32 @test_mismatched_operands(i32 %arg0, i32 %arg1) {
; CHECK-LABEL: define i32 @test_mismatched_operands(
; CHECK-SAME: i32 [[ARG0:%.*]], i32 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[TMP:%.*]] = load i32, ptr @tmp, align 4
; CHECK-NEXT:    [[V0:%.*]] = tail call i32 @llvm.smin.i32(i32 [[ARG0]], i32 [[TMP]])
; CHECK-NEXT:    [[V1:%.*]] = add nsw i32 [[ARG0]], 1
; CHECK-NEXT:    [[V2:%.*]] = tail call i32 @llvm.smin.i32(i32 [[V1]], i32 [[ARG1]])
; CHECK-NEXT:    [[V3:%.*]] = sub i32 [[V2]], [[V0]]
; CHECK-NEXT:    ret i32 [[V3]]
;
  %tmp = load i32, ptr @tmp, align 4
  %v0 = tail call i32 @llvm.smin.i32(i32 %arg0, i32 %tmp)
  %v1 = add nsw i32 %arg0, 1
  %v2 = tail call i32 @llvm.smin.i32(i32 %v1, i32 %arg1)
  %v3 = sub i32 %v2, %v0
  ret i32 %v3
}

define i32 @test_disjoint_or(i32 %arg0, i32 %arg1) {
; CHECK-LABEL: define i32 @test_disjoint_or(
; CHECK-SAME: i32 [[ARG0:%.*]], i32 [[ARG1:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = icmp slt i32 [[ARG0]], [[ARG1]]
; CHECK-NEXT:    [[V3:%.*]] = zext i1 [[TMP1]] to i32
; CHECK-NEXT:    ret i32 [[V3]]
;
  %v0 = tail call i32 @llvm.smin.i32(i32 %arg0, i32 %arg1)
  %v1 = or disjoint i32 %arg0, 1
  %v2 = tail call i32 @llvm.smin.i32(i32 %v1, i32 %arg1)
  %v3 = sub i32 %v2, %v0
  ret i32 %v3
}
