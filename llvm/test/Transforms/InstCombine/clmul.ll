; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

declare i8 @llvm.clmul.i8(i8 %a, i8 %b)
declare i16 @llvm.clmul.i16(i16 %a, i16 %b)
declare i32 @llvm.clmul.i32(i32 %a, i32 %b)
declare i64 @llvm.clmul.i64(i64 %a, i64 %b)
declare <2 x i32> @llvm.clmul.v2i32(<2 x i32> %a, <2 x i32> %b)
declare <4 x i32> @llvm.clmul.v4i32(<4 x i32> %a, <4 x i32> %b)

; Test constant folding

define i8 @clmul_i8_const() {
; CHECK-LABEL: @clmul_i8_const(
; CHECK-NEXT:    ret i8 14
;
  %result = call i8 @llvm.clmul.i8(i8 5, i8 6)
  ret i8 %result
}

define i16 @clmul_i16_const() {
; CHECK-LABEL: @clmul_i16_const(
; CHECK-NEXT:    ret i16 158
;
  ; clmul(15, 13) = clmul(0b1111, 0b1101) = 0b10011110 = 158
  %result = call i16 @llvm.clmul.i16(i16 15, i16 13)
  ret i16 %result
}

define i32 @clmul_i32_const() {
; CHECK-LABEL: @clmul_i32_const(
; CHECK-NEXT:    ret i32 14
;
  %result = call i32 @llvm.clmul.i32(i32 5, i32 6)
  ret i32 %result
}

define i64 @clmul_i64_const() {
; CHECK-LABEL: @clmul_i64_const(
; CHECK-NEXT:    ret i64 398
;
  ; clmul(31, 17) = clmul(0b11111, 0b10001) = 0b110001110 = 398
  %result = call i64 @llvm.clmul.i64(i64 31, i64 17) 
  ret i64 %result
}

; Test zero operands

define i32 @clmul_zero_left(i32 %a) {
; CHECK-LABEL: @clmul_zero_left(
; CHECK-NEXT:    ret i32 0
;
  %result = call i32 @llvm.clmul.i32(i32 0, i32 %a)
  ret i32 %result
}

define i32 @clmul_zero_right(i32 %a) {
; CHECK-LABEL: @clmul_zero_right(
; CHECK-NEXT:    ret i32 0
;
  %result = call i32 @llvm.clmul.i32(i32 %a, i32 0)
  ret i32 %result
}

; Test identity (multiply by 1)

define i32 @clmul_identity_left(i32 %a) {
; CHECK-LABEL: @clmul_identity_left(
; CHECK-NEXT:    ret i32 [[A:%.*]]
;
  %result = call i32 @llvm.clmul.i32(i32 1, i32 %a)
  ret i32 %result
}

define i32 @clmul_identity_right(i32 %a) {
; CHECK-LABEL: @clmul_identity_right(
; CHECK-NEXT:    ret i32 [[A:%.*]]
;
  %result = call i32 @llvm.clmul.i32(i32 %a, i32 1)
  ret i32 %result
}

; Test with vector constants

define <2 x i32> @clmul_v2i32_const() {
; CHECK-LABEL: @clmul_v2i32_const(
; CHECK-NEXT:    ret <2 x i32> <i32 14, i32 6>
;
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> <i32 5, i32 2>, <2 x i32> <i32 6, i32 3>)
  ret <2 x i32> %result
}

define <2 x i32> @clmul_v2i32_zero_left(<2 x i32> %a) {
; CHECK-LABEL: @clmul_v2i32_zero_left(
; CHECK-NEXT:    ret <2 x i32> zeroinitializer
;
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> zeroinitializer, <2 x i32> %a)
  ret <2 x i32> %result
}

define <2 x i32> @clmul_v2i32_zero_right(<2 x i32> %a) {
; CHECK-LABEL: @clmul_v2i32_zero_right(
; CHECK-NEXT:    ret <2 x i32> zeroinitializer
;
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> %a, <2 x i32> zeroinitializer)
  ret <2 x i32> %result
}

define <2 x i32> @clmul_v2i32_identity_left(<2 x i32> %a) {
; CHECK-LABEL: @clmul_v2i32_identity_left(
; CHECK-NEXT:    ret <2 x i32> [[A:%.*]]
;
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> <i32 1, i32 1>, <2 x i32> %a)
  ret <2 x i32> %result
}

define <2 x i32> @clmul_v2i32_identity_right(<2 x i32> %a) {
; CHECK-LABEL: @clmul_v2i32_identity_right(
; CHECK-NEXT:    ret <2 x i32> [[A:%.*]]
;
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> %a, <2 x i32> <i32 1, i32 1>)
  ret <2 x i32> %result
}

; Test commutativity - this should be optimized to 0

define i32 @clmul_commutative_cancel(i32 %a, i32 %b) {
; CHECK-LABEL: @clmul_commutative_cancel(
; CHECK-NEXT:    ret i32 0
;
  %result1 = call i32 @llvm.clmul.i32(i32 %a, i32 %b)
  %result2 = call i32 @llvm.clmul.i32(i32 %b, i32 %a)
  %xor = xor i32 %result1, %result2
  ret i32 %xor
}

; Test partial evaluation with mixed constants and variables

define i32 @clmul_partial_const(i32 %a) {
; CHECK-LABEL: @clmul_partial_const(
; CHECK-NEXT:    [[RESULT:%.*]] = call i32 @llvm.clmul.i32(i32 [[A:%.*]], i32 5)
; CHECK-NEXT:    ret i32 [[RESULT]]
;
  %result = call i32 @llvm.clmul.i32(i32 %a, i32 5)
  ret i32 %result
}

; Test with specific known values for manual verification

define i8 @clmul_i8_manual_check1() {
; CHECK-LABEL: @clmul_i8_manual_check1(
; CHECK-NEXT:    ret i8 2
;
  ; clmul(1, 2) = clmul(0b1, 0b10) = 0b10 = 2
  %result = call i8 @llvm.clmul.i8(i8 1, i8 2)
  ret i8 %result
}

define i8 @clmul_i8_manual_check2() {
; CHECK-LABEL: @clmul_i8_manual_check2(
; CHECK-NEXT:    ret i8 6
;
  ; clmul(2, 3) = clmul(0b10, 0b11) = 0b110 = 6
  %result = call i8 @llvm.clmul.i8(i8 2, i8 3)
  ret i8 %result
}

define i8 @clmul_i8_manual_check3() {
; CHECK-LABEL: @clmul_i8_manual_check3(
; CHECK-NEXT:    ret i8 -64
;
  ; clmul(12, 12) = clmul(0b1100, 0b1100) = 0b11000000 = 192 = -64 (i8)
  %result = call i8 @llvm.clmul.i8(i8 12, i8 12)
  ret i8 %result
}