; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s
target datalayout = "E-p:64:64:64-p1:64:64:64-a0:0:8-f32:32:32-f64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-v64:64:64-v128:128:128"

define i1 @f(i1 %x) {
; CHECK-LABEL: @f(
; CHECK-NEXT:    ret i1 false
;
  %c = icmp eq ptr inttoptr (i32 1 to ptr), inttoptr (i32 2 to ptr)
  %b = and i1 %x, %c
  ret i1 %b
}

define i1 @f_logical(i1 %x) {
; CHECK-LABEL: @f_logical(
; CHECK-NEXT:    ret i1 false
;
  %c = icmp eq ptr inttoptr (i32 1 to ptr), inttoptr (i32 2 to ptr)
  %b = select i1 %x, i1 %c, i1 false
  ret i1 %b
}

define i32 @g(i32 %x) {
; CHECK-LABEL: @g(
; CHECK-NEXT:    ret i32 [[X:%.*]]
;
  %c = icmp eq ptr inttoptr (i32 1 to ptr), inttoptr (i32 2 to ptr)
  %ext = zext i1 %c to i32
  %b = add i32 %x, %ext
  ret i32 %b
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp(ptr %src, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp(
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[SRC:%.*]], i64 10
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2]], [[P:%.*]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  %c = icmp eq ptr %p, %p2
  ret i1 %c
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp_operands_swapped(ptr %src, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp_operands_swapped(
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[SRC:%.*]], i64 10
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2]], [[P:%.*]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 10, %i
  %p = inttoptr i64 %a to ptr
  %c = icmp eq ptr %p, %p2
  ret i1 %c
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp_constant_offset(ptr %src, i64 %off, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp_constant_offset(
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[SRC:%.*]], i64 [[OFF:%.*]]
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2]], [[P:%.*]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, %off
  %p = inttoptr i64 %a to ptr
  %c = icmp eq ptr %p, %p2
  ret i1 %c
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp_constant_offset_operands_swapped(ptr %src, i64 %off, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp_constant_offset_operands_swapped(
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[SRC:%.*]], i64 [[OFF:%.*]]
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2]], [[P:%.*]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %off, %i
  %p = inttoptr i64 %a to ptr
  %c = icmp eq ptr %p, %p2
  ret i1 %c
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp_different_src_address_spaces(ptr addrspace(1) %src, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp_different_src_address_spaces(
; CHECK-NEXT:    [[I:%.*]] = ptrtoint ptr addrspace(1) [[SRC:%.*]] to i64
; CHECK-NEXT:    [[A:%.*]] = add i64 [[I]], 10
; CHECK-NEXT:    [[P:%.*]] = inttoptr i64 [[A]] to ptr
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2:%.*]], [[P]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr addrspace(1) %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  %c = icmp eq ptr %p, %p2
  ret i1 %c
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp_different_dst_address_spaces(ptr %src, ptr addrspace(1) %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp_different_dst_address_spaces(
; CHECK-NEXT:    [[I:%.*]] = ptrtoint ptr [[SRC:%.*]] to i64
; CHECK-NEXT:    [[A:%.*]] = add i64 [[I]], 10
; CHECK-NEXT:    [[P:%.*]] = inttoptr i64 [[A]] to ptr addrspace(1)
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr addrspace(1) [[P2:%.*]], [[P]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr addrspace(1)
  %c = icmp eq ptr addrspace(1) %p, %p2
  ret i1 %c
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp_int_type_does_not_match_ptr_ty(ptr %src, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp_int_type_does_not_match_ptr_ty(
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[SRC:%.*]] to i64
; CHECK-NEXT:    [[I:%.*]] = trunc i64 [[TMP1]] to i8
; CHECK-NEXT:    [[A:%.*]] = add i8 [[I]], 10
; CHECK-NEXT:    [[TMP2:%.*]] = zext i8 [[A]] to i64
; CHECK-NEXT:    [[P:%.*]] = inttoptr i64 [[TMP2]] to ptr
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2:%.*]], [[P]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i8
  %a = add i8 %i, 10
  %p = inttoptr i8 %a to ptr
  %c = icmp eq ptr %p, %p2
  ret i1 %c
}

define i1 @inttoptr_add_multiple_users_ptrtoint_used_by_single_icmp(ptr %src, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_multiple_users_ptrtoint_used_by_single_icmp(
; CHECK-NEXT:    [[I:%.*]] = ptrtoint ptr [[SRC:%.*]] to i64
; CHECK-NEXT:    [[A:%.*]] = add i64 [[I]], 10
; CHECK-NEXT:    [[P:%.*]] = inttoptr i64 [[A]] to ptr
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2:%.*]], [[P]]
; CHECK-NEXT:    call void @bar(i64 [[A]])
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  %c = icmp eq ptr %p, %p2
  call void @bar(i64 %a)
  ret i1 %c
}

define i1 @multiple_inttoptr_add_ptrtoint_used_by_single_icmp(ptr %src) {
; CHECK-LABEL: @multiple_inttoptr_add_ptrtoint_used_by_single_icmp(
; CHECK-NEXT:    ret i1 false
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  %a.2 = add i64 %i, 11
  %p.2 = inttoptr i64 %a.2 to ptr
  %c = icmp eq ptr %p, %p.2
  ret i1 %c
}

define i1 @multiple_inttoptr_add_ptrtoint_used_by_single_icmp_non_constant_offset(ptr %src, i64 %off.1) {
; CHECK-LABEL: @multiple_inttoptr_add_ptrtoint_used_by_single_icmp_non_constant_offset(
; CHECK-NEXT:    ret i1 false
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  %a.2 = add i64 %i, 11
  %p.2 = inttoptr i64 %a.2 to ptr
  %c = icmp eq ptr %p, %p.2
  ret i1 %c
}

define i1 @multiple_inttoptr_add_ptrtoint_used_by_single_icmp_multiple_non_constant_offset(ptr %src, i64 %off.1, i64 %off.2) {
; CHECK-LABEL: @multiple_inttoptr_add_ptrtoint_used_by_single_icmp_multiple_non_constant_offset(
; CHECK-NEXT:    [[C:%.*]] = icmp eq i64 [[OFF_1:%.*]], [[OFF_2:%.*]]
; CHECK-NEXT:    ret i1 [[C]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, %off.1
  %p = inttoptr i64 %a to ptr
  %a.2 = add i64 %i, %off.2
  %p.2 = inttoptr i64 %a.2 to ptr
  %c = icmp eq ptr %p, %p.2
  ret i1 %c
}

define i1 @inttoptr_add_ptrtoint_used_by_single_icmp_in_different_bb(i1 %bc, ptr %src, ptr %p2) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_single_icmp_in_different_bb(
; CHECK-NEXT:    br i1 [[BC:%.*]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[SRC:%.*]], i64 10
; CHECK-NEXT:    [[C:%.*]] = icmp eq ptr [[P2]], [[P:%.*]]
; CHECK-NEXT:    ret i1 [[C]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  br i1 %bc, label %then, label %else

then:
  %c = icmp eq ptr %p, %p2
  ret i1 %c

else:
  ret i1 false
}

define i1 @inttoptr_add_ptrtoint_used_by_multiple_icmps(ptr %src, ptr %p2, ptr %p3) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_multiple_icmps(
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[SRC:%.*]], i64 10
; CHECK-NEXT:    [[C_1:%.*]] = icmp eq ptr [[P2]], [[P:%.*]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp eq ptr [[P2]], [[P3:%.*]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    ret i1 [[XOR]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  %c.1 = icmp eq ptr %p, %p2
  %c.2 = icmp eq ptr %p, %p3
  %xor = xor i1 %c.1, %c.2
  ret i1 %xor
}

declare void @foo(ptr)
declare void @bar(i64)

define i1 @inttoptr_add_ptrtoint_used_by_multiple_icmps_and_other_user(ptr %src, ptr %p2, ptr %p3) {
; CHECK-LABEL: @inttoptr_add_ptrtoint_used_by_multiple_icmps_and_other_user(
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[SRC:%.*]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = add i64 [[TMP1]], 10
; CHECK-NEXT:    [[P:%.*]] = inttoptr i64 [[TMP2]] to ptr
; CHECK-NEXT:    [[C_1:%.*]] = icmp eq ptr [[P2:%.*]], [[P]]
; CHECK-NEXT:    [[C_2:%.*]] = icmp eq ptr [[P3:%.*]], [[P]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    call void @foo(ptr [[P]])
; CHECK-NEXT:    ret i1 [[XOR]]
;
  %i = ptrtoint ptr %src to i64
  %a = add i64 %i, 10
  %p = inttoptr i64 %a to ptr
  %c.1 = icmp eq ptr %p, %p2
  %c.2 = icmp eq ptr %p, %p3
  %xor = xor i1 %c.1, %c.2
  call void @foo(ptr %p)
  ret i1 %xor
}

define i32 @h(i1 %A, i32 %B) {
; CHECK-LABEL: @h(
; CHECK-NEXT:  EntryBlock:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[B:%.*]], 2
; CHECK-NEXT:    [[OP:%.*]] = select i1 [[A:%.*]], i32 3, i32 [[TMP0]]
; CHECK-NEXT:    ret i32 [[OP]]
;
EntryBlock:
  %cf = select i1 %A, i32 1, i32 %B
  %op = add i32 2, %cf
  ret i32 %op
}

define <4 x float> @h1(i1 %A, <4 x i32> %B) {
; CHECK-LABEL: @h1(
; CHECK-NEXT:  EntryBlock:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x i32> [[B:%.*]] to <4 x float>
; CHECK-NEXT:    [[BC:%.*]] = select i1 [[A:%.*]], <4 x float> splat (float 0x36A0000000000000), <4 x float> [[TMP0]]
; CHECK-NEXT:    ret <4 x float> [[BC]]
;
EntryBlock:
  %cf = select i1 %A, <4 x i32> <i32 1, i32 1, i32 1, i32 1>, <4 x i32> %B
  %bc = bitcast <4 x i32> %cf to <4 x float>
  ret <4 x float> %bc
}

define <vscale x 4 x float> @h2(i1 %A, <vscale x 4 x i32> %B) {
; CHECK-LABEL: @h2(
; CHECK-NEXT:  EntryBlock:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <vscale x 4 x i32> [[B:%.*]] to <vscale x 4 x float>
; CHECK-NEXT:    [[BC:%.*]] = select i1 [[A:%.*]], <vscale x 4 x float> zeroinitializer, <vscale x 4 x float> [[TMP0]]
; CHECK-NEXT:    ret <vscale x 4 x float> [[BC]]
;
EntryBlock:
  %cf = select i1 %A, <vscale x 4 x i32> zeroinitializer, <vscale x 4 x i32> %B
  %bc = bitcast <vscale x 4 x i32> %cf to <vscale x 4 x float>
  ret <vscale x 4 x float> %bc
}

define <vscale x 2 x i64> @h3(i1 %A, <vscale x 4 x i32> %B) {
; CHECK-LABEL: @h3(
; CHECK-NEXT:  EntryBlock:
; CHECK-NEXT:    [[CF:%.*]] = select i1 [[A:%.*]], <vscale x 4 x i32> zeroinitializer, <vscale x 4 x i32> [[B:%.*]]
; CHECK-NEXT:    [[BC:%.*]] = bitcast <vscale x 4 x i32> [[CF]] to <vscale x 2 x i64>
; CHECK-NEXT:    ret <vscale x 2 x i64> [[BC]]
;
EntryBlock:
  %cf = select i1 %A, <vscale x 4 x i32> zeroinitializer, <vscale x 4 x i32> %B
  %bc = bitcast <vscale x 4 x i32> %cf to <vscale x 2 x i64>
  ret <vscale x 2 x i64> %bc

}

