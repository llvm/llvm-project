; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -instcombine-disable-insert-assume-icmp=false -S | FileCheck %s

target datalayout = "e-p:64:64:64-p1:16:16:16-p2:32:32:32-p3:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"

define void @generate_assume_ult(i16 %a) {
; CHECK-LABEL: define void @generate_assume_ult(
; CHECK-SAME: i16 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AND_:%.*]] = and i16 [[A]], -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i16 [[AND_]], 14
; CHECK-NEXT:    br i1 [[CMP]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i16 [[AND_]], 13
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    ret void
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp uge i16 [[AND_]], 16
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP1]])
; CHECK-NEXT:    ret void
;
entry:
  %and_ = and i16 %a, 65532
  %cmp = icmp ult i16 %and_, 14
  br i1 %cmp, label %t, label %f

t:
  ret void

f:
  ret void
}

define void @generate_assume_slt(i16 %a) {
; CHECK-LABEL: define void @generate_assume_slt(
; CHECK-SAME: i16 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AND_:%.*]] = and i16 [[A]], -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i16 [[AND_]], 14
; CHECK-NEXT:    br i1 [[CMP]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp slt i16 [[AND_]], 13
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    ret void
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp sge i16 [[AND_]], 16
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP1]])
; CHECK-NEXT:    ret void
;
entry:
  %and_ = and i16 %a, 65532
  %cmp = icmp slt i16 %and_, 14
  br i1 %cmp, label %t, label %f

t:
  ret void

f:
  ret void
}

define void @generate_assume_ugt(i16 %a) {
; CHECK-LABEL: define void @generate_assume_ugt(
; CHECK-SAME: i16 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AND_:%.*]] = and i16 [[A]], -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i16 [[AND_]], 14
; CHECK-NEXT:    br i1 [[CMP]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ugt i16 [[AND_]], 15
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    ret void
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ule i16 [[AND_]], 12
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP1]])
; CHECK-NEXT:    ret void
;
entry:
  %and_ = and i16 %a, 65532
  %cmp = icmp ugt i16 %and_, 14
  br i1 %cmp, label %t, label %f

t:
  ret void

f:
  ret void
}

define void @generate_assume_sgt(i16 %a) {
; CHECK-LABEL: define void @generate_assume_sgt(
; CHECK-SAME: i16 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AND_:%.*]] = and i16 [[A]], -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i16 [[AND_]], 14
; CHECK-NEXT:    br i1 [[CMP]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i16 [[AND_]], 15
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    ret void
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp sle i16 [[AND_]], 12
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP1]])
; CHECK-NEXT:    ret void
;
entry:
  %and_ = and i16 %a, 65532
  %cmp = icmp sgt i16 %and_, 14
  br i1 %cmp, label %t, label %f

t:
  ret void

f:
  ret void
}

define void @dont_generate_assume_t_ult(i16 %a) {
; CHECK-LABEL: define void @dont_generate_assume_t_ult(
; CHECK-SAME: i16 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AND_:%.*]] = and i16 [[A]], -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i16 [[AND_]], 13
; CHECK-NEXT:    br i1 [[CMP]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    ret void
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp uge i16 [[AND_]], 16
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    ret void
;
entry:
  %and_ = and i16 %a, 65532
  %cmp = icmp ult i16 %and_, 13
  br i1 %cmp, label %t, label %f

t:
  ret void

f:
  ret void
}

define void @dont_generate_assume_t_slt(i16 %a) {
; CHECK-LABEL: define void @dont_generate_assume_t_slt(
; CHECK-SAME: i16 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AND_:%.*]] = and i16 [[A]], -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i16 [[AND_]], 13
; CHECK-NEXT:    br i1 [[CMP]], label %[[T:.*]], label %[[F:.*]]
; CHECK:       [[T]]:
; CHECK-NEXT:    ret void
; CHECK:       [[F]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp sge i16 [[AND_]], 16
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    ret void
;
entry:
  %and_ = and i16 %a, 65532
  %cmp = icmp slt i16 %and_, 13
  br i1 %cmp, label %t, label %f

t:
  ret void

f:
  ret void
}

define void @multiple_branches_ult(i16 %a) {
; CHECK-LABEL: define void @multiple_branches_ult(
; CHECK-SAME: i16 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AND_:%.*]] = and i16 [[A]], -4
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i16 [[AND_]], 14
; CHECK-NEXT:    br i1 [[CMP]], label %[[T0:.*]], label %[[F0:.*]]
; CHECK:       [[T0]]:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i16 [[AND_]], 13
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    br label %[[BB:.*]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp uge i16 [[AND_]], 16
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP1]])
; CHECK-NEXT:    br label %[[BB]]
; CHECK:       [[BB]]:
; CHECK-NEXT:    br i1 [[CMP]], label %[[T1:.*]], label %[[F1:.*]]
; CHECK:       [[T1]]:
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i16 [[AND_]], 13
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP2]])
; CHECK-NEXT:    ret void
; CHECK:       [[F1]]:
; CHECK-NEXT:    [[TMP3:%.*]] = icmp uge i16 [[AND_]], 16
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP3]])
; CHECK-NEXT:    ret void
;
entry:
  %and_ = and i16 %a, 65532
  %cmp = icmp ult i16 %and_, 14
  br i1 %cmp, label %t0, label %f0

t0:
  br label %bb

f0:
  br label %bb

bb:
  br i1 %cmp, label %t1, label %f1

t1:
  ret void
f1:
  ret void
}
