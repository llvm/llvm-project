; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; Test for optimization: If (x & y) == y, then (x - y) == (x ^ y) == (x & ~y)
; The optimizer should choose the most efficient form for the target architecture

define i32 @test_sub_to_xor(i32 %x, i32 %y) {
; CHECK-LABEL: @test_sub_to_xor(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[RESULT:%.*]] = sub i32 [[X]], [[Y]]
; CHECK-NEXT:    ret i32 [[RESULT]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @abort()
; CHECK-NEXT:    unreachable
;
entry:
  %and = and i32 %x, %y
  %cmp = icmp eq i32 %and, %y
  br i1 %cmp, label %if.true, label %if.false

if.true:
  %sub = sub i32 %x, %y
  ret i32 %sub

if.false:
  call void @abort()
  unreachable
}

define i32 @test_xor_form(i32 %x, i32 %y) {
; CHECK-LABEL: @test_xor_form(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[RESULT:%.*]] = xor i32 [[X]], [[Y]]
; CHECK-NEXT:    ret i32 [[RESULT]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @abort()
; CHECK-NEXT:    unreachable
;
entry:
  %and = and i32 %x, %y
  %cmp = icmp eq i32 %and, %y
  br i1 %cmp, label %if.true, label %if.false

if.true:
  %xor = xor i32 %x, %y
  ret i32 %xor

if.false:
  call void @abort()
  unreachable
}

define i32 @test_and_not_form(i32 %x, i32 %y) {
; CHECK-LABEL: @test_and_not_form(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], [[Y]]
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[NOT_Y:%.*]] = xor i32 [[Y]], -1
; CHECK-NEXT:    [[RESULT:%.*]] = and i32 [[X]], [[NOT_Y]]
; CHECK-NEXT:    ret i32 [[RESULT]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @abort()
; CHECK-NEXT:    unreachable
;
entry:
  %and = and i32 %x, %y
  %cmp = icmp eq i32 %and, %y
  br i1 %cmp, label %if.true, label %if.false

if.true:
  %not_y = xor i32 %y, -1
  %and_not = and i32 %x, %not_y
  ret i32 %and_not

if.false:
  call void @abort()
  unreachable
}

; Test with immediate values to ensure the optimization works with constants
define i32 @test_with_constant(i32 %x) {
; CHECK-LABEL: @test_with_constant(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X:%.*]], 7
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[AND]], 7
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[RESULT:%.*]] = add nsw i32 [[X]], -7
; CHECK-NEXT:    ret i32 [[RESULT]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @abort()
; CHECK-NEXT:    unreachable
;
entry:
  %and = and i32 %x, 7
  %cmp = icmp eq i32 %and, 7
  br i1 %cmp, label %if.true, label %if.false

if.true:
  %sub = sub i32 %x, 7
  ret i32 %sub

if.false:
  call void @abort()
  unreachable
}

declare void @abort()
