; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

%foo = type { i16, i16, i16 }

define <16 x ptr> @test(i1 %tobool, i1 %end, <16 x i64> %varidx) {
; CHECK-LABEL: define <16 x ptr> @test(
; CHECK-SAME: i1 [[TOBOOL:%.*]], i1 [[END:%.*]], <16 x i64> [[VARIDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[LANE_0:%.*]] = alloca [[FOO:%.*]], align 16
; CHECK-NEXT:    [[LANE_15:%.*]] = insertelement <16 x ptr> poison, ptr [[LANE_0]], i64 0
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <16 x ptr> [ [[MM_VECTORGEP11:%.*]], %[[F0:.*]] ], [ [[MM_VECTORGEP22:%.*]], %[[F1:.*]] ], [ zeroinitializer, %[[ENTRY]] ]
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[F1]], label %[[F0]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    [[MM_VECTORGEP11_SPLIT:%.*]] = getelementptr inbounds [[FOO]], <16 x ptr> [[LANE_15]], <16 x i64> [[VARIDX]]
; CHECK-NEXT:    [[MM_VECTORGEP11]] = getelementptr inbounds i8, <16 x ptr> [[MM_VECTORGEP11_SPLIT]], i64 2
; CHECK-NEXT:    br i1 [[END]], label %[[LOOP]], label %[[MERGE:.*]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    [[MM_VECTORGEP22_SPLIT:%.*]] = getelementptr inbounds [[FOO]], <16 x ptr> [[LANE_15]], <16 x i64> [[VARIDX]]
; CHECK-NEXT:    [[MM_VECTORGEP22]] = getelementptr inbounds i8, <16 x ptr> [[MM_VECTORGEP22_SPLIT]], i64 4
; CHECK-NEXT:    br i1 [[END]], label %[[LOOP]], label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    ret <16 x ptr> [[VEC_PHI]]
;
entry:
  %lane.0 = alloca %foo, align 16
  %lane.15 = insertelement <16 x ptr> poison, ptr %lane.0, i64 0
  br label %loop

loop:
  %vec.phi = phi <16 x ptr> [ %mm_vectorGEP1, %f0], [ %mm_vectorGEP2, %f1 ], [ zeroinitializer, %entry]
  %mm_vectorGEP1 = getelementptr inbounds %foo, <16 x ptr> %lane.15, <16 x i64> %varidx, <16 x i32> splat (i32 1)
  %mm_vectorGEP2 = getelementptr inbounds %foo, <16 x ptr> %lane.15, <16 x i64> %varidx, <16 x i32> splat (i32 2)
  br i1 %tobool, label %f1, label %f0

f0:
  br i1 %end, label %loop, label %merge

f1:
  br i1 %end, label %loop, label %merge

merge:
  ret <16 x ptr> %vec.phi
}

define ptr @gep_constant_offset(i1 %cond, ptr %ptr) {
; CHECK-LABEL: define ptr @gep_constant_offset(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[F1:.*]], label %[[F0:.*]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    br label %[[MERGE:.*]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[DOTPN:%.*]] = phi i64 [ 16, %[[F0]] ], [ 32, %[[F1]] ]
; CHECK-NEXT:    [[PHI:%.*]] = getelementptr inbounds nuw i8, ptr [[PTR]], i64 [[DOTPN]]
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  %gep0 = getelementptr inbounds i8, ptr %ptr, i64 16
  %gep1 = getelementptr inbounds i8, ptr %ptr, i64 32
  br i1 %cond, label %f1, label %f0

f0:
  br label %merge

f1:
  br label %merge

merge:
  %phi = phi ptr [ %gep0, %f0], [ %gep1, %f1 ]
  ret ptr %phi
}

define ptr @gep_variable_offset(i1 %cond, ptr %ptr, i64 %off0, i64 %off1) {
; CHECK-LABEL: define ptr @gep_variable_offset(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[PTR:%.*]], i64 [[OFF0:%.*]], i64 [[OFF1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[F1:.*]], label %[[F0:.*]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    br label %[[MERGE:.*]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[OFF0_PN:%.*]] = phi i64 [ [[OFF0]], %[[F0]] ], [ [[OFF1]], %[[F1]] ]
; CHECK-NEXT:    [[PHI:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[OFF0_PN]]
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  %gep0 = getelementptr inbounds i8, ptr %ptr, i64 %off0
  %gep1 = getelementptr inbounds i8, ptr %ptr, i64 %off1
  br i1 %cond, label %f1, label %f0

f0:
  br label %merge

f1:
  br label %merge

merge:
  %phi = phi ptr [ %gep0, %f0], [ %gep1, %f1 ]
  ret ptr %phi
}

define ptr @gep_mixed_offset_1(i1 %cond, ptr %ptr, i64 %off1) {
; CHECK-LABEL: define ptr @gep_mixed_offset_1(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[PTR:%.*]], i64 [[OFF1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[F1:.*]], label %[[F0:.*]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    [[GEP0:%.*]] = getelementptr inbounds nuw i8, ptr [[PTR]], i64 16
; CHECK-NEXT:    br label %[[MERGE:.*]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[OFF1]]
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[GEP0]], %[[F0]] ], [ [[GEP1]], %[[F1]] ]
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  %gep0 = getelementptr inbounds i8, ptr %ptr, i64 16
  %gep1 = getelementptr inbounds i8, ptr %ptr, i64 %off1
  br i1 %cond, label %f1, label %f0

f0:
  br label %merge

f1:
  br label %merge

merge:
  %phi = phi ptr [ %gep0, %f0], [ %gep1, %f1 ]
  ret ptr %phi
}

define ptr @gep_mixed_offset_2(i1 %cond, ptr %ptr, i64 %off0) {
; CHECK-LABEL: define ptr @gep_mixed_offset_2(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[PTR:%.*]], i64 [[OFF0:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[COND]], label %[[F1:.*]], label %[[F0:.*]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    [[GEP0:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[OFF0]]
; CHECK-NEXT:    br label %[[MERGE:.*]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds nuw i8, ptr [[PTR]], i64 32
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[GEP0]], %[[F0]] ], [ [[GEP1]], %[[F1]] ]
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  %gep0 = getelementptr inbounds i8, ptr %ptr, i64 %off0
  %gep1 = getelementptr inbounds i8, ptr %ptr, i64 32
  br i1 %cond, label %f1, label %f0

f0:
  br label %merge

f1:
  br label %merge

merge:
  %phi = phi ptr [ %gep0, %f0], [ %gep1, %f1 ]
  ret ptr %phi
}

define ptr @struct_constant_offset(i1 %cond, %foo %ptr) {
; CHECK-LABEL: define ptr @struct_constant_offset(
; CHECK-SAME: i1 [[COND:%.*]], [[FOO:%.*]] [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LANE_0:%.*]] = alloca [[FOO]], align 16
; CHECK-NEXT:    br i1 [[COND]], label %[[F1:.*]], label %[[F0:.*]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    [[GEP0:%.*]] = getelementptr inbounds nuw i8, ptr [[LANE_0]], i64 6
; CHECK-NEXT:    br label %[[MERGE:.*]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds nuw i8, ptr [[LANE_0]], i64 12
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[GEP0]], %[[F0]] ], [ [[GEP1]], %[[F1]] ]
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  %lane.0 = alloca %foo, align 16
  %gep0 = getelementptr inbounds %foo, ptr %lane.0, i64 1
  %gep1 = getelementptr inbounds %foo, ptr %lane.0, i64 2
  br i1 %cond, label %f1, label %f0

f0:
  br label %merge

f1:
  br label %merge

merge:
  %phi = phi ptr [ %gep0, %f0], [ %gep1, %f1 ]
  ret ptr %phi
}

define ptr @gep_different_offset_types_canonicalized(i1 %cond, i1 %end, ptr %ptr, i64 %off0, i32 %off1) {
; CHECK-LABEL: define ptr @gep_different_offset_types_canonicalized(
; CHECK-SAME: i1 [[COND:%.*]], i1 [[END:%.*]], ptr [[PTR:%.*]], i64 [[OFF0:%.*]], i32 [[OFF1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = sext i32 [[OFF1]] to i64
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[OFF0_PN:%.*]] = phi i64 [ [[OFF0]], %[[F0:.*]] ], [ [[TMP0]], %[[F1:.*]] ], [ [[OFF0]], %[[ENTRY]] ]
; CHECK-NEXT:    br i1 [[COND]], label %[[F1]], label %[[F0]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    br i1 [[END]], label %[[MERGE:.*]], label %[[LOOP]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    br i1 [[END]], label %[[MERGE]], label %[[LOOP]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[PHI:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[OFF0_PN]]
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  %gep0 = getelementptr inbounds <3 x i8>, ptr %ptr, i64 0, i64 %off0
  %gep1 = getelementptr inbounds <3 x i8>, ptr %ptr, i64 0, i32 %off1
  br label %loop

loop:
  %phi = phi ptr [ %gep0, %f0 ], [ %gep1, %f1 ], [ %gep0, %entry ]
  br i1 %cond, label %f1, label %f0

f0:
  br i1 %end, label %merge, label %loop

f1:
  br i1 %end, label %merge, label %loop

merge:
  ret ptr %phi
}

define ptr @gep_different_offset_types_negative(i1 %cond, i1 %end, ptr %ptr, i64 %off0, i32 %off1) {
; CHECK-LABEL: define ptr @gep_different_offset_types_negative(
; CHECK-SAME: i1 [[COND:%.*]], i1 [[END:%.*]], ptr [[PTR:%.*]], i64 [[OFF0:%.*]], i32 [[OFF1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[GEP0:%.*]], %[[F0:.*]] ], [ [[GEP1:%.*]], %[[F1:.*]] ], [ null, %[[ENTRY]] ]
; CHECK-NEXT:    br i1 [[COND]], label %[[F1]], label %[[F0]]
; CHECK:       [[F0]]:
; CHECK-NEXT:    [[GEP0]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[OFF0]]
; CHECK-NEXT:    br i1 [[END]], label %[[MERGE:.*]], label %[[LOOP]]
; CHECK:       [[F1]]:
; CHECK-NEXT:    [[TMP0:%.*]] = sext i32 [[OFF1]] to i64
; CHECK-NEXT:    [[GEP1]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[TMP0]]
; CHECK-NEXT:    br i1 [[END]], label %[[MERGE]], label %[[LOOP]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    ret ptr [[PHI]]
;
entry:
  br label %loop

loop:
  %phi = phi ptr [ %gep0, %f0 ], [ %gep1, %f1 ], [ zeroinitializer, %entry ]
  %gep0 = getelementptr inbounds <3 x i8>, ptr %ptr, i64 0, i64 %off0
  %gep1 = getelementptr inbounds <3 x i8>, ptr %ptr, i64 0, i32 %off1
  br i1 %cond, label %f1, label %f0

f0:
  br i1 %end, label %merge, label %loop

f1:
  br i1 %end, label %merge, label %loop

merge:
  ret ptr %phi
}
