; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; (B ule ~A) && (A ugt ~B) -> false
; These conditions contradict each other.

define i1 @test_basic(i32 %a, i32 %b) {
; CHECK-LABEL: @test_basic(
; CHECK-NEXT:    ret i1 false
;
  %nota = xor i32 %a, -1
  %cmp1 = icmp ule i32 %b, %nota
  %notb = xor i32 %b, -1
  %cmp2 = icmp ugt i32 %a, %notb
  %ret = and i1 %cmp1, %cmp2
  ret i1 %ret
}

; Commuted: (A ugt ~B) && (B ule ~A) -> false
define i1 @test_commuted(i32 %a, i32 %b) {
; CHECK-LABEL: @test_commuted(
; CHECK-NEXT:    ret i1 false
;
  %nota = xor i32 %a, -1
  %notb = xor i32 %b, -1
  %cmp1 = icmp ugt i32 %a, %notb
  %cmp2 = icmp ule i32 %b, %nota
  %ret = and i1 %cmp1, %cmp2
  ret i1 %ret
}

; Different types: i64
define i1 @test_i64(i64 %a, i64 %b) {
; CHECK-LABEL: @test_i64(
; CHECK-NEXT:    ret i1 false
;
  %nota = xor i64 %a, -1
  %cmp1 = icmp ule i64 %b, %nota
  %notb = xor i64 %b, -1
  %cmp2 = icmp ugt i64 %a, %notb
  %ret = and i1 %cmp1, %cmp2
  ret i1 %ret
}

; Different types: i16
define i1 @test_i16(i16 %a, i16 %b) {
; CHECK-LABEL: @test_i16(
; CHECK-NEXT:    ret i1 false
;
  %nota = xor i16 %a, -1
  %cmp1 = icmp ule i16 %b, %nota
  %notb = xor i16 %b, -1
  %cmp2 = icmp ugt i16 %a, %notb
  %ret = and i1 %cmp1, %cmp2
  ret i1 %ret
}

; Negative test: OR instead of AND (should NOT fold)
define i1 @test_negative_or(i32 %a, i32 %b) {
; CHECK-LABEL: @test_negative_or(
; CHECK-NOT:     ret i1 false
;
  %nota = xor i32 %a, -1
  %cmp1 = icmp ule i32 %b, %nota
  %notb = xor i32 %b, -1
  %cmp2 = icmp ugt i32 %a, %notb
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Negative test: wrong predicate (ult instead of ule)
define i1 @test_negative_wrong_pred(i32 %a, i32 %b) {
; CHECK-LABEL: @test_negative_wrong_pred(
; CHECK-NOT:     ret i1 false
;
  %nota = xor i32 %a, -1
  %cmp1 = icmp ult i32 %b, %nota
  %notb = xor i32 %b, -1
  %cmp2 = icmp ugt i32 %a, %notb
  %ret = and i1 %cmp1, %cmp2
  ret i1 %ret
}
