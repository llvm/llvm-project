; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=instcombine %s | FileCheck %s

declare void @use.i32(i32)

define i64 @simple(i32 %x) {
; CHECK-LABEL: define i64 @simple(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i32 [[X]], 8
; CHECK-NEXT:    [[ZEXT:%.*]] = zext nneg i32 [[LSHR]] to i64
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw i64 [[ZEXT]], 32
; CHECK-NEXT:    ret i64 [[SHL]]
;
  %lshr = lshr i32 %x, 8
  %zext = zext i32 %lshr to i64
  %shl = shl i64 %zext, 32
  ret i64 %shl
}

define <2 x i64> @simple.vec(<2 x i32> %v) {
; CHECK-LABEL: define <2 x i64> @simple.vec(
; CHECK-SAME: <2 x i32> [[V:%.*]]) {
; CHECK-NEXT:    [[LSHR:%.*]] = lshr <2 x i32> [[V]], splat (i32 8)
; CHECK-NEXT:    [[ZEXT:%.*]] = zext nneg <2 x i32> [[LSHR]] to <2 x i64>
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw <2 x i64> [[ZEXT]], splat (i64 32)
; CHECK-NEXT:    ret <2 x i64> [[SHL]]
;
  %lshr = lshr <2 x i32> %v, splat(i32 8)
  %zext = zext <2 x i32> %lshr to <2 x i64>
  %shl = shl <2 x i64> %zext, splat(i64 32)
  ret <2 x i64> %shl
}

;; u0xff0 = 4080
define i64 @masked(i32 %x) {
; CHECK-LABEL: define i64 @masked(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    [[MASK:%.*]] = and i32 [[X]], 4080
; CHECK-NEXT:    [[ZEXT:%.*]] = zext nneg i32 [[MASK]] to i64
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw i64 [[ZEXT]], 44
; CHECK-NEXT:    ret i64 [[SHL]]
;
  %lshr = lshr i32 %x, 4
  %mask = and i32 %lshr, u0xff
  %zext = zext i32 %mask to i64
  %shl = shl i64 %zext, 48
  ret i64 %shl
}

define i64 @masked.multi_use.0(i32 %x) {
; CHECK-LABEL: define i64 @masked.multi_use.0(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i32 [[X]], 4
; CHECK-NEXT:    call void @use.i32(i32 [[LSHR]])
; CHECK-NEXT:    [[MASK:%.*]] = and i32 [[LSHR]], 255
; CHECK-NEXT:    [[ZEXT:%.*]] = zext nneg i32 [[MASK]] to i64
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw i64 [[ZEXT]], 48
; CHECK-NEXT:    ret i64 [[SHL]]
;
  %lshr = lshr i32 %x, 4
  call void @use.i32(i32 %lshr)
  %mask = and i32 %lshr, u0xff
  %zext = zext i32 %mask to i64
  %shl = shl i64 %zext, 48
  ret i64 %shl
}

define i64 @masked.multi_use.1(i32 %x) {
; CHECK-LABEL: define i64 @masked.multi_use.1(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i32 [[X]], 4
; CHECK-NEXT:    [[MASK:%.*]] = and i32 [[LSHR]], 255
; CHECK-NEXT:    call void @use.i32(i32 [[MASK]])
; CHECK-NEXT:    [[ZEXT:%.*]] = zext nneg i32 [[MASK]] to i64
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw i64 [[ZEXT]], 48
; CHECK-NEXT:    ret i64 [[SHL]]
;
  %lshr = lshr i32 %x, 4
  %mask = and i32 %lshr, u0xff
  call void @use.i32(i32 %mask)
  %zext = zext i32 %mask to i64
  %shl = shl i64 %zext, 48
  ret i64 %shl
}

define <2 x i64> @masked.multi_use.2(i32 %x) {
; CHECK-LABEL: define <2 x i64> @masked.multi_use.2(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:    [[LSHR:%.*]] = lshr i32 [[X]], 4
; CHECK-NEXT:    [[MASK:%.*]] = and i32 [[LSHR]], 255
; CHECK-NEXT:    [[ZEXT:%.*]] = zext nneg i32 [[MASK]] to i64
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw i64 [[ZEXT]], 48
; CHECK-NEXT:    [[USE:%.*]] = xor i32 [[MASK]], 255
; CHECK-NEXT:    [[USE_Z:%.*]] = zext nneg i32 [[USE]] to i64
; CHECK-NEXT:    [[V_0:%.*]] = insertelement <2 x i64> poison, i64 [[SHL]], i64 0
; CHECK-NEXT:    [[V_1:%.*]] = insertelement <2 x i64> [[V_0]], i64 [[USE_Z]], i64 1
; CHECK-NEXT:    ret <2 x i64> [[V_1]]
;
  %lshr = lshr i32 %x, 4
  %mask = and i32 %lshr, u0xff
  %zext = zext i32 %mask to i64
  %shl = shl i64 %zext, 48

  %use = xor i32 %mask, u0xff
  %use.z = zext i32 %use to i64
  %v.0 = insertelement <2 x i64> poison, i64 %shl, i32 0
  %v.1 = insertelement <2 x i64> %v.0, i64 %use.z, i32 1
  ret <2 x i64> %v.1
}

;; u0xff0 = 4080
define <2 x i64> @masked.vec(<2 x i32> %v) {
; CHECK-LABEL: define <2 x i64> @masked.vec(
; CHECK-SAME: <2 x i32> [[V:%.*]]) {
; CHECK-NEXT:    [[MASK:%.*]] = and <2 x i32> [[V]], splat (i32 4080)
; CHECK-NEXT:    [[ZEXT:%.*]] = zext nneg <2 x i32> [[MASK]] to <2 x i64>
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw nsw <2 x i64> [[ZEXT]], splat (i64 44)
; CHECK-NEXT:    ret <2 x i64> [[SHL]]
;
  %lshr = lshr <2 x i32> %v, splat(i32 4)
  %mask = and <2 x i32> %lshr, splat(i32 u0xff)
  %zext = zext <2 x i32> %mask to <2 x i64>
  %shl = shl <2 x i64> %zext, splat(i64 48)
  ret <2 x i64> %shl
}

define i64 @combine(i32 %lower, i32 %upper) {
; CHECK-LABEL: define i64 @combine(
; CHECK-SAME: i32 [[LOWER:%.*]], i32 [[UPPER:%.*]]) {
; CHECK-NEXT:    [[BASE:%.*]] = zext i32 [[LOWER]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[UPPER]], 16777215
; CHECK-NEXT:    [[TMP2:%.*]] = zext nneg i32 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = shl nuw nsw i64 [[TMP2]], 32
; CHECK-NEXT:    [[O_2:%.*]] = or disjoint i64 [[TMP3]], [[BASE]]
; CHECK-NEXT:    [[R_3:%.*]] = lshr i32 [[UPPER]], 24
; CHECK-NEXT:    [[Z_3:%.*]] = zext nneg i32 [[R_3]] to i64
; CHECK-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 56
; CHECK-NEXT:    [[O_3:%.*]] = or disjoint i64 [[O_2]], [[S_3]]
; CHECK-NEXT:    ret i64 [[O_3]]
;
  %base = zext i32 %lower to i64

  %u.0 = and i32 %upper, u0xff
  %z.0 = zext i32 %u.0 to i64
  %s.0 = shl i64 %z.0, 32
  %o.0 = or i64 %base, %s.0

  %r.1 = lshr i32 %upper, 8
  %u.1 = and i32 %r.1, u0xff
  %z.1 = zext i32 %u.1 to i64
  %s.1 = shl i64 %z.1, 40
  %o.1 = or i64 %o.0, %s.1

  %r.2 = lshr i32 %upper, 16
  %u.2 = and i32 %r.2, u0xff
  %z.2 = zext i32 %u.2 to i64
  %s.2 = shl i64 %z.2, 48
  %o.2 = or i64 %o.1, %s.2

  %r.3 = lshr i32 %upper, 24
  %u.3 = and i32 %r.3, u0xff
  %z.3 = zext i32 %u.3 to i64
  %s.3 = shl i64 %z.3, 56
  %o.3 = or i64 %o.2, %s.3

  ret i64 %o.3
}
