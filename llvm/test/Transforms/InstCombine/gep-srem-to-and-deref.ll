; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes=instcombine %s -S | FileCheck %s

;NOTE: tests InstCombine transform the following pattern:
;   %idx = srem i64 %x, 2^k
; from a dereferenceable(2^k) base, into:
;   %idx = and i64 %x, (2^k-1)

define ptr @pos_pow2_2(ptr dereferenceable(2) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @pos_pow2_2(
; CHECK-SAME: ptr dereferenceable(2) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX_MASK:%.*]] = and i64 [[X]], 1
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX_MASK]]
; CHECK-NEXT:    ret ptr [[P1]]
;
  %idx = srem i64 %x, 2
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

define ptr @pos_pow2_4(ptr dereferenceable(4) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @pos_pow2_4(
; CHECK-SAME: ptr dereferenceable(4) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX_MASK:%.*]] = and i64 [[X]], 3
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX_MASK]]
; CHECK-NEXT:    ret ptr [[P1]]
;
  %idx = srem i64 %x, 4
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

define ptr @pos_pow2_8_exact(ptr dereferenceable(8) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @pos_pow2_8_exact(
; CHECK-SAME: ptr dereferenceable(8) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX_MASK:%.*]] = and i64 [[X]], 7
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX_MASK]]
; CHECK-NEXT:    ret ptr [[P1]]
;
  %idx = srem i64 %x, 8
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

; dereferenceable(64) implies dereferenceable(8)
define ptr @pos_pow2_8_more_deref(ptr dereferenceable(64) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @pos_pow2_8_more_deref(
; CHECK-SAME: ptr dereferenceable(64) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX_MASK:%.*]] = and i64 [[X]], 7
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX_MASK]]
; CHECK-NEXT:    ret ptr [[P1]]
;
  %idx = srem i64 %x, 8
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

; srem x, 1 is always 0, and mask is 0. GEP should be folded to %foo.
define ptr @pos_pow2_1(ptr dereferenceable(1) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @pos_pow2_1(
; CHECK-SAME: ptr dereferenceable(1) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    ret ptr [[FOO]]
;
  %idx = srem i64 %x, 1
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

; Non-power-of-two constant divisor
define ptr @neg_non_pow2_6(ptr dereferenceable(6) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @neg_non_pow2_6(
; CHECK-SAME: ptr dereferenceable(6) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX:%.*]] = srem i64 [[X]], 6
; CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX]]
; CHECK-NEXT:    ret ptr [[P]]
;
  %idx = srem i64 %x, 6
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

; Missing 'no unsigned wrap'
define ptr @neg_missing_nuw(ptr dereferenceable(4) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @neg_missing_nuw(
; CHECK-SAME: ptr dereferenceable(4) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX:%.*]] = srem i64 [[X]], 4
; CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds i8, ptr [[FOO]], i64 [[IDX]]
; CHECK-NEXT:    ret ptr [[P]]
;
  %idx = srem i64 %x, 4
  %p = getelementptr inbounds i8, ptr %foo, i64 %idx
  ret ptr %p
}

; Missing 'inbounds'
define ptr @neg_missing_inbounds(ptr dereferenceable(4) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @neg_missing_inbounds(
; CHECK-SAME: ptr dereferenceable(4) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX:%.*]] = srem i64 [[X]], 4
; CHECK-NEXT:    [[P:%.*]] = getelementptr nuw i8, ptr [[FOO]], i64 [[IDX]]
; CHECK-NEXT:    ret ptr [[P]]
;
  %idx = srem i64 %x, 4
  %p = getelementptr nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

; Base dereferenceable is too small
define ptr @neg_deref_too_small(ptr dereferenceable(3) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @neg_deref_too_small(
; CHECK-SAME: ptr dereferenceable(3) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX:%.*]] = srem i64 [[X]], 4
; CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX]]
; CHECK-NEXT:    ret ptr [[P]]
;
  %idx = srem i64 %x, 4
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

define ptr @neg_deref_or_null(ptr dereferenceable_or_null(4) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @neg_deref_or_null(
; CHECK-SAME: ptr dereferenceable_or_null(4) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX:%.*]] = srem i64 [[X]], 4
; CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX]]
; CHECK-NEXT:    ret ptr [[P]]
;
  %idx = srem i64 %x, 4
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

define ptr @neg_nonconst_divisor(ptr dereferenceable(8) %foo, i64 noundef %x, i64 noundef %d) {
; CHECK-LABEL: define ptr @neg_nonconst_divisor(
; CHECK-SAME: ptr dereferenceable(8) [[FOO:%.*]], i64 noundef [[X:%.*]], i64 noundef [[D:%.*]]) {
; CHECK-NEXT:    [[IDX:%.*]] = srem i64 [[X]], [[D]]
; CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds nuw i8, ptr [[FOO]], i64 [[IDX]]
; CHECK-NEXT:    ret ptr [[P]]
;
  %idx = srem i64 %x, %d
  %p = getelementptr inbounds nuw i8, ptr %foo, i64 %idx
  ret ptr %p
}

define ptr @neg_not_i8(ptr dereferenceable(16) %foo, i64 noundef %x) {
; CHECK-LABEL: define ptr @neg_not_i8(
; CHECK-SAME: ptr dereferenceable(16) [[FOO:%.*]], i64 noundef [[X:%.*]]) {
; CHECK-NEXT:    [[IDX:%.*]] = srem i64 [[X]], 4
; CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds nuw i32, ptr [[FOO]], i64 [[IDX]]
; CHECK-NEXT:    ret ptr [[P]]
;
  %idx = srem i64 %x, 4
  %p = getelementptr inbounds nuw i32, ptr %foo, i64 %idx
  ret ptr %p
}
