; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt %s -passes=instcombine -data-layout="E" -S | FileCheck %s --check-prefixes=CHECK,CHECK-BE
; RUN: opt %s -passes=instcombine -data-layout="e" -S | FileCheck %s --check-prefixes=CHECK,CHECK-LE

define i32 @bitcast.v2i.le(<4 x i8> %v) {
; CHECK-BE-LABEL: define i32 @bitcast.v2i.le(
; CHECK-BE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <4 x i8> [[V]], i64 0
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <4 x i8> [[V]], i64 1
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_2:%.*]] = extractelement <4 x i8> [[V]], i64 2
; CHECK-BE-NEXT:    [[Z_2:%.*]] = zext i8 [[V_2]] to i32
; CHECK-BE-NEXT:    [[S_2:%.*]] = shl nuw nsw i32 [[Z_2]], 16
; CHECK-BE-NEXT:    [[X_2:%.*]] = or disjoint i32 [[X_1]], [[S_2]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <4 x i8> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_2]], [[S_3]]
; CHECK-BE-NEXT:    ret i32 [[X_3]]
;
; CHECK-LE-LABEL: define i32 @bitcast.v2i.le(
; CHECK-LE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[V]] to i32
; CHECK-LE-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <4 x i8> %v, i64 0
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i64 1
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <4 x i8> %v, i64 2
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16
  %x.2 = or i32 %x.1, %s.2

  %v.3 = extractelement <4 x i8> %v, i64 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.2, %s.3

  ret i32 %x.3
}

define i32 @bitcast.v2i.be(<4 x i8> %v) {
; CHECK-BE-LABEL: define i32 @bitcast.v2i.be(
; CHECK-BE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[V]] to i32
; CHECK-BE-NEXT:    ret i32 [[X_3]]
;
; CHECK-LE-LABEL: define i32 @bitcast.v2i.be(
; CHECK-LE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <4 x i8> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <4 x i8> [[V]], i64 2
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <4 x i8> [[V]], i64 1
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i8 [[V_2]] to i32
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i32 [[Z_2]], 16
; CHECK-LE-NEXT:    [[X_2:%.*]] = or disjoint i32 [[X_1]], [[S_2]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <4 x i8> [[V]], i64 0
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_2]], [[S_3]]
; CHECK-LE-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <4 x i8> %v, i64 3
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i64 2
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <4 x i8> %v, i64 1
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16
  %x.2 = or i32 %x.1, %s.2

  %v.3 = extractelement <4 x i8> %v, i64 0
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.2, %s.3

  ret i32 %x.3
}

define i64 @bitcast.v2i.le.i16(<4 x i16> %v) {
; CHECK-BE-LABEL: define i64 @bitcast.v2i.le.i16(
; CHECK-BE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <4 x i16> [[V]], i64 0
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <4 x i16> [[V]], i64 1
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_2:%.*]] = extractelement <4 x i16> [[V]], i64 2
; CHECK-BE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-BE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-BE-NEXT:    [[X_2:%.*]] = or disjoint i64 [[X_1]], [[S_2]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <4 x i16> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_2]], [[S_3]]
; CHECK-BE-NEXT:    ret i64 [[X_3]]
;
; CHECK-LE-LABEL: define i64 @bitcast.v2i.le.i16(
; CHECK-LE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3:%.*]] = bitcast <4 x i16> [[V]] to i64
; CHECK-LE-NEXT:    ret i64 [[X_3]]
;
  %v.0 = extractelement <4 x i16> %v, i64 0
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <4 x i16> %v, i64 1
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.2 = extractelement <4 x i16> %v, i64 2
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32
  %x.2 = or i64 %x.1, %s.2

  %v.3 = extractelement <4 x i16> %v, i64 3
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.2, %s.3

  ret i64 %x.3
}

define i64 @bitcast.v2i.be.i16(<4 x i16> %v) {
; CHECK-BE-LABEL: define i64 @bitcast.v2i.be.i16(
; CHECK-BE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3:%.*]] = bitcast <4 x i16> [[V]] to i64
; CHECK-BE-NEXT:    ret i64 [[X_3]]
;
; CHECK-LE-LABEL: define i64 @bitcast.v2i.be.i16(
; CHECK-LE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <4 x i16> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <4 x i16> [[V]], i64 2
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <4 x i16> [[V]], i64 1
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-LE-NEXT:    [[X_2:%.*]] = or disjoint i64 [[X_1]], [[S_2]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <4 x i16> [[V]], i64 0
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_2]], [[S_3]]
; CHECK-LE-NEXT:    ret i64 [[X_3]]
;
  %v.0 = extractelement <4 x i16> %v, i64 3
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <4 x i16> %v, i64 2
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.2 = extractelement <4 x i16> %v, i64 1
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32
  %x.2 = or i64 %x.1, %s.2

  %v.3 = extractelement <4 x i16> %v, i64 0
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.2, %s.3

  ret i64 %x.3
}

define i32 @bitcast.v2i.le.tree(<4 x i8> %v) {
; CHECK-BE-LABEL: define i32 @bitcast.v2i.le.tree(
; CHECK-BE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <4 x i8> [[V]], i64 0
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <4 x i8> [[V]], i64 1
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_2:%.*]] = extractelement <4 x i8> [[V]], i64 2
; CHECK-BE-NEXT:    [[Z_2:%.*]] = zext i8 [[V_2]] to i32
; CHECK-BE-NEXT:    [[S_2:%.*]] = shl nuw nsw i32 [[Z_2]], 16
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <4 x i8> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[S_2]], [[S_3]]
; CHECK-BE-NEXT:    [[X:%.*]] = or disjoint i32 [[X_1]], [[X_3]]
; CHECK-BE-NEXT:    ret i32 [[X]]
;
; CHECK-LE-LABEL: define i32 @bitcast.v2i.le.tree(
; CHECK-LE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X:%.*]] = bitcast <4 x i8> [[V]] to i32
; CHECK-LE-NEXT:    ret i32 [[X]]
;
  %v.0 = extractelement <4 x i8> %v, i64 0
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i64 1
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <4 x i8> %v, i64 2
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16

  %v.3 = extractelement <4 x i8> %v, i64 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %s.2, %s.3

  %x = or i32 %x.1, %x.3

  ret i32 %x
}

define i32 @bitcast.v2i.be.tree(<4 x i8> %v) {
; CHECK-BE-LABEL: define i32 @bitcast.v2i.be.tree(
; CHECK-BE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X:%.*]] = bitcast <4 x i8> [[V]] to i32
; CHECK-BE-NEXT:    ret i32 [[X]]
;
; CHECK-LE-LABEL: define i32 @bitcast.v2i.be.tree(
; CHECK-LE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <4 x i8> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <4 x i8> [[V]], i64 2
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <4 x i8> [[V]], i64 1
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i8 [[V_2]] to i32
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i32 [[Z_2]], 16
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <4 x i8> [[V]], i64 0
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[S_2]], [[S_3]]
; CHECK-LE-NEXT:    [[X:%.*]] = or disjoint i32 [[X_1]], [[X_3]]
; CHECK-LE-NEXT:    ret i32 [[X]]
;
  %v.0 = extractelement <4 x i8> %v, i64 3
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i64 2
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <4 x i8> %v, i64 1
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16

  %v.3 = extractelement <4 x i8> %v, i64 0
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %s.2, %s.3

  %x = or i32 %x.1, %x.3

  ret i32 %x
}

define i64 @bitcast.v2i.le.tree.i16(<4 x i16> %v) {
; CHECK-BE-LABEL: define i64 @bitcast.v2i.le.tree.i16(
; CHECK-BE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <4 x i16> [[V]], i64 0
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <4 x i16> [[V]], i64 1
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_2:%.*]] = extractelement <4 x i16> [[V]], i64 2
; CHECK-BE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-BE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <4 x i16> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[S_2]], [[S_3]]
; CHECK-BE-NEXT:    [[X:%.*]] = or disjoint i64 [[X_1]], [[X_3]]
; CHECK-BE-NEXT:    ret i64 [[X]]
;
; CHECK-LE-LABEL: define i64 @bitcast.v2i.le.tree.i16(
; CHECK-LE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X:%.*]] = bitcast <4 x i16> [[V]] to i64
; CHECK-LE-NEXT:    ret i64 [[X]]
;
  %v.0 = extractelement <4 x i16> %v, i64 0
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <4 x i16> %v, i64 1
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.2 = extractelement <4 x i16> %v, i64 2
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32

  %v.3 = extractelement <4 x i16> %v, i64 3
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %s.2, %s.3

  %x = or i64 %x.1, %x.3

  ret i64 %x
}

define i64 @bitcast.v2i.be.tree.i16(<4 x i16> %v) {
; CHECK-BE-LABEL: define i64 @bitcast.v2i.be.tree.i16(
; CHECK-BE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X:%.*]] = bitcast <4 x i16> [[V]] to i64
; CHECK-BE-NEXT:    ret i64 [[X]]
;
; CHECK-LE-LABEL: define i64 @bitcast.v2i.be.tree.i16(
; CHECK-LE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <4 x i16> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <4 x i16> [[V]], i64 2
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <4 x i16> [[V]], i64 1
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <4 x i16> [[V]], i64 0
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[S_2]], [[S_3]]
; CHECK-LE-NEXT:    [[X:%.*]] = or disjoint i64 [[X_1]], [[X_3]]
; CHECK-LE-NEXT:    ret i64 [[X]]
;
  %v.0 = extractelement <4 x i16> %v, i64 3
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <4 x i16> %v, i64 2
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.2 = extractelement <4 x i16> %v, i64 1
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32

  %v.3 = extractelement <4 x i16> %v, i64 0
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %s.2, %s.3

  %x = or i64 %x.1, %x.3

  ret i64 %x
}

define i32 @extract.le.i32(<8 x i8> %v) {
; CHECK-BE-LABEL: define i32 @extract.le.i32(
; CHECK-BE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <8 x i8> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <8 x i8> [[V]], i64 4
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_2:%.*]] = extractelement <8 x i8> [[V]], i64 5
; CHECK-BE-NEXT:    [[Z_2:%.*]] = zext i8 [[V_2]] to i32
; CHECK-BE-NEXT:    [[S_2:%.*]] = shl nuw nsw i32 [[Z_2]], 16
; CHECK-BE-NEXT:    [[X_2:%.*]] = or disjoint i32 [[X_1]], [[S_2]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <8 x i8> [[V]], i64 6
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_2]], [[S_3]]
; CHECK-BE-NEXT:    ret i32 [[X_3]]
;
; CHECK-LE-LABEL: define i32 @extract.le.i32(
; CHECK-LE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3_V_EXTRACT:%.*]] = shufflevector <8 x i8> [[V]], <8 x i8> poison, <8 x i32> <i32 3, i32 4, i32 5, i32 6, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-LE-NEXT:    [[X_3_V_BC:%.*]] = bitcast <8 x i8> [[X_3_V_EXTRACT]] to <2 x i32>
; CHECK-LE-NEXT:    [[X_3_V_EXTRACT1:%.*]] = extractelement <2 x i32> [[X_3_V_BC]], i64 0
; CHECK-LE-NEXT:    ret i32 [[X_3_V_EXTRACT1]]
;
  %v.0 = extractelement <8 x i8> %v, i64 3
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <8 x i8> %v, i64 4
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <8 x i8> %v, i64 5
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16
  %x.2 = or i32 %x.1, %s.2

  %v.3 = extractelement <8 x i8> %v, i64 6
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.2, %s.3

  ret i32 %x.3
}

define i32 @extract.be.i32(<8 x i8> %v) {
; CHECK-BE-LABEL: define i32 @extract.be.i32(
; CHECK-BE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3_V_EXTRACT:%.*]] = shufflevector <8 x i8> [[V]], <8 x i8> poison, <8 x i32> <i32 3, i32 4, i32 5, i32 6, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-BE-NEXT:    [[X_3_V_BC:%.*]] = bitcast <8 x i8> [[X_3_V_EXTRACT]] to <2 x i32>
; CHECK-BE-NEXT:    [[X_3_V_EXTRACT1:%.*]] = extractelement <2 x i32> [[X_3_V_BC]], i64 0
; CHECK-BE-NEXT:    ret i32 [[X_3_V_EXTRACT1]]
;
; CHECK-LE-LABEL: define i32 @extract.be.i32(
; CHECK-LE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <8 x i8> [[V]], i64 6
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <8 x i8> [[V]], i64 5
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <8 x i8> [[V]], i64 4
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i8 [[V_2]] to i32
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i32 [[Z_2]], 16
; CHECK-LE-NEXT:    [[X_2:%.*]] = or disjoint i32 [[X_1]], [[S_2]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <8 x i8> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_2]], [[S_3]]
; CHECK-LE-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <8 x i8> %v, i64 6
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <8 x i8> %v, i64 5
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <8 x i8> %v, i64 4
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16
  %x.2 = or i32 %x.1, %s.2

  %v.3 = extractelement <8 x i8> %v, i64 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.2, %s.3

  ret i32 %x.3
}

define i64 @extract.le.i64(<8 x i16> %v) {
; CHECK-BE-LABEL: define i64 @extract.le.i64(
; CHECK-BE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <8 x i16> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <8 x i16> [[V]], i64 4
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_2:%.*]] = extractelement <8 x i16> [[V]], i64 5
; CHECK-BE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-BE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-BE-NEXT:    [[X_2:%.*]] = or disjoint i64 [[X_1]], [[S_2]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <8 x i16> [[V]], i64 6
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_2]], [[S_3]]
; CHECK-BE-NEXT:    ret i64 [[X_3]]
;
; CHECK-LE-LABEL: define i64 @extract.le.i64(
; CHECK-LE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3_V_EXTRACT:%.*]] = shufflevector <8 x i16> [[V]], <8 x i16> poison, <8 x i32> <i32 3, i32 4, i32 5, i32 6, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-LE-NEXT:    [[X_3_V_BC:%.*]] = bitcast <8 x i16> [[X_3_V_EXTRACT]] to <2 x i64>
; CHECK-LE-NEXT:    [[X_3_V_EXTRACT1:%.*]] = extractelement <2 x i64> [[X_3_V_BC]], i64 0
; CHECK-LE-NEXT:    ret i64 [[X_3_V_EXTRACT1]]
;
  %v.0 = extractelement <8 x i16> %v, i64 3
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <8 x i16> %v, i64 4
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.2 = extractelement <8 x i16> %v, i64 5
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32
  %x.2 = or i64 %x.1, %s.2

  %v.3 = extractelement <8 x i16> %v, i64 6
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.2, %s.3

  ret i64 %x.3
}

define i64 @extract.be.i64(<8 x i16> %v) {
; CHECK-BE-LABEL: define i64 @extract.be.i64(
; CHECK-BE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3_V_EXTRACT:%.*]] = shufflevector <8 x i16> [[V]], <8 x i16> poison, <8 x i32> <i32 3, i32 4, i32 5, i32 6, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-BE-NEXT:    [[X_3_V_BC:%.*]] = bitcast <8 x i16> [[X_3_V_EXTRACT]] to <2 x i64>
; CHECK-BE-NEXT:    [[X_3_V_EXTRACT1:%.*]] = extractelement <2 x i64> [[X_3_V_BC]], i64 0
; CHECK-BE-NEXT:    ret i64 [[X_3_V_EXTRACT1]]
;
; CHECK-LE-LABEL: define i64 @extract.be.i64(
; CHECK-LE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <8 x i16> [[V]], i64 6
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <8 x i16> [[V]], i64 5
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <8 x i16> [[V]], i64 4
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-LE-NEXT:    [[X_2:%.*]] = or disjoint i64 [[X_1]], [[S_2]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <8 x i16> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_2]], [[S_3]]
; CHECK-LE-NEXT:    ret i64 [[X_3]]
;
  %v.0 = extractelement <8 x i16> %v, i64 6
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <8 x i16> %v, i64 5
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.2 = extractelement <8 x i16> %v, i64 4
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32
  %x.2 = or i64 %x.1, %s.2

  %v.3 = extractelement <8 x i16> %v, i64 3
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.2, %s.3

  ret i64 %x.3
}

define i32 @partial.le(<4 x i8> %v) {
; CHECK-BE-LABEL: define i32 @partial.le(
; CHECK-BE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <4 x i8> [[V]], i64 0
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <4 x i8> [[V]], i64 1
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <4 x i8> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_1]], [[S_3]]
; CHECK-BE-NEXT:    ret i32 [[X_3]]
;
; CHECK-LE-LABEL: define i32 @partial.le(
; CHECK-LE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3_V1:%.*]] = insertelement <4 x i8> [[V]], i8 0, i64 2
; CHECK-LE-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[X_3_V1]] to i32
; CHECK-LE-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <4 x i8> %v, i64 0
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i64 1
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.3 = extractelement <4 x i8> %v, i64 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.1, %s.3

  ret i32 %x.3
}

define i32 @partial.be(<4 x i8> %v) {
; CHECK-BE-LABEL: define i32 @partial.be(
; CHECK-BE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3_V1:%.*]] = insertelement <4 x i8> [[V]], i8 0, i64 2
; CHECK-BE-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[X_3_V1]] to i32
; CHECK-BE-NEXT:    ret i32 [[X_3]]
;
; CHECK-LE-LABEL: define i32 @partial.be(
; CHECK-LE-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <4 x i8> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <4 x i8> [[V]], i64 1
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 16
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <4 x i8> [[V]], i64 0
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_1]], [[S_3]]
; CHECK-LE-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <4 x i8> %v, i64 3
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i64 1
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 16
  %x.1 = or i32 %z.0, %s.1

  %v.3 = extractelement <4 x i8> %v, i64 0
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.1, %s.3

  ret i32 %x.3
}


define i64 @partial.le.i16(<4 x i16> %v) {
; CHECK-BE-LABEL: define i64 @partial.le.i16(
; CHECK-BE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <4 x i16> [[V]], i64 0
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <4 x i16> [[V]], i64 1
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <4 x i16> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_1]], [[S_3]]
; CHECK-BE-NEXT:    ret i64 [[X_3]]
;
; CHECK-LE-LABEL: define i64 @partial.le.i16(
; CHECK-LE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3_V1:%.*]] = insertelement <4 x i16> [[V]], i16 0, i64 2
; CHECK-LE-NEXT:    [[X_3:%.*]] = bitcast <4 x i16> [[X_3_V1]] to i64
; CHECK-LE-NEXT:    ret i64 [[X_3]]
;
  %v.0 = extractelement <4 x i16> %v, i64 0
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <4 x i16> %v, i64 1
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.3 = extractelement <4 x i16> %v, i64 3
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.1, %s.3

  ret i64 %x.3
}

define i64 @partial.be.i16(<4 x i16> %v) {
; CHECK-BE-LABEL: define i64 @partial.be.i16(
; CHECK-BE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3_V1:%.*]] = insertelement <4 x i16> [[V]], i16 0, i64 2
; CHECK-BE-NEXT:    [[X_3:%.*]] = bitcast <4 x i16> [[X_3_V1]] to i64
; CHECK-BE-NEXT:    ret i64 [[X_3]]
;
; CHECK-LE-LABEL: define i64 @partial.be.i16(
; CHECK-LE-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <4 x i16> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-LE-NEXT:    [[V_1:%.*]] = extractelement <4 x i16> [[V]], i64 1
; CHECK-LE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-LE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 32
; CHECK-LE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <4 x i16> [[V]], i64 0
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_1]], [[S_3]]
; CHECK-LE-NEXT:    ret i64 [[X_3]]
;
  %v.0 = extractelement <4 x i16> %v, i64 3
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <4 x i16> %v, i64 1
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 32
  %x.1 = or i64 %z.0, %s.1

  %v.3 = extractelement <4 x i16> %v, i64 0
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.1, %s.3

  ret i64 %x.3
}

define i32 @partial.extract.le.i32(<8 x i8> %v) {
; CHECK-BE-LABEL: define i32 @partial.extract.le.i32(
; CHECK-BE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <8 x i8> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <8 x i8> [[V]], i64 4
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i8 [[V_1]] to i32
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i32 [[Z_1]], 8
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i32 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <8 x i8> [[V]], i64 6
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_1]], [[S_3]]
; CHECK-BE-NEXT:    ret i32 [[X_3]]
;
; CHECK-LE-LABEL: define i32 @partial.extract.le.i32(
; CHECK-LE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3_V:%.*]] = shufflevector <8 x i8> [[V]], <8 x i8> <i8 0, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison>, <4 x i32> <i32 3, i32 4, i32 8, i32 6>
; CHECK-LE-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[X_3_V]] to i32
; CHECK-LE-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <8 x i8> %v, i64 3
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <8 x i8> %v, i64 4
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.3 = extractelement <8 x i8> %v, i64 6
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.1, %s.3

  ret i32 %x.3
}

define i32 @partial.extract.be.i32(<8 x i8> %v) {
; CHECK-BE-LABEL: define i32 @partial.extract.be.i32(
; CHECK-BE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3_V:%.*]] = shufflevector <8 x i8> [[V]], <8 x i8> <i8 0, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison, i8 poison>, <4 x i32> <i32 3, i32 4, i32 8, i32 6>
; CHECK-BE-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[X_3_V]] to i32
; CHECK-BE-NEXT:    ret i32 [[X_3]]
;
; CHECK-LE-LABEL: define i32 @partial.extract.be.i32(
; CHECK-LE-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <8 x i8> [[V]], i64 6
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i8 [[V_0]] to i32
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <8 x i8> [[V]], i64 4
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i8 [[V_2]] to i32
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i32 [[Z_2]], 16
; CHECK-LE-NEXT:    [[X_2:%.*]] = or disjoint i32 [[S_2]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <8 x i8> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i8 [[V_3]] to i32
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i32 [[Z_3]], 24
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i32 [[X_2]], [[S_3]]
; CHECK-LE-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <8 x i8> %v, i64 6
  %z.0 = zext i8 %v.0 to i32

  %v.2 = extractelement <8 x i8> %v, i64 4
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16
  %x.2 = or i32 %z.0, %s.2

  %v.3 = extractelement <8 x i8> %v, i64 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.2, %s.3

  ret i32 %x.3
}

define i64 @partial.extract.le.i64(<8 x i16> %v) {
; CHECK-BE-LABEL: define i64 @partial.extract.le.i64(
; CHECK-BE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[V_0:%.*]] = extractelement <8 x i16> [[V]], i64 3
; CHECK-BE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-BE-NEXT:    [[V_1:%.*]] = extractelement <8 x i16> [[V]], i64 4
; CHECK-BE-NEXT:    [[Z_1:%.*]] = zext i16 [[V_1]] to i64
; CHECK-BE-NEXT:    [[S_1:%.*]] = shl nuw nsw i64 [[Z_1]], 16
; CHECK-BE-NEXT:    [[X_1:%.*]] = or disjoint i64 [[S_1]], [[Z_0]]
; CHECK-BE-NEXT:    [[V_2:%.*]] = extractelement <8 x i16> [[V]], i64 5
; CHECK-BE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-BE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-BE-NEXT:    [[X_2:%.*]] = or disjoint i64 [[X_1]], [[S_2]]
; CHECK-BE-NEXT:    [[V_3:%.*]] = extractelement <8 x i16> [[V]], i64 6
; CHECK-BE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-BE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-BE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_2]], [[S_3]]
; CHECK-BE-NEXT:    ret i64 [[X_3]]
;
; CHECK-LE-LABEL: define i64 @partial.extract.le.i64(
; CHECK-LE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[X_3_V_EXTRACT:%.*]] = shufflevector <8 x i16> [[V]], <8 x i16> poison, <8 x i32> <i32 3, i32 4, i32 5, i32 6, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-LE-NEXT:    [[X_3_V_BC:%.*]] = bitcast <8 x i16> [[X_3_V_EXTRACT]] to <2 x i64>
; CHECK-LE-NEXT:    [[X_3_V_EXTRACT1:%.*]] = extractelement <2 x i64> [[X_3_V_BC]], i64 0
; CHECK-LE-NEXT:    ret i64 [[X_3_V_EXTRACT1]]
;
  %v.0 = extractelement <8 x i16> %v, i64 3
  %z.0 = zext i16 %v.0 to i64

  %v.1 = extractelement <8 x i16> %v, i64 4
  %z.1 = zext i16 %v.1 to i64
  %s.1 = shl i64 %z.1, 16
  %x.1 = or i64 %z.0, %s.1

  %v.2 = extractelement <8 x i16> %v, i64 5
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32
  %x.2 = or i64 %x.1, %s.2

  %v.3 = extractelement <8 x i16> %v, i64 6
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.2, %s.3

  ret i64 %x.3
}

define i64 @partial.extract.be.i64(<8 x i16> %v) {
; CHECK-BE-LABEL: define i64 @partial.extract.be.i64(
; CHECK-BE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-BE-NEXT:    [[X_3_V:%.*]] = shufflevector <8 x i16> [[V]], <8 x i16> <i16 0, i16 poison, i16 poison, i16 poison, i16 poison, i16 poison, i16 poison, i16 poison>, <4 x i32> <i32 3, i32 4, i32 8, i32 6>
; CHECK-BE-NEXT:    [[X_3:%.*]] = bitcast <4 x i16> [[X_3_V]] to i64
; CHECK-BE-NEXT:    ret i64 [[X_3]]
;
; CHECK-LE-LABEL: define i64 @partial.extract.be.i64(
; CHECK-LE-SAME: <8 x i16> [[V:%.*]]) {
; CHECK-LE-NEXT:    [[V_0:%.*]] = extractelement <8 x i16> [[V]], i64 6
; CHECK-LE-NEXT:    [[Z_0:%.*]] = zext i16 [[V_0]] to i64
; CHECK-LE-NEXT:    [[V_2:%.*]] = extractelement <8 x i16> [[V]], i64 4
; CHECK-LE-NEXT:    [[Z_2:%.*]] = zext i16 [[V_2]] to i64
; CHECK-LE-NEXT:    [[S_2:%.*]] = shl nuw nsw i64 [[Z_2]], 32
; CHECK-LE-NEXT:    [[X_2:%.*]] = or disjoint i64 [[S_2]], [[Z_0]]
; CHECK-LE-NEXT:    [[V_3:%.*]] = extractelement <8 x i16> [[V]], i64 3
; CHECK-LE-NEXT:    [[Z_3:%.*]] = zext i16 [[V_3]] to i64
; CHECK-LE-NEXT:    [[S_3:%.*]] = shl nuw i64 [[Z_3]], 48
; CHECK-LE-NEXT:    [[X_3:%.*]] = or disjoint i64 [[X_2]], [[S_3]]
; CHECK-LE-NEXT:    ret i64 [[X_3]]
;
  %v.0 = extractelement <8 x i16> %v, i64 6
  %z.0 = zext i16 %v.0 to i64

  %v.2 = extractelement <8 x i16> %v, i64 4
  %z.2 = zext i16 %v.2 to i64
  %s.2 = shl i64 %z.2, 32
  %x.2 = or i64 %z.0, %s.2

  %v.3 = extractelement <8 x i16> %v, i64 3
  %z.3 = zext i16 %v.3 to i64
  %s.3 = shl i64 %z.3, 48
  %x.3 = or i64 %x.2, %s.3

  ret i64 %x.3
}

define <2 x i16> @shufflecast.v2v(<4 x i8> %v) {
; CHECK-LABEL: define <2 x i16> @shufflecast.v2v(
; CHECK-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-NEXT:    [[W_3:%.*]] = bitcast <4 x i8> [[V]] to <2 x i16>
; CHECK-NEXT:    ret <2 x i16> [[W_3]]
;
  %v.0 = shufflevector <4 x i8> %v, <4 x i8> zeroinitializer, <4 x i32> <i32 0, i32 4, i32 4, i32 4>
  %c.0 = bitcast <4 x i8> %v.0 to <2 x i16>

  %v.1 = shufflevector <4 x i8> %v, <4 x i8> zeroinitializer, <4 x i32> <i32 4, i32 1, i32 4, i32 4>
  %c.1 = bitcast <4 x i8> %v.1 to <2 x i16>
  %w.1 = or <2 x i16> %c.0, %c.1

  %v.2 = shufflevector <4 x i8> %v, <4 x i8> zeroinitializer, <4 x i32> <i32 4, i32 4, i32 2, i32 4>
  %c.2 = bitcast <4 x i8> %v.2 to <2 x i16>
  %w.2 = or <2 x i16> %w.1, %c.2

  %v.3 = shufflevector <4 x i8> %v, <4 x i8> zeroinitializer, <4 x i32> <i32 4, i32 4, i32 4, i32 3>
  %c.3 = bitcast <4 x i8> %v.3 to <2 x i16>
  %w.3 = or <2 x i16> %w.2, %c.3

  ret <2 x i16> %w.3
}

define <2 x i32> @shufflecast.v2v.i16(<4 x i16> %v) {
; CHECK-LABEL: define <2 x i32> @shufflecast.v2v.i16(
; CHECK-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-NEXT:    [[W_3:%.*]] = bitcast <4 x i16> [[V]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[W_3]]
;
  %v.0 = shufflevector <4 x i16> %v, <4 x i16> zeroinitializer, <4 x i32> <i32 0, i32 4, i32 4, i32 4>
  %c.0 = bitcast <4 x i16> %v.0 to <2 x i32>

  %v.1 = shufflevector <4 x i16> %v, <4 x i16> zeroinitializer, <4 x i32> <i32 4, i32 1, i32 4, i32 4>
  %c.1 = bitcast <4 x i16> %v.1 to <2 x i32>
  %w.1 = or <2 x i32> %c.0, %c.1

  %v.2 = shufflevector <4 x i16> %v, <4 x i16> zeroinitializer, <4 x i32> <i32 4, i32 4, i32 2, i32 4>
  %c.2 = bitcast <4 x i16> %v.2 to <2 x i32>
  %w.2 = or <2 x i32> %w.1, %c.2

  %v.3 = shufflevector <4 x i16> %v, <4 x i16> zeroinitializer, <4 x i32> <i32 4, i32 4, i32 4, i32 3>
  %c.3 = bitcast <4 x i16> %v.3 to <2 x i32>
  %w.3 = or <2 x i32> %w.2, %c.3

  ret <2 x i32> %w.3
}

define i32 @bitcast.v2i.half(<2 x half> %v) {
; CHECK-LABEL: define i32 @bitcast.v2i.half(
; CHECK-SAME: <2 x half> [[V:%.*]]) {
; CHECK-NEXT:    [[X:%.*]] = bitcast <2 x half> [[V]] to i32
; CHECK-NEXT:    ret i32 [[X]]
;
  %v.0 = insertelement <2 x half> %v, half 0.0, i64 1
  %x.0 = bitcast <2 x half> %v.0 to i32

  %v.1 = insertelement <2 x half> %v, half 0.0, i64 0
  %x.1 = bitcast <2 x half> %v.1 to i32

  %x = or i32 %x.0, %x.1
  ret i32 %x
}
