; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -S -data-layout="E" | FileCheck %s --check-prefixes=CHECK
; RUN: opt < %s -passes=instcombine -S -data-layout="e" | FileCheck %s --check-prefixes=CHECK

define i32 @bitcast.v2i(<4 x i8> %v) {
; CHECK-LABEL: define i32 @bitcast.v2i(
; CHECK-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[V]] to i32
; CHECK-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <4 x i8> %v, i32 0
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i32 1
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <4 x i8> %v, i32 2
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16
  %x.2 = or i32 %x.1, %s.2

  %v.3 = extractelement <4 x i8> %v, i32 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.2, %s.3

  ret i32 %x.3
}

define i32 @bitcast.v2i.tree(<4 x i8> %v) {
; CHECK-LABEL: define i32 @bitcast.v2i.tree(
; CHECK-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-NEXT:    [[X:%.*]] = bitcast <4 x i8> [[V]] to i32
; CHECK-NEXT:    ret i32 [[X]]
;
  %v.0 = extractelement <4 x i8> %v, i32 0
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i32 1
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <4 x i8> %v, i32 2
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16

  %v.3 = extractelement <4 x i8> %v, i32 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %s.2, %s.3

  %x = or i32 %x.1, %x.3

  ret i32 %x
}

define i32 @extract.i32(<8 x i8> %v) {
; CHECK-LABEL: define i32 @extract.i32(
; CHECK-SAME: <8 x i8> [[V:%.*]]) {
; CHECK-NEXT:    [[X_3_V_EXTRACT:%.*]] = shufflevector <8 x i8> [[V]], <8 x i8> poison, <8 x i32> <i32 3, i32 4, i32 5, i32 6, i32 poison, i32 poison, i32 poison, i32 poison>
; CHECK-NEXT:    [[X_3_V_BC:%.*]] = bitcast <8 x i8> [[X_3_V_EXTRACT]] to <2 x i32>
; CHECK-NEXT:    [[X_3_V_EXTRACT1:%.*]] = extractelement <2 x i32> [[X_3_V_BC]], i64 0
; CHECK-NEXT:    ret i32 [[X_3_V_EXTRACT1]]
;
  %v.0 = extractelement <8 x i8> %v, i32 3
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <8 x i8> %v, i32 4
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.2 = extractelement <8 x i8> %v, i32 5
  %z.2 = zext i8 %v.2 to i32
  %s.2 = shl i32 %z.2, 16
  %x.2 = or i32 %x.1, %s.2

  %v.3 = extractelement <8 x i8> %v, i32 6
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.2, %s.3

  ret i32 %x.3
}

define i32 @partial(<4 x i8> %v) {
; CHECK-LABEL: define i32 @partial(
; CHECK-SAME: <4 x i8> [[V:%.*]]) {
; CHECK-NEXT:    [[X_3_V1:%.*]] = insertelement <4 x i8> [[V]], i8 0, i64 2
; CHECK-NEXT:    [[X_3:%.*]] = bitcast <4 x i8> [[X_3_V1]] to i32
; CHECK-NEXT:    ret i32 [[X_3]]
;
  %v.0 = extractelement <4 x i8> %v, i32 0
  %z.0 = zext i8 %v.0 to i32

  %v.1 = extractelement <4 x i8> %v, i32 1
  %z.1 = zext i8 %v.1 to i32
  %s.1 = shl i32 %z.1, 8
  %x.1 = or i32 %z.0, %s.1

  %v.3 = extractelement <4 x i8> %v, i32 3
  %z.3 = zext i8 %v.3 to i32
  %s.3 = shl i32 %z.3, 24
  %x.3 = or i32 %x.1, %s.3

  ret i32 %x.3
}
