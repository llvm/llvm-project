; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; std::bit_ceil<uint32_t>(x)
define i32 @bit_ceil_32(i32 %x) {
; CHECK-LABEL: @bit_ceil_32(
; CHECK-NEXT:    [[DEC:%.*]] = add i32 [[X:%.*]], -1
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call i32 @llvm.ctlz.i32(i32 [[DEC]], i1 false), !range [[RNG0:![0-9]+]]
; CHECK-NEXT:    [[SUB:%.*]] = sub nuw nsw i32 32, [[CTLZ]]
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw i32 1, [[SUB]]
; CHECK-NEXT:    [[UGT:%.*]] = icmp ugt i32 [[X]], 1
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[UGT]], i32 [[SHL]], i32 1
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %dec = add i32 %x, -1
  %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false)
  %sub = sub i32 32, %ctlz
  %shl = shl i32 1, %sub
  %ugt = icmp ugt i32 %x, 1
  %sel = select i1 %ugt, i32 %shl, i32 1
  ret i32 %sel
}

; std::bit_ceil<uint64_t>(x)
define i64 @bit_ceil_64(i64 %x) {
; CHECK-LABEL: @bit_ceil_64(
; CHECK-NEXT:    [[DEC:%.*]] = add i64 [[X:%.*]], -1
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call i64 @llvm.ctlz.i64(i64 [[DEC]], i1 false), !range [[RNG1:![0-9]+]]
; CHECK-NEXT:    [[SUB:%.*]] = sub nuw nsw i64 64, [[CTLZ]]
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw i64 1, [[SUB]]
; CHECK-NEXT:    [[UGT:%.*]] = icmp ugt i64 [[X]], 1
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[UGT]], i64 [[SHL]], i64 1
; CHECK-NEXT:    ret i64 [[SEL]]
;
  %dec = add i64 %x, -1
  %ctlz = tail call i64 @llvm.ctlz.i64(i64 %dec, i1 false)
  %sub = sub i64 64, %ctlz
  %shl = shl i64 1, %sub
  %ugt = icmp ugt i64 %x, 1
  %sel = select i1 %ugt, i64 %shl, i64 1
  ret i64 %sel
}

; std::bit_ceil<uint32_t>(x - 1)
define i32 @bit_ceil_32_minus_1(i32 %x) {
; CHECK-LABEL: @bit_ceil_32_minus_1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB:%.*]] = add i32 [[X:%.*]], -2
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call i32 @llvm.ctlz.i32(i32 [[SUB]], i1 false), !range [[RNG0]]
; CHECK-NEXT:    [[SUB2:%.*]] = sub nuw nsw i32 32, [[CTLZ]]
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw i32 1, [[SUB2]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X]], -3
; CHECK-NEXT:    [[ULT:%.*]] = icmp ult i32 [[ADD]], -2
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[ULT]], i32 [[SHL]], i32 1
; CHECK-NEXT:    ret i32 [[SEL]]
;
entry:
  %sub = add i32 %x, -2
  %ctlz = tail call i32 @llvm.ctlz.i32(i32 %sub, i1 false)
  %sub2 = sub nuw nsw i32 32, %ctlz
  %shl = shl nuw i32 1, %sub2
  %add = add i32 %x, -3
  %ult = icmp ult i32 %add, -2
  %sel = select i1 %ult, i32 %shl, i32 1
  ret i32 %sel
}

; std::bit_ceil<uint32_t>(x + 1)
define i32 @bit_ceil_32_plus_1(i32 %x) {
; CHECK-LABEL: @bit_ceil_32_plus_1(
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call i32 @llvm.ctlz.i32(i32 [[X:%.*]], i1 false), !range [[RNG0]]
; CHECK-NEXT:    [[SUB:%.*]] = sub nuw nsw i32 32, [[CTLZ]]
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw i32 1, [[SUB]]
; CHECK-NEXT:    [[DEC:%.*]] = add i32 [[X]], -1
; CHECK-NEXT:    [[ULT:%.*]] = icmp ult i32 [[DEC]], -2
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[ULT]], i32 [[SHL]], i32 1
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %ctlz = tail call i32 @llvm.ctlz.i32(i32 %x, i1 false)
  %sub = sub i32 32, %ctlz
  %shl = shl i32 1, %sub
  %dec = add i32 %x, -1
  %ult = icmp ult i32 %dec, -2
  %sel = select i1 %ult, i32 %shl, i32 1
  ret i32 %sel
}

define i32 @bit_ceil_plus_2(i32 %x) {
; CHECK-LABEL: @bit_ceil_plus_2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB:%.*]] = add i32 [[X:%.*]], 1
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call i32 @llvm.ctlz.i32(i32 [[SUB]], i1 false), !range [[RNG0]]
; CHECK-NEXT:    [[SUB2:%.*]] = sub nuw nsw i32 32, [[CTLZ]]
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw i32 1, [[SUB2]]
; CHECK-NEXT:    [[ULT:%.*]] = icmp ult i32 [[X]], -2
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[ULT]], i32 [[SHL]], i32 1
; CHECK-NEXT:    ret i32 [[SEL]]
;
entry:
  %sub = add i32 %x, 1
  %ctlz = tail call i32 @llvm.ctlz.i32(i32 %sub, i1 false)
  %sub2 = sub nuw nsw i32 32, %ctlz
  %shl = shl nuw i32 1, %sub2
  %ult = icmp ult i32 %x, -2
  %sel = select i1 %ult, i32 %shl, i32 1
  ret i32 %sel
}

; std::bit_ceil<uint32_t>(-x)
define i32 @bit_ceil_32_neg(i32 %x) {
; CHECK-LABEL: @bit_ceil_32_neg(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB:%.*]] = xor i32 [[X:%.*]], -1
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call i32 @llvm.ctlz.i32(i32 [[SUB]], i1 false), !range [[RNG0]]
; CHECK-NEXT:    [[SUB2:%.*]] = sub nuw nsw i32 32, [[CTLZ]]
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw i32 1, [[SUB2]]
; CHECK-NEXT:    [[NOTSUB:%.*]] = add i32 [[X]], -1
; CHECK-NEXT:    [[ULT:%.*]] = icmp ult i32 [[NOTSUB]], -2
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[ULT]], i32 [[SHL]], i32 1
; CHECK-NEXT:    ret i32 [[SEL]]
;
entry:
  %sub = xor i32 %x, -1
  %ctlz = tail call i32 @llvm.ctlz.i32(i32 %sub, i1 false)
  %sub2 = sub nuw nsw i32 32, %ctlz
  %shl = shl nuw i32 1, %sub2
  %notsub = add i32 %x, -1
  %ult = icmp ult i32 %notsub, -2
  %sel = select i1 %ult, i32 %shl, i32 1
  ret i32 %sel
}

; std::bit_ceil<uint32_t>(~x)
define i32 @bit_ceil_not(i32 %x) {
; CHECK-LABEL: @bit_ceil_not(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 -2, [[X:%.*]]
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call i32 @llvm.ctlz.i32(i32 [[SUB]], i1 false), !range [[RNG0]]
; CHECK-NEXT:    [[SUB2:%.*]] = sub nuw nsw i32 32, [[CTLZ]]
; CHECK-NEXT:    [[SHL:%.*]] = shl nuw i32 1, [[SUB2]]
; CHECK-NEXT:    [[ULT:%.*]] = icmp ult i32 [[X]], -2
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[ULT]], i32 [[SHL]], i32 1
; CHECK-NEXT:    ret i32 [[SEL]]
;
entry:
  %sub = sub i32 -2, %x
  %ctlz = tail call i32 @llvm.ctlz.i32(i32 %sub, i1 false)
  %sub2 = sub nuw nsw i32 32, %ctlz
  %shl = shl nuw i32 1, %sub2
  %ult = icmp ult i32 %x, -2
  %sel = select i1 %ult, i32 %shl, i32 1
  ret i32 %sel
}

declare i32 @llvm.ctlz.i32(i32, i1 immarg)
declare i64 @llvm.ctlz.i64(i64, i1 immarg)
