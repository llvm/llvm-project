; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s
; Tests for GitHub issue #97044 - Boolean expression canonicalization
define i32 @test0_4way_or(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test0_4way_or(
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[Y:%.*]], [[Z:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[TMP1]], [[X:%.*]]
; CHECK-NEXT:    [[OR13:%.*]] = xor i32 [[TMP2]], -1
; CHECK-NEXT:    ret i32 [[OR13]]
;
  %not = xor i32 %z, -1
  %and = and i32 %y, %not
  %and1 = and i32 %and, %x
  %not2 = xor i32 %y, -1
  %and3 = and i32 %x, %not2
  %and4 = and i32 %and3, %z
  %or = or i32 %and1, %and4
  %not5 = xor i32 %x, -1
  %not6 = xor i32 %y, -1
  %and7 = and i32 %not5, %not6
  %not8 = xor i32 %z, -1
  %and9 = and i32 %and7, %not8
  %or10 = or i32 %or, %and9
  %and11 = and i32 %x, %y
  %and12 = and i32 %and11, %z
  %or13 = or i32 %or10, %and12
  ret i32 %or13
}
define i32 @test1_xor_pattern(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test1_xor_pattern(
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[Y:%.*]], [[Z:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[TMP1]], [[X:%.*]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i32 [[TMP2]], -1
; CHECK-NEXT:    ret i32 [[XOR]]
;
  %not = xor i32 %z, -1
  %and = and i32 %x, %y
  %not1 = xor i32 %x, -1
  %not2 = xor i32 %y, -1
  %and3 = and i32 %not1, %not2
  %or = or i32 %and, %and3
  %and4 = and i32 %not, %or
  %and5 = and i32 %x, %y
  %and6 = and i32 %x, %not2
  %or7 = or i32 %and5, %and6
  %and8 = and i32 %z, %or7
  %xor = xor i32 %and4, %and8
  ret i32 %xor
}
define i32 @test2_nested_xor(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test2_nested_xor(
; CHECK-NEXT:    [[TMP1:%.*]] = or i32 [[Y:%.*]], [[Z:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[TMP1]], [[X:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = xor i32 [[TMP2]], [[Y]]
; CHECK-NEXT:    ret i32 [[TMP3]]
;
  %and = and i32 %x, %y
  %not = xor i32 %x, -1
  %not1 = xor i32 %y, -1
  %and2 = and i32 %not, %not1
  %or = or i32 %and, %and2
  %and3 = and i32 %x, %y
  %not4 = xor i32 %y, -1
  %and5 = and i32 %x, %not4
  %or6 = or i32 %and3, %and5
  %xor = xor i32 %or, %or6
  %not7 = xor i32 %y, -1
  %and8 = and i32 %z, %not7
  %and9 = and i32 %xor, %and8
  %xor10 = xor i32 %or, %and9
  %xor11 = xor i32 %xor10, %y
  %xor12 = xor i32 %xor11, -1
  ret i32 %xor12
}
define i32 @test3_already_optimal(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test3_already_optimal(
; CHECK-NEXT:    [[OR:%.*]] = or i32 [[Y:%.*]], [[Z:%.*]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i32 [[OR]], [[X:%.*]]
; CHECK-NEXT:    [[NOT:%.*]] = xor i32 [[XOR]], -1
; CHECK-NEXT:    ret i32 [[NOT]]
;
  %or = or i32 %y, %z
  %xor = xor i32 %or, %x
  %not = xor i32 %xor, -1
  ret i32 %not
}
; Negative Tests
; Test with non-bitwise operation (should not transform - add/sub not supported)
define i32 @negative_non_bitwise_add(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @negative_non_bitwise_add(
; CHECK-NEXT:    [[ADD1:%.*]] = add i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[ADD1]], [[Z:%.*]]
; CHECK-NEXT:    ret i32 [[ADD2]]
;
  %add1 = add i32 %x, %y
  %add2 = add i32 %add1, %z
  ret i32 %add2
}
; Test with only 2 variables (should not transform - needs exactly 3 variables)
define i32 @negative_two_variables(i32 %x, i32 %y) {
; CHECK-LABEL: @negative_two_variables(
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[NOT:%.*]] = xor i32 [[AND]], -1
; CHECK-NEXT:    ret i32 [[NOT]]
;
  %and = and i32 %x, %y
  %not = xor i32 %and, -1
  ret i32 %not
}
; Test with 4 variables (should not transform - needs exactly 3 variables)
define i32 @negative_four_variables(i32 %x, i32 %y, i32 %z, i32 %w) {
; CHECK-LABEL: @negative_four_variables(
; CHECK-NEXT:    [[AND1:%.*]] = and i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[AND2:%.*]] = and i32 [[Z:%.*]], [[W:%.*]]
; CHECK-NEXT:    [[OR:%.*]] = or i32 [[AND1]], [[AND2]]
; CHECK-NEXT:    ret i32 [[OR]]
;
  %and1 = and i32 %x, %y
  %and2 = and i32 %z, %w
  %or = or i32 %and1, %and2
  ret i32 %or
}
; Test with simple 2-level expression (should not transform - not complex enough)
define i32 @negative_simple_expression(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @negative_simple_expression(
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[OR:%.*]] = or i32 [[AND]], [[Z:%.*]]
; CHECK-NEXT:    ret i32 [[OR]]
;
  %and = and i32 %x, %y
  %or = or i32 %and, %z
  ret i32 %or
}
; Test with instructions in different basic blocks (should not transform)
define i32 @negative_different_basic_blocks(i32 %x, i32 %y, i32 %z, i1 %cond) {
; CHECK-LABEL: @negative_different_basic_blocks(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND1:%.*]] = and i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[IF_TRUE:%.*]], label [[IF_FALSE:%.*]]
; CHECK:       if.true:
; CHECK-NEXT:    [[AND2:%.*]] = and i32 [[AND1]], [[Z:%.*]]
; CHECK-NEXT:    ret i32 [[AND2]]
; CHECK:       if.false:
; CHECK-NEXT:    ret i32 [[AND1]]
;
entry:
  %and1 = and i32 %x, %y
  br i1 %cond, label %if.true, label %if.false
if.true:
  %and2 = and i32 %and1, %z
  ret i32 %and2
if.false:
  ret i32 %and1
}
