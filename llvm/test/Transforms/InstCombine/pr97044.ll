; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s
; Tests for GitHub issue #97044 - Boolean expression canonicalization
define i32 @test0_4way_or(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test0_4way_or(
; CHECK-NEXT:    [[NOT:%.*]] = xor i32 [[Z:%.*]], -1
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[Y:%.*]], [[NOT]]
; CHECK-NEXT:    [[AND1:%.*]] = and i32 [[AND]], [[X:%.*]]
; CHECK-NEXT:    [[NOT2:%.*]] = xor i32 [[Y]], -1
; CHECK-NEXT:    [[AND3:%.*]] = and i32 [[X]], [[NOT2]]
; CHECK-NEXT:    [[AND4:%.*]] = and i32 [[AND3]], [[Z]]
; CHECK-NEXT:    [[OR:%.*]] = or i32 [[AND1]], [[AND4]]
; CHECK-NEXT:    [[AND7_DEMORGAN:%.*]] = or i32 [[X]], [[Y]]
; CHECK-NEXT:    [[AND9_DEMORGAN:%.*]] = or i32 [[AND7_DEMORGAN]], [[Z]]
; CHECK-NEXT:    [[AND9:%.*]] = xor i32 [[AND9_DEMORGAN]], -1
; CHECK-NEXT:    [[OR10:%.*]] = or i32 [[OR]], [[AND9]]
; CHECK-NEXT:    [[AND11:%.*]] = and i32 [[X]], [[Y]]
; CHECK-NEXT:    [[AND12:%.*]] = and i32 [[AND11]], [[Z]]
; CHECK-NEXT:    [[OR13:%.*]] = or i32 [[OR10]], [[AND12]]
; CHECK-NEXT:    ret i32 [[OR13]]
;
  %not = xor i32 %z, -1
  %and = and i32 %y, %not
  %and1 = and i32 %and, %x
  %not2 = xor i32 %y, -1
  %and3 = and i32 %x, %not2
  %and4 = and i32 %and3, %z
  %or = or i32 %and1, %and4
  %not5 = xor i32 %x, -1
  %not6 = xor i32 %y, -1
  %and7 = and i32 %not5, %not6
  %not8 = xor i32 %z, -1
  %and9 = and i32 %and7, %not8
  %or10 = or i32 %or, %and9
  %and11 = and i32 %x, %y
  %and12 = and i32 %and11, %z
  %or13 = or i32 %or10, %and12
  ret i32 %or13
}
define i32 @test1_xor_pattern(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test1_xor_pattern(
; CHECK-NEXT:    [[TMP1:%.*]] = xor i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    [[AND4_DEMORGAN:%.*]] = or i32 [[TMP1]], [[Z:%.*]]
; CHECK-NEXT:    [[AND8:%.*]] = and i32 [[Z]], [[X]]
; CHECK-NEXT:    [[TMP2:%.*]] = xor i32 [[AND4_DEMORGAN]], -1
; CHECK-NEXT:    [[XOR:%.*]] = or i32 [[AND8]], [[TMP2]]
; CHECK-NEXT:    ret i32 [[XOR]]
;
  %not = xor i32 %z, -1
  %and = and i32 %x, %y
  %not1 = xor i32 %x, -1
  %not2 = xor i32 %y, -1
  %and3 = and i32 %not1, %not2
  %or = or i32 %and, %and3
  %and4 = and i32 %not, %or
  %and5 = and i32 %x, %y
  %and6 = and i32 %x, %not2
  %or7 = or i32 %and5, %and6
  %and8 = and i32 %z, %or7
  %xor = xor i32 %and4, %and8
  ret i32 %xor
}
define i32 @test2_nested_xor(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test2_nested_xor(
; CHECK-NEXT:    [[NOT7:%.*]] = xor i32 [[Y:%.*]], -1
; CHECK-NEXT:    [[AND8:%.*]] = and i32 [[Z:%.*]], [[NOT7]]
; CHECK-NEXT:    [[TMP1:%.*]] = xor i32 [[X:%.*]], [[AND8]]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
  %and = and i32 %x, %y
  %not = xor i32 %x, -1
  %not1 = xor i32 %y, -1
  %and2 = and i32 %not, %not1
  %or = or i32 %and, %and2
  %and3 = and i32 %x, %y
  %not4 = xor i32 %y, -1
  %and5 = and i32 %x, %not4
  %or6 = or i32 %and3, %and5
  %xor = xor i32 %or, %or6
  %not7 = xor i32 %y, -1
  %and8 = and i32 %z, %not7
  %and9 = and i32 %xor, %and8
  %xor10 = xor i32 %or, %and9
  %xor11 = xor i32 %xor10, %y
  %xor12 = xor i32 %xor11, -1
  ret i32 %xor12
}
define i32 @test3_already_optimal(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: @test3_already_optimal(
; CHECK-NEXT:    [[OR:%.*]] = or i32 [[Y:%.*]], [[Z:%.*]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i32 [[OR]], [[X:%.*]]
; CHECK-NEXT:    [[NOT:%.*]] = xor i32 [[XOR]], -1
; CHECK-NEXT:    ret i32 [[NOT]]
;
  %or = or i32 %y, %z
  %xor = xor i32 %or, %x
  %not = xor i32 %xor, -1
  ret i32 %not
}
