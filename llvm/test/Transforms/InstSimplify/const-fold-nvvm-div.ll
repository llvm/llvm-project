; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instsimplify -march=nvptx64 --mcpu=sm_86 --mattr=+ptx72 -S | FileCheck %s

; Check constant-folding for NVVM divide intrinsics with different rounding modes

;###############################################################
;#                    Div(1.25, 2.0)                           #
;###############################################################
; Tests division of two normal numbers (1.25 by 2.0) where the result
; is exactly representable. All rounding modes should produce the same result.

define double @test_1_25_div_2_rm_d() {
; CHECK-LABEL: define double @test_1_25_div_2_rm_d() {
; CHECK-NEXT:    ret double 6.250000e-01
;
  %res = call double @llvm.nvvm.div.rm.d(double 1.25, double 2.0)
  ret double %res
}

define double @test_1_25_div_2_rn_d() {
; CHECK-LABEL: define double @test_1_25_div_2_rn_d() {
; CHECK-NEXT:    ret double 6.250000e-01
;
  %res = call double @llvm.nvvm.div.rn.d(double 1.25, double 2.0)
  ret double %res
}

define double @test_1_25_div_2_rp_d() {
; CHECK-LABEL: define double @test_1_25_div_2_rp_d() {
; CHECK-NEXT:    ret double 6.250000e-01
;
  %res = call double @llvm.nvvm.div.rp.d(double 1.25, double 2.0)
  ret double %res
}

define double @test_1_25_div_2_rz_d() {
; CHECK-LABEL: define double @test_1_25_div_2_rz_d() {
; CHECK-NEXT:    ret double 6.250000e-01
;
  %res = call double @llvm.nvvm.div.rz.d(double 1.25, double 2.0)
  ret double %res
}

define float @test_1_25_div_2_rm_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rm_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rm.f(float 1.25, float 2.0)
  ret float %res
}

define float @test_1_25_div_2_rn_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rn_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rn.f(float 1.25, float 2.0)
  ret float %res
}

define float @test_1_25_div_2_rp_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rp_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rp.f(float 1.25, float 2.0)
  ret float %res
}

define float @test_1_25_div_2_rz_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rz_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rz.f(float 1.25, float 2.0)
  ret float %res
}

define float @test_1_25_div_2_rm_ftz_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rm_ftz_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 1.25, float 2.0)
  ret float %res
}

define float @test_1_25_div_2_rn_ftz_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rn_ftz_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 1.25, float 2.0)
  ret float %res
}

define float @test_1_25_div_2_rp_ftz_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rp_ftz_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 1.25, float 2.0)
  ret float %res
}

define float @test_1_25_div_2_rz_ftz_f() {
; CHECK-LABEL: define float @test_1_25_div_2_rz_ftz_f() {
; CHECK-NEXT:    ret float 6.250000e-01
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 1.25, float 2.0)
  ret float %res
}

;###############################################################
;#                    Div(Subnormal, 1.0)                      #
;###############################################################
; Tests division of a subnormal number by 1.0 to verify FTZ behavior.
; For float, we use 2^-149 (smallest subnormal).
; For double, we use 2^-1074 (smallest subnormal).
; Without FTZ, the result should be the subnormal number.
; With FTZ, the result should be 0.0.

define double @test_subnorm_div_1_rm_d() {
; CHECK-LABEL: define double @test_subnorm_div_1_rm_d() {
; CHECK-NEXT:    ret double 4.940660e-324
;
  %res = call double @llvm.nvvm.div.rm.d(double 0x0000000000000001, double 1.0)
  ret double %res
}

define double @test_subnorm_div_1_rn_d() {
; CHECK-LABEL: define double @test_subnorm_div_1_rn_d() {
; CHECK-NEXT:    ret double 4.940660e-324
;
  %res = call double @llvm.nvvm.div.rn.d(double 0x0000000000000001, double 1.0)
  ret double %res
}

define double @test_subnorm_div_1_rp_d() {
; CHECK-LABEL: define double @test_subnorm_div_1_rp_d() {
; CHECK-NEXT:    ret double 4.940660e-324
;
  %res = call double @llvm.nvvm.div.rp.d(double 0x0000000000000001, double 1.0)
  ret double %res
}

define double @test_subnorm_div_1_rz_d() {
; CHECK-LABEL: define double @test_subnorm_div_1_rz_d() {
; CHECK-NEXT:    ret double 4.940660e-324
;
  %res = call double @llvm.nvvm.div.rz.d(double 0x0000000000000001, double 1.0)
  ret double %res
}

define float @test_subnorm_div_1_rm_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rm_f() {
; CHECK-NEXT:    ret float 0x36A0000000000000
;
  %res = call float @llvm.nvvm.div.rm.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

define float @test_subnorm_div_1_rn_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rn_f() {
; CHECK-NEXT:    ret float 0x36A0000000000000
;
  %res = call float @llvm.nvvm.div.rn.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

define float @test_subnorm_div_1_rp_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rp_f() {
; CHECK-NEXT:    ret float 0x36A0000000000000
;
  %res = call float @llvm.nvvm.div.rp.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

define float @test_subnorm_div_1_rz_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rz_f() {
; CHECK-NEXT:    ret float 0x36A0000000000000
;
  %res = call float @llvm.nvvm.div.rz.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

define float @test_subnorm_div_1_rm_ftz_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rm_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

define float @test_subnorm_div_1_rn_ftz_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rn_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

define float @test_subnorm_div_1_rp_ftz_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rp_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

define float @test_subnorm_div_1_rz_ftz_f() {
; CHECK-LABEL: define float @test_subnorm_div_1_rz_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 0x36A0000000000000, float 1.0)
  ret float %res
}

;###############################################################
;#                    Div(Normal, Normal) -> Subnormal         #
;###############################################################
; Tests division of two normal numbers that produces a subnormal result.
; We divide the smallest normal float (2^-126 or 2^-1022 for doubles) by 2 to get 2^-127 (or 2^-1023),
; which is subnormal. This tests the transition from normal to subnormal numbers.

define double @test_normal_div_normal_to_subnorm_rm_d() {
; CHECK-LABEL: define double @test_normal_div_normal_to_subnorm_rm_d() {
; CHECK-NEXT:    ret double 0x8000000000000
;
  %res = call double @llvm.nvvm.div.rm.d(double 0x10000000000000, double 2.0)
  ret double %res
}

define double @test_normal_div_normal_to_subnorm_rn_d() {
; CHECK-LABEL: define double @test_normal_div_normal_to_subnorm_rn_d() {
; CHECK-NEXT:    ret double 0x8000000000000
;
  %res = call double @llvm.nvvm.div.rn.d(double 0x10000000000000, double 2.0)
  ret double %res
}

define double @test_normal_div_normal_to_subnorm_rp_d() {
; CHECK-LABEL: define double @test_normal_div_normal_to_subnorm_rp_d() {
; CHECK-NEXT:    ret double 0x8000000000000
;
  %res = call double @llvm.nvvm.div.rp.d(double 0x10000000000000, double 2.0)
  ret double %res
}

define double @test_normal_div_normal_to_subnorm_rz_d() {
; CHECK-LABEL: define double @test_normal_div_normal_to_subnorm_rz_d() {
; CHECK-NEXT:    ret double 0x8000000000000
;
  %res = call double @llvm.nvvm.div.rz.d(double 0x10000000000000, double 2.0)
  ret double %res
}

define float @test_normal_div_normal_to_subnorm_rm_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rm_f() {
; CHECK-NEXT:    ret float 0x3800000000000000
;
  %res = call float @llvm.nvvm.div.rm.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

define float @test_normal_div_normal_to_subnorm_rn_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rn_f() {
; CHECK-NEXT:    ret float 0x3800000000000000
;
  %res = call float @llvm.nvvm.div.rn.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

define float @test_normal_div_normal_to_subnorm_rp_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rp_f() {
; CHECK-NEXT:    ret float 0x3800000000000000
;
  %res = call float @llvm.nvvm.div.rp.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

define float @test_normal_div_normal_to_subnorm_rz_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rz_f() {
; CHECK-NEXT:    ret float 0x3800000000000000
;
  %res = call float @llvm.nvvm.div.rz.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

define float @test_normal_div_normal_to_subnorm_rm_ftz_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rm_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

define float @test_normal_div_normal_to_subnorm_rn_ftz_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rn_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

define float @test_normal_div_normal_to_subnorm_rp_ftz_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rp_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

define float @test_normal_div_normal_to_subnorm_rz_ftz_f() {
; CHECK-LABEL: define float @test_normal_div_normal_to_subnorm_rz_ftz_f() {
; CHECK-NEXT:    ret float 0.000000e+00
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 0x3810000000000000, float 2.0)
  ret float %res
}

;###############################################################
;#              Div( 4/3 + epsilon , 4/3 - epsilon)            #
;###############################################################
; Tests division of numbers just above and just below 4/3.
; The result falls between 1.0 and 1.0 + 2^-23
; - RZ, RM round to 1.0 (rounding towards zero/down)
; - RN, RP rounds to 1.0 + 2^-23 (rounding towards nearest/up)

define float @test_div_just_above_1_rm_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rm_f() {
; CHECK-NEXT:    ret float 1.000000e+00
;
  %res = call float @llvm.nvvm.div.rm.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_above_1_rn_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rn_f() {
; CHECK-NEXT:    ret float 0x3FF0000020000000
;
  %res = call float @llvm.nvvm.div.rn.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_above_1_rp_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rp_f() {
; CHECK-NEXT:    ret float 0x3FF0000020000000
;
  %res = call float @llvm.nvvm.div.rp.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_above_1_rz_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rz_f() {
; CHECK-NEXT:    ret float 1.000000e+00
;
  %res = call float @llvm.nvvm.div.rz.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_above_1_rm_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rm_ftz_f() {
; CHECK-NEXT:    ret float 1.000000e+00
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_above_1_rn_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rn_ftz_f() {
; CHECK-NEXT:    ret float 0x3FF0000020000000
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_above_1_rp_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rp_ftz_f() {
; CHECK-NEXT:    ret float 0x3FF0000020000000
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_above_1_rz_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_1_rz_ftz_f() {
; CHECK-NEXT:    ret float 1.000000e+00
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 0x3FF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

;###############################################################
;#               Div(4/3 + epsilon / 4/3 - epsilon)            #
;###############################################################
; Tests division of numbers just above and just below 4/3.
; The result falls between 1.0 and 1.0 + 2^-52
; - RZ, RM round to 1.0 (rounding towards zero/down)
; - RN, RP rounds to 1.0 + 2^-23 (rounding towards nearest/up)

define double @test_div_just_above_1_rm_d() {
; CHECK-LABEL: define double @test_div_just_above_1_rm_d() {
; CHECK-NEXT:    ret double 1.000000e+00
;
  %res = call double @llvm.nvvm.div.rm.d(double 0x3FF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

define double @test_div_just_above_1_rn_d() {
; CHECK-LABEL: define double @test_div_just_above_1_rn_d() {
; CHECK-NEXT:    ret double 0x3FF0000000000001
;
  %res = call double @llvm.nvvm.div.rn.d(double 0x3FF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

define double @test_div_just_above_1_rp_d() {
; CHECK-LABEL: define double @test_div_just_above_1_rp_d() {
; CHECK-NEXT:    ret double 0x3FF0000000000001
;
  %res = call double @llvm.nvvm.div.rp.d(double 0x3FF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

define double @test_div_just_above_1_rz_d() {
; CHECK-LABEL: define double @test_div_just_above_1_rz_d() {
; CHECK-NEXT:    ret double 1.000000e+00
;
  %res = call double @llvm.nvvm.div.rz.d(double 0x3FF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

;###############################################################
;#            Div( -(4/3 + epsilon),  4/3 - epsilon  )         #
;###############################################################
; Tests division of numbers just below -4/3 and just below 4/3.
; The result falls between -1.0 and -1.0 - 2^-52
; - RZ, RP round to -1.0 (rounding towards zero/up)
; - RN, RM rounds to -1.0 - 2^-52 (rounding towards nearest/down)

define float @test_div_just_below_negative_1_rm_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rm_f() {
; CHECK-NEXT:    ret float 0xBFF0000020000000
;
  %res = call float @llvm.nvvm.div.rm.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_below_negative_1_rn_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rn_f() {
; CHECK-NEXT:    ret float 0xBFF0000020000000
;
  %res = call float @llvm.nvvm.div.rn.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_below_negative_1_rp_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rp_f() {
; CHECK-NEXT:    ret float -1.000000e+00
;
  %res = call float @llvm.nvvm.div.rp.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_below_negative_1_rz_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rz_f() {
; CHECK-NEXT:    ret float -1.000000e+00
;
  %res = call float @llvm.nvvm.div.rz.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_below_negative_1_rm_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rm_ftz_f() {
; CHECK-NEXT:    ret float 0xBFF0000020000000
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_below_negative_1_rn_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rn_ftz_f() {
; CHECK-NEXT:    ret float 0xBFF0000020000000
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_below_negative_1_rp_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rp_ftz_f() {
; CHECK-NEXT:    ret float -1.000000e+00
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

define float @test_div_just_below_negative_1_rz_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_negative_1_rz_ftz_f() {
; CHECK-NEXT:    ret float -1.000000e+00
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 0xBFF5555560000000, float 0x3FF5555540000000)
  ret float %res
}

;###############################################################
;#            Div( -(4/3 + epsilon),  4/3 - epsilon  )         #
;###############################################################
; Tests division of numbers just below -4/3 and just below 4/3.
; The result falls between -1.0 and -1.0 - 2^-52
; - RZ, RP round to -1.0 (rounding towards zero/up)
; - RN, RM rounds to -1.0 - 2^-52 (rounding towards nearest/down)

define double @test_div_just_below_negative_1_rm_d() {
; CHECK-LABEL: define double @test_div_just_below_negative_1_rm_d() {
; CHECK-NEXT:    ret double 0xBFF0000000000001
;
  %res = call double @llvm.nvvm.div.rm.d(double 0xBFF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

define double @test_div_just_below_negative_1_rn_d() {
; CHECK-LABEL: define double @test_div_just_below_negative_1_rn_d() {
; CHECK-NEXT:    ret double 0xBFF0000000000001
;
  %res = call double @llvm.nvvm.div.rn.d(double 0xBFF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

define double @test_div_just_below_negative_1_rp_d() {
; CHECK-LABEL: define double @test_div_just_below_negative_1_rp_d() {
; CHECK-NEXT:    ret double -1.000000e+00
;
  %res = call double @llvm.nvvm.div.rp.d(double 0xBFF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

define double @test_div_just_below_negative_1_rz_d() {
; CHECK-LABEL: define double @test_div_just_below_negative_1_rz_d() {
; CHECK-NEXT:    ret double -1.000000e+00
;
  %res = call double @llvm.nvvm.div.rz.d(double 0xBFF5555555555555, double 0x3FF5555555555554)
  ret double %res
}

;###############################################################
;#                    Div(~4/3 , ~4/3 + epsilon)               #
;###############################################################
; Tests division of ~4/3 by a value just over 4/3
; The exact result falls between 1.0 - 2^23 ( = 0x3FEFFFFFC0000000)
; and 1.0 - (2^23 + 2^24)  ( = 0x3FEFFFFFA0000000).
; - RN, RZ, RM round to 1.0 - 2^-23 - 2^-24 (rounding towards nearest/zero/down)
; - RP rounds to 1.0 - 2^-23 (rounding up)

define float @test_div_just_below_1_rm_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rm_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rm.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_below_1_rn_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rn_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rn.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_below_1_rp_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rp_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFC0000000
;
  %res = call float @llvm.nvvm.div.rp.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_below_1_rz_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rz_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rz.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_below_1_rm_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rm_ftz_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_below_1_rn_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rn_ftz_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_below_1_rp_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rp_ftz_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFC0000000
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_below_1_rz_ftz_f() {
; CHECK-LABEL: define float @test_div_just_below_1_rz_ftz_f() {
; CHECK-NEXT:    ret float 0x3FEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 0x3FF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

;###############################################################
;#                    Div(~4/3 , ~4/3 + epsilon)               #
;###############################################################
; Tests division of ~4/3 by a value just over 4/3
; The exact result falls between 1.0 - 2^-51 - 2^-52  ( = 0x3FEFFFFFFFFFFFFA)
; and 1.0 - 2^-51 - 2^-53  ( = 0x3FEFFFFFFFFFFFFB).
; - RN, RZ, RM round to 1.0 - 2^-51 - 2^-52 (rounding towards nearest/zero/down)
; - RP rounds to 1.0 - 2^-51 - 2^-53 (rounding up)

define double @test_div_just_below_1_rm_d() {
; CHECK-LABEL: define double @test_div_just_below_1_rm_d() {
; CHECK-NEXT:    ret double 0x3FEFFFFFFFFFFFFA
;
  %res = call double @llvm.nvvm.div.rm.d(double 0x3FF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

define double @test_div_just_below_1_rn_d() {
; CHECK-LABEL: define double @test_div_just_below_1_rn_d() {
; CHECK-NEXT:    ret double 0x3FEFFFFFFFFFFFFA
;
  %res = call double @llvm.nvvm.div.rn.d(double 0x3FF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

define double @test_div_just_below_1_rp_d() {
; CHECK-LABEL: define double @test_div_just_below_1_rp_d() {
; CHECK-NEXT:    ret double 0x3FEFFFFFFFFFFFFB
;
  %res = call double @llvm.nvvm.div.rp.d(double 0x3FF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

define double @test_div_just_below_1_rz_d() {
; CHECK-LABEL: define double @test_div_just_below_1_rz_d() {
; CHECK-NEXT:    ret double 0x3FEFFFFFFFFFFFFA
;
  %res = call double @llvm.nvvm.div.rz.d(double 0x3FF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

;###############################################################
;#                   Div(-4/3, ~4/3 + epsilon)                 #
;###############################################################
; Tests division of ~4/3 by a value just over 4/3
; The exact result falls between 1.0 - 2^23 ( = 0x3FEFFFFFC0000000)
; and 1.0 - (2^23 + 2^24)  ( = 0x3FEFFFFFA0000000).
; - RN, RZ, RP round to -1.0 + 2^-23 + + 2^-24 (rounding towards nearest/zero/up)
; - RM rounds to -1.0 + 2^-23 (rounding up)

define float @test_div_just_above_negative_1_rm_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rm_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFC0000000
;
  %res = call float @llvm.nvvm.div.rm.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_above_negative_1_rn_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rn_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rn.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_above_negative_1_rp_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rp_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rp.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_above_negative_1_rz_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rz_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rz.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_above_negative_1_rm_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rm_ftz_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFC0000000
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_above_negative_1_rn_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rn_ftz_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_above_negative_1_rp_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rp_ftz_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

define float @test_div_just_above_negative_1_rz_ftz_f() {
; CHECK-LABEL: define float @test_div_just_above_negative_1_rz_ftz_f() {
; CHECK-NEXT:    ret float 0xBFEFFFFFA0000000
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 0xBFF5555540000000, float 0x3FF5555580000000)
  ret float %res
}

;###############################################################
;#                    Div(~4/3 , ~4/3 + epsilon)               #
;###############################################################
; Tests division of ~4/3 by a value just over 4/3
; The exact result falls between -1.0 + 2^-51 + 2^-52  ( = 0x3FEFFFFFFFFFFFFA)
; and -1.0 + 2^-51 + 2^-53  ( = 0x3FEFFFFFFFFFFFFB).
; - RN, RZ, RP round to -1.0 + 2^-51 + 2^-52 (rounding towards nearest/zero/up)
; - RM rounds to -1.0 + 2^-51 + 2^-53 (rounding down)

define double @test_div_just_above_negative_1_rm_d() {
; CHECK-LABEL: define double @test_div_just_above_negative_1_rm_d() {
; CHECK-NEXT:    ret double 0xBFEFFFFFFFFFFFFB
;
  %res = call double @llvm.nvvm.div.rm.d(double 0xBFF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

define double @test_div_just_above_negative_1_rn_d() {
; CHECK-LABEL: define double @test_div_just_above_negative_1_rn_d() {
; CHECK-NEXT:    ret double 0xBFEFFFFFFFFFFFFA
;
  %res = call double @llvm.nvvm.div.rn.d(double 0xBFF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

define double @test_div_just_above_negative_1_rp_d() {
; CHECK-LABEL: define double @test_div_just_above_negative_1_rp_d() {
; CHECK-NEXT:    ret double 0xBFEFFFFFFFFFFFFA
;
  %res = call double @llvm.nvvm.div.rp.d(double 0xBFF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

define double @test_div_just_above_negative_1_rz_d() {
; CHECK-LABEL: define double @test_div_just_above_negative_1_rz_d() {
; CHECK-NEXT:    ret double 0xBFEFFFFFFFFFFFFA
;
  %res = call double @llvm.nvvm.div.rz.d(double 0xBFF5555555555554, double 0x3FF5555555555558)
  ret double %res
}

;###############################################################
;#                    Div(NaN, NaN)                           #
;###############################################################
; Tests division of NaN by NaN to verify that constant folding is not performed
; when the result would be NaN.

define float @test_nan_div_nan_rm_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rm_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rm.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rm.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define float @test_nan_div_nan_rn_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rn_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rn.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rn.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define float @test_nan_div_nan_rp_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rp_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rp.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rp.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define float @test_nan_div_nan_rz_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rz_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define float @test_nan_div_nan_rm_ftz_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rm_ftz_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rm.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rm.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define float @test_nan_div_nan_rn_ftz_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rn_ftz_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rn.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rn.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define float @test_nan_div_nan_rp_ftz_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rp_ftz_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rp.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rp.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define float @test_nan_div_nan_rz_ftz_f() {
; CHECK-LABEL: define float @test_nan_div_nan_rz_ftz_f() {
; CHECK-NEXT:    [[RES:%.*]] = call float @llvm.nvvm.div.rz.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
; CHECK-NEXT:    ret float [[RES]]
;
  %res = call float @llvm.nvvm.div.rz.ftz.f(float 0x7FFFFFFF00000000, float 0x7FFFFFFF00000000)
  ret float %res
}

define double @test_nan_div_nan_rm_d() {
; CHECK-LABEL: define double @test_nan_div_nan_rm_d() {
; CHECK-NEXT:    [[RES:%.*]] = call double @llvm.nvvm.div.rm.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
; CHECK-NEXT:    ret double [[RES]]
;
  %res = call double @llvm.nvvm.div.rm.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
  ret double %res
}

define double @test_nan_div_nan_rn_d() {
; CHECK-LABEL: define double @test_nan_div_nan_rn_d() {
; CHECK-NEXT:    [[RES:%.*]] = call double @llvm.nvvm.div.rn.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
; CHECK-NEXT:    ret double [[RES]]
;
  %res = call double @llvm.nvvm.div.rn.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
  ret double %res
}

define double @test_nan_div_nan_rp_d() {
; CHECK-LABEL: define double @test_nan_div_nan_rp_d() {
; CHECK-NEXT:    [[RES:%.*]] = call double @llvm.nvvm.div.rp.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
; CHECK-NEXT:    ret double [[RES]]
;
  %res = call double @llvm.nvvm.div.rp.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
  ret double %res
}

define double @test_nan_div_nan_rz_d() {
; CHECK-LABEL: define double @test_nan_div_nan_rz_d() {
; CHECK-NEXT:    [[RES:%.*]] = call double @llvm.nvvm.div.rz.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
; CHECK-NEXT:    ret double [[RES]]
;
  %res = call double @llvm.nvvm.div.rz.d(double 0x7FFFFFFFFFFFFFFF, double 0x7FFFFFFFFFFFFFFF)
  ret double %res
}
