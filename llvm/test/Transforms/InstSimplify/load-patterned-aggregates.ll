; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instsimplify -S | FileCheck %s
target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:32:32-n8:16:32"
@constzeroarray = internal constant [4 x i32] zeroinitializer

@constarray = internal constant [8 x i8]  c"\01\00\01\00\01\00\01\00", align 4
@conststruct = internal constant <{[8 x i8]}>  <{[8 x i8] c"\01\00\01\00\01\00\01\00"}>, align 4

define i32 @load_gep_const_zero_array(i64 %idx) {
; CHECK-LABEL: @load_gep_const_zero_array(
; CHECK-NEXT:    ret i32 0
;
  %gep = getelementptr inbounds [4 x i32], ptr @constzeroarray, i64 0, i64 %idx
  %load = load i32, ptr %gep
  ret i32 %load
}

define i8 @load_i8_multi_gep_const_zero_array(i64 %idx1, i64 %idx2) {
; CHECK-LABEL: @load_i8_multi_gep_const_zero_array(
; CHECK-NEXT:    ret i8 0
;
  %gep1 = getelementptr inbounds i8, ptr @constzeroarray, i64 %idx1
  %gep = getelementptr inbounds i8, ptr %gep1, i64 %idx2
  %load = load i8, ptr %gep
  ret i8 %load
}


define i32 @load_gep_const_patterned_array(i64 %idx) {
; CHECK-LABEL: @load_gep_const_patterned_array(
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds [4 x i32], ptr @constarray, i64 0, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-NEXT:    ret i32 [[LOAD]]
;
  %gep = getelementptr inbounds [4 x i32], ptr @constarray, i64 0, i64 %idx
  %load = load i32, ptr %gep
  ret i32 %load
}

define i8 @load_i8_multi_gep_const_array(i64 %idx1, i64 %idx2) {
; CHECK-LABEL: @load_i8_multi_gep_const_array(
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i8, ptr @constarray, i64 [[IDX1:%.*]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, ptr [[GEP1]], i64 [[IDX2:%.*]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[GEP]], align 1
; CHECK-NEXT:    ret i8 [[LOAD]]
;
  %gep1 = getelementptr inbounds i8, ptr @constarray, i64 %idx1
  %gep = getelementptr inbounds i8, ptr %gep1, i64 %idx2
  %load = load i8, ptr %gep
  ret i8 %load
}

; TODO: this should be ret i8 1
define i8 @gep_load_i8_align2(i64 %idx){
; CHECK-LABEL: @gep_load_i8_align2(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr @constarray, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[TMP1]], align 2
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %1 = getelementptr inbounds i8, ptr @constarray, i64 %idx
  %2 = load i8, ptr %1, align 2
  ret i8 %2
}

; can't be folded
define i8 @gep_load_i8_align1(i64 %idx){
; CHECK-LABEL: @gep_load_i8_align1(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr @constarray, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[TMP1]], align 1
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %1 = getelementptr inbounds i8, ptr @constarray, i64 %idx
  %2 = load i8, ptr %1, align 1
  ret i8 %2
}

; TODO: this should be ret i8 65537 on the case for little endian
define i32 @gep_i32_load_i32_align4(i64 %idx){
; CHECK-LABEL: @gep_i32_load_i32_align4(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr @constarray, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 4
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %1 = getelementptr inbounds i32, ptr @constarray, i64 %idx
  %2 = load i32, ptr %1, align 4
  ret i32 %2
}

; TODO: this should be ret i8 65537 on the case for little endian
define i32 @gep_i32_load_i32_align4_struct(i64 %idx){
; CHECK-LABEL: @gep_i32_load_i32_align4_struct(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr @conststruct, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 4
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %1 = getelementptr inbounds i32, ptr @conststruct, i64 %idx
  %2 = load i32, ptr %1, align 4
  ret i32 %2
}

; can't be folded
define i32 @gep_i8_load_i32_align1(i64 %idx){
; CHECK-LABEL: @gep_i8_load_i32_align1(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr @constarray, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 1
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %1 = getelementptr inbounds i8, ptr @constarray, i64 %idx
  %2 = load i32, ptr %1, align 1
  ret i32 %2
}

; can't be folded
define i32 @gep_i8_load_i32_align1_struct(i64 %idx){
; CHECK-LABEL: @gep_i8_load_i32_align1_struct(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr @conststruct, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 1
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %1 = getelementptr inbounds i8, ptr @conststruct, i64 %idx
  %2 = load i32, ptr %1, align 1
  ret i32 %2
}
; TODO: This could be folded but need to see GEP source types
define i32 @gep_i16_load_i32_align1(i64 %idx){
; CHECK-LABEL: @gep_i16_load_i32_align1(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i16, ptr @constarray, i64 [[IDX:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 1
; CHECK-NEXT:    ret i32 [[TMP2]]
;
  %1 = getelementptr inbounds i16, ptr @constarray, i64 %idx
  %2 = load i32, ptr %1, align 1
  ret i32 %2
}
