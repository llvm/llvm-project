; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=powerpc64-unknown-linux-gnu -passes=loop-unroll -S %s | FileCheck %s

; Test that loop peeling for load widening correctly handles big-endian targets.
; On PowerPC64 (big-endian), the cost model determines that widening 3 consecutive
; i8 loads to an i32 load + shifts + truncs is NOT profitable (widened cost > original),
; so the optimization correctly bails out. This test verifies the cost model check
; works on big-endian targets.
;
; Note: The big-endian extraction logic (different shift directions from LE) is
; tested implicitly - if cost model ever changes to favor widening on BE targets,
; this test's CHECK lines would need updating to verify correct shift amounts.

; Test that 3-byte consecutive loads are NOT widened on PowerPC due to cost model.
define void @test_3_consecutive_loads_be(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_3_consecutive_loads_be(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  ; Use the loaded values to prevent DCE
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

