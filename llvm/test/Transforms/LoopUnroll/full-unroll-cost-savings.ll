; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=loop-unroll -unroll-threshold=25 < %s | FileCheck %s

; All functions are simple variations of the same double nested loop with an
; if/then/else-like CFG structure in the outer loop. The unrolling threshold is
; set manually so that it is just slightly higher than the estimated unrolled
; cost of the outer loop in the baseline, even after unroll cost savings
; analysis.

; Baseline. Inner loop's bounds and if/then/else's condition depend on function
; arguments. No unrolling happens.

define void @no_fullunroll(ptr noundef %mem, i32 noundef %inner.ub, i32 noundef %ifcond) {
; CHECK-LABEL: @no_fullunroll(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[OUTER_HEADER:%.*]]
; CHECK:       outer.header:
; CHECK-NEXT:    [[OUTER_IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[OUTER_IV_NEXT:%.*]], [[OUTER_LATCH_EXITING:%.*]] ]
; CHECK-NEXT:    [[OUTER_IV_EXT:%.*]] = zext nneg i32 [[OUTER_IV]] to i64
; CHECK-NEXT:    br label [[INNER_HEADER_LATCH_EXITING:%.*]]
; CHECK:       inner.header_latch_exiting:
; CHECK-NEXT:    [[INNER_IV:%.*]] = phi i32 [ [[OUTER_IV]], [[OUTER_HEADER]] ], [ [[INNER_IV_NEXT:%.*]], [[INNER_HEADER_LATCH_EXITING]] ]
; CHECK-NEXT:    [[INNER_IV_NEXT]] = add nuw nsw i32 [[INNER_IV]], 1
; CHECK-NEXT:    [[IDX_PART:%.*]] = mul nuw nsw i64 [[OUTER_IV_EXT]], 16
; CHECK-NEXT:    [[INNER_IV_EXT:%.*]] = zext nneg i32 [[INNER_IV]] to i64
; CHECK-NEXT:    [[IDX:%.*]] = add nuw nsw i64 [[IDX_PART]], [[INNER_IV_EXT]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds i8, ptr [[MEM:%.*]], i64 [[IDX]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR]], align 4
; CHECK-NEXT:    [[INNER_COND:%.*]] = icmp ult i32 [[INNER_IV_NEXT]], [[INNER_UB:%.*]]
; CHECK-NEXT:    br i1 [[INNER_COND]], label [[INNER_HEADER_LATCH_EXITING]], label [[OUTER_IF:%.*]]
; CHECK:       outer.if:
; CHECK-NEXT:    [[IF_ADDR:%.*]] = getelementptr inbounds i8, ptr [[MEM]], i64 [[OUTER_IV_EXT]]
; CHECK-NEXT:    [[MOD2:%.*]] = and i32 [[IFCOND:%.*]], 1
; CHECK-NEXT:    [[IF_COND:%.*]] = icmp ult i32 [[MOD2]], 0
; CHECK-NEXT:    br i1 [[IF_COND]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store i32 1, ptr [[IF_ADDR]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING]]
; CHECK:       if.else:
; CHECK-NEXT:    store i32 2, ptr [[IF_ADDR]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING]]
; CHECK:       outer.latch_exiting:
; CHECK-NEXT:    [[OUTER_IV_NEXT]] = add nuw nsw i32 [[OUTER_IV]], 1
; CHECK-NEXT:    [[OUTER_COND:%.*]] = icmp ult i32 [[OUTER_IV_NEXT]], 2
; CHECK-NEXT:    br i1 [[OUTER_COND]], label [[OUTER_HEADER]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  br label %outer.header

outer.header:                                                 ; preds = %entry, %outer.latch_exiting
  %outer.iv = phi i32 [ 0, %entry ], [ %outer.iv_next, %outer.latch_exiting ]
  %outer.iv.ext = zext nneg i32 %outer.iv to i64
  br label %inner.header_latch_exiting

inner.header_latch_exiting:                                   ; preds = %outer.header, %inner.header_latch_exiting
  %inner.iv = phi i32 [ %outer.iv, %outer.header ], [ %inner.iv_next, %inner.header_latch_exiting ]
  %inner.iv_next = add nuw nsw i32 %inner.iv, 1
  %idx_part = mul nuw nsw i64 %outer.iv.ext, 16
  %inner.iv.ext = zext nneg i32 %inner.iv to i64
  %idx = add nuw nsw i64 %idx_part, %inner.iv.ext
  %addr = getelementptr inbounds i8, ptr %mem, i64 %idx
  store i32 0, ptr %addr
  %inner.cond = icmp ult i32 %inner.iv_next, %inner.ub
  br i1 %inner.cond, label %inner.header_latch_exiting, label %outer.if

outer.if:                                                     ; preds = %inner.header_latch_exiting
  %if.addr = getelementptr inbounds i8, ptr %mem, i64 %outer.iv.ext
  %mod2 = and i32 %ifcond, 1
  %if.cond = icmp ult i32 %mod2, 0
  br i1 %if.cond, label %if.then, label %if.else

if.then:                                                      ; preds = %outer.if
  store i32 1, ptr %if.addr
  br label %outer.latch_exiting

if.else:                                                      ; preds = %outer.if
  store i32 2, ptr %if.addr
  br label %outer.latch_exiting

outer.latch_exiting:                                          ; preds = %if.then, %if.else
  %outer.iv_next = add nuw nsw i32 %outer.iv, 1
  %outer.cond = icmp ult i32 %outer.iv_next, 2
  br i1 %outer.cond, label %outer.header, label %end

end:                                                          ; preds = %outer.latch_exiting
  ret void
}

; Inner loop's bounds depend on constants and outer IV, yielding extra cost
; savings. These are enough to fully unroll the outer loop.

define void @save_subloop(ptr noundef %mem, i32 noundef %ifcond) {
; CHECK-LABEL: @save_subloop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[OUTER_HEADER:%.*]]
; CHECK:       outer.header:
; CHECK-NEXT:    br label [[INNER_HEADER_LATCH_EXITING:%.*]]
; CHECK:       inner.header_latch_exiting:
; CHECK-NEXT:    [[INNER_IV:%.*]] = phi i32 [ 0, [[OUTER_HEADER]] ], [ [[INNER_IV_NEXT:%.*]], [[INNER_HEADER_LATCH_EXITING]] ]
; CHECK-NEXT:    [[INNER_IV_NEXT]] = add nuw nsw i32 [[INNER_IV]], 1
; CHECK-NEXT:    [[INNER_IV_EXT:%.*]] = zext nneg i32 [[INNER_IV]] to i64
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds i8, ptr [[MEM:%.*]], i64 [[INNER_IV_EXT]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR]], align 4
; CHECK-NEXT:    [[INNER_COND:%.*]] = icmp ult i32 [[INNER_IV_NEXT]], 2
; CHECK-NEXT:    br i1 [[INNER_COND]], label [[INNER_HEADER_LATCH_EXITING]], label [[OUTER_LATCH_EXITING_1:%.*]]
; CHECK:       outer.if:
; CHECK-NEXT:    br i1 false, label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store i32 1, ptr [[MEM]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    store i32 2, ptr [[MEM]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING]]
; CHECK:       outer.latch_exiting:
; CHECK-NEXT:    br label [[INNER_HEADER_LATCH_EXITING_1:%.*]]
; CHECK:       inner.header_latch_exiting.1:
; CHECK-NEXT:    [[OUTER_IV:%.*]] = phi i32 [ 1, [[OUTER_LATCH_EXITING]] ], [ [[OUTER_IV_NEXT_1:%.*]], [[INNER_HEADER_LATCH_EXITING_1]] ]
; CHECK-NEXT:    [[OUTER_IV_NEXT_1]] = add nuw nsw i32 [[OUTER_IV]], 1
; CHECK-NEXT:    [[INNER_IV_EXT_1:%.*]] = zext nneg i32 [[OUTER_IV]] to i64
; CHECK-NEXT:    [[IDX_1:%.*]] = add nuw nsw i64 16, [[INNER_IV_EXT_1]]
; CHECK-NEXT:    [[ADDR_1:%.*]] = getelementptr inbounds i8, ptr [[MEM]], i64 [[IDX_1]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR_1]], align 4
; CHECK-NEXT:    [[INNER_COND_1:%.*]] = icmp ult i32 [[OUTER_IV_NEXT_1]], 2
; CHECK-NEXT:    br i1 [[INNER_COND_1]], label [[INNER_HEADER_LATCH_EXITING_1]], label [[OUTER_IF_1:%.*]]
; CHECK:       outer.if.1:
; CHECK-NEXT:    [[IF_ADDR_1:%.*]] = getelementptr inbounds i8, ptr [[MEM]], i64 1
; CHECK-NEXT:    br i1 false, label [[IF_THEN_1:%.*]], label [[IF_ELSE_1:%.*]]
; CHECK:       if.else.1:
; CHECK-NEXT:    store i32 2, ptr [[IF_ADDR_1]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING_2:%.*]]
; CHECK:       if.then.1:
; CHECK-NEXT:    store i32 1, ptr [[IF_ADDR_1]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING_2]]
; CHECK:       outer.latch_exiting.1:
; CHECK-NEXT:    ret void
;
entry:
  br label %outer.header

outer.header:                                                 ; preds = %entry, %outer.latch_exiting
  %outer.iv = phi i32 [ 0, %entry ], [ %outer.iv_next, %outer.latch_exiting ]
  %outer.iv.ext = zext nneg i32 %outer.iv to i64
  br label %inner.header_latch_exiting

inner.header_latch_exiting:                                   ; preds = %outer.header, %inner.header_latch_exiting
  %inner.iv = phi i32 [ %outer.iv, %outer.header ], [ %inner.iv_next, %inner.header_latch_exiting ]
  %inner.iv_next = add nuw nsw i32 %inner.iv, 1
  %idx_part = mul nuw nsw i64 %outer.iv.ext, 16
  %inner.iv.ext = zext nneg i32 %inner.iv to i64
  %idx = add nuw nsw i64 %idx_part, %inner.iv.ext
  %addr = getelementptr inbounds i8, ptr %mem, i64 %idx
  store i32 0, ptr %addr
  %inner.cond = icmp ult i32 %inner.iv_next, 2
  br i1 %inner.cond, label %inner.header_latch_exiting, label %outer.if

outer.if:                                                     ; preds = %inner.header_latch_exiting
  %if.addr = getelementptr inbounds i8, ptr %mem, i64 %outer.iv.ext
  %mod2 = and i32 %ifcond, 1
  %if.cond = icmp ult i32 %mod2, 0
  br i1 %if.cond, label %if.then, label %if.else

if.then:                                                      ; preds = %outer.if
  store i32 1, ptr %if.addr
  br label %outer.latch_exiting

if.else:                                                      ; preds = %outer.if
  store i32 2, ptr %if.addr
  br label %outer.latch_exiting

outer.latch_exiting:                                          ; preds = %if.then, %if.else
  %outer.iv_next = add nuw nsw i32 %outer.iv, 1
  %outer.cond = icmp ult i32 %outer.iv_next, 2
  br i1 %outer.cond, label %outer.header, label %end

end:                                                          ; preds = %outer.latch_exiting
  ret void
}

; If/then/else's condition depends on constants and outer IV, yielding extra
; cost savings. These are enough to fully unroll the outer loop.

define void @save_ifthenelse(ptr noundef %mem, i32 noundef %inner.ub) {
; CHECK-LABEL: @save_ifthenelse(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[OUTER_HEADER:%.*]]
; CHECK:       outer.header:
; CHECK-NEXT:    br label [[INNER_HEADER_LATCH_EXITING:%.*]]
; CHECK:       inner.header_latch_exiting:
; CHECK-NEXT:    [[INNER_IV:%.*]] = phi i32 [ 0, [[OUTER_HEADER]] ], [ [[INNER_IV_NEXT:%.*]], [[INNER_HEADER_LATCH_EXITING]] ]
; CHECK-NEXT:    [[INNER_IV_NEXT]] = add nuw nsw i32 [[INNER_IV]], 1
; CHECK-NEXT:    [[INNER_IV_EXT:%.*]] = zext nneg i32 [[INNER_IV]] to i64
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds i8, ptr [[MEM:%.*]], i64 [[INNER_IV_EXT]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR]], align 4
; CHECK-NEXT:    [[INNER_COND:%.*]] = icmp ult i32 [[INNER_IV_NEXT]], [[INNER_UB:%.*]]
; CHECK-NEXT:    br i1 [[INNER_COND]], label [[INNER_HEADER_LATCH_EXITING]], label [[OUTER_LATCH_EXITING_1:%.*]]
; CHECK:       outer.if:
; CHECK-NEXT:    br i1 false, label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store i32 1, ptr [[MEM]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    store i32 2, ptr [[MEM]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING]]
; CHECK:       outer.latch_exiting:
; CHECK-NEXT:    br label [[INNER_HEADER_LATCH_EXITING_1:%.*]]
; CHECK:       inner.header_latch_exiting.1:
; CHECK-NEXT:    [[OUTER_IV:%.*]] = phi i32 [ 1, [[OUTER_LATCH_EXITING]] ], [ [[OUTER_IV_NEXT_1:%.*]], [[INNER_HEADER_LATCH_EXITING_1]] ]
; CHECK-NEXT:    [[OUTER_IV_NEXT_1]] = add nuw nsw i32 [[OUTER_IV]], 1
; CHECK-NEXT:    [[INNER_IV_EXT_1:%.*]] = zext nneg i32 [[OUTER_IV]] to i64
; CHECK-NEXT:    [[IDX_1:%.*]] = add nuw nsw i64 16, [[INNER_IV_EXT_1]]
; CHECK-NEXT:    [[ADDR_1:%.*]] = getelementptr inbounds i8, ptr [[MEM]], i64 [[IDX_1]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR_1]], align 4
; CHECK-NEXT:    [[INNER_COND_1:%.*]] = icmp ult i32 [[OUTER_IV_NEXT_1]], [[INNER_UB]]
; CHECK-NEXT:    br i1 [[INNER_COND_1]], label [[INNER_HEADER_LATCH_EXITING_1]], label [[OUTER_IF_1:%.*]]
; CHECK:       outer.if.1:
; CHECK-NEXT:    [[IF_ADDR_1:%.*]] = getelementptr inbounds i8, ptr [[MEM]], i64 1
; CHECK-NEXT:    br i1 false, label [[IF_THEN_1:%.*]], label [[IF_ELSE_1:%.*]]
; CHECK:       if.else.1:
; CHECK-NEXT:    store i32 2, ptr [[IF_ADDR_1]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING_2:%.*]]
; CHECK:       if.then.1:
; CHECK-NEXT:    store i32 1, ptr [[IF_ADDR_1]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING_2]]
; CHECK:       outer.latch_exiting.1:
; CHECK-NEXT:    ret void
;
entry:
  br label %outer.header

outer.header:                                                 ; preds = %entry, %outer.latch_exiting
  %outer.iv = phi i32 [ 0, %entry ], [ %outer.iv_next, %outer.latch_exiting ]
  %outer.iv.ext = zext nneg i32 %outer.iv to i64
  br label %inner.header_latch_exiting

inner.header_latch_exiting:                                   ; preds = %outer.header, %inner.header_latch_exiting
  %inner.iv = phi i32 [ %outer.iv, %outer.header ], [ %inner.iv_next, %inner.header_latch_exiting ]
  %inner.iv_next = add nuw nsw i32 %inner.iv, 1
  %idx_part = mul nuw nsw i64 %outer.iv.ext, 16
  %inner.iv.ext = zext nneg i32 %inner.iv to i64
  %idx = add nuw nsw i64 %idx_part, %inner.iv.ext
  %addr = getelementptr inbounds i8, ptr %mem, i64 %idx
  store i32 0, ptr %addr
  %inner.cond = icmp ult i32 %inner.iv_next, %inner.ub
  br i1 %inner.cond, label %inner.header_latch_exiting, label %outer.if

outer.if:                                                     ; preds = %inner.header_latch_exiting
  %if.addr = getelementptr inbounds i8, ptr %mem, i64 %outer.iv.ext
  %mod2 = and i32 %outer.iv, 1
  %if.cond = icmp ult i32 %mod2, 0
  br i1 %if.cond, label %if.then, label %if.else

if.then:                                                      ; preds = %outer.if
  store i32 1, ptr %if.addr
  br label %outer.latch_exiting

if.else:                                                      ; preds = %outer.if
  store i32 2, ptr %if.addr
  br label %outer.latch_exiting

outer.latch_exiting:                                          ; preds = %if.then, %if.else
  %outer.iv_next = add nuw nsw i32 %outer.iv, 1
  %outer.cond = icmp ult i32 %outer.iv_next, 2
  br i1 %outer.cond, label %outer.header, label %end

end:                                                          ; preds = %outer.latch_exiting
  ret void
}


; Tests whether an if/then-like CFG structure is also recognized as a cost
; saving opportunity. Same double nested loop as before, but the if's else
; branch is removed and two extra instructions are added to the then branch to
; maintain the same loop size.

define void @save_ifthen(ptr noundef %mem, i32 noundef %inner.ub) {
; CHECK-LABEL: @save_ifthen(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[OUTER_HEADER:%.*]]
; CHECK:       outer.header:
; CHECK-NEXT:    br label [[INNER_HEADER_LATCH_EXITING:%.*]]
; CHECK:       inner.header_latch_exiting:
; CHECK-NEXT:    [[INNER_IV:%.*]] = phi i32 [ 0, [[OUTER_HEADER]] ], [ [[INNER_IV_NEXT:%.*]], [[INNER_HEADER_LATCH_EXITING]] ]
; CHECK-NEXT:    [[INNER_IV_NEXT]] = add nuw nsw i32 [[INNER_IV]], 1
; CHECK-NEXT:    [[INNER_IV_EXT:%.*]] = zext nneg i32 [[INNER_IV]] to i64
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds i8, ptr [[MEM:%.*]], i64 [[INNER_IV_EXT]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR]], align 4
; CHECK-NEXT:    [[INNER_COND:%.*]] = icmp ult i32 [[INNER_IV_NEXT]], [[INNER_UB:%.*]]
; CHECK-NEXT:    br i1 [[INNER_COND]], label [[INNER_HEADER_LATCH_EXITING]], label [[OUTER_IF:%.*]]
; CHECK:       outer.if:
; CHECK-NEXT:    br i1 false, label [[IF_THEN:%.*]], label [[OUTER_LATCH_EXITING:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store i32 0, ptr [[MEM]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING]]
; CHECK:       outer.latch_exiting:
; CHECK-NEXT:    br label [[INNER_HEADER_LATCH_EXITING_1:%.*]]
; CHECK:       inner.header_latch_exiting.1:
; CHECK-NEXT:    [[INNER_IV_1:%.*]] = phi i32 [ 1, [[OUTER_LATCH_EXITING]] ], [ [[INNER_IV_NEXT_1:%.*]], [[INNER_HEADER_LATCH_EXITING_1]] ]
; CHECK-NEXT:    [[INNER_IV_NEXT_1]] = add nuw nsw i32 [[INNER_IV_1]], 1
; CHECK-NEXT:    [[INNER_IV_EXT_1:%.*]] = zext nneg i32 [[INNER_IV_1]] to i64
; CHECK-NEXT:    [[IDX_1:%.*]] = add nuw nsw i64 16, [[INNER_IV_EXT_1]]
; CHECK-NEXT:    [[ADDR_1:%.*]] = getelementptr inbounds i8, ptr [[MEM]], i64 [[IDX_1]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR_1]], align 4
; CHECK-NEXT:    [[INNER_COND_1:%.*]] = icmp ult i32 [[INNER_IV_NEXT_1]], [[INNER_UB]]
; CHECK-NEXT:    br i1 [[INNER_COND_1]], label [[INNER_HEADER_LATCH_EXITING_1]], label [[OUTER_IF_1:%.*]]
; CHECK:       outer.if.1:
; CHECK-NEXT:    [[IF_ADDR_1:%.*]] = getelementptr inbounds i8, ptr [[MEM]], i64 1
; CHECK-NEXT:    br i1 false, label [[IF_THEN_1:%.*]], label [[OUTER_LATCH_EXITING_1:%.*]]
; CHECK:       if.then.1:
; CHECK-NEXT:    store i32 4, ptr [[IF_ADDR_1]], align 4
; CHECK-NEXT:    br label [[OUTER_LATCH_EXITING_1]]
; CHECK:       outer.latch_exiting.1:
; CHECK-NEXT:    ret void
;
entry:
  br label %outer.header

outer.header:                                                 ; preds = %entry, %outer.latch_exiting
  %outer.iv = phi i32 [ 0, %entry ], [ %outer.iv_next, %outer.latch_exiting ]
  %outer.iv.ext = zext nneg i32 %outer.iv to i64
  br label %inner.header_latch_exiting

inner.header_latch_exiting:                                   ; preds = %outer.header, %inner.header_latch_exiting
  %inner.iv = phi i32 [ %outer.iv, %outer.header ], [ %inner.iv_next, %inner.header_latch_exiting ]
  %inner.iv_next = add nuw nsw i32 %inner.iv, 1
  %idx_part = mul nuw nsw i64 %outer.iv.ext, 16
  %inner.iv.ext = zext nneg i32 %inner.iv to i64
  %idx = add nuw nsw i64 %idx_part, %inner.iv.ext
  %addr = getelementptr inbounds i8, ptr %mem, i64 %idx
  store i32 0, ptr %addr
  %inner.cond = icmp ult i32 %inner.iv_next, %inner.ub
  br i1 %inner.cond, label %inner.header_latch_exiting, label %outer.if

outer.if:                                                     ; preds = %inner.header_latch_exiting
  %if.addr = getelementptr inbounds i8, ptr %mem, i64 %outer.iv.ext
  %mod2 = and i32 %outer.iv, 1
  %if.cond = icmp ult i32 %mod2, 0
  br i1 %if.cond, label %if.then, label %outer.latch_exiting

if.then:                                                      ; preds = %outer.if
  %mod2x2 = mul i32 %mod2, 2
  %mod2x2x2 = mul i32 %mod2x2, 2
  store i32 %mod2x2x2, ptr %if.addr
  br label %outer.latch_exiting

outer.latch_exiting:                                          ; preds = %if.then, $outer.if
  %outer.iv_next = add nuw nsw i32 %outer.iv, 1
  %outer.cond = icmp ult i32 %outer.iv_next, 2
  br i1 %outer.cond, label %outer.header, label %end

end:                                                          ; preds = %outer.latch_exiting
  ret void
}
