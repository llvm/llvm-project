; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -S -passes=loop-unroll | FileCheck %s --check-prefix=AGGRESSIVE
; RUN: opt < %s -S -passes=loop-unroll -unroll-allow-aggressive-eliminate-compares=false | FileCheck %s

; The loop can only be peeled if aggressive compare elimination is allowed
; because one of the condition's components depends on an unknown function
; argument.

define void @unknown_cond_prevents_peel(ptr noundef %mem, i1 noundef zeroext %cond) {
; AGGRESSIVE-LABEL: @unknown_cond_prevents_peel(
; AGGRESSIVE-NEXT:  entry:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL_BEGIN:%.*]]
; AGGRESSIVE:       header.peel.begin:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL:%.*]]
; AGGRESSIVE:       header.peel:
; AGGRESSIVE-NEXT:    [[NOT_FIRST_IT_PEEL:%.*]] = icmp ugt i32 0, 0
; AGGRESSIVE-NEXT:    [[IF_COND_PEEL:%.*]] = and i1 [[COND:%.*]], [[NOT_FIRST_IT_PEEL]]
; AGGRESSIVE-NEXT:    br i1 [[IF_COND_PEEL]], label [[IF_PEEL:%.*]], label [[LATCH_EXITING_PEEL:%.*]]
; AGGRESSIVE:       if.peel:
; AGGRESSIVE-NEXT:    [[IV_EXT_PEEL:%.*]] = zext nneg i32 0 to i64
; AGGRESSIVE-NEXT:    [[ADDR_PEEL:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM:%.*]], i64 [[IV_EXT_PEEL]]
; AGGRESSIVE-NEXT:    store i32 0, ptr [[ADDR_PEEL]], align 4
; AGGRESSIVE-NEXT:    br label [[LATCH_EXITING_PEEL]]
; AGGRESSIVE:       latch_exiting.peel:
; AGGRESSIVE-NEXT:    [[IV_NEXT_PEEL:%.*]] = add nuw nsw i32 0, 1
; AGGRESSIVE-NEXT:    [[LOOP_COND_PEEL:%.*]] = icmp ult i32 [[IV_NEXT_PEEL]], 64
; AGGRESSIVE-NEXT:    br i1 [[LOOP_COND_PEEL]], label [[HEADER_PEEL_NEXT:%.*]], label [[END:%.*]]
; AGGRESSIVE:       header.peel.next:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL_NEXT1:%.*]]
; AGGRESSIVE:       header.peel.next1:
; AGGRESSIVE-NEXT:    br label [[ENTRY_PEEL_NEWPH:%.*]]
; AGGRESSIVE:       entry.peel.newph:
; AGGRESSIVE-NEXT:    br label [[HEADER:%.*]]
; AGGRESSIVE:       header:
; AGGRESSIVE-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT_PEEL]], [[ENTRY_PEEL_NEWPH]] ], [ [[IV_NEXT:%.*]], [[LATCH_EXITING:%.*]] ]
; AGGRESSIVE-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[LATCH_EXITING]]
; AGGRESSIVE:       if:
; AGGRESSIVE-NEXT:    [[IV_EXT:%.*]] = zext nneg i32 [[IV]] to i64
; AGGRESSIVE-NEXT:    [[ADDR:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT]]
; AGGRESSIVE-NEXT:    store i32 0, ptr [[ADDR]], align 4
; AGGRESSIVE-NEXT:    br label [[LATCH_EXITING]]
; AGGRESSIVE:       latch_exiting:
; AGGRESSIVE-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; AGGRESSIVE-NEXT:    [[LOOP_COND:%.*]] = icmp ult i32 [[IV_NEXT]], 64
; AGGRESSIVE-NEXT:    br i1 [[LOOP_COND]], label [[HEADER]], label [[END_LOOPEXIT:%.*]], !llvm.loop [[LOOP0:![0-9]+]]
; AGGRESSIVE:       end.loopexit:
; AGGRESSIVE-NEXT:    br label [[END]]
; AGGRESSIVE:       end:
; AGGRESSIVE-NEXT:    ret void
;
; CHECK-LABEL: @unknown_cond_prevents_peel(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[HEADER:%.*]]
; CHECK:       header:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LATCH_EXITING:%.*]] ]
; CHECK-NEXT:    [[NOT_FIRST_IT:%.*]] = icmp ugt i32 [[IV]], 0
; CHECK-NEXT:    [[IF_COND:%.*]] = and i1 [[COND:%.*]], [[NOT_FIRST_IT]]
; CHECK-NEXT:    br i1 [[IF_COND]], label [[IF:%.*]], label [[LATCH_EXITING]]
; CHECK:       if:
; CHECK-NEXT:    [[IV_EXT:%.*]] = zext nneg i32 [[IV]] to i64
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM:%.*]], i64 [[IV_EXT]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR]], align 4
; CHECK-NEXT:    br label [[LATCH_EXITING]]
; CHECK:       latch_exiting:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp ult i32 [[IV_NEXT]], 64
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[HEADER]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  br label %header

header:                                                 ; preds = %header, %latch_exiting
  %iv = phi i32 [ 0, %entry ], [ %iv_next, %latch_exiting ]
  %not_first_it = icmp ugt i32 %iv, 0
  %if.cond = and i1 %cond, %not_first_it
  br i1 %if.cond, label %if, label %latch_exiting

if:                                                     ; preds = %header
  %iv.ext = zext nneg i32 %iv to i64
  %addr = getelementptr inbounds [16 x [16 x i32]], ptr %mem, i64 %iv.ext
  store i32 0, ptr %addr, align 4
  br label %latch_exiting

latch_exiting:                                          ; preds = %header, %if
  %iv_next = add nuw nsw i32 %iv, 1
  %loop.cond = icmp ult i32 %iv_next, 64
  br i1 %loop.cond, label %header, label %end

end:                                                    ; preds = %header
  ret void
}

; Even in non-aggressive mode, an unknown select condition should not prevent
; an otherwise possible peeling thanks to all branch conditions being known
; after a number of iterations.

define void @unknown_select_doesnt_prevent_peel(ptr noundef %mem, i1 noundef zeroext %cond) {
; AGGRESSIVE-LABEL: @unknown_select_doesnt_prevent_peel(
; AGGRESSIVE-NEXT:  entry:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL_BEGIN:%.*]]
; AGGRESSIVE:       header.peel.begin:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL:%.*]]
; AGGRESSIVE:       header.peel:
; AGGRESSIVE-NEXT:    [[NOT_FIRST_IT_PEEL:%.*]] = icmp ugt i32 0, 0
; AGGRESSIVE-NEXT:    br i1 [[NOT_FIRST_IT_PEEL]], label [[IF_PEEL:%.*]], label [[LATCH_EXITING_PEEL:%.*]]
; AGGRESSIVE:       if.peel:
; AGGRESSIVE-NEXT:    [[IV_EXT_PEEL:%.*]] = zext nneg i32 0 to i64
; AGGRESSIVE-NEXT:    [[ADDR_PEEL:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM:%.*]], i64 [[IV_EXT_PEEL]]
; AGGRESSIVE-NEXT:    [[DATA_PEEL:%.*]] = select i1 [[COND:%.*]], i32 0, i32 1
; AGGRESSIVE-NEXT:    store i32 [[DATA_PEEL]], ptr [[ADDR_PEEL]], align 4
; AGGRESSIVE-NEXT:    br label [[LATCH_EXITING_PEEL]]
; AGGRESSIVE:       latch_exiting.peel:
; AGGRESSIVE-NEXT:    [[IV_NEXT_PEEL:%.*]] = add nuw nsw i32 0, 1
; AGGRESSIVE-NEXT:    [[LOOP_COND_PEEL:%.*]] = icmp ult i32 [[IV_NEXT_PEEL]], 64
; AGGRESSIVE-NEXT:    br i1 [[LOOP_COND_PEEL]], label [[HEADER_PEEL_NEXT:%.*]], label [[END:%.*]]
; AGGRESSIVE:       header.peel.next:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL_NEXT1:%.*]]
; AGGRESSIVE:       header.peel.next1:
; AGGRESSIVE-NEXT:    br label [[ENTRY_PEEL_NEWPH:%.*]]
; AGGRESSIVE:       entry.peel.newph:
; AGGRESSIVE-NEXT:    br label [[HEADER:%.*]]
; AGGRESSIVE:       header:
; AGGRESSIVE-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT_PEEL]], [[ENTRY_PEEL_NEWPH]] ], [ [[IV_NEXT:%.*]], [[LATCH_EXITING:%.*]] ]
; AGGRESSIVE-NEXT:    br i1 true, label [[IF:%.*]], label [[LATCH_EXITING]]
; AGGRESSIVE:       if:
; AGGRESSIVE-NEXT:    [[IV_EXT:%.*]] = zext nneg i32 [[IV]] to i64
; AGGRESSIVE-NEXT:    [[ADDR:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT]]
; AGGRESSIVE-NEXT:    [[DATA:%.*]] = select i1 [[COND]], i32 0, i32 1
; AGGRESSIVE-NEXT:    store i32 [[DATA]], ptr [[ADDR]], align 4
; AGGRESSIVE-NEXT:    br label [[LATCH_EXITING]]
; AGGRESSIVE:       latch_exiting:
; AGGRESSIVE-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; AGGRESSIVE-NEXT:    [[LOOP_COND:%.*]] = icmp ult i32 [[IV_NEXT]], 64
; AGGRESSIVE-NEXT:    br i1 [[LOOP_COND]], label [[HEADER]], label [[END_LOOPEXIT:%.*]], !llvm.loop [[LOOP2:![0-9]+]]
; AGGRESSIVE:       end.loopexit:
; AGGRESSIVE-NEXT:    br label [[END]]
; AGGRESSIVE:       end:
; AGGRESSIVE-NEXT:    ret void
;
; CHECK-LABEL: @unknown_select_doesnt_prevent_peel(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[HEADER_PEEL_BEGIN:%.*]]
; CHECK:       header.peel.begin:
; CHECK-NEXT:    br label [[HEADER_PEEL:%.*]]
; CHECK:       header.peel:
; CHECK-NEXT:    [[NOT_FIRST_IT_PEEL:%.*]] = icmp ugt i32 0, 0
; CHECK-NEXT:    br i1 [[NOT_FIRST_IT_PEEL]], label [[IF_PEEL:%.*]], label [[LATCH_EXITING_PEEL:%.*]]
; CHECK:       if.peel:
; CHECK-NEXT:    [[IV_EXT_PEEL:%.*]] = zext nneg i32 0 to i64
; CHECK-NEXT:    [[ADDR_PEEL:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM:%.*]], i64 [[IV_EXT_PEEL]]
; CHECK-NEXT:    [[DATA_PEEL:%.*]] = select i1 [[COND:%.*]], i32 0, i32 1
; CHECK-NEXT:    store i32 [[DATA_PEEL]], ptr [[ADDR_PEEL]], align 4
; CHECK-NEXT:    br label [[LATCH_EXITING_PEEL]]
; CHECK:       latch_exiting.peel:
; CHECK-NEXT:    [[IV_NEXT_PEEL:%.*]] = add nuw nsw i32 0, 1
; CHECK-NEXT:    [[LOOP_COND_PEEL:%.*]] = icmp ult i32 [[IV_NEXT_PEEL]], 64
; CHECK-NEXT:    br i1 [[LOOP_COND_PEEL]], label [[HEADER_PEEL_NEXT:%.*]], label [[END:%.*]]
; CHECK:       header.peel.next:
; CHECK-NEXT:    br label [[HEADER_PEEL_NEXT1:%.*]]
; CHECK:       header.peel.next1:
; CHECK-NEXT:    br label [[ENTRY_PEEL_NEWPH:%.*]]
; CHECK:       entry.peel.newph:
; CHECK-NEXT:    br label [[HEADER:%.*]]
; CHECK:       header:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT_PEEL]], [[ENTRY_PEEL_NEWPH]] ], [ [[IV_NEXT:%.*]], [[LATCH_EXITING:%.*]] ]
; CHECK-NEXT:    br i1 true, label [[IF:%.*]], label [[LATCH_EXITING]]
; CHECK:       if:
; CHECK-NEXT:    [[IV_EXT:%.*]] = zext nneg i32 [[IV]] to i64
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT]]
; CHECK-NEXT:    [[DATA:%.*]] = select i1 [[COND]], i32 0, i32 1
; CHECK-NEXT:    store i32 [[DATA]], ptr [[ADDR]], align 4
; CHECK-NEXT:    br label [[LATCH_EXITING]]
; CHECK:       latch_exiting:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp ult i32 [[IV_NEXT]], 64
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[HEADER]], label [[END_LOOPEXIT:%.*]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       end.loopexit:
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  br label %header

header:                                                 ; preds = %header, %latch_exiting
  %iv = phi i32 [ 0, %entry ], [ %iv_next, %latch_exiting ]
  %not_first_it = icmp ugt i32 %iv, 0
  br i1 %not_first_it, label %if, label %latch_exiting

if:                                                     ; preds = %header
  %iv.ext = zext nneg i32 %iv to i64
  %addr = getelementptr inbounds [16 x [16 x i32]], ptr %mem, i64 %iv.ext
  %data = select i1 %cond, i32 0, i32 1
  store i32 %data, ptr %addr, align 4
  br label %latch_exiting

latch_exiting:                                          ; preds = %header, %if
  %iv_next = add nuw nsw i32 %iv, 1
  %loop.cond = icmp ult i32 %iv_next, 64
  br i1 %loop.cond, label %header, label %end

end:                                                    ; preds = %header
  ret void
}

; In aggressive mode, two iterations of the loop are peeled because if1's
; condition is IV < 2, even though if2's condition is not fully determined.
; In non-aggressive mode, the latter prevents any peeling.

define void @mix_known_unknown_prevents_peel(ptr noundef %mem, i1 noundef zeroext %cond) {
; AGGRESSIVE-LABEL: @mix_known_unknown_prevents_peel(
; AGGRESSIVE-NEXT:  entry:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL_BEGIN:%.*]]
; AGGRESSIVE:       header.peel.begin:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL:%.*]]
; AGGRESSIVE:       header.peel:
; AGGRESSIVE-NEXT:    [[IV_EXT_PEEL:%.*]] = zext nneg i32 0 to i64
; AGGRESSIVE-NEXT:    [[IF1_COND_PEEL:%.*]] = icmp ult i32 0, 2
; AGGRESSIVE-NEXT:    br i1 [[IF1_COND_PEEL]], label [[IF1_PEEL:%.*]], label [[PRED_IF2_PEEL:%.*]]
; AGGRESSIVE:       if1.peel:
; AGGRESSIVE-NEXT:    [[ADDR1_PEEL:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM:%.*]], i64 [[IV_EXT_PEEL]]
; AGGRESSIVE-NEXT:    store i32 0, ptr [[ADDR1_PEEL]], align 4
; AGGRESSIVE-NEXT:    br label [[PRED_IF2_PEEL]]
; AGGRESSIVE:       pred_if2.peel:
; AGGRESSIVE-NEXT:    [[NOT_FIRST_IT_PEEL:%.*]] = icmp ugt i32 0, 0
; AGGRESSIVE-NEXT:    [[IF2_COND_PEEL:%.*]] = and i1 [[COND:%.*]], [[NOT_FIRST_IT_PEEL]]
; AGGRESSIVE-NEXT:    br i1 [[IF2_COND_PEEL]], label [[IF2_PEEL:%.*]], label [[LATCH_EXITING_PEEL:%.*]]
; AGGRESSIVE:       if2.peel:
; AGGRESSIVE-NEXT:    [[ADDR2_PEEL:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT_PEEL]]
; AGGRESSIVE-NEXT:    store i32 42, ptr [[ADDR2_PEEL]], align 4
; AGGRESSIVE-NEXT:    br label [[LATCH_EXITING_PEEL]]
; AGGRESSIVE:       latch_exiting.peel:
; AGGRESSIVE-NEXT:    [[IV_NEXT_PEEL:%.*]] = add nuw nsw i32 0, 1
; AGGRESSIVE-NEXT:    [[LOOP_COND_PEEL:%.*]] = icmp ult i32 [[IV_NEXT_PEEL]], 64
; AGGRESSIVE-NEXT:    br i1 [[LOOP_COND_PEEL]], label [[HEADER_PEEL_NEXT:%.*]], label [[END:%.*]]
; AGGRESSIVE:       header.peel.next:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL2:%.*]]
; AGGRESSIVE:       header.peel2:
; AGGRESSIVE-NEXT:    [[IV_EXT_PEEL3:%.*]] = zext nneg i32 [[IV_NEXT_PEEL]] to i64
; AGGRESSIVE-NEXT:    [[IF1_COND_PEEL4:%.*]] = icmp ult i32 [[IV_NEXT_PEEL]], 2
; AGGRESSIVE-NEXT:    br i1 [[IF1_COND_PEEL4]], label [[IF1_PEEL5:%.*]], label [[PRED_IF2_PEEL7:%.*]]
; AGGRESSIVE:       if1.peel5:
; AGGRESSIVE-NEXT:    [[ADDR1_PEEL6:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT_PEEL3]]
; AGGRESSIVE-NEXT:    store i32 0, ptr [[ADDR1_PEEL6]], align 4
; AGGRESSIVE-NEXT:    br label [[PRED_IF2_PEEL7]]
; AGGRESSIVE:       pred_if2.peel7:
; AGGRESSIVE-NEXT:    [[NOT_FIRST_IT_PEEL8:%.*]] = icmp ugt i32 [[IV_NEXT_PEEL]], 0
; AGGRESSIVE-NEXT:    [[IF2_COND_PEEL9:%.*]] = and i1 [[COND]], [[NOT_FIRST_IT_PEEL8]]
; AGGRESSIVE-NEXT:    br i1 [[IF2_COND_PEEL9]], label [[IF2_PEEL10:%.*]], label [[LATCH_EXITING_PEEL12:%.*]]
; AGGRESSIVE:       if2.peel10:
; AGGRESSIVE-NEXT:    [[ADDR2_PEEL11:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT_PEEL3]]
; AGGRESSIVE-NEXT:    store i32 42, ptr [[ADDR2_PEEL11]], align 4
; AGGRESSIVE-NEXT:    br label [[LATCH_EXITING_PEEL12]]
; AGGRESSIVE:       latch_exiting.peel12:
; AGGRESSIVE-NEXT:    [[IV_NEXT_PEEL13:%.*]] = add nuw nsw i32 [[IV_NEXT_PEEL]], 1
; AGGRESSIVE-NEXT:    [[LOOP_COND_PEEL14:%.*]] = icmp ult i32 [[IV_NEXT_PEEL13]], 64
; AGGRESSIVE-NEXT:    br i1 [[LOOP_COND_PEEL14]], label [[HEADER_PEEL_NEXT1:%.*]], label [[END]]
; AGGRESSIVE:       header.peel.next1:
; AGGRESSIVE-NEXT:    br label [[HEADER_PEEL_NEXT15:%.*]]
; AGGRESSIVE:       header.peel.next15:
; AGGRESSIVE-NEXT:    br label [[ENTRY_PEEL_NEWPH:%.*]]
; AGGRESSIVE:       entry.peel.newph:
; AGGRESSIVE-NEXT:    br label [[HEADER:%.*]]
; AGGRESSIVE:       header:
; AGGRESSIVE-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT_PEEL13]], [[ENTRY_PEEL_NEWPH]] ], [ [[IV_NEXT:%.*]], [[LATCH_EXITING:%.*]] ]
; AGGRESSIVE-NEXT:    [[IV_EXT:%.*]] = zext nneg i32 [[IV]] to i64
; AGGRESSIVE-NEXT:    br i1 false, label [[IF1:%.*]], label [[PRED_IF2:%.*]]
; AGGRESSIVE:       if1:
; AGGRESSIVE-NEXT:    [[ADDR1:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT]]
; AGGRESSIVE-NEXT:    store i32 0, ptr [[ADDR1]], align 4
; AGGRESSIVE-NEXT:    br label [[PRED_IF2]]
; AGGRESSIVE:       pred_if2:
; AGGRESSIVE-NEXT:    br i1 [[COND]], label [[IF2:%.*]], label [[LATCH_EXITING]]
; AGGRESSIVE:       if2:
; AGGRESSIVE-NEXT:    [[ADDR2:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT]]
; AGGRESSIVE-NEXT:    store i32 42, ptr [[ADDR2]], align 4
; AGGRESSIVE-NEXT:    br label [[LATCH_EXITING]]
; AGGRESSIVE:       latch_exiting:
; AGGRESSIVE-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; AGGRESSIVE-NEXT:    [[LOOP_COND:%.*]] = icmp ult i32 [[IV_NEXT]], 64
; AGGRESSIVE-NEXT:    br i1 [[LOOP_COND]], label [[HEADER]], label [[END_LOOPEXIT:%.*]], !llvm.loop [[LOOP3:![0-9]+]]
; AGGRESSIVE:       end.loopexit:
; AGGRESSIVE-NEXT:    br label [[END]]
; AGGRESSIVE:       end:
; AGGRESSIVE-NEXT:    ret void
;
; CHECK-LABEL: @mix_known_unknown_prevents_peel(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[HEADER:%.*]]
; CHECK:       header:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[LATCH_EXITING:%.*]] ]
; CHECK-NEXT:    [[IV_EXT:%.*]] = zext nneg i32 [[IV]] to i64
; CHECK-NEXT:    [[IF1_COND:%.*]] = icmp ult i32 [[IV]], 2
; CHECK-NEXT:    br i1 [[IF1_COND]], label [[IF1:%.*]], label [[PRED_IF2:%.*]]
; CHECK:       if1:
; CHECK-NEXT:    [[ADDR1:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM:%.*]], i64 [[IV_EXT]]
; CHECK-NEXT:    store i32 0, ptr [[ADDR1]], align 4
; CHECK-NEXT:    br label [[PRED_IF2]]
; CHECK:       pred_if2:
; CHECK-NEXT:    [[NOT_FIRST_IT:%.*]] = icmp ugt i32 [[IV]], 0
; CHECK-NEXT:    [[IF2_COND:%.*]] = and i1 [[COND:%.*]], [[NOT_FIRST_IT]]
; CHECK-NEXT:    br i1 [[IF2_COND]], label [[IF2:%.*]], label [[LATCH_EXITING]]
; CHECK:       if2:
; CHECK-NEXT:    [[ADDR2:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[MEM]], i64 [[IV_EXT]]
; CHECK-NEXT:    store i32 42, ptr [[ADDR2]], align 4
; CHECK-NEXT:    br label [[LATCH_EXITING]]
; CHECK:       latch_exiting:
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp ult i32 [[IV_NEXT]], 64
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[HEADER]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  br label %header

header:                                                 ; preds = %header, %latch_exiting
  %iv = phi i32 [ 0, %entry ], [ %iv_next, %latch_exiting ]
  %iv.ext = zext nneg i32 %iv to i64
  %if1.cond = icmp ult i32 %iv, 2
  br i1 %if1.cond, label %if1, label %pred_if2

if1:                                                    ; preds = %header
  %addr1 = getelementptr inbounds [16 x [16 x i32]], ptr %mem, i64 %iv.ext
  store i32 0, ptr %addr1, align 4
  br label %pred_if2

pred_if2:                                               ; preds = %if1
  %not_first_it = icmp ugt i32 %iv, 0
  %if2.cond = and i1 %cond, %not_first_it
  br i1 %if2.cond, label %if2, label %latch_exiting

if2:                                                    ; preds = %pred_if2
  %addr2 = getelementptr inbounds [16 x [16 x i32]], ptr %mem, i64 %iv.ext
  store i32 42, ptr %addr2, align 4
  br label %latch_exiting

latch_exiting:                                          ; preds = %pred_if2, %pred_if2
  %iv_next = add nuw nsw i32 %iv, 1
  %loop.cond = icmp ult i32 %iv_next, 64
  br i1 %loop.cond, label %header, label %end

end:                                                    ; preds = %header
  ret void
}
