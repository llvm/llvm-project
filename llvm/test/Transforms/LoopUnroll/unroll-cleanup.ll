; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; PR23524
; The test is to check redundency produced by loop unroll pass
; should be cleaned up by later pass.
; RUN: opt < %s -O2 -S | FileCheck %s

; After loop unroll:
;       %dec18 = add nsw i32 %dec18.in, -1
;       ...
;       %dec18.1 = add nsw i32 %dec18, -1
; should be merged to:
;       %dec18.1 = add nsw i32 %dec18.in, -2
;

; ModuleID = '<stdin>'
target triple = "x86_64-unknown-linux-gnu"

@b = global i32 0, align 4
@c = global i32 0, align 4

; Function Attrs: nounwind uwtable
define void @_Z3fn1v(ptr %r, ptr %a) #0 {
; CHECK-LABEL: define void @_Z3fn1v(
; CHECK-SAME: ptr nocapture writeonly [[R:%.*]], ptr nocapture readonly [[A:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP:%.*]] = load i32, ptr @b, align 4
; CHECK-NEXT:    [[TOBOOL20:%.*]] = icmp eq i32 [[TMP]], 0
; CHECK-NEXT:    br i1 [[TOBOOL20]], label %[[FOR_END6:.*]], label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_COND_LOOPEXIT_LOOPEXIT:.*]]:
; CHECK-NEXT:    [[ADD_PTR_LCSSA:%.*]] = phi ptr [ [[ADD_PTR_LCSSA_UNR:%.*]], %[[FOR_BODY3_PROL_LOOPEXIT:.*]] ], [ [[ADD_PTR_1:%.*]], %[[FOR_INC_1:.*]] ]
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[A_021:%.*]], i64 1
; CHECK-NEXT:    [[SCEVGEP1:%.*]] = getelementptr i8, ptr [[SCEVGEP]], i64 [[TMP1:%.*]]
; CHECK-NEXT:    [[TMP1_PRE:%.*]] = load i32, ptr @b, align 4
; CHECK-NEXT:    br label %[[FOR_COND_LOOPEXIT:.*]]
; CHECK:       [[FOR_COND_LOOPEXIT]]:
; CHECK-NEXT:    [[T1:%.*]] = phi i32 [ [[T12:%.*]], %[[FOR_BODY]] ], [ [[TMP1_PRE]], %[[FOR_COND_LOOPEXIT_LOOPEXIT]] ]
; CHECK-NEXT:    [[R_1_LCSSA:%.*]] = phi ptr [ [[R_022:%.*]], %[[FOR_BODY]] ], [ [[ADD_PTR_LCSSA]], %[[FOR_COND_LOOPEXIT_LOOPEXIT]] ]
; CHECK-NEXT:    [[A_1_LCSSA:%.*]] = phi ptr [ [[A_021]], %[[FOR_BODY]] ], [ [[SCEVGEP1]], %[[FOR_COND_LOOPEXIT_LOOPEXIT]] ]
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[T1]], 0
; CHECK-NEXT:    br i1 [[TOBOOL]], label %[[FOR_END6]], label %[[FOR_BODY]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[T12]] = phi i32 [ [[T1]], %[[FOR_COND_LOOPEXIT]] ], [ [[TMP]], %[[ENTRY]] ]
; CHECK-NEXT:    [[R_022]] = phi ptr [ [[R_1_LCSSA]], %[[FOR_COND_LOOPEXIT]] ], [ [[R]], %[[ENTRY]] ]
; CHECK-NEXT:    [[A_021]] = phi ptr [ [[A_1_LCSSA]], %[[FOR_COND_LOOPEXIT]] ], [ [[A]], %[[ENTRY]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr @c, align 4
; CHECK-NEXT:    [[TOBOOL215:%.*]] = icmp eq i32 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[TOBOOL215]], label %[[FOR_COND_LOOPEXIT]], label %[[FOR_BODY3_PREHEADER:.*]]
; CHECK:       [[FOR_BODY3_PREHEADER]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[TMP2]], -1
; CHECK-NEXT:    [[TMP1]] = zext i32 [[TMP0]] to i64
; CHECK-NEXT:    [[XTRAITER:%.*]] = and i32 [[TMP2]], 1
; CHECK-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i32 [[XTRAITER]], 0
; CHECK-NEXT:    br i1 [[LCMP_MOD_NOT]], label %[[FOR_BODY3_PROL_LOOPEXIT]], label %[[FOR_BODY3_PROL:.*]]
; CHECK:       [[FOR_BODY3_PROL]]:
; CHECK-NEXT:    [[DEC18_PROL:%.*]] = add nsw i32 [[TMP2]], -1
; CHECK-NEXT:    [[TMP3_PROL:%.*]] = load i8, ptr [[A_021]], align 1
; CHECK-NEXT:    [[CMP_PROL:%.*]] = icmp eq i8 [[TMP3_PROL]], 0
; CHECK-NEXT:    br i1 [[CMP_PROL]], label %[[IF_THEN_PROL:.*]], label %[[FOR_INC_PROL:.*]]
; CHECK:       [[IF_THEN_PROL]]:
; CHECK-NEXT:    [[ARRAYIDX_PROL:%.*]] = getelementptr inbounds nuw i8, ptr [[R_022]], i64 2
; CHECK-NEXT:    store i16 0, ptr [[ARRAYIDX_PROL]], align 2
; CHECK-NEXT:    store i16 0, ptr [[R_022]], align 2
; CHECK-NEXT:    [[ARRAYIDX5_PROL:%.*]] = getelementptr inbounds nuw i8, ptr [[R_022]], i64 4
; CHECK-NEXT:    store i16 0, ptr [[ARRAYIDX5_PROL]], align 2
; CHECK-NEXT:    br label %[[FOR_INC_PROL]]
; CHECK:       [[FOR_INC_PROL]]:
; CHECK-NEXT:    [[INCDEC_PTR_PROL:%.*]] = getelementptr inbounds nuw i8, ptr [[A_021]], i64 1
; CHECK-NEXT:    [[ADD_PTR_PROL:%.*]] = getelementptr inbounds nuw i8, ptr [[R_022]], i64 6
; CHECK-NEXT:    br label %[[FOR_BODY3_PROL_LOOPEXIT]]
; CHECK:       [[FOR_BODY3_PROL_LOOPEXIT]]:
; CHECK-NEXT:    [[ADD_PTR_LCSSA_UNR]] = phi ptr [ poison, %[[FOR_BODY3_PREHEADER]] ], [ [[ADD_PTR_PROL]], %[[FOR_INC_PROL]] ]
; CHECK-NEXT:    [[DEC18_IN_UNR:%.*]] = phi i32 [ [[TMP2]], %[[FOR_BODY3_PREHEADER]] ], [ [[DEC18_PROL]], %[[FOR_INC_PROL]] ]
; CHECK-NEXT:    [[R_117_UNR:%.*]] = phi ptr [ [[R_022]], %[[FOR_BODY3_PREHEADER]] ], [ [[ADD_PTR_PROL]], %[[FOR_INC_PROL]] ]
; CHECK-NEXT:    [[A_116_UNR:%.*]] = phi ptr [ [[A_021]], %[[FOR_BODY3_PREHEADER]] ], [ [[INCDEC_PTR_PROL]], %[[FOR_INC_PROL]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP4]], label %[[FOR_COND_LOOPEXIT_LOOPEXIT]], label %[[FOR_BODY3:.*]]
; CHECK:       [[FOR_BODY3]]:
; CHECK-NEXT:    [[DEC18_IN:%.*]] = phi i32 [ [[DEC18_1:%.*]], %[[FOR_INC_1]] ], [ [[DEC18_IN_UNR]], %[[FOR_BODY3_PROL_LOOPEXIT]] ]
; CHECK-NEXT:    [[R_117:%.*]] = phi ptr [ [[ADD_PTR_1]], %[[FOR_INC_1]] ], [ [[R_117_UNR]], %[[FOR_BODY3_PROL_LOOPEXIT]] ]
; CHECK-NEXT:    [[A_116:%.*]] = phi ptr [ [[INCDEC_PTR_1:%.*]], %[[FOR_INC_1]] ], [ [[A_116_UNR]], %[[FOR_BODY3_PROL_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr [[A_116]], align 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 [[TMP3]], 0
; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[FOR_INC:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i8, ptr [[R_117]], i64 2
; CHECK-NEXT:    store i16 0, ptr [[ARRAYIDX]], align 2
; CHECK-NEXT:    store i16 0, ptr [[R_117]], align 2
; CHECK-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds nuw i8, ptr [[R_117]], i64 4
; CHECK-NEXT:    store i16 0, ptr [[ARRAYIDX5]], align 2
; CHECK-NEXT:    br label %[[FOR_INC]]
; CHECK:       [[FOR_INC]]:
; CHECK-NEXT:    [[INCDEC_PTR:%.*]] = getelementptr inbounds nuw i8, ptr [[A_116]], i64 1
; CHECK-NEXT:    [[DEC18_1]] = add nsw i32 [[DEC18_IN]], -2
; CHECK-NEXT:    [[TMP3_1:%.*]] = load i8, ptr [[INCDEC_PTR]], align 1
; CHECK-NEXT:    [[CMP_1:%.*]] = icmp eq i8 [[TMP3_1]], 0
; CHECK-NEXT:    br i1 [[CMP_1]], label %[[IF_THEN_1:.*]], label %[[FOR_INC_1]]
; CHECK:       [[IF_THEN_1]]:
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw i8, ptr [[R_117]], i64 6
; CHECK-NEXT:    [[ARRAYIDX_1:%.*]] = getelementptr inbounds nuw i8, ptr [[R_117]], i64 8
; CHECK-NEXT:    store i16 0, ptr [[ARRAYIDX_1]], align 2
; CHECK-NEXT:    store i16 0, ptr [[ADD_PTR]], align 2
; CHECK-NEXT:    [[ARRAYIDX5_1:%.*]] = getelementptr inbounds nuw i8, ptr [[R_117]], i64 10
; CHECK-NEXT:    store i16 0, ptr [[ARRAYIDX5_1]], align 2
; CHECK-NEXT:    br label %[[FOR_INC_1]]
; CHECK:       [[FOR_INC_1]]:
; CHECK-NEXT:    [[INCDEC_PTR_1]] = getelementptr inbounds nuw i8, ptr [[A_116]], i64 2
; CHECK-NEXT:    [[ADD_PTR_1]] = getelementptr inbounds nuw i8, ptr [[R_117]], i64 12
; CHECK-NEXT:    [[TOBOOL2_1:%.*]] = icmp eq i32 [[DEC18_1]], 0
; CHECK-NEXT:    br i1 [[TOBOOL2_1]], label %[[FOR_COND_LOOPEXIT_LOOPEXIT]], label %[[FOR_BODY3]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[FOR_END6]]:
; CHECK-NEXT:    ret void
;
entry:
  %t = load i32, ptr @b, align 4
  %tobool20 = icmp eq i32 %t, 0
  br i1 %tobool20, label %for.end6, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  br label %for.body

for.cond1.for.cond.loopexit_crit_edge:            ; preds = %for.inc
  %add.ptr.lcssa = phi ptr [ %add.ptr, %for.inc ]
  %incdec.ptr.lcssa = phi ptr [ %incdec.ptr, %for.inc ]
  br label %for.cond.loopexit

for.cond.loopexit:                                ; preds = %for.body, %for.cond1.for.cond.loopexit_crit_edge
  %r.1.lcssa = phi ptr [ %add.ptr.lcssa, %for.cond1.for.cond.loopexit_crit_edge ], [ %r.022, %for.body ]
  %a.1.lcssa = phi ptr [ %incdec.ptr.lcssa, %for.cond1.for.cond.loopexit_crit_edge ], [ %a.021, %for.body ]
  %t1 = load i32, ptr @b, align 4
  %tobool = icmp eq i32 %t1, 0
  br i1 %tobool, label %for.cond.for.end6_crit_edge, label %for.body

for.body:                                         ; preds = %for.cond.loopexit, %for.body.lr.ph
  %r.022 = phi ptr [ %r, %for.body.lr.ph ], [ %r.1.lcssa, %for.cond.loopexit ]
  %a.021 = phi ptr [ %a, %for.body.lr.ph ], [ %a.1.lcssa, %for.cond.loopexit ]
  %t2 = load i32, ptr @c, align 4
  %tobool215 = icmp eq i32 %t2, 0
  br i1 %tobool215, label %for.cond.loopexit, label %for.body3.lr.ph

for.body3.lr.ph:                                  ; preds = %for.body
  br label %for.body3

for.body3:                                        ; preds = %for.inc, %for.body3.lr.ph
  %dec18.in = phi i32 [ %t2, %for.body3.lr.ph ], [ %dec18, %for.inc ]
  %r.117 = phi ptr [ %r.022, %for.body3.lr.ph ], [ %add.ptr, %for.inc ]
  %a.116 = phi ptr [ %a.021, %for.body3.lr.ph ], [ %incdec.ptr, %for.inc ]
  %dec18 = add nsw i32 %dec18.in, -1
  %t3 = load i8, ptr %a.116, align 1
  %cmp = icmp eq i8 %t3, 0
  br i1 %cmp, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body3
  %arrayidx = getelementptr inbounds i16, ptr %r.117, i64 1
  store i16 0, ptr %arrayidx, align 2
  store i16 0, ptr %r.117, align 2
  %arrayidx5 = getelementptr inbounds i16, ptr %r.117, i64 2
  store i16 0, ptr %arrayidx5, align 2
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body3
  %incdec.ptr = getelementptr inbounds i8, ptr %a.116, i64 1
  %add.ptr = getelementptr inbounds i16, ptr %r.117, i64 3
  %tobool2 = icmp eq i32 %dec18, 0
  br i1 %tobool2, label %for.cond1.for.cond.loopexit_crit_edge, label %for.body3, !llvm.loop !0

for.cond.for.end6_crit_edge:                      ; preds = %for.cond.loopexit
  br label %for.end6

for.end6:                                         ; preds = %for.cond.for.end6_crit_edge, %entry
  ret void
}

!0 = !{!0, !1}
!1 = !{!"llvm.loop.unroll.count", i32 2}
;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.unroll.disable"}
;.
