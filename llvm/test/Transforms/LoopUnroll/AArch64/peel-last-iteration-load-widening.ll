; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=aarch64 -passes=loop-unroll -S %s | FileCheck %s

; Test that loop peeling is applied for consecutive load widening opportunities
; and that the loads are widened to natural sizes.

define void @test_3_consecutive_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_3_consecutive_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP10:%.*]] = lshr i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP10]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i32 [[TMP2]], 16
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i32 [[TMP6]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP9]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  ; Use the loaded values to prevent DCE
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_5_consecutive_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_5_consecutive_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[P]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = trunc i64 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP14:%.*]] = lshr i64 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i64 [[TMP14]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i64 [[TMP2]], 16
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i64 [[TMP6]] to i8
; CHECK-NEXT:    [[TMP8:%.*]] = lshr i64 [[TMP2]], 24
; CHECK-NEXT:    [[TMP9:%.*]] = trunc i64 [[TMP8]] to i8
; CHECK-NEXT:    [[TMP10:%.*]] = lshr i64 [[TMP2]], 32
; CHECK-NEXT:    [[TMP11:%.*]] = trunc i64 [[TMP10]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP13]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[SUM3:%.*]] = add i8 [[SUM2]], [[TMP9]]
; CHECK-NEXT:    [[SUM4:%.*]] = add i8 [[SUM3]], [[TMP11]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM4]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 5
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP12:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP12]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[P3_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[P4_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 4
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[D_PEEL:%.*]] = load i8, ptr [[P3_PEEL]], align 1
; CHECK-NEXT:    [[E_PEEL:%.*]] = load i8, ptr [[P4_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[SUM3_PEEL:%.*]] = add i8 [[SUM2_PEEL]], [[D_PEEL]]
; CHECK-NEXT:    [[SUM4_PEEL:%.*]] = add i8 [[SUM3_PEEL]], [[E_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM4_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 5
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2
  %p3 = getelementptr inbounds i8, ptr %p, i64 3
  %p4 = getelementptr inbounds i8, ptr %p, i64 4

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1
  %d = load i8, ptr %p3, align 1
  %e = load i8, ptr %p4, align 1

  ; Use the loaded values
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %sum3 = add i8 %sum2, %d
  %sum4 = add i8 %sum3, %e
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum4, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 5
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_8_consecutive_loads_no_peel(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_8_consecutive_loads_no_peel(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[P3:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[P4:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[P5:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 5
; CHECK-NEXT:    [[P6:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 6
; CHECK-NEXT:    [[P7:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 7
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[D:%.*]] = load i8, ptr [[P3]], align 1
; CHECK-NEXT:    [[E:%.*]] = load i8, ptr [[P4]], align 1
; CHECK-NEXT:    [[F:%.*]] = load i8, ptr [[P5]], align 1
; CHECK-NEXT:    [[G:%.*]] = load i8, ptr [[P6]], align 1
; CHECK-NEXT:    [[H:%.*]] = load i8, ptr [[P7]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[SUM3:%.*]] = add i8 [[SUM2]], [[D]]
; CHECK-NEXT:    [[SUM4:%.*]] = add i8 [[SUM3]], [[E]]
; CHECK-NEXT:    [[SUM5:%.*]] = add i8 [[SUM4]], [[F]]
; CHECK-NEXT:    [[SUM6:%.*]] = add i8 [[SUM5]], [[G]]
; CHECK-NEXT:    [[SUM7:%.*]] = add i8 [[SUM6]], [[H]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM7]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2
  %p3 = getelementptr inbounds i8, ptr %p, i64 3
  %p4 = getelementptr inbounds i8, ptr %p, i64 4
  %p5 = getelementptr inbounds i8, ptr %p, i64 5
  %p6 = getelementptr inbounds i8, ptr %p, i64 6
  %p7 = getelementptr inbounds i8, ptr %p, i64 7

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1
  %d = load i8, ptr %p3, align 1
  %e = load i8, ptr %p4, align 1
  %f = load i8, ptr %p5, align 1
  %g = load i8, ptr %p6, align 1
  %h = load i8, ptr %p7, align 1

  ; Use all values
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %sum3 = add i8 %sum2, %d
  %sum4 = add i8 %sum3, %e
  %sum5 = add i8 %sum4, %f
  %sum6 = add i8 %sum5, %g
  %sum7 = add i8 %sum6, %h
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum7, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 8
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_non_consecutive_loads_no_peel(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_non_consecutive_loads_no_peel(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 2  ; Skip offset 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 3

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 4
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_9_consecutive_loads_no_peel(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_9_consecutive_loads_no_peel(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT_PEEL:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT_PEEL:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[P3_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[P4_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 4
; CHECK-NEXT:    [[P5_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 5
; CHECK-NEXT:    [[P6_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 6
; CHECK-NEXT:    [[P7_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 7
; CHECK-NEXT:    [[P8_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 8
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 16
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[D_PEEL:%.*]] = load i8, ptr [[P3_PEEL]], align 1
; CHECK-NEXT:    [[E_PEEL:%.*]] = load i8, ptr [[P4_PEEL]], align 1
; CHECK-NEXT:    [[F_PEEL:%.*]] = load i8, ptr [[P5_PEEL]], align 1
; CHECK-NEXT:    [[G_PEEL:%.*]] = load i8, ptr [[P6_PEEL]], align 1
; CHECK-NEXT:    [[H_PEEL:%.*]] = load i8, ptr [[P7_PEEL]], align 1
; CHECK-NEXT:    [[I_VAL_PEEL:%.*]] = load i8, ptr [[P8_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[SUM3_PEEL:%.*]] = add i8 [[SUM2_PEEL]], [[D_PEEL]]
; CHECK-NEXT:    [[SUM4_PEEL:%.*]] = add i8 [[SUM3_PEEL]], [[E_PEEL]]
; CHECK-NEXT:    [[SUM5_PEEL:%.*]] = add i8 [[SUM4_PEEL]], [[F_PEEL]]
; CHECK-NEXT:    [[SUM6_PEEL:%.*]] = add i8 [[SUM5_PEEL]], [[G_PEEL]]
; CHECK-NEXT:    [[SUM7_PEEL:%.*]] = add i8 [[SUM6_PEEL]], [[H_PEEL]]
; CHECK-NEXT:    [[SUM9_PEEL:%.*]] = add i8 [[SUM7_PEEL]], [[I_VAL_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM9_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL]] = getelementptr inbounds i8, ptr [[TMP4]], i64 9
; CHECK-NEXT:    [[I_NEXT_PEEL]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2
  %p3 = getelementptr inbounds i8, ptr %p, i64 3
  %p4 = getelementptr inbounds i8, ptr %p, i64 4
  %p5 = getelementptr inbounds i8, ptr %p, i64 5
  %p6 = getelementptr inbounds i8, ptr %p, i64 6
  %p7 = getelementptr inbounds i8, ptr %p, i64 7
  %p8 = getelementptr inbounds i8, ptr %p, i64 8

  %a = load i8, ptr %p, align 16
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1
  %d = load i8, ptr %p3, align 1
  %e = load i8, ptr %p4, align 1
  %f = load i8, ptr %p5, align 1
  %g = load i8, ptr %p6, align 1
  %h = load i8, ptr %p7, align 1
  %i.val = load i8, ptr %p8, align 1

  ; Use all values
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %sum3 = add i8 %sum2, %d
  %sum4 = add i8 %sum3, %e
  %sum5 = add i8 %sum4, %f
  %sum6 = add i8 %sum5, %g
  %sum7 = add i8 %sum6, %h
  %sum8 = add i8 %sum7, %i.val
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum8, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 9
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_intervening_store(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_intervening_store(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT_PEEL:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    store i8 42, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  store i8 42, ptr %p1, align 1  ; Intervening store prevents optimization
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_3_consecutive_i16_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_3_consecutive_i16_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[P]], align 8
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i64 [[TMP2]] to i16
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i64 [[TMP2]], 16
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i64 [[TMP4]] to i16
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i64 [[TMP2]], 32
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i64 [[TMP6]] to i16
; CHECK-NEXT:    [[SUM1:%.*]] = add i16 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i16 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i16, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i16 [[SUM2]], ptr [[DST_I]], align 2
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 6
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i16, ptr [[TMP10]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i16, ptr [[TMP10]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i16, ptr [[TMP10]], align 2
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i16, ptr [[P1_PEEL]], align 2
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i16, ptr [[P2_PEEL]], align 2
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i16 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i16 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i16, ptr [[DST]], i32 [[TMP9]]
; CHECK-NEXT:    store i16 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 2
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 6
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP9]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i16, ptr %p, i64 1
  %p2 = getelementptr inbounds i16, ptr %p, i64 2

  %a = load i16, ptr %p, align 2
  %b = load i16, ptr %p1, align 2
  %c = load i16, ptr %p2, align 2

  %sum1 = add i16 %a, %b
  %sum2 = add i16 %sum1, %c
  %dst.i = getelementptr inbounds i16, ptr %dst, i32 %i
  store i16 %sum2, ptr %dst.i, align 2

  %p.next = getelementptr inbounds i8, ptr %p, i64 6
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

; Two consecutive i8 loads (2 bytes) are widened to i32 on AArch64 because
; the smallest legal integer type is i32 (i16 isn't in the legal int widths).
; This test verifies that 2-byte spans are still profitable to widen.
define void @test_2_consecutive_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_2_consecutive_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I1:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT1:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P2:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT1:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P2]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i8
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[DST_I1:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I1]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I1]], align 1
; CHECK-NEXT:    [[P_NEXT1]] = getelementptr inbounds i8, ptr [[P2]], i64 2
; CHECK-NEXT:    [[I_NEXT1]] = add nuw i32 [[I1]], 1
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND1:%.*]] = icmp ne i32 [[I_NEXT1]], [[TMP6]]
; CHECK-NEXT:    br i1 [[COND1]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP4:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT1]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT1]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 2
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM1]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[I_NEXT:%.*]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1

  %a = load i8, ptr %p, align 2
  %b = load i8, ptr %p1, align 1

  %sum1 = add i8 %a, %b
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum1, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 2
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_aa_metadata_preserved(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_aa_metadata_preserved(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 4, !tbaa [[TBAA5:![0-9]+]]
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i32 [[TMP2]], 16
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i32 [[TMP6]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP8:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP10]], align 1, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP9]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 3
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP9]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1, !tbaa !0
  %b = load i8, ptr %p1, align 1, !tbaa !0
  %c = load i8, ptr %p2, align 1, !tbaa !0

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_aa_metadata_different(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_aa_metadata_different(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i32 [[TMP2]], 16
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i32 [[TMP6]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP9:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP10]], align 1, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1, !tbaa [[TBAA10:![0-9]+]]
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP9]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 3
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP9]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1, !tbaa !0
  %b = load i8, ptr %p1, align 1, !tbaa !3
  %c = load i8, ptr %p2, align 1, !tbaa !0

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_negative_offsets(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_negative_offsets(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[SRC_OFFSET:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 2
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC_OFFSET]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[P]], i64 -2
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[TMP2]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = trunc i32 [[TMP3]] to i8
; CHECK-NEXT:    [[TMP5:%.*]] = lshr i32 [[TMP3]], 8
; CHECK-NEXT:    [[TMP6:%.*]] = trunc i32 [[TMP5]] to i8
; CHECK-NEXT:    [[TMP7:%.*]] = lshr i32 [[TMP3]], 16
; CHECK-NEXT:    [[TMP8:%.*]] = trunc i32 [[TMP7]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP4]], [[TMP6]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP8]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP9:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP9]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP12:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP10:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP11:%.*]] = phi ptr [ [[SRC_OFFSET]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P_NEG2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP11]], i64 -2
; CHECK-NEXT:    [[P_NEG1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP11]], i64 -1
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[P_NEG2_PEEL]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P_NEG1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[TMP11]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP10]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP11]], i64 3
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP10]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  ; Start at offset 2 so negative offsets are valid
  %src.offset = getelementptr inbounds i8, ptr %src, i64 2
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src.offset, %entry ], [ %p.next, %loop ]

  ; Negative offsets from current pointer
  %p_neg2 = getelementptr inbounds i8, ptr %p, i64 -2
  %p_neg1 = getelementptr inbounds i8, ptr %p, i64 -1

  %a = load i8, ptr %p_neg2, align 1
  %b = load i8, ptr %p_neg1, align 1
  %c = load i8, ptr %p, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_unordered_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_unordered_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP4]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i32 [[TMP2]], 16
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i32 [[TMP6]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP13:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 2
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP9]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 3
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP9]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  ; Loads in non-sequential order: offset 2, then 0, then 1
  %c = load i8, ptr %p2, align 1
  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_multiple_exits(ptr %src, ptr %dst, i32 %n, i1 %cond_early) {
; CHECK-LABEL: define void @test_multiple_exits(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]], i1 [[COND_EARLY:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP_LATCH:.*]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP_LATCH]] ]
; CHECK-NEXT:    br i1 [[COND_EARLY]], label %[[EARLY_EXIT:.*]], label %[[LOOP_BODY:.*]]
; CHECK:       [[LOOP_BODY]]:
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    br label %[[LOOP_LATCH]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EARLY_EXIT]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop.latch ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop.latch ]

  ; Early exit condition
  br i1 %cond_early, label %early_exit, label %loop.body

loop.body:
  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1
  br label %loop.latch

loop.latch:
  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

early_exit:
  ret void

exit:
  ret void
}

define void @test_side_effects_between_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_side_effects_between_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    store i8 42, ptr [[P1]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  ; Store between loads - prevents grouping
  store i8 42, ptr %p1, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_non_consecutive_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_non_consecutive_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[P]], align 8
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i64 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i64 [[TMP2]], 16
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i64 [[TMP4]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i64 [[TMP2]], 32
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i64 [[TMP6]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 5
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP14:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 2
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 4
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP10]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP9]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 5
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP9]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  ; Non-consecutive: 0, 2, 4 (gaps at 1, 3)
  %p1 = getelementptr inbounds i8, ptr %p, i64 2
  %p2 = getelementptr inbounds i8, ptr %p, i64 4

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  ; Step doesn't match the span
  %p.next = getelementptr inbounds i8, ptr %p, i64 5
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_float_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_float_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds float, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds float, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load float, ptr [[P]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, ptr [[P1]], align 4
; CHECK-NEXT:    [[C:%.*]] = load float, ptr [[P2]], align 4
; CHECK-NEXT:    [[SUM1:%.*]] = fadd float [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = fadd float [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds float, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store float [[SUM2]], ptr [[DST_I]], align 4
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds float, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds float, ptr %p, i64 1
  %p2 = getelementptr inbounds float, ptr %p, i64 2

  %a = load float, ptr %p, align 4
  %b = load float, ptr %p1, align 4
  %c = load float, ptr %p2, align 4

  %sum1 = fadd float %a, %b
  %sum2 = fadd float %sum1, %c
  %dst.i = getelementptr inbounds float, ptr %dst, i32 %i
  store float %sum2, ptr %dst.i, align 4

  %p.next = getelementptr inbounds float, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_i24_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_i24_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 6
; CHECK-NEXT:    [[A:%.*]] = load i24, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i24, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i24, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i24 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i24 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i24, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i24 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 9
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 3
  %p2 = getelementptr inbounds i8, ptr %p, i64 6

  %a = load i24, ptr %p, align 1
  %b = load i24, ptr %p1, align 1
  %c = load i24, ptr %p2, align 1

  %sum1 = add i24 %a, %b
  %sum2 = add i24 %sum1, %c
  %dst.i = getelementptr inbounds i24, ptr %dst, i32 %i
  store i24 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 9
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_non_inbounds_geps(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_non_inbounds_geps(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  ; Non-inbounds GEPs
  %p1 = getelementptr i8, ptr %p, i64 1
  %p2 = getelementptr i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  ; Non-inbounds for pointer advancement
  %p.next = getelementptr i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_base_plus_iv_pattern(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_base_plus_iv_pattern(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[I_EXT:%.*]] = zext i32 [[I]] to i64
; CHECK-NEXT:    [[STRIDE:%.*]] = mul i64 [[I_EXT]], 3
; CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 [[STRIDE]]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 [[STRIDE]]
; CHECK-NEXT:    [[P1_OFF:%.*]] = getelementptr inbounds i8, ptr [[P1]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[SRC]], i64 [[STRIDE]]
; CHECK-NEXT:    [[P2_OFF:%.*]] = getelementptr inbounds i8, ptr [[P2]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1_OFF]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2_OFF]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]

  ; Compute pointer as base + i * 3 + offset
  %i.ext = zext i32 %i to i64
  %stride = mul i64 %i.ext, 3
  %p = getelementptr inbounds i8, ptr %src, i64 %stride
  %p1 = getelementptr inbounds i8, ptr %src, i64 %stride
  %p1.off = getelementptr inbounds i8, ptr %p1, i64 1
  %p2 = getelementptr inbounds i8, ptr %src, i64 %stride
  %p2.off = getelementptr inbounds i8, ptr %p2, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1.off, align 1
  %c = load i8, ptr %p2.off, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_mixed_size_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_mixed_size_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i16, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[A_EXT:%.*]] = zext i8 [[A]] to i16
; CHECK-NEXT:    [[SUM1:%.*]] = add i16 [[A_EXT]], [[B]]
; CHECK-NEXT:    [[C_EXT:%.*]] = zext i8 [[C]] to i16
; CHECK-NEXT:    [[SUM2:%.*]] = add i16 [[SUM1]], [[C_EXT]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i16, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i16 [[SUM2]], ptr [[DST_I]], align 2
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  ; Mixed sizes: i8, i16, i8
  %a = load i8, ptr %p, align 1
  %b = load i16, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %a.ext = zext i8 %a to i16
  %sum1 = add i16 %a.ext, %b
  %c.ext = zext i8 %c to i16
  %sum2 = add i16 %sum1, %c.ext
  %dst.i = getelementptr inbounds i16, ptr %dst, i32 %i
  store i16 %sum2, ptr %dst.i, align 2

  %p.next = getelementptr inbounds i8, ptr %p, i64 4
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_volatile_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_volatile_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load volatile i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load volatile i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load volatile i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load volatile i8, ptr %p, align 1
  %b = load volatile i8, ptr %p1, align 1
  %c = load volatile i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_atomic_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_atomic_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load atomic i8, ptr [[P]] monotonic, align 1
; CHECK-NEXT:    [[B:%.*]] = load atomic i8, ptr [[P1]] monotonic, align 1
; CHECK-NEXT:    [[C:%.*]] = load atomic i8, ptr [[P2]] monotonic, align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load atomic i8, ptr %p monotonic, align 1
  %b = load atomic i8, ptr %p1 monotonic, align 1
  %c = load atomic i8, ptr %p2 monotonic, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_different_address_spaces(ptr %src, ptr addrspace(1) %src2, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_different_address_spaces(
; CHECK-SAME: ptr [[SRC:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P2:%.*]] = phi ptr addrspace(1) [ [[SRC2]], %[[ENTRY]] ], [ [[P2_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2_OFF:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[P2]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr addrspace(1) [[P2_OFF]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[P2_NEXT]] = getelementptr inbounds i8, ptr addrspace(1) [[P2]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]
  %p2 = phi ptr addrspace(1) [ %src2, %entry ], [ %p2.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2.off = getelementptr inbounds i8, ptr addrspace(1) %p2, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr addrspace(1) %p2.off, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %p2.next = getelementptr inbounds i8, ptr addrspace(1) %p2, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_step_mismatch(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_step_mismatch(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  ; Step is 4 but span is only 3 - mismatch prevents widening
  %p.next = getelementptr inbounds i8, ptr %p, i64 4
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

!0 = !{!1, !1, i64 0}
!1 = !{!"char", !2, i64 0}
!2 = !{!"root"}
!3 = !{!4, !4, i64 0}
!4 = !{!"int", !2, i64 0}

;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.peeled.count", i32 1}
; CHECK: [[LOOP2]] = distinct !{[[LOOP2]], [[META1]]}
; CHECK: [[LOOP3]] = distinct !{[[LOOP3]], [[META1]]}
; CHECK: [[LOOP4]] = distinct !{[[LOOP4]], [[META1]]}
; CHECK: [[TBAA5]] = !{[[META6:![0-9]+]], [[META6]], i64 0}
; CHECK: [[META6]] = !{!"char", [[META7:![0-9]+]], i64 0}
; CHECK: [[META7]] = !{!"root"}
; CHECK: [[LOOP8]] = distinct !{[[LOOP8]], [[META1]]}
; CHECK: [[LOOP9]] = distinct !{[[LOOP9]], [[META1]]}
; CHECK: [[TBAA10]] = !{[[META11:![0-9]+]], [[META11]], i64 0}
; CHECK: [[META11]] = !{!"int", [[META7]], i64 0}
; CHECK: [[LOOP12]] = distinct !{[[LOOP12]], [[META1]]}
; CHECK: [[LOOP13]] = distinct !{[[LOOP13]], [[META1]]}
; CHECK: [[LOOP14]] = distinct !{[[LOOP14]], [[META1]]}
;.
