; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -S -passes=loop-unroll -unroll-peel-max-count=3 | FileCheck %s

declare void @foo(i32)
declare void @bar(i8)

define void @test_umin(i32 %N) {
; CHECK-LABEL: define void @test_umin(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP5_NOT:%.*]] = icmp eq i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP5_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_06:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[COND:%.*]] = tail call i32 @llvm.umin.i32(i32 [[I_06]], i32 2)
; CHECK-NEXT:    tail call void @foo(i32 [[COND]])
; CHECK-NEXT:    [[INC]] = add nuw i32 [[I_06]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[FOR_BODY]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp5.not = icmp eq i32 %N, 0
  br i1 %cmp5.not, label %for.cond.cleanup, label %for.body

for.body:
  %i.06 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %cond = tail call i32 @llvm.umin.i32(i32 %i.06, i32 2)
  tail call void @foo(i32 %cond)
  %inc = add nuw i32 %i.06, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}

define void @test_umax(i32 %N) {
; CHECK-LABEL: define void @test_umax(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP5_NOT:%.*]] = icmp eq i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP5_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_06:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[COND:%.*]] = tail call i32 @llvm.umax.i32(i32 [[I_06]], i32 2)
; CHECK-NEXT:    tail call void @foo(i32 [[COND]])
; CHECK-NEXT:    [[INC]] = add nuw i32 [[I_06]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[FOR_BODY]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp5.not = icmp eq i32 %N, 0
  br i1 %cmp5.not, label %for.cond.cleanup, label %for.body

for.body:
  %i.06 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %cond = tail call i32 @llvm.umax.i32(i32 %i.06, i32 2)
  tail call void @foo(i32 %cond)
  %inc = add nuw i32 %i.06, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}

define void @test_smax(i32 %N) {
; CHECK-LABEL: define void @test_smax(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP5:%.*]] = icmp slt i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP5]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_06:%.*]] = phi i32 [ [[DEC:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[COND:%.*]] = tail call i32 @llvm.smax.i32(i32 [[I_06]], i32 -2)
; CHECK-NEXT:    tail call void @foo(i32 [[COND]])
; CHECK-NEXT:    [[DEC]] = add nsw i32 [[I_06]], -1
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[DEC]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp5 = icmp slt i32 %N, 0
  br i1 %cmp5, label %for.body, label %for.cond.cleanup

for.body:
  %i.06 = phi i32 [ %dec, %for.body ], [ 0, %entry ]
  %cond = tail call i32 @llvm.smax.i32(i32 %i.06, i32 -2)
  tail call void @foo(i32 %cond)
  %dec = add nsw i32 %i.06, -1
  %cmp = icmp sgt i32 %dec, %N
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:
  ret void
}

define void @test_smin(i32 %N) {
; CHECK-LABEL: define void @test_smin(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP5:%.*]] = icmp slt i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP5]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_06:%.*]] = phi i32 [ [[DEC:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[COND:%.*]] = tail call i32 @llvm.smin.i32(i32 [[I_06]], i32 -2)
; CHECK-NEXT:    tail call void @foo(i32 noundef signext [[COND]])
; CHECK-NEXT:    [[DEC]] = add nsw i32 [[I_06]], -1
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[DEC]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp5 = icmp slt i32 %N, 0
  br i1 %cmp5, label %for.body, label %for.cond.cleanup

for.body:
  %i.06 = phi i32 [ %dec, %for.body ], [ 0, %entry ]
  %cond = tail call i32 @llvm.smin.i32(i32 %i.06, i32 -2)
  tail call void @foo(i32 noundef signext %cond)
  %dec = add nsw i32 %i.06, -1
  %cmp = icmp sgt i32 %dec, %N
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:
  ret void
}

define void @test_negative(i32 %End, i32 %Step) {
; CHECK-LABEL: define void @test_negative(
; CHECK-SAME: i32 [[END:%.*]], i32 [[STEP:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT5:%.*]] = icmp eq i32 [[END]], 0
; CHECK-NEXT:    br i1 [[CMP_NOT5]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_06:%.*]] = phi i32 [ [[ADD:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[COND:%.*]] = tail call i32 @llvm.smin.i32(i32 [[I_06]], i32 2)
; CHECK-NEXT:    tail call void @foo(i32 [[COND]])
; CHECK-NEXT:    [[ADD]] = add nsw i32 [[I_06]], [[STEP]]
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[ADD]], [[END]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[FOR_BODY]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp.not5 = icmp eq i32 %End, 0
  br i1 %cmp.not5, label %for.cond.cleanup, label %for.body

for.body:
  %i.06 = phi i32 [ %add, %for.body ], [ 0, %entry ]
  %cond = tail call i32 @llvm.smin.i32(i32 %i.06, i32 2)
  tail call void @foo(i32 %cond)
  %add = add nsw i32 %i.06, %Step
  %cmp.not = icmp eq i32 %add, %End
  br i1 %cmp.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}

define void @test_max_count_threshold(i32 %N) {
; CHECK-LABEL: define void @test_max_count_threshold(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP5_NOT:%.*]] = icmp eq i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP5_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_06:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[COND:%.*]] = tail call i32 @llvm.umin.i32(i32 [[I_06]], i32 5)
; CHECK-NEXT:    tail call void @foo(i32 [[COND]])
; CHECK-NEXT:    [[INC]] = add nuw i32 [[I_06]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[FOR_BODY]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp5.not = icmp eq i32 %N, 0
  br i1 %cmp5.not, label %for.cond.cleanup, label %for.body

for.body:
  %i.06 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %cond = tail call i32 @llvm.umin.i32(i32 %i.06, i32 5)
  tail call void @foo(i32 %cond)
  %inc = add nuw i32 %i.06, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}

define void @test_wrap(i8 %N) {
; CHECK-LABEL: define void @test_wrap(
; CHECK-SAME: i8 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP5_NOT:%.*]] = icmp eq i8 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP5_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    br label [[FOR_BODY1:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[I_06:%.*]] = phi i8 [ [[INC1:%.*]], [[FOR_BODY1]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[COND1:%.*]] = tail call i8 @llvm.umin.i8(i8 [[I_06]], i8 -2)
; CHECK-NEXT:    tail call void @bar(i8 [[COND1]])
; CHECK-NEXT:    [[INC1]] = add i8 [[I_06]], 127
; CHECK-NEXT:    [[EXITCOND_NOT1:%.*]] = icmp eq i8 [[INC1]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT1]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[FOR_BODY1]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %cmp5.not = icmp eq i8 %N, 0
  br i1 %cmp5.not, label %for.cond.cleanup, label %for.body

for.body:
  %i.06 = phi i8 [ %inc, %for.body ], [ 0, %entry ]
  %cond = tail call i8 @llvm.umin.i8(i8 %i.06, i8 254)
  tail call void @bar(i8 %cond)
  %inc = add i8 %i.06, 127
  %exitcond.not = icmp eq i8 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void
}
