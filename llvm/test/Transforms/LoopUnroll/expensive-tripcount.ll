; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -S -passes=loop-unroll,instcombine | FileCheck -check-prefixes=CHECK,CHECK-NOUNROLL %s
; RUN: opt < %s -S -passes=loop-unroll,instcombine -unroll-runtime-expensive-trip-count | FileCheck -check-prefixes=CHECK,CHECK-UNROLL %s

define amdgpu_kernel void @_Z6kernelPilll(ptr addrspace(1) noundef writeonly captures(none) %a.coerce, i64 noundef %n, i64 noundef %k, i64 noundef %s) {
; CHECK-NOUNROLL-LABEL: define amdgpu_kernel void @_Z6kernelPilll(
; CHECK-NOUNROLL-SAME: ptr addrspace(1) noundef writeonly captures(none) [[A_COERCE:%.*]], i64 noundef [[N:%.*]], i64 noundef [[K:%.*]], i64 noundef [[S:%.*]]) {
; CHECK-NOUNROLL-NEXT:  [[ENTRY:.*:]]
; CHECK-NOUNROLL-NEXT:    [[IMPL_ARG_PTR:%.*]] = tail call ptr addrspace(4) @llvm.amdgcn.implicitarg.ptr()
; CHECK-NOUNROLL-NEXT:    [[BID:%.*]] = tail call i32 @llvm.amdgcn.workgroup.id.x()
; CHECK-NOUNROLL-NEXT:    [[IMPL_ARG:%.*]] = load i32, ptr addrspace(4) [[IMPL_ARG_PTR]], align 4
; CHECK-NOUNROLL-NEXT:    [[CMP_ULT:%.*]] = icmp ult i32 [[BID]], [[IMPL_ARG]]
; CHECK-NOUNROLL-NEXT:    [[SEL_I:%.*]] = select i1 [[CMP_ULT]], i64 12, i64 18
; CHECK-NOUNROLL-NEXT:    [[GEP:%.*]] = getelementptr inbounds nuw i8, ptr addrspace(4) [[IMPL_ARG_PTR]], i64 [[SEL_I]]
; CHECK-NOUNROLL-NEXT:    [[LD:%.*]] = load i16, ptr addrspace(4) [[GEP]], align 2
; CHECK-NOUNROLL-NEXT:    [[TID:%.*]] = tail call i32 @llvm.amdgcn.workitem.id.x()
; CHECK-NOUNROLL-NEXT:    [[MUL:%.*]] = mul nsw i64 [[K]], [[N]]
; CHECK-NOUNROLL-NEXT:    [[CONV_I_I4:%.*]] = zext i16 [[LD]] to i32
; CHECK-NOUNROLL-NEXT:    [[CONV5:%.*]] = zext nneg i32 [[TID]] to i64
; CHECK-NOUNROLL-NEXT:    [[CMP6:%.*]] = icmp sgt i64 [[MUL]], [[CONV5]]
; CHECK-NOUNROLL-NEXT:    br i1 [[CMP6]], label %[[FOR_BODY_PREHEADER:.*]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK-NOUNROLL:       [[FOR_BODY_PREHEADER]]:
; CHECK-NOUNROLL-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-NOUNROLL:       [[FOR_COND_CLEANUP_LOOPEXIT:.*]]:
; CHECK-NOUNROLL-NEXT:    br label %[[FOR_COND_CLEANUP]]
; CHECK-NOUNROLL:       [[FOR_COND_CLEANUP]]:
; CHECK-NOUNROLL-NEXT:    ret void
; CHECK-NOUNROLL:       [[FOR_BODY]]:
; CHECK-NOUNROLL-NEXT:    [[CONV8:%.*]] = phi i64 [ [[CONV:%.*]], %[[FOR_BODY]] ], [ [[CONV5]], %[[FOR_BODY_PREHEADER]] ]
; CHECK-NOUNROLL-NEXT:    [[I3_07:%.*]] = phi i32 [ [[ADD:%.*]], %[[FOR_BODY]] ], [ [[TID]], %[[FOR_BODY_PREHEADER]] ]
; CHECK-NOUNROLL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV8]]
; CHECK-NOUNROLL-NEXT:    store i32 [[I3_07]], ptr addrspace(1) [[ARRAYIDX]], align 4
; CHECK-NOUNROLL-NEXT:    [[ADD]] = add nuw nsw i32 [[I3_07]], [[CONV_I_I4]]
; CHECK-NOUNROLL-NEXT:    [[CONV]] = zext nneg i32 [[ADD]] to i64
; CHECK-NOUNROLL-NEXT:    [[CMP:%.*]] = icmp sgt i64 [[MUL]], [[CONV]]
; CHECK-NOUNROLL-NEXT:    br i1 [[CMP]], label %[[FOR_BODY]], label %[[FOR_COND_CLEANUP_LOOPEXIT]], !llvm.loop [[LOOP0:![0-9]+]]
;
; CHECK-UNROLL-LABEL: define amdgpu_kernel void @_Z6kernelPilll(
; CHECK-UNROLL-SAME: ptr addrspace(1) noundef writeonly captures(none) [[A_COERCE:%.*]], i64 noundef [[N:%.*]], i64 noundef [[K:%.*]], i64 noundef [[S:%.*]]) {
; CHECK-UNROLL-NEXT:  [[ENTRY:.*:]]
; CHECK-UNROLL-NEXT:    [[IMPL_ARG_PTR:%.*]] = tail call ptr addrspace(4) @llvm.amdgcn.implicitarg.ptr()
; CHECK-UNROLL-NEXT:    [[BID:%.*]] = tail call i32 @llvm.amdgcn.workgroup.id.x()
; CHECK-UNROLL-NEXT:    [[IMPL_ARG:%.*]] = load i32, ptr addrspace(4) [[IMPL_ARG_PTR]], align 4
; CHECK-UNROLL-NEXT:    [[CMP_ULT:%.*]] = icmp ult i32 [[BID]], [[IMPL_ARG]]
; CHECK-UNROLL-NEXT:    [[SEL_I:%.*]] = select i1 [[CMP_ULT]], i64 12, i64 18
; CHECK-UNROLL-NEXT:    [[GEP:%.*]] = getelementptr inbounds nuw i8, ptr addrspace(4) [[IMPL_ARG_PTR]], i64 [[SEL_I]]
; CHECK-UNROLL-NEXT:    [[LD:%.*]] = load i16, ptr addrspace(4) [[GEP]], align 2
; CHECK-UNROLL-NEXT:    [[TID:%.*]] = tail call i32 @llvm.amdgcn.workitem.id.x()
; CHECK-UNROLL-NEXT:    [[MUL:%.*]] = mul nsw i64 [[K]], [[N]]
; CHECK-UNROLL-NEXT:    [[CONV_I_I4:%.*]] = zext i16 [[LD]] to i32
; CHECK-UNROLL-NEXT:    [[CONV5:%.*]] = zext nneg i32 [[TID]] to i64
; CHECK-UNROLL-NEXT:    [[CMP6:%.*]] = icmp sgt i64 [[MUL]], [[CONV5]]
; CHECK-UNROLL-NEXT:    br i1 [[CMP6]], label %[[FOR_BODY_PREHEADER:.*]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK-UNROLL:       [[FOR_BODY_PREHEADER]]:
; CHECK-UNROLL-NEXT:    [[TMP0:%.*]] = zext i16 [[LD]] to i64
; CHECK-UNROLL-NEXT:    [[TMP1:%.*]] = add nuw nsw i64 [[CONV5]], [[TMP0]]
; CHECK-UNROLL-NEXT:    [[SMAX:%.*]] = call i64 @llvm.smax.i64(i64 [[MUL]], i64 [[TMP1]])
; CHECK-UNROLL-NEXT:    [[TMP2:%.*]] = icmp slt i64 [[TMP1]], [[MUL]]
; CHECK-UNROLL-NEXT:    [[UMIN:%.*]] = zext i1 [[TMP2]] to i64
; CHECK-UNROLL-NEXT:    [[TMP3:%.*]] = add nuw nsw i64 [[TMP1]], [[UMIN]]
; CHECK-UNROLL-NEXT:    [[TMP4:%.*]] = sub nsw i64 [[SMAX]], [[TMP3]]
; CHECK-UNROLL-NEXT:    [[TMP5:%.*]] = udiv i64 [[TMP4]], [[TMP0]]
; CHECK-UNROLL-NEXT:    [[TMP6:%.*]] = add i64 [[TMP5]], [[UMIN]]
; CHECK-UNROLL-NEXT:    [[TMP7:%.*]] = add i64 [[TMP6]], 1
; CHECK-UNROLL-NEXT:    [[XTRAITER:%.*]] = and i64 [[TMP7]], 7
; CHECK-UNROLL-NEXT:    [[TMP8:%.*]] = and i64 [[TMP6]], 7
; CHECK-UNROLL-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[TMP8]], 7
; CHECK-UNROLL-NEXT:    br i1 [[LCMP_MOD_NOT]], label %[[FOR_BODY_PROL_LOOPEXIT:.*]], label %[[FOR_BODY_PROL_PREHEADER:.*]]
; CHECK-UNROLL:       [[FOR_BODY_PROL_PREHEADER]]:
; CHECK-UNROLL-NEXT:    br label %[[FOR_BODY_PROL:.*]]
; CHECK-UNROLL:       [[FOR_BODY_PROL]]:
; CHECK-UNROLL-NEXT:    [[CONV8_PROL:%.*]] = phi i64 [ [[CONV_PROL:%.*]], %[[FOR_BODY_PROL]] ], [ [[CONV5]], %[[FOR_BODY_PROL_PREHEADER]] ]
; CHECK-UNROLL-NEXT:    [[I3_07_PROL:%.*]] = phi i32 [ [[ADD_PROL:%.*]], %[[FOR_BODY_PROL]] ], [ [[TID]], %[[FOR_BODY_PROL_PREHEADER]] ]
; CHECK-UNROLL-NEXT:    [[PROL_ITER:%.*]] = phi i64 [ [[PROL_ITER_NEXT:%.*]], %[[FOR_BODY_PROL]] ], [ 0, %[[FOR_BODY_PROL_PREHEADER]] ]
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_PROL:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV8_PROL]]
; CHECK-UNROLL-NEXT:    store i32 [[I3_07_PROL]], ptr addrspace(1) [[ARRAYIDX_PROL]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_PROL]] = add nuw nsw i32 [[I3_07_PROL]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_PROL]] = zext nneg i32 [[ADD_PROL]] to i64
; CHECK-UNROLL-NEXT:    [[PROL_ITER_NEXT]] = add i64 [[PROL_ITER]], 1
; CHECK-UNROLL-NEXT:    [[PROL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[PROL_ITER_NEXT]], [[XTRAITER]]
; CHECK-UNROLL-NEXT:    br i1 [[PROL_ITER_CMP_NOT]], label %[[FOR_BODY_PROL_LOOPEXIT_UNR_LCSSA:.*]], label %[[FOR_BODY_PROL]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK-UNROLL:       [[FOR_BODY_PROL_LOOPEXIT_UNR_LCSSA]]:
; CHECK-UNROLL-NEXT:    br label %[[FOR_BODY_PROL_LOOPEXIT]]
; CHECK-UNROLL:       [[FOR_BODY_PROL_LOOPEXIT]]:
; CHECK-UNROLL-NEXT:    [[CONV8_UNR:%.*]] = phi i64 [ [[CONV5]], %[[FOR_BODY_PREHEADER]] ], [ [[CONV_PROL]], %[[FOR_BODY_PROL_LOOPEXIT_UNR_LCSSA]] ]
; CHECK-UNROLL-NEXT:    [[I3_07_UNR:%.*]] = phi i32 [ [[TID]], %[[FOR_BODY_PREHEADER]] ], [ [[ADD_PROL]], %[[FOR_BODY_PROL_LOOPEXIT_UNR_LCSSA]] ]
; CHECK-UNROLL-NEXT:    [[TMP9:%.*]] = icmp ult i64 [[TMP6]], 7
; CHECK-UNROLL-NEXT:    br i1 [[TMP9]], label %[[FOR_COND_CLEANUP_LOOPEXIT:.*]], label %[[FOR_BODY_PREHEADER_NEW:.*]]
; CHECK-UNROLL:       [[FOR_BODY_PREHEADER_NEW]]:
; CHECK-UNROLL-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK-UNROLL:       [[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA:.*]]:
; CHECK-UNROLL-NEXT:    br label %[[FOR_COND_CLEANUP_LOOPEXIT]]
; CHECK-UNROLL:       [[FOR_COND_CLEANUP_LOOPEXIT]]:
; CHECK-UNROLL-NEXT:    br label %[[FOR_COND_CLEANUP]]
; CHECK-UNROLL:       [[FOR_COND_CLEANUP]]:
; CHECK-UNROLL-NEXT:    ret void
; CHECK-UNROLL:       [[FOR_BODY]]:
; CHECK-UNROLL-NEXT:    [[CONV8:%.*]] = phi i64 [ [[CONV8_UNR]], %[[FOR_BODY_PREHEADER_NEW]] ], [ [[CONV_7:%.*]], %[[FOR_BODY]] ]
; CHECK-UNROLL-NEXT:    [[I3_07:%.*]] = phi i32 [ [[I3_07_UNR]], %[[FOR_BODY_PREHEADER_NEW]] ], [ [[ADD_7:%.*]], %[[FOR_BODY]] ]
; CHECK-UNROLL-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV8]]
; CHECK-UNROLL-NEXT:    store i32 [[I3_07]], ptr addrspace(1) [[ARRAYIDX]], align 4
; CHECK-UNROLL-NEXT:    [[ADD:%.*]] = add nuw nsw i32 [[I3_07]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV:%.*]] = zext nneg i32 [[ADD]] to i64
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_1:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV]]
; CHECK-UNROLL-NEXT:    store i32 [[ADD]], ptr addrspace(1) [[ARRAYIDX_1]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_1:%.*]] = add nuw nsw i32 [[ADD]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_1:%.*]] = zext nneg i32 [[ADD_1]] to i64
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_2:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV_1]]
; CHECK-UNROLL-NEXT:    store i32 [[ADD_1]], ptr addrspace(1) [[ARRAYIDX_2]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_2:%.*]] = add nuw nsw i32 [[ADD_1]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_2:%.*]] = zext nneg i32 [[ADD_2]] to i64
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_3:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV_2]]
; CHECK-UNROLL-NEXT:    store i32 [[ADD_2]], ptr addrspace(1) [[ARRAYIDX_3]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_3:%.*]] = add nuw nsw i32 [[ADD_2]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_3:%.*]] = zext nneg i32 [[ADD_3]] to i64
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_4:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV_3]]
; CHECK-UNROLL-NEXT:    store i32 [[ADD_3]], ptr addrspace(1) [[ARRAYIDX_4]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_4:%.*]] = add nuw nsw i32 [[ADD_3]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_4:%.*]] = zext nneg i32 [[ADD_4]] to i64
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_5:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV_4]]
; CHECK-UNROLL-NEXT:    store i32 [[ADD_4]], ptr addrspace(1) [[ARRAYIDX_5]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_5:%.*]] = add nuw nsw i32 [[ADD_4]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_5:%.*]] = zext nneg i32 [[ADD_5]] to i64
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_6:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV_5]]
; CHECK-UNROLL-NEXT:    store i32 [[ADD_5]], ptr addrspace(1) [[ARRAYIDX_6]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_6:%.*]] = add nuw nsw i32 [[ADD_5]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_6:%.*]] = zext nneg i32 [[ADD_6]] to i64
; CHECK-UNROLL-NEXT:    [[ARRAYIDX_7:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[A_COERCE]], i64 [[CONV_6]]
; CHECK-UNROLL-NEXT:    store i32 [[ADD_6]], ptr addrspace(1) [[ARRAYIDX_7]], align 4
; CHECK-UNROLL-NEXT:    [[ADD_7]] = add nuw nsw i32 [[ADD_6]], [[CONV_I_I4]]
; CHECK-UNROLL-NEXT:    [[CONV_7]] = zext nneg i32 [[ADD_7]] to i64
; CHECK-UNROLL-NEXT:    [[CMP_7:%.*]] = icmp sgt i64 [[MUL]], [[CONV_7]]
; CHECK-UNROLL-NEXT:    br i1 [[CMP_7]], label %[[FOR_BODY]], label %[[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA]], !llvm.loop [[LOOP2:![0-9]+]]
;
entry:
  %impl.arg.ptr = tail call ptr addrspace(4) @llvm.amdgcn.implicitarg.ptr()
  %bid = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %impl.arg = load i32, ptr addrspace(4) %impl.arg.ptr, align 4
  %cmp.ult = icmp ult i32 %bid, %impl.arg
  %sel.i = select i1 %cmp.ult, i64 12, i64 18
  %gep = getelementptr inbounds nuw i8, ptr addrspace(4) %impl.arg.ptr, i64 %sel.i
  %ld = load i16, ptr addrspace(4) %gep, align 2
  %tid = tail call i32 @llvm.amdgcn.workitem.id.x()
  %mul = mul nsw i64 %k, %n
  %cmp.i.i = icmp eq i64 %s, 0
  %spec.select.i.i = add nsw i64 %s, %mul
  %conv.i.i4 = zext i16 %ld to i32
  %conv5 = zext nneg i32 %tid to i64
  %cmp6 = icmp sgt i64 %mul, %conv5
  br i1 %cmp6, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body, %for.body.preheader
  %conv8 = phi i64 [ %conv, %for.body ], [ %conv5, %for.body.preheader ]
  %i3.07 = phi i32 [ %add, %for.body ], [ %tid, %for.body.preheader ]
  %arrayidx = getelementptr inbounds nuw i32, ptr addrspace(1) %a.coerce, i64 %conv8
  store i32 %i3.07, ptr addrspace(1) %arrayidx, align 4
  %add = add nuw nsw i32 %i3.07, %conv.i.i4
  %conv = zext nneg i32 %add to i64
  %cmp = icmp sgt i64 %mul, %conv
  br i1 %cmp, label %for.body, label %for.cond.cleanup.loopexit, !llvm.loop !0
}

!0 = distinct !{!0, !1, !2}
!1 = !{!"llvm.loop.mustprogress"}
!2 = !{!"llvm.loop.unroll.enable"}
;.
; CHECK-NOUNROLL: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK-NOUNROLL: [[META1]] = !{!"llvm.loop.mustprogress"}
; CHECK-NOUNROLL: [[META2]] = !{!"llvm.loop.unroll.enable"}
;.
; CHECK-UNROLL: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]]}
; CHECK-UNROLL: [[META1]] = !{!"llvm.loop.unroll.disable"}
; CHECK-UNROLL: [[LOOP2]] = distinct !{[[LOOP2]], [[META3:![0-9]+]], [[META1]]}
; CHECK-UNROLL: [[META3]] = !{!"llvm.loop.mustprogress"}
;.
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
