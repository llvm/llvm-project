; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=aarch64 -passes=loop-unroll -S %s | FileCheck %s

; Test that loop peeling is applied for consecutive load widening opportunities
; and that appropriate dereferenceable assumptions are added.

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"

; Test 3-byte consecutive loads, should peel last iteration and use an i32 load.
define void @test_3_consecutive_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_3_consecutive_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = trunc i32 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP10:%.*]] = lshr i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i32 [[TMP10]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i32 [[TMP2]], 16
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i32 [[TMP6]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP9]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  ; Use the loaded values to prevent DCE
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

; Test 3-byte consecutive loads, should peel last iteration and use an i64 load.
define void @test_5_consecutive_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_5_consecutive_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[P]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = trunc i64 [[TMP2]] to i8
; CHECK-NEXT:    [[TMP14:%.*]] = lshr i64 [[TMP2]], 8
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i64 [[TMP14]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i64 [[TMP2]], 16
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i64 [[TMP6]] to i8
; CHECK-NEXT:    [[TMP8:%.*]] = lshr i64 [[TMP2]], 24
; CHECK-NEXT:    [[TMP9:%.*]] = trunc i64 [[TMP8]] to i8
; CHECK-NEXT:    [[TMP10:%.*]] = lshr i64 [[TMP2]], 32
; CHECK-NEXT:    [[TMP11:%.*]] = trunc i64 [[TMP10]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP13]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[SUM3:%.*]] = add i8 [[SUM2]], [[TMP9]]
; CHECK-NEXT:    [[SUM4:%.*]] = add i8 [[SUM3]], [[TMP11]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM4]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 5
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP12:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP12]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[P3_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[P4_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 4
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[D_PEEL:%.*]] = load i8, ptr [[P3_PEEL]], align 1
; CHECK-NEXT:    [[E_PEEL:%.*]] = load i8, ptr [[P4_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[SUM3_PEEL:%.*]] = add i8 [[SUM2_PEEL]], [[D_PEEL]]
; CHECK-NEXT:    [[SUM4_PEEL:%.*]] = add i8 [[SUM3_PEEL]], [[E_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM4_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 5
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2
  %p3 = getelementptr inbounds i8, ptr %p, i64 3
  %p4 = getelementptr inbounds i8, ptr %p, i64 4

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1
  %d = load i8, ptr %p3, align 1
  %e = load i8, ptr %p4, align 1

  ; Use the loaded values
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %sum3 = add i8 %sum2, %d
  %sum4 = add i8 %sum3, %e
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum4, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 5
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

; Test 8-byte consecutive loads does not peel the loop, already natural size.
define void @test_8_consecutive_loads_no_peel(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_8_consecutive_loads_no_peel(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[P3:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[P4:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[P5:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 5
; CHECK-NEXT:    [[P6:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 6
; CHECK-NEXT:    [[P7:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 7
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[D:%.*]] = load i8, ptr [[P3]], align 1
; CHECK-NEXT:    [[E:%.*]] = load i8, ptr [[P4]], align 1
; CHECK-NEXT:    [[F:%.*]] = load i8, ptr [[P5]], align 1
; CHECK-NEXT:    [[G:%.*]] = load i8, ptr [[P6]], align 1
; CHECK-NEXT:    [[H:%.*]] = load i8, ptr [[P7]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[SUM3:%.*]] = add i8 [[SUM2]], [[D]]
; CHECK-NEXT:    [[SUM4:%.*]] = add i8 [[SUM3]], [[E]]
; CHECK-NEXT:    [[SUM5:%.*]] = add i8 [[SUM4]], [[F]]
; CHECK-NEXT:    [[SUM6:%.*]] = add i8 [[SUM5]], [[G]]
; CHECK-NEXT:    [[SUM7:%.*]] = add i8 [[SUM6]], [[H]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM7]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 8
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2
  %p3 = getelementptr inbounds i8, ptr %p, i64 3
  %p4 = getelementptr inbounds i8, ptr %p, i64 4
  %p5 = getelementptr inbounds i8, ptr %p, i64 5
  %p6 = getelementptr inbounds i8, ptr %p, i64 6
  %p7 = getelementptr inbounds i8, ptr %p, i64 7

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1
  %d = load i8, ptr %p3, align 1
  %e = load i8, ptr %p4, align 1
  %f = load i8, ptr %p5, align 1
  %g = load i8, ptr %p6, align 1
  %h = load i8, ptr %p7, align 1

  ; Use all values
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %sum3 = add i8 %sum2, %d
  %sum4 = add i8 %sum3, %e
  %sum5 = add i8 %sum4, %f
  %sum6 = add i8 %sum5, %g
  %sum7 = add i8 %sum6, %h
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum7, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 8
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_non_consecutive_loads_no_peel(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_non_consecutive_loads_no_peel(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[P2:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 1
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[C:%.*]] = load i8, ptr [[P2]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[C]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 4
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 2  ; Skip offset 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 3

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 4
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

; Test 9-byte consecutive loads, should not peel because i128 isn't a legal integer type.
define void @test_9_consecutive_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_9_consecutive_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT_PEEL:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT_PEEL:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[P3_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[P4_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 4
; CHECK-NEXT:    [[P5_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 5
; CHECK-NEXT:    [[P6_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 6
; CHECK-NEXT:    [[P7_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 7
; CHECK-NEXT:    [[P8_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 8
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 16
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[D_PEEL:%.*]] = load i8, ptr [[P3_PEEL]], align 1
; CHECK-NEXT:    [[E_PEEL:%.*]] = load i8, ptr [[P4_PEEL]], align 1
; CHECK-NEXT:    [[F_PEEL:%.*]] = load i8, ptr [[P5_PEEL]], align 1
; CHECK-NEXT:    [[G_PEEL:%.*]] = load i8, ptr [[P6_PEEL]], align 1
; CHECK-NEXT:    [[H_PEEL:%.*]] = load i8, ptr [[P7_PEEL]], align 1
; CHECK-NEXT:    [[I_VAL_PEEL:%.*]] = load i8, ptr [[P8_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[SUM3_PEEL:%.*]] = add i8 [[SUM2_PEEL]], [[D_PEEL]]
; CHECK-NEXT:    [[SUM4_PEEL:%.*]] = add i8 [[SUM3_PEEL]], [[E_PEEL]]
; CHECK-NEXT:    [[SUM5_PEEL:%.*]] = add i8 [[SUM4_PEEL]], [[F_PEEL]]
; CHECK-NEXT:    [[SUM6_PEEL:%.*]] = add i8 [[SUM5_PEEL]], [[G_PEEL]]
; CHECK-NEXT:    [[SUM7_PEEL:%.*]] = add i8 [[SUM6_PEEL]], [[H_PEEL]]
; CHECK-NEXT:    [[SUM9_PEEL:%.*]] = add i8 [[SUM7_PEEL]], [[I_VAL_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM9_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL]] = getelementptr inbounds i8, ptr [[TMP4]], i64 9
; CHECK-NEXT:    [[I_NEXT_PEEL]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2
  %p3 = getelementptr inbounds i8, ptr %p, i64 3
  %p4 = getelementptr inbounds i8, ptr %p, i64 4
  %p5 = getelementptr inbounds i8, ptr %p, i64 5
  %p6 = getelementptr inbounds i8, ptr %p, i64 6
  %p7 = getelementptr inbounds i8, ptr %p, i64 7
  %p8 = getelementptr inbounds i8, ptr %p, i64 8

  %a = load i8, ptr %p, align 16
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1
  %d = load i8, ptr %p3, align 1
  %e = load i8, ptr %p4, align 1
  %f = load i8, ptr %p5, align 1
  %g = load i8, ptr %p6, align 1
  %h = load i8, ptr %p7, align 1
  %i.val = load i8, ptr %p8, align 1

  ; Use all values
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %sum3 = add i8 %sum2, %d
  %sum4 = add i8 %sum3, %e
  %sum5 = add i8 %sum4, %f
  %sum6 = add i8 %sum5, %g
  %sum7 = add i8 %sum6, %h
  %sum8 = add i8 %sum7, %i.val
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum8, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 9
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_intervening_store(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_intervening_store(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT_PEEL:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP4]], align 1
; CHECK-NEXT:    store i8 42, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP3]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL]] = getelementptr inbounds i8, ptr [[TMP4]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[TMP3]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  store i8 42, ptr %p1, align 1  ; Intervening store prevents optimization
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

; Test 3 consecutive i16 loads (6 bytes), should peel and widen to i64.
define void @test_3_consecutive_i16_loads(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_3_consecutive_i16_loads(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[P]], align 8
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i64 [[TMP2]] to i16
; CHECK-NEXT:    [[TMP4:%.*]] = lshr i64 [[TMP2]], 16
; CHECK-NEXT:    [[TMP5:%.*]] = trunc i64 [[TMP4]] to i16
; CHECK-NEXT:    [[TMP6:%.*]] = lshr i64 [[TMP2]], 32
; CHECK-NEXT:    [[TMP7:%.*]] = trunc i64 [[TMP6]] to i16
; CHECK-NEXT:    [[SUM1:%.*]] = add i16 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i16 [[SUM1]], [[TMP7]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i16, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i16 [[SUM2]], ptr [[DST_I]], align 2
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 6
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP8]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i16, ptr [[TMP10]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i16, ptr [[TMP10]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i16, ptr [[TMP10]], align 2
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i16, ptr [[P1_PEEL]], align 2
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i16, ptr [[P2_PEEL]], align 2
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i16 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i16 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i16, ptr [[DST]], i32 [[TMP9]]
; CHECK-NEXT:    store i16 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 2
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP10]], i64 6
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP9]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i16, ptr %p, i64 1
  %p2 = getelementptr inbounds i16, ptr %p, i64 2

  %a = load i16, ptr %p, align 2
  %b = load i16, ptr %p1, align 2
  %c = load i16, ptr %p2, align 2

  %sum1 = add i16 %a, %b
  %sum2 = add i16 %sum1, %c
  %dst.i = getelementptr inbounds i16, ptr %dst, i32 %i
  store i16 %sum2, ptr %dst.i, align 2

  %p.next = getelementptr inbounds i8, ptr %p, i64 6
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

; Two i8 loads (or one i16) should not peel because 16-bits is already a natural size.
define void @test_2_consecutive_loads_no_peel_legal_type(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_2_consecutive_loads_no_peel_legal_type(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 1
; CHECK-NEXT:    [[A:%.*]] = load i8, ptr [[P]], align 2
; CHECK-NEXT:    [[B:%.*]] = load i8, ptr [[P1]], align 1
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM1]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 2
; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1

  %a = load i8, ptr %p, align 2
  %b = load i8, ptr %p1, align 1

  %sum1 = add i8 %a, %b
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum1, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 2
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.peeled.count", i32 1}
; CHECK: [[LOOP2]] = distinct !{[[LOOP2]], [[META1]]}
; CHECK: [[LOOP3]] = distinct !{[[LOOP3]], [[META1]]}
;.
