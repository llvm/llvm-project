; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -loop-unroll -S -unroll-threshold=120 -unroll-max-iteration-count-to-analyze=100 < %s | FileCheck %s

; TODO: None of the if.false blocks are reachable, it would be nice if
; the output of unrolling made this obvious and didn't rely on other
; passes to cleanup code the cost model already knew was dead.

@G = global i32 0

; Symbolic simplification can prove the value of %zext on first
; iteration, and can prove that it's loop invariant on the second
define i32 @test_symbolic_simplify(i32 %limit) {
; CHECK-LABEL: @test_symbolic_simplify(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_PEEL_BEGIN:%.*]]
; CHECK:       loop.peel.begin:
; CHECK-NEXT:    br label [[LOOP_PEEL:%.*]]
; CHECK:       loop.peel:
; CHECK-NEXT:    [[SUB_PEEL:%.*]] = sub i32 [[LIMIT:%.*]], 0
; CHECK-NEXT:    [[CMP_PEEL:%.*]] = icmp eq i32 [[SUB_PEEL]], [[LIMIT]]
; CHECK-NEXT:    [[ZEXT_PEEL:%.*]] = sext i1 [[CMP_PEEL]] to i32
; CHECK-NEXT:    store i32 [[ZEXT_PEEL]], i32* @G, align 4
; CHECK-NEXT:    [[IV_NEXT_PEEL:%.*]] = add i32 0, 1
; CHECK-NEXT:    [[LOOP_COND_PEEL:%.*]] = icmp ne i32 0, 80
; CHECK-NEXT:    br i1 [[LOOP_COND_PEEL]], label [[LOOP_PEEL_NEXT:%.*]], label [[DONE:%.*]]
; CHECK:       loop.peel.next:
; CHECK-NEXT:    br label [[LOOP_PEEL_NEXT1:%.*]]
; CHECK:       loop.peel.next1:
; CHECK-NEXT:    br label [[ENTRY_PEEL_NEWPH:%.*]]
; CHECK:       entry.peel.newph:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT_PEEL]], [[ENTRY_PEEL_NEWPH]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 0, [[LIMIT]]
; CHECK-NEXT:    [[ZEXT:%.*]] = sext i1 [[CMP]] to i32
; CHECK-NEXT:    store i32 [[ZEXT]], i32* @G, align 4
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp ne i32 [[IV]], 80
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[DONE_LOOPEXIT:%.*]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       done.loopexit:
; CHECK-NEXT:    [[ZEXT_LCSSA_PH:%.*]] = phi i32 [ [[ZEXT]], [[LOOP]] ]
; CHECK-NEXT:    br label [[DONE]]
; CHECK:       done:
; CHECK-NEXT:    [[ZEXT_LCSSA:%.*]] = phi i32 [ [[ZEXT_PEEL]], [[LOOP_PEEL]] ], [ [[ZEXT_LCSSA_PH]], [[DONE_LOOPEXIT]] ]
; CHECK-NEXT:    ret i32 [[ZEXT_LCSSA]]
;
entry:
  br label %loop

loop:                                             ; preds = %backedge, %entry
  %phi = phi i32 [ 0, %entry ], [ %limit, %loop ]
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %sub = sub i32 %limit, %phi
  %cmp = icmp eq i32 %sub, %limit
  %zext = sext i1 %cmp to i32
  store i32 %zext, i32* @G
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp ne i32 %iv, 80
  br i1 %loop.cond, label %loop, label %done

done:                                             ; preds = %backedge
  ret i32 %zext
}

; Use symbolic value facts to prune unreachable (expensive) paths
; through the loop.
define i32 @test_symbolic_path(i32 %limit) {
; CHECK-LABEL: @test_symbolic_path(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[SUM:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SUM_NEXT:%.*]], [[BACKEDGE:%.*]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[IV_NEXT:%.*]], [[BACKEDGE]] ]
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[LIMIT:%.*]], [[SUM]]
; CHECK-NEXT:    [[IS_POSITIVE:%.*]] = icmp eq i32 [[SUB]], [[LIMIT]]
; CHECK-NEXT:    br i1 [[IS_POSITIVE]], label [[BACKEDGE]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    br label [[BACKEDGE]]
; CHECK:       backedge:
; CHECK-NEXT:    [[HIDDEN_ZERO:%.*]] = sub i32 [[LIMIT]], [[SUB]]
; CHECK-NEXT:    [[SUM_NEXT]] = add i32 [[SUM]], [[HIDDEN_ZERO]]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp ne i32 [[IV]], 8
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[DONE:%.*]]
; CHECK:       done:
; CHECK-NEXT:    [[SUM_NEXT_LCSSA:%.*]] = phi i32 [ [[SUM_NEXT]], [[BACKEDGE]] ]
; CHECK-NEXT:    ret i32 [[SUM_NEXT_LCSSA]]
;
entry:
  br label %loop

loop:                                             ; preds = %backedge, %entry
  %sum = phi i32 [ 0, %entry ], [ %sum.next, %backedge ]
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  %sub = sub i32 %limit, %sum
  %is.positive = icmp eq i32 %sub, %limit
  br i1 %is.positive, label %backedge, label %if.false

if.false:                                         ; preds = %loop
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  br label %backedge

backedge:                                         ; preds = %if.false, %loop
  %hidden_zero = sub i32 %limit, %sub
  %sum.next = add i32 %sum, %hidden_zero
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp ne i32 %iv, 8
  br i1 %loop.cond, label %loop, label %done

done:                                             ; preds = %backedge
  %sum.next.lcssa = phi i32 [ %sum.next, %backedge ]
  ret i32 %sum.next.lcssa
}

; A test to show the ability to simplify branches (even without general
; symbolic execution of the loop beyond constants) is still useful.
define i32 @test_dom_condition(i32 %limit) {
; CHECK-LABEL: @test_dom_condition(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LOOP_GUARD:%.*]] = icmp sge i32 [[LIMIT:%.*]], 0
; CHECK-NEXT:    br i1 [[LOOP_GUARD]], label [[LOOP_PREHEADER:%.*]], label [[FAILURE:%.*]]
; CHECK:       loop.preheader:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[SUM:%.*]] = phi i32 [ [[SUM_NEXT:%.*]], [[BACKEDGE:%.*]] ], [ 0, [[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT:%.*]], [[BACKEDGE]] ], [ 0, [[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 0, [[SUM]]
; CHECK-NEXT:    [[IS_POSITIVE:%.*]] = icmp sle i32 [[SUB]], [[LIMIT]]
; CHECK-NEXT:    br i1 [[IS_POSITIVE]], label [[BACKEDGE]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    br label [[BACKEDGE]]
; CHECK:       backedge:
; CHECK-NEXT:    [[SUM_NEXT]] = add i32 [[SUM]], [[SUB]]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp ne i32 [[IV]], 8
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[DONE:%.*]]
; CHECK:       done:
; CHECK-NEXT:    [[SUM_NEXT_LCSSA:%.*]] = phi i32 [ [[SUM_NEXT]], [[BACKEDGE]] ]
; CHECK-NEXT:    ret i32 [[SUM_NEXT_LCSSA]]
; CHECK:       failure:
; CHECK-NEXT:    unreachable
;
entry:
  %loop_guard = icmp sge i32 %limit, 0
  br i1 %loop_guard, label %loop, label %failure

loop:                                             ; preds = %backedge, %entry
  %sum = phi i32 [ 0, %entry ], [ %sum.next, %backedge ]
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  %sub = sub i32 0, %sum
  %is.positive = icmp sle i32 %sub, %limit
  br i1 %is.positive, label %backedge, label %if.false

if.false:                                         ; preds = %loop
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  br label %backedge

backedge:                                         ; preds = %if.false, %loop
  %sum.next = add i32 %sum, %sub
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp ne i32 %iv, 8
  br i1 %loop.cond, label %loop, label %done

done:                                             ; preds = %backedge
  %sum.next.lcssa = phi i32 [ %sum.next, %backedge ]
  ret i32 %sum.next.lcssa

failure:
  unreachable
}

; We can symbolically evaluate %sub to %limit on first iteration, and
; to zero on all future iterations.
define i32 @test_both(i32 %limit) {
; CHECK-LABEL: @test_both(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LOOP_GUARD:%.*]] = icmp sge i32 [[LIMIT:%.*]], 0
; CHECK-NEXT:    br i1 [[LOOP_GUARD]], label [[LOOP_PREHEADER:%.*]], label [[FAILURE:%.*]]
; CHECK:       loop.preheader:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[SUM:%.*]] = phi i32 [ [[SUM_NEXT:%.*]], [[BACKEDGE:%.*]] ], [ 0, [[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT:%.*]], [[BACKEDGE]] ], [ 0, [[LOOP_PREHEADER]] ]
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[LIMIT]], [[SUM]]
; CHECK-NEXT:    [[IS_POSITIVE:%.*]] = icmp sge i32 [[SUB]], 0
; CHECK-NEXT:    br i1 [[IS_POSITIVE]], label [[BACKEDGE]], label [[IF_FALSE:%.*]]
; CHECK:       if.false:
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    call void @foo()
; CHECK-NEXT:    br label [[BACKEDGE]]
; CHECK:       backedge:
; CHECK-NEXT:    [[SUM_NEXT]] = add i32 [[SUM]], [[SUB]]
; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp ne i32 [[IV]], 8
; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[DONE:%.*]]
; CHECK:       done:
; CHECK-NEXT:    [[SUM_NEXT_LCSSA:%.*]] = phi i32 [ [[SUM_NEXT]], [[BACKEDGE]] ]
; CHECK-NEXT:    ret i32 [[SUM_NEXT_LCSSA]]
; CHECK:       failure:
; CHECK-NEXT:    unreachable
;
entry:
  %loop_guard = icmp sge i32 %limit, 0
  br i1 %loop_guard, label %loop, label %failure

loop:                                             ; preds = %backedge, %entry
  %sum = phi i32 [ 0, %entry ], [ %sum.next, %backedge ]
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %backedge ]
  %sub = sub i32 %limit, %sum
  %is.positive = icmp sge i32 %sub, 0
  br i1 %is.positive, label %backedge, label %if.false

if.false:                                         ; preds = %loop
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  call void @foo()
  br label %backedge

backedge:                                         ; preds = %if.false, %loop
  %sum.next = add i32 %sum, %sub
  %iv.next = add i32 %iv, 1
  %loop.cond = icmp ne i32 %iv, 8
  br i1 %loop.cond, label %loop, label %done

done:                                             ; preds = %backedge
  %sum.next.lcssa = phi i32 [ %sum.next, %backedge ]
  ret i32 %sum.next.lcssa

failure:
  unreachable
}

declare void @foo()
