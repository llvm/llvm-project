; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=aarch64_be -passes=loop-unroll -S %s | FileCheck %s

; Test that loop peeling for load widening works correctly on big-endian targets.
; The byte extraction shifts should be different from little-endian.

target datalayout = "E-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"

; Test 3-byte consecutive loads on big-endian, should peel and use i32 load.
; For big-endian with i32 load:
;   byte 0 (lowest address) is in bits [31:24]
;   byte 1 is in bits [23:16]
;   byte 2 is in bits [15:8]
;   byte 3 (unused) is in bits [7:0]
define void @test_3_consecutive_loads_be(ptr %src, ptr %dst, i32 %n) {
; CHECK-LABEL: define void @test_3_consecutive_loads_be(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label %[[ENTRY_SPLIT:.*]], label %[[EXIT_PEEL_BEGIN:.*]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY_SPLIT]] ], [ [[I_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[P:%.*]] = phi ptr [ [[SRC]], %[[ENTRY_SPLIT]] ], [ [[P_NEXT:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = lshr i32 [[TMP2]], 24
; CHECK-NEXT:    [[TMP4:%.*]] = trunc i32 [[TMP3]] to i8
; CHECK-NEXT:    [[TMP5:%.*]] = lshr i32 [[TMP2]], 16
; CHECK-NEXT:    [[TMP6:%.*]] = trunc i32 [[TMP5]] to i8
; CHECK-NEXT:    [[TMP7:%.*]] = lshr i32 [[TMP2]], 8
; CHECK-NEXT:    [[TMP8:%.*]] = trunc i32 [[TMP7]] to i8
; CHECK-NEXT:    [[SUM1:%.*]] = add i8 [[TMP4]], [[TMP6]]
; CHECK-NEXT:    [[SUM2:%.*]] = add i8 [[SUM1]], [[TMP8]]
; CHECK-NEXT:    [[DST_I:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[I]]
; CHECK-NEXT:    store i8 [[SUM2]], ptr [[DST_I]], align 1
; CHECK-NEXT:    [[P_NEXT]] = getelementptr inbounds i8, ptr [[P]], i64 3
; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1
; CHECK-NEXT:    [[TMP9:%.*]] = sub i32 [[N]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp ne i32 [[I_NEXT]], [[TMP9]]
; CHECK-NEXT:    br i1 [[COND]], label %[[LOOP]], label %[[EXIT_PEEL_BEGIN_LOOPEXIT:.*]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[EXIT_PEEL_BEGIN_LOOPEXIT]]:
; CHECK-NEXT:    [[DOTPH:%.*]] = phi i32 [ [[I_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    [[DOTPH1:%.*]] = phi ptr [ [[P_NEXT]], %[[LOOP]] ]
; CHECK-NEXT:    br label %[[EXIT_PEEL_BEGIN]]
; CHECK:       [[EXIT_PEEL_BEGIN]]:
; CHECK-NEXT:    [[TMP10:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[DOTPH]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    [[TMP11:%.*]] = phi ptr [ [[SRC]], %[[ENTRY]] ], [ [[DOTPH1]], %[[EXIT_PEEL_BEGIN_LOOPEXIT]] ]
; CHECK-NEXT:    br label %[[LOOP_PEEL:.*]]
; CHECK:       [[LOOP_PEEL]]:
; CHECK-NEXT:    [[P1_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP11]], i64 1
; CHECK-NEXT:    [[P2_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP11]], i64 2
; CHECK-NEXT:    [[A_PEEL:%.*]] = load i8, ptr [[TMP11]], align 1
; CHECK-NEXT:    [[B_PEEL:%.*]] = load i8, ptr [[P1_PEEL]], align 1
; CHECK-NEXT:    [[C_PEEL:%.*]] = load i8, ptr [[P2_PEEL]], align 1
; CHECK-NEXT:    [[SUM1_PEEL:%.*]] = add i8 [[A_PEEL]], [[B_PEEL]]
; CHECK-NEXT:    [[SUM2_PEEL:%.*]] = add i8 [[SUM1_PEEL]], [[C_PEEL]]
; CHECK-NEXT:    [[DST_I_PEEL:%.*]] = getelementptr inbounds i8, ptr [[DST]], i32 [[TMP10]]
; CHECK-NEXT:    store i8 [[SUM2_PEEL]], ptr [[DST_I_PEEL]], align 1
; CHECK-NEXT:    [[P_NEXT_PEEL:%.*]] = getelementptr inbounds i8, ptr [[TMP11]], i64 3
; CHECK-NEXT:    [[I_NEXT_PEEL:%.*]] = add i32 [[TMP10]], 1
; CHECK-NEXT:    [[COND_PEEL:%.*]] = icmp ne i32 [[I_NEXT_PEEL]], [[N]]
; CHECK-NEXT:    br i1 [[COND_PEEL]], label %[[EXIT_PEEL_NEXT:.*]], label %[[EXIT_PEEL_NEXT]]
; CHECK:       [[EXIT_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[LOOP_PEEL_NEXT:.*]]
; CHECK:       [[LOOP_PEEL_NEXT]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %p = phi ptr [ %src, %entry ], [ %p.next, %loop ]

  %p1 = getelementptr inbounds i8, ptr %p, i64 1
  %p2 = getelementptr inbounds i8, ptr %p, i64 2

  %a = load i8, ptr %p, align 1
  %b = load i8, ptr %p1, align 1
  %c = load i8, ptr %p2, align 1

  ; Use the loaded values to prevent DCE
  %sum1 = add i8 %a, %b
  %sum2 = add i8 %sum1, %c
  %dst.i = getelementptr inbounds i8, ptr %dst, i32 %i
  store i8 %sum2, ptr %dst.i, align 1

  %p.next = getelementptr inbounds i8, ptr %p, i64 3
  %i.next = add i32 %i, 1
  %cond = icmp ne i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.peeled.count", i32 1}
;.
