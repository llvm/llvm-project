; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=loop-unroll -unroll-runtime %s | FileCheck %s

define i32 @pr131465(i1 %x) mustprogress {
; CHECK-LABEL: define i32 @pr131465(
; CHECK-SAME: i1 [[X:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[INC:%.*]] = zext i1 [[X]] to i32
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[INDVAR:%.*]] = phi i32 [ 2, %[[ENTRY]] ], [ [[NEXT_1:%.*]], %[[FOR_BODY_1:.*]] ]
; CHECK-NEXT:    [[NEXT:%.*]] = add nsw i32 [[INDVAR]], [[INC]]
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[NEXT]], 2
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[FOR_END:.*]], label %[[FOR_BODY_1]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[FOR_BODY_1]]:
; CHECK-NEXT:    [[NEXT_1]] = add nsw i32 [[NEXT]], [[INC]]
; CHECK-NEXT:    [[EXITCOND_1:%.*]] = icmp eq i32 [[NEXT_1]], 2
; CHECK-NEXT:    br i1 [[EXITCOND_1]], label %[[FOR_END]], label %[[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    ret i32 0
;
entry:
  %inc = zext i1 %x to i32
  br label %for.body

for.body:
  %indvar = phi i32 [ 2, %entry ], [ %next, %for.body ]
  %next = add nsw i32 %indvar, %inc
  %exitcond = icmp eq i32 %next, 2
  br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0

for.end:
  ret i32 0
}

; Force runtime unrolling.
!0 = !{!0, !{!"llvm.loop.unroll.count", i32 2}}
;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]]}
; CHECK: [[META1]] = !{!"llvm.loop.unroll.count", i32 2}
; CHECK: [[LOOP2]] = distinct !{[[LOOP2]], [[META3:![0-9]+]]}
; CHECK: [[META3]] = !{!"llvm.loop.unroll.disable"}
;.
