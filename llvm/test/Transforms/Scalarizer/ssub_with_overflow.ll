; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt %s -passes="function(scalarizer)" -S | FileCheck %s

define <3 x i32> @test_(<3 x i32> %a, <3 x i32> %b) {
; CHECK-LABEL: define <3 x i32> @test_(
; CHECK-SAME: <3 x i32> [[A:%.*]], <3 x i32> [[B:%.*]]) {
; CHECK-NEXT:    [[B_I0:%.*]] = extractelement <3 x i32> [[B]], i64 0
; CHECK-NEXT:    [[R_I0:%.*]] = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 [[B_I0]], i32 [[B_I0]])
; CHECK-NEXT:    [[B_I1:%.*]] = extractelement <3 x i32> [[B]], i64 1
; CHECK-NEXT:    [[R_I1:%.*]] = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 [[B_I1]], i32 [[B_I1]])
; CHECK-NEXT:    [[B_I2:%.*]] = extractelement <3 x i32> [[B]], i64 2
; CHECK-NEXT:    [[R_I2:%.*]] = call { i32, i1 } @llvm.ssub.with.overflow.i32(i32 [[B_I2]], i32 [[B_I2]])
; CHECK-NEXT:    [[EL_ELEM0:%.*]] = extractvalue { i32, i1 } [[R_I0]], 0
; CHECK-NEXT:    [[EL_ELEM01:%.*]] = extractvalue { i32, i1 } [[R_I1]], 0
; CHECK-NEXT:    [[EL_ELEM02:%.*]] = extractvalue { i32, i1 } [[R_I2]], 0
; CHECK-NEXT:    [[EL_UPTO0:%.*]] = insertelement <3 x i32> poison, i32 [[EL_ELEM0]], i64 0
; CHECK-NEXT:    [[EL_UPTO1:%.*]] = insertelement <3 x i32> [[EL_UPTO0]], i32 [[EL_ELEM01]], i64 1
; CHECK-NEXT:    [[EL:%.*]] = insertelement <3 x i32> [[EL_UPTO1]], i32 [[EL_ELEM02]], i64 2
; CHECK-NEXT:    ret <3 x i32> [[EL]]
;
  %r = call { <3 x i32>, <3 x i1> } @llvm.ssub.with.overflow.v3i32(<3 x i32> %b, <3 x i32> %b)
  %el = extractvalue { <3 x i32>, <3 x i1> } %r, 0
  ret <3 x i32> %el
}
