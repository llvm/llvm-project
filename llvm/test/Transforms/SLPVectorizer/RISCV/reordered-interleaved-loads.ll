; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S --passes=slp-vectorizer -mtriple=riscv64-unknown-linux-gnu -mattr=+v %s | FileCheck %s

@h = external global [21 x i16]
@a = external global [21 x [21 x i16]]

define i1 @test(i32 %conv15.12, i16 %0, ptr %1, i16 %2, i16 %3, i16 %4, i16 %5, i32 %conv15.1.3, i16 %6, i32 %conv15.1.4) {
; CHECK-LABEL: define i1 @test(
; CHECK-SAME: i32 [[CONV15_12:%.*]], i16 [[TMP0:%.*]], ptr [[TMP1:%.*]], i16 [[TMP2:%.*]], i16 [[TMP3:%.*]], i16 [[TMP4:%.*]], i16 [[TMP5:%.*]], i32 [[CONV15_1_3:%.*]], i16 [[TMP6:%.*]], i32 [[CONV15_1_4:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP7:%.*]] = load i16, ptr [[TMP1]], align 2
; CHECK-NEXT:    [[TMP8:%.*]] = load i16, ptr @h, align 2
; CHECK-NEXT:    [[TMP9:%.*]] = insertelement <4 x i16> poison, i16 [[TMP2]], i32 0
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <4 x i16> [[TMP9]], i16 [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP11:%.*]] = insertelement <4 x i16> [[TMP10]], i16 [[TMP8]], i32 1
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <4 x i16> [[TMP11]], i16 [[TMP7]], i32 3
; CHECK-NEXT:    [[TMP13:%.*]] = sext <4 x i16> [[TMP12]] to <4 x i32>
; CHECK-NEXT:    [[TMP14:%.*]] = call <4 x i32> @llvm.smax.v4i32(<4 x i32> [[TMP13]], <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq <4 x i16> [[TMP12]], zeroinitializer
; CHECK-NEXT:    [[TMP16:%.*]] = select <4 x i1> [[TMP15]], <4 x i32> splat (i32 8), <4 x i32> [[TMP13]]
; CHECK-NEXT:    [[TMP17:%.*]] = insertelement <4 x i32> [[TMP13]], i32 [[CONV15_12]], i32 3
; CHECK-NEXT:    [[TMP18:%.*]] = xor <4 x i32> [[TMP16]], [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = icmp sgt <4 x i32> [[TMP14]], [[TMP18]]
; CHECK-NEXT:    [[TMP29:%.*]] = extractelement <4 x i1> [[TMP19]], i32 3
; CHECK-NEXT:    [[CONV30_18:%.*]] = zext i1 [[TMP29]] to i16
; CHECK-NEXT:    store i16 [[CONV30_18]], ptr @a, align 2
; CHECK-NEXT:    [[TMP30:%.*]] = extractelement <4 x i1> [[TMP19]], i32 2
; CHECK-NEXT:    [[CONV30_219:%.*]] = zext i1 [[TMP30]] to i16
; CHECK-NEXT:    store i16 [[CONV30_219]], ptr @a, align 2
; CHECK-NEXT:    [[TMP31:%.*]] = extractelement <4 x i1> [[TMP19]], i32 1
; CHECK-NEXT:    [[CONV30_330:%.*]] = zext i1 [[TMP31]] to i16
; CHECK-NEXT:    store i16 [[CONV30_330]], ptr @a, align 2
; CHECK-NEXT:    [[TMP32:%.*]] = extractelement <4 x i1> [[TMP19]], i32 0
; CHECK-NEXT:    [[CONV30_4:%.*]] = zext i1 [[TMP32]] to i16
; CHECK-NEXT:    store i16 [[CONV30_4]], ptr @a, align 2
; CHECK-NEXT:    [[TMP24:%.*]] = insertelement <4 x i16> poison, i16 [[TMP3]], i32 0
; CHECK-NEXT:    [[TMP25:%.*]] = insertelement <4 x i16> [[TMP24]], i16 [[TMP4]], i32 1
; CHECK-NEXT:    [[TMP26:%.*]] = insertelement <4 x i16> [[TMP25]], i16 [[TMP5]], i32 2
; CHECK-NEXT:    [[TMP27:%.*]] = insertelement <4 x i16> [[TMP26]], i16 [[TMP6]], i32 3
; CHECK-NEXT:    [[TMP28:%.*]] = sext <4 x i16> [[TMP27]] to <4 x i32>
; CHECK-NEXT:    [[TMP38:%.*]] = load <16 x i16>, ptr getelementptr inbounds nuw (i8, ptr @h, i64 6), align 2
; CHECK-NEXT:    [[TMP39:%.*]] = shufflevector <16 x i16> [[TMP38]], <16 x i16> poison, <4 x i32> <i32 0, i32 3, i32 6, i32 9>
; CHECK-NEXT:    [[TMP40:%.*]] = call <4 x i32> @llvm.smax.v4i32(<4 x i32> [[TMP28]], <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP41:%.*]] = icmp eq <4 x i16> [[TMP39]], zeroinitializer
; CHECK-NEXT:    [[TMP42:%.*]] = select <4 x i1> [[TMP41]], <4 x i32> splat (i32 8), <4 x i32> [[TMP28]]
; CHECK-NEXT:    [[TMP43:%.*]] = insertelement <4 x i32> [[TMP28]], i32 [[CONV15_1_3]], i32 2
; CHECK-NEXT:    [[TMP44:%.*]] = insertelement <4 x i32> [[TMP43]], i32 [[CONV15_1_4]], i32 3
; CHECK-NEXT:    [[TMP45:%.*]] = xor <4 x i32> [[TMP42]], [[TMP44]]
; CHECK-NEXT:    [[TMP37:%.*]] = icmp sgt <4 x i32> [[TMP40]], [[TMP45]]
; CHECK-NEXT:    [[TMP33:%.*]] = extractelement <4 x i1> [[TMP37]], i32 0
; CHECK-NEXT:    [[CONV30_1_1:%.*]] = zext i1 [[TMP33]] to i16
; CHECK-NEXT:    store i16 [[CONV30_1_1]], ptr @a, align 2
; CHECK-NEXT:    [[TMP34:%.*]] = extractelement <4 x i1> [[TMP37]], i32 1
; CHECK-NEXT:    [[CONV30_1_2:%.*]] = zext i1 [[TMP34]] to i16
; CHECK-NEXT:    store i16 [[CONV30_1_2]], ptr @a, align 2
; CHECK-NEXT:    [[TMP35:%.*]] = extractelement <4 x i1> [[TMP37]], i32 2
; CHECK-NEXT:    [[CONV30_1_3:%.*]] = zext i1 [[TMP35]] to i16
; CHECK-NEXT:    store i16 [[CONV30_1_3]], ptr @a, align 2
; CHECK-NEXT:    [[TMP36:%.*]] = extractelement <4 x i1> [[TMP37]], i32 3
; CHECK-NEXT:    ret i1 [[TMP36]]
;
entry:
  %7 = load i16, ptr %1, align 2
  %conv15.121 = sext i16 %7 to i32
  %cond.13 = tail call i32 @llvm.smax.i32(i32 %conv15.121, i32 0)
  %tobool.not.14 = icmp eq i16 %7, 0
  %cond27.15 = select i1 %tobool.not.14, i32 8, i32 %conv15.121
  %xor.16 = xor i32 %cond27.15, %conv15.12
  %cmp28.17 = icmp sgt i32 %cond.13, %xor.16
  %conv30.18 = zext i1 %cmp28.17 to i16
  store i16 %conv30.18, ptr @a, align 2
  %conv15.213 = sext i16 %0 to i32
  %cond.214 = tail call i32 @llvm.smax.i32(i32 %conv15.213, i32 0)
  %tobool.not.215 = icmp eq i16 %0, 0
  %cond27.216 = select i1 %tobool.not.215, i32 8, i32 %conv15.213
  %xor.217 = xor i32 %cond27.216, %conv15.213
  %cmp28.218 = icmp sgt i32 %cond.214, %xor.217
  %conv30.219 = zext i1 %cmp28.218 to i16
  store i16 %conv30.219, ptr @a, align 2
  %8 = load i16, ptr @h, align 2
  %conv15.324 = sext i16 %8 to i32
  %cond.325 = tail call i32 @llvm.smax.i32(i32 %conv15.324, i32 0)
  %tobool.not.326 = icmp eq i16 %8, 0
  %cond27.327 = select i1 %tobool.not.326, i32 8, i32 %conv15.324
  %xor.328 = xor i32 %cond27.327, %conv15.324
  %cmp28.329 = icmp sgt i32 %cond.325, %xor.328
  %conv30.330 = zext i1 %cmp28.329 to i16
  store i16 %conv30.330, ptr @a, align 2
  %conv15.4 = sext i16 %2 to i32
  %cond.4 = tail call i32 @llvm.smax.i32(i32 %conv15.4, i32 0)
  %tobool.not.4 = icmp eq i16 %2, 0
  %cond27.4 = select i1 %tobool.not.4, i32 8, i32 %conv15.4
  %xor.4 = xor i32 %cond27.4, %conv15.4
  %cmp28.4 = icmp sgt i32 %cond.4, %xor.4
  %conv30.4 = zext i1 %cmp28.4 to i16
  store i16 %conv30.4, ptr @a, align 2
  %9 = load i16, ptr getelementptr inbounds nuw (i8, ptr @h, i64 6), align 2
  %conv15.1.1 = sext i16 %3 to i32
  %cond.1.1 = tail call i32 @llvm.smax.i32(i32 %conv15.1.1, i32 0)
  %tobool.not.1.1 = icmp eq i16 %9, 0
  %cond27.1.1 = select i1 %tobool.not.1.1, i32 8, i32 %conv15.1.1
  %xor.1.1 = xor i32 %cond27.1.1, %conv15.1.1
  %cmp28.1.1 = icmp sgt i32 %cond.1.1, %xor.1.1
  %conv30.1.1 = zext i1 %cmp28.1.1 to i16
  store i16 %conv30.1.1, ptr @a, align 2
  %10 = load i16, ptr getelementptr inbounds nuw (i8, ptr @h, i64 12), align 4
  %conv15.1.2 = sext i16 %4 to i32
  %cond.1.2 = tail call i32 @llvm.smax.i32(i32 %conv15.1.2, i32 0)
  %tobool.not.1.2 = icmp eq i16 %10, 0
  %cond27.1.2 = select i1 %tobool.not.1.2, i32 8, i32 %conv15.1.2
  %xor.1.2 = xor i32 %cond27.1.2, %conv15.1.2
  %cmp28.1.2 = icmp sgt i32 %cond.1.2, %xor.1.2
  %conv30.1.2 = zext i1 %cmp28.1.2 to i16
  store i16 %conv30.1.2, ptr @a, align 2
  %11 = load i16, ptr getelementptr inbounds nuw (i8, ptr @h, i64 18), align 2
  %conv15.1.32 = sext i16 %5 to i32
  %cond.1.3 = tail call i32 @llvm.smax.i32(i32 %conv15.1.32, i32 0)
  %tobool.not.1.3 = icmp eq i16 %11, 0
  %cond27.1.3 = select i1 %tobool.not.1.3, i32 8, i32 %conv15.1.32
  %xor.1.3 = xor i32 %cond27.1.3, %conv15.1.3
  %cmp28.1.3 = icmp sgt i32 %cond.1.3, %xor.1.3
  %conv30.1.3 = zext i1 %cmp28.1.3 to i16
  store i16 %conv30.1.3, ptr @a, align 2
  %12 = load i16, ptr getelementptr inbounds nuw (i8, ptr @h, i64 24), align 8
  %conv15.1.43 = sext i16 %6 to i32
  %cond.1.4 = tail call i32 @llvm.smax.i32(i32 %conv15.1.43, i32 0)
  %tobool.not.1.4 = icmp eq i16 %12, 0
  %cond27.1.4 = select i1 %tobool.not.1.4, i32 8, i32 %conv15.1.43
  %xor.1.4 = xor i32 %cond27.1.4, %conv15.1.4
  %cmp28.1.4 = icmp sgt i32 %cond.1.4, %xor.1.4
  ret i1 %cmp28.1.4
}

declare i32 @llvm.smax.i32(i32, i32)
