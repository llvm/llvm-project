; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s | FileCheck %s

define void @test(i32 %e, i32 %0) {
; CHECK-LABEL: define void @test(
; CHECK-SAME: i32 [[E:%.*]], i32 [[TMP0:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[H:%.*]] = alloca [4 x i32], align 16
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP0]], [[E]]
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[ADD]], 1
; CHECK-NEXT:    [[ADD4:%.*]] = add i32 [[ADD]], [[ADD2]]
; CHECK-NEXT:    store i32 [[ADD4]], ptr [[H]], align 16
; CHECK-NEXT:    [[ARRAYINIT_ELEMENT:%.*]] = getelementptr i8, ptr [[H]], i64 4
; CHECK-NEXT:    [[ADD5:%.*]] = add i32 [[E]], 1
; CHECK-NEXT:    [[ADD6:%.*]] = add i32 [[ADD5]], [[ADD2]]
; CHECK-NEXT:    store i32 [[ADD6]], ptr [[ARRAYINIT_ELEMENT]], align 4
; CHECK-NEXT:    [[ARRAYINIT_ELEMENT7:%.*]] = getelementptr i8, ptr [[H]], i64 8
; CHECK-NEXT:    store i32 [[ADD6]], ptr [[ARRAYINIT_ELEMENT7]], align 8
; CHECK-NEXT:    [[ARRAYINIT_ELEMENT10:%.*]] = getelementptr i8, ptr [[H]], i64 12
; CHECK-NEXT:    [[CALL12:%.*]] = tail call i32 @fn1(i32 [[ADD]])
; CHECK-NEXT:    store i32 [[CALL12]], ptr [[ARRAYINIT_ELEMENT10]], align 4
; CHECK-NEXT:    store volatile i32 0, ptr [[H]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %h = alloca [4 x i32], align 16
  %add = add i32 %0, %e
  %add2 = add i32 %add, 1
  %add4 = add i32 %add, %add2
  store i32 %add4, ptr %h, align 16
  %arrayinit.element = getelementptr i8, ptr %h, i64 4
  %add5 = add i32 %e, 1
  %add6 = add i32 %add5, %add2
  store i32 %add6, ptr %arrayinit.element, align 4
  %arrayinit.element7 = getelementptr i8, ptr %h, i64 8
  store i32 %add6, ptr %arrayinit.element7, align 8
  %arrayinit.element10 = getelementptr i8, ptr %h, i64 12
  %call12 = tail call i32 @fn1(i32 %add)
  store i32 %call12, ptr %arrayinit.element10, align 4
  store volatile i32 0, ptr %h, align 4
  ret void
}

declare i32 @fn1(i32)
