; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=slp-vectorizer -S -mtriple=x86_64-unknown-linux-gnu -mcpu=corei7-avx | FileCheck %s

; Make sure that we rotate the graph to help avoid the shuffle to
; the external vectorizable stores.
;
; SLP starts vectorizing from the operands of the `fcmp` in bb2, then crosses
; into bb1, vectorizing all the way to the broadcast load at the top.
; The stores in bb1 are external to this tree, but they are vectorizable and are
; in reverse order.
define void @alt_but_not_addsub_and_external_users(ptr %A, ptr %ptr) {
; CHECK-LABEL: @alt_but_not_addsub_and_external_users(
; CHECK-NEXT:  bb1:
; CHECK-NEXT:    [[LD:%.*]] = load double, ptr undef, align 8
; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <4 x double> poison, double [[LD]], i32 0
; CHECK-NEXT:    [[SHUFFLE:%.*]] = shufflevector <4 x double> [[TMP0]], <4 x double> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP1:%.*]] = fsub <4 x double> [[SHUFFLE]], <double 1.400000e+00, double 1.300000e+00, double 1.200000e+00, double 1.100000e+00>
; CHECK-NEXT:    [[TMP2:%.*]] = fadd <4 x double> [[SHUFFLE]], <double 1.400000e+00, double 1.300000e+00, double 1.200000e+00, double 1.100000e+00>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x double> [[TMP1]], <4 x double> [[TMP2]], <4 x i32> <i32 0, i32 5, i32 6, i32 3>
; CHECK-NEXT:    [[TMP4:%.*]] = fdiv <4 x double> [[TMP3]], <double 2.400000e+00, double 2.300000e+00, double 2.200000e+00, double 2.100000e+00>
; CHECK-NEXT:    [[TMP5:%.*]] = fmul <4 x double> [[TMP4]], <double 3.400000e+00, double 3.300000e+00, double 3.200000e+00, double 3.100000e+00>
; CHECK-NEXT:    store <4 x double> [[TMP5]], ptr [[A:%.*]], align 8
; CHECK-NEXT:    br label [[BB2:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[TMP7:%.*]] = phi <4 x double> [ [[TMP5]], [[BB1:%.*]] ], [ <double 4.400000e+00, double 4.300000e+00, double 4.200000e+00, double 4.100000e+00>, [[BB2]] ]
; CHECK-NEXT:    br label [[BB2]]
;
bb1:
  %ld = load double, ptr undef

  %sub1 = fsub double %ld, 1.1
  %add2 = fadd double %ld, 1.2
  %add3 = fadd double %ld, 1.3
  %sub4 = fsub double %ld, 1.4

  %div1 = fdiv double %sub1, 2.1
  %div2 = fdiv double %add2, 2.2
  %div3 = fdiv double %add3, 2.3
  %div4 = fdiv double %sub4, 2.4

  %mul1 = fmul double %div1, 3.1
  %mul2 = fmul double %div2, 3.2
  %mul3 = fmul double %div3, 3.3
  %mul4 = fmul double %div4, 3.4

  ; These are external vectorizable stores with operands in reverse order.
  %ptrA3 = getelementptr inbounds double, ptr %A, i64 3
  %ptrA2 = getelementptr inbounds double, ptr %A, i64 2
  %ptrA1 = getelementptr inbounds double, ptr %A, i64 1
  store double %mul4, ptr %A
  store double %mul3, ptr %ptrA1
  store double %mul2, ptr %ptrA2
  store double %mul1, ptr %ptrA3
  br label %bb2

bb2:
  %phi1 = phi double [ %mul1, %bb1 ], [ 4.1, %bb2 ]
  %phi2 = phi double [ %mul2, %bb1 ], [ 4.2, %bb2 ]
  %phi3 = phi double [ %mul3, %bb1 ], [ 4.3, %bb2 ]
  %phi4 = phi double [ %mul4, %bb1 ], [ 4.4, %bb2 ]
  br label %bb2
}
