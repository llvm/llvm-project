; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=slp-vectorizer -slp-threshold=-200 -mtriple=x86_64-unknown-linux -mcpu=core-avx2 -S | FileCheck %s

define i32 @test_commutative() {
; CHECK-LABEL: @test_commutative(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP0:%.*]] = phi <4 x i32> [ [[TMP14:%.*]], [[BB24:%.*]] ], [ <i32 poison, i32 poison, i32 0, i32 0>, [[BB:%.*]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = phi <4 x i32> [ [[TMP15:%.*]], [[BB24]] ], [ <i32 poison, i32 poison, i32 0, i32 0>, [[BB]] ]
; CHECK-NEXT:    br i1 false, label [[BB4:%.*]], label [[BB11:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    [[TMP2:%.*]] = phi <2 x double> [ zeroinitializer, [[BB1]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = phi <4 x i32> [ [[TMP0]], [[BB1]] ]
; CHECK-NEXT:    br label [[BB19:%.*]]
; CHECK:       bb11:
; CHECK-NEXT:    br i1 false, label [[BB12:%.*]], label [[BB16:%.*]]
; CHECK:       bb12:
; CHECK-NEXT:    [[TMP4:%.*]] = or <4 x i32> [[TMP1]], <i32 poison, i32 poison, i32 0, i32 0>
; CHECK-NEXT:    br label [[BB13:%.*]]
; CHECK:       bb13:
; CHECK-NEXT:    [[TMP5:%.*]] = phi <4 x i32> [ [[TMP4]], [[BB12]] ]
; CHECK-NEXT:    br label [[BB16]]
; CHECK:       bb16:
; CHECK-NEXT:    [[TMP6:%.*]] = phi <4 x i32> [ <i32 poison, i32 poison, i32 0, i32 0>, [[BB11]] ], [ [[TMP5]], [[BB13]] ]
; CHECK-NEXT:    br label [[BB19]]
; CHECK:       bb19:
; CHECK-NEXT:    [[PHI22:%.*]] = phi double [ 0.000000e+00, [[BB4]] ], [ 0.000000e+00, [[BB16]] ]
; CHECK-NEXT:    [[TMP7:%.*]] = phi <4 x i32> [ <i32 poison, i32 poison, i32 0, i32 0>, [[BB4]] ], [ [[TMP6]], [[BB16]] ]
; CHECK-NEXT:    [[TMP8:%.*]] = or <4 x i32> [[TMP7]], <i32 poison, i32 poison, i32 0, i32 0>
; CHECK-NEXT:    br label [[BB24]]
; CHECK:       bb24:
; CHECK-NEXT:    [[TMP9:%.*]] = lshr <4 x i32> [[TMP8]], <i32 poison, i32 poison, i32 0, i32 0>
; CHECK-NEXT:    [[TMP10:%.*]] = and <4 x i32> <i32 poison, i32 poison, i32 0, i32 -1>, [[TMP9]]
; CHECK-NEXT:    [[TMP11:%.*]] = shufflevector <4 x i32> [[TMP0]], <4 x i32> <i32 poison, i32 poison, i32 poison, i32 0>, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
; CHECK-NEXT:    [[TMP12:%.*]] = lshr <4 x i32> [[TMP11]], [[TMP10]]
; CHECK-NEXT:    [[TMP13:%.*]] = or <4 x i32> [[TMP11]], [[TMP10]]
; CHECK-NEXT:    [[TMP14]] = shufflevector <4 x i32> [[TMP12]], <4 x i32> [[TMP13]], <4 x i32> <i32 poison, i32 poison, i32 2, i32 7>
; CHECK-NEXT:    [[TMP15]] = shufflevector <4 x i32> [[TMP14]], <4 x i32> <i32 poison, i32 poison, i32 poison, i32 0>, <4 x i32> <i32 poison, i32 poison, i32 2, i32 7>
; CHECK-NEXT:    br label [[BB1]]
;
bb:
  br label %bb1

bb1:
  %phi = phi i32 [ %lshr25, %bb24 ], [ 0, %bb ]
  %phi2 = phi i32 [ %or26, %bb24 ], [ 0, %bb ]
  %phi3 = phi i32 [ 0, %bb24 ], [ 0, %bb ]
  br i1 false, label %bb4, label %bb11

bb4:
  %phi6 = phi i32 [ poison, %bb1 ]
  %phi7 = phi i32 [ poison, %bb1 ]
  %phi9 = phi i32 [ %phi2, %bb1 ]
  %phi10 = phi i32 [ %phi, %bb1 ]
  %0 = phi <2 x double> [ zeroinitializer, %bb1 ]
  br label %bb19

bb11:
  br i1 false, label %bb12, label %bb16

bb12:
  %or = or i32 0, %phi3
  br label %bb13

bb13:
  %phi14 = phi i32 [ %phi, %bb12 ]
  %phi15 = phi i32 [ %or, %bb12 ]
  br label %bb16

bb16:
  %phi17 = phi i32 [ 0, %bb11 ], [ %phi14, %bb13 ]
  %phi18 = phi i32 [ 0, %bb11 ], [ %phi15, %bb13 ]
  br label %bb19

bb19:
  %phi20 = phi i32 [ 0, %bb4 ], [ %phi17, %bb16 ]
  %phi21 = phi i32 [ 0, %bb4 ], [ %phi18, %bb16 ]
  %phi22 = phi double [ 0.000000e+00, %bb4 ], [ 0.000000e+00, %bb16 ]
  %or23 = or i32 %phi21, 0
  br label %bb24

bb24:
  %lshr = lshr i32 %phi20, 0
  %and = and i32 0, %lshr
  %lshr25 = lshr i32 %phi, %and
  %or26 = or i32 0, %or23
  br label %bb1
}

define void @test_add_udiv(ptr %arr1, ptr %arr2, i32 %a0, i32 %a1, i32 %a2, i32 %a3) {
; CHECK-LABEL: @test_add_udiv(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[ARR1:%.*]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i32> <i32 0, i32 0, i32 poison, i32 0>, i32 [[A2:%.*]], i32 2
; CHECK-NEXT:    [[TMP2:%.*]] = add <4 x i32> [[TMP1]], <i32 1, i32 1, i32 42, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i32> <i32 poison, i32 poison, i32 0, i32 poison>, i32 [[A0:%.*]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <4 x i32> [[TMP3]], i32 [[A1:%.*]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <4 x i32> [[TMP4]], i32 [[A3:%.*]], i32 3
; CHECK-NEXT:    [[TMP6:%.*]] = add nsw <4 x i32> <i32 1146, i32 146, i32 0, i32 0>, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = udiv <4 x i32> [[TMP0]], [[TMP2]]
; CHECK-NEXT:    [[TMP8:%.*]] = add nsw <4 x i32> [[TMP7]], [[TMP6]]
; CHECK-NEXT:    store <4 x i32> [[TMP8]], ptr [[ARR2:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep1.1 = getelementptr i32, ptr %arr1, i32 1
  %gep1.2 = getelementptr i32, ptr %arr1, i32 2
  %gep1.3 = getelementptr i32, ptr %arr1, i32 3
  %gep2.1 = getelementptr i32, ptr %arr2, i32 1
  %gep2.2 = getelementptr i32, ptr %arr2, i32 2
  %gep2.3 = getelementptr i32, ptr %arr2, i32 3
  %v0 = load i32, ptr %arr1
  %v1 = load i32, ptr %gep1.1
  %v2 = load i32, ptr %gep1.2
  %v3 = load i32, ptr %gep1.3
  %y0 = add nsw i32 %a0, 1146
  %y1 = add nsw i32 %a1, 146
  %y2 = add nsw i32 %a2, 42
  %y3 = add nsw i32 %a3, 0
  %res0 = add nsw i32 %v0, %y0
  %res1 = add nsw i32 %v1, %y1
  %res2 = udiv i32 %v2, %y2
  %res3 = add nsw i32 %v3, %y3
  store i32 %res0, ptr %arr2
  store i32 %res1, ptr %gep2.1
  store i32 %res2, ptr %gep2.2
  store i32 %res3, ptr %gep2.3
  ret void
}

define void @test_add_udiv_commuted(ptr %arr1, ptr %arr2, i32 %a0, i32 %a1, i32 %a2, i32 %a3) {
; CHECK-LABEL: @test_add_udiv_commuted(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP1_2:%.*]] = getelementptr i32, ptr [[ARR1:%.*]], i32 2
; CHECK-NEXT:    [[GEP1_3:%.*]] = getelementptr i32, ptr [[ARR1]], i32 3
; CHECK-NEXT:    [[V2:%.*]] = load i32, ptr [[GEP1_2]], align 4
; CHECK-NEXT:    [[V3:%.*]] = load i32, ptr [[GEP1_3]], align 4
; CHECK-NEXT:    [[Y2:%.*]] = add nsw i32 [[A2:%.*]], 42
; CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i32>, ptr [[ARR1]], align 4
; CHECK-NEXT:    [[RES2:%.*]] = udiv i32 [[V2]], [[Y2]]
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i32> poison, i32 [[A0:%.*]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <4 x i32> [[TMP1]], i32 [[A1:%.*]], i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i32> [[TMP2]], i32 [[A3:%.*]], i32 3
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <4 x i32> [[TMP3]], i32 [[RES2]], i32 2
; CHECK-NEXT:    [[TMP5:%.*]] = add nsw <4 x i32> [[TMP4]], <i32 1146, i32 146, i32 0, i32 0>
; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <4 x i32> <i32 poison, i32 poison, i32 0, i32 poison>, i32 [[V3]], i32 3
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <2 x i32> [[TMP0]], <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i32> [[TMP6]], <4 x i32> [[TMP7]], <4 x i32> <i32 4, i32 5, i32 2, i32 3>
; CHECK-NEXT:    [[TMP9:%.*]] = add nsw <4 x i32> [[TMP5]], [[TMP8]]
; CHECK-NEXT:    store <4 x i32> [[TMP9]], ptr [[ARR2:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep1.1 = getelementptr i32, ptr %arr1, i32 1
  %gep1.2 = getelementptr i32, ptr %arr1, i32 2
  %gep1.3 = getelementptr i32, ptr %arr1, i32 3
  %gep2.1 = getelementptr i32, ptr %arr2, i32 1
  %gep2.2 = getelementptr i32, ptr %arr2, i32 2
  %gep2.3 = getelementptr i32, ptr %arr2, i32 3
  %v0 = load i32, ptr %arr1
  %v1 = load i32, ptr %gep1.1
  %v2 = load i32, ptr %gep1.2
  %v3 = load i32, ptr %gep1.3
  %y0 = add nsw i32 %a0, 1146
  %y1 = add nsw i32 %a1, 146
  %y2 = add nsw i32 %a2, 42
  %y3 = add nsw i32 %a3, 0
  %res0 = add nsw i32 %y0, %v0
  %res1 = add nsw i32 %y1, %v1
  %res2 = udiv i32 %v2, %y2
  %res3 = add nsw i32 %y3, %v3
  store i32 %res0, ptr %arr2
  store i32 %res1, ptr %gep2.1
  store i32 %res2, ptr %gep2.2
  store i32 %res3, ptr %gep2.3
  ret void
}

define void @test_add_mul(ptr %arr1, ptr %arr2, i32 %a0, i32 %a1, i32 %a2, i32 %a3) {
; CHECK-LABEL: @test_add_mul(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i32> poison, i32 [[A0:%.*]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <4 x i32> [[TMP1]], i32 [[A1:%.*]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <4 x i32> [[TMP2]], i32 [[A2:%.*]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i32> [[TMP5]], i32 [[A3:%.*]], i32 3
; CHECK-NEXT:    [[TMP4:%.*]] = add <4 x i32> [[TMP3]], <i32 1146, i32 146, i32 42, i32 0>
; CHECK-NEXT:    [[TMP6:%.*]] = load <4 x i32>, ptr [[ARR1:%.*]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = add nsw <4 x i32> [[TMP6]], [[TMP4]]
; CHECK-NEXT:    [[TMP9:%.*]] = mul <4 x i32> [[TMP6]], [[TMP4]]
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i32> [[TMP7]], <4 x i32> [[TMP9]], <4 x i32> <i32 0, i32 1, i32 6, i32 3>
; CHECK-NEXT:    store <4 x i32> [[TMP8]], ptr [[ARR2:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep1.1 = getelementptr i32, ptr %arr1, i32 1
  %gep1.2 = getelementptr i32, ptr %arr1, i32 2
  %gep1.3 = getelementptr i32, ptr %arr1, i32 3
  %gep2.1 = getelementptr i32, ptr %arr2, i32 1
  %gep2.2 = getelementptr i32, ptr %arr2, i32 2
  %gep2.3 = getelementptr i32, ptr %arr2, i32 3
  %v0 = load i32, ptr %arr1
  %v1 = load i32, ptr %gep1.1
  %v2 = load i32, ptr %gep1.2
  %v3 = load i32, ptr %gep1.3
  %y0 = add nsw i32 %a0, 1146
  %y1 = add nsw i32 %a1, 146
  %y2 = add i32 %a2, 42
  %y3 = add nsw i32 %a3, 0
  %res0 = add nsw i32 %v0, %y0
  %res1 = add nsw i32 %v1, %y1
  %res2 = mul i32 %v2, %y2
  %res3 = add nsw i32 %v3, %y3
  store i32 %res0, ptr %arr2
  store i32 %res1, ptr %gep2.1
  store i32 %res2, ptr %gep2.2
  store i32 %res3, ptr %gep2.3
  ret void
}

define void @test_add_mul_commuted(ptr %arr1, ptr %arr2, i32 %a0, i32 %a1, i32 %a2, i32 %a3) {
; CHECK-LABEL: @test_add_mul_commuted(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i32> poison, i32 [[A0:%.*]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <4 x i32> [[TMP1]], i32 [[A1:%.*]], i32 1
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <4 x i32> [[TMP2]], i32 [[A2:%.*]], i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i32> [[TMP4]], i32 [[A3:%.*]], i32 3
; CHECK-NEXT:    [[TMP8:%.*]] = add <4 x i32> <i32 1146, i32 146, i32 42, i32 0>, [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = load <4 x i32>, ptr [[ARR1:%.*]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = add nsw <4 x i32> [[TMP5]], [[TMP8]]
; CHECK-NEXT:    [[TMP7:%.*]] = mul <4 x i32> [[TMP5]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = shufflevector <4 x i32> [[TMP9]], <4 x i32> [[TMP7]], <4 x i32> <i32 0, i32 1, i32 6, i32 3>
; CHECK-NEXT:    store <4 x i32> [[TMP10]], ptr [[ARR2:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep1.1 = getelementptr i32, ptr %arr1, i32 1
  %gep1.2 = getelementptr i32, ptr %arr1, i32 2
  %gep1.3 = getelementptr i32, ptr %arr1, i32 3
  %gep2.1 = getelementptr i32, ptr %arr2, i32 1
  %gep2.2 = getelementptr i32, ptr %arr2, i32 2
  %gep2.3 = getelementptr i32, ptr %arr2, i32 3
  %v0 = load i32, ptr %arr1
  %v1 = load i32, ptr %gep1.1
  %v2 = load i32, ptr %gep1.2
  %v3 = load i32, ptr %gep1.3
  %y0 = add nsw i32 %a0, 1146
  %y1 = add nsw i32 %a1, 146
  %y2 = add i32 42, %a2
  %y3 = add nsw i32 %a3, 0
  %res0 = add nsw i32 %y0, %v0
  %res1 = add nsw i32 %y1, %v1
  %res2 = mul i32 %v2, %y2
  %res3 = add nsw i32 %y3, %v3
  store i32 %res0, ptr %arr2
  store i32 %res1, ptr %gep2.1
  store i32 %res2, ptr %gep2.2
  store i32 %res3, ptr %gep2.3
  ret void
}

define void @test_add_udiv_sub(ptr %arr1, ptr %arr2, i32 %a0, i32 %a1, i32 %a2, i32 %a3) {
; CHECK-LABEL: @test_add_udiv_sub(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[ARR1:%.*]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i32> <i32 1, i32 1, i32 poison, i32 1>, i32 [[A2:%.*]], i32 2
; CHECK-NEXT:    [[TMP2:%.*]] = sub <4 x i32> [[TMP1]], <i32 0, i32 0, i32 42, i32 0>
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i32> <i32 poison, i32 poison, i32 0, i32 poison>, i32 [[A0:%.*]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <4 x i32> [[TMP3]], i32 [[A1:%.*]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <4 x i32> [[TMP4]], i32 [[A3:%.*]], i32 3
; CHECK-NEXT:    [[TMP6:%.*]] = add nsw <4 x i32> <i32 1146, i32 146, i32 0, i32 0>, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = udiv <4 x i32> [[TMP0]], [[TMP2]]
; CHECK-NEXT:    [[TMP8:%.*]] = add nsw <4 x i32> [[TMP7]], [[TMP6]]
; CHECK-NEXT:    store <4 x i32> [[TMP8]], ptr [[ARR2:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep1.1 = getelementptr i32, ptr %arr1, i32 1
  %gep1.2 = getelementptr i32, ptr %arr1, i32 2
  %gep1.3 = getelementptr i32, ptr %arr1, i32 3
  %gep2.1 = getelementptr i32, ptr %arr2, i32 1
  %gep2.2 = getelementptr i32, ptr %arr2, i32 2
  %gep2.3 = getelementptr i32, ptr %arr2, i32 3
  %v0 = load i32, ptr %arr1
  %v1 = load i32, ptr %gep1.1
  %v2 = load i32, ptr %gep1.2
  %v3 = load i32, ptr %gep1.3
  %y0 = add nsw i32 %a0, 1146
  %y1 = add nsw i32 %a1, 146
  %y2 = sub i32 %a2, 42
  %y3 = add nsw i32 %a3, 0
  %res0 = add nsw i32 %v0, %y0
  %res1 = add nsw i32 %v1, %y1
  %res2 = udiv i32 %v2, %y2
  %res3 = add nsw i32 %v3, %y3
  store i32 %res0, ptr %arr2
  store i32 %res1, ptr %gep2.1
  store i32 %res2, ptr %gep2.2
  store i32 %res3, ptr %gep2.3
  ret void
}

define void @test_add_udiv_sub_commuted(ptr %arr1, ptr %arr2, i32 %a0, i32 %a1, i32 %a2, i32 %a3) {
; CHECK-LABEL: @test_add_udiv_sub_commuted(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP1_2:%.*]] = getelementptr i32, ptr [[ARR1:%.*]], i32 2
; CHECK-NEXT:    [[GEP1_3:%.*]] = getelementptr i32, ptr [[ARR1]], i32 3
; CHECK-NEXT:    [[V2:%.*]] = load i32, ptr [[GEP1_2]], align 4
; CHECK-NEXT:    [[V3:%.*]] = load i32, ptr [[GEP1_3]], align 4
; CHECK-NEXT:    [[Y2:%.*]] = sub i32 [[A2:%.*]], 42
; CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i32>, ptr [[ARR1]], align 4
; CHECK-NEXT:    [[RES2:%.*]] = udiv i32 [[V2]], [[Y2]]
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i32> poison, i32 [[A0:%.*]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <4 x i32> [[TMP1]], i32 [[A1:%.*]], i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i32> [[TMP2]], i32 [[A3:%.*]], i32 3
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <4 x i32> [[TMP3]], i32 [[RES2]], i32 2
; CHECK-NEXT:    [[TMP5:%.*]] = add nsw <4 x i32> [[TMP4]], <i32 1146, i32 146, i32 0, i32 0>
; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <4 x i32> <i32 poison, i32 poison, i32 0, i32 poison>, i32 [[V3]], i32 3
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <2 x i32> [[TMP0]], <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i32> [[TMP6]], <4 x i32> [[TMP7]], <4 x i32> <i32 4, i32 5, i32 2, i32 3>
; CHECK-NEXT:    [[TMP9:%.*]] = add nsw <4 x i32> [[TMP5]], [[TMP8]]
; CHECK-NEXT:    store <4 x i32> [[TMP9]], ptr [[ARR2:%.*]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep1.1 = getelementptr i32, ptr %arr1, i32 1
  %gep1.2 = getelementptr i32, ptr %arr1, i32 2
  %gep1.3 = getelementptr i32, ptr %arr1, i32 3
  %gep2.1 = getelementptr i32, ptr %arr2, i32 1
  %gep2.2 = getelementptr i32, ptr %arr2, i32 2
  %gep2.3 = getelementptr i32, ptr %arr2, i32 3
  %v0 = load i32, ptr %arr1
  %v1 = load i32, ptr %gep1.1
  %v2 = load i32, ptr %gep1.2
  %v3 = load i32, ptr %gep1.3
  %y0 = add nsw i32 %a0, 1146
  %y1 = add nsw i32 %a1, 146
  %y2 = sub i32 %a2, 42
  %y3 = add nsw i32 %a3, 0
  %res0 = add nsw i32 %y0, %v0
  %res1 = add nsw i32 %y1, %v1
  %res2 = udiv i32 %v2, %y2
  %res3 = add nsw i32 %y3, %v3
  store i32 %res0, ptr %arr2
  store i32 %res1, ptr %gep2.1
  store i32 %res2, ptr %gep2.2
  store i32 %res3, ptr %gep2.3
  ret void
}
