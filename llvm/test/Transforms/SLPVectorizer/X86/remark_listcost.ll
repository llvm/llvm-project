; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -mtriple=x86_64-pc-linux-gnu -mcpu=generic -passes=slp-vectorizer -pass-remarks-output=%t < %s | FileCheck %s
; RUN: FileCheck --input-file=%t --check-prefix=YAML %s

define void @vsub2_test(ptr %pin1, ptr %pin2, ptr %pout) #0 {
; CHECK-LABEL: define void @vsub2_test(
; CHECK-SAME: ptr [[PIN1:%.*]], ptr [[PIN2:%.*]], ptr [[POUT:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    br label %[[TMP1:.*]]
; CHECK:       [[TMP1]]:
; CHECK-NEXT:    [[IDX_04:%.*]] = phi i32 [ 0, [[TMP0:%.*]] ], [ [[TMP8:%.*]], %[[TMP1]] ]
; CHECK-NEXT:    [[PO_03:%.*]] = phi ptr [ [[POUT]], [[TMP0]] ], [ [[TMP7:%.*]], %[[TMP1]] ]
; CHECK-NEXT:    [[PTMPI2_02:%.*]] = phi ptr [ [[PIN2]], [[TMP0]] ], [ [[TMP4:%.*]], %[[TMP1]] ]
; CHECK-NEXT:    [[PTMPI1_01:%.*]] = phi ptr [ [[PIN1]], [[TMP0]] ], [ [[TMP2:%.*]], %[[TMP1]] ]
; CHECK-NEXT:    [[TMP2]] = getelementptr inbounds i32, ptr [[PTMPI1_01]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[PTMPI1_01]], align 4, !tbaa [[INT_TBAA1:![0-9]+]]
; CHECK-NEXT:    [[TMP4]] = getelementptr inbounds i32, ptr [[PTMPI2_02]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[PTMPI2_02]], align 4, !tbaa [[INT_TBAA1]]
; CHECK-NEXT:    [[TMP6:%.*]] = sub nsw i32 [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[TMP7]] = getelementptr inbounds i32, ptr [[PO_03]], i64 1
; CHECK-NEXT:    store i32 [[TMP6]], ptr [[PO_03]], align 4, !tbaa [[INT_TBAA1]]
; CHECK-NEXT:    [[TMP8]] = add nuw nsw i32 [[IDX_04]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[TMP8]], 64
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[BB9:.*]], label %[[TMP1]], !llvm.loop [[LOOP5:![0-9]+]]
; CHECK:       [[BB9]]:
; CHECK-NEXT:    ret void
;
  br label %1

  %idx.04 = phi i32 [ 0, %0 ], [ %8, %1 ]
  %po.03 = phi ptr [ %pout, %0 ], [ %7, %1 ]
  %ptmpi2.02 = phi ptr [ %pin2, %0 ], [ %4, %1 ]
  %ptmpi1.01 = phi ptr [ %pin1, %0 ], [ %2, %1 ]
  %2 = getelementptr inbounds i32, ptr %ptmpi1.01, i64 1
  %3 = load i32, ptr %ptmpi1.01, align 4, !tbaa !1
  %4 = getelementptr inbounds i32, ptr %ptmpi2.02, i64 1
  %5 = load i32, ptr %ptmpi2.02, align 4, !tbaa !1
  %6 = sub nsw i32 %3, %5
  %7 = getelementptr inbounds i32, ptr %po.03, i64 1
  ; YAML:      Pass:            slp-vectorizer
  ; YAML-NEXT: Name:            NotBeneficial
  ; YAML-NEXT: Function:        vsub2_test
  ; YAML-NEXT: Args:
  ; YAML-NEXT:   - String:          'List vectorization was possible but not beneficial with cost '
  ; YAML-NEXT:   - Cost:            '0'
  ; YAML-NEXT:   - String:          ' >= '
  ; YAML-NEXT:   - Treshold:        '0'
  store i32 %6, ptr %po.03, align 4, !tbaa !1
  %8 = add nuw nsw i32 %idx.04, 1
  %exitcond = icmp eq i32 %8, 64
  br i1 %exitcond, label %9, label %1, !llvm.loop !5

  ret void
}

!llvm.ident = !{!0}

!0 = !{!"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = distinct !{!5, !6, !7}
!6 = !{!"llvm.loop.vectorize.width", i32 1}
!7 = !{!"llvm.loop.interleave.count", i32 1}
;.
; CHECK: [[INT_TBAA1]] = !{[[META2:![0-9]+]], [[META2]], i64 0}
; CHECK: [[META2]] = !{!"int", [[META3:![0-9]+]], i64 0}
; CHECK: [[META3]] = !{!"omnipotent char", [[META4:![0-9]+]], i64 0}
; CHECK: [[META4]] = !{!"Simple C/C++ TBAA"}
; CHECK: [[LOOP5]] = distinct !{[[LOOP5]], [[META6:![0-9]+]], [[META7:![0-9]+]]}
; CHECK: [[META6]] = !{!"llvm.loop.vectorize.width", i32 1}
; CHECK: [[META7]] = !{!"llvm.loop.interleave.count", i32 1}
;.
