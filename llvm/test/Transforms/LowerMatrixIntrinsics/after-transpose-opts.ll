; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; REQUIRES: aarch64-registered-target

; RUN: opt -passes='lower-matrix-intrinsics' -matrix-print-after-transpose-opt -disable-output %s 2>&1 | FileCheck %s

target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "aarch64-apple-ios"

; k * A^T
define void @kat(<9 x double>* %Aptr, double %k, <9 x double>* %C) {
; CHECK-LABEL: @kat(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load <9 x double>, <9 x double>* [[APTR:%.*]], align 128
; CHECK-NEXT:    [[VECK:%.*]] = insertelement <9 x double> poison, double [[K:%.*]], i64 0
; CHECK-NEXT:    [[SPLAT:%.*]] = shufflevector <9 x double> [[VECK]], <9 x double> poison, <9 x i32> zeroinitializer
; CHECK-NEXT:    [[AT:%.*]] = call <9 x double> @llvm.matrix.transpose.v9f64(<9 x double> [[A]], i32 3, i32 3)
; CHECK-NEXT:    [[MUL:%.*]] = call <9 x double> @llvm.matrix.multiply.v9f64.v9f64.v9f64(<9 x double> [[SPLAT]], <9 x double> [[AT]], i32 3, i32 3, i32 3)
; CHECK-NEXT:    store <9 x double> [[MUL]], <9 x double>* [[C:%.*]], align 128
; CHECK-NEXT:    ret void
;
entry:
  %a = load <9 x double>, <9 x double>* %Aptr
  %veck = insertelement <9 x double> poison, double %k, i64 0
  %splat = shufflevector <9 x double> %veck, <9 x double> poison, <9 x i32> zeroinitializer
  %at = call <9 x double> @llvm.matrix.transpose.v9f64.v9f64(<9 x double> %a, i32 3, i32 3)
  %mul = call <9 x double> @llvm.matrix.multiply.v9f64.v9f64.v9f64(<9 x double> %splat, <9 x double> %at, i32 3, i32 3, i32 3)
  store <9 x double> %mul, <9 x double>* %C
  ret void
}

; (k * A)^T -> A^T * k
define void @ka_t(<9 x double>* %Aptr, double %k, <9 x double>* %C) {
; CHECK-LABEL: @ka_t(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load <9 x double>, <9 x double>* [[APTR:%.*]], align 128
; CHECK-NEXT:    [[VECK:%.*]] = insertelement <9 x double> poison, double [[K:%.*]], i64 0
; CHECK-NEXT:    [[SPLAT:%.*]] = shufflevector <9 x double> [[VECK]], <9 x double> poison, <9 x i32> zeroinitializer
; CHECK-NEXT:    [[A_T:%.*]] = call <9 x double> @llvm.matrix.transpose.v9f64(<9 x double> [[A]], i32 3, i32 3)
; CHECK-NEXT:    [[MMUL:%.*]] = call <9 x double> @llvm.matrix.multiply.v9f64.v9f64.v9f64(<9 x double> [[A_T]], <9 x double> [[SPLAT]], i32 3, i32 3, i32 3)
; CHECK-NEXT:    store <9 x double> [[MMUL]], <9 x double>* [[C:%.*]], align 128
; CHECK-NEXT:    ret void
;
entry:
  %a = load <9 x double>, <9 x double>* %Aptr
  %veck = insertelement <9 x double> poison, double %k, i64 0
  %splat = shufflevector <9 x double> %veck, <9 x double> poison, <9 x i32> zeroinitializer
  %mul = call <9 x double> @llvm.matrix.multiply.v9f64.v9f64.v9f64(<9 x double> %splat, <9 x double> %a, i32 3, i32 3, i32 3)
  %t = call <9 x double> @llvm.matrix.transpose.v9f64.v9f64(<9 x double> %mul, i32 3, i32 3)
  store <9 x double> %t, <9 x double>* %C
  ret void
}

; (k * A)^T -> A^T * k with fmul
define void @ka_t_fmul(<9 x double>* %Aptr, double %k, <9 x double>* %C) {
; CHECK-LABEL: @ka_t_fmul(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load <9 x double>, <9 x double>* [[APTR:%.*]], align 128
; CHECK-NEXT:    [[VECK:%.*]] = insertelement <9 x double> poison, double [[K:%.*]], i64 0
; CHECK-NEXT:    [[SPLAT:%.*]] = shufflevector <9 x double> [[VECK]], <9 x double> poison, <9 x i32> zeroinitializer
; CHECK-NEXT:    [[A_T:%.*]] = call <9 x double> @llvm.matrix.transpose.v9f64(<9 x double> [[A]], i32 3, i32 3)
; CHECK-NEXT:    [[MMUL:%.*]] = fmul <9 x double> [[SPLAT]], [[A_T]]
; CHECK-NEXT:    store <9 x double> [[MMUL]], <9 x double>* [[C:%.*]], align 128
; CHECK-NEXT:    ret void
;
entry:
  %a = load <9 x double>, <9 x double>* %Aptr
  %veck = insertelement <9 x double> poison, double %k, i64 0
  %splat = shufflevector <9 x double> %veck, <9 x double> poison, <9 x i32> zeroinitializer
  %mul = fmul <9 x double> %splat, %a
  %t = call <9 x double> @llvm.matrix.transpose.v9f64.v9f64(<9 x double> %mul, i32 3, i32 3)
  store <9 x double> %t, <9 x double>* %C
  ret void
}

; (k * A)^T -> A^T * k with mul (non-fp types)
define void @ka_t_mul(<9 x i32>* %Aptr, i32 %k, <9 x i32>* %C) {
; CHECK-LABEL: @ka_t_mul(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load <9 x i32>, <9 x i32>* [[APTR:%.*]], align 64
; CHECK-NEXT:    [[VECK:%.*]] = insertelement <9 x i32> poison, i32 [[K:%.*]], i64 0
; CHECK-NEXT:    [[SPLAT:%.*]] = shufflevector <9 x i32> [[VECK]], <9 x i32> poison, <9 x i32> zeroinitializer
; CHECK-NEXT:    [[A_T:%.*]] = call <9 x i32> @llvm.matrix.transpose.v9i32(<9 x i32> [[A]], i32 3, i32 3)
; CHECK-NEXT:    [[MMUL:%.*]] = mul <9 x i32> [[SPLAT]], [[A_T]]
; CHECK-NEXT:    store <9 x i32> [[MMUL]], <9 x i32>* [[C:%.*]], align 64
; CHECK-NEXT:    ret void
;
entry:
  %a = load <9 x i32>, <9 x i32>* %Aptr
  %veck = insertelement <9 x i32> poison, i32 %k, i64 0
  %splat = shufflevector <9 x i32> %veck, <9 x i32> poison, <9 x i32> zeroinitializer
  %mul = mul <9 x i32> %splat, %a
  %t = call <9 x i32> @llvm.matrix.transpose.v9i32.v9i32(<9 x i32> %mul, i32 3, i32 3)
  store <9 x i32> %t, <9 x i32>* %C
  ret void
}

declare <9 x double> @llvm.matrix.multiply.v9f64.v9f64.v9f64(<9 x double>, <9 x double>, i32, i32, i32)
declare <9 x double> @llvm.matrix.transpose.v9f64.v9f64(<9 x double>, i32, i32)
declare <9 x i32> @llvm.matrix.transpose.v9i32.v9i32(<9 x i32>, i32, i32)
