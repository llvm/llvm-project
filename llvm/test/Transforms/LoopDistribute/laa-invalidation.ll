; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes='loop-load-elim,indvars,loop-distribute' -enable-loop-distribute -S %s | FileCheck %s

define void @test_pr50940(ptr %A, ptr %B) {
; CHECK-LABEL: @test_pr50940(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[OUTER_HEADER:%.*]]
; CHECK:       outer.header:
; CHECK-NEXT:    br i1 false, label [[OUTER_LATCH:%.*]], label [[INNER_PH:%.*]]
; CHECK:       inner.ph:
; CHECK-NEXT:    [[UGLYGEP:%.*]] = getelementptr i8, ptr [[A:%.*]], i64 4
; CHECK-NEXT:    [[GEP_A_3:%.*]] = getelementptr inbounds i16, ptr [[A]], i64 3
; CHECK-NEXT:    br label [[INNER_LVER_CHECK:%.*]]
; CHECK:       inner.lver.check:
; CHECK-NEXT:    [[UGLYGEP1:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[UGLYGEP2:%.*]] = getelementptr i8, ptr [[B:%.*]], i64 2
; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ult ptr [[UGLYGEP]], [[UGLYGEP2]]
; CHECK-NEXT:    [[BOUND1:%.*]] = icmp ult ptr [[B]], [[UGLYGEP1]]
; CHECK-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]
; CHECK-NEXT:    br i1 [[FOUND_CONFLICT]], label [[INNER_PH3_LVER_ORIG:%.*]], label [[INNER_PH3_LDIST1:%.*]]
; CHECK:       inner.ph3.lver.orig:
; CHECK-NEXT:    br label [[INNER_LVER_ORIG:%.*]]
; CHECK:       inner.lver.orig:
; CHECK-NEXT:    [[IV_LVER_ORIG:%.*]] = phi i16 [ 0, [[INNER_PH3_LVER_ORIG]] ], [ [[IV_NEXT_LVER_ORIG:%.*]], [[INNER_LVER_ORIG]] ]
; CHECK-NEXT:    [[L_LVER_ORIG:%.*]] = load <2 x i16>, ptr [[UGLYGEP]], align 1
; CHECK-NEXT:    store i16 0, ptr [[GEP_A_3]], align 1
; CHECK-NEXT:    store i16 1, ptr [[B]], align 1
; CHECK-NEXT:    [[IV_NEXT_LVER_ORIG]] = add nuw nsw i16 [[IV_LVER_ORIG]], 1
; CHECK-NEXT:    [[C_1_LVER_ORIG:%.*]] = icmp ult i16 [[IV_LVER_ORIG]], 38
; CHECK-NEXT:    br i1 [[C_1_LVER_ORIG]], label [[INNER_LVER_ORIG]], label [[EXIT_LOOPEXIT:%.*]]
; CHECK:       inner.ph3.ldist1:
; CHECK-NEXT:    br label [[INNER_LDIST1:%.*]]
; CHECK:       inner.ldist1:
; CHECK-NEXT:    [[IV_LDIST1:%.*]] = phi i16 [ 0, [[INNER_PH3_LDIST1]] ], [ [[IV_NEXT_LDIST1:%.*]], [[INNER_LDIST1]] ]
; CHECK-NEXT:    [[L_LDIST1:%.*]] = load <2 x i16>, ptr [[UGLYGEP]], align 1, !alias.scope !0, !noalias !3
; CHECK-NEXT:    store i16 0, ptr [[GEP_A_3]], align 1, !alias.scope !0, !noalias !3
; CHECK-NEXT:    [[IV_NEXT_LDIST1]] = add nuw nsw i16 [[IV_LDIST1]], 1
; CHECK-NEXT:    [[C_1_LDIST1:%.*]] = icmp ult i16 [[IV_LDIST1]], 38
; CHECK-NEXT:    br i1 [[C_1_LDIST1]], label [[INNER_LDIST1]], label [[INNER_PH3:%.*]]
; CHECK:       inner.ph3:
; CHECK-NEXT:    br label [[INNER:%.*]]
; CHECK:       inner:
; CHECK-NEXT:    [[IV:%.*]] = phi i16 [ 0, [[INNER_PH3]] ], [ [[IV_NEXT:%.*]], [[INNER]] ]
; CHECK-NEXT:    store i16 1, ptr [[B]], align 1, !alias.scope !3
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i16 [[IV]], 1
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult i16 [[IV]], 38
; CHECK-NEXT:    br i1 [[C_1]], label [[INNER]], label [[EXIT_LOOPEXIT4:%.*]]
; CHECK:       outer.latch:
; CHECK-NEXT:    br label [[OUTER_HEADER]]
; CHECK:       exit.loopexit:
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       exit.loopexit4:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %gep.A.1 = getelementptr inbounds i16, ptr %A, i64 1
  br label %outer.header

outer.header:
  %gep.A.2 = getelementptr inbounds i16, ptr %gep.A.1, i64 1
  br i1 false, label %outer.latch, label %inner.ph

inner.ph:                             ; preds = %for.body5
  %lcssa.gep = phi ptr [ %gep.A.2, %outer.header ]
  %gep.A.3 = getelementptr inbounds i16, ptr %A, i64 3
  br label %inner

inner:
  %iv = phi i16 [ 0, %inner.ph ], [ %iv.next, %inner ]
  %l = load <2 x i16>, ptr %lcssa.gep, align 1
  store i16 0, ptr %gep.A.3, align 1
  store i16 1, ptr %B, align 1
  %iv.next = add nuw nsw i16 %iv, 1
  %c.1 = icmp ult i16 %iv, 38
  br i1 %c.1, label %inner, label %exit

outer.latch:
  br label %outer.header

exit:
  ret void
}
