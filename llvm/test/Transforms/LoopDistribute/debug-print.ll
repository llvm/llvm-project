; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; REQUIRES: asserts
; RUN: opt -passes=loop-distribute -enable-loop-distribute \
; RUN:   -debug-only=loop-distribute -disable-output 2>&1 %s | FileCheck %s

define void @f(ptr noalias %a, ptr noalias %b, ptr noalias %c, ptr noalias %d, i64 %stride) {
; CHECK-LABEL: 'f'
; CHECK-NEXT:  LDist: Found a candidate loop: for.body
; CHECK-NEXT:  LDist: Backward dependences:
; CHECK-NEXT:    Backward:
; CHECK-NEXT:        %load.a = load i32, ptr %gep.a, align 4 ->
; CHECK-NEXT:        store i32 %mul.a, ptr %gep.a.plus4, align 4
; CHECK-NEXT:  LDist: Seeded partitions:
; CHECK-NEXT:  LDist: Partition 0: (cycle)
; CHECK-NEXT:    for.body: %load.a = load i32, ptr %gep.a, align 4
; CHECK-NEXT:    for.body: %load.b = load i32, ptr %gep.b, align 4
; CHECK-NEXT:    for.body: store i32 %mul.a, ptr %gep.a.plus4, align 4
; CHECK-NEXT:  LDist: Partition 1:
; CHECK-NEXT:    for.body: %loadD = load i32, ptr %gep.d, align 4
; CHECK-NEXT:  LDist: Partition 2:
; CHECK-NEXT:    for.body: %load.strided.a = load i32, ptr %gep.strided.a, align 4
; CHECK-NEXT:  LDist: Partition 3:
; CHECK-NEXT:    for.body: store i32 %mul.c, ptr %gep.c, align 4
; CHECK-NEXT:  LDist: Merged partitions:
; CHECK-NEXT:  LDist: Partition 0: (cycle)
; CHECK-NEXT:    for.body: %load.a = load i32, ptr %gep.a, align 4
; CHECK-NEXT:    for.body: %load.b = load i32, ptr %gep.b, align 4
; CHECK-NEXT:    for.body: store i32 %mul.a, ptr %gep.a.plus4, align 4
; CHECK-NEXT:  LDist: Partition 1:
; CHECK-NEXT:    for.body: %loadD = load i32, ptr %gep.d, align 4
; CHECK-NEXT:    for.body: %load.strided.a = load i32, ptr %gep.strided.a, align 4
; CHECK-NEXT:    for.body: store i32 %mul.c, ptr %gep.c, align 4
; CHECK-NEXT:  LDist: Populated partitions:
; CHECK-NEXT:  LDist: Partition 0: (cycle)
; CHECK-NEXT:    for.body: %load.a = load i32, ptr %gep.a, align 4
; CHECK-NEXT:    for.body: %load.b = load i32, ptr %gep.b, align 4
; CHECK-NEXT:    for.body: store i32 %mul.a, ptr %gep.a.plus4, align 4
; CHECK-NEXT:    for.body: br i1 %exitcond, label %exit, label %for.body
; CHECK-NEXT:    for.body: %exitcond = icmp eq i64 %add, 20
; CHECK-NEXT:    for.body: %add = add nuw nsw i64 %ind, 1
; CHECK-NEXT:    for.body: %ind = phi i64 [ 0, %entry ], [ %add, %for.body ]
; CHECK-NEXT:    for.body: %mul.a = mul i32 %load.b, %load.a
; CHECK-NEXT:    for.body: %gep.a.plus4 = getelementptr inbounds i32, ptr %a, i64 %add
; CHECK-NEXT:    for.body: %gep.b = getelementptr inbounds i32, ptr %b, i64 %ind
; CHECK-NEXT:    for.body: %gep.a = getelementptr inbounds i32, ptr %a, i64 %ind
; CHECK-NEXT:  LDist: Partition 1:
; CHECK-NEXT:    for.body: %loadD = load i32, ptr %gep.d, align 4
; CHECK-NEXT:    for.body: %load.strided.a = load i32, ptr %gep.strided.a, align 4
; CHECK-NEXT:    for.body: store i32 %mul.c, ptr %gep.c, align 4
; CHECK-NEXT:    for.body: br i1 %exitcond, label %exit, label %for.body
; CHECK-NEXT:    for.body: %exitcond = icmp eq i64 %add, 20
; CHECK-NEXT:    for.body: %add = add nuw nsw i64 %ind, 1
; CHECK-NEXT:    for.body: %ind = phi i64 [ 0, %entry ], [ %add, %for.body ]
; CHECK-NEXT:    for.body: %mul.c = mul i32 %loadD, %load.strided.a
; CHECK-NEXT:    for.body: %gep.c = getelementptr inbounds i32, ptr %c, i64 %ind
; CHECK-NEXT:    for.body: %gep.strided.a = getelementptr inbounds i32, ptr %a, i64 %mul
; CHECK-NEXT:    for.body: %mul = mul i64 %ind, %stride
; CHECK-NEXT:    for.body: %gep.d = getelementptr inbounds i32, ptr %d, i64 %ind
; CHECK-NEXT:  LDist: Distributing loop: for.body
; CHECK-NEXT:  LDist: Pointers:
; CHECK-NEXT:  LDist: After removing unused Instrs:
; CHECK-NEXT:  LDist: Partition 0:
; CHECK-NEXT:  for.body.ldist1: ; preds = %for.body.ldist1, %for.body.ph.ldist1
; CHECK-NEXT:    %ind.ldist1 = phi i64 [ 0, %for.body.ph.ldist1 ], [ %add.ldist1, %for.body.ldist1 ]
; CHECK-NEXT:    %gep.a.ldist1 = getelementptr inbounds i32, ptr %a, i64 %ind.ldist1
; CHECK-NEXT:    %load.a.ldist1 = load i32, ptr %gep.a.ldist1, align 4
; CHECK-NEXT:    %gep.b.ldist1 = getelementptr inbounds i32, ptr %b, i64 %ind.ldist1
; CHECK-NEXT:    %load.b.ldist1 = load i32, ptr %gep.b.ldist1, align 4
; CHECK-NEXT:    %mul.a.ldist1 = mul i32 %load.b.ldist1, %load.a.ldist1
; CHECK-NEXT:    %add.ldist1 = add nuw nsw i64 %ind.ldist1, 1
; CHECK-NEXT:    %gep.a.plus4.ldist1 = getelementptr inbounds i32, ptr %a, i64 %add.ldist1
; CHECK-NEXT:    store i32 %mul.a.ldist1, ptr %gep.a.plus4.ldist1, align 4
; CHECK-NEXT:    %exitcond.ldist1 = icmp eq i64 %add.ldist1, 20
; CHECK-NEXT:    br i1 %exitcond.ldist1, label %for.body.ph, label %for.body.ldist1
; CHECK-NEXT:  LDist: Partition 1:
; CHECK-NEXT:  for.body: ; preds = %for.body, %for.body.ph
; CHECK-NEXT:    %ind = phi i64 [ 0, %for.body.ph ], [ %add, %for.body ]
; CHECK-NEXT:    %add = add nuw nsw i64 %ind, 1
; CHECK-NEXT:    %gep.d = getelementptr inbounds i32, ptr %d, i64 %ind
; CHECK-NEXT:    %loadD = load i32, ptr %gep.d, align 4
; CHECK-NEXT:    %mul = mul i64 %ind, %stride
; CHECK-NEXT:    %gep.strided.a = getelementptr inbounds i32, ptr %a, i64 %mul
; CHECK-NEXT:    %load.strided.a = load i32, ptr %gep.strided.a, align 4
; CHECK-NEXT:    %mul.c = mul i32 %loadD, %load.strided.a
; CHECK-NEXT:    %gep.c = getelementptr inbounds i32, ptr %c, i64 %ind
; CHECK-NEXT:    store i32 %mul.c, ptr %gep.c, align 4
; CHECK-NEXT:    %exitcond = icmp eq i64 %add, 20
; CHECK-NEXT:    br i1 %exitcond, label %exit.loopexit1, label %for.body
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %ind = phi i64 [ 0, %entry ], [ %add, %for.body ]
  %gep.a = getelementptr inbounds i32, ptr %a, i64 %ind
  %load.a = load i32, ptr %gep.a, align 4
  %gep.b = getelementptr inbounds i32, ptr %b, i64 %ind
  %load.b = load i32, ptr %gep.b, align 4
  %mul.a = mul i32 %load.b, %load.a
  %add = add nuw nsw i64 %ind, 1
  %gep.a.plus4 = getelementptr inbounds i32, ptr %a, i64 %add
  store i32 %mul.a, ptr %gep.a.plus4, align 4
  %gep.d = getelementptr inbounds i32, ptr %d, i64 %ind
  %loadD = load i32, ptr %gep.d, align 4
  %mul = mul i64 %ind, %stride
  %gep.strided.a = getelementptr inbounds i32, ptr %a, i64 %mul
  %load.strided.a = load i32, ptr %gep.strided.a, align 4
  %mul.c = mul i32 %loadD, %load.strided.a
  %gep.c = getelementptr inbounds i32, ptr %c, i64 %ind
  store i32 %mul.c, ptr %gep.c, align 4
  %exitcond = icmp eq i64 %add, 20
  br i1 %exitcond, label %exit, label %for.body

exit:                                             ; preds = %for.body
  ret void
}
