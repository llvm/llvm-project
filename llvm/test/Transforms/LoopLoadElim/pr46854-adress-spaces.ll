; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; REQUIRES: amdgpu-registered-target

; RUN: opt -passes='require<globals-aa>,loop-simplify,loop-load-elim' -S %s | FileCheck %s

target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn-amd-amdhsa"

%struct.foo = type { %struct.pluto, i8, ptr, i32 }
%struct.pluto = type { i32, i32, i32, ptr, i32, i32, i32 }
%struct.wombat = type { %struct.barney }
%struct.barney = type { <2 x float> }

@global = external protected local_unnamed_addr addrspace(4) externally_initialized global %struct.foo, align 8
@global.1 = internal unnamed_addr addrspace(3) constant [4000 x float] undef, align 16

; Function Attrs: nounwind
define protected amdgpu_kernel void @widget(i32 %arg, i32 %arg1) #0 {
; CHECK-LABEL: @widget(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = getelementptr inbounds [4000 x float], ptr addrspace(3) @global.1, i32 0, i32 [[ARG:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr addrspace(4) getelementptr inbounds (%struct.foo, ptr addrspace(4) @global, i64 0, i32 0, i32 3), align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[STRUCT_WOMBAT:%.*]], ptr [[TMP2]], i64 undef, i32 0
; CHECK-NEXT:    br label [[BB5:%.*]]
; CHECK:       bb5.loopexit:
; CHECK-NEXT:    br label [[BB5]]
; CHECK:       bb5:
; CHECK-NEXT:    br label [[BB6:%.*]]
; CHECK:       bb6:
; CHECK-NEXT:    [[TMP7:%.*]] = phi i32 [ undef, [[BB5]] ], [ [[TMP19:%.*]], [[BB6]] ]
; CHECK-NEXT:    [[TMP8:%.*]] = mul nsw i32 [[TMP7]], undef
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 [[TMP8]], undef
; CHECK-NEXT:    [[TMP10:%.*]] = sext i32 [[TMP9]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds [[STRUCT_WOMBAT]], ptr [[TMP2]], i64 [[TMP10]]
; CHECK-NEXT:    [[TMP13:%.*]] = load i64, ptr [[TMP11]], align 8
; CHECK-NEXT:    [[TMP14:%.*]] = srem i32 1, [[ARG1:%.*]]
; CHECK-NEXT:    [[TMP15:%.*]] = add nuw nsw i32 [[TMP14]], 1
; CHECK-NEXT:    [[TMP16:%.*]] = getelementptr inbounds [4000 x float], ptr addrspace(3) @global.1, i32 0, i32 [[TMP15]]
; CHECK-NEXT:    [[TMP17:%.*]] = load float, ptr addrspace(3) [[TMP16]], align 4
; CHECK-NEXT:    [[TMP18:%.*]] = load float, ptr addrspace(3) [[TMP]], align 4
; CHECK-NEXT:    store i64 [[TMP13]], ptr [[TMP3]], align 8
; CHECK-NEXT:    [[TMP19]] = add nsw i32 [[TMP7]], 1
; CHECK-NEXT:    [[TMP20:%.*]] = icmp slt i32 [[TMP7]], 3
; CHECK-NEXT:    br i1 [[TMP20]], label [[BB6]], label [[BB5_LOOPEXIT:%.*]]
;
bb:
  %tmp = getelementptr inbounds [4000 x float], ptr addrspace(3) @global.1, i32 0, i32 %arg
  %tmp2 = load ptr, ptr addrspace(4) getelementptr inbounds (%struct.foo, ptr addrspace(4) @global, i64 0, i32 0, i32 3), align 8
  %tmp3 = getelementptr inbounds %struct.wombat, ptr %tmp2, i64 undef, i32 0
  br label %bb5

bb5:                                              ; preds = %bb6, %bb
  br label %bb6

bb6:                                              ; preds = %bb6, %bb5
  %tmp7 = phi i32 [ undef, %bb5 ], [ %tmp19, %bb6 ]
  %tmp8 = mul nsw i32 %tmp7, undef
  %tmp9 = add i32 %tmp8, undef
  %tmp10 = sext i32 %tmp9 to i64
  %tmp11 = getelementptr inbounds %struct.wombat, ptr %tmp2, i64 %tmp10
  %tmp13 = load i64, ptr %tmp11, align 8
  %tmp14 = srem i32 1, %arg1
  %tmp15 = add nuw nsw i32 %tmp14, 1
  %tmp16 = getelementptr inbounds [4000 x float], ptr addrspace(3) @global.1, i32 0, i32 %tmp15
  %tmp17 = load float, ptr addrspace(3) %tmp16, align 4
  %tmp18 = load float, ptr addrspace(3) %tmp, align 4
  store i64 %tmp13, ptr %tmp3, align 8
  %tmp19 = add nsw i32 %tmp7, 1
  %tmp20 = icmp slt i32 %tmp7, 3
  br i1 %tmp20, label %bb6, label %bb5
}

attributes #0 = { nounwind }
