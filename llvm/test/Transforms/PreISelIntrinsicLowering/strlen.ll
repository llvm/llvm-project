; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=pre-isel-intrinsic-lowering -S < %s | FileCheck %s

declare i64 @llvm.strlen.p0.i8(ptr, i8)
declare i64 @llvm.strlen.p0.i16(ptr, i16)
declare i64 @llvm.strlen.p0.i32(ptr, i32)

declare i64 @llvm.strlen.p1.i8(ptr addrspace(1), i8)
declare i32 @llvm.strlen.i32.p0.i32(ptr, i32)

declare void @before()
declare void @after()

define i64 @expand_as_libcall_strlen8(ptr %p) {
; CHECK-LABEL: define i64 @expand_as_libcall_strlen8(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @before()
; CHECK-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(ptr [[P]])
; CHECK-NEXT:    call void @after()
; CHECK-NEXT:    ret i64 [[STRLEN]]
;
entry:
  call void @before()
  %0 = call i64 @llvm.strlen.p0.i8(ptr %p, i8 0)
  call void @after()
  ret i64 %0
}

define i32 @expand_as_libcall_strlen8_32bit(ptr %p) {
; CHECK-LABEL: define i32 @expand_as_libcall_strlen8_32bit(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @before()
; CHECK-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(ptr [[P]])
; CHECK-NEXT:    [[TMP0:%.*]] = trunc i64 [[STRLEN]] to i32
; CHECK-NEXT:    call void @after()
; CHECK-NEXT:    ret i32 [[TMP0]]
;
entry:
  call void @before()
  %0 = call i32 @llvm.strlen.i32.p0.i8(ptr %p, i8 0)
  call void @after()
  ret i32 %0
}

define i64 @expand_as_libcall_strlen32(ptr %p) {
; CHECK-LABEL: define i64 @expand_as_libcall_strlen32(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @before()
; CHECK-NEXT:    [[WCSLEN:%.*]] = call i64 @wcslen(ptr [[P]])
; CHECK-NEXT:    call void @after()
; CHECK-NEXT:    ret i64 [[WCSLEN]]
;
entry:
  call void @before()
  %0 = call i64 @llvm.strlen.p0.i32(ptr %p, i32 0)
  call void @after()
  ret i64 %0
}

define i64 @expand_as_loop_strlen8(ptr %p) #0 {
; CHECK-LABEL: define i64 @expand_as_loop_strlen8(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @before()
; CHECK-NEXT:    br label %[[STRLEN_LOOP_EXPANSION:.*]]
; CHECK:       [[STRLEN_LOOP_EXPANSION]]:
; CHECK-NEXT:    [[STR:%.*]] = phi ptr [ [[P]], %[[ENTRY]] ], [ [[STR_INC:%.*]], %[[STRLEN_LOOP_EXPANSION]] ]
; CHECK-NEXT:    [[CHAR:%.*]] = load i8, ptr [[STR]], align 1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 [[CHAR]], 0
; CHECK-NEXT:    [[STR_INC]] = getelementptr i8, ptr [[STR]], i64 1
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[STRLEN_LOOP_EXPANSION_TERMINATOR:.*]], label %[[STRLEN_LOOP_EXPANSION]]
; CHECK:       [[STRLEN_LOOP_EXPANSION_TERMINATOR]]:
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[STR]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    call void @after()
; CHECK-NEXT:    ret i64 [[TMP2]]
;
entry:
  call void @before()
  %0 = call i64 @llvm.strlen.p0.i8(ptr %p, i8 0)
  call void @after()
  ret i64 %0
}

define i32 @expand_as_loop_strlen8_32bit(ptr %p) #0 {
; CHECK-LABEL: define i32 @expand_as_loop_strlen8_32bit(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @before()
; CHECK-NEXT:    br label %[[STRLEN_LOOP_EXPANSION:.*]]
; CHECK:       [[STRLEN_LOOP_EXPANSION]]:
; CHECK-NEXT:    [[STR:%.*]] = phi ptr [ [[P]], %[[ENTRY]] ], [ [[STR_INC:%.*]], %[[STRLEN_LOOP_EXPANSION]] ]
; CHECK-NEXT:    [[CHAR:%.*]] = load i8, ptr [[STR]], align 1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 [[CHAR]], 0
; CHECK-NEXT:    [[STR_INC]] = getelementptr i8, ptr [[STR]], i64 1
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[STRLEN_LOOP_EXPANSION_TERMINATOR:.*]], label %[[STRLEN_LOOP_EXPANSION]]
; CHECK:       [[STRLEN_LOOP_EXPANSION_TERMINATOR]]:
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[STR]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = trunc i64 [[TMP2]] to i32
; CHECK-NEXT:    call void @after()
; CHECK-NEXT:    ret i32 [[TMP3]]
;
entry:
  call void @before()
  %0 = call i32 @llvm.strlen.i32.p0.i8(ptr %p, i8 0)
  call void @after()
  ret i32 %0
}

define i64 @expand_as_loop_strlen16(ptr %p) #0 {
; CHECK-LABEL: define i64 @expand_as_loop_strlen16(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @before()
; CHECK-NEXT:    br label %[[STRLEN_LOOP_EXPANSION:.*]]
; CHECK:       [[STRLEN_LOOP_EXPANSION]]:
; CHECK-NEXT:    [[STR:%.*]] = phi ptr [ [[P]], %[[ENTRY]] ], [ [[STR_INC:%.*]], %[[STRLEN_LOOP_EXPANSION]] ]
; CHECK-NEXT:    [[CHAR:%.*]] = load i16, ptr [[STR]], align 2
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i16 [[CHAR]], 0
; CHECK-NEXT:    [[STR_INC]] = getelementptr i8, ptr [[STR]], i64 2
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[STRLEN_LOOP_EXPANSION_TERMINATOR:.*]], label %[[STRLEN_LOOP_EXPANSION]]
; CHECK:       [[STRLEN_LOOP_EXPANSION_TERMINATOR]]:
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[STR]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[STR_LEN:%.*]] = lshr i64 [[TMP2]], 1
; CHECK-NEXT:    call void @after()
; CHECK-NEXT:    ret i64 [[STR_LEN]]
;
entry:
  call void @before()
  %0 = call i64 @llvm.strlen.p0.i16(ptr %p, i16 0)
  call void @after()
  ret i64 %0
}

define i64 @expand_as_loop_strlen32(ptr %p) #0 {
; CHECK-LABEL: define i64 @expand_as_loop_strlen32(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @before()
; CHECK-NEXT:    br label %[[STRLEN_LOOP_EXPANSION:.*]]
; CHECK:       [[STRLEN_LOOP_EXPANSION]]:
; CHECK-NEXT:    [[STR:%.*]] = phi ptr [ [[P]], %[[ENTRY]] ], [ [[STR_INC:%.*]], %[[STRLEN_LOOP_EXPANSION]] ]
; CHECK-NEXT:    [[CHAR:%.*]] = load i32, ptr [[STR]], align 4
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[CHAR]], 0
; CHECK-NEXT:    [[STR_INC]] = getelementptr i8, ptr [[STR]], i64 4
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[STRLEN_LOOP_EXPANSION_TERMINATOR:.*]], label %[[STRLEN_LOOP_EXPANSION]]
; CHECK:       [[STRLEN_LOOP_EXPANSION_TERMINATOR]]:
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[STR]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[P]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[STR_LEN:%.*]] = lshr i64 [[TMP2]], 2
; CHECK-NEXT:    call void @after()
; CHECK-NEXT:    ret i64 [[STR_LEN]]
;
entry:
  call void @before()
  %0 = call i64 @llvm.strlen.p0.i32(ptr %p, i32 0)
  call void @after()
  ret i64 %0
}

define i64 @expanded_loop_keep_addrspace(ptr addrspace(1) %p) #0 {
; CHECK-LABEL: define i64 @expanded_loop_keep_addrspace(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[STRLEN_LOOP_EXPANSION:.*]]
; CHECK:       [[STRLEN_LOOP_EXPANSION]]:
; CHECK-NEXT:    [[STR:%.*]] = phi ptr addrspace(1) [ [[P]], %[[ENTRY]] ], [ [[STR_INC:%.*]], %[[STRLEN_LOOP_EXPANSION]] ]
; CHECK-NEXT:    [[CHAR:%.*]] = load i8, ptr addrspace(1) [[STR]], align 1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i8 [[CHAR]], 0
; CHECK-NEXT:    [[STR_INC]] = getelementptr i8, ptr addrspace(1) [[STR]], i64 1
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[STRLEN_LOOP_EXPANSION_TERMINATOR:.*]], label %[[STRLEN_LOOP_EXPANSION]]
; CHECK:       [[STRLEN_LOOP_EXPANSION_TERMINATOR]]:
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr addrspace(1) [[STR]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr addrspace(1) [[P]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    ret i64 [[TMP2]]
;
entry:
  %0 = call i64 @llvm.strlen.p1.i8(ptr addrspace(1) %p, i8 0)
  ret i64 %0
}

attributes #0 = { "no-builtins" }

!llvm.module.flags = !{!0}
!0 = !{i32 1, !"wchar_size", i32 4}

