; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=mergeicmps -verify-dom-info -mtriple=x86_64-unknown-unknown -S | FileCheck %s --check-prefix=X86

%S = type { i32, i32, i32, i32 }

declare void @foo(...)
declare void @bar(...)

; We can split %entry and create a memcmp(16 bytes).
define zeroext i1 @opeq1(
; X86-LABEL: @opeq1(
; X86-NEXT:  "entry+land.rhs.i+land.rhs.i.2+land.rhs.i.3":
; X86-NEXT:    call void (...) @foo() #[[ATTR2:[0-9]+]]
; X86-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[A:%.*]], ptr [[B:%.*]], i64 16)
; X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[MEMCMP]], 0
; X86-NEXT:    br label [[OPEQ1_EXIT:%.*]]
; X86:       opeq1.exit:
; X86-NEXT:    ret i1 [[TMP2]]
;
; Make sure this call is moved to the beginning of the entry block.
  ptr nocapture readonly dereferenceable(16) %a,
  ptr nocapture readonly dereferenceable(16) %b) local_unnamed_addr nofree nosync {
entry:
  %0 = load i32, ptr %a, align 4
  %1 = load i32, ptr %b, align 4
  ; Does other work.
  call void (...) @foo() inaccessiblememonly
  %cmp.i = icmp eq i32 %0, %1
  br i1 %cmp.i, label %land.rhs.i, label %opeq1.exit

land.rhs.i:
  %second.i = getelementptr inbounds %S, ptr %a, i64 0, i32 1
  %2 = load i32, ptr %second.i, align 4
  %second2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 1
  %3 = load i32, ptr %second2.i, align 4
  %cmp2.i = icmp eq i32 %2, %3
  br i1 %cmp2.i, label %land.rhs.i.2, label %opeq1.exit

land.rhs.i.2:
  %third.i = getelementptr inbounds %S, ptr %a, i64 0, i32 2
  %4 = load i32, ptr %third.i, align 4
  %third2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 2
  %5 = load i32, ptr %third2.i, align 4
  %cmp3.i = icmp eq i32 %4, %5
  br i1 %cmp3.i, label %land.rhs.i.3, label %opeq1.exit

land.rhs.i.3:
  %fourth.i = getelementptr inbounds %S, ptr %a, i64 0, i32 3
  %6 = load i32, ptr %fourth.i, align 4
  %fourth2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 3
  %7 = load i32, ptr %fourth2.i, align 4
  %cmp4.i = icmp eq i32 %6, %7
  br label %opeq1.exit

opeq1.exit:
  %8 = phi i1 [ false, %entry ], [ false, %land.rhs.i] , [ false, %land.rhs.i.2 ], [ %cmp4.i, %land.rhs.i.3 ]
  ret i1 %8
}


; We will not be able to merge anything, make sure the call is not moved out.
define zeroext i1 @opeq1_discontiguous(
; X86-LABEL: @opeq1_discontiguous(
; X86-NEXT:  entry:
; X86-NEXT:    [[FIRST_I:%.*]] = getelementptr inbounds [[S:%.*]], ptr [[A:%.*]], i64 0, i32 1
; X86-NEXT:    [[TMP0:%.*]] = load i32, ptr [[FIRST_I]], align 4
; X86-NEXT:    [[TMP1:%.*]] = load i32, ptr [[B:%.*]], align 4
; X86-NEXT:    call void (...) @foo() #[[ATTR2]]
; X86-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[TMP0]], [[TMP1]]
; X86-NEXT:    br i1 [[CMP_I]], label [[LAND_RHS_I:%.*]], label [[OPEQ1_EXIT:%.*]]
; X86:       land.rhs.i:
; X86-NEXT:    [[SECOND_I:%.*]] = getelementptr inbounds [[S]], ptr [[A]], i64 0, i32 2
; X86-NEXT:    [[TMP2:%.*]] = load i32, ptr [[SECOND_I]], align 4
; X86-NEXT:    [[SECOND2_I:%.*]] = getelementptr inbounds [[S]], ptr [[B]], i64 0, i32 1
; X86-NEXT:    [[TMP3:%.*]] = load i32, ptr [[SECOND2_I]], align 4
; X86-NEXT:    [[CMP2_I:%.*]] = icmp eq i32 [[TMP2]], [[TMP3]]
; X86-NEXT:    br i1 [[CMP2_I]], label [[LAND_RHS_I_2:%.*]], label [[OPEQ1_EXIT]]
; X86:       land.rhs.i.2:
; X86-NEXT:    [[THIRD_I:%.*]] = getelementptr inbounds [[S]], ptr [[A]], i64 0, i32 2
; X86-NEXT:    [[TMP4:%.*]] = load i32, ptr [[THIRD_I]], align 4
; X86-NEXT:    [[THIRD2_I:%.*]] = getelementptr inbounds [[S]], ptr [[B]], i64 0, i32 3
; X86-NEXT:    [[TMP5:%.*]] = load i32, ptr [[THIRD2_I]], align 4
; X86-NEXT:    [[CMP3_I:%.*]] = icmp eq i32 [[TMP4]], [[TMP5]]
; X86-NEXT:    br i1 [[CMP3_I]], label [[LAND_RHS_I_3:%.*]], label [[OPEQ1_EXIT]]
; X86:       land.rhs.i.3:
; X86-NEXT:    [[FOURTH_I:%.*]] = getelementptr inbounds [[S]], ptr [[A]], i64 0, i32 1
; X86-NEXT:    [[TMP6:%.*]] = load i32, ptr [[FOURTH_I]], align 4
; X86-NEXT:    [[FOURTH2_I:%.*]] = getelementptr inbounds [[S]], ptr [[B]], i64 0, i32 3
; X86-NEXT:    [[TMP7:%.*]] = load i32, ptr [[FOURTH2_I]], align 4
; X86-NEXT:    [[CMP4_I:%.*]] = icmp eq i32 [[TMP6]], [[TMP7]]
; X86-NEXT:    br label [[OPEQ1_EXIT]]
; X86:       opeq1.exit:
; X86-NEXT:    [[TMP8:%.*]] = phi i1 [ false, [[ENTRY:%.*]] ], [ false, [[LAND_RHS_I]] ], [ false, [[LAND_RHS_I_2]] ], [ [[CMP4_I]], [[LAND_RHS_I_3]] ]
; X86-NEXT:    ret i1 [[TMP8]]
;
; Make sure this call is moved in the entry block.
  ptr nocapture readonly dereferenceable(16) %a,
  ptr nocapture readonly dereferenceable(16) %b) local_unnamed_addr #0 {
entry:
  %first.i = getelementptr inbounds %S, ptr %a, i64 0, i32 1
  %0 = load i32, ptr %first.i, align 4
  %1 = load i32, ptr %b, align 4
  ; Does other work.
  call void (...) @foo() inaccessiblememonly
  %cmp.i = icmp eq i32 %0, %1
  br i1 %cmp.i, label %land.rhs.i, label %opeq1.exit

land.rhs.i:
  %second.i = getelementptr inbounds %S, ptr %a, i64 0, i32 2
  %2 = load i32, ptr %second.i, align 4
  %second2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 1
  %3 = load i32, ptr %second2.i, align 4
  %cmp2.i = icmp eq i32 %2, %3
  br i1 %cmp2.i, label %land.rhs.i.2, label %opeq1.exit

land.rhs.i.2:
  %third.i = getelementptr inbounds %S, ptr %a, i64 0, i32 2
  %4 = load i32, ptr %third.i, align 4
  %third2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 3
  %5 = load i32, ptr %third2.i, align 4
  %cmp3.i = icmp eq i32 %4, %5
  br i1 %cmp3.i, label %land.rhs.i.3, label %opeq1.exit

land.rhs.i.3:
  %fourth.i = getelementptr inbounds %S, ptr %a, i64 0, i32 1
  %6 = load i32, ptr %fourth.i, align 4
  %fourth2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 3
  %7 = load i32, ptr %fourth2.i, align 4
  %cmp4.i = icmp eq i32 %6, %7
  br label %opeq1.exit

opeq1.exit:
  %8 = phi i1 [ false, %entry ], [ false, %land.rhs.i] , [ false, %land.rhs.i.2 ], [ %cmp4.i, %land.rhs.i.3 ]
  ret i1 %8
}

; The call happens before the loads, so it cannot clobber them.
define zeroext i1 @opeq1_call_before_loads(
; X86-LABEL: @opeq1_call_before_loads(
; X86-NEXT:  "entry+land.rhs.i+land.rhs.i.2+land.rhs.i.3":
; X86-NEXT:    call void (...) @foo()
; X86-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[A:%.*]], ptr [[B:%.*]], i64 16)
; X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[MEMCMP]], 0
; X86-NEXT:    br label [[OPEQ1_EXIT:%.*]]
; X86:       opeq1.exit:
; X86-NEXT:    ret i1 [[TMP2]]
;
; Make sure this call is moved to the beginning of the entry block.
  ptr nocapture readonly dereferenceable(16) %a,
  ptr nocapture readonly dereferenceable(16) %b) local_unnamed_addr nofree nosync {
entry:
  call void (...) @foo()
  %0 = load i32, ptr %a, align 4
  %1 = load i32, ptr %b, align 4
  %cmp.i = icmp eq i32 %0, %1
  br i1 %cmp.i, label %land.rhs.i, label %opeq1.exit

land.rhs.i:
  %second.i = getelementptr inbounds %S, ptr %a, i64 0, i32 1
  %2 = load i32, ptr %second.i, align 4
  %second2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 1
  %3 = load i32, ptr %second2.i, align 4
  %cmp2.i = icmp eq i32 %2, %3
  br i1 %cmp2.i, label %land.rhs.i.2, label %opeq1.exit

land.rhs.i.2:
  %third.i = getelementptr inbounds %S, ptr %a, i64 0, i32 2
  %4 = load i32, ptr %third.i, align 4
  %third2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 2
  %5 = load i32, ptr %third2.i, align 4
  %cmp3.i = icmp eq i32 %4, %5
  br i1 %cmp3.i, label %land.rhs.i.3, label %opeq1.exit

land.rhs.i.3:
  %fourth.i = getelementptr inbounds %S, ptr %a, i64 0, i32 3
  %6 = load i32, ptr %fourth.i, align 4
  %fourth2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 3
  %7 = load i32, ptr %fourth2.i, align 4
  %cmp4.i = icmp eq i32 %6, %7
  br label %opeq1.exit

opeq1.exit:
  %8 = phi i1 [ false, %entry ], [ false, %land.rhs.i] , [ false, %land.rhs.i.2 ], [ %cmp4.i, %land.rhs.i.3 ]
  ret i1 %8
}

; Call happens after the loads, and may clobber them.
define zeroext i1 @opeq1_call_after_loads(
; X86-LABEL: @opeq1_call_after_loads(
; X86-NEXT:  entry:
; X86-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A:%.*]], align 4
; X86-NEXT:    [[TMP1:%.*]] = load i32, ptr [[B:%.*]], align 4
; X86-NEXT:    call void (...) @foo()
; X86-NEXT:    [[CMP_I:%.*]] = icmp eq i32 [[TMP0]], [[TMP1]]
; X86-NEXT:    br i1 [[CMP_I]], label %"land.rhs.i+land.rhs.i.2+land.rhs.i.3", label [[OPEQ1_EXIT:%.*]]
; X86:       "land.rhs.i+land.rhs.i.2+land.rhs.i.3":
; X86-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [[S]], ptr [[A]], i64 0, i32 1
; X86-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[S]], ptr [[B]], i64 0, i32 1
; X86-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[TMP2]], ptr [[TMP3]], i64 12)
; X86-NEXT:    [[TMP4:%.*]] = icmp eq i32 [[MEMCMP]], 0
; X86-NEXT:    br label [[OPEQ1_EXIT]]
; X86:       opeq1.exit:
; X86-NEXT:    [[TMP5:%.*]] = phi i1 [ false, [[ENTRY:%.*]] ], [ [[TMP4]], %"land.rhs.i+land.rhs.i.2+land.rhs.i.3" ]
; X86-NEXT:    ret i1 [[TMP5]]
;
; Make sure this call is moved to the beginning of the entry block.
  ptr nocapture readonly dereferenceable(16) %a,
  ptr nocapture readonly dereferenceable(16) %b) local_unnamed_addr nofree nosync {
entry:
  %0 = load i32, ptr %a, align 4
  %1 = load i32, ptr %b, align 4
  call void (...) @foo()
  %cmp.i = icmp eq i32 %0, %1
  br i1 %cmp.i, label %land.rhs.i, label %opeq1.exit

land.rhs.i:
  %second.i = getelementptr inbounds %S, ptr %a, i64 0, i32 1
  %2 = load i32, ptr %second.i, align 4
  %second2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 1
  %3 = load i32, ptr %second2.i, align 4
  %cmp2.i = icmp eq i32 %2, %3
  br i1 %cmp2.i, label %land.rhs.i.2, label %opeq1.exit

land.rhs.i.2:
  %third.i = getelementptr inbounds %S, ptr %a, i64 0, i32 2
  %4 = load i32, ptr %third.i, align 4
  %third2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 2
  %5 = load i32, ptr %third2.i, align 4
  %cmp3.i = icmp eq i32 %4, %5
  br i1 %cmp3.i, label %land.rhs.i.3, label %opeq1.exit

land.rhs.i.3:
  %fourth.i = getelementptr inbounds %S, ptr %a, i64 0, i32 3
  %6 = load i32, ptr %fourth.i, align 4
  %fourth2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 3
  %7 = load i32, ptr %fourth2.i, align 4
  %cmp4.i = icmp eq i32 %6, %7
  br label %opeq1.exit

opeq1.exit:
  %8 = phi i1 [ false, %entry ], [ false, %land.rhs.i] , [ false, %land.rhs.i.2 ], [ %cmp4.i, %land.rhs.i.3 ]
  ret i1 %8
}

; Call instruction mixed in with select block but doesn't clobber memory, so can safely sink and merge all comparisons.
; Make sure that call order stays the same.
define dso_local noundef zeroext i1 @unclobbered_select_cmp(
; X86-LABEL: @unclobbered_select_cmp(
; X86-NEXT:       "entry+land.rhs":
; X86-NEXT:    call void (...) @foo() #[[ATTR2]]
; X86-NEXT:    call void (...) @bar() #[[ATTR2]]
; X86-NEXT:    [[OFFSET:%.*]] = getelementptr inbounds nuw i8, ptr [[A:%.*]], i64 2
; X86-NEXT:    [[TMP0:%.*]] = alloca [3 x i8], align 1
; X86-NEXT:    store [3 x i8] c"d\03\C8", ptr [[TMP0]], align 1
; X86-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[OFFSET]], ptr [[TMP0]], i64 3)
; X86-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[MEMCMP]], 0
; X86-NEXT:    br label [[LAND_END:%.*]]
; X86:       land.end:
; X86-NEXT:    ret i1 [[TMP1]]
;
  ptr nocapture readonly dereferenceable(5) %a) local_unnamed_addr nofree nosync {
entry:
  %q = getelementptr inbounds nuw i8, ptr %a, i64 4
  %0 = load i8, ptr %q, align 1
  call void (...) @foo() inaccessiblememonly
  %cmp = icmp eq i8 %0, 200
  %c = getelementptr inbounds nuw i8, ptr %a, i64 2
  %1 = load i8, ptr %c, align 1
  %cmp2 = icmp eq i8 %1, 100
  call void (...) @bar() inaccessiblememonly
  %or.cond = select i1 %cmp, i1 %cmp2, i1 false
  br i1 %or.cond, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %b3 = getelementptr inbounds nuw i8, ptr %a, i64 3
  %2 = load i8, ptr %b3, align 1
  %cmp5 = icmp eq i8 %2, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp5, %land.rhs ]
  ret i1 %3
}


; Can only split first block. If subsequent block contains a clobber instruction then don't merge.
define dso_local noundef zeroext i1 @not_split_sec_block(
; X86-LABEL: @not_split_sec_block(
; X86-NEXT:  entry:
; X86-NEXT:    [[TMP0:%.*]] = load i8, ptr [[A:%.*]], align 1
; X86-NEXT:    call void (...) @foo() #[[ATTR2]]
; X86-NEXT:    [[CMP0:%.*]] = icmp eq i8 [[TMP0]], -56
; X86-NEXT:    [[TMP1:%.*]] = getelementptr inbounds nuw i8, ptr [[A]], i64 2
; X86-NEXT:    [[TMP2:%.*]] = load i8, ptr [[TMP1]], align 1
; X86-NEXT:    [[CMP1:%.*]] = icmp eq i8 [[TMP2]], 100
; X86-NEXT:    [[SEL0:%.*]] = select i1 [[CMP0]], i1 [[CMP1]], i1 false
; X86-NEXT:    br i1 [[SEL0]], label [[LAND_RHS:%.*]], label [[LAND_END:%.*]]
; X86:       land.rhs:
; X86-NEXT:    [[TMP3:%.*]] = getelementptr inbounds nuw i8, ptr [[A]], i64 1
; X86-NEXT:    [[TMP4:%.*]] = load i8, ptr [[TMP3]], align 1
; X86-NEXT:    call void (...) @bar() #[[ATTR2]]
; X86-NEXT:    [[CMP2:%.*]] = icmp eq i8 [[TMP4]], 3
; X86-NEXT:    br label [[LAND_END]]
; X86:       land.end:
; X86-NEXT:    [[RES:%.*]] = phi i1 [ false, %entry ], [ [[CMP2]], [[LAND_RHS]] ]
; X86-NEXT:    ret i1 [[RES]]
;
  ptr nocapture readonly dereferenceable(3) %a) local_unnamed_addr nofree nosync {
entry:
  %0 = load i8, ptr %a, align 1
  call void (...) @foo() inaccessiblememonly
  %cmp = icmp eq i8 %0, 200
  %c = getelementptr inbounds nuw i8, ptr %a, i64 2
  %1 = load i8, ptr %c, align 1
  %cmp2 = icmp eq i8 %1, 100
  %or.cond = select i1 %cmp, i1 %cmp2, i1 false
  br i1 %or.cond, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %b3 = getelementptr inbounds nuw i8, ptr %a, i64 1
  %2 = load i8, ptr %b3, align 1
; Even though this call doesn't clobber any memory, can only sink instructions from first block.
  call void (...) @bar() inaccessiblememonly
  %cmp5 = icmp eq i8 %2, 3
  br label %land.end
land.end:
  %3 = phi i1 [ false, %entry ], [ %cmp5, %land.rhs ]
  ret i1 %3
}
