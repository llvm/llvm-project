; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update
; RUN: opt < %s -mtriple=x86_64-unknown-unknown -passes=mergeicmps -verify-dom-info -S 2>&1 | FileCheck %s

; adjacent byte pointer accesses compared to constants, should be merged into single memcmp, spanning multiple basic blocks

define zeroext i1 @test(ptr nocapture noundef nonnull dereferenceable(3) %p) local_unnamed_addr #0 {
; CHECK-LABEL: @test(
; CHECK-NEXT:  "entry+land.lhs.true+land.rhs":
; CHECK-NEXT:    [[TMP0:%.*]] = alloca [3 x i8], align 1
; CHECK-NEXT:    store [3 x i8] c"\FF\C8\BE", ptr [[O1:%.*]], align 1
; CHECK-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[p:%.*]], ptr [[TMP0:%.*]], i64 3)
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[MEMCMP]], 0
; CHECK-NEXT:    br label [[LAND_END5:%.*]]
; CHECK:       land.end:
; CHECK-NEXT:    ret i1 [[TMP1]]
;
entry:
  %0 = load i8, ptr %p, align 1
  %cmp = icmp eq i8 %0, -1
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %arrayidx1 = getelementptr inbounds nuw i8, ptr %p, i64 1
  %1 = load i8, ptr %arrayidx1, align 1
  %cmp5 = icmp eq i8 %1, -56
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %arrayidx2 = getelementptr inbounds nuw i8, ptr %p, i64 2
  %2 = load i8, ptr %arrayidx2, align 1
  %cmp8 = icmp eq i8 %2, -66
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp8, %land.rhs ]
  ret i1 %3
}
