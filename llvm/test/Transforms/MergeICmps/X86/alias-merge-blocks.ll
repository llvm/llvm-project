; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -mtriple=x86_64-unknown-unknown -passes=mergeicmps -verify-dom-info -S | FileCheck %s --check-prefix=X86

%S = type { i32, i32, i32, i32, i32}

define zeroext i1 @opeq1(
; X86-LABEL: @opeq1(
; X86-NEXT:  "entry+land.rhs.i+land.rhs.i.2+land.rhs.i.3":
; X86-NEXT:    [[PTR:%.*]] = alloca i32, align 4
; X86-NEXT:    store i32 42, ptr [[PTR]], align 4
; X86-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[A:%.*]], ptr [[B:%.*]], i64 16)
; X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[MEMCMP]], 0
; X86-NEXT:    br label [[OPEQ1_EXIT:%.*]]
; X86:       opeq1.exit:
; X86-NEXT:    ret i1 [[TMP2]]
;
  ptr nocapture readonly dereferenceable(16) %a,
  ptr nocapture readonly dereferenceable(16) %b) local_unnamed_addr nofree nosync {

entry:
  %ptr = alloca i32
  %0 = load i32, ptr %a, align 4
  %1 = load i32, ptr %b, align 4
  ; Does other work, has no interference, merge block
  store i32 42, ptr %ptr
  %cmp.i = icmp eq i32 %0, %1
  br i1 %cmp.i, label %land.rhs.i, label %opeq1.exit

land.rhs.i:
  %second.i = getelementptr inbounds %S, ptr %a, i64 0, i32 1
  %2 = load i32, ptr %second.i, align 4
  %second2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 1
  %3 = load i32, ptr %second2.i, align 4
  %cmp2.i = icmp eq i32 %2, %3
  br i1 %cmp2.i, label %land.rhs.i.2, label %opeq1.exit

land.rhs.i.2:
  %third.i = getelementptr inbounds %S, ptr %a, i64 0, i32 2
  %4 = load i32, ptr %third.i, align 4
  %third2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 2
  %5 = load i32, ptr %third2.i, align 4
  %cmp3.i = icmp eq i32 %4, %5
  br i1 %cmp3.i, label %land.rhs.i.3, label %opeq1.exit

land.rhs.i.3:
  %fourth.i = getelementptr inbounds %S, ptr %a, i64 0, i32 3
  %6 = load i32, ptr %fourth.i, align 4
  %fourth2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 3
  %7 = load i32, ptr %fourth2.i, align 4
  %cmp4.i = icmp eq i32 %6, %7
  br label %opeq1.exit

opeq1.exit:
  %8 = phi i1 [ false, %entry ], [ false, %land.rhs.i] , [ false, %land.rhs.i.2 ], [ %cmp4.i, %land.rhs.i.3 ]
  ret i1 %8
}

define zeroext i1 @part_sequent_eq_with_metadata() {
; X86-LABEL: @part_sequent_eq_with_metadata(
; X86-NEXT:  bb01:
; X86-NEXT:    [[A:%.*]] = alloca [[S:%.*]], align 8
; X86-NEXT:    [[B:%.*]] = alloca [[S]], align 8
; X86-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A]], align 4, !range [[RNG0:![0-9]+]], !noundef !1
; X86-NEXT:    [[TMP1:%.*]] = load i32, ptr [[B]], align 4, !range [[RNG0]], !noundef !1
; X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP0]], [[TMP1]]
; X86-NEXT:    br i1 [[TMP2]], label %"bb1+bb2+bb3", label [[EXIT:%.*]]
; X86:       "bb1+bb2+bb3":
; X86-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[S]], ptr [[A]], i64 0, i32 2
; X86-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [[S]], ptr [[B]], i64 0, i32 2
; X86-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[TMP3]], ptr [[TMP4]], i64 12)
; X86-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[MEMCMP]], 0
; X86-NEXT:    br label [[EXIT]]
; X86:       exit:
; X86-NEXT:    [[RET:%.*]] = phi i1 [ [[TMP5]], %"bb1+bb2+bb3" ], [ false, [[BB01:%.*]] ]
; X86-NEXT:    ret i1 [[RET]]
;
bb0:
  %a = alloca %S, align 8
  %b = alloca %S, align 8
  %value0 = load i32, ptr %a, align 4, !range !0, !noundef !1
  %value1 = load i32, ptr %b, align 4, !range !0, !noundef !1
  %cmp.i = icmp eq i32 %value0, %value1
  br i1 %cmp.i, label %bb1, label %exit

bb1:
  %second.i = getelementptr inbounds %S, ptr %a, i64 0, i32 2
  %value2 = load i32, ptr %second.i, align 4
  %second2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 2
  %value3 = load i32, ptr %second2.i, align 4
  %cmp2.i = icmp eq i32 %value2, %value3
  br i1 %cmp2.i, label %bb2, label %exit

bb2:
  %third.i = getelementptr inbounds %S, ptr %a, i64 0, i32 3
  %value4 = load i32, ptr %third.i, align 4
  %third2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 3
  %value5 = load i32, ptr %third2.i, align 4
  %cmp3.i = icmp eq i32 %value4, %value5
  br i1 %cmp3.i, label %bb3, label %exit

bb3:
  %fourth.i = getelementptr inbounds %S, ptr %a, i64 0, i32 4
  %value6 = load i32, ptr %fourth.i, align 4
  %fourth2.i = getelementptr inbounds %S, ptr %b, i64 0, i32 4
  %value7 = load i32, ptr %fourth2.i, align 4
  %cmp4.i = icmp eq i32 %value6, %value7
  br label %exit

exit:
  %ret = phi i1 [ false, %bb0 ], [ false, %bb1] , [ false, %bb2] ,[ %cmp4.i, %bb3 ]
  ret i1 %ret
}

!0 = !{i32 0, i32 2}
!1 = !{}
