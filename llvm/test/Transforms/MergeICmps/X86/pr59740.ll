; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=mergeicmps -verify-dom-info -S -mtriple=x86_64-unknown-unknown | FileCheck %s

%struct.S = type { i8, i8, i8, i8 }
%struct1.S = type { i32, i32, i32, i8 }
%"struct.media::WebrtcVideoStatsDB::VideoDescKey" = type { i8, i32, i8, i32 }
%"c" = type { i32, i32, i32, float}

define noundef i1 @full_sequent_ne(ptr nocapture readonly align 1 dereferenceable(4) %s0, ptr nocapture readonly align 1 dereferenceable(4) %s1) {
; CHECK-LABEL: @full_sequent_ne(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    [[V0:%.*]] = load i8, ptr [[S0:%.*]], align 1
; CHECK-NEXT:    [[V1:%.*]] = load i8, ptr [[S1:%.*]], align 1
; CHECK-NEXT:    [[CMP0:%.*]] = icmp eq i8 [[V0]], [[V1]]
; CHECK-NEXT:    br i1 [[CMP0]], label [[BB1:%.*]], label [[BB4:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[S2:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr [[S0]], i64 0, i32 1
; CHECK-NEXT:    [[V2:%.*]] = load i8, ptr [[S2]], align 1
; CHECK-NEXT:    [[S3:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S1]], i64 0, i32 1
; CHECK-NEXT:    [[V3:%.*]] = load i8, ptr [[S3]], align 1
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i8 [[V2]], [[V3]]
; CHECK-NEXT:    br i1 [[CMP1]], label [[BB2:%.*]], label [[BB4]]
; CHECK:       bb2:
; CHECK-NEXT:    [[S4:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S0]], i64 0, i32 2
; CHECK-NEXT:    [[V4:%.*]] = load i8, ptr [[S4]], align 1
; CHECK-NEXT:    [[S5:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S1]], i64 0, i32 2
; CHECK-NEXT:    [[V5:%.*]] = load i8, ptr [[S5]], align 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i8 [[V4]], [[V5]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[BB3:%.*]], label [[BB4]]
; CHECK:       bb3:
; CHECK-NEXT:    [[S6:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S0]], i64 0, i32 3
; CHECK-NEXT:    [[V6:%.*]] = load i8, ptr [[S6]], align 1
; CHECK-NEXT:    [[S7:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S1]], i64 0, i32 3
; CHECK-NEXT:    [[V7:%.*]] = load i8, ptr [[S7]], align 1
; CHECK-NEXT:    [[CMP3:%.*]] = icmp ne i8 [[V6]], [[V7]]
; CHECK-NEXT:    br label [[BB4]]
; CHECK:       bb4:
; CHECK-NEXT:    [[CMP:%.*]] = phi i1 [ true, [[BB0:%.*]] ], [ true, [[BB1]] ], [ true, [[BB2]] ], [ [[CMP3]], [[BB3]] ]
; CHECK-NEXT:    ret i1 [[CMP]]
;
bb0:
  %v0 = load i8, ptr %s0, align 1
  %v1 = load i8, ptr %s1, align 1
  %cmp0 = icmp eq i8 %v0, %v1
  br i1 %cmp0, label %bb1, label %bb4

bb1:                                              ; preds = %bb0
  %s2 = getelementptr inbounds %struct.S, ptr %s0, i64 0, i32 1
  %v2 = load i8, ptr %s2, align 1
  %s3 = getelementptr inbounds %struct.S, ptr %s1, i64 0, i32 1
  %v3 = load i8, ptr %s3, align 1
  %cmp1 = icmp eq i8 %v2, %v3
  br i1 %cmp1, label %bb2, label %bb4

bb2:                                             ; preds = %bb1
  %s4 = getelementptr inbounds %struct.S, ptr %s0, i64 0, i32 2
  %v4 = load i8, ptr %s4, align 1
  %s5 = getelementptr inbounds %struct.S, ptr %s1, i64 0, i32 2
  %v5 = load i8, ptr %s5, align 1
  %cmp2 = icmp eq i8 %v4, %v5
  br i1 %cmp2, label %bb3, label %bb4

bb3:                                               ; preds = %bb2
  %s6 = getelementptr inbounds %struct.S, ptr %s0, i64 0, i32 3
  %v6 = load i8, ptr %s6, align 1
  %s7 = getelementptr inbounds %struct.S, ptr %s1, i64 0, i32 3
  %v7 = load i8, ptr %s7, align 1
  %cmp3 = icmp ne i8 %v6, %v7
  br label %bb4

bb4:                                               ; preds = %bb0, %bb1, %bb2, %bb3
  %cmp = phi i1 [ true, %bb0 ], [ true, %bb1 ], [ true, %bb2 ], [ %cmp3, %bb3 ]
  ret i1 %cmp
}

; Negative test: Incorrect const value in PHI node
define noundef i1 @cmp_ne_incorrect_const(ptr nocapture readonly align 1 dereferenceable(4) %s0, ptr nocapture readonly align 1 dereferenceable(4) %s1) {
; CHECK-LABEL: @cmp_ne_incorrect_const(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    [[V0:%.*]] = load i8, ptr [[S0:%.*]], align 1
; CHECK-NEXT:    [[V1:%.*]] = load i8, ptr [[S1:%.*]], align 1
; CHECK-NEXT:    [[CMP0:%.*]] = icmp eq i8 [[V0]], [[V1]]
; CHECK-NEXT:    br i1 [[CMP0]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[S6:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr [[S0]], i64 0, i32 1
; CHECK-NEXT:    [[V6:%.*]] = load i8, ptr [[S6]], align 1
; CHECK-NEXT:    [[S7:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S1]], i64 0, i32 1
; CHECK-NEXT:    [[V7:%.*]] = load i8, ptr [[S7]], align 1
; CHECK-NEXT:    [[CMP3:%.*]] = icmp ne i8 [[V6]], [[V7]]
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[CMP:%.*]] = phi i1 [ false, [[BB0:%.*]] ], [ [[CMP3]], [[BB1]] ]
; CHECK-NEXT:    ret i1 [[CMP]]
;
bb0:
  %v0 = load i8, ptr %s0, align 1
  %v1 = load i8, ptr %s1, align 1
  %cmp0 = icmp eq i8 %v0, %v1
  br i1 %cmp0, label %bb1, label %bb2

bb1:                                               ; preds = %bb0
  %s6 = getelementptr inbounds %struct.S, ptr %s0, i64 0, i32 1
  %v6 = load i8, ptr %s6, align 1
  %s7 = getelementptr inbounds %struct.S, ptr %s1, i64 0, i32 1
  %v7 = load i8, ptr %s7, align 1
  %cmp3 = icmp ne i8 %v6, %v7
  br label %bb2

bb2:                                               ; preds = %bb0, %bb1
  %cmp = phi i1 [ false, %bb0 ], [ %cmp3, %bb1 ]
  ret i1 %cmp
}

; https://alive2.llvm.org/ce/z/Zi2Z3Y
define noundef i1 @partial_sequent_eq(ptr nocapture readonly dereferenceable(16) %s0, ptr nocapture readonly dereferenceable(16) %s1) {
; CHECK-LABEL: @partial_sequent_eq(
; CHECK-NEXT:  bb01:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[S0:%.*]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[S1:%.*]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    br i1 [[TMP2]], label %"bb1+bb2", label [[BB3:%.*]]
; CHECK:       "bb1+bb2":
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[STRUCT1_S:%.*]], ptr [[S0]], i64 0, i32 2
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [[STRUCT1_S]], ptr [[S1]], i64 0, i32 2
; CHECK-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(ptr [[TMP3]], ptr [[TMP4]], i64 5)
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[MEMCMP]], 0
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    [[CMP:%.*]] = phi i1 [ [[TMP5]], %"bb1+bb2" ], [ false, [[BB01:%.*]] ]
; CHECK-NEXT:    ret i1 [[CMP]]
;
bb0:
  %v0 = load i32, ptr %s0, align 8
  %v1 = load i32, ptr %s1, align 8
  %cmp0 = icmp eq i32 %v0, %v1
  br i1 %cmp0, label %bb1, label %bb3

bb1:                                              ; preds = %bb0
  %s2 = getelementptr inbounds %struct1.S, ptr %s0, i64 0, i32 2
  %v2 = load i32, ptr %s2, align 8
  %s3 = getelementptr inbounds %struct1.S, ptr %s1, i64 0, i32 2
  %v3 = load i32, ptr %s3, align 8
  %cmp1 = icmp eq i32 %v2, %v3
  br i1 %cmp1, label %bb2, label %bb3

bb2:                                               ; preds = %bb2
  %s6 = getelementptr inbounds %struct1.S, ptr %s0, i64 0, i32 3
  %v6 = load i8, ptr %s6, align 1
  %s7 = getelementptr inbounds %struct1.S, ptr %s1, i64 0, i32 3
  %v7 = load i8, ptr %s7, align 1
  %cmp3 = icmp eq i8 %v6, %v7
  br label %bb3

bb3:                                               ; preds = %bb0, %bb1, %bb2
  %cmp = phi i1 [ false, %bb0 ], [ false, %bb1 ], [ %cmp3, %bb2 ]
  ret i1 %cmp
}

; https://alive2.llvm.org/ce/z/sL5Uz6
define noundef i1 @partial_sequent_ne(ptr nocapture readonly dereferenceable(16) %s0, ptr nocapture readonly dereferenceable(16) %s1) {
; CHECK-LABEL: @partial_sequent_ne(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    [[V0:%.*]] = load i32, ptr [[S0:%.*]], align 8
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[S1:%.*]], align 8
; CHECK-NEXT:    [[CMP0:%.*]] = icmp eq i32 [[V0]], [[V1]]
; CHECK-NEXT:    br i1 [[CMP0]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[S2:%.*]] = getelementptr inbounds [[STRUCT1_S:%.*]], ptr [[S0]], i64 0, i32 2
; CHECK-NEXT:    [[V2:%.*]] = load i32, ptr [[S2]], align 8
; CHECK-NEXT:    [[S3:%.*]] = getelementptr inbounds [[STRUCT1_S]], ptr [[S1]], i64 0, i32 2
; CHECK-NEXT:    [[V3:%.*]] = load i32, ptr [[S3]], align 8
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[V2]], [[V3]]
; CHECK-NEXT:    br i1 [[CMP1]], label [[BB2:%.*]], label [[BB3]]
; CHECK:       bb2:
; CHECK-NEXT:    [[S6:%.*]] = getelementptr inbounds [[STRUCT1_S]], ptr [[S0]], i64 0, i32 3
; CHECK-NEXT:    [[V6:%.*]] = load i8, ptr [[S6]], align 1
; CHECK-NEXT:    [[S7:%.*]] = getelementptr inbounds [[STRUCT1_S]], ptr [[S1]], i64 0, i32 3
; CHECK-NEXT:    [[V7:%.*]] = load i8, ptr [[S7]], align 1
; CHECK-NEXT:    [[CMP3:%.*]] = icmp ne i8 [[V6]], [[V7]]
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    [[CMP:%.*]] = phi i1 [ true, [[BB0:%.*]] ], [ true, [[BB1]] ], [ [[CMP3]], [[BB2]] ]
; CHECK-NEXT:    ret i1 [[CMP]]
;
bb0:
  %v0 = load i32, ptr %s0, align 8
  %v1 = load i32, ptr %s1, align 8
  %cmp0 = icmp eq i32 %v0, %v1
  br i1 %cmp0, label %bb1, label %bb3

bb1:                                              ; preds = %bb0
  %s2 = getelementptr inbounds %struct1.S, ptr %s0, i64 0, i32 2
  %v2 = load i32, ptr %s2, align 8
  %s3 = getelementptr inbounds %struct1.S, ptr %s1, i64 0, i32 2
  %v3 = load i32, ptr %s3, align 8
  %cmp1 = icmp eq i32 %v2, %v3
  br i1 %cmp1, label %bb2, label %bb3

bb2:                                               ; preds = %bb2
  %s6 = getelementptr inbounds %struct1.S, ptr %s0, i64 0, i32 3
  %v6 = load i8, ptr %s6, align 1
  %s7 = getelementptr inbounds %struct1.S, ptr %s1, i64 0, i32 3
  %v7 = load i8, ptr %s7, align 1
  %cmp3 = icmp ne i8 %v6, %v7
  br label %bb3

bb3:                                               ; preds = %bb0, %bb1, %bb2
  %cmp = phi i1 [ true, %bb0 ], [ true, %bb1 ], [ %cmp3, %bb2 ]
  ret i1 %cmp
}

; https://alive2.llvm.org/ce/z/EQtb_S
define i1 @WebrtcVideoStats(ptr nocapture noundef dereferenceable(16) %S0, ptr nocapture noundef dereferenceable(16) %S1) {
; CHECK-LABEL: @WebrtcVideoStats(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    [[V0:%.*]] = load i8, ptr [[S0:%.*]], align 4
; CHECK-NEXT:    [[V1:%.*]] = load i8, ptr [[S1:%.*]], align 4
; CHECK-NEXT:    [[CMP0:%.*]] = icmp eq i8 [[V0]], [[V1]]
; CHECK-NEXT:    br i1 [[CMP0]], label [[BB1:%.*]], label [[BB4:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[BASE2:%.*]] = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr [[S0]], i64 0, i32 1
; CHECK-NEXT:    [[V2:%.*]] = load i32, ptr [[BASE2]], align 4
; CHECK-NEXT:    [[BASE3:%.*]] = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr [[S1]], i64 0, i32 1
; CHECK-NEXT:    [[V3:%.*]] = load i32, ptr [[BASE3]], align 4
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[V2]], [[V3]]
; CHECK-NEXT:    br i1 [[CMP1]], label [[BB2:%.*]], label [[BB4]]
; CHECK:       bb2:
; CHECK-NEXT:    [[BASE4:%.*]] = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr [[S0]], i64 0, i32 2
; CHECK-NEXT:    [[V4:%.*]] = load i8, ptr [[BASE4]], align 4
; CHECK-NEXT:    [[BASE5:%.*]] = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr [[S1]], i64 0, i32 2
; CHECK-NEXT:    [[V5:%.*]] = load i8, ptr [[BASE5]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i8 [[V4]], [[V5]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[BB3:%.*]], label [[BB4]]
; CHECK:       bb3:
; CHECK-NEXT:    [[BASE6:%.*]] = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr [[S0]], i64 0, i32 3
; CHECK-NEXT:    [[V6:%.*]] = load i32, ptr [[BASE6]], align 4
; CHECK-NEXT:    [[BASE7:%.*]] = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr [[S1]], i64 0, i32 3
; CHECK-NEXT:    [[V7:%.*]] = load i32, ptr [[BASE7]], align 4
; CHECK-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[V6]], [[V7]]
; CHECK-NEXT:    br label [[BB4]]
; CHECK:       bb4:
; CHECK-NEXT:    [[RESULT:%.*]] = phi i1 [ [[CMP3]], [[BB3]] ], [ true, [[BB2]] ], [ true, [[BB1]] ], [ true, [[BB0:%.*]] ]
; CHECK-NEXT:    ret i1 [[RESULT]]
;
bb0:
  %V0 = load i8, ptr %S0, align 4
  %V1 = load i8, ptr %S1, align 4
  %Cmp0 = icmp eq i8 %V0, %V1
  br i1 %Cmp0, label %bb1, label %bb4

bb1:                                                ; preds = %bb0
  %Base2 = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr %S0, i64 0, i32 1
  %V2 = load i32, ptr %Base2, align 4
  %Base3 = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr %S1, i64 0, i32 1
  %V3 = load i32, ptr %Base3, align 4
  %Cmp1 = icmp eq i32 %V2, %V3
  br i1 %Cmp1, label %bb2, label %bb4

bb2:                                               ; preds = %bb1
  %Base4 = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr %S0, i64 0, i32 2
  %V4 = load i8, ptr %Base4, align 4
  %Base5 = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr %S1, i64 0, i32 2
  %V5 = load i8, ptr %Base5, align 4
  %Cmp2 = icmp eq i8 %V4, %V5
  br i1 %Cmp2, label %bb3, label %bb4

bb3:                                               ; preds = %bb2
  %Base6 = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr %S0, i64 0, i32 3
  %V6 = load i32, ptr %Base6, align 4
  %Base7 = getelementptr inbounds %"struct.media::WebrtcVideoStatsDB::VideoDescKey", ptr %S1, i64 0, i32 3
  %V7 = load i32, ptr %Base7, align 4
  %Cmp3 = icmp ne i32 %V6, %V7
  br label %bb4

bb4:                                               ; preds = %bb3, %bb2, %bb1, %bb0
  %result = phi i1 [ %Cmp3, %bb3 ], [ true, %bb2 ], [ true, %bb1 ], [ true, %bb0 ]
  ret i1 %result
}

; the comparison link sequence will be reordered according the memory offset,
; and the unconditionla comparison will not at the end of the chain.
define i1 @full_revert_order_ne(ptr nocapture noundef nonnull readonly dereferenceable(24) %0, ptr nocapture noundef nonnull readonly dereferenceable(24) %1) {
; CHECK-LABEL: @full_revert_order_ne(
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    [[S0:%.*]] = getelementptr inbounds [[C:%.*]], ptr [[TMP0:%.*]], i64 0, i32 2
; CHECK-NEXT:    [[V0:%.*]] = load i32, ptr [[S0]], align 4
; CHECK-NEXT:    [[S1:%.*]] = getelementptr inbounds [[C]], ptr [[TMP1:%.*]], i64 0, i32 2
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[S1]], align 4
; CHECK-NEXT:    [[CMP0:%.*]] = icmp eq i32 [[V0]], [[V1]]
; CHECK-NEXT:    br i1 [[CMP0]], label [[BB1:%.*]], label [[BB3:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[S2:%.*]] = getelementptr inbounds [[C]], ptr [[TMP0]], i64 0, i32 1
; CHECK-NEXT:    [[V2:%.*]] = load i32, ptr [[S2]], align 4
; CHECK-NEXT:    [[S3:%.*]] = getelementptr inbounds [[C]], ptr [[TMP1]], i64 0, i32 1
; CHECK-NEXT:    [[V3:%.*]] = load i32, ptr [[S3]], align 4
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[V2]], [[V3]]
; CHECK-NEXT:    br i1 [[CMP1]], label [[BB2:%.*]], label [[BB3]]
; CHECK:       bb2:
; CHECK-NEXT:    [[S4:%.*]] = getelementptr inbounds [[C]], ptr [[TMP0]], i64 0, i32 0
; CHECK-NEXT:    [[V4:%.*]] = load i32, ptr [[S4]], align 4
; CHECK-NEXT:    [[S5:%.*]] = getelementptr inbounds [[C]], ptr [[TMP1]], i64 0, i32 0
; CHECK-NEXT:    [[V5:%.*]] = load i32, ptr [[S5]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[V4]], [[V5]]
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    [[CMP3:%.*]] = phi i1 [ true, [[BB1]] ], [ true, [[BB0:%.*]] ], [ [[CMP2]], [[BB2]] ]
; CHECK-NEXT:    ret i1 [[CMP3]]
;
bb0:
  %s0 = getelementptr inbounds %"c", ptr %0, i64 0, i32 2
  %v0 = load i32, ptr %s0, align 4
  %s1 = getelementptr inbounds %"c", ptr %1, i64 0, i32 2
  %v1 = load i32, ptr %s1, align 4
  %cmp0 = icmp eq i32 %v0, %v1
  br i1 %cmp0, label %bb1, label %bb3

bb1:                                                ; preds = %bb0
  %s2 = getelementptr inbounds %"c", ptr %0, i64 0, i32 1
  %v2 = load i32, ptr %s2, align 4
  %s3 = getelementptr inbounds %"c", ptr %1, i64 0, i32 1
  %v3 = load i32, ptr %s3, align 4
  %cmp1 = icmp eq i32 %v2, %v3
  br i1 %cmp1, label %bb2, label %bb3

bb2:                                               ; preds = %bb1
  %s4 = getelementptr inbounds %"c", ptr %0, i64 0, i32 0
  %v4 = load i32, ptr %s4, align 4
  %s5 = getelementptr inbounds %"c", ptr %1, i64 0, i32 0
  %v5 = load i32, ptr %s5, align 4
  %cmp2 = icmp ne i32 %v4, %v5
  br label %bb3

bb3:                                               ; preds = %bb2, %bb1, %bb0
  %cmp3 = phi i1 [ true, %bb1 ], [ true, %bb0 ], [ %cmp2, %bb2 ]
  ret i1 %cmp3
}
