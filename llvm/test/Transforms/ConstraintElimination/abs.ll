; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

define i1 @abs_int_min_is_not_poison(i32 %arg) {
; CHECK-LABEL: define i1 @abs_int_min_is_not_poison(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 false)
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i32 [[ABS]], [[ARG]]
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 false)
  %cmp = icmp sge i32 %abs, %arg
  ret i1 %cmp
}

define i1 @abs_int_min_is_poison(i32 %arg) {
; CHECK-LABEL: define i1 @abs_int_min_is_poison(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 true)
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i32 [[ABS]], [[ARG]]
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %cmp = icmp sge i32 %abs, %arg
  ret i1 %cmp
}

define i1 @abs_plus_one(i32 %arg) {
; CHECK-LABEL: define i1 @abs_plus_one(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 true)
; CHECK-NEXT:    [[ABS_PLUS_ONE:%.*]] = add nsw i32 [[ABS]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i32 [[ABS_PLUS_ONE]], [[ARG]]
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %abs_plus_one = add nsw i32 %abs, 1
  %cmp = icmp sge i32 %abs_plus_one, %arg
  ret i1 %cmp
}

define i1 @arg_minus_one_strict_less(i32 %arg) {
; CHECK-LABEL: define i1 @arg_minus_one_strict_less(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 true)
; CHECK-NEXT:    [[ARG_MINUS_ONE:%.*]] = add nsw i32 [[ARG]], -1
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[ARG_MINUS_ONE]], [[ABS]]
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %arg_minus_one = add nsw i32 %arg, -1
  %cmp = icmp slt i32 %arg_minus_one, %abs
  ret i1 %cmp
}

define i1 @arg_minus_one_strict_greater(i32 %arg) {
; CHECK-LABEL: define i1 @arg_minus_one_strict_greater(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 true)
; CHECK-NEXT:    [[ARG_MINUS_ONE:%.*]] = add nsw i32 [[ARG]], -1
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[ARG_MINUS_ONE]], [[ABS]]
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %arg_minus_one = add nsw i32 %arg, -1
  %cmp = icmp sgt i32 %arg_minus_one, %abs
  ret i1 %cmp
}

define i1 @abs_plus_one_unsigned_greater_or_equal_nonnegative_arg(i32 %arg) {
; CHECK-LABEL: define i1 @abs_plus_one_unsigned_greater_or_equal_nonnegative_arg(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[CMP_ARG_NONNEGATIVE:%.*]] = icmp sge i32 [[ARG]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP_ARG_NONNEGATIVE]])
; CHECK-NEXT:    [[ABS_PLUS_ONE:%.*]] = add nuw i32 [[ARG]], 1
; CHECK-NEXT:    ret i1 true
;
  %cmp_arg_nonnegative = icmp sge i32 %arg, 0
  call void @llvm.assume(i1 %cmp_arg_nonnegative)
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %abs_plus_one = add nuw i32 %abs, 1
  %cmp = icmp uge i32 %abs_plus_one, %arg
  ret i1 %cmp
}

define i1 @abs_plus_one_unsigned_greater_or_equal_cannot_be_simplified(i32 %arg) {
; CHECK-LABEL: define i1 @abs_plus_one_unsigned_greater_or_equal_cannot_be_simplified(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 true)
; CHECK-NEXT:    [[ABS_PLUS_ONE:%.*]] = add nuw i32 [[ABS]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[ABS_PLUS_ONE]], [[ARG]]
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %abs_plus_one = add nuw i32 %abs, 1
  %cmp = icmp uge i32 %abs_plus_one, %arg
  ret i1 %cmp
}

define i1 @abs_constant_negative_arg() {
; CHECK-LABEL: define i1 @abs_constant_negative_arg() {
; CHECK-NEXT:    ret i1 true
;
  %abs = tail call i32 @llvm.abs.i32(i32 -3, i1 false)
  %cmp = icmp sge i32 %abs, 3
  ret i1 %cmp
}

define i1 @abs_constant_positive_arg() {
; CHECK-LABEL: define i1 @abs_constant_positive_arg() {
; CHECK-NEXT:    ret i1 true
;
  %abs = tail call i32 @llvm.abs.i32(i32 3, i1 false)
  %cmp = icmp sge i32 %abs, 3
  ret i1 %cmp
}

define i1 @abs_is_nonnegative_except_for_int_min_if_int_min_is_not_poison(i32 %arg) {
; CHECK-LABEL: define i1 @abs_is_nonnegative_except_for_int_min_if_int_min_is_not_poison(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 false)
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i32 [[ABS]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 false)
  %cmp = icmp sge i32 %abs, 0
  ret i1 %cmp
}

define i1 @abs_is_not_strictly_positive(i32 %arg) {
; CHECK-LABEL: define i1 @abs_is_not_strictly_positive(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 true)
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[ABS]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %cmp = icmp sgt i32 %abs, 0
  ret i1 %cmp
}

define i1 @abs_is_nonnegative_int_min_is_poison(i32 %arg) {
; CHECK-LABEL: define i1 @abs_is_nonnegative_int_min_is_poison(
; CHECK-SAME: i32 [[ARG:%.*]]) {
; CHECK-NEXT:    [[ABS:%.*]] = tail call i32 @llvm.abs.i32(i32 [[ARG]], i1 true)
; CHECK-NEXT:    [[CMP:%.*]] = icmp sge i32 [[ABS]], 0
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %abs = tail call i32 @llvm.abs.i32(i32 %arg, i1 true)
  %cmp = icmp sge i32 %abs, 0
  ret i1 %cmp
}

define i1 @abs_is_nonnegative_constant_arg() {
; CHECK-LABEL: define i1 @abs_is_nonnegative_constant_arg() {
; CHECK-NEXT:    ret i1 true
;
  %abs = tail call i32 @llvm.abs.i32(i32 -3, i1 true)
  %cmp = icmp sge i32 %abs, 0
  ret i1 %cmp
}

define i64 @abs_assume_nonnegative(i64 %arg) {
; CHECK-LABEL: define i64 @abs_assume_nonnegative(
; CHECK-SAME: i64 [[ARG:%.*]]) {
; CHECK-NEXT:    [[PRECOND:%.*]] = icmp sge i64 [[ARG]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[PRECOND]])
; CHECK-NEXT:    ret i64 [[ARG]]
;
  %precond = icmp sge i64 %arg, 0
  call void @llvm.assume(i1 %precond)
  %abs = tail call i64 @llvm.abs.i64(i64 %arg, i1 false)
  ret i64 %abs
}

define i64 @abs_assume_negative(i64 %arg) {
; CHECK-LABEL: define i64 @abs_assume_negative(
; CHECK-SAME: i64 [[ARG:%.*]]) {
; CHECK-NEXT:    [[PRECOND:%.*]] = icmp slt i64 [[ARG]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[PRECOND]])
; CHECK-NEXT:    [[ABS:%.*]] = sub i64 0, [[ARG]]
; CHECK-NEXT:    ret i64 [[ABS]]
;
  %precond = icmp slt i64 %arg, 0
  call void @llvm.assume(i1 %precond)
  %abs = tail call i64 @llvm.abs.i64(i64 %arg, i1 false)
  ret i64 %abs
}

; Negative test
define i64 @abs_assume_unrelated(i64 %arg) {
; CHECK-LABEL: define i64 @abs_assume_unrelated(
; CHECK-SAME: i64 [[ARG:%.*]]) {
; CHECK-NEXT:    [[PRECOND:%.*]] = icmp slt i64 [[ARG]], 3
; CHECK-NEXT:    call void @llvm.assume(i1 [[PRECOND]])
; CHECK-NEXT:    [[ABS:%.*]] = tail call i64 @llvm.abs.i64(i64 [[ARG]], i1 false)
; CHECK-NEXT:    ret i64 [[ABS]]
;
  %precond = icmp slt i64 %arg, 3
  call void @llvm.assume(i1 %precond)
  %abs = tail call i64 @llvm.abs.i64(i64 %arg, i1 false)
  ret i64 %abs
}

declare i32 @llvm.abs.i32(i32, i1 immarg)
declare void @llvm.assume(i1)
