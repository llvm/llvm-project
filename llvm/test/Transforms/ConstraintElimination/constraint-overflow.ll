; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

define i32 @f(i64 %a3, i64 %numElements) {
; CHECK-LABEL: define i32 @f(
; CHECK-SAME: i64 [[A3:%.*]], i64 [[NUMELEMENTS:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp ule i64 [[NUMELEMENTS]], 1152921504606846975
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    [[A1:%.*]] = shl nuw i64 [[NUMELEMENTS]], 4
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i64 [[A1]], [[A3]]
; CHECK-NEXT:    br i1 [[CMP]], label [[IF_END_I:%.*]], label [[ABORT:%.*]]
; CHECK:       if.end.i:
; CHECK-NEXT:    [[CMP2_NOT_I:%.*]] = icmp ult i64 [[A1]], [[A3]]
; CHECK-NEXT:    br i1 [[CMP2_NOT_I]], label [[ABORT]], label [[EXIT:%.*]]
; CHECK:       abort:
; CHECK-NEXT:    ret i32 -1
; CHECK:       exit:
; CHECK-NEXT:    ret i32 0
;
entry:
  %cond = icmp ule i64 %numElements, 1152921504606846975
  call void @llvm.assume(i1 %cond)
  %a1 = shl nuw i64 %numElements, 4
  br label %if.end
if.end:
  %cmp = icmp ugt i64 %a1, %a3
  br i1 %cmp, label %if.end.i, label %abort
if.end.i:
  %cmp2.not.i = icmp ult i64 %a1, %a3
  br i1 %cmp2.not.i, label %abort, label %exit
abort:
  ret i32 -1
exit:
  ret i32 0
}

declare void @llvm.assume(i1)

define i1 @negate_overflow_add_1(i64 %x) {
; CHECK-LABEL: define i1 @negate_overflow_add_1(
; CHECK-SAME: i64 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB:%.*]] = add nsw i64 [[X]], -9223372036854775807
; CHECK-NEXT:    [[C:%.*]] = icmp slt i64 0, [[SUB]]
; CHECK-NEXT:    ret i1 [[C]]
;
entry:
  %sub = add nsw i64 %x, -9223372036854775807
  %c = icmp slt i64 0, %sub
  ret i1 %c
}

define i1 @pr140481(i32 %x) {
; CHECK-LABEL: define i1 @pr140481(
; CHECK-SAME: i32 [[X:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[COND:%.*]] = icmp slt i32 [[X]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[X]], 5001000
; CHECK-NEXT:    [[MUL1:%.*]] = mul nsw i32 [[ADD]], -5001000
; CHECK-NEXT:    [[MUL2:%.*]] = mul nsw i32 [[MUL1]], 5001000
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[MUL2]], 0
; CHECK-NEXT:    ret i1 [[CMP2]]
;
entry:
  %cond = icmp slt i32 %x, 0
  call void @llvm.assume(i1 %cond)
  %add = add nsw i32 %x, 5001000
  %mul1 = mul nsw i32 %add, -5001000
  %mul2 = mul nsw i32 %mul1, 5001000
  %cmp2 = icmp sgt i32 %mul2, 0
  ret i1 %cmp2
}
