; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

declare void @llvm.assume(i1 noundef) #0

@arr1 = common global [3 x i16] zeroinitializer, align 2

define i1 @gep_constexpr_index_lt_upper(i32 noundef %i) {
; CHECK-LABEL: @gep_constexpr_index_lt_upper(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I:%.*]], 3
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext i32 [[I]] to i64
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds i16, ptr @arr1, i64 [[IDXPROM]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[UPPER]], getelementptr inbounds ([3 x i16], ptr @arr1, i64 1, i64 0)
; CHECK-NEXT:    ret i1 true
;
entry:
  %cmp = icmp ult i32 %i, 3
  call void @llvm.assume(i1 %cmp)
  %idxprom = zext i32 %i to i64
  %upper = getelementptr inbounds i16, ptr @arr1, i64 %idxprom
  %c.1 = icmp ult ptr %upper, getelementptr inbounds ([3 x i16], ptr @arr1, i64 1, i64 0)
  ret i1 %c.1
}

define i1 @gep_constexpr_index_may_be_gt_upper(i32 noundef %i) {
; CHECK-LABEL: @gep_constexpr_index_may_be_gt_upper(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I:%.*]], 3
; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext i32 [[I]] to i64
; CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds i16, ptr @arr1, i64 [[IDXPROM]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[UPPER]], getelementptr inbounds ([3 x i16], ptr @arr1, i64 0, i64 2)
; CHECK-NEXT:    ret i1 [[C_1]]
;
entry:
  %cmp = icmp ult i32 %i, 3
  call void @llvm.assume(i1 %cmp)
  %idxprom = zext i32 %i to i64
  %upper = getelementptr inbounds i16, ptr @arr1, i64 %idxprom
  %c.1 = icmp ult ptr %upper, getelementptr inbounds ([3 x i16], ptr @arr1, i64 0, i64 2)
  ret i1 %c.1
}
