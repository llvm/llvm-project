; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

declare void @may_unwind()

define i1 @test_switch_in_block_with_assume(i8 %x) {
; CHECK-LABEL: @test_switch_in_block_with_assume(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @may_unwind()
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult i8 [[X:%.*]], 10
; CHECK-NEXT:    call void @llvm.assume(i1 [[C_1]])
; CHECK-NEXT:    switch i8 0, label [[EXIT_1:%.*]] [
; CHECK-NEXT:    i8 1, label [[EXIT_2:%.*]]
; CHECK-NEXT:    ]
; CHECK:       exit.1:
; CHECK-NEXT:    [[C_2:%.*]] = icmp ult i8 [[X]], 9
; CHECK-NEXT:    [[RES_1:%.*]] = xor i1 true, [[C_2]]
; CHECK-NEXT:    ret i1 [[RES_1]]
; CHECK:       exit.2:
; CHECK-NEXT:    [[C_3:%.*]] = icmp ult i8 [[X]], 9
; CHECK-NEXT:    [[RES_2:%.*]] = xor i1 true, [[C_3]]
; CHECK-NEXT:    ret i1 [[RES_2]]
;
entry:
  call void @may_unwind()
  %c.1 = icmp ult i8 %x, 10
  call void @llvm.assume(i1 %c.1)
  switch i8 0, label %exit.1 [
  i8 1, label %exit.2
  ]

exit.1:
  %t.1 = icmp ult i8 %x, 10
  %c.2 = icmp ult i8 %x, 9
  %res.1 = xor i1 %t.1, %c.2
  ret i1 %res.1

exit.2:
  %t.2 = icmp ult i8 %x, 10
  %c.3 = icmp ult i8 %x, 9
  %res.2 = xor i1 %t.2, %c.3
  ret i1 %res.2
}

declare void @llvm.assume(i1)

define i1 @simplify_based_on_switch(i8 %x) {
; CHECK-LABEL: @simplify_based_on_switch(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i8 [[X:%.*]], label [[EXIT_1:%.*]] [
; CHECK-NEXT:    i8 6, label [[EXIT_2:%.*]]
; CHECK-NEXT:    i8 10, label [[EXIT_3:%.*]]
; CHECK-NEXT:    ]
; CHECK:       exit.1:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult i8 [[X]], 7
; CHECK-NEXT:    [[C_2:%.*]] = icmp ult i8 [[X]], 6
; CHECK-NEXT:    [[RES_1:%.*]] = xor i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    ret i1 [[RES_1]]
; CHECK:       exit.2:
; CHECK-NEXT:    [[RES_2:%.*]] = xor i1 true, false
; CHECK-NEXT:    ret i1 [[RES_2]]
; CHECK:       exit.3:
; CHECK-NEXT:    [[RES_3:%.*]] = xor i1 true, false
; CHECK-NEXT:    ret i1 [[RES_3]]
;
entry:
  switch i8 %x, label %exit.1 [
  i8 6, label %exit.2
  i8 10, label %exit.3
  ]

exit.1:
  %c.1 = icmp ult i8 %x, 7
  %c.2 = icmp ult i8 %x, 6
  %res.1 = xor i1 %c.1, %c.2
  ret i1 %res.1

exit.2:
  %t.1 = icmp ult i8 %x, 7
  %f.1 = icmp ult i8 %x, 6
  %res.2 = xor i1 %t.1, %f.1
  ret i1 %res.2

exit.3:
  %t.2 = icmp ult i8 %x, 11
  %f.2 = icmp ult i8 %x, 10
  %res.3 = xor i1 %t.2, %f.2
  ret i1 %res.3
}

define i1 @simplify_based_on_switch_successor_branches(i8 %x) {
; CHECK-LABEL: @simplify_based_on_switch_successor_branches(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i8 [[X:%.*]], label [[EXIT_1:%.*]] [
; CHECK-NEXT:    i8 6, label [[EXIT_2:%.*]]
; CHECK-NEXT:    i8 10, label [[EXIT_3:%.*]]
; CHECK-NEXT:    ]
; CHECK:       exit.1:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult i8 [[X]], 7
; CHECK-NEXT:    [[C_2:%.*]] = icmp ult i8 [[X]], 6
; CHECK-NEXT:    [[RES_1:%.*]] = xor i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    ret i1 [[RES_1]]
; CHECK:       exit.2:
; CHECK-NEXT:    [[RES_2:%.*]] = xor i1 true, false
; CHECK-NEXT:    call void @use(i1 [[RES_2]])
; CHECK-NEXT:    br label [[EXIT_3]]
; CHECK:       exit.3:
; CHECK-NEXT:    [[C_3:%.*]] = icmp ult i8 [[X]], 11
; CHECK-NEXT:    [[C_4:%.*]] = icmp ult i8 [[X]], 10
; CHECK-NEXT:    [[RES_3:%.*]] = xor i1 [[C_3]], [[C_4]]
; CHECK-NEXT:    ret i1 [[RES_3]]
;
entry:
  switch i8 %x, label %exit.1 [
  i8 6, label %exit.2
  i8 10, label %exit.3
  ]

exit.1:
  %c.1 = icmp ult i8 %x, 7
  %c.2 = icmp ult i8 %x, 6
  %res.1 = xor i1 %c.1, %c.2
  ret i1 %res.1

exit.2:
  %t.1 = icmp ult i8 %x, 7
  %f.1 = icmp ult i8 %x, 6
  %res.2 = xor i1 %t.1, %f.1
  call void @use(i1 %res.2)
  br label %exit.3

exit.3:
  %c.3 = icmp ult i8 %x, 11
  %c.4 = icmp ult i8 %x, 10
  %res.3 = xor i1 %c.3, %c.4
  ret i1 %res.3
}

define i1 @switch_same_destination_for_different_cases(i8 %x) {
; CHECK-LABEL: @switch_same_destination_for_different_cases(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    switch i8 [[X:%.*]], label [[EXIT_1:%.*]] [
; CHECK-NEXT:    i8 6, label [[EXIT_2:%.*]]
; CHECK-NEXT:    i8 10, label [[EXIT_2]]
; CHECK-NEXT:    ]
; CHECK:       exit.1:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult i8 [[X]], 7
; CHECK-NEXT:    [[C_2:%.*]] = icmp ult i8 [[X]], 6
; CHECK-NEXT:    [[RES_1:%.*]] = xor i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    ret i1 [[RES_1]]
; CHECK:       exit.2:
; CHECK-NEXT:    [[C_3:%.*]] = icmp ult i8 [[X]], 7
; CHECK-NEXT:    call void @use(i1 [[C_3]])
; CHECK-NEXT:    call void @use(i1 false)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[C_6:%.*]] = icmp ult i8 [[X]], 10
; CHECK-NEXT:    ret i1 [[C_6]]
;
entry:
  switch i8 %x, label %exit.1 [
  i8 6, label %exit.2
  i8 10, label %exit.2
  ]

exit.1:
  %c.1 = icmp ult i8 %x, 7
  %c.2 = icmp ult i8 %x, 6
  %res.1 = xor i1 %c.1, %c.2
  ret i1 %res.1

exit.2:
  %c.3 = icmp ult i8 %x, 7
  call void @use(i1 %c.3)
  %c.4 = icmp ult i8 %x, 6
  call void @use(i1 %c.4)
  %c.5 = icmp ult i8 %x, 11
  call void @use(i1 %c.5)
  %c.6 = icmp ult i8 %x, 10
  ret i1 %c.6
}

define i1 @test_switch_with_same_dest(i32 %a) {
; CHECK-LABEL: @test_switch_with_same_dest(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[B:%.*]] = and i32 [[A:%.*]], 1023
; CHECK-NEXT:    switch i32 [[B]], label [[SW_DEFAULT:%.*]] [
; CHECK-NEXT:      i32 37, label [[SW_BB:%.*]]
; CHECK-NEXT:      i32 38, label [[SW_BB]]
; CHECK-NEXT:    ]
; CHECK:       sw.bb:
; CHECK-NEXT:    ret i1 false
; CHECK:       sw.default:
; CHECK-NEXT:    ret i1 false
;
entry:
  %b = and i32 %a, 1023
  switch i32 %b, label %sw.default [
  i32 37, label %sw.bb
  i32 38, label %sw.bb
  ]

sw.bb:
  %cmp = icmp eq i32 %b, 1023
  ret i1 %cmp
sw.default:
  ret i1 false
}

define i1 @test_switch_with_same_dest_zext(i16 %a) {
; CHECK-LABEL: @test_switch_with_same_dest_zext(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[B:%.*]] = and i16 [[A:%.*]], 1023
; CHECK-NEXT:    [[B_EXT:%.*]] = zext nneg i16 [[B]] to i32
; CHECK-NEXT:    switch i32 [[B_EXT]], label [[SW_DEFAULT:%.*]] [
; CHECK-NEXT:      i32 37, label [[SW_BB:%.*]]
; CHECK-NEXT:      i32 38, label [[SW_BB]]
; CHECK-NEXT:    ]
; CHECK:       sw.bb:
; CHECK-NEXT:    ret i1 false
; CHECK:       sw.default:
; CHECK-NEXT:    ret i1 false
;
entry:
  %b = and i16 %a, 1023
  %b.ext = zext nneg i16 %b to i32
  switch i32 %b.ext, label %sw.default [
  i32 37, label %sw.bb
  i32 38, label %sw.bb
  ]

sw.bb:
  %cmp = icmp eq i16 %b, 1023
  ret i1 %cmp
sw.default:
  ret i1 false
}

; Negative tests

define i1 @test_switch_with_same_dest_fail1(i32 %a) {
; CHECK-LABEL: @test_switch_with_same_dest_fail1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[B:%.*]] = and i32 [[A:%.*]], 1023
; CHECK-NEXT:    switch i32 [[B]], label [[SW_BB:%.*]] [
; CHECK-NEXT:      i32 37, label [[SW_BB]]
; CHECK-NEXT:      i32 38, label [[SW_BB]]
; CHECK-NEXT:    ]
; CHECK:       sw.bb:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[B]], 1023
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  %b = and i32 %a, 1023
  switch i32 %b, label %sw.bb [
  i32 37, label %sw.bb
  i32 38, label %sw.bb
  ]

sw.bb:
  %cmp = icmp eq i32 %b, 1023
  ret i1 %cmp
}

define i1 @test_switch_with_same_dest_fail2(i32 %a, i1 %cond) {
; CHECK-LABEL: @test_switch_with_same_dest_fail2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[B:%.*]] = and i32 [[A:%.*]], 1023
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[IF_THEN:%.*]], label [[SW_BB:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    switch i32 [[B]], label [[SW_BB]] [
; CHECK-NEXT:      i32 37, label [[SW_BB]]
; CHECK-NEXT:      i32 38, label [[SW_BB]]
; CHECK-NEXT:    ]
; CHECK:       sw.bb:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[B]], 1023
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  %b = and i32 %a, 1023
  br i1 %cond, label %if.then, label %sw.bb

if.then:
  switch i32 %b, label %sw.bb [
  i32 37, label %sw.bb
  i32 38, label %sw.bb
  ]

sw.bb:
  %cmp = icmp eq i32 %b, 1023
  ret i1 %cmp
}

declare void @use(i1)
