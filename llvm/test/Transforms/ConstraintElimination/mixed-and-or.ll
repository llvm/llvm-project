; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

declare void @use(i1)

define void @test_decompose_mixed_bitwise_and_or(i4 %x, i4 %y, i4 %z) {
; CHECK-LABEL: @test_decompose_mixed_bitwise_and_or(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND_1:%.*]] = and i4 [[Y:%.*]], [[X:%.*]]
; CHECK-NEXT:    [[OR_1:%.*]] = or i4 [[AND_1]], [[Z:%.*]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp sgt i4 [[OR_1]], -1
; CHECK-NEXT:    br i1 [[C_1]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[C_2:%.*]] = icmp sgt i4 [[X]], -1
; CHECK-NEXT:    [[C_3:%.*]] = icmp sgt i4 [[Y]], -1
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    call void @use(i1 [[C_3]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    ret void
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %and.1 = and i4 %y, %x
  %or.1 = or i4 %and.1, %z
  %c.1= icmp sgt i4 %or.1, -1
  br i1 %c.1, label %then, label %end

then:
  ; fact: %or.1 > -1 => %and.1 >= 0 && %z >= 0
  ; %and.1 >= 0 => %x >= 0 || %y >= 0 (constraint system doesn't support logical OR)
  %c.2 = icmp sgt i4 %x, -1
  %c.3 = icmp sgt i4 %y, -1
  %t.1 = icmp sgt i4 %z, -1
  call void @use(i1 %c.2)
  call void @use(i1 %c.3)
  ; only %t.1 can be replaced
  call void @use(i1 %t.1)
  ret void

end:
  ret void
}

define void @test_decompose_mixed_bitwise_and_or2(i4 %x, i4 %y, i4 %z) {
; CHECK-LABEL: @test_decompose_mixed_bitwise_and_or2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND_1:%.*]] = and i4 [[Y:%.*]], [[X:%.*]]
; CHECK-NEXT:    [[OR_1:%.*]] = or i4 [[AND_1]], [[Z:%.*]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp slt i4 [[OR_1]], 0
; CHECK-NEXT:    br i1 [[C_1]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret void
; CHECK:       end:
; CHECK-NEXT:    [[C_2:%.*]] = icmp sgt i4 [[X]], -1
; CHECK-NEXT:    [[C_3:%.*]] = icmp sgt i4 [[Y]], -1
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    call void @use(i1 [[C_3]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    ret void
;
entry:
  %and.1 = and i4 %y, %x
  %or.1 = or i4 %and.1, %z
  %c.1 = icmp slt i4 %or.1, 0
  br i1 %c.1, label %then, label %end

then:
  ; fact: %or.1 < 0
  ret void

end:
  ; fact: %or.1 >= 0 => %and.1 >= 0 && %z >= 0
  ; %and.1 >= 0 => %x >= 0 || %y >= 0 (constraint system doesn't support logical OR)
  %c.2 = icmp sgt i4 %x, -1
  %c.3 = icmp sgt i4 %y, -1
  %t.1 = icmp sgt i4 %z, -1
  call void @use(i1 %c.2)
  call void @use(i1 %c.3)
  ; only %t.1 can be replaced
  call void @use(i1 %t.1)
  ret void
}

define void @test_decompose_mixed_bitwise_and_or3(i4 %x, i4 %y, i4 %z) {
; CHECK-LABEL: @test_decompose_mixed_bitwise_and_or3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OR_1:%.*]] = or i4 [[Y:%.*]], [[X:%.*]]
; CHECK-NEXT:    [[AND_1:%.*]] = and i4 [[OR_1]], [[Z:%.*]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp slt i4 [[AND_1]], 0
; CHECK-NEXT:    br i1 [[C_1]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[C_2:%.*]] = icmp slt i4 [[X]], 0
; CHECK-NEXT:    [[C_3:%.*]] = icmp slt i4 [[Y]], 0
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    call void @use(i1 [[C_3]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    ret void
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %or.1 = or i4 %y, %x
  %and.1 = and i4 %or.1, %z
  %c.1= icmp slt i4 %and.1, 0
  br i1 %c.1, label %then, label %end

then:
  ; fact: %and.1 < 0 => %or.1 < 0 && %z < 0
  ; %or.1 < 0 => %x < 0 || %y < 0 (constraint system doesn't support logical OR)
  %c.2 = icmp slt i4 %x, 0
  %c.3 = icmp slt i4 %y, 0
  %t.1 = icmp slt i4 %z, 0
  call void @use(i1 %c.2)
  call void @use(i1 %c.3)
  ; only %t.1 can be replaced
  call void @use(i1 %t.1)
  ret void

end:
  ret void
}

define void @test_decompose_mixed_bitwise_and_or4(i4 %x, i4 %y, i4 %z) {
; CHECK-LABEL: @test_decompose_mixed_bitwise_and_or4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OR_1:%.*]] = or i4 [[Y:%.*]], [[X:%.*]]
; CHECK-NEXT:    [[AND_1:%.*]] = and i4 [[OR_1]], [[Z:%.*]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp sgt i4 [[AND_1]], -1
; CHECK-NEXT:    br i1 [[C_1]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret void
; CHECK:       end:
; CHECK-NEXT:    [[C_2:%.*]] = icmp slt i4 [[X]], 0
; CHECK-NEXT:    [[C_3:%.*]] = icmp slt i4 [[Y]], 0
; CHECK-NEXT:    call void @use(i1 [[C_2]])
; CHECK-NEXT:    call void @use(i1 [[C_3]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    ret void
;
entry:
  %or.1 = or i4 %y, %x
  %and.1 = and i4 %or.1, %z
  %c.1 = icmp sgt i4 %and.1, -1
  br i1 %c.1, label %then, label %end

then:
  ; fact: %and.1 > -1
  ret void

end:
  ; fact: %and.1 <= -1 => %or.1 < 0 && %z < 0
  ; %or.1 < 0 => %x < 0 || %y < 0 (constraint system doesn't support logical OR)
  %c.2 = icmp slt i4 %x, 0
  %c.3 = icmp slt i4 %y, 0
  %t.1 = icmp slt i4 %z, 0
  call void @use(i1 %c.2)
  call void @use(i1 %c.3)
  ; only %t.1 can be replaced
  call void @use(i1 %t.1)
  ret void
}
