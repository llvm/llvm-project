; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

define i1 @masked_value_bounds(i32 %x) {
; CHECK-LABEL: @masked_value_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[MASKED:%.*]] = and i32 [[X:%.*]], 15
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i32 [[MASKED]], 20
; CHECK-NEXT:    br i1 [[COND]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %masked = and i32 %x, 15
  %cond = icmp ult i32 %masked, 20
  br i1 %cond, label %then, label %else

then:
  %cmp.redundant = icmp ult i32 %masked, 16
  ret i1 %cmp.redundant

else:
  %res = icmp ult i32 %masked, 10
  ret i1 %res
}

define i1 @and_power_of_two_bounds(i32 %x) {
; CHECK-LABEL: @and_power_of_two_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[AND:%.*]] = and i32 [[X:%.*]], 127
; CHECK-NEXT:    [[COND:%.*]] = icmp sgt i32 [[AND]], -1
; CHECK-NEXT:    br i1 [[COND]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    [[RES:%.*]] = icmp slt i32 [[AND]], 64
; CHECK-NEXT:    ret i1 [[RES]]
;
entry:
  %and = and i32 %x, 127
  %cond = icmp sgt i32 %and, -1
  br i1 %cond, label %then, label %else

then:
  %cmp.redundant = icmp slt i32 %and, 128
  ret i1 %cmp.redundant

else:
  %res = icmp slt i32 %and, 64
  ret i1 %res
}

define i1 @shift_bounds(i8 %x) {
; CHECK-LABEL: @shift_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BOUNDED:%.*]] = and i8 [[X:%.*]], 7
; CHECK-NEXT:    [[SHL:%.*]] = shl i8 [[BOUNDED]], 2
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i8 [[SHL]], 40
; CHECK-NEXT:    br i1 [[COND]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %bounded = and i8 %x, 7
  %shl = shl i8 %bounded, 2
  %cond = icmp ult i8 %shl, 40
  br i1 %cond, label %then, label %else

then:
  %cmp.redundant = icmp ult i8 %shl, 32
  ret i1 %cmp.redundant

else:
  %res = icmp eq i8 %shl, 0
  ret i1 %res
}

define i1 @or_minimum_bounds(i16 %x) {
; CHECK-LABEL: @or_minimum_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OR:%.*]] = or i16 [[X:%.*]], 48
; CHECK-NEXT:    [[COND:%.*]] = icmp ugt i16 [[OR]], 40
; CHECK-NEXT:    br i1 [[COND]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %or = or i16 %x, 48
  %cond = icmp ugt i16 %or, 40
  br i1 %cond, label %then, label %else

then:
  %cmp.redundant = icmp ugt i16 %or, 47
  ret i1 %cmp.redundant

else:
  %res = icmp ult i16 %or, 48
  ret i1 %res
}

define i1 @nested_and_operations(i32 %x) {
; CHECK-LABEL: @nested_and_operations(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[MASK1:%.*]] = and i32 [[X:%.*]], 255
; CHECK-NEXT:    [[MASK2:%.*]] = and i32 [[MASK1]], 63
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i32 [[MASK2]], 70
; CHECK-NEXT:    br i1 [[COND]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %mask1 = and i32 %x, 255
  %mask2 = and i32 %mask1, 63
  %cond = icmp ult i32 %mask2, 70
  br i1 %cond, label %then, label %else

then:
  %cmp.redundant = icmp ult i32 %mask2, 64
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i32 %mask2, 63
  ret i1 %res
}

define i1 @right_shift_bounds(i16 %x) {
; CHECK-LABEL: @right_shift_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LARGE:%.*]] = or i16 [[X:%.*]], 512
; CHECK-NEXT:    [[SHR:%.*]] = lshr i16 [[LARGE]], 3
; CHECK-NEXT:    [[COND:%.*]] = icmp ugt i16 [[SHR]], 50
; CHECK-NEXT:    br i1 [[COND]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %large = or i16 %x, 512
  %shr = lshr i16 %large, 3
  %cond = icmp ugt i16 %shr, 50
  br i1 %cond, label %then, label %else

then:
  %cmp.redundant = icmp ugt i16 %shr, 63
  ret i1 %cmp.redundant

else:
  %res = icmp ult i16 %shr, 64
  ret i1 %res
}

define i1 @multiply_bounds(i8 %x) {
; CHECK-LABEL: @multiply_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SMALL:%.*]] = and i8 [[X:%.*]], 3
; CHECK-NEXT:    [[MUL:%.*]] = mul i8 [[SMALL]], 5
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i8 [[MUL]], 20
; CHECK-NEXT:    br i1 [[COND]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %small = and i8 %x, 3
  %mul = mul i8 %small, 5
  %cond = icmp ult i8 %mul, 20
  br i1 %cond, label %then, label %else

then:
  %cmp.redundant = icmp ult i8 %mul, 16
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i8 %mul, 15
  ret i1 %res
}

define i1 @select_bounded_values(i32 %x, i1 %cond) {
; CHECK-LABEL: @select_bounded_values(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = and i32 [[X:%.*]], 7
; CHECK-NEXT:    [[B:%.*]] = and i32 [[X]], 15
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND:%.*]], i32 [[A]], i32 [[B]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[SEL]], 20
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %a = and i32 %x, 7
  %b = and i32 %x, 15
  %sel = select i1 %cond, i32 %a, i32 %b
  %cmp = icmp ult i32 %sel, 20
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp ult i32 %sel, 16
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i32 %sel, 15
  ret i1 %res
}

define i1 @phi_bounded_values(i32 %x, i1 %cond) {
; CHECK-LABEL: @phi_bounded_values(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[PATH1:%.*]], label [[PATH2:%.*]]
; CHECK:       path1:
; CHECK-NEXT:    [[VAL1:%.*]] = and i32 [[X:%.*]], 15
; CHECK-NEXT:    br label [[MERGE:%.*]]
; CHECK:       path2:
; CHECK-NEXT:    [[VAL2:%.*]] = and i32 [[X]], 7
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[VAL1]], [[PATH1]] ], [ [[VAL2]], [[PATH2]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[PHI]], 20
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  br i1 %cond, label %path1, label %path2

path1:
  %val1 = and i32 %x, 15
  br label %merge

path2:
  %val2 = and i32 %x, 7
  br label %merge

merge:
  %phi = phi i32 [ %val1, %path1 ], [ %val2, %path2 ]
  %cmp = icmp ult i32 %phi, 20
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp ult i32 %phi, 16
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i32 %phi, 15
  ret i1 %res
}

define i1 @phi_loop_bounded(i32 %n) {
; CHECK-LABEL: @phi_loop_bounded(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BOUND_N:%.*]] = and i32 [[N:%.*]], 7
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[I_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i32 [[I]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_NEXT]], [[BOUND_N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[FINAL_CMP:%.*]] = icmp ult i32 [[I]], 10
; CHECK-NEXT:    br i1 [[FINAL_CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[CMP_REDUNDANT:%.*]] = icmp ult i32 [[I]], 8
; CHECK-NEXT:    ret i1 [[CMP_REDUNDANT]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %bound.n = and i32 %n, 7
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %i.next = add nuw nsw i32 %i, 1
  %cmp = icmp ult i32 %i.next, %bound.n
  br i1 %cmp, label %loop, label %exit

exit:
  %final.cmp = icmp ult i32 %i, 10
  br i1 %final.cmp, label %then, label %else

then:
  %cmp.redundant = icmp ult i32 %i, 8
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i32 %i, 7
  ret i1 %res
}

define i1 @zext_bounds_i8_to_i32(i8 %x) {
; CHECK-LABEL: @zext_bounds_i8_to_i32(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SMALL:%.*]] = and i8 [[X:%.*]], 31
; CHECK-NEXT:    [[EXTENDED:%.*]] = zext i8 [[SMALL]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[EXTENDED]], 40
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %small = and i8 %x, 31
  %extended = zext i8 %small to i32
  %cmp = icmp ult i32 %extended, 40
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp ult i32 %extended, 32
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i32 %extended, 31
  ret i1 %res
}

define i1 @sext_bounds_negative_check(i8 %x) {
; CHECK-LABEL: @sext_bounds_negative_check(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SMALL:%.*]] = and i8 [[X:%.*]], 63
; CHECK-NEXT:    [[EXTENDED:%.*]] = sext i8 [[SMALL]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[EXTENDED]], -1
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %small = and i8 %x, 63
  %extended = sext i8 %small to i32
  %cmp = icmp sgt i32 %extended, -1
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp sgt i32 %extended, -1
  ret i1 %cmp.redundant

else:
  %res = icmp slt i32 %extended, 0
  ret i1 %res
}

define i1 @zext_from_i1(i1 %flag) {
; CHECK-LABEL: @zext_from_i1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[EXTENDED:%.*]] = zext i1 [[FLAG:%.*]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[EXTENDED]], 5
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[CMP_REDUNDANT:%.*]] = icmp ult i32 [[EXTENDED]], 2
; CHECK-NEXT:    ret i1 [[CMP_REDUNDANT]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %extended = zext i1 %flag to i32
  %cmp = icmp ult i32 %extended, 5
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp ult i32 %extended, 2
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i32 %extended, 1
  ret i1 %res
}

define i1 @trunc_bounds_i32_to_i8(i32 %x) {
; CHECK-LABEL: @trunc_bounds_i32_to_i8(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SMALL:%.*]] = and i32 [[X:%.*]], 63
; CHECK-NEXT:    [[TRUNCATED:%.*]] = trunc i32 [[SMALL]] to i8
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i8 [[TRUNCATED]], 100
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %small = and i32 %x, 63
  %truncated = trunc i32 %small to i8
  %cmp = icmp ult i8 %truncated, 100
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp ult i8 %truncated, 64
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i8 %truncated, 63
  ret i1 %res
}

define i1 @trunc_nsw_bounds(i32 %x) {
; CHECK-LABEL: @trunc_nsw_bounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[MASKED:%.*]] = and i32 [[X:%.*]], 127
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc nsw i32 [[MASKED]] to i8
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i8 [[TRUNC]], 100
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %masked = and i32 %x, 127
  %trunc = trunc nsw i32 %masked to i8
  %cmp = icmp slt i8 %trunc, 100
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp sgt i8 %trunc, -1
  ret i1 %cmp.redundant

else:
  %res = icmp slt i8 %trunc, 0
  ret i1 %res
}

define i1 @trunc_combined_with_operations(i16 %x) {
; CHECK-LABEL: @trunc_combined_with_operations(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BOUNDED:%.*]] = and i16 [[X:%.*]], 15
; CHECK-NEXT:    [[SHIFTED:%.*]] = shl nuw nsw i16 [[BOUNDED]], 1
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i16 [[SHIFTED]] to i8
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i8 [[TRUNC]], 40
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 true
;
entry:
  %bounded = and i16 %x, 15
  %shifted = shl nuw nsw i16 %bounded, 1
  %trunc = trunc i16 %shifted to i8
  %cmp = icmp ult i8 %trunc, 40
  br i1 %cmp, label %then, label %else

then:
  %cmp.redundant = icmp ult i8 %trunc, 31
  ret i1 %cmp.redundant

else:
  %res = icmp ugt i8 %trunc, 30
  ret i1 %res
}
