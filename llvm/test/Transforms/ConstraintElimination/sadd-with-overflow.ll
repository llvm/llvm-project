; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

declare { i8, i1 } @llvm.sadd.with.overflow.i8(i8, i8)

define i8 @sadd_no_overflow_due_to_cmp_condition(i8 %a, i8 %b) {
; CHECK-LABEL: define i8 @sadd_no_overflow_due_to_cmp_condition(
; CHECK-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp sge i8 [[A]], 0
; CHECK-NEXT:    [[C_2:%.*]] = icmp sle i8 [[B]], 0
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    br i1 [[AND]], label %[[MATH:.*]], label %[[EXIT_FAIL:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[TMP1:%.*]] = insertvalue { i8, i1 } poison, i8 [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertvalue { i8, i1 } [[TMP1]], i1 false, 1
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[TMP2]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_FAIL]], label %[[EXIT_OK:.*]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    [[RES:%.*]] = extractvalue { i8, i1 } [[TMP2]], 0
; CHECK-NEXT:    ret i8 [[RES]]
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp sge i8 %a, 0
  %c.2 = icmp sle i8 %b, 0
  %and = and i1 %c.1, %c.2
  br i1 %and, label %math, label %exit.fail

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.fail, label %exit.ok

exit.ok:
  %res = extractvalue { i8, i1 } %op, 0
  ret i8 %res

exit.fail:
  ret i8 0
}

define i8 @sadd_no_overflow_due_to_cmp_condition2(i8 %a, i8 %b) {
; CHECK-LABEL: define i8 @sadd_no_overflow_due_to_cmp_condition2(
; CHECK-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp slt i8 [[A]], 64
; CHECK-NEXT:    [[C_2:%.*]] = icmp sle i8 [[B]], 64
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    br i1 [[AND]], label %[[MATH:.*]], label %[[EXIT_FAIL:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[OP:%.*]] = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 [[A]], i8 [[B]])
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[OP]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_FAIL]], label %[[EXIT_OK:.*]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    [[TMP0:%.*]] = extractvalue { i8, i1 } [[OP]], 0
; CHECK-NEXT:    ret i8 [[TMP0]]
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp slt i8 %a, 64
  %c.2 = icmp sle i8 %b, 64
  %and = and i1 %c.1, %c.2
  br i1 %and, label %math, label %exit.fail

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.fail, label %exit.ok

exit.ok:
  %res = extractvalue { i8, i1 } %op, 0
  ret i8 %res

exit.fail:
  ret i8 0
}

declare void @use_res({ i8, i1 })

define i8 @sadd_no_overflow_due_to_cmp_condition_result_used(i8 %a, i8 %b) {
; CHECK-LABEL: define i8 @sadd_no_overflow_due_to_cmp_condition_result_used(
; CHECK-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp sge i8 [[A]], 0
; CHECK-NEXT:    [[C_2:%.*]] = icmp sle i8 [[B]], 0
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    br i1 [[AND]], label %[[MATH:.*]], label %[[EXIT_FAIL:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[TMP0:%.*]] = add i8 [[A]], [[B]]
; CHECK-NEXT:    [[TMP1:%.*]] = insertvalue { i8, i1 } poison, i8 [[TMP0]], 0
; CHECK-NEXT:    [[OP:%.*]] = insertvalue { i8, i1 } [[TMP1]], i1 false, 1
; CHECK-NEXT:    call void @use_res({ i8, i1 } [[OP]])
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[OP]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_FAIL]], label %[[EXIT_OK:.*]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    [[RES:%.*]] = extractvalue { i8, i1 } [[OP]], 0
; CHECK-NEXT:    ret i8 [[RES]]
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp sge i8 %a, 0
  %c.2 = icmp sle i8 %b, 0
  %and = and i1 %c.1, %c.2
  br i1 %and, label %math, label %exit.fail

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)
  call void @use_res({ i8, i1 } %op)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.fail, label %exit.ok

exit.ok:
  %res = extractvalue { i8, i1 } %op, 0
  ret i8 %res

exit.fail:
  ret i8 0
}

define i8 @sadd_no_overflow_due_to_or_conds(i8 %a, i8 %b) {
; CHECK-LABEL: define i8 @sadd_no_overflow_due_to_or_conds(
; CHECK-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp eq i8 [[A]], 0
; CHECK-NEXT:    [[C_2:%.*]] = icmp eq i8 [[B]], 0
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    br i1 [[OR]], label %[[MATH:.*]], label %[[EXIT_FAIL:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[OP:%.*]] = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 [[A]], i8 [[B]])
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[OP]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_FAIL]], label %[[EXIT_OK:.*]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    [[RES:%.*]] = extractvalue { i8, i1 } [[OP]], 0
; CHECK-NEXT:    ret i8 [[RES]]
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp eq i8 %a, 0
  %c.2 = icmp eq i8 %b, 0
  %or = or i1 %c.1, %c.2
  br i1 %or, label %math, label %exit.fail

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.fail, label %exit.ok

exit.ok:
  %res = extractvalue { i8, i1 } %op, 0
  ret i8 %res

exit.fail:
  ret i8 0
}

define i8 @sadd_no_overflow_due_to_and_conds(i8 %a, i8 %b) {
; CHECK-LABEL: define i8 @sadd_no_overflow_due_to_and_conds(
; CHECK-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp sge i8 [[A]], 0
; CHECK-NEXT:    [[C_2:%.*]] = icmp sle i8 [[A]], 63
; CHECK-NEXT:    [[C_3:%.*]] = icmp sge i8 [[B]], 0
; CHECK-NEXT:    [[C_4:%.*]] = icmp sle i8 [[B]], 63
; CHECK-NEXT:    [[AND1:%.*]] = and i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    [[AND2:%.*]] = and i1 [[C_3]], [[C_4]]
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[AND1]], [[AND2]]
; CHECK-NEXT:    br i1 [[AND]], label %[[MATH:.*]], label %[[EXIT_FAIL:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[OP:%.*]] = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 [[A]], i8 [[B]])
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[OP]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_FAIL]], label %[[EXIT_OK:.*]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    [[RES:%.*]] = extractvalue { i8, i1 } [[OP]], 0
; CHECK-NEXT:    ret i8 [[RES]]
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp sge i8 %a, 0
  %c.2 = icmp sle i8 %a, 63
  %c.3 = icmp sge i8 %b, 0
  %c.4 = icmp sle i8 %b, 63
  %and1 = and i1 %c.1, %c.2
  %and2 = and i1 %c.3, %c.4
  %and = and i1 %and1, %and2
  br i1 %and, label %math, label %exit.fail

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.fail, label %exit.ok

exit.ok:
  %res = extractvalue { i8, i1 } %op, 0
  ret i8 %res

exit.fail:
  ret i8 0
}

define i8 @sadd_may_overflow1(i8 %a, i8 %b) {
; CHECK-LABEL: define i8 @sadd_may_overflow1(
; CHECK-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp sge i8 [[A]], 64
; CHECK-NEXT:    [[C_2:%.*]] = icmp sge i8 [[B]], 64
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    br i1 [[OR]], label %[[EXIT_FAIL:.*]], label %[[MATH:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[OP:%.*]] = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 [[A]], i8 [[B]])
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[OP]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_FAIL]], label %[[EXIT_OK:.*]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    [[TMP0:%.*]] = extractvalue { i8, i1 } [[OP]], 0
; CHECK-NEXT:    ret i8 [[TMP0]]
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp sge i8 %a, 64
  %c.2 = icmp sge i8 %b, 64
  %or = or i1 %c.1, %c.2
  br i1 %or, label %exit.fail, label %math

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.fail, label %exit.ok

exit.ok:
  %res = extractvalue { i8, i1 } %op, 0
  ret i8 %res

exit.fail:
  ret i8 0
}

define i8 @sadd_may_overflow2(i8 %a, i8 %b) {
; CHECK-LABEL: define i8 @sadd_may_overflow2(
; CHECK-SAME: i8 [[A:%.*]], i8 [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp sle i8 [[A]], -65
; CHECK-NEXT:    [[C_2:%.*]] = icmp sle i8 [[B]], -65
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[C_1]], [[C_2]]
; CHECK-NEXT:    br i1 [[OR]], label %[[EXIT_FAIL:.*]], label %[[MATH:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[OP:%.*]] = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 [[A]], i8 [[B]])
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[OP]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_FAIL]], label %[[EXIT_OK:.*]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    [[TMP0:%.*]] = extractvalue { i8, i1 } [[OP]], 0
; CHECK-NEXT:    ret i8 [[TMP0]]
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp sle i8 %a, -65
  %c.2 = icmp sle i8 %b, -65
  %or = or i1 %c.1, %c.2
  br i1 %or, label %exit.fail, label %math

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.fail, label %exit.ok

exit.ok:
  %res = extractvalue { i8, i1 } %op, 0
  ret i8 %res

exit.fail:
  ret i8 0
}

define i8 @sadd_known_overflow(i8 %a) {
; CHECK-LABEL: define i8 @sadd_known_overflow(
; CHECK-SAME: i8 [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C_1:%.*]] = icmp eq i8 [[A]], 127
; CHECK-NEXT:    br i1 [[C_1]], label %[[MATH:.*]], label %[[EXIT_FAIL:.*]]
; CHECK:       [[MATH]]:
; CHECK-NEXT:    [[OP:%.*]] = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 [[A]], i8 1)
; CHECK-NEXT:    [[STATUS:%.*]] = extractvalue { i8, i1 } [[OP]], 1
; CHECK-NEXT:    br i1 [[STATUS]], label %[[EXIT_OK:.*]], label %[[EXIT_FAIL]]
; CHECK:       [[EXIT_OK]]:
; CHECK-NEXT:    ret i8 1
; CHECK:       [[EXIT_FAIL]]:
; CHECK-NEXT:    ret i8 0
;
entry:
  %c.1 = icmp eq i8 %a, 127
  br i1 %c.1, label %math, label %exit.fail

math:
  %op = tail call { i8, i1 } @llvm.sadd.with.overflow.i8(i8 %a, i8 1)
  %status = extractvalue { i8, i1 } %op, 1
  br i1 %status, label %exit.ok, label %exit.fail

exit.ok:
  ret i8 1

exit.fail:
  ret i8 0
}
