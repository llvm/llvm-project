; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals --version 2

; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

; Changed check lines for annotation to ensure annotations are attatched to the correct instruction.

declare void @use(i1)

define void @shl(ptr %a, i32 %n) {
; CHECK-LABEL: define void @shl
; CHECK-SAME: (ptr [[A:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = shl i64 [[IDX_EXT]], 1, !annotation !0
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[MUL]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[I_ZEXT:%.*]] = zext i32 [[I_0]] to i64
; CHECK-NEXT:    [[PTR_IV:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[I_ZEXT]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]], !annotation !2
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %mul = shl i64 %idx.ext , 1
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %mul
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %i.zext = zext i32 %i.0 to i64
  %ptr.iv = getelementptr inbounds i32, ptr %a, i64 %i.zext
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr, !annotation !0
  %c.2 = icmp uge ptr %ptr.iv, %a, !annotation !1
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @shl_nuw(ptr %a, i32 %n) {
; CHECK-LABEL: define void @shl_nuw
; CHECK-SAME: (ptr [[A:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = shl nuw i64 [[IDX_EXT]], 1
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[MUL]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[I_ZEXT:%.*]] = zext i32 [[I_0]] to i64
; CHECK-NEXT:    [[PTR_IV:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[I_ZEXT]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %mul = shl nuw i64 %idx.ext , 1
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %mul
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %i.zext = zext i32 %i.0 to i64
  %ptr.iv = getelementptr inbounds i32, ptr %a, i64 %i.zext
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr, !annotation !0
  %c.2 = icmp uge ptr %ptr.iv, %a, !annotation !1
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @mul(ptr %a, i32 %n) {
; CHECK-LABEL: define void @mul
; CHECK-SAME: (ptr [[A:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = mul i64 [[IDX_EXT]], 2, !annotation !0
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[MUL]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[I_ZEXT:%.*]] = zext i32 [[I_0]] to i64
; CHECK-NEXT:    [[PTR_IV:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[I_ZEXT]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[PTR_IV]], [[ADD_PTR]], !annotation !2
; CHECK-NEXT:    call void @use(i1 [[C_1]])
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %mul = mul i64 %idx.ext, 2
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %mul
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %i.zext = zext i32 %i.0 to i64
  %ptr.iv = getelementptr inbounds i32, ptr %a, i64 %i.zext
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr, !annotation !0
  %c.2 = icmp uge ptr %ptr.iv, %a, !annotation !1
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @mul_nuw(ptr %a, i32 %n) {
; CHECK-LABEL: define void @mul_nuw
; CHECK-SAME: (ptr [[A:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = mul nuw i64 [[IDX_EXT]], 2
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[MUL]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY:%.*]] ]
; CHECK-NEXT:    [[I_ZEXT:%.*]] = zext i32 [[I_0]] to i64
; CHECK-NEXT:    [[PTR_IV:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[I_ZEXT]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
;
entry:
  %idx.ext = zext i32 %n to i64
  %mul = mul nuw i64 %idx.ext , 2
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %mul
  br label %for.cond

for.cond:
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %i.zext = zext i32 %i.0 to i64
  %ptr.iv = getelementptr inbounds i32, ptr %a, i64 %i.zext
  %cmp = icmp ult i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.body:
  %c.1 = icmp ult ptr %ptr.iv, %add.ptr, !annotation !0
  %c.2 = icmp uge ptr %ptr.iv, %a, !annotation !1
  call void @use(i1 %c.1)
  call void @use(i1 %c.2)
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond

for.cond.cleanup:
  ret void
}

define void @add_ub_unsigned(i32 %n) {
; CHECK-LABEL: define void @add_ub_unsigned
; CHECK-SAME: (i32 [[N:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[N]], 1, !annotation !0
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[N]], [[ADD]], !annotation !2
; CHECK-NEXT:    call void @use(i1 [[CMP]])
; CHECK-NEXT:    ret void
;
  %add = add i32 %n, 1
  %cmp = icmp ult i32 %n, %add, !annotation !0
  call void @use(i1 %cmp)
  ret void
}

define void @add_ub_nuw_unsigned(i32 %n) {
; CHECK-LABEL: define void @add_ub_nuw_unsigned
; CHECK-SAME: (i32 [[N:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add nuw i32 [[N]], 1
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    ret void
;
  %add = add nuw i32 %n, 1
  %cmp = icmp ult i32 %n, %add, !annotation !0
  call void @use(i1 %cmp)
  ret void
}

define void @add_ub_signed(i32 %n) {
; CHECK-LABEL: define void @add_ub_signed
; CHECK-SAME: (i32 [[N:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[N]], 1, !annotation !3
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[N]], [[ADD]], !annotation !2
; CHECK-NEXT:    call void @use(i1 [[CMP]])
; CHECK-NEXT:    ret void
;
  %add = add i32 %n, 1
  %cmp = icmp slt i32 %n, %add, !annotation !0
  call void @use(i1 %cmp)
  ret void
}

define void @add_ub_nsw_signed(i32 %n) {
; CHECK-LABEL: define void @add_ub_nsw_signed
; CHECK-SAME: (i32 [[N:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[N]], 1
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    ret void
;
  %add = add nsw i32 %n, 1
  %cmp = icmp slt i32 %n, %add, !annotation !0
  call void @use(i1 %cmp)
  ret void
}

define void @mul_ub_signed(i32 %n) {
; CHECK-LABEL: define void @mul_ub_signed
; CHECK-SAME: (i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[POS:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-NEXT:    br i1 [[POS]], label [[MAIN:%.*]], label [[END:%.*]]
; CHECK:       main:
; CHECK-NEXT:    [[ADD:%.*]] = mul i32 [[N]], 2, !annotation !3
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[N]], [[ADD]], !annotation !2
; CHECK-NEXT:    call void @use(i1 [[CMP]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %pos = icmp sgt i32 %n, 0
  br i1 %pos, label %main, label %end

main:                                             ; preds = %entry
  %add = mul i32 %n, 2
  %cmp = icmp slt i32 %n, %add, !annotation !0
  call void @use(i1 %cmp)
  br label %end

end:                                              ; preds = %main, %entry
  ret void
}

define void @mul_ub_nsw_signed(i32 %n) {
; CHECK-LABEL: define void @mul_ub_nsw_signed
; CHECK-SAME: (i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[POS:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-NEXT:    br i1 [[POS]], label [[MAIN:%.*]], label [[END:%.*]]
; CHECK:       main:
; CHECK-NEXT:    [[ADD:%.*]] = mul nsw i32 [[N]], 2
; CHECK-NEXT:    call void @use(i1 true)
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %pos = icmp sgt i32 %n, 0
  br i1 %pos, label %main, label %end

main:                                             ; preds = %entry
  %add = mul nsw i32 %n, 2
  %cmp = icmp slt i32 %n, %add, !annotation !0
  call void @use(i1 %cmp)
  br label %end

end:                                              ; preds = %main, %entry
  ret void
}

!0 = !{!"bounds-safety-check-ptr-lt-upper-bound"}
!1 = !{!"bounds-safety-check-ptr-ge-lower-bound"}
;.
; CHECK: [[META0:![0-9]+]] = !{!1}
; CHECK: [[META1:![0-9]+]] = !{!"bounds-safety-missed-optimization-nuw", !"Check can not be removed because the arithmetic operation might wrap in the unsigned sense. Optimize the check by adding conditions to check for overflow before doing the operation"}
; CHECK: [[META2:![0-9]+]] = !{!"bounds-safety-check-ptr-lt-upper-bound"}
; CHECK: [[META3:![0-9]+]] = !{!4}
; CHECK: [[META4:![0-9]+]] = !{!"bounds-safety-missed-optimization-nsw", !"Check can not be removed because the arithmetic operation might wrap in the signed sense. Optimize the check by adding conditions to check for overflow before doing the operation"}
;.
