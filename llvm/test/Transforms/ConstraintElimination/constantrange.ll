; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=constraint-elimination -S %s | FileCheck %s

; v = and x, 7 → v <= 7.  Branch: z > y + 7.  w = v + y.
; z > y + 7 >= v + y = w → z > w.
define i1 @and_mask_add_nuw(i32 noundef %x, i32 noundef %y, i32 noundef %z) {
; CHECK-LABEL: define i1 @and_mask_add_nuw(
; CHECK-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]], i32 noundef [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V:%.*]] = and i32 [[X]], 7
; CHECK-NEXT:    [[W:%.*]] = add nuw i32 [[V]], [[Y]]
; CHECK-NEXT:    [[OFF:%.*]] = add nuw i32 [[Y]], 7
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[Z]], [[OFF]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %v = and i32 %x, 7
  %w = add nuw i32 %v, %y
  %off = add nuw i32 %y, 7
  %cmp = icmp ugt i32 %z, %off
  br i1 %cmp, label %then, label %else
then:
  %r = icmp ugt i32 %z, %w
  ret i1 %r
else:
  ret i1 false
}

; v = or x, 1 → v >= 1.  w = v + y (nuw).  Branch: z >= w.
; z >= w = v + y >= 1 + y > y → z > y.
define i1 @or_add_nuw(i32 noundef %x, i32 noundef %y, i32 noundef %z) {
; CHECK-LABEL: define i1 @or_add_nuw(
; CHECK-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]], i32 noundef [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V:%.*]] = or i32 [[X]], 1
; CHECK-NEXT:    [[W:%.*]] = add nuw i32 [[V]], [[Y]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp uge i32 [[Z]], [[W]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %v = or i32 %x, 1
  %w = add nuw i32 %v, %y
  %cmp = icmp uge i32 %z, %w
  br i1 %cmp, label %then, label %else
then:
  %r = icmp ugt i32 %z, %y
  ret i1 %r
else:
  ret i1 false
}

; v = or x, 4 → v >= 4.  Branch: z <= y + 3.
; w = v + y (nuw) >= 4 + y > 3 + y >= z → w > z.
define i1 @or_lower_bound_offset(i32 noundef %x, i32 noundef %y, i32 noundef %z) {
; CHECK-LABEL: define i1 @or_lower_bound_offset(
; CHECK-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]], i32 noundef [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V:%.*]] = or i32 [[X]], 4
; CHECK-NEXT:    [[W:%.*]] = add nuw i32 [[V]], [[Y]]
; CHECK-NEXT:    [[OFF:%.*]] = add nuw i32 [[Y]], 3
; CHECK-NEXT:    [[CMP:%.*]] = icmp ule i32 [[Z]], [[OFF]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %v = or i32 %x, 4
  %w = add nuw i32 %v, %y
  %off = add nuw i32 %y, 3
  %cmp = icmp ule i32 %z, %off
  br i1 %cmp, label %then, label %else
then:
  %r = icmp ugt i32 %w, %z
  ret i1 %r
else:
  ret i1 false
}

; v = lshr x, 2 → v <= 1073741823.  Branch: z > y + 1073741823.
; w = v + y.  z > y + 1073741823 >= v + y = w → z > w.
define i1 @lshr_add_nuw(i32 noundef %x, i32 noundef %y, i32 noundef %z) {
; CHECK-LABEL: define i1 @lshr_add_nuw(
; CHECK-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]], i32 noundef [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V:%.*]] = lshr i32 [[X]], 2
; CHECK-NEXT:    [[W:%.*]] = add nuw i32 [[V]], [[Y]]
; CHECK-NEXT:    [[OFF:%.*]] = add nuw i32 [[Y]], 1073741823
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[Z]], [[OFF]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %v = lshr i32 %x, 2
  %w = add nuw i32 %v, %y
  %off = add nuw i32 %y, 1073741823
  %cmp = icmp ugt i32 %z, %off
  br i1 %cmp, label %then, label %else
then:
  %r = icmp ugt i32 %z, %w
  ret i1 %r
else:
  ret i1 false
}

; call range(i32 0, 100) → v <= 99.  Branch: z > y + 99.
; w = v + y.  z > y + 99 >= v + y = w → z > w.
declare i32 @get_percent()
define i1 @call_range_add_nuw(i32 noundef %y, i32 noundef %z) {
; CHECK-LABEL: define i1 @call_range_add_nuw(
; CHECK-SAME: i32 noundef [[Y:%.*]], i32 noundef [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V:%.*]] = call range(i32 0, 100) i32 @get_percent()
; CHECK-NEXT:    [[W:%.*]] = add nuw i32 [[V]], [[Y]]
; CHECK-NEXT:    [[OFF:%.*]] = add nuw i32 [[Y]], 99
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[Z]], [[OFF]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %v = call range(i32 0, 100) i32 @get_percent()
  %w = add nuw i32 %v, %y
  %off = add nuw i32 %y, 99
  %cmp = icmp ugt i32 %z, %off
  br i1 %cmp, label %then, label %else
then:
  %r = icmp ugt i32 %z, %w
  ret i1 %r
else:
  ret i1 false
}

; range() on argument: x in [0, 10) → x <= 9.  Branch: z > y + 9.
; w = x + y.  z > y + 9 >= x + y = w → z > w.
define i1 @arg_range_add_nuw(i32 range(i32 0, 10) %x, i32 noundef %y, i32 noundef %z) {
; CHECK-LABEL: define i1 @arg_range_add_nuw(
; CHECK-SAME: i32 range(i32 0, 10) [[X:%.*]], i32 noundef [[Y:%.*]], i32 noundef [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[W:%.*]] = add nuw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[OFF:%.*]] = add nuw i32 [[Y]], 9
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[Z]], [[OFF]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    ret i1 true
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %w = add nuw i32 %x, %y
  %off = add nuw i32 %y, 9
  %cmp = icmp ugt i32 %z, %off
  br i1 %cmp, label %then, label %else
then:
  %r = icmp ugt i32 %z, %w
  ret i1 %r
else:
  ret i1 false
}

; Negative test, 'wrong' bound
; v = and x, 7 → v <= 7.  Branch: z > y + 6 (not 7!).
; z > y + 6, but w = v + y could be y + 7 > y + 6, so z > w is NOT guaranteed.
define i1 @neg_and_mask_tight(i32 noundef %x, i32 noundef %y, i32 noundef %z) {
; CHECK-LABEL: define i1 @neg_and_mask_tight(
; CHECK-SAME: i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]], i32 noundef [[Z:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V:%.*]] = and i32 [[X]], 7
; CHECK-NEXT:    [[W:%.*]] = add nuw i32 [[V]], [[Y]]
; CHECK-NEXT:    [[OFF:%.*]] = add nuw i32 [[Y]], 6
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[Z]], [[OFF]]
; CHECK-NEXT:    br i1 [[CMP]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[R:%.*]] = icmp ugt i32 [[Z]], [[W]]
; CHECK-NEXT:    ret i1 [[R]]
; CHECK:       else:
; CHECK-NEXT:    ret i1 false
;
entry:
  %v = and i32 %x, 7
  %w = add nuw i32 %v, %y
  %off = add nuw i32 %y, 6
  %cmp = icmp ugt i32 %z, %off
  br i1 %cmp, label %then, label %else
then:
  %r = icmp ugt i32 %z, %w
  ret i1 %r
else:
  ret i1 false
}
