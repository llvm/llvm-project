; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -S '-passes=separate-const-offset-from-gep<lower-gep>' < %s | FileCheck %s

; These tests check that this pass does not incorrectly handle negative offsets.

@c = internal constant [4 x i32] [i32 0, i32 1, i32 2, i32 3]

; FIXME: We could optimize this case, but we don't currently.  This test just
; checks that we don't miscompile it.
define i32 @sub_positive(i32 %a, i32 %b, ptr %ptr) {
; CHECK-LABEL: define i32 @sub_positive
; CHECK-SAME: (i32 [[A:%.*]], i32 [[B:%.*]], ptr [[PTR:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = sub nuw nsw i32 15, [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = sub nuw nsw i32 [[B]], [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = zext i32 [[TMP1]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [4 x i32], ptr [[PTR]], i64 0, i64 [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4
; CHECK-NEXT:    ret i32 [[TMP4]]
;
entry:
  %0 = sub nuw nsw i32 15, %a
  %1 = sub nuw nsw i32 %b, %0
  %2 = zext i32 %1 to i64
  %3 = getelementptr inbounds [4 x i32], ptr %ptr, i64 0, i64 %2
  %4 = load i32, ptr %3
  ret i32 %4
}
