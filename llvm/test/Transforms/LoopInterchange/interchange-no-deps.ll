; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes='loop(loop-interchange),simplifycfg' -simplifycfg-require-and-preserve-domtree=1 \
; RUN:     -pass-remarks=loop-interchange -pass-remarks-missed=loop-interchange -stats -S 2>&1 \
; RUN:     | FileCheck -check-prefix=STATS %s

; no_deps_interchange just accesses a single nested array and can be interchange.
;
define i32 @no_deps_interchange(ptr nocapture %Arr) {
; STATS-LABEL: define i32 @no_deps_interchange(
; STATS-SAME: ptr nocapture [[ARR:%.*]]) {
; STATS-NEXT:  [[ENTRY:.*]]:
; STATS-NEXT:    br label %[[FOR2:.*]]
; STATS:       [[FOR1_HEADER:.*]]:
; STATS-NEXT:    [[INDVARS_IV19:%.*]] = phi i64 [ [[INDVARS_IV_NEXT20:%.*]], %[[FOR1_HEADER]] ], [ 0, %[[FOR2]] ]
; STATS-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [1024 x i32], ptr [[ARR]], i64 [[INDVARS_IV:%.*]], i64 [[INDVARS_IV19]]
; STATS-NEXT:    store i32 0, ptr [[ARRAYIDX6]], align 4
; STATS-NEXT:    [[INDVARS_IV_NEXT:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 1
; STATS-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT]], 1024
; STATS-NEXT:    [[INDVARS_IV_NEXT20]] = add nuw nsw i64 [[INDVARS_IV19]], 1
; STATS-NEXT:    [[EXITCOND21:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT20]], 1024
; STATS-NEXT:    br i1 [[EXITCOND21]], label %[[FOR1_HEADER]], label %[[FOR2_SPLIT:.*]]
; STATS:       [[FOR2]]:
; STATS-NEXT:    [[INDVARS_IV]] = phi i64 [ [[TMP0:%.*]], %[[FOR2_SPLIT]] ], [ 0, %[[ENTRY]] ]
; STATS-NEXT:    br label %[[FOR1_HEADER]]
; STATS:       [[FOR2_SPLIT]]:
; STATS-NEXT:    [[TMP0]] = add nuw nsw i64 [[INDVARS_IV]], 1
; STATS-NEXT:    [[TMP1:%.*]] = icmp ne i64 [[TMP0]], 1024
; STATS-NEXT:    br i1 [[TMP1]], label %[[FOR2]], label %[[EXIT:.*]]
; STATS:       [[EXIT]]:
; STATS-NEXT:    ret i32 0
;
entry:
  br label %for1.header

for1.header:
  %indvars.iv19 = phi i64 [ 0, %entry ], [ %indvars.iv.next20, %for1.inc ]
  br label %for2

for2:
  %indvars.iv = phi i64 [ 0, %for1.header ], [ %indvars.iv.next, %for2 ]
  %arrayidx6 = getelementptr inbounds [1024 x i32], ptr %Arr, i64 %indvars.iv, i64 %indvars.iv19
  store i32 0, ptr %arrayidx6, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for2, label %for1.inc

for1.inc:
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %exitcond21 = icmp ne i64 %indvars.iv.next20, 1024
  br i1 %exitcond21, label %for1.header, label %exit

exit:
  ret i32 0

}

; No memory access using any induction variables, interchanging not beneficial.
;
define i32 @no_mem_instrs(ptr %ptr) {
; STATS-LABEL: define i32 @no_mem_instrs(
; STATS-SAME: ptr [[PTR:%.*]]) {
; STATS-NEXT:  [[ENTRY:.*]]:
; STATS-NEXT:    br label %[[FOR1_HEADER:.*]]
; STATS:       [[FOR1_HEADER]]:
; STATS-NEXT:    [[INDVARS_IV19:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INDVARS_IV_NEXT20:%.*]], %[[FOR1_INC:.*]] ]
; STATS-NEXT:    br label %[[FOR2:.*]]
; STATS:       [[FOR2]]:
; STATS-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[FOR1_HEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[FOR2]] ]
; STATS-NEXT:    store i64 [[INDVARS_IV]], ptr [[PTR]], align 4
; STATS-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; STATS-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT]], 1024
; STATS-NEXT:    br i1 [[EXITCOND]], label %[[FOR2]], label %[[FOR1_INC]]
; STATS:       [[FOR1_INC]]:
; STATS-NEXT:    [[INDVARS_IV_NEXT20]] = add nuw nsw i64 [[INDVARS_IV19]], 1
; STATS-NEXT:    [[EXITCOND21:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT20]], 1024
; STATS-NEXT:    br i1 [[EXITCOND21]], label %[[FOR1_HEADER]], label %[[EXIT:.*]]
; STATS:       [[EXIT]]:
; STATS-NEXT:    ret i32 0
;
entry:
  br label %for1.header

for1.header:
  %indvars.iv19 = phi i64 [ 0, %entry ], [ %indvars.iv.next20, %for1.inc ]
  br label %for2

for2:
  %indvars.iv = phi i64 [ 0, %for1.header ], [ %indvars.iv.next, %for2 ]
  store i64 %indvars.iv, ptr %ptr, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for2, label %for1.inc

for1.inc:
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %exitcond21 = icmp ne i64 %indvars.iv.next20, 1024
  br i1 %exitcond21, label %for1.header, label %exit

exit:                                 ; preds = %for1.inc
  ret i32 0
}
