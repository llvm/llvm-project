; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=loop-interchange -cache-line-size=64 -pass-remarks-missed='loop-interchange' -pass-remarks-output=%t -S
; RUN: FileCheck --input-file=%t %s

@b = external dso_local global [5 x i32], align 16

;; Not profitable to interchange, because the access is invariant to j loop.
;;
;;  for(int i=0;i<4;i++) {
;;    for(int j=1;j<4;j++) {
;;      b[i] = ....
;;    }
;; }

; CHECK: --- !Missed
; CHECK-NEXT: Pass:            loop-interchange
; CHECK-NEXT: Name:            Dependence
; CHECK-NEXT: Function:        test1
; CHECK-NEXT: Args:
; CHECK-NEXT:  - String:       Cannot interchange loops due to dependences.

define void @test1() {
entry:
  br label %outer.header

outer.header:
  %i = phi i32 [ %i.next, %outer.latch ], [ 0, %entry ]
  br label %inner.header

inner.header:
  %j = phi i32 [ %j.next, %inner.latch ], [ 1, %outer.header ]
  br label %inner.latch

inner.latch:
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds [5 x i32], ptr @b, i64 0, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 4
  store i32 undef, ptr %arrayidx, align 4
  %cmp = icmp slt i32 %j, 4
  %j.next = add nuw nsw i32 %j, 1
  br i1 %cmp, label %inner.header, label %outer.body

outer.body:
  br label %outer.latch

outer.latch:
  %i.next = add nsw i32 %i, 1
  %cmp2 = icmp slt i32 %i, 4
  br i1 %cmp2, label %outer.header, label %exit

exit:
  ret void
}


; CHECK: --- !Missed
; CHECK-NEXT: Pass:            loop-interchange
; CHECK-NEXT: Name:            Dependence
; CHECK-NEXT: Function:        test2
; CHECK-NEXT: Args:
; CHECK-NEXT:  - String:       Cannot interchange loops due to dependences.

define void @test2() {
entry:
  br label %outer.header

outer.header:
  %i = phi i32 [ %i.next, %outer.latch ], [ 0, %entry ]
  br label %inner.header

inner.header:
  %lsr.iv = phi i32 [ %lsr.iv.next, %inner.latch ], [ 1, %outer.header ]
  br label %inner.latch

inner.latch:
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds [5 x i32], ptr @b, i64 0, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 4
  %cmp = icmp slt i32 %lsr.iv, 4
  %cmp.zext = zext i1 %cmp to i32
  store i32 %cmp.zext, ptr %arrayidx, align 4
  %lsr.iv.next = add nuw nsw i32 %lsr.iv, 1
  br i1 %cmp, label %inner.header, label %outer.body

outer.body:
  br label %outer.latch

outer.latch:
  %i.next = add nsw i32 %i, 1
  %cmp2 = icmp slt i32 %i, 4
  br i1 %cmp2, label %outer.header, label %exit

exit:
  ret void
}
