; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=loop-interchange -cache-line-size=64 -verify-loop-lcssa -S | FileCheck %s
; RUN: opt < %s -passes=loop-interchange -cache-line-size=64 -da-disable-delinearization-checks -verify-loop-lcssa -S | FileCheck -check-prefix=CHECK-DELIN %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"

; void foo(int n, int m) {
;   int temp[16][16];
;   int res[16][16];
;   for(int i = 0; i < n; i++) {
;     for(int j = 0; j < m; j++)
;       res[j][i] = temp[j][i];
;   }
; }

;; This loop can be interchanged with -da-disable-delinearization-checks, otherwise it cannot
;; be interchanged due to dependence.
define void @lcssa_08(i32 %n, i32 %m) {;
; CHECK-LABEL: define void @lcssa_08(
; CHECK-SAME: i32 [[N:%.*]], i32 [[M:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TEMP:%.*]] = alloca [16 x [16 x i32]], align 4
; CHECK-NEXT:    [[RES:%.*]] = alloca [16 x [16 x i32]], align 4
; CHECK-NEXT:    [[CMP24:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP24]], label %[[OUTER_PREHEADER:.*]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[OUTER_PREHEADER]]:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT29:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    br label %[[OUTER_HEADER:.*]]
; CHECK:       [[OUTER_HEADER]]:
; CHECK-NEXT:    [[INDVARS_IV27:%.*]] = phi i64 [ 0, %[[OUTER_PREHEADER]] ], [ [[INDVARS_IV_NEXT28:%.*]], %[[OUTER_LATCH:.*]] ]
; CHECK-NEXT:    [[CMP222:%.*]] = icmp sgt i32 [[M]], 0
; CHECK-NEXT:    br i1 [[CMP222]], label %[[INNER_PREHEADER:.*]], label %[[OUTER_LATCH]]
; CHECK:       [[INNER_PREHEADER]]:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[M]] to i64
; CHECK-NEXT:    br label %[[INNER_FOR_BODY:.*]]
; CHECK:       [[INNER_FOR_BODY]]:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[INNER_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], %[[INNER_FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[TEMP]], i64 0, i64 [[INDVARS_IV]], i64 [[INDVARS_IV27]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[RES]], i64 0, i64 [[INDVARS_IV]], i64 [[INDVARS_IV27]]
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[ARRAYIDX8]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[INNER_FOR_BODY]], label %[[INNER_CRIT_EDGE:.*]]
; CHECK:       [[INNER_CRIT_EDGE]]:
; CHECK-NEXT:    br label %[[OUTER_LATCH]]
; CHECK:       [[OUTER_LATCH]]:
; CHECK-NEXT:    [[INDVARS_IV_NEXT28]] = add nuw nsw i64 [[INDVARS_IV27]], 1
; CHECK-NEXT:    [[EXITCOND30:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT28]], [[WIDE_TRIP_COUNT29]]
; CHECK-NEXT:    br i1 [[EXITCOND30]], label %[[OUTER_HEADER]], label %[[OUTER_CRIT_EDGE:.*]]
; CHECK:       [[OUTER_CRIT_EDGE]]:
; CHECK-NEXT:    br label %[[FOR_COND_CLEANUP]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
;
; CHECK-DELIN-LABEL: define void @lcssa_08(
; CHECK-DELIN-SAME: i32 [[N:%.*]], i32 [[M:%.*]]) {
; CHECK-DELIN-NEXT:  [[ENTRY:.*:]]
; CHECK-DELIN-NEXT:    [[TEMP:%.*]] = alloca [16 x [16 x i32]], align 4
; CHECK-DELIN-NEXT:    [[RES:%.*]] = alloca [16 x [16 x i32]], align 4
; CHECK-DELIN-NEXT:    [[CMP24:%.*]] = icmp sgt i32 [[N]], 0
; CHECK-DELIN-NEXT:    br i1 [[CMP24]], label %[[INNER_PREHEADER:.*]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK-DELIN:       [[OUTER_PREHEADER:.*]]:
; CHECK-DELIN-NEXT:    br label %[[OUTER_HEADER:.*]]
; CHECK-DELIN:       [[OUTER_HEADER]]:
; CHECK-DELIN-NEXT:    [[INDVARS_IV27:%.*]] = phi i64 [ 0, %[[OUTER_PREHEADER]] ], [ [[INDVARS_IV_NEXT28:%.*]], %[[OUTER_LATCH:.*]] ]
; CHECK-DELIN-NEXT:    [[CMP222:%.*]] = icmp sgt i32 [[M]], 0
; CHECK-DELIN-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[M]] to i64
; CHECK-DELIN-NEXT:    br i1 [[CMP222]], label %[[INNER_FOR_BODY_SPLIT1:.*]], label %[[INNER_FOR_BODY_SPLIT:.*]]
; CHECK-DELIN:       [[INNER_PREHEADER]]:
; CHECK-DELIN-NEXT:    [[WIDE_TRIP_COUNT29:%.*]] = zext i32 [[N]] to i64
; CHECK-DELIN-NEXT:    br label %[[INNER_FOR_BODY:.*]]
; CHECK-DELIN:       [[INNER_FOR_BODY]]:
; CHECK-DELIN-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, %[[INNER_PREHEADER]] ], [ [[TMP1:%.*]], %[[INNER_FOR_BODY_SPLIT]] ]
; CHECK-DELIN-NEXT:    br label %[[OUTER_PREHEADER]]
; CHECK-DELIN:       [[INNER_FOR_BODY_SPLIT1]]:
; CHECK-DELIN-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[TEMP]], i64 0, i64 [[INDVARS_IV]], i64 [[INDVARS_IV27]]
; CHECK-DELIN-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARRAYIDX6]], align 4
; CHECK-DELIN-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds [16 x [16 x i32]], ptr [[RES]], i64 0, i64 [[INDVARS_IV]], i64 [[INDVARS_IV27]]
; CHECK-DELIN-NEXT:    store i32 [[TMP0]], ptr [[ARRAYIDX8]], align 4
; CHECK-DELIN-NEXT:    [[INDVARS_IV_NEXT:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-DELIN-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-DELIN-NEXT:    br label %[[INNER_CRIT_EDGE:.*]]
; CHECK-DELIN:       [[INNER_FOR_BODY_SPLIT]]:
; CHECK-DELIN-NEXT:    [[WIDE_TRIP_COUNT_LCSSA:%.*]] = phi i64 [ [[WIDE_TRIP_COUNT]], %[[OUTER_LATCH]] ], [ [[WIDE_TRIP_COUNT]], %[[OUTER_HEADER]] ]
; CHECK-DELIN-NEXT:    [[TMP1]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-DELIN-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP1]], [[WIDE_TRIP_COUNT_LCSSA]]
; CHECK-DELIN-NEXT:    br i1 [[TMP2]], label %[[INNER_FOR_BODY]], label %[[OUTER_CRIT_EDGE:.*]]
; CHECK-DELIN:       [[INNER_CRIT_EDGE]]:
; CHECK-DELIN-NEXT:    br label %[[OUTER_LATCH]]
; CHECK-DELIN:       [[OUTER_LATCH]]:
; CHECK-DELIN-NEXT:    [[INDVARS_IV_NEXT28]] = add nuw nsw i64 [[INDVARS_IV27]], 1
; CHECK-DELIN-NEXT:    [[EXITCOND30:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT28]], [[WIDE_TRIP_COUNT29]]
; CHECK-DELIN-NEXT:    br i1 [[EXITCOND30]], label %[[OUTER_HEADER]], label %[[INNER_FOR_BODY_SPLIT]]
; CHECK-DELIN:       [[OUTER_CRIT_EDGE]]:
; CHECK-DELIN-NEXT:    br label %[[FOR_COND_CLEANUP]]
; CHECK-DELIN:       [[FOR_COND_CLEANUP]]:
; CHECK-DELIN-NEXT:    ret void
;
entry:
  %temp = alloca [16 x [16 x i32]], align 4
  %res = alloca [16 x [16 x i32]], align 4
  %cmp24 = icmp sgt i32 %n, 0
  br i1 %cmp24, label %outer.preheader, label %for.cond.cleanup

outer.preheader:                        ; preds = %entry
  %wide.trip.count29 = zext i32 %n to i64
  br label %outer.header

outer.header:                              ; preds = %outer.preheader, %outer.latch
  %indvars.iv27 = phi i64 [ 0, %outer.preheader ], [ %indvars.iv.next28, %outer.latch ]
  %cmp222 = icmp sgt i32 %m, 0
  br i1 %cmp222, label %inner.preheader, label %outer.latch

inner.preheader:                                  ; preds = %outer.header
  ; When inner.preheader becomes the outer preheader, do not move
  ; %wide.trip.count into the inner loop header lest LCSSA break
  ; (if %wide.trip.count gets moved, its use is now outside the inner loop).
  %wide.trip.count = zext i32 %m to i64
  br label %inner.for.body

inner.for.body:                                        ; preds = %inner.preheader, %inner.for.body
  %indvars.iv = phi i64 [ 0, %inner.preheader ], [ %indvars.iv.next, %inner.for.body ]
  %arrayidx6 = getelementptr inbounds [16 x [16 x i32]], ptr %temp, i64 0, i64 %indvars.iv, i64 %indvars.iv27
  %0 = load i32, ptr %arrayidx6, align 4
  %arrayidx8 = getelementptr inbounds [16 x [16 x i32]], ptr %res, i64 0, i64 %indvars.iv, i64 %indvars.iv27
  store i32 %0, ptr %arrayidx8, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %inner.for.body, label %inner.crit_edge

inner.crit_edge:            ; preds = %inner.for.body
  br label %outer.latch

outer.latch:                                ; preds = %inner.crit_edge, %outer.header
  %indvars.iv.next28 = add nuw nsw i64 %indvars.iv27, 1
  %exitcond30 = icmp ne i64 %indvars.iv.next28, %wide.trip.count29
  br i1 %exitcond30, label %outer.header, label %outer.crit_edge

outer.crit_edge:              ; preds = %outer.latch
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %outer.crit_edge, %entry
  ret void
}

@global = external local_unnamed_addr global [4 x [4 x [2 x i16]]] align 16

; %N.ext is defined in the outer loop header and used in the inner loop. After
; interchanging, it will be defined in the new inner loop and used in the new;
; outer latch, so we need to create a new LCSSA phi node for it.

define void @test2(i32 %N) {
; CHECK-LABEL: define void @test2(
; CHECK-SAME: i32 [[N:%.*]]) {
; CHECK-NEXT:  [[BB:.*]]:
; CHECK-NEXT:    br label %[[OUTER_HEADER:.*]]
; CHECK:       [[OUTER_HEADER]]:
; CHECK-NEXT:    [[OUTER_IV:%.*]] = phi i64 [ 0, %[[BB]] ], [ [[OUTER_IV_NEXT:%.*]], %[[EXIT:.*]] ]
; CHECK-NEXT:    [[N_EXT:%.*]] = sext i32 [[N]] to i64
; CHECK-NEXT:    br label %[[INNER:.*]]
; CHECK:       [[INNER]]:
; CHECK-NEXT:    [[INNER_IV:%.*]] = phi i64 [ 0, %[[OUTER_HEADER]] ], [ [[TMP0:%.*]], %[[INNER]] ]
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds [4 x [4 x [2 x i16]]], ptr @global, i64 0, i64 [[INNER_IV]], i64 [[OUTER_IV]], i64 0
; CHECK-NEXT:    store i16 0, ptr [[TMP8]], align 2
; CHECK-NEXT:    [[TMP0]] = add nsw i64 [[INNER_IV]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i64 [[TMP0]], [[N_EXT]]
; CHECK-NEXT:    br i1 [[TMP1]], label %[[INNER]], label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[OUTER_IV_NEXT]] = add nsw i64 [[OUTER_IV]], 1
; CHECK-NEXT:    [[C_2:%.*]] = icmp ne i64 [[OUTER_IV]], [[N_EXT]]
; CHECK-NEXT:    br i1 [[C_2]], label %[[OUTER_HEADER]], label %[[EXIT1:.*]]
; CHECK:       [[EXIT1]]:
; CHECK-NEXT:    ret void
;
; CHECK-DELIN-LABEL: define void @test2(
; CHECK-DELIN-SAME: i32 [[N:%.*]]) {
; CHECK-DELIN-NEXT:  [[BB:.*:]]
; CHECK-DELIN-NEXT:    br label %[[INNER_PREHEADER:.*]]
; CHECK-DELIN:       [[OUTER_HEADER_PREHEADER:.*]]:
; CHECK-DELIN-NEXT:    br label %[[OUTER_HEADER:.*]]
; CHECK-DELIN:       [[OUTER_HEADER]]:
; CHECK-DELIN-NEXT:    [[OUTER_IV:%.*]] = phi i64 [ [[OUTER_IV_NEXT:%.*]], %[[OUTER_LATCH:.*]] ], [ 0, %[[OUTER_HEADER_PREHEADER]] ]
; CHECK-DELIN-NEXT:    [[N_EXT:%.*]] = sext i32 [[N]] to i64
; CHECK-DELIN-NEXT:    br label %[[INNER_SPLIT1:.*]]
; CHECK-DELIN:       [[INNER_PREHEADER]]:
; CHECK-DELIN-NEXT:    br label %[[INNER:.*]]
; CHECK-DELIN:       [[INNER]]:
; CHECK-DELIN-NEXT:    [[INNER_IV:%.*]] = phi i64 [ [[TMP0:%.*]], %[[INNER_SPLIT:.*]] ], [ 0, %[[INNER_PREHEADER]] ]
; CHECK-DELIN-NEXT:    br label %[[OUTER_HEADER_PREHEADER]]
; CHECK-DELIN:       [[INNER_SPLIT1]]:
; CHECK-DELIN-NEXT:    [[TMP8:%.*]] = getelementptr inbounds [4 x [4 x [2 x i16]]], ptr @global, i64 0, i64 [[INNER_IV]], i64 [[OUTER_IV]], i64 0
; CHECK-DELIN-NEXT:    store i16 0, ptr [[TMP8]], align 2
; CHECK-DELIN-NEXT:    [[INNER_IV_NEXT:%.*]] = add nsw i64 [[INNER_IV]], 1
; CHECK-DELIN-NEXT:    [[C_1:%.*]] = icmp ne i64 [[INNER_IV_NEXT]], [[N_EXT]]
; CHECK-DELIN-NEXT:    br label %[[OUTER_LATCH]]
; CHECK-DELIN:       [[INNER_SPLIT]]:
; CHECK-DELIN-NEXT:    [[N_EXT_LCSSA:%.*]] = phi i64 [ [[N_EXT]], %[[OUTER_LATCH]] ]
; CHECK-DELIN-NEXT:    [[TMP0]] = add nsw i64 [[INNER_IV]], 1
; CHECK-DELIN-NEXT:    [[TMP1:%.*]] = icmp ne i64 [[TMP0]], [[N_EXT_LCSSA]]
; CHECK-DELIN-NEXT:    br i1 [[TMP1]], label %[[INNER]], label %[[EXIT:.*]]
; CHECK-DELIN:       [[OUTER_LATCH]]:
; CHECK-DELIN-NEXT:    [[OUTER_IV_NEXT]] = add nsw i64 [[OUTER_IV]], 1
; CHECK-DELIN-NEXT:    [[C_2:%.*]] = icmp ne i64 [[OUTER_IV]], [[N_EXT]]
; CHECK-DELIN-NEXT:    br i1 [[C_2]], label %[[OUTER_HEADER]], label %[[INNER_SPLIT]]
; CHECK-DELIN:       [[EXIT]]:
; CHECK-DELIN-NEXT:    ret void
;
bb:
  br label %outer.header

outer.header:                                              ; preds = %bb11, %bb2
  %outer.iv = phi i64 [ 0, %bb ], [ %outer.iv.next, %outer.latch ]
  %N.ext = sext i32 %N to i64
  br label %inner

inner:                                              ; preds = %bb6, %bb4
  %inner.iv = phi i64 [ 0, %outer.header ], [ %inner.iv.next, %inner ]
  %gep = getelementptr inbounds [4 x [4 x [2 x i16]]], ptr @global, i64 0, i64 %inner.iv, i64 %outer.iv, i64 0
  store i16 0, ptr %gep
  %inner.iv.next = add nsw i64 %inner.iv, 1
  %c.1 = icmp ne i64 %inner.iv.next, %N.ext
  br i1 %c.1, label %inner, label %outer.latch

outer.latch:                                             ; preds = %bb6
  %outer.iv.next = add nsw i64 %outer.iv, 1
  %c.2 = icmp ne i64 %outer.iv, %N.ext
  br i1 %c.2 , label %outer.header, label %exit

exit:                                             ; preds = %bb11
  ret void
}
