; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=loop-interchange -S | FileCheck %s

@f = dso_local local_unnamed_addr global [4 x [9 x i32]] [[9 x i32] [i32 5, i32 3, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0], [9 x i32] zeroinitializer, [9 x i32] zeroinitializer, [9 x i32] zeroinitializer], align 4
@g = common dso_local local_unnamed_addr global i32 0, align 4

; int32_t f[3][3];
; int32_t g;
;
; int32_t test1(_Bool cond) {
;     for (int64_t i = 0; i < 3; i++) {
;         for (int64_t j = 0; j < 3; j++) {
;            int32_t val = f[i][j];
;            if (val == 0)
;              if (!cond)
;                g++;
;            else
;              g = 3;
;              if (!cond)
;                g++;
;         }
;     }
;     return g;
; }
;
; FIXME: if there's an output dependency inside the loop and Src doesn't
; dominate Dst, we should not interchange. Thus, this currently miscompiles.
;
define dso_local i32 @test1(i1 %cond) {
; CHECK-LABEL: define dso_local i32 @test1(
; CHECK-SAME: i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[FOR_PREHEADER:.*:]]
; CHECK-NEXT:    br label %[[INNERLOOP_PREHEADER:.*]]
; CHECK:       [[OUTERLOOP_PREHEADER:.*]]:
; CHECK-NEXT:    br label %[[OUTERLOOP:.*]]
; CHECK:       [[OUTERLOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ [[INDVARS_IV_NEXT21_I:%.*]], %[[FOR_LATCH:.*]] ], [ 0, %[[OUTERLOOP_PREHEADER]] ]
; CHECK-NEXT:    br label %[[INNERLOOP_SPLIT:.*]]
; CHECK:       [[INNERLOOP_PREHEADER]]:
; CHECK-NEXT:    br label %[[INNERLOOP:.*]]
; CHECK:       [[INNERLOOP]]:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[TMP0:%.*]], %[[IF_END_SPLIT:.*]] ], [ 0, %[[INNERLOOP_PREHEADER]] ]
; CHECK-NEXT:    br label %[[OUTERLOOP_PREHEADER]]
; CHECK:       [[INNERLOOP_SPLIT]]:
; CHECK-NEXT:    [[ARRAYIDX6_I:%.*]] = getelementptr inbounds [4 x [9 x i32]], ptr @f, i64 0, i64 [[J]], i64 [[I]]
; CHECK-NEXT:    [[I1:%.*]] = load i32, ptr [[ARRAYIDX6_I]], align 4
; CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp eq i32 [[I1]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_I]], label %[[LAND_END:.*]], label %[[LAND_RHS:.*]]
; CHECK:       [[LAND_RHS]]:
; CHECK-NEXT:    store i32 3, ptr @g, align 4
; CHECK-NEXT:    br label %[[LAND_END]]
; CHECK:       [[LAND_END]]:
; CHECK-NEXT:    br i1 [[COND]], label %[[IF_END:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[I2:%.*]] = load i32, ptr @g, align 4
; CHECK-NEXT:    [[INC_I:%.*]] = add i32 [[I2]], 1
; CHECK-NEXT:    store i32 [[INC_I]], ptr @g, align 4
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[J_NEXT:%.*]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[EXITCOND_I:%.*]] = icmp eq i64 [[J_NEXT]], 3
; CHECK-NEXT:    br label %[[FOR_LATCH]]
; CHECK:       [[IF_END_SPLIT]]:
; CHECK-NEXT:    [[TMP0]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 [[TMP0]], 3
; CHECK-NEXT:    br i1 [[TMP1]], label %[[EXIT:.*]], label %[[INNERLOOP]]
; CHECK:       [[FOR_LATCH]]:
; CHECK-NEXT:    [[INDVARS_IV_NEXT21_I]] = add nsw i64 [[I]], 1
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp slt i64 [[I]], 2
; CHECK-NEXT:    br i1 [[CMP_I]], label %[[OUTERLOOP]], label %[[IF_END_SPLIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[I3:%.*]] = load i32, ptr @g, align 4
; CHECK-NEXT:    ret i32 [[I3]]
;
for.preheader:
  br label %outerloop

outerloop:
  %i = phi i64 [ 0, %for.preheader ], [ %indvars.iv.next21.i, %for.latch ]
  br label %innerloop

innerloop:
  %j = phi i64 [ 0, %outerloop ], [ %j.next, %if.end ]
  %arrayidx6.i = getelementptr inbounds [4 x [9 x i32]], [4 x [9 x i32]]* @f, i64 0, i64 %j, i64 %i
  %i1 = load i32, i32* %arrayidx6.i, align 4
  %tobool.i = icmp eq i32 %i1, 0
  br i1 %tobool.i, label %land.end, label %land.rhs

land.rhs:
  store i32 3, i32* @g, align 4
  br label %land.end

land.end:
  br i1 %cond, label %if.end, label %if.then

if.then:
  %i2 = load i32, i32* @g, align 4
  %inc.i = add i32 %i2, 1
  store i32 %inc.i, i32* @g, align 4
  br label %if.end

if.end:
  %j.next = add nuw nsw i64 %j, 1
  %exitcond.i = icmp eq i64 %j.next, 3
  br i1 %exitcond.i, label %for.latch, label %innerloop

for.latch:
  %indvars.iv.next21.i = add nsw i64 %i, 1
  %cmp.i = icmp slt i64 %i, 2
  br i1 %cmp.i, label %outerloop, label %exit

exit:
  %i3 = load i32, i32* @g, align 4
  ret i32 %i3
}

; int32_t f[3][3];
; int32_t g;
;
; int32_t test2(_Bool cond) {
;     for (int64_t i = 0; i < 3; i++) {
;       for (int64_t j = 0; j < 3; j++) {
;          int32_t val = f[i][j];
;          g = 3;
;          if (val == 0)
;            if (!cond)
;              g++;
;          else
;            if (!cond)
;              g++;
;         }
;     }
;     return g;
; }
;
; FIXME: if there's an output dependency inside the loop and Src doesn't
; dominate Dst, we should not interchange. Thus, this currently miscompiles.
;
define dso_local i32 @test2(i1 %cond) {
; CHECK-LABEL: define dso_local i32 @test2(
; CHECK-SAME: i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[FOR_PREHEADER:.*:]]
; CHECK-NEXT:    br label %[[INNERLOOP_PREHEADER:.*]]
; CHECK:       [[OUTERLOOP_PREHEADER:.*]]:
; CHECK-NEXT:    br label %[[OUTERLOOP:.*]]
; CHECK:       [[OUTERLOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ [[INDVARS_IV_NEXT21_I:%.*]], %[[FOR_LATCH:.*]] ], [ 0, %[[OUTERLOOP_PREHEADER]] ]
; CHECK-NEXT:    br label %[[INNERLOOP_SPLIT:.*]]
; CHECK:       [[INNERLOOP_PREHEADER]]:
; CHECK-NEXT:    br label %[[INNERLOOP:.*]]
; CHECK:       [[INNERLOOP]]:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[TMP0:%.*]], %[[IF_END_SPLIT:.*]] ], [ 0, %[[INNERLOOP_PREHEADER]] ]
; CHECK-NEXT:    br label %[[OUTERLOOP_PREHEADER]]
; CHECK:       [[INNERLOOP_SPLIT]]:
; CHECK-NEXT:    [[ARRAYIDX6_I:%.*]] = getelementptr inbounds [4 x [9 x i32]], ptr @f, i64 0, i64 [[J]], i64 [[I]]
; CHECK-NEXT:    [[I1:%.*]] = load i32, ptr [[ARRAYIDX6_I]], align 4
; CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp eq i32 [[I1]], 0
; CHECK-NEXT:    store i32 3, ptr @g, align 4
; CHECK-NEXT:    br i1 [[TOBOOL_I]], label %[[LAND_END:.*]], label %[[LAND_RHS:.*]]
; CHECK:       [[LAND_RHS]]:
; CHECK-NEXT:    br label %[[LAND_END]]
; CHECK:       [[LAND_END]]:
; CHECK-NEXT:    br i1 [[COND]], label %[[IF_END:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[I2:%.*]] = load i32, ptr @g, align 4
; CHECK-NEXT:    [[INC_I:%.*]] = add i32 [[I2]], 1
; CHECK-NEXT:    store i32 [[INC_I]], ptr @g, align 4
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[J_NEXT:%.*]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[EXITCOND_I:%.*]] = icmp eq i64 [[J_NEXT]], 3
; CHECK-NEXT:    br label %[[FOR_LATCH]]
; CHECK:       [[IF_END_SPLIT]]:
; CHECK-NEXT:    [[TMP0]] = add nuw nsw i64 [[J]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 [[TMP0]], 3
; CHECK-NEXT:    br i1 [[TMP1]], label %[[EXIT:.*]], label %[[INNERLOOP]]
; CHECK:       [[FOR_LATCH]]:
; CHECK-NEXT:    [[INDVARS_IV_NEXT21_I]] = add nsw i64 [[I]], 1
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp slt i64 [[I]], 2
; CHECK-NEXT:    br i1 [[CMP_I]], label %[[OUTERLOOP]], label %[[IF_END_SPLIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[I3:%.*]] = load i32, ptr @g, align 4
; CHECK-NEXT:    ret i32 [[I3]]
;
for.preheader:
  br label %outerloop

outerloop:
  %i = phi i64 [ 0, %for.preheader ], [ %indvars.iv.next21.i, %for.latch ]
  br label %innerloop

innerloop:
  %j = phi i64 [ 0, %outerloop ], [ %j.next, %if.end ]
  %arrayidx6.i = getelementptr inbounds [4 x [9 x i32]], [4 x [9 x i32]]* @f, i64 0, i64 %j, i64 %i
  %i1 = load i32, i32* %arrayidx6.i, align 4
  %tobool.i = icmp eq i32 %i1, 0
  store i32 3, i32* @g, align 4
  br i1 %tobool.i, label %land.end, label %land.rhs

land.rhs:
  br label %land.end

land.end:
  br i1 %cond, label %if.end, label %if.then

if.then:
  %i2 = load i32, i32* @g, align 4
  %inc.i = add i32 %i2, 1
  store i32 %inc.i, i32* @g, align 4
  br label %if.end

if.end:
  %j.next = add nuw nsw i64 %j, 1
  %exitcond.i = icmp eq i64 %j.next, 3
  br i1 %exitcond.i, label %for.latch, label %innerloop

for.latch:
  %indvars.iv.next21.i = add nsw i64 %i, 1
  %cmp.i = icmp slt i64 %i, 2
  br i1 %cmp.i, label %outerloop, label %exit

exit:
  %i3 = load i32, i32* @g, align 4
  ret i32 %i3
}
