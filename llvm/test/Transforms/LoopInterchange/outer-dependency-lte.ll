; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=loop-interchange -pass-remarks-missed='loop-interchange' -pass-remarks-output=%t \
; RUN:     -verify-dom-info -verify-loop-info -verify-loop-lcssa -S 2>&1 | FileCheck %s

;; The original code:
;;
;; #define N 4
;; int a[N*N][N*N][N*N];
;; void f() {
;;   for (int i = 0; i < N; i++)
;;     for (int j = 1; j < 2*N; j++)
;;       for (int k = 1; k < 2*N; k++)
;;         a[2*i][k+1][j-1] -= a[i+N-1][k][j];
;; }
;;
;; The entry of the direction vector for the outermost loop is `DVEntry::LE`.
;; We need to treat this as `*`, not `<`. See issue #123920 for details.
;; In conclusion, we must not interchange the loops.

@a = dso_local global [16 x [16 x [16 x i32]]] zeroinitializer, align 4

define dso_local void @f() {
; CHECK-LABEL: define dso_local void @f() {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[FOR_COND1_PREHEADER:.*]]
; CHECK:       [[FOR_COND1_PREHEADER]]:
; CHECK-NEXT:    [[I_039:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[INC26:%.*]], %[[FOR_COND_CLEANUP3:.*]] ]
; CHECK-NEXT:    [[SUB:%.*]] = add nuw nsw i32 [[I_039]], 3
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext nneg i32 [[SUB]] to i64
; CHECK-NEXT:    [[MUL:%.*]] = shl nuw nsw i32 [[I_039]], 1
; CHECK-NEXT:    [[IDXPROM13:%.*]] = zext nneg i32 [[MUL]] to i64
; CHECK-NEXT:    br label %[[FOR_COND5_PREHEADER:.*]]
; CHECK:       [[FOR_COND_CLEANUP:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[FOR_COND5_PREHEADER]]:
; CHECK-NEXT:    [[J_038:%.*]] = phi i32 [ 1, %[[FOR_COND1_PREHEADER]] ], [ [[INC23:%.*]], %[[FOR_COND_CLEANUP7:.*]] ]
; CHECK-NEXT:    [[IDXPROM11:%.*]] = zext nneg i32 [[J_038]] to i64
; CHECK-NEXT:    [[SUB18:%.*]] = add nsw i32 [[J_038]], -1
; CHECK-NEXT:    [[IDXPROM19:%.*]] = sext i32 [[SUB18]] to i64
; CHECK-NEXT:    br label %[[FOR_BODY8:.*]]
; CHECK:       [[FOR_COND_CLEANUP3]]:
; CHECK-NEXT:    [[INC26]] = add nuw nsw i32 [[I_039]], 1
; CHECK-NEXT:    [[CMP:%.*]] = icmp samesign ult i32 [[I_039]], 3
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_COND1_PREHEADER]], label %[[FOR_COND_CLEANUP]]
; CHECK:       [[FOR_COND_CLEANUP7]]:
; CHECK-NEXT:    [[INC23]] = add nuw nsw i32 [[J_038]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp samesign ult i32 [[J_038]], 7
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_COND5_PREHEADER]], label %[[FOR_COND_CLEANUP3]]
; CHECK:       [[FOR_BODY8]]:
; CHECK-NEXT:    [[K_037:%.*]] = phi i32 [ 1, %[[FOR_COND5_PREHEADER]] ], [ [[ADD15:%.*]], %[[FOR_BODY8]] ]
; CHECK-NEXT:    [[IDXPROM9:%.*]] = zext nneg i32 [[K_037]] to i64
; CHECK-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds nuw [16 x [16 x [16 x i32]]], ptr @a, i64 0, i64 [[IDXPROM]], i64 [[IDXPROM9]], i64 [[IDXPROM11]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARRAYIDX12]], align 4
; CHECK-NEXT:    [[ADD15]] = add nuw nsw i32 [[K_037]], 1
; CHECK-NEXT:    [[IDXPROM16:%.*]] = zext nneg i32 [[ADD15]] to i64
; CHECK-NEXT:    [[ARRAYIDX20:%.*]] = getelementptr inbounds [16 x [16 x [16 x i32]]], ptr @a, i64 0, i64 [[IDXPROM13]], i64 [[IDXPROM16]], i64 [[IDXPROM19]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARRAYIDX20]], align 4
; CHECK-NEXT:    [[SUB21:%.*]] = sub nsw i32 [[TMP1]], [[TMP0]]
; CHECK-NEXT:    store i32 [[SUB21]], ptr [[ARRAYIDX20]], align 4
; CHECK-NEXT:    [[CMP6:%.*]] = icmp samesign ult i32 [[K_037]], 7
; CHECK-NEXT:    br i1 [[CMP6]], label %[[FOR_BODY8]], label %[[FOR_COND_CLEANUP7]]
;
entry:
  br label %for.cond1.preheader

for.cond1.preheader:
  %i.039 = phi i32 [ 0, %entry ], [ %inc26, %for.cond.cleanup3 ]
  %sub = add nuw nsw i32 %i.039, 3
  %idxprom = zext nneg i32 %sub to i64
  %mul = shl nuw nsw i32 %i.039, 1
  %idxprom13 = zext nneg i32 %mul to i64
  br label %for.cond5.preheader

for.cond.cleanup:
  ret void

for.cond5.preheader:
  %j.038 = phi i32 [ 1, %for.cond1.preheader ], [ %inc23, %for.cond.cleanup7 ]
  %idxprom11 = zext nneg i32 %j.038 to i64
  %sub18 = add nsw i32 %j.038, -1
  %idxprom19 = sext i32 %sub18 to i64
  br label %for.body8

for.cond.cleanup3:
  %inc26 = add nuw nsw i32 %i.039, 1
  %cmp = icmp samesign ult i32 %i.039, 3
  br i1 %cmp, label %for.cond1.preheader, label %for.cond.cleanup

for.cond.cleanup7:
  %inc23 = add nuw nsw i32 %j.038, 1
  %cmp2 = icmp samesign ult i32 %j.038, 7
  br i1 %cmp2, label %for.cond5.preheader, label %for.cond.cleanup3

for.body8:
  %k.037 = phi i32 [ 1, %for.cond5.preheader ], [ %add15, %for.body8 ]
  %idxprom9 = zext nneg i32 %k.037 to i64
  %arrayidx12 = getelementptr inbounds nuw [16 x [16 x [16 x i32]]], ptr @a, i64 0, i64 %idxprom, i64 %idxprom9, i64 %idxprom11
  %0 = load i32, ptr %arrayidx12, align 4
  %add15 = add nuw nsw i32 %k.037, 1
  %idxprom16 = zext nneg i32 %add15 to i64
  %arrayidx20 = getelementptr inbounds [16 x [16 x [16 x i32]]], ptr @a, i64 0, i64 %idxprom13, i64 %idxprom16, i64 %idxprom19
  %1 = load i32, ptr %arrayidx20, align 4
  %sub21 = sub nsw i32 %1, %0
  store i32 %sub21, ptr %arrayidx20, align 4
  %cmp6 = icmp samesign ult i32 %k.037, 7
  br i1 %cmp6, label %for.body8, label %for.cond.cleanup7
}
