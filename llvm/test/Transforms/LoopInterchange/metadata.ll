; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=loop-interchange -loop-interchange-only-when-forced=1 --cache-line-size=64 -S < %s | FileCheck %s

@a = dso_local local_unnamed_addr global [128 x [128 x [128 x i32]]] zeroinitializer, align 4

; Check that the interchanges are applied in the expected order. The original
; code looks like as follows:
;
; #pragma clang loop interchange(enable)
; for (int j=0; j<128; j++)
;   #pragma clang loop interchange(enable)
;   for (int i=0; i<128; i++)
;     for (int k=0; k<128; k++)
;       a[k][j][i]++;
;
; At first the interchange is applied to the j-loop and the k-loop. The
; follow-up metadata is attached to the outermost loop, then the interchange to
; the i-loop and the k-loop.
;
define void @f() {
; CHECK-LABEL: define void @f() {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[FOR_I_HEADER:.*]]
; CHECK:       [[FOR_I_HEADER]]:
; CHECK-NEXT:    [[IV_I:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[IV_I_NEXT:%.*]], %[[FOR_I_CLEANUP:.*]] ]
; CHECK-NEXT:    br label %[[FOR_J_HEADER:.*]]
; CHECK:       [[FOR_J_HEADER]]:
; CHECK-NEXT:    [[IV_J:%.*]] = phi i64 [ 0, %[[FOR_I_HEADER]] ], [ [[IV_J_NEXT:%.*]], %[[FOR_J_CLEANUP:.*]] ]
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[IV_K:%.*]] = phi i64 [ 0, %[[FOR_J_HEADER]] ], [ [[TMP0:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds nuw [128 x [128 x [128 x i32]]], ptr @a, i64 [[IV_K]], i64 [[IV_J]], i64 [[IV_I]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[VAL]], 1
; CHECK-NEXT:    store i32 [[INC]], ptr [[PTR]], align 4
; CHECK-NEXT:    [[TMP0]] = add nuw nsw i64 [[IV_K]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 [[TMP0]], 128
; CHECK-NEXT:    br i1 [[TMP1]], label %[[FOR_J_CLEANUP]], label %[[FOR_BODY]]
; CHECK:       [[FOR_J_CLEANUP]]:
; CHECK-NEXT:    [[IV_J_NEXT]] = add nuw nsw i64 [[IV_J]], 1
; CHECK-NEXT:    [[EXITCOND_J:%.*]] = icmp eq i64 [[IV_J_NEXT]], 128
; CHECK-NEXT:    br i1 [[EXITCOND_J]], label %[[FOR_I_CLEANUP]], label %[[FOR_J_HEADER]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[FOR_I_CLEANUP]]:
; CHECK-NEXT:    [[IV_I_NEXT]] = add nuw nsw i64 [[IV_I]], 1
; CHECK-NEXT:    [[EXITCOND_I:%.*]] = icmp eq i64 [[IV_I_NEXT]], 128
; CHECK-NEXT:    br i1 [[EXITCOND_I]], label %[[EXIT:.*]], label %[[FOR_I_HEADER]], !llvm.loop [[LOOP8:![0-9]+]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.i.header

for.i.header:
  %iv.i = phi i64 [ 0, %entry ], [ %iv.i.next, %for.i.cleanup ]
  br label %for.j.header

for.j.header:
  %iv.j = phi i64 [ 0, %for.i.header ], [ %iv.j.next, %for.j.cleanup ]
  br label %for.body

for.body:
  %iv.k = phi i64 [ 0, %for.j.header ], [ %iv.k.next, %for.body ]
  %ptr = getelementptr inbounds nuw [128 x [128 x [128 x i32]]], ptr @a, i64 %iv.k, i64 %iv.j, i64 %iv.i
  %val = load i32, ptr %ptr, align 4
  %inc = add nuw nsw i32 %val, 1
  store i32 %inc, ptr %ptr, align 4
  %iv.k.next = add nuw nsw i64 %iv.k, 1
  %exitcond.k = icmp eq i64 %iv.k.next, 128
  br i1 %exitcond.k, label %for.j.cleanup, label %for.body

for.j.cleanup:
  %iv.j.next = add nuw nsw i64 %iv.j, 1
  %exitcond.j = icmp eq i64 %iv.j.next, 128
  br i1 %exitcond.j, label %for.i.cleanup, label %for.j.header, !llvm.loop !0

for.i.cleanup:
  %iv.i.next = add nuw nsw i64 %iv.i, 1
  %exitcond.i = icmp eq i64 %iv.i.next, 128
  br i1 %exitcond.i, label %exit, label %for.i.header, !llvm.loop !5

exit:
  ret void
}

!0 = distinct !{!0, !1, !2, !3, !4, !5}
!1 = !{!"llvm.loop.interchange.enable", i1 true}
!2 = !{!"llvm.loop.interchange.followup_all", !{!"FolloupAll"}}
!3 = !{!"llvm.loop.interchange.followup_inner", !{!"FollowupInner0"}}
!4 = !{!"llvm.loop.interchange.followup_outer", !{!"FollowupOuter0"}}
!5 = !{!"llvm.loop.interchange.followup_next_outer", !1, !2, !6, !7}
!6 = !{!"llvm.loop.interchange.followup_inner", !{!"FollowupInner1"}}
!7 = !{!"llvm.loop.interchange.followup_outer", !{!"FollowupOuter1"}}
;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]], [[META4:![0-9]+]], [[META6:![0-9]+]], [[LOOP8]]}
; CHECK: [[META1]] = !{!"llvm.loop.interchange.enable", i1 true}
; CHECK: [[META2]] = !{!"llvm.loop.interchange.followup_all", [[META3:![0-9]+]]}
; CHECK: [[META3]] = !{!"FolloupAll"}
; CHECK: [[META4]] = !{!"llvm.loop.interchange.followup_inner", [[META5:![0-9]+]]}
; CHECK: [[META5]] = !{!"FollowupInner0"}
; CHECK: [[META6]] = !{!"llvm.loop.interchange.followup_outer", [[META7:![0-9]+]]}
; CHECK: [[META7]] = !{!"FollowupOuter0"}
; CHECK: [[LOOP8]] = !{!"llvm.loop.interchange.followup_next_outer", [[META1]], [[META2]], [[META9:![0-9]+]], [[META11:![0-9]+]]}
; CHECK: [[META9]] = !{!"llvm.loop.interchange.followup_inner", [[META10:![0-9]+]]}
; CHECK: [[META10]] = !{!"FollowupInner1"}
; CHECK: [[META11]] = !{!"llvm.loop.interchange.followup_outer", [[META12:![0-9]+]]}
; CHECK: [[META12]] = !{!"FollowupOuter1"}
;.
