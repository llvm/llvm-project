; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=loop-interchange -loop-interchange-only-when-forced=1 --cache-line-size=64 -S < %s | FileCheck %s

@a = dso_local local_unnamed_addr global [128 x [128 x [128 x i32]]] zeroinitializer, align 4

; Check that the interchanges are applied in the expected order. The original
; code looks like as follows:
;
; #pragma clang loop interchange(enable)
; for (int j=0; j<128; j++)
;   #pragma clang loop interchange(enable)
;   for (int i=0; i<128; i++)
;     for (int k=0; k<128; k++)
;       a[k][j][i]++;
;
; At first the interchange is applied to the i-loop and the k-loop. The
; follow-up metadata is attached to the outermost loop, then the interchange to
; the j-loop and the k-loop.
;
define void @f() {
; CHECK-LABEL: define void @f() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[FOR_BODY_PREHEADER:.*]]
; CHECK:       [[FOR_J_HEADER_PREHEADER:.*]]:
; CHECK-NEXT:    br label %[[FOR_J_HEADER:.*]]
; CHECK:       [[FOR_J_HEADER]]:
; CHECK-NEXT:    [[IV_J:%.*]] = phi i64 [ [[IV_I_NEXT1:%.*]], %[[FOR_J_CLEANUP:.*]] ], [ 0, %[[FOR_J_HEADER_PREHEADER]] ]
; CHECK-NEXT:    br label %[[FOR_I_HEADER_PREHEADER:.*]]
; CHECK:       [[FOR_I_HEADER_PREHEADER]]:
; CHECK-NEXT:    br label %[[FOR_I_HEADER:.*]]
; CHECK:       [[FOR_I_HEADER]]:
; CHECK-NEXT:    [[IV_I:%.*]] = phi i64 [ [[IV_I_NEXT:%.*]], %[[FOR_I_CLEANUP:.*]] ], [ 0, %[[FOR_I_HEADER_PREHEADER]] ]
; CHECK-NEXT:    br label %[[FOR_BODY_SPLIT1:.*]]
; CHECK:       [[FOR_BODY_PREHEADER]]:
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[IV_K:%.*]] = phi i64 [ [[IV_J_NEXT:%.*]], %[[FOR_BODY_SPLIT:.*]] ], [ 0, %[[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    br label %[[FOR_J_HEADER_PREHEADER]]
; CHECK:       [[FOR_BODY_SPLIT1]]:
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds nuw [128 x [128 x [128 x i32]]], ptr @a, i64 [[IV_K]], i64 [[IV_J]], i64 [[IV_I]]
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[PTR]], align 4
; CHECK-NEXT:    [[INC:%.*]] = add nuw nsw i32 [[VAL]], 1
; CHECK-NEXT:    store i32 [[INC]], ptr [[PTR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = add nuw nsw i64 [[IV_K]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 [[TMP0]], 128
; CHECK-NEXT:    br label %[[FOR_I_CLEANUP]]
; CHECK:       [[FOR_BODY_SPLIT]]:
; CHECK-NEXT:    [[IV_J_NEXT]] = add nuw nsw i64 [[IV_K]], 1
; CHECK-NEXT:    [[EXITCOND_J:%.*]] = icmp eq i64 [[IV_J_NEXT]], 128
; CHECK-NEXT:    br i1 [[EXITCOND_J]], label %[[EXIT:.*]], label %[[FOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       [[FOR_I_CLEANUP]]:
; CHECK-NEXT:    [[IV_I_NEXT]] = add nuw nsw i64 [[IV_I]], 1
; CHECK-NEXT:    [[EXITCOND_I:%.*]] = icmp eq i64 [[IV_I_NEXT]], 128
; CHECK-NEXT:    br i1 [[EXITCOND_I]], label %[[FOR_J_CLEANUP]], label %[[FOR_I_HEADER]], !llvm.loop [[LOOP3:![0-9]+]]
; CHECK:       [[FOR_J_CLEANUP]]:
; CHECK-NEXT:    [[IV_I_NEXT1]] = add nuw nsw i64 [[IV_J]], 1
; CHECK-NEXT:    [[EXITCOND_I1:%.*]] = icmp eq i64 [[IV_I_NEXT1]], 128
; CHECK-NEXT:    br i1 [[EXITCOND_I1]], label %[[FOR_BODY_SPLIT]], label %[[FOR_J_HEADER]], !llvm.loop [[LOOP5:![0-9]+]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.j.header

for.j.header:
  %iv.j = phi i64 [ 0, %entry ], [ %iv.j.next, %for.j.cleanup ]
  br label %for.i.header

for.i.header:
  %iv.i = phi i64 [ 0, %for.j.header ], [ %iv.i.next, %for.i.cleanup ]
  br label %for.body

for.body:
  %iv.k = phi i64 [ 0, %for.i.header ], [ %iv.k.next, %for.body ]
  %ptr = getelementptr inbounds nuw [128 x [128 x [128 x i32]]], ptr @a, i64 %iv.k, i64 %iv.j, i64 %iv.i
  %val = load i32, ptr %ptr, align 4
  %inc = add nuw nsw i32 %val, 1
  store i32 %inc, ptr %ptr, align 4
  %iv.k.next = add nuw nsw i64 %iv.k, 1
  %exitcond.k = icmp eq i64 %iv.k.next, 128
  br i1 %exitcond.k, label %for.i.cleanup, label %for.body

for.i.cleanup:
  %iv.i.next = add nuw nsw i64 %iv.i, 1
  %exitcond.i = icmp eq i64 %iv.i.next, 128
  br i1 %exitcond.i, label %for.j.cleanup, label %for.i.header, !llvm.loop !0

for.j.cleanup:
  %iv.j.next = add nuw nsw i64 %iv.j, 1
  %exitcond.j = icmp eq i64 %iv.j.next, 128
  br i1 %exitcond.j, label %exit, label %for.j.header

exit:
  ret void
}

!0 = distinct !{!0, !1, !2, !3, !4, !5}
!1 = !{!"llvm.loop.interchange.enable", i1 true}
!2 = !{!"llvm.loop.interchange.followup_all", !{!"FolloupAll"}}
!3 = !{!"llvm.loop.interchange.followup_inner", !{!"FollowupInner0"}}
!4 = !{!"llvm.loop.interchange.followup_outer", !{!"FollowupOuter0"}}
!5 = !{!"llvm.loop.interchange.followup_next_outer", !1, !2, !6, !7}
!6 = !{!"llvm.loop.interchange.followup_inner", !{!"FollowupInner1"}}
!7 = !{!"llvm.loop.interchange.followup_outer", !{!"FollowupOuter1"}}
;.
; CHECK: [[LOOP0]] = distinct !{[[LOOP0]], [[META1:![0-9]+]], [[META2:![0-9]+]]}
; CHECK: [[META1]] = !{!"FolloupAll"}
; CHECK: [[META2]] = !{!"FollowupInner1"}
; CHECK: [[LOOP3]] = distinct !{[[LOOP3]], [[META1]], [[META4:![0-9]+]]}
; CHECK: [[META4]] = !{!"FollowupOuter0"}
; CHECK: [[LOOP5]] = distinct !{[[LOOP5]], [[META1]], [[META6:![0-9]+]]}
; CHECK: [[META6]] = !{!"FollowupOuter1"}
;.
