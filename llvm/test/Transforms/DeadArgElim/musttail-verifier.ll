; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; Testcases comes from PR126817 and PR107569
; See PR54964 and langref for more information about how llvm deal with musttail currently
; RUN: opt -passes=deadargelim -S < %s | FileCheck %s

define i64 @A() {
; CHECK-LABEL: define i64 @A() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[V2660:%.*]] = musttail call i64 @B()
; CHECK-NEXT:    ret i64 [[V2660]]
;
entry:
  %v2660 = musttail call i64 @B()
  ret i64 %v2660
}

define internal i64 @B() {
; CHECK-LABEL: define internal i64 @B() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i64 0
;
entry:
  ret i64 0
}

define internal i64 @C() {
; CHECK-LABEL: define internal i64 @C() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[V30543:%.*]] = musttail call i64 @B()
; CHECK-NEXT:    ret i64 [[V30543]]
;
entry:
  %v30543 = musttail call i64 @B()
  ret i64 %v30543
}

%struct.S = type { double }

define internal %struct.S @F38() {
; CHECK-LABEL: define internal %struct.S @F38() {
; CHECK-NEXT:    ret [[STRUCT_S:%.*]] zeroinitializer
;
  ret %struct.S { double 0.0 }
}

define internal %struct.S @F36() {
; CHECK-LABEL: define internal %struct.S @F36() {
; CHECK-NEXT:    [[TMP1:%.*]] = alloca [[STRUCT_S:%.*]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = musttail call [[STRUCT_S]] @[[F38:[a-zA-Z0-9_$\"\\.-]*[a-zA-Z_$\"\\.-][a-zA-Z0-9_$\"\\.-]*]]()
; CHECK-NEXT:    ret [[STRUCT_S]] [[TMP2]]
;
  %1 = alloca %struct.S, align 8
  %3 = musttail call %struct.S @F38()
  ret %struct.S %3
}

define double @foo() {
; CHECK-LABEL: define double @foo() {
; CHECK-NEXT:    [[TMP1:%.*]] = call [[STRUCT_S:%.*]] @[[F36:[a-zA-Z0-9_$\"\\.-]*[a-zA-Z_$\"\\.-][a-zA-Z0-9_$\"\\.-]*]]()
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue [[STRUCT_S]] [[TMP1]], 0
; CHECK-NEXT:    ret double [[TMP2]]
;
  %3 = call %struct.S @F36()
  %5 = extractvalue %struct.S %3, 0
  ret double %5
}
