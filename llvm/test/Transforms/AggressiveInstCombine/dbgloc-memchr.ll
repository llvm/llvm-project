; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -p=aggressive-instcombine < %s | FileCheck %s
;; Tests that when we inline a simple memchr, we transfer its DILocation to the
;; generated instructions.

@.str.30 = constant [3 x i8] c"/\\\00"

define i32 @foo(i32 %conv22) {
; CHECK-LABEL: define i32 @foo(
; CHECK-SAME: i32 [[CONV22:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = trunc i32 [[CONV22]] to i8, !dbg [[DBG3:![0-9]+]]
; CHECK-NEXT:    switch i8 [[TMP0]], label %[[ENTRY_SPLIT:.*]] [
; CHECK-NEXT:    ], !dbg [[DBG3]]
; CHECK:       [[MEMCHR_SUCCESS:.*:]]
; CHECK-NEXT:    br label %[[ENTRY_SPLIT]], !dbg [[DBG3]]
; CHECK:       [[ENTRY_SPLIT]]:
; CHECK-NEXT:    ret i32 0
;
entry:
  %memchr = call ptr @memchr(ptr @.str.30, i32 %conv22, i64 0), !dbg !3
  ret i32 0
}

declare ptr @memchr(ptr, i32, i64)

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!2}

!0 = distinct !DICompileUnit(language: DW_LANG_C11, file: !1, producer: "clang version 20.0.0git")
!1 = !DIFile(filename: "test.c", directory: "/tmp")
!2 = !{i32 2, !"Debug Info Version", i32 3}
!3 = !DILocation(line: 19, column: 42, scope: !4)
!4 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 174, type: !5, unit: !0, retainedNodes: !6)
!5 = !DISubroutineType(types: !6)
!6 = !{}
;.
; CHECK: [[META0:![0-9]+]] = distinct !DICompileUnit(language: DW_LANG_C11, file: [[META1:![0-9]+]], producer: "{{.*}}clang version {{.*}}", isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug)
; CHECK: [[META1]] = !DIFile(filename: "test.c", directory: {{.*}})
; CHECK: [[DBG3]] = !DILocation(line: 19, column: 42, scope: [[META4:![0-9]+]])
; CHECK: [[META4]] = distinct !DISubprogram(name: "foo", scope: [[META1]], file: [[META1]], line: 174, type: [[META5:![0-9]+]], spFlags: DISPFlagDefinition, unit: [[META0]], retainedNodes: [[META6:![0-9]+]])
; CHECK: [[META5]] = !DISubroutineType(types: [[META6]])
; CHECK: [[META6]] = !{}
;.
