; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -aggressive-instcombine -S < %s | FileCheck %s --implicit-check-not=llvm.cttz

;; These cases should ensure we are not lowering of some wrong implementations
;; of table-based ctz algorithms to the llvm.cttz instruction.

@ctz7.table = internal unnamed_addr constant [32 x i8] c"\05\01\1C\02\1D\0E\18\03\1E\16\14\0F\19\11\04\08\1F\1B\0D\17\15\13\10\07\1A\0C\12\06\0B\05\0A\09", align 1

;; This is a negative test with a wrong table constant.

define i32 @ctz1(i32 %x) {
entry:
  %sub = sub i32 0, %x
  %and = and i32 %sub, %x
  %mul = mul i32 %and, 125613361
  %shr = lshr i32 %mul, 27
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz7.table, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

;; These are some negative tests with a wrong instruction sequences.

@ctz1.table = internal unnamed_addr constant [32 x i8] c"\00\01\1C\02\1D\0E\18\03\1E\16\14\0F\19\11\04\08\1F\1B\0D\17\15\13\10\07\1A\0C\12\06\0B\05\0A\09", align 1

define i32 @ctz2(i32 %x) {
entry:
  %sub = sub i32 1, %x
  %and = and i32 %sub, %x
  %mul = mul i32 %and, 125613361
  %shr = lshr i32 %mul, 27
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

define i32 @ctz3(i32 %x) {
entry:
  %sub = sub i32 0, %x
  %and = and i32 %sub, %x
  %mul = mul i32 %and, 125613362
  %shr = lshr i32 %mul, 27
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

define i32 @ctz4(i32 %x) {
entry:
  %sub = sub i32 0, %x
  %and = and i32 %sub, %x
  %mul = mul i32 %and, 125613361
  %shr = lshr i32 %mul, 26
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* @ctz1.table, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

;; This is a negative test with a wrong table size and constants.

@ctz3.table = internal unnamed_addr constant [128 x i8] c"\00\01\1C\02\1D\0E\18\03\1E\16\14\0F\19\11\04\08\1F\1B\0D\17\15\13\10\07\1A\0C\12\06\0B\05\0A\09\00\01\1C\02\1D\0E\18\03\1E\16\14\0F\19\11\04\08\1F\1B\0D\17\15\13\10\07\1A\0C\12\06\0B\05\0A\09\00\01\1C\02\1D\0E\18\03\1E\16\14\0F\19\11\04\08\1F\1B\0D\17\15\13\10\07\1A\0C\12\06\0B\05\0A\09\00\01\1C\02\1D\0E\18\03\1E\16\14\0F\19\11\04\08\1F\1B\0D\17\15\13\10\07\1A\0C\12\06\0B\05\0A\09", align 1

define i32 @ctz5(i32 %x) {
entry:
  %sub = sub i32 0, %x
  %and = and i32 %sub, %x
  %mul = mul i32 %and, 125613361
  %shr = lshr i32 %mul, 27
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds [128 x i8], [128 x i8]* @ctz3.table, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %0 to i32
  ret i32 %conv
}

;; A test with an extern global variable representing the table.
;; extern int table[32];
;;
;;  int ctz6(unsigned x) {
;;    if (x == 0) return 32;
;;    x = (x & -x) * 0x04D7651F;
;;    return table[x >> 27];
;;  }

@table = external global [32 x i32], align 16
define i32 @ctz6(i32 noundef %x) {
entry:
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %sub = sub i32 0, %x
  %and = and i32 %sub, %x
  %mul = mul i32 %and, 81224991
  %shr = lshr i32 %mul, 27
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x i32], [32 x i32]* @table, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %0, %if.end ], [ 32, %entry ]
  ret i32 %retval.0
}
