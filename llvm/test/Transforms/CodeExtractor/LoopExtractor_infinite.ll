; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
; RUN: opt < %s -passes=loop-extract -S | FileCheck %s

; This test used to enter an infinite loop, until out of memory (PR3082).

define void @test() {

entry:
  br label %loopentry

loopentry:
  br i1 undef, label %exit.1, label %loopexit

loopexit:
  br i1 undef, label %loopentry, label %exit.0

exit.0:
  br label %unified

exit.1:
  br label %unified

unified:
  ret void
}
; CHECK-LABEL: define {{[^@]+}}@test() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[CODEREPL:%.*]]
; CHECK:       codeRepl:
; CHECK-NEXT:    [[TARGETBLOCK:%.*]] = call i1 @test.loopentry()
; CHECK-NEXT:    br i1 [[TARGETBLOCK]], label [[EXIT_1:%.*]], label [[EXIT_0:%.*]]
; CHECK:       exit.0:
; CHECK-NEXT:    br label [[UNIFIED:%.*]]
; CHECK:       exit.1:
; CHECK-NEXT:    br label [[UNIFIED]]
; CHECK:       unified:
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@test.loopentry() {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[LOOPENTRY:%.*]]
; CHECK:       loopentry:
; CHECK-NEXT:    br i1 undef, label [[EXIT_1_EXITSTUB:%.*]], label [[LOOPEXIT:%.*]]
; CHECK:       loopexit:
; CHECK-NEXT:    br i1 undef, label [[LOOPENTRY]], label [[EXIT_0_EXITSTUB:%.*]]
; CHECK:       exit.1.exitStub:
; CHECK-NEXT:    ret i1 true
; CHECK:       exit.0.exitStub:
; CHECK-NEXT:    ret i1 false
;
