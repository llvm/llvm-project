; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=nvptx64-nvidia-cuda -passes=load-store-vectorizer -S < %s | FileCheck %s

; Test that gap filled instructions don't lose invariant metadata
%struct.S10 = type { i32, i32, i32, i32 }

; With no gaps, if every load is invariant, the vectorized load will be too.
define i32 @noGaps(ptr %in) {
; CHECK-LABEL: define i32 @noGaps(
; CHECK-SAME: ptr [[IN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr [[IN]], align 16, !invariant.load [[META0:![0-9]+]]
; CHECK-NEXT:    [[TMP01:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP12:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP23:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[TMP34:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    [[SUM01:%.*]] = add i32 [[TMP01]], [[TMP12]]
; CHECK-NEXT:    [[SUM012:%.*]] = add i32 [[SUM01]], [[TMP23]]
; CHECK-NEXT:    [[SUM0123:%.*]] = add i32 [[SUM012]], [[TMP34]]
; CHECK-NEXT:    ret i32 [[SUM0123]]
;
  %load0 = load i32, ptr %in, align 16, !invariant.load !0
  %getElem1 = getelementptr inbounds %struct.S10, ptr %in, i64 0, i32 1
  %load1 = load i32, ptr %getElem1, align 4, !invariant.load !0
  %getElem2 = getelementptr inbounds %struct.S10, ptr %in, i64 0, i32 2
  %load2 = load i32, ptr %getElem2, align 4, !invariant.load !0
  %getElem3 = getelementptr inbounds %struct.S10, ptr %in, i64 0, i32 3
  %load3 = load i32, ptr %getElem3, align 4, !invariant.load !0
  %sum01 = add i32 %load0, %load1
  %sum012 = add i32 %sum01, %load2
  %sum0123 = add i32 %sum012, %load3
  ret i32 %sum0123
}

; If one of the loads is not invariant, the vectorized load will not be invariant.
define i32 @noGapsMissingInvariant(ptr %in) {
; CHECK-LABEL: define i32 @noGapsMissingInvariant(
; CHECK-SAME: ptr [[IN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr [[IN]], align 16
; CHECK-NEXT:    [[TMP01:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP12:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP23:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[TMP34:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    [[SUM01:%.*]] = add i32 [[TMP01]], [[TMP12]]
; CHECK-NEXT:    [[SUM012:%.*]] = add i32 [[SUM01]], [[TMP23]]
; CHECK-NEXT:    [[SUM0123:%.*]] = add i32 [[SUM012]], [[TMP34]]
; CHECK-NEXT:    ret i32 [[SUM0123]]
;
  %load0 = load i32, ptr %in, align 16, !invariant.load !0
  %getElem1 = getelementptr inbounds %struct.S10, ptr %in, i64 0, i32 1
  %load1 = load i32, ptr %getElem1, align 4, !invariant.load !0
  %getElem2 = getelementptr inbounds %struct.S10, ptr %in, i64 0, i32 2
  %load2 = load i32, ptr %getElem2, align 4, !invariant.load !0
  %getElem3 = getelementptr inbounds %struct.S10, ptr %in, i64 0, i32 3
  %load3 = load i32, ptr %getElem3, align 4
  %sum01 = add i32 %load0, %load1
  %sum012 = add i32 %sum01, %load2
  %sum0123 = add i32 %sum012, %load3
  ret i32 %sum0123
}

; With two gaps, if every real load is invariant, the vectorized load will be too.
define i32 @twoGaps(ptr %in) {
; CHECK-LABEL: define i32 @twoGaps(
; CHECK-SAME: ptr [[IN:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[IN]], <4 x i1> <i1 true, i1 false, i1 false, i1 true>, <4 x i32> poison), !invariant.load [[META0]]
; CHECK-NEXT:    [[LOAD03:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[GAPFILL4:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[GAPFILL25:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LOAD36:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    [[SUM:%.*]] = add i32 [[LOAD03]], [[LOAD36]]
; CHECK-NEXT:    ret i32 [[SUM]]
;
  %load0 = load i32, ptr %in, align 16, !invariant.load !0
  %getElem3 = getelementptr inbounds %struct.S10, ptr %in, i64 0, i32 3
  %load3 = load i32, ptr %getElem3, align 4, !invariant.load !0
  %sum = add i32 %load0, %load3
  ret i32 %sum
}

!0 = !{}
;.
; CHECK: [[META0]] = !{}
;.
