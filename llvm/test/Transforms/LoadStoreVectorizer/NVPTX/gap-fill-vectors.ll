; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=nvptx64-nvidia-cuda -passes=load-store-vectorizer -mcpu=sm_100 -mattr=+ptx88 -S < %s | FileCheck %s

; The LSV can handle vector inputs, and gap filling can too, with one exception:
; currently, we do not gap fill when the loads enclosing the gap are different sizes
; Otherwise, vectors are treated the same as any other scalar types

; Gap of two load <2 x i8>s gets filled
define void @i8x2_gap_gap_i8x2(ptr %ptr) {
; CHECK-LABEL: define void @i8x2_gap_gap_i8x2(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = call <8 x i8> @llvm.masked.load.v8i8.p0(ptr align 8 [[PTR0]], <8 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 true, i1 true>, <8 x i8> poison)
; CHECK-NEXT:    [[L03:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[GAPFILL4:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GAPFILL25:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[L36:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 6

  %l0 = load <2 x i8>,  ptr %ptr0, align 8
  %l3 = load <2 x i8>,  ptr %ptr3, align 2

  ret void
}

; The chain elements are different sizes, gap filling won't kick in
define void @i8x2_gap_gap_i8(ptr %ptr) {
; CHECK-LABEL: define void @i8x2_gap_gap_i8(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[PTR3:%.*]] = getelementptr i8, ptr [[PTR]], i64 6
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i8>, ptr [[PTR0]], align 8
; CHECK-NEXT:    [[L3:%.*]] = load i8, ptr [[PTR3]], align 1
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 6

  %l0 = load <2 x i8>,  ptr %ptr0, align 8
  %l3 = load i8,  ptr %ptr3, align 1

  ret void
}


define void @i16x2_gap_i16x2_i16x2(ptr %ptr) {
; CHECK-LABEL: define void @i16x2_gap_i16x2_i16x2(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = call <8 x i16> @llvm.masked.load.v8i16.p0(ptr align 16 [[PTR0]], <8 x i1> <i1 true, i1 true, i1 false, i1 false, i1 true, i1 true, i1 true, i1 true>, <8 x i16> poison)
; CHECK-NEXT:    [[L01:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[GAPFILL2:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[L23:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[L34:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr2 = getelementptr i8, ptr %ptr, i64 8
  %ptr3 = getelementptr i8, ptr %ptr, i64 12

  %l0 = load <2 x i16>,  ptr %ptr0, align 16
  %l2 = load <2 x i16>,  ptr %ptr2, align 2
  %l3 = load <2 x i16>,  ptr %ptr3, align 2

  ret void
}

define void @i16x2_gap_gap_i16x2(ptr %ptr) {
; CHECK-LABEL: define void @i16x2_gap_gap_i16x2(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = call <8 x i16> @llvm.masked.load.v8i16.p0(ptr align 16 [[PTR0]], <8 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 true, i1 true>, <8 x i16> poison)
; CHECK-NEXT:    [[L03:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[GAPFILL4:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GAPFILL25:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[L36:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 12

  %l0 = load <2 x i16>,  ptr %ptr0, align 16
  %l3 = load <2 x i16>,  ptr %ptr3, align 4

  ret void
}

define void @i32x2_i32x2_gap_i32x2(ptr addrspace(1) %in) {
; CHECK-LABEL: define void @i32x2_i32x2_gap_i32x2(
; CHECK-SAME: ptr addrspace(1) [[IN:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call <8 x i32> @llvm.masked.load.v8i32.p1(ptr addrspace(1) align 32 [[IN]], <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 false, i1 false, i1 true, i1 true>, <8 x i32> poison)
; CHECK-NEXT:    [[VEC01:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[VEC12:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GAPFILL3:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[VEC34:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %vec0 = load <2 x i32>, ptr addrspace(1) %in, align 32
  %getElem1 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 8
  %vec1 = load <2 x i32>, ptr addrspace(1) %getElem1, align 8
  %getElem3 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 24
  %vec3 = load <2 x i32>, ptr addrspace(1) %getElem3, align 8
  ret void
}

; This gap is filled but then eventually discarded because the total size
; of the vector is larger than the target supports.
define void @i64x2_gap_i64x2_i64x2(ptr addrspace(1) %in) {
; CHECK-LABEL: define void @i64x2_gap_i64x2_i64x2(
; CHECK-SAME: ptr addrspace(1) [[IN:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VEC0:%.*]] = load <2 x i64>, ptr addrspace(1) [[IN]], align 32
; CHECK-NEXT:    [[GETELEM3:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[IN]], i32 32
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i64>, ptr addrspace(1) [[GETELEM3]], align 32
; CHECK-NEXT:    [[VEC31:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[VEC12:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    ret void
;
  %vec0 = load <2 x i64>, ptr addrspace(1) %in, align 32
  %getElem3 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 32
  %vec3 = load <2 x i64>, ptr addrspace(1) %getElem3, align 32
  %getElem1 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 48
  %vec1 = load <2 x i64>, ptr addrspace(1) %getElem1, align 16
  ret void
}

; This gap is filled but then eventually discarded because the total size
; of the vector is larger than the target supports.
define void @i64x2_i64x2_gap_i64x2(ptr addrspace(1) %in) {
; CHECK-LABEL: define void @i64x2_i64x2_gap_i64x2(
; CHECK-SAME: ptr addrspace(1) [[IN:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i64>, ptr addrspace(1) [[IN]], align 32
; CHECK-NEXT:    [[VEC01:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[VEC32:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GETELEM1:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[IN]], i32 48
; CHECK-NEXT:    [[VEC1:%.*]] = load <2 x i64>, ptr addrspace(1) [[GETELEM1]], align 8
; CHECK-NEXT:    ret void
;
  %vec0 = load <2 x i64>, ptr addrspace(1) %in, align 32
  %getElem3 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 16
  %vec3 = load <2 x i64>, ptr addrspace(1) %getElem3, align 16
  %getElem1 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 48
  %vec1 = load <2 x i64>, ptr addrspace(1) %getElem1, align 8
  ret void
}

; Masked loads are not supported for sub-byte element types.
define void @i1x8_gap_gap_i1x8(ptr %ptr) {
; CHECK-LABEL: define void @i1x8_gap_gap_i1x8(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[PTR3:%.*]] = getelementptr i8, ptr [[PTR]], i64 3
; CHECK-NEXT:    [[L0:%.*]] = load <8 x i1>, ptr [[PTR0]], align 4
; CHECK-NEXT:    [[L3:%.*]] = load <8 x i1>, ptr [[PTR3]], align 1
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 3

  %l0 = load <8 x i1>,  ptr %ptr0, align 4
  %l3 = load <8 x i1>,  ptr %ptr3, align 1

  ret void
}
