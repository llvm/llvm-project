; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=nvptx64-nvidia-cuda -passes=load-store-vectorizer -mcpu=sm_100 -mattr=+ptx88 -S < %s | FileCheck %s

; The LSV can handle vector inputs, and gap filling can too, with one exception:
; currently, we do not gap fill when the loads enclosing the gap are different sizes
; Otherwise, vectors are treated the same as any other scalar types

define void @i1x8_gap_gap_i1x8(ptr %ptr) {
; CHECK-LABEL: define void @i1x8_gap_gap_i1x8(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = load <32 x i1>, ptr [[PTR0]], align 4
; CHECK-NEXT:    [[L03:%.*]] = shufflevector <32 x i1> [[TMP1]], <32 x i1> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    [[GAPFILL4:%.*]] = shufflevector <32 x i1> [[TMP1]], <32 x i1> poison, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[GAPFILL25:%.*]] = shufflevector <32 x i1> [[TMP1]], <32 x i1> poison, <8 x i32> <i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23>
; CHECK-NEXT:    [[L36:%.*]] = shufflevector <32 x i1> [[TMP1]], <32 x i1> poison, <8 x i32> <i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 3

  %l0 = load <8 x i1>,  ptr %ptr0, align 4
  %l3 = load <8 x i1>,  ptr %ptr3, align 1

  ret void
}

; The chain elements are different sizes, gap filling won't kick in
define void @i1x8_gap_gap_i1x16(ptr %ptr) {
; CHECK-LABEL: define void @i1x8_gap_gap_i1x16(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[PTR3:%.*]] = getelementptr i8, ptr [[PTR]], i64 3
; CHECK-NEXT:    [[L0:%.*]] = load <8 x i1>, ptr [[PTR0]], align 4
; CHECK-NEXT:    [[L3:%.*]] = load <16 x i1>, ptr [[PTR3]], align 2
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 3

  %l0 = load <8 x i1>,  ptr %ptr0, align 4
  %l3 = load <16 x i1>,  ptr %ptr3, align 2

  ret void
}

; Gap of two load <2 x i8>s gets filled
define void @i8x2_gap_gap_i8x2(ptr %ptr) {
; CHECK-LABEL: define void @i8x2_gap_gap_i8x2(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = load <8 x i8>, ptr [[PTR0]], align 8
; CHECK-NEXT:    [[L03:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[GAPFILL4:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GAPFILL25:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[L36:%.*]] = shufflevector <8 x i8> [[TMP1]], <8 x i8> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 6

  %l0 = load <2 x i8>,  ptr %ptr0, align 8
  %l3 = load <2 x i8>,  ptr %ptr3, align 2

  ret void
}

; The chain elements are different sizes, gap filling won't kick in
define void @i8x2_gap_gap_i8(ptr %ptr) {
; CHECK-LABEL: define void @i8x2_gap_gap_i8(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[PTR3:%.*]] = getelementptr i8, ptr [[PTR]], i64 6
; CHECK-NEXT:    [[L0:%.*]] = load <2 x i8>, ptr [[PTR0]], align 8
; CHECK-NEXT:    [[L3:%.*]] = load i8, ptr [[PTR3]], align 1
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 6

  %l0 = load <2 x i8>,  ptr %ptr0, align 8
  %l3 = load i8,  ptr %ptr3, align 1

  ret void
}


define void @i16x2_gap_i16x2_i16x2(ptr %ptr) {
; CHECK-LABEL: define void @i16x2_gap_i16x2_i16x2(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = load <8 x i16>, ptr [[PTR0]], align 16
; CHECK-NEXT:    [[L01:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[GAPFILL2:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[L23:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[L34:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr2 = getelementptr i8, ptr %ptr, i64 8
  %ptr3 = getelementptr i8, ptr %ptr, i64 12

  %l0 = load <2 x i16>,  ptr %ptr0, align 16
  %l2 = load <2 x i16>,  ptr %ptr2, align 2
  %l3 = load <2 x i16>,  ptr %ptr3, align 2

  ret void
}

define void @i16x2_gap_gap_i16x2(ptr %ptr) {
; CHECK-LABEL: define void @i16x2_gap_gap_i16x2(
; CHECK-SAME: ptr [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr [[PTR]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = load <8 x i16>, ptr [[PTR0]], align 16
; CHECK-NEXT:    [[L03:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[GAPFILL4:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GAPFILL25:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[L36:%.*]] = shufflevector <8 x i16> [[TMP1]], <8 x i16> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr %ptr, i64 0
  %ptr3 = getelementptr i8, ptr %ptr, i64 12

  %l0 = load <2 x i16>,  ptr %ptr0, align 16
  %l3 = load <2 x i16>,  ptr %ptr3, align 4

  ret void
}

define void @i32x2_i32x2_gap_i32x2(ptr addrspace(1) %in) {
; CHECK-LABEL: define void @i32x2_i32x2_gap_i32x2(
; CHECK-SAME: ptr addrspace(1) [[IN:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <8 x i32>, ptr addrspace(1) [[IN]], align 32
; CHECK-NEXT:    [[VEC01:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[VEC12:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GAPFILL3:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 4, i32 5>
; CHECK-NEXT:    [[VEC34:%.*]] = shufflevector <8 x i32> [[TMP1]], <8 x i32> poison, <2 x i32> <i32 6, i32 7>
; CHECK-NEXT:    ret void
;
  %vec0 = load <2 x i32>, ptr addrspace(1) %in, align 32
  %getElem1 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 8
  %vec1 = load <2 x i32>, ptr addrspace(1) %getElem1, align 8
  %getElem3 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 24
  %vec3 = load <2 x i32>, ptr addrspace(1) %getElem3, align 8
  ret void
}

; This gap is filled but then eventually discarded because the total size
; of the vector is larger than the target supports.
define void @i64x2_gap_i64x2_i64x2(ptr addrspace(1) %in) {
; CHECK-LABEL: define void @i64x2_gap_i64x2_i64x2(
; CHECK-SAME: ptr addrspace(1) [[IN:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VEC0:%.*]] = load <2 x i64>, ptr addrspace(1) [[IN]], align 32
; CHECK-NEXT:    [[GETELEM3:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[IN]], i32 32
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i64>, ptr addrspace(1) [[GETELEM3]], align 32
; CHECK-NEXT:    [[VEC31:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[VEC12:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    ret void
;
  %vec0 = load <2 x i64>, ptr addrspace(1) %in, align 32
  %getElem3 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 32
  %vec3 = load <2 x i64>, ptr addrspace(1) %getElem3, align 32
  %getElem1 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 48
  %vec1 = load <2 x i64>, ptr addrspace(1) %getElem1, align 16
  ret void
}

; This gap is filled but then eventually discarded because the total size
; of the vector is larger than the target supports.
define void @i64x2_i64x2_gap_i64x2(ptr addrspace(1) %in) {
; CHECK-LABEL: define void @i64x2_i64x2_gap_i64x2(
; CHECK-SAME: ptr addrspace(1) [[IN:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i64>, ptr addrspace(1) [[IN]], align 32
; CHECK-NEXT:    [[VEC01:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[VEC32:%.*]] = shufflevector <4 x i64> [[TMP1]], <4 x i64> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[GETELEM1:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[IN]], i32 48
; CHECK-NEXT:    [[VEC1:%.*]] = load <2 x i64>, ptr addrspace(1) [[GETELEM1]], align 8
; CHECK-NEXT:    ret void
;
  %vec0 = load <2 x i64>, ptr addrspace(1) %in, align 32
  %getElem3 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 16
  %vec3 = load <2 x i64>, ptr addrspace(1) %getElem3, align 16
  %getElem1 = getelementptr inbounds i8, ptr addrspace(1) %in, i32 48
  %vec1 = load <2 x i64>, ptr addrspace(1) %getElem1, align 8
  ret void
}
