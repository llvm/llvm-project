; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=nvptx64-nvidia-cuda -passes=load-store-vectorizer -S < %s | FileCheck %s

; Load elements 0, 1, and 3, filling the gap with a generated load of element 2
define void @test(ptr %ptr) {
; CHECK-LABEL: define void @test(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[PTR]], <4 x i1> <i1 true, i1 true, i1 false, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD01:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LD12:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[GAPFILL3:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LD34:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    ret void
;
  %ld0 = load i32, ptr %ptr, align 16
  %gep1 = getelementptr inbounds i8, ptr %ptr, i32 4
  %ld1 = load i32, ptr %gep1, align 4
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 12
  %ld3 = load i32, ptr %gep3, align 4
  ret void
}

; Load elements 0, 2, and 3, filling the gap with a generated load of element 1
define void @test2(ptr %ptr) {
; CHECK-LABEL: define void @test2(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[PTR]], <4 x i1> <i1 true, i1 false, i1 true, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD01:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[GAPFILL2:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[LD23:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LD34:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    ret void
;
  %ld0 = load i32, ptr %ptr, align 16
  %gep2 = getelementptr inbounds i8, ptr %ptr, i32 8
  %ld2 = load i32, ptr %gep2, align 4
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 12
  %ld3 = load i32, ptr %gep3, align 4
  ret void
}

; This gap can be filled, but the types are too large to do a v4 load,
; So we should end up with a v2 load and a single scalar load
define void @test3(ptr %ptr) {
; CHECK-LABEL: define void @test3(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i64>, ptr [[PTR]], align 16
; CHECK-NEXT:    [[LD01:%.*]] = extractelement <2 x i64> [[TMP1]], i32 0
; CHECK-NEXT:    [[LD12:%.*]] = extractelement <2 x i64> [[TMP1]], i32 1
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i32 24
; CHECK-NEXT:    [[LD3:%.*]] = load i64, ptr [[GEP3]], align 4
; CHECK-NEXT:    ret void
;
  %ld0 = load i64, ptr %ptr, align 16
  %gep1 = getelementptr inbounds i8, ptr %ptr, i32 8
  %ld1 = load i64, ptr %gep1, align 4
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 24
  %ld3 = load i64, ptr %gep3, align 4
  ret void
}

; This gap can be filled, but the types are too large to do a v4 load,
; So we should end up with a v2 load and a single scalar load
define void @test4(ptr %ptr) {
; CHECK-LABEL: define void @test4(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[LD0:%.*]] = load i64, ptr [[PTR]], align 16
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i32 16
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i64>, ptr [[GEP2]], align 16
; CHECK-NEXT:    [[LD21:%.*]] = extractelement <2 x i64> [[TMP1]], i32 0
; CHECK-NEXT:    [[LD32:%.*]] = extractelement <2 x i64> [[TMP1]], i32 1
; CHECK-NEXT:    ret void
;
  %ld0 = load i64, ptr %ptr, align 16
  %gep2 = getelementptr inbounds i8, ptr %ptr, i32 16
  %ld2 = load i64, ptr %gep2, align 16
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 24
  %ld3 = load i64, ptr %gep3, align 4
  ret void
}

; Load elements 0 and 3, filling the gap with a generated load of element 1 and 2
define void @test5(ptr %ptr) {
; CHECK-LABEL: define void @test5(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[PTR]], <4 x i1> <i1 true, i1 false, i1 false, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD03:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[GAPFILL4:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[GAPFILL25:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LD36:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    ret void
;
  %ld0 = load i32, ptr %ptr, align 16
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 12
  %ld3 = load i32, ptr %gep3, align 4
  ret void
}

; Load elements 0, 1, 3, 4, 6, and 7, filling gaps at elements 2 and 5.
define void @test6(ptr %ptr) {
; CHECK-LABEL: define void @test6(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[PTR]], <4 x i1> <i1 true, i1 true, i1 false, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD03:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LD14:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[GAPFILL5:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LD36:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i32 16
; CHECK-NEXT:    [[TMP2:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[GEP4]], <4 x i1> <i1 true, i1 false, i1 true, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD47:%.*]] = extractelement <4 x i32> [[TMP2]], i32 0
; CHECK-NEXT:    [[GAPFILL28:%.*]] = extractelement <4 x i32> [[TMP2]], i32 1
; CHECK-NEXT:    [[LD69:%.*]] = extractelement <4 x i32> [[TMP2]], i32 2
; CHECK-NEXT:    [[LD710:%.*]] = extractelement <4 x i32> [[TMP2]], i32 3
; CHECK-NEXT:    ret void
;
  %ld0 = load i32, ptr %ptr, align 16
  %gep1 = getelementptr inbounds i8, ptr %ptr, i32 4
  %ld1 = load i32, ptr %gep1, align 4
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 12
  %ld3 = load i32, ptr %gep3, align 4

  %gep4 = getelementptr inbounds i8, ptr %ptr, i32 16
  %ld4 = load i32, ptr %gep4, align 16
  %gep6 = getelementptr inbounds i8, ptr %ptr, i32 24
  %ld6 = load i32, ptr %gep6, align 4
  %gep7 = getelementptr inbounds i8, ptr %ptr, i32 28
  %ld7 = load i32, ptr %gep7, align 4
  ret void
}

; Load elements 0, 1, 3, 4 and 7, elements 2, 5, and 6 will be filled
define void @test7(ptr %ptr) {
; CHECK-LABEL: define void @test7(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[PTR]], <4 x i1> <i1 true, i1 true, i1 false, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD05:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LD16:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[GAPFILL7:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LD38:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i32 16
; CHECK-NEXT:    [[TMP2:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[GEP4]], <4 x i1> <i1 true, i1 false, i1 false, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD49:%.*]] = extractelement <4 x i32> [[TMP2]], i32 0
; CHECK-NEXT:    [[GAPFILL210:%.*]] = extractelement <4 x i32> [[TMP2]], i32 1
; CHECK-NEXT:    [[GAPFILL411:%.*]] = extractelement <4 x i32> [[TMP2]], i32 2
; CHECK-NEXT:    [[LD712:%.*]] = extractelement <4 x i32> [[TMP2]], i32 3
; CHECK-NEXT:    ret void
;
  %ld0 = load i32, ptr %ptr, align 16
  %gep1 = getelementptr inbounds i8, ptr %ptr, i32 4
  %ld1 = load i32, ptr %gep1, align 4
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 12
  %ld3 = load i32, ptr %gep3, align 4

  %gep4 = getelementptr inbounds i8, ptr %ptr, i32 16
  %ld4 = load i32, ptr %gep4, align 16
  %gep7 = getelementptr inbounds i8, ptr %ptr, i32 28
  %ld7 = load i32, ptr %gep7, align 4
  ret void
}

; Load elements 0, 1, 3, 5, 6, and 7. Elements 2 and 4 will be filled.
; Element 4 will be created and well-aligned because of its
; distance from the first load.
define void @test8(ptr %ptr) {
; CHECK-LABEL: define void @test8(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[PTR]], <4 x i1> <i1 true, i1 true, i1 false, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[LD03:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LD14:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[GAPFILL5:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LD36:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i32 12
; CHECK-NEXT:    [[GAPFILLGEP1:%.*]] = getelementptr i8, ptr [[GEP3]], i64 4
; CHECK-NEXT:    [[TMP2:%.*]] = call <4 x i32> @llvm.masked.load.v4i32.p0(ptr align 16 [[GAPFILLGEP1]], <4 x i1> <i1 false, i1 true, i1 true, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[GAPFILL27:%.*]] = extractelement <4 x i32> [[TMP2]], i32 0
; CHECK-NEXT:    [[LD58:%.*]] = extractelement <4 x i32> [[TMP2]], i32 1
; CHECK-NEXT:    [[LD69:%.*]] = extractelement <4 x i32> [[TMP2]], i32 2
; CHECK-NEXT:    [[LD710:%.*]] = extractelement <4 x i32> [[TMP2]], i32 3
; CHECK-NEXT:    ret void
;
  %ld0 = load i32, ptr %ptr, align 16
  %gep1 = getelementptr inbounds i8, ptr %ptr, i32 4
  %ld1 = load i32, ptr %gep1, align 4
  %gep3 = getelementptr inbounds i8, ptr %ptr, i32 12
  %ld3 = load i32, ptr %gep3, align 4

  %gep5 = getelementptr inbounds i8, ptr %ptr, i32 20
  %ld5 = load i32, ptr %gep5, align 16
  %gep6 = getelementptr inbounds i8, ptr %ptr, i32 24
  %ld6 = load i32, ptr %gep6, align 4
  %gep7 = getelementptr inbounds i8, ptr %ptr, i32 28
  %ld7 = load i32, ptr %gep7, align 4
  ret void
}
