; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -mtriple=amdgcn-amd-amdhsa -passes=load-store-vectorizer -S -o - %s | FileCheck %s

define void @no_merge_i16_half(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @no_merge_i16_half(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i16, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[LOAD_0:%.*]] = load i16, ptr addrspace(1) [[PTR1]], align 2
; CHECK-NEXT:    [[LOAD_1:%.*]] = load half, ptr addrspace(1) [[GEP_1]], align 2
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i16, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i16 [[LOAD_0]], ptr addrspace(2) [[PTR2]], align 2
; CHECK-NEXT:    store half [[LOAD_1]], ptr addrspace(2) [[STORE_GEP_1]], align 2
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i16, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i16, ptr addrspace(1) %ptr1
  %load.1 = load half, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i16, ptr addrspace(2) %ptr2, i64 1
  store i16 %load.0, ptr addrspace(2) %ptr2
  store half %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @no_merge_i16_float(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @no_merge_i16_float(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i16, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[LOAD_0:%.*]] = load i16, ptr addrspace(1) [[PTR1]], align 2
; CHECK-NEXT:    [[LOAD_1:%.*]] = load float, ptr addrspace(1) [[GEP_1]], align 4
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i16, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i16 [[LOAD_0]], ptr addrspace(2) [[PTR2]], align 2
; CHECK-NEXT:    store float [[LOAD_1]], ptr addrspace(2) [[STORE_GEP_1]], align 4
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i16, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i16, ptr addrspace(1) %ptr1
  %load.1 = load float, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i16, ptr addrspace(2) %ptr2, i64 1
  store i16 %load.0, ptr addrspace(2) %ptr2
  store float %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @merge_i32_v2i16(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @merge_i32_v2i16(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr addrspace(1) [[PTR1]], align 4
; CHECK-NEXT:    [[LOAD_01:%.*]] = extractelement <2 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD_1_MUT2:%.*]] = extractelement <2 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[LOAD_1_MUT_BC:%.*]] = bitcast i32 [[LOAD_1_MUT2]] to <2 x i16>
; CHECK-NEXT:    [[LOAD_1_BC:%.*]] = bitcast <2 x i16> [[LOAD_1_MUT_BC]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> poison, i32 [[LOAD_01]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> [[TMP2]], i32 [[LOAD_1_BC]], i32 1
; CHECK-NEXT:    store <2 x i32> [[TMP3]], ptr addrspace(2) [[PTR2]], align 4
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i32, ptr addrspace(1) %ptr1
  %load.1 = load <2 x i16>, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i32, ptr addrspace(2) %ptr2, i64 1
  store i32 %load.0, ptr addrspace(2) %ptr2
  store <2 x i16> %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @no_merge_i32_ptr(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @no_merge_i32_ptr(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[LOAD_0:%.*]] = load i32, ptr addrspace(1) [[PTR1]], align 4
; CHECK-NEXT:    [[LOAD_1:%.*]] = load ptr, ptr addrspace(1) [[GEP_1]], align 8
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i32 [[LOAD_0]], ptr addrspace(2) [[PTR2]], align 4
; CHECK-NEXT:    store ptr [[LOAD_1]], ptr addrspace(2) [[STORE_GEP_1]], align 8
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i32, ptr addrspace(1) %ptr1
  %load.1 = load ptr, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i32, ptr addrspace(2) %ptr2, i64 1
  store i32 %load.0, ptr addrspace(2) %ptr2
  store ptr %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @no_merge_i32_half(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @no_merge_i32_half(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[LOAD_0:%.*]] = load i32, ptr addrspace(1) [[PTR1]], align 4
; CHECK-NEXT:    [[LOAD_1:%.*]] = load half, ptr addrspace(1) [[GEP_1]], align 2
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i32 [[LOAD_0]], ptr addrspace(2) [[PTR2]], align 4
; CHECK-NEXT:    store half [[LOAD_1]], ptr addrspace(2) [[STORE_GEP_1]], align 2
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i32, ptr addrspace(1) %ptr1
  %load.1 = load half, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i32, ptr addrspace(2) %ptr2, i64 1
  store i32 %load.0, ptr addrspace(2) %ptr2
  store half %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @merge_i32_float(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @merge_i32_float(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr addrspace(1) [[PTR1]], align 4
; CHECK-NEXT:    [[LOAD_01:%.*]] = extractelement <2 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD_12:%.*]] = extractelement <2 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[LOAD_12]] to float
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> poison, i32 [[LOAD_01]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast float [[TMP2]] to i32
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <2 x i32> [[TMP3]], i32 [[TMP4]], i32 1
; CHECK-NEXT:    store <2 x i32> [[TMP5]], ptr addrspace(2) [[PTR2]], align 4
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i32, ptr addrspace(1) %ptr1
  %load.1 = load float, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i32, ptr addrspace(2) %ptr2, i64 1
  store i32 %load.0, ptr addrspace(2) %ptr2
  store float %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @no_merge_i32_double(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @no_merge_i32_double(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[LOAD_0:%.*]] = load i32, ptr addrspace(1) [[PTR1]], align 4
; CHECK-NEXT:    [[LOAD_1:%.*]] = load double, ptr addrspace(1) [[GEP_1]], align 8
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i32 [[LOAD_0]], ptr addrspace(2) [[PTR2]], align 4
; CHECK-NEXT:    store double [[LOAD_1]], ptr addrspace(2) [[STORE_GEP_1]], align 8
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i32, ptr addrspace(1) %ptr1
  %load.1 = load double, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i32, ptr addrspace(2) %ptr2, i64 1
  store i32 %load.0, ptr addrspace(2) %ptr2
  store double %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @merge_i64_ptr(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @merge_i64_ptr(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i64>, ptr addrspace(1) [[PTR1]], align 8
; CHECK-NEXT:    [[LOAD_01:%.*]] = extractelement <2 x i64> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD_12:%.*]] = extractelement <2 x i64> [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[LOAD_12]] to ptr
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i64, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i64 [[LOAD_01]], ptr addrspace(2) [[PTR2]], align 8
; CHECK-NEXT:    store ptr [[TMP2]], ptr addrspace(2) [[STORE_GEP_1]], align 8
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i64, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i64, ptr addrspace(1) %ptr1
  %load.1 = load ptr, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i64, ptr addrspace(2) %ptr2, i64 1
  store i64 %load.0, ptr addrspace(2) %ptr2
  store ptr %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @no_merge_i64_float(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @no_merge_i64_float(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i64, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[LOAD_0:%.*]] = load i64, ptr addrspace(1) [[PTR1]], align 8
; CHECK-NEXT:    [[LOAD_1:%.*]] = load float, ptr addrspace(1) [[GEP_1]], align 4
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i64, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i64 [[LOAD_0]], ptr addrspace(2) [[PTR2]], align 8
; CHECK-NEXT:    store float [[LOAD_1]], ptr addrspace(2) [[STORE_GEP_1]], align 4
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i64, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i64, ptr addrspace(1) %ptr1
  %load.1 = load float, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i64, ptr addrspace(2) %ptr2, i64 1
  store i64 %load.0, ptr addrspace(2) %ptr2
  store float %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @merge_i64_double(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @merge_i64_double(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i64>, ptr addrspace(1) [[PTR1]], align 8
; CHECK-NEXT:    [[LOAD_01:%.*]] = extractelement <2 x i64> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD_12:%.*]] = extractelement <2 x i64> [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i64 [[LOAD_12]] to double
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i64, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i64 [[LOAD_01]], ptr addrspace(2) [[PTR2]], align 8
; CHECK-NEXT:    store double [[TMP2]], ptr addrspace(2) [[STORE_GEP_1]], align 8
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i64, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i64, ptr addrspace(1) %ptr1
  %load.1 = load double, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i64, ptr addrspace(2) %ptr2, i64 1
  store i64 %load.0, ptr addrspace(2) %ptr2
  store double %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @merge_i64_v2i32(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @merge_i64_v2i32(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i64>, ptr addrspace(1) [[PTR1]], align 8
; CHECK-NEXT:    [[LOAD_01:%.*]] = extractelement <2 x i64> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD_1_MUT2:%.*]] = extractelement <2 x i64> [[TMP1]], i32 1
; CHECK-NEXT:    [[LOAD_1_MUT_BC:%.*]] = bitcast i64 [[LOAD_1_MUT2]] to <2 x i32>
; CHECK-NEXT:    [[STORE_GEP_1:%.*]] = getelementptr inbounds i64, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store i64 [[LOAD_01]], ptr addrspace(2) [[PTR2]], align 8
; CHECK-NEXT:    [[LOAD_1_BC:%.*]] = bitcast <2 x i32> [[LOAD_1_MUT_BC]] to i64
; CHECK-NEXT:    store i64 [[LOAD_1_BC]], ptr addrspace(2) [[STORE_GEP_1]], align 8
; CHECK-NEXT:    ret void
;
  %gep.1 = getelementptr inbounds i64, ptr addrspace(1) %ptr1, i64 1
  %load.0 = load i64, ptr addrspace(1) %ptr1
  %load.1 = load <2 x i32>, ptr addrspace(1) %gep.1
  %store.gep.1 = getelementptr inbounds i64, ptr addrspace(2) %ptr2, i64 1
  store i64 %load.0, ptr addrspace(2) %ptr2
  store <2 x i32> %load.1, ptr addrspace(2) %store.gep.1
  ret void
}

define void @merge_i32_v2i16_v4i8(ptr addrspace(1) %ptr1) {
; CHECK-LABEL: define void @merge_i32_v2i16_v4i8(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]]) {
; CHECK-NEXT:    [[LOAD_0:%.*]] = load i32, ptr addrspace(1) [[PTR1]], align 4
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr addrspace(1) [[GEP2]], align 4
; CHECK-NEXT:    [[LOAD2_MUT1:%.*]] = extractelement <2 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD4_MUT2:%.*]] = extractelement <2 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[LOAD2_MUT_BC:%.*]] = bitcast i32 [[LOAD2_MUT1]] to <2 x i16>
; CHECK-NEXT:    [[LOAD4_MUT_BC:%.*]] = bitcast i32 [[LOAD4_MUT2]] to <4 x i8>
; CHECK-NEXT:    [[GEP_3:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[PTR1]], i64 3
; CHECK-NEXT:    [[LOAD_3:%.*]] = load float, ptr addrspace(1) [[GEP_3]], align 4
; CHECK-NEXT:    ret void
;
  %load.0 = load i32, ptr addrspace(1) %ptr1, align 4
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 1
  %load.1 = load <2 x i16>, ptr addrspace(1) %gep.1, align 4
  %gep.2 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 2
  %load.2 = load <4 x i8>, ptr addrspace(1) %gep.2, align 4
  %gep.3 = getelementptr inbounds i32, ptr addrspace(1) %ptr1, i64 3
  %load.3 = load float, ptr addrspace(1) %gep.3, align 4
  ret void
}

define void @merge_float_v2f16_type(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @merge_float_v2f16_type(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds float, ptr addrspace(1) [[PTR1]], i64 0
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr addrspace(1) [[GEP1]], align 4
; CHECK-NEXT:    [[LOAD1_MUT1:%.*]] = extractelement <2 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD2_MUT2:%.*]] = extractelement <2 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[LOAD1_TOORIG:%.*]] = bitcast i32 [[LOAD1_MUT1]] to float
; CHECK-NEXT:    [[LOAD2_TOORIG:%.*]] = bitcast i32 [[LOAD2_MUT2]] to <2 x half>
; CHECK-NEXT:    [[STORE_GEP1:%.*]] = getelementptr inbounds i32, ptr addrspace(2) [[PTR2]], i64 0
; CHECK-NEXT:    [[LOAD1_BC:%.*]] = bitcast float [[LOAD1_TOORIG]] to i32
; CHECK-NEXT:    [[LOAD2_BC:%.*]] = bitcast <2 x half> [[LOAD2_TOORIG]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> poison, i32 [[LOAD1_BC]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> [[TMP2]], i32 [[LOAD2_BC]], i32 1
; CHECK-NEXT:    store <2 x i32> [[TMP3]], ptr addrspace(2) [[STORE_GEP1]], align 4
; CHECK-NEXT:    ret void
;
  %gep1 = getelementptr inbounds float, ptr addrspace(1) %ptr1, i64 0
  %load1 = load float, ptr addrspace(1) %gep1, align 4
  %gep2 = getelementptr inbounds <2 x half>, ptr addrspace(1) %ptr1, i64 1
  %load2 = load <2 x half>, ptr addrspace(1) %gep2, align 4
  %store.gep1 = getelementptr inbounds i32, ptr addrspace(2) %ptr2, i64 0
  store float %load1, ptr addrspace(2) %store.gep1, align 4
  %store.gep2 = getelementptr inbounds <2 x half>, ptr addrspace(2) %ptr2, i64 1
  store <2 x half> %load2, ptr addrspace(2) %store.gep2, align 4
  ret void
}

define void @merge_v2f16_bfloat_type(ptr addrspace(1) %ptr1, ptr addrspace(2) %ptr2) {
; CHECK-LABEL: define void @merge_v2f16_bfloat_type(
; CHECK-SAME: ptr addrspace(1) [[PTR1:%.*]], ptr addrspace(2) [[PTR2:%.*]]) {
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds bfloat, ptr addrspace(1) [[PTR1]], i64 0
; CHECK-NEXT:    [[LOAD1:%.*]] = load bfloat, ptr addrspace(1) [[GEP1]], align 4
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds <2 x half>, ptr addrspace(1) [[PTR1]], i64 1
; CHECK-NEXT:    [[LOAD2:%.*]] = load <2 x half>, ptr addrspace(1) [[GEP2]], align 4
; CHECK-NEXT:    [[STORE_GEP1:%.*]] = getelementptr inbounds i32, ptr addrspace(2) [[PTR2]], i64 0
; CHECK-NEXT:    store bfloat [[LOAD1]], ptr addrspace(2) [[STORE_GEP1]], align 4
; CHECK-NEXT:    [[STORE_GEP2:%.*]] = getelementptr inbounds <2 x half>, ptr addrspace(2) [[PTR2]], i64 1
; CHECK-NEXT:    store <2 x half> [[LOAD2]], ptr addrspace(2) [[STORE_GEP2]], align 4
; CHECK-NEXT:    ret void
;
  %gep1 = getelementptr inbounds bfloat, ptr addrspace(1) %ptr1, i64 0
  %load1 = load bfloat, ptr addrspace(1) %gep1, align 4
  %gep2 = getelementptr inbounds <2 x half>, ptr addrspace(1) %ptr1, i64 1
  %load2 = load <2 x half>, ptr addrspace(1) %gep2, align 4
  %store.gep1 = getelementptr inbounds i32, ptr addrspace(2) %ptr2, i64 0
  store bfloat %load1, ptr addrspace(2) %store.gep1, align 4
  %store.gep2 = getelementptr inbounds <2 x half>, ptr addrspace(2) %ptr2, i64 1
  store <2 x half> %load2, ptr addrspace(2) %store.gep2, align 4
  ret void
}
