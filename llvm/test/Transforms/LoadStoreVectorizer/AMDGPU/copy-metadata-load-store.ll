; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -mtriple=amdgcn-amd-amdhsa -passes=load-store-vectorizer -S -o - %s | FileCheck %s

; We expect the merged vector load to retain nontemporal and tbaa, and normalization to handle
; other load-only metadata.
define void @lsv_copy_load_metadata(ptr %p) {
; CHECK-LABEL: define void @lsv_copy_load_metadata(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = load <2 x i32>, ptr [[P]], align 4, !tbaa [[CHAR_TBAA0:![0-9]+]], !invariant.load [[META3:![0-9]+]], !nontemporal [[META4:![0-9]+]]
; CHECK-NEXT:    [[LD01:%.*]] = extractelement <2 x i32> [[TMP0]], i32 0
; CHECK-NEXT:    [[LD1_MUT2:%.*]] = extractelement <2 x i32> [[TMP0]], i32 1
; CHECK-NEXT:    [[LD1_MUT_BC:%.*]] = bitcast i32 [[LD1_MUT2]] to <2 x i16>
; CHECK-NEXT:    ret void
;
entry:
  %p1 = getelementptr i32, ptr %p, i64 1
  %ld0 = load i32, ptr %p, align 4, !tbaa !0, !nontemporal !5, !invariant.load !6
  %ld1 = load <2 x i16>, ptr %p1, align 4, !tbaa !0, !nontemporal !5, !invariant.load !6
  ret void
}

; Check that metadata on stores is preserved when LSV normalizes mixed-typed
; chains (exercises copyMetadataForAccess on stores).
define void @lsv_copy_store_metadata(ptr %p) {
; CHECK-LABEL: define void @lsv_copy_store_metadata(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    store <2 x i32> <i32 7, i32 bitcast (<2 x i16> <i16 4, i16 5> to i32)>, ptr [[P]], align 4, !nontemporal [[META4]]
; CHECK-NEXT:    ret void
;
entry:
  %p1 = getelementptr i32, ptr %p, i64 1
  store i32 7, ptr %p, align 4, !nontemporal !5
  store <2 x i16> <i16 4, i16 5>, ptr %p1, align 4, !nontemporal !5
  ret void
}

; Check that MD_nonnull on pointer loads is transformed to an integer !range
; via copyMetadataForAccess during normalization.
define void @lsv_copy_load_nonnull_to_range(ptr %p) {
; CHECK-LABEL: define void @lsv_copy_load_nonnull_to_range(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[VEC:%.*]] = load <2 x i64>, ptr [[P]], align 8
; CHECK-NEXT:    [[LD01:%.*]] = extractelement <2 x i64> [[VEC]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[LD01]] to ptr
; CHECK-NEXT:    [[LD12:%.*]] = extractelement <2 x i64> [[VEC]], i32 1
; CHECK-NEXT:    ret void
;
entry:
  %p1 = getelementptr i64, ptr %p, i64 1
  %ld0 = load ptr, ptr %p, align 8, !nonnull !6
  %ld1 = load i64, ptr %p1, align 8
  ret void
}

; Check that MD_dereferenceable_or_null is not propagated when the new type is
; not a pointer after normalization (as per copyMetadataForAccess semantics).
define void @lsv_copy_load_deref_or_null(ptr %p) {
; CHECK-LABEL: define void @lsv_copy_load_deref_or_null(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[VEC:%.*]] = load <2 x i64>, ptr [[P]], align 8
; CHECK-NEXT:    [[LD01:%.*]] = extractelement <2 x i64> [[VEC]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[LD01]] to ptr
; CHECK-NEXT:    [[LD12:%.*]] = extractelement <2 x i64> [[VEC]], i32 1
; CHECK-NEXT:    ret void
;
entry:
  %p1 = getelementptr i64, ptr %p, i64 1
  %ld0 = load ptr, ptr %p, align 8, !dereferenceable_or_null !7
  %ld1 = load i64, ptr %p1, align 8
  ret void
}

; Stores do not accept !dereferenceable_or_null metadata; ensure vectorization
; still succeeds on a mixed chain without such metadata on stores.
define void @lsv_copy_store_chain(ptr %p, ptr %q) {
; CHECK-LABEL: define void @lsv_copy_store_chain(
; CHECK-SAME: ptr [[P:%.*]], ptr [[Q:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[P1:%.*]] = getelementptr i64, ptr [[P]], i64 1
; CHECK-NEXT:    [[Q1:%.*]] = getelementptr i64, ptr [[Q]], i64 1
; CHECK-NEXT:    [[V:%.*]] = load ptr, ptr [[P]], align 8
; CHECK-NEXT:    store ptr [[V]], ptr [[Q]], align 8
; CHECK-NEXT:    [[W:%.*]] = load i64, ptr [[P1]], align 8
; CHECK-NEXT:    store i64 [[W]], ptr [[Q1]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %p1 = getelementptr i64, ptr %p, i64 1
  %q1 = getelementptr i64, ptr %q, i64 1
  %v = load ptr, ptr %p, align 8
  store ptr %v, ptr %q, align 8
  %w = load i64, ptr %p1, align 8
  store i64 %w, ptr %q1, align 8
  ret void
}

!0 = !{!3, !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{i32 1}
!6 = !{}
!7 = !{i64 8}
attributes #0 = { nounwind }
attributes #1 = { nounwind readnone }
;.
; CHECK: [[CHAR_TBAA0]] = !{[[META1:![0-9]+]], [[META1]], i64 0}
; CHECK: [[META1]] = !{!"omnipotent char", [[META2:![0-9]+]], i64 0}
; CHECK: [[META2]] = !{!"Simple C/C++ TBAA"}
; CHECK: [[META3]] = !{}
; CHECK: [[META4]] = !{i32 1}
;.
