; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -mtriple=amdgcn-amd-amdhsa -passes=load-store-vectorizer -S -o - %s | FileCheck -check-prefixes=GCN %s

; Checks that there is no crash when there are multiple tails
; for a the same head starting a chain.
@0 = internal addrspace(3) global [16384 x i32] undef

define amdgpu_kernel void @no_crash(i32 %arg) {
; GCN-LABEL: define amdgpu_kernel void @no_crash(
; GCN-SAME: i32 [[ARG:%.*]]) {
; GCN-NEXT:    [[TEMP2:%.*]] = add i32 [[ARG]], 14
; GCN-NEXT:    [[TEMP3:%.*]] = getelementptr [16384 x i32], ptr addrspace(3) @[[GLOB0:[0-9]+]], i32 0, i32 [[TEMP2]]
; GCN-NEXT:    [[TEMP4:%.*]] = add i32 [[ARG]], 15
; GCN-NEXT:    [[TEMP5:%.*]] = getelementptr [16384 x i32], ptr addrspace(3) @[[GLOB0]], i32 0, i32 [[TEMP4]]
; GCN-NEXT:    store <2 x i32> zeroinitializer, ptr addrspace(3) [[TEMP3]], align 4
; GCN-NEXT:    store i32 0, ptr addrspace(3) [[TEMP5]], align 4
; GCN-NEXT:    store i32 0, ptr addrspace(3) [[TEMP5]], align 4
; GCN-NEXT:    ret void
;
  %temp2 = add i32 %arg, 14
  %temp3 = getelementptr [16384 x i32], ptr addrspace(3) @0, i32 0, i32 %temp2
  %temp4 = add i32 %arg, 15
  %temp5 = getelementptr [16384 x i32], ptr addrspace(3) @0, i32 0, i32 %temp4

  store i32 0, ptr addrspace(3) %temp3, align 4
  store i32 0, ptr addrspace(3) %temp5, align 4
  store i32 0, ptr addrspace(3) %temp5, align 4
  store i32 0, ptr addrspace(3) %temp5, align 4

  ret void
}

; Check adjacent memory locations are properly matched and the
; longest chain vectorized
define amdgpu_kernel void @interleave_get_longest(i32 %arg) {
; GCN-LABEL: define amdgpu_kernel void @interleave_get_longest(
; GCN-SAME: i32 [[ARG:%.*]]) {
; GCN-NEXT:    [[A1:%.*]] = add i32 [[ARG]], 1
; GCN-NEXT:    [[A3:%.*]] = add i32 [[ARG]], 3
; GCN-NEXT:    [[TEMP1:%.*]] = getelementptr [16384 x i32], ptr addrspace(3) @[[GLOB0]], i32 0, i32 [[ARG]]
; GCN-NEXT:    [[TEMP2:%.*]] = getelementptr [16384 x i32], ptr addrspace(3) @[[GLOB0]], i32 0, i32 [[A1]]
; GCN-NEXT:    [[TEMP4:%.*]] = getelementptr [16384 x i32], ptr addrspace(3) @[[GLOB0]], i32 0, i32 [[A3]]
; GCN-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr addrspace(3) [[TEMP1]], align 4
; GCN-NEXT:    [[L21:%.*]] = extractelement <2 x i32> [[TMP1]], i32 0
; GCN-NEXT:    [[L12:%.*]] = extractelement <2 x i32> [[TMP1]], i32 1
; GCN-NEXT:    store <2 x i32> zeroinitializer, ptr addrspace(3) [[TEMP1]], align 4
; GCN-NEXT:    [[TMP2:%.*]] = load <2 x i32>, ptr addrspace(3) [[TEMP2]], align 4
; GCN-NEXT:    [[L33:%.*]] = extractelement <2 x i32> [[TMP2]], i32 0
; GCN-NEXT:    [[L44:%.*]] = extractelement <2 x i32> [[TMP2]], i32 1
; GCN-NEXT:    [[TMP3:%.*]] = load <2 x i32>, ptr addrspace(3) [[TEMP4]], align 4
; GCN-NEXT:    [[L55:%.*]] = extractelement <2 x i32> [[TMP3]], i32 0
; GCN-NEXT:    [[L66:%.*]] = extractelement <2 x i32> [[TMP3]], i32 1
; GCN-NEXT:    [[L77:%.*]] = extractelement <2 x i32> [[TMP3]], i32 1
; GCN-NEXT:    [[L88:%.*]] = extractelement <2 x i32> [[TMP3]], i32 1
; GCN-NEXT:    ret void
;
  %a1 = add i32 %arg, 1
  %a2 = add i32 %arg, 2
  %a3 = add i32 %arg, 3
  %a4 = add i32 %arg, 4
  %temp1 = getelementptr [16384 x i32], ptr addrspace(3) @0, i32 0, i32 %arg
  %temp2 = getelementptr [16384 x i32], ptr addrspace(3) @0, i32 0, i32 %a1
  %temp3 = getelementptr [16384 x i32], ptr addrspace(3) @0, i32 0, i32 %a2
  %temp4 = getelementptr [16384 x i32], ptr addrspace(3) @0, i32 0, i32 %a3
  %temp5 = getelementptr [16384 x i32], ptr addrspace(3) @0, i32 0, i32 %a4

  %l1 = load i32, ptr addrspace(3) %temp2, align 4
  %l2 = load i32, ptr addrspace(3) %temp1, align 4
  store i32 0, ptr addrspace(3) %temp2, align 4
  store i32 0, ptr addrspace(3) %temp1, align 4
  %l3 = load i32, ptr addrspace(3) %temp2, align 4
  %l4 = load i32, ptr addrspace(3) %temp3, align 4
  %l5 = load i32, ptr addrspace(3) %temp4, align 4
  %l6 = load i32, ptr addrspace(3) %temp5, align 4
  %l7 = load i32, ptr addrspace(3) %temp5, align 4
  %l8 = load i32, ptr addrspace(3) %temp5, align 4

  ret void
}
