; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -mtriple=x86_64-unknown-linux-gnu -passes=load-store-vectorizer -S < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

define void @same_type_i32(ptr %p) {
; CHECK-LABEL: @same_type_i32(
; CHECK-NEXT:    [[L_ALL:%.*]] = load <2 x i32>, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[E_0:%.*]] = extractelement <2 x i32> [[L_ALL]], i32 0
; CHECK-NEXT:    [[E_1:%.*]] = extractelement <2 x i32> [[L_ALL]], i32 1
; CHECK-NEXT:    call void @use_i32(i32 [[E_0]])
; CHECK-NEXT:    call void @use_i32(i32 [[E_1]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 4
  %l.0 = load i32, ptr %p, align 4
  %l.1 = load i32, ptr %p.1, align 4
  call void @use_i32(i32 %l.0)
  call void @use_i32(i32 %l.1)
  ret void
}

define void @mixed_i32_i16_i16(ptr %p) {
; CHECK-LABEL: @mixed_i32_i16_i16(
; CHECK-NEXT:    [[L_ALL:%.*]] = load <4 x i16>, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[E_0:%.*]] = shufflevector <4 x i16> [[L_ALL]], <4 x i16> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[L_0:%.*]] = bitcast <2 x i16> [[E_0]] to i32
; CHECK-NEXT:    [[L_1:%.*]] = extractelement <4 x i16> [[L_ALL]], i32 2
; CHECK-NEXT:    [[L_2:%.*]] = extractelement <4 x i16> [[L_ALL]], i32 3
; CHECK-NEXT:    call void @use_i32(i32 [[L_0]])
; CHECK-NEXT:    call void @use_i16(i16 [[L_1]])
; CHECK-NEXT:    call void @use_i16(i16 [[L_2]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 4
  %p.2 = getelementptr i8, ptr %p, i64 6
  %l.0 = load i32, ptr %p, align 4
  %l.1 = load i16, ptr %p.1, align 4
  %l.2 = load i16, ptr %p.2, align 4
  call void @use_i32(i32 %l.0)
  call void @use_i16(i16 %l.1)
  call void @use_i16(i16 %l.2)
  ret void
}

define void @mixed_i16_i16_i32(ptr %p) {
; CHECK-LABEL: @mixed_i16_i16_i32(
; CHECK-NEXT:    [[L_ALL:%.*]] = load <4 x i16>, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[L_0:%.*]] = extractelement <4 x i16> [[L_ALL]], i32 0
; CHECK-NEXT:    [[L_1:%.*]] = extractelement <4 x i16> [[L_ALL]], i32 1
; CHECK-NEXT:    [[E_2:%.*]] = shufflevector <4 x i16> [[L_ALL]], <4 x i16> poison, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[L_2:%.*]] = bitcast <2 x i16> [[E_2]] to i32
; CHECK-NEXT:    call void @use_i16(i16 [[L_0]])
; CHECK-NEXT:    call void @use_i16(i16 [[L_1]])
; CHECK-NEXT:    call void @use_i32(i32 [[L_2]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 2
  %p.2 = getelementptr i8, ptr %p, i64 4
  %l.0 = load i16, ptr %p, align 4
  %l.1 = load i16, ptr %p.1, align 4
  %l.2 = load i32, ptr %p.2, align 4
  call void @use_i16(i16 %l.0)
  call void @use_i16(i16 %l.1)
  call void @use_i32(i32 %l.2)
  ret void
}

define void @mixed_float_i32(ptr %p) {
; CHECK-LABEL: @mixed_float_i32(
; CHECK-NEXT:    [[L_ALL:%.*]] = load <2 x i32>, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[E_0:%.*]] = extractelement <2 x i32> [[L_ALL]], i32 0
; CHECK-NEXT:    [[L_0:%.*]] = bitcast i32 [[E_0]] to float
; CHECK-NEXT:    [[L_1:%.*]] = extractelement <2 x i32> [[L_ALL]], i32 1
; CHECK-NEXT:    call void @use_float(float [[L_0]])
; CHECK-NEXT:    call void @use_i32(i32 [[L_1]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 4
  %l.0 = load float, ptr %p, align 4
  %l.1 = load i32, ptr %p.1, align 4
  call void @use_float(float %l.0)
  call void @use_i32(i32 %l.1)
  ret void
}

define void @mixed_i64_i32_i32(ptr %p) {
; CHECK-LABEL: @mixed_i64_i32_i32(
; CHECK-NEXT:    [[L_ALL:%.*]] = load <4 x i32>, ptr [[P:%.*]], align 16
; CHECK-NEXT:    [[E_0:%.*]] = shufflevector <4 x i32> [[L_ALL]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[L_0:%.*]] = bitcast <2 x i32> [[E_0]] to i64
; CHECK-NEXT:    [[L_1:%.*]] = extractelement <4 x i32> [[L_ALL]], i32 2
; CHECK-NEXT:    [[L_2:%.*]] = extractelement <4 x i32> [[L_ALL]], i32 3
; CHECK-NEXT:    call void @use_i64(i64 [[L_0]])
; CHECK-NEXT:    call void @use_i32(i32 [[L_1]])
; CHECK-NEXT:    call void @use_i32(i32 [[L_2]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 8
  %p.2 = getelementptr i8, ptr %p, i64 12
  %l.0 = load i64, ptr %p, align 16
  %l.1 = load i32, ptr %p.1, align 4
  %l.2 = load i32, ptr %p.2, align 4
  call void @use_i64(i64 %l.0)
  call void @use_i32(i32 %l.1)
  call void @use_i32(i32 %l.2)
  ret void
}

; Test mixed stores
define void @mixed_store_i32_i16_i16(ptr %p, i32 %v.0, i16 %v.1, i16 %v.2) {
; CHECK-LABEL: @mixed_store_i32_i16_i16(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[V_0:%.*]] to <2 x i16>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <2 x i16> [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i16> poison, i16 [[TMP2]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <2 x i16> [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <4 x i16> [[TMP3]], i16 [[TMP4]], i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <4 x i16> [[TMP5]], i16 [[V_1:%.*]], i32 2
; CHECK-NEXT:    [[TMP7:%.*]] = insertelement <4 x i16> [[TMP6]], i16 [[V_2:%.*]], i32 3
; CHECK-NEXT:    store <4 x i16> [[TMP7]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 4
  %p.2 = getelementptr i8, ptr %p, i64 6
  store i32 %v.0, ptr %p, align 4
  store i16 %v.1, ptr %p.1, align 4
  store i16 %v.2, ptr %p.2, align 4
  ret void
}

define void @mixed_store_float_i32(ptr %p, float %v.0, i32 %v.1) {
; CHECK-LABEL: @mixed_store_float_i32(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast float [[V_0:%.*]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> poison, i32 [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> [[TMP2]], i32 [[V_1:%.*]], i32 1
; CHECK-NEXT:    store <2 x i32> [[TMP3]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 4
  store float %v.0, ptr %p, align 4
  store i32 %v.1, ptr %p.1, align 4
  ret void
}

; Test i64 and i16 (GCD = i16)
define void @mixed_i64_i16(ptr %p) {
; CHECK-LABEL: @mixed_i64_i16(
; CHECK-NEXT:    [[TMP1:%.*]] = load <5 x i16>, ptr [[P:%.*]], align 8
; CHECK-NEXT:    [[L_01:%.*]] = shufflevector <5 x i16> [[TMP1]], <5 x i16> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <4 x i16> [[L_01]] to i64
; CHECK-NEXT:    [[L_12:%.*]] = extractelement <5 x i16> [[TMP1]], i32 4
; CHECK-NEXT:    call void @use_i64(i64 [[TMP2]])
; CHECK-NEXT:    call void @use_i16(i16 [[L_12]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 8
  %l.0 = load i64, ptr %p, align 8
  %l.1 = load i16, ptr %p.1, align 2
  call void @use_i64(i64 %l.0)
  call void @use_i16(i16 %l.1)
  ret void
}

; Test with padding/gap (should not vectorizer)
define void @mixed_gap_i32_i16(ptr %p) {
; CHECK-LABEL: @mixed_gap_i32_i16(
; CHECK-NEXT:    [[P_1:%.*]] = getelementptr i8, ptr [[P:%.*]], i64 5
; CHECK-NEXT:    [[L_0:%.*]] = load i32, ptr [[P]], align 4
; CHECK-NEXT:    [[L_1:%.*]] = load i16, ptr [[P_1]], align 1
; CHECK-NEXT:    call void @use_i32(i32 [[L_0]])
; CHECK-NEXT:    call void @use_i16(i16 [[L_1]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 5 ; Gap of 1 byte after i32
  %l.0 = load i32, ptr %p, align 4
  %l.1 = load i16, ptr %p.1, align 1
  call void @use_i32(i32 %l.0)
  call void @use_i16(i16 %l.1)
  ret void
}

; Test 3-element i32 (should vectorize if allowed)
define void @mixed_i32_i32_i32(ptr %p) {
; CHECK-LABEL: @mixed_i32_i32_i32(
; CHECK-NEXT:    [[TMP1:%.*]] = load <3 x i32>, ptr [[P:%.*]], align 4
; CHECK-NEXT:    [[L_01:%.*]] = extractelement <3 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[L_12:%.*]] = extractelement <3 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[L_23:%.*]] = extractelement <3 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    call void @use_i32(i32 [[L_01]])
; CHECK-NEXT:    call void @use_i32(i32 [[L_12]])
; CHECK-NEXT:    call void @use_i32(i32 [[L_23]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 4
  %p.2 = getelementptr i8, ptr %p, i64 8
  %l.0 = load i32, ptr %p, align 4
  %l.1 = load i32, ptr %p.1, align 4
  %l.2 = load i32, ptr %p.2, align 4
  call void @use_i32(i32 %l.0)
  call void @use_i32(i32 %l.1)
  call void @use_i32(i32 %l.2)
  ret void
}

; Test i8 (should vectorize)
define void @mixed_i16_i8_i8(ptr %p) {
; CHECK-LABEL: @mixed_i16_i8_i8(
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i8>, ptr [[P:%.*]], align 2
; CHECK-NEXT:    [[L_01:%.*]] = shufflevector <4 x i8> [[TMP1]], <4 x i8> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i8> [[L_01]] to i16
; CHECK-NEXT:    [[L_12:%.*]] = extractelement <4 x i8> [[TMP1]], i32 2
; CHECK-NEXT:    [[L_23:%.*]] = extractelement <4 x i8> [[TMP1]], i32 3
; CHECK-NEXT:    call void @use_i16(i16 [[TMP2]])
; CHECK-NEXT:    call void @use_i8(i8 [[L_12]])
; CHECK-NEXT:    call void @use_i8(i8 [[L_23]])
; CHECK-NEXT:    ret void
;
  %p.1 = getelementptr i8, ptr %p, i64 2
  %p.2 = getelementptr i8, ptr %p, i64 3
  %l.0 = load i16, ptr %p, align 2
  %l.1 = load i8, ptr %p.1, align 1
  %l.2 = load i8, ptr %p.2, align 1
  call void @use_i16(i16 %l.0)
  call void @use_i8(i8 %l.1)
  call void @use_i8(i8 %l.2)
  ret void
}

declare void @use_i16(i16)
declare void @use_i32(i32)
declare void @use_i64(i64)
declare void @use_float(float)
declare void @use_i8(i8)
