; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=load-store-vectorizer -S < %s | FileCheck %s

; The IR has the first float3 labeled with align 16, and that 16 should
; be propagated such that the second set of 4 values
; can also be vectorized together.
%struct.float3 = type { float, float, float }
%struct.S1 = type { %struct.float3, %struct.float3, i32, i32 }

define void @testStore(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testStore(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    store <4 x float> zeroinitializer, ptr [[TMP0]], align 16
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds [[STRUCT_S1:%.*]], ptr [[TMP0]], i64 0, i32 1, i32 1
; CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    ret void
;
  store float 0.000000e+00, ptr %1, align 16
  %getElem = getelementptr inbounds %struct.float3, ptr %1, i64 0, i32 1
  store float 0.000000e+00, ptr %getElem, align 4
  %getElem8 = getelementptr inbounds %struct.float3, ptr %1, i64 0, i32 2
  store float 0.000000e+00, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 1
  store float 0.000000e+00, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 1, i32 1
  store float 0.000000e+00, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 1, i32 2
  store float 0.000000e+00, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 2
  store i32 0, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 3
  store i32 0, ptr %getElem13, align 4
  ret void
}

define void @testLoad(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testLoad(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = load <4 x float>, ptr [[TMP0]], align 16
; CHECK-NEXT:    [[L11:%.*]] = extractelement <4 x float> [[TMP2]], i32 0
; CHECK-NEXT:    [[L22:%.*]] = extractelement <4 x float> [[TMP2]], i32 1
; CHECK-NEXT:    [[L33:%.*]] = extractelement <4 x float> [[TMP2]], i32 2
; CHECK-NEXT:    [[L44:%.*]] = extractelement <4 x float> [[TMP2]], i32 3
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds [[STRUCT_S1:%.*]], ptr [[TMP0]], i64 0, i32 1, i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = load <4 x i32>, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    [[L55:%.*]] = extractelement <4 x i32> [[TMP3]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i32 [[L55]] to float
; CHECK-NEXT:    [[L66:%.*]] = extractelement <4 x i32> [[TMP3]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32 [[L66]] to float
; CHECK-NEXT:    [[L77:%.*]] = extractelement <4 x i32> [[TMP3]], i32 2
; CHECK-NEXT:    [[L88:%.*]] = extractelement <4 x i32> [[TMP3]], i32 3
; CHECK-NEXT:    ret void
;
  %l1 = load float, ptr %1, align 16
  %getElem = getelementptr inbounds %struct.float3, ptr %1, i64 0, i32 1
  %l2 = load float, ptr %getElem, align 4
  %getElem8 = getelementptr inbounds %struct.float3, ptr %1, i64 0, i32 2
  %l3 = load float, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 1
  %l4 = load float, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 1, i32 1
  %l5 = load float, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 1, i32 2
  %l6 = load float, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 2
  %l7 = load i32, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds %struct.S1, ptr %1, i64 0, i32 3
  %l8 = load i32, ptr %getElem13, align 4
  ret void
}

; Also, test without the struct geps, to see if it still works with i8 geps/ptradd

define void @testStorei8(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testStorei8(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    store <4 x float> zeroinitializer, ptr [[TMP0]], align 16
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 16
; CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    ret void
;
  store float 0.000000e+00, ptr %1, align 16
  %getElem = getelementptr inbounds i8, ptr %1, i64 4
  store float 0.000000e+00, ptr %getElem, align 4
  %getElem8 = getelementptr inbounds i8, ptr %1, i64 8
  store float 0.000000e+00, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds i8, ptr %1, i64 12
  store float 0.000000e+00, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds i8, ptr %1, i64 16
  store float 0.000000e+00, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds i8, ptr %1, i64 20
  store float 0.000000e+00, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds i8, ptr %1, i64 24
  store i32 0, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds i8, ptr %1, i64 28
  store i32 0, ptr %getElem13, align 4
  ret void
}

define void @testLoadi8(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testLoadi8(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = load <4 x float>, ptr [[TMP0]], align 16
; CHECK-NEXT:    [[L11:%.*]] = extractelement <4 x float> [[TMP2]], i32 0
; CHECK-NEXT:    [[L22:%.*]] = extractelement <4 x float> [[TMP2]], i32 1
; CHECK-NEXT:    [[L33:%.*]] = extractelement <4 x float> [[TMP2]], i32 2
; CHECK-NEXT:    [[L44:%.*]] = extractelement <4 x float> [[TMP2]], i32 3
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 16
; CHECK-NEXT:    [[TMP3:%.*]] = load <4 x i32>, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    [[L55:%.*]] = extractelement <4 x i32> [[TMP3]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i32 [[L55]] to float
; CHECK-NEXT:    [[L66:%.*]] = extractelement <4 x i32> [[TMP3]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32 [[L66]] to float
; CHECK-NEXT:    [[L77:%.*]] = extractelement <4 x i32> [[TMP3]], i32 2
; CHECK-NEXT:    [[L88:%.*]] = extractelement <4 x i32> [[TMP3]], i32 3
; CHECK-NEXT:    ret void
;
  %l1 = load float, ptr %1, align 16
  %getElem = getelementptr inbounds i8, ptr %1, i64 4
  %l2 = load float, ptr %getElem, align 4
  %getElem8 = getelementptr inbounds i8, ptr %1, i64 8
  %l3 = load float, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds i8, ptr %1, i64 12
  %l4 = load float, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds i8, ptr %1, i64 16
  %l5 = load float, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds i8, ptr %1, i64 20
  %l6 = load float, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds i8, ptr %1, i64 24
  %l7 = load i32, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds i8, ptr %1, i64 28
  %l8 = load i32, ptr %getElem13, align 4
  ret void
}


; This version of the test adjusts the struct to hold two i32s at the beginning,
; but still assumes that the first float3 is 16 aligned. If the alignment
; propagation works correctly, it should be able to load this struct in three
; loads: a 2x32, a 4x32, and a 4x32. Without the alignment propagation, the last
; 4x32 will instead be a 2x32 and a 2x32
%struct.S2 = type { i32, i32, %struct.float3, %struct.float3, i32, i32 }

define void @testStore_2(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testStore_2(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[GETELEM1:%.*]] = getelementptr inbounds [[STRUCT_S2:%.*]], ptr [[TMP0]], i64 0, i32 2
; CHECK-NEXT:    store <4 x float> zeroinitializer, ptr [[GETELEM1]], align 16
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds [[STRUCT_S2]], ptr [[TMP0]], i64 0, i32 3, i32 1
; CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    ret void
;
  store i32 0, ptr %1, align 8
  %getElem = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 1
  store i32 0, ptr %getElem, align 4
  %getElem1 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 2
  store float 0.000000e+00, ptr %getElem1, align 16
  %getElem2 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 2, i32 1
  store float 0.000000e+00, ptr %getElem2, align 4
  %getElem8 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 2, i32 2
  store float 0.000000e+00, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 3
  store float 0.000000e+00, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 3, i32 1
  store float 0.000000e+00, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 3, i32 2
  store float 0.000000e+00, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 4
  store i32 0, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 5
  store i32 0, ptr %getElem13, align 4
  ret void
}

define void @testLoad_2(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testLoad_2(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = load <2 x i32>, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[L1:%.*]] = extractelement <2 x i32> [[TMP2]], i32 0
; CHECK-NEXT:    [[L22:%.*]] = extractelement <2 x i32> [[TMP2]], i32 1
; CHECK-NEXT:    [[GETELEM1:%.*]] = getelementptr inbounds [[STRUCT_S2:%.*]], ptr [[TMP0]], i64 0, i32 2
; CHECK-NEXT:    [[TMP3:%.*]] = load <4 x float>, ptr [[GETELEM1]], align 16
; CHECK-NEXT:    [[L33:%.*]] = extractelement <4 x float> [[TMP3]], i32 0
; CHECK-NEXT:    [[L44:%.*]] = extractelement <4 x float> [[TMP3]], i32 1
; CHECK-NEXT:    [[L55:%.*]] = extractelement <4 x float> [[TMP3]], i32 2
; CHECK-NEXT:    [[L66:%.*]] = extractelement <4 x float> [[TMP3]], i32 3
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds [[STRUCT_S2]], ptr [[TMP0]], i64 0, i32 3, i32 1
; CHECK-NEXT:    [[TMP4:%.*]] = load <4 x i32>, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    [[L77:%.*]] = extractelement <4 x i32> [[TMP4]], i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32 [[L77]] to float
; CHECK-NEXT:    [[L88:%.*]] = extractelement <4 x i32> [[TMP4]], i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 [[L88]] to float
; CHECK-NEXT:    [[L99:%.*]] = extractelement <4 x i32> [[TMP4]], i32 2
; CHECK-NEXT:    [[L010:%.*]] = extractelement <4 x i32> [[TMP4]], i32 3
; CHECK-NEXT:    ret void
;
  %l = load i32, ptr %1, align 8
  %getElem = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 1
  %l2 = load i32, ptr %getElem, align 4
  %getElem1 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 2
  %l3 = load float, ptr %getElem1, align 16
  %getElem2 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 2, i32 1
  %l4 = load float, ptr %getElem2, align 4
  %getElem8 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 2, i32 2
  %l5 = load float, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 3
  %l6 = load float, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 3, i32 1
  %l7 = load float, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 3, i32 2
  %l8 = load float, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 4
  %l9 = load i32, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds %struct.S2, ptr %1, i64 0, i32 5
  %l0 = load i32, ptr %getElem13, align 4
  ret void
}

; Also, test without the struct geps, to see if it still works with i8 geps/ptradd

define void @testStorei8_2(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testStorei8_2(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    store <2 x i32> zeroinitializer, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[GETELEM1:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 8
; CHECK-NEXT:    store <4 x float> zeroinitializer, ptr [[GETELEM1]], align 16
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 24
; CHECK-NEXT:    store <4 x i32> zeroinitializer, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    ret void
;
  store i32 0, ptr %1, align 8
  %getElem = getelementptr inbounds i8, ptr %1, i64 4
  store i32 0, ptr %getElem, align 4
  %getElem1 = getelementptr inbounds i8, ptr %1, i64 8
  store float 0.000000e+00, ptr %getElem1, align 16
  %getElem2 = getelementptr inbounds i8, ptr %1, i64 12
  store float 0.000000e+00, ptr %getElem2, align 4
  %getElem8 = getelementptr inbounds i8, ptr %1, i64 16
  store float 0.000000e+00, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds i8, ptr %1, i64 20
  store float 0.000000e+00, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds i8, ptr %1, i64 24
  store float 0.000000e+00, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds i8, ptr %1, i64 28
  store float 0.000000e+00, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds i8, ptr %1, i64 32
  store i32 0, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds i8, ptr %1, i64 36
  store i32 0, ptr %getElem13, align 4
  ret void
}

define void @testLoadi8_2(ptr nocapture writeonly %1) {
; CHECK-LABEL: define void @testLoadi8_2(
; CHECK-SAME: ptr writeonly captures(none) [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = load <2 x i32>, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[L1:%.*]] = extractelement <2 x i32> [[TMP2]], i32 0
; CHECK-NEXT:    [[L22:%.*]] = extractelement <2 x i32> [[TMP2]], i32 1
; CHECK-NEXT:    [[GETELEM1:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 8
; CHECK-NEXT:    [[TMP3:%.*]] = load <4 x float>, ptr [[GETELEM1]], align 16
; CHECK-NEXT:    [[L33:%.*]] = extractelement <4 x float> [[TMP3]], i32 0
; CHECK-NEXT:    [[L44:%.*]] = extractelement <4 x float> [[TMP3]], i32 1
; CHECK-NEXT:    [[L55:%.*]] = extractelement <4 x float> [[TMP3]], i32 2
; CHECK-NEXT:    [[L66:%.*]] = extractelement <4 x float> [[TMP3]], i32 3
; CHECK-NEXT:    [[GETELEM10:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 24
; CHECK-NEXT:    [[TMP4:%.*]] = load <4 x i32>, ptr [[GETELEM10]], align 16
; CHECK-NEXT:    [[L77:%.*]] = extractelement <4 x i32> [[TMP4]], i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32 [[L77]] to float
; CHECK-NEXT:    [[L88:%.*]] = extractelement <4 x i32> [[TMP4]], i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 [[L88]] to float
; CHECK-NEXT:    [[L99:%.*]] = extractelement <4 x i32> [[TMP4]], i32 2
; CHECK-NEXT:    [[L010:%.*]] = extractelement <4 x i32> [[TMP4]], i32 3
; CHECK-NEXT:    ret void
;
  %l = load i32, ptr %1, align 8
  %getElem = getelementptr inbounds i8, ptr %1, i64 4
  %l2 = load i32, ptr %getElem, align 4
  %getElem1 = getelementptr inbounds i8, ptr %1, i64 8
  %l3 = load float, ptr %getElem1, align 16
  %getElem2 = getelementptr inbounds i8, ptr %1, i64 12
  %l4 = load float, ptr %getElem2, align 4
  %getElem8 = getelementptr inbounds i8, ptr %1, i64 16
  %l5 = load float, ptr %getElem8, align 8
  %getElem9 = getelementptr inbounds i8, ptr %1, i64 20
  %l6 = load float, ptr %getElem9, align 4
  %getElem10 = getelementptr inbounds i8, ptr %1, i64 24
  %l7 = load float, ptr %getElem10, align 4
  %getElem11 = getelementptr inbounds i8, ptr %1, i64 28
  %l8 = load float, ptr %getElem11, align 4
  %getElem12 = getelementptr inbounds i8, ptr %1, i64 32
  %l9 = load i32, ptr %getElem12, align 8
  %getElem13 = getelementptr inbounds i8, ptr %1, i64 36
  %l0 = load i32, ptr %getElem13, align 4
  ret void
}
