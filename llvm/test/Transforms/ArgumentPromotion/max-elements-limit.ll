; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -passes=argpromotion -S %s | FileCheck %s

define internal i32 @callee2(ptr noundef %0) {
; CHECK-LABEL: define {{[^@]+}}@callee2.argprom
; CHECK-SAME: (i32 [[DOT0_VAL:%.*]], i32 [[DOT4_VAL:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = add nsw i32 [[DOT0_VAL]], [[DOT4_VAL]]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
  %2 = load i32, ptr %0, align 4
  %3 = getelementptr inbounds i32, ptr %0, i64 1
  %4 = load i32, ptr %3, align 4
  %5 = add nsw i32 %2, %4
  ret i32 %5
}

define i32 @caller2(i32 %0, i32 %1) {
; CHECK-LABEL: define {{[^@]+}}@caller2
; CHECK-SAME: (i32 [[TMP0:%.*]], i32 [[TMP1:%.*]]) {
; CHECK-NEXT:    [[TMP3:%.*]] = alloca [2 x i32], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP3]], i64 1
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[TMP4]], align 4
; CHECK-NEXT:    [[DOTVAL:%.*]] = load i32, ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP3]], i64 4
; CHECK-NEXT:    [[DOTVAL1:%.*]] = load i32, ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @callee2.argprom(i32 [[DOTVAL]], i32 [[DOTVAL1]])
; CHECK-NEXT:    ret i32 [[TMP6]]
;
  %3 = alloca [2 x i32], align 4
  store i32 %0, ptr %3, align 4
  %4 = getelementptr inbounds i32, ptr %3, i64 1
  store i32 %1, ptr %4, align 4
  %5 = call i32 @callee2(ptr noundef %3)
  ret i32 %5
}

define internal i32 @callee3(ptr noundef %0) {
; CHECK-LABEL: define {{[^@]+}}@callee3
; CHECK-SAME: (ptr noundef [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP0]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP0]], i64 1
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = add nsw i32 [[TMP2]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i32, ptr [[TMP0]], i64 2
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[TMP6]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = add nsw i32 [[TMP5]], [[TMP7]]
; CHECK-NEXT:    ret i32 [[TMP8]]
;
  %2 = load i32, ptr %0, align 4
  %3 = getelementptr inbounds i32, ptr %0, i64 1
  %4 = load i32, ptr %3, align 4
  %5 = add nsw i32 %2, %4
  %6 = getelementptr inbounds i32, ptr %0, i64 2
  %7 = load i32, ptr %6, align 4
  %8 = add nsw i32 %5, %7
  ret i32 %8
}

define i32 @caller3(i32 %0, i32 %1, i32 %2) {
; CHECK-LABEL: define {{[^@]+}}@caller3
; CHECK-SAME: (i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], i32 [[TMP2:%.*]]) {
; CHECK-NEXT:    [[TMP4:%.*]] = alloca [3 x i32], align 4
; CHECK-NEXT:    store i32 [[TMP0]], ptr [[TMP4]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i64 1
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], i64 1
; CHECK-NEXT:    store i32 [[TMP2]], ptr [[TMP6]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = call i32 @callee3(ptr noundef [[TMP4]])
; CHECK-NEXT:    ret i32 [[TMP7]]
;
  %4 = alloca [3 x i32], align 4
  store i32 %0, ptr %4, align 4
  %5 = getelementptr inbounds i32, ptr %4, i64 1
  store i32 %1, ptr %5, align 4
  %6 = getelementptr inbounds i32, ptr %5, i64 1
  store i32 %2, ptr %6, align 4
  %7 = call i32 @callee3(ptr noundef %4)
  ret i32 %7
}
