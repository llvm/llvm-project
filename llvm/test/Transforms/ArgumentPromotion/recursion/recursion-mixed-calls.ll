; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=argpromotion < %s | FileCheck %s
define internal i32 @zoo(ptr %x, i32 %m) {
; CHECK-LABEL: define internal i32 @zoo(
; CHECK-SAME: i32 [[X_0_VAL:%.*]], i32 [[M:%.*]]) {
; CHECK-NEXT:    [[RESZOO:%.*]] = add i32 [[X_0_VAL]], [[M]]
; CHECK-NEXT:    ret i32 [[X_0_VAL]]
;
  %valzoo = load i32, ptr %x, align 4
  %reszoo = add i32 %valzoo, %m
  ret i32 %valzoo
}

define internal i32 @foo(ptr %x, ptr %y, i32 %n, i32 %m) {
; CHECK-LABEL: define internal i32 @foo(
; CHECK-SAME: ptr [[X:%.*]], i32 [[Y_0_VAL:%.*]], i32 [[N:%.*]], i32 [[M:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[N]], 0
; CHECK-NEXT:    br i1 [[CMP]], label %[[COND_TRUE:.*]], label %[[COND_FALSE:.*]]
; CHECK:       [[COND_TRUE]]:
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[COND_FALSE]]:
; CHECK-NEXT:    [[VAL2:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[SUBVAL:%.*]] = sub i32 [[N]], [[Y_0_VAL]]
; CHECK-NEXT:    [[CALLRET:%.*]] = call i32 @foo(ptr [[X]], i32 [[Y_0_VAL]], i32 [[SUBVAL]], i32 [[VAL2]])
; CHECK-NEXT:    [[SUBVAL2:%.*]] = sub i32 [[N]], 2
; CHECK-NEXT:    [[CALLRET2:%.*]] = call i32 @foo(ptr [[X]], i32 [[Y_0_VAL]], i32 [[SUBVAL2]], i32 [[M]])
; CHECK-NEXT:    [[CMP1:%.*]] = add i32 [[CALLRET]], [[CALLRET2]]
; CHECK-NEXT:    [[X_VAL:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[CALLRETFINAL:%.*]] = call i32 @zoo(i32 [[X_VAL]], i32 [[M]])
; CHECK-NEXT:    [[CMP2:%.*]] = add i32 [[CMP1]], [[CALLRETFINAL]]
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[COND_NEXT:.*]]:
; CHECK-NEXT:    br label %[[RETURN]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ [[VAL]], %[[COND_TRUE]] ], [ [[CMP2]], %[[COND_FALSE]] ], [ poison, %[[COND_NEXT]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %cmp = icmp ne i32 %n, 0
  br i1 %cmp, label %cond_true, label %cond_false

cond_true:                                        ; preds = %entry
  %val = load i32, ptr %x, align 4
  br label %return

cond_false:                                       ; preds = %entry
  %val2 = load i32, ptr %x, align 4
  %val3 = load i32, ptr %y, align 4
  %subval = sub i32 %n, %val3
  %callret = call i32 @foo(ptr %x, ptr %y, i32 %subval, i32 %val2)
  %subval2 = sub i32 %n, 2
  %callret2 = call i32 @foo(ptr %x, ptr %y, i32 %subval2, i32 %m)
  %cmp1 = add i32 %callret, %callret2
  %callretfinal = call i32 @zoo(ptr %x, i32 %m)
  %cmp2 = add i32 %cmp1, %callretfinal
  br label %return

cond_next:                                        ; No predecessors!
  br label %return

return:                                           ; preds = %cond_next, %cond_false, %cond_true
  %retval.0 = phi i32 [ %val, %cond_true ], [ %cmp2, %cond_false ], [ poison, %cond_next ]
  ret i32 %retval.0
}

define i32 @bar(ptr align(4) dereferenceable(4) %x, ptr align(4) dereferenceable(4) %y, i32 %n, i32 %m) {
; CHECK-LABEL: define i32 @bar(
; CHECK-SAME: ptr align 4 dereferenceable(4) [[X:%.*]], ptr align 4 dereferenceable(4) [[Y:%.*]], i32 [[N:%.*]], i32 [[M:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[Y_VAL:%.*]] = load i32, ptr [[Y]], align 4
; CHECK-NEXT:    [[CALLRET3:%.*]] = call i32 @foo(ptr [[X]], i32 [[Y_VAL]], i32 [[N]], i32 [[M]])
; CHECK-NEXT:    br label %[[RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret i32 [[CALLRET3]]
;
entry:
  %callret3 = call i32 @foo(ptr %x, ptr %y, i32 %n, i32 %m)
  br label %return

return:                                           ; preds = %entry
  ret i32 %callret3
}
