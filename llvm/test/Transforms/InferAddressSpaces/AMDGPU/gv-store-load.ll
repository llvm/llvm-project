; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -passes=infer-address-spaces %s | FileCheck %s

@WGCopy = internal addrspace(3) global ptr poison, align 8
@WGCopy1 = internal addrspace(3) global ptr poison, align 8
@WGCopy2 = internal addrspace(3) global ptr poison, align 8
@WGCopy3 = internal addrspace(3) global ptr poison, align 8
@WGCopy4 = internal addrspace(3) global ptr poison, align 8
@WGCopyVec = internal addrspace(3) global <2 x ptr> poison, align 16

; load ptr AS is inferred.
define void @gv_store_load() {
; CHECK-LABEL: define void @gv_store_load() {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[AGG:%.*]] = alloca i64, align 8, addrspace(5)
; CHECK-NEXT:    [[IS:%.*]] = call i1 @is_leader()
; CHECK-NEXT:    br i1 [[IS]], label %[[LEADER:.*]], label %[[MERGE:.*]]
; CHECK:       [[LEADER]]:
; CHECK-NEXT:    br label %[[MERGE]]
; CHECK:       [[MERGE]]:
; CHECK-NEXT:    [[AGG_SROA:%.*]] = phi ptr addrspace(5) [ [[AGG]], %[[LEADER]] ], [ poison, %[[ENTRY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast ptr addrspace(5) [[AGG_SROA]] to ptr
; CHECK-NEXT:    br i1 [[IS]], label %[[LEADER_I:.*]], label %[[EXIT:.*]]
; CHECK:       [[LEADER_I]]:
; CHECK-NEXT:    store ptr [[TMP0]], ptr addrspace(3) @WGCopy, align 8
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr addrspace(3) @WGCopy, align 8
; CHECK-NEXT:    [[AGG_SROA_COPYLOAD:%.*]] = addrspacecast ptr [[TMP1]] to ptr addrspace(5)
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr addrspace(5) [[AGG_SROA_COPYLOAD]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %agg = alloca i64, align 8, addrspace(5)
  %is = call i1 @is_leader()
  br i1 %is, label %leader, label %merge

leader:                                           ; preds = %entry
  %group.ascast = addrspacecast ptr addrspace(5) %agg to ptr
  br label %merge

merge:                                            ; preds = %leader, %entry
  %agg.sroa = phi ptr [ %group.ascast, %leader ], [ poison, %entry ]
  br i1 %is, label %leader.i, label %exit

leader.i:                                         ; preds = %merge
  store ptr %agg.sroa, ptr addrspace(3) @WGCopy, align 8
  br label %exit

exit:                                             ; preds = %leader.i, %merge
  %agg.sroa.copyload = load ptr, ptr addrspace(3) @WGCopy, align 8
  %val = load i64, ptr %agg.sroa.copyload, align 8
  ret void
}

declare i1 @is_leader()

; vector load ptr AS is inferred.
define void @gv_store_load_vec(<2 x ptr addrspace(5)> %private.ptr) {
; CHECK-LABEL: define void @gv_store_load_vec(
; CHECK-SAME: <2 x ptr addrspace(5)> [[PRIVATE_PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[GROUP_ASCAST:%.*]] = addrspacecast <2 x ptr addrspace(5)> [[PRIVATE_PTR]] to <2 x ptr>
; CHECK-NEXT:    store <2 x ptr> [[GROUP_ASCAST]], ptr addrspace(3) @WGCopyVec, align 16
; CHECK-NEXT:    [[TMP0:%.*]] = load <2 x ptr>, ptr addrspace(3) @WGCopyVec, align 16
; CHECK-NEXT:    [[AGG_SROA_COPYLOAD:%.*]] = addrspacecast <2 x ptr> [[TMP0]] to <2 x ptr addrspace(5)>
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq <2 x ptr addrspace(5)> [[AGG_SROA_COPYLOAD]], <ptr addrspace(5) addrspacecast (ptr null to ptr addrspace(5)), ptr addrspace(5) addrspacecast (ptr null to ptr addrspace(5))>
; CHECK-NEXT:    ret void
;
entry:
  %group.ascast = addrspacecast <2 x ptr addrspace(5)> %private.ptr to <2 x ptr>
  store <2 x ptr> %group.ascast, ptr addrspace(3) @WGCopyVec, align 16
  %agg.sroa.copyload = load <2 x ptr>, ptr addrspace(3) @WGCopyVec, align 16
  %cmp = icmp eq <2 x ptr> %agg.sroa.copyload, zeroinitializer
  ret void
}

; load ptr AS is not inferred since GV has a user that is not load or store.
define void @negative_test_gv_user_not_load_store(ptr addrspace(5) %agg) {
; CHECK-LABEL: define void @negative_test_gv_user_not_load_store(
; CHECK-SAME: ptr addrspace(5) [[AGG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[GROUP_ASCAST:%.*]] = addrspacecast ptr addrspace(5) [[AGG]] to ptr
; CHECK-NEXT:    store ptr [[GROUP_ASCAST]], ptr addrspace(3) @WGCopy1, align 8
; CHECK-NEXT:    [[AGG_COPYLOAD:%.*]] = load ptr, ptr addrspace(3) @WGCopy1, align 8
; CHECK-NEXT:    [[VAL:%.*]] = load i64, ptr [[AGG_COPYLOAD]], align 8
; CHECK-NEXT:    [[GV_ASC:%.*]] = addrspacecast ptr addrspace(3) @WGCopy1 to ptr
; CHECK-NEXT:    ret void
;
entry:
  %group.ascast = addrspacecast ptr addrspace(5) %agg to ptr
  store ptr %group.ascast, ptr addrspace(3) @WGCopy1, align 8
  %agg.copyload = load ptr, ptr addrspace(3) @WGCopy1, align 8
  %val = load i64, ptr %agg.copyload, align 8
  %gv.asc = addrspacecast ptr addrspace(3) @WGCopy1 to ptr
  ret void
}

; load ptr AS is not inferred since GV is not used as pointer operand in store
; inst.
define void @negative_test_gv_store_not_pointer_operand(ptr addrspace(5) %agg) {
; CHECK-LABEL: define void @negative_test_gv_store_not_pointer_operand(
; CHECK-SAME: ptr addrspace(5) [[AGG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[B:%.*]] = alloca ptr addrspace(3), align 8, addrspace(5)
; CHECK-NEXT:    [[GROUP_ASCAST:%.*]] = addrspacecast ptr addrspace(5) [[AGG]] to ptr
; CHECK-NEXT:    store ptr [[GROUP_ASCAST]], ptr addrspace(3) @WGCopy2, align 8
; CHECK-NEXT:    store ptr addrspace(3) @WGCopy2, ptr addrspace(5) [[B]], align 8
; CHECK-NEXT:    [[AGG_COPYLOAD:%.*]] = load ptr, ptr addrspace(3) @WGCopy2, align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[AGG_COPYLOAD]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %b = alloca ptr addrspace(3), align 8, addrspace(5)
  %group.ascast = addrspacecast ptr addrspace(5) %agg to ptr
  store ptr %group.ascast, ptr addrspace(3) @WGCopy2, align 8
  store ptr addrspace(3) @WGCopy2, ptr addrspace(5) %b, align 8
  %agg.copyload = load ptr, ptr addrspace(3) @WGCopy2, align 8
  %val = load i64, ptr %agg.copyload, align 8
  ret void
}

; load ptr AS is not inferred since there are multiple stores to GV and stored
; pointers have different AS.
define void @negative_test_gv_multi_store_different_addrspace(ptr addrspace(1) %arg) {
; CHECK-LABEL: define void @negative_test_gv_multi_store_different_addrspace(
; CHECK-SAME: ptr addrspace(1) [[ARG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[AGG:%.*]] = alloca i64, align 8, addrspace(5)
; CHECK-NEXT:    [[GROUP_ASCAST:%.*]] = addrspacecast ptr addrspace(1) [[ARG]] to ptr
; CHECK-NEXT:    store ptr [[GROUP_ASCAST]], ptr addrspace(3) @WGCopy3, align 8
; CHECK-NEXT:    [[GROUP_ASCAST1:%.*]] = addrspacecast ptr addrspace(5) [[AGG]] to ptr
; CHECK-NEXT:    store ptr [[GROUP_ASCAST1]], ptr addrspace(3) @WGCopy3, align 8
; CHECK-NEXT:    [[AGG_COPYLOAD:%.*]] = load ptr, ptr addrspace(3) @WGCopy3, align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[AGG_COPYLOAD]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %agg = alloca i64, align 8, addrspace(5)
  %group.ascast = addrspacecast ptr addrspace(1) %arg to ptr
  store ptr %group.ascast, ptr addrspace(3) @WGCopy3, align 8
  %group.ascast1 = addrspacecast ptr addrspace(5) %agg to ptr
  store ptr %group.ascast1, ptr addrspace(3) @WGCopy3, align 8
  %agg.copyload = load ptr, ptr addrspace(3) @WGCopy3, align 8
  %val = load i64, ptr %agg.copyload, align 8
  ret void
}

; load ptr AS is not inferred since GV is used in two functions
; negative_test_gv_used_in_two_funcs_foo and negative_test_gv_used_in_two_funcs_bar.
define void @negative_test_gv_used_in_two_funcs_foo(ptr addrspace(1) %agg) {
; CHECK-LABEL: define void @negative_test_gv_used_in_two_funcs_foo(
; CHECK-SAME: ptr addrspace(1) [[AGG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[GROUP_ASCAST:%.*]] = addrspacecast ptr addrspace(1) [[AGG]] to ptr
; CHECK-NEXT:    store ptr [[GROUP_ASCAST]], ptr addrspace(3) @WGCopy4, align 8
; CHECK-NEXT:    [[AGG_SROA_COPYLOAD:%.*]] = load ptr, ptr addrspace(3) @WGCopy4, align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[AGG_SROA_COPYLOAD]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %group.ascast = addrspacecast ptr addrspace(1) %agg to ptr
  store ptr %group.ascast, ptr addrspace(3) @WGCopy4, align 8
  %agg.sroa.copyload = load ptr, ptr addrspace(3) @WGCopy4, align 8
  %val = load i64, ptr %agg.sroa.copyload, align 8
  ret void
}

define void @negative_test_gv_used_in_two_funcs_bar(ptr addrspace(1) %agg) {
; CHECK-LABEL: define void @negative_test_gv_used_in_two_funcs_bar(
; CHECK-SAME: ptr addrspace(1) [[AGG:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[GROUP_ASCAST:%.*]] = addrspacecast ptr addrspace(1) [[AGG]] to ptr
; CHECK-NEXT:    store ptr [[GROUP_ASCAST]], ptr addrspace(3) @WGCopy4, align 8
; CHECK-NEXT:    ret void
;
entry:
  %group.ascast = addrspacecast ptr addrspace(1) %agg to ptr
  store ptr %group.ascast, ptr addrspace(3) @WGCopy4, align 8
  ret void
}
