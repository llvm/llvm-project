; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -mtriple=nvptx64-nvidia-cuda -passes=infer-address-spaces-prepare,instcombine,infer-address-spaces %s | FileCheck %s

define void @test_smem_fail(ptr addrspace(3) %sp) {
; CHECK-LABEL: define void @test_smem_fail(
; CHECK-SAME: ptr addrspace(3) [[SP:%.*]]) {
; CHECK-NEXT:    [[GP:%.*]] = addrspacecast ptr addrspace(3) [[SP]] to ptr
; CHECK-NEXT:    [[A:%.*]] = ptrtoint ptr [[GP]] to i64
; CHECK-NEXT:    [[B:%.*]] = xor i64 [[A]], 8191
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[B]] to ptr
; CHECK-NEXT:    store i16 0, ptr [[GP2]], align 2
; CHECK-NEXT:    ret void
;
  %gp = addrspacecast ptr addrspace(3) %sp to ptr
  %a = ptrtoint ptr %gp to i64
  %b = xor i64 8191, %a
  %gp2 = inttoptr i64 %b to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

define void @test_smem(ptr addrspace(3) %sp) {
; CHECK-LABEL: define void @test_smem(
; CHECK-SAME: ptr addrspace(3) [[SP:%.*]]) {
; CHECK-NEXT:    [[GP:%.*]] = addrspacecast ptr addrspace(3) [[SP]] to ptr
; CHECK-NEXT:    [[A:%.*]] = ptrtoint ptr [[GP]] to i64
; CHECK-NEXT:    [[B:%.*]] = xor i64 [[A]], 4095
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[B]] to ptr addrspace(3)
; CHECK-NEXT:    store i16 0, ptr addrspace(3) [[GP2]], align 2
; CHECK-NEXT:    ret void
;
  %gp = addrspacecast ptr addrspace(3) %sp to ptr
  %a = ptrtoint ptr %gp to i64
  %b = xor i64 4095, %a
  %gp2 = inttoptr i64 %b to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

define void @test_gmem(ptr addrspace(1) %sp) {
; CHECK-LABEL: define void @test_gmem(
; CHECK-SAME: ptr addrspace(1) [[SP:%.*]]) {
; CHECK-NEXT:    [[GP:%.*]] = addrspacecast ptr addrspace(1) [[SP]] to ptr
; CHECK-NEXT:    [[A:%.*]] = ptrtoint ptr [[GP]] to i64
; CHECK-NEXT:    [[B:%.*]] = xor i64 [[A]], 7
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[B]] to ptr addrspace(1)
; CHECK-NEXT:    store i16 0, ptr addrspace(1) [[GP2]], align 2
; CHECK-NEXT:    ret void
;
  %gp = addrspacecast ptr addrspace(1) %sp to ptr
  %a = ptrtoint ptr %gp to i64
  %b = xor i64 7, %a
  %gp2 = inttoptr i64 %b to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

define void @test_lmem(ptr addrspace(5) %sp) {
; CHECK-LABEL: define void @test_lmem(
; CHECK-SAME: ptr addrspace(5) [[SP:%.*]]) {
; CHECK-NEXT:    [[GP:%.*]] = addrspacecast ptr addrspace(5) [[SP]] to ptr
; CHECK-NEXT:    [[A:%.*]] = ptrtoint ptr [[GP]] to i64
; CHECK-NEXT:    [[B:%.*]] = xor i64 [[A]], 7
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[B]] to ptr
; CHECK-NEXT:    store i16 0, ptr [[GP2]], align 2
; CHECK-NEXT:    ret void
;
  %gp = addrspacecast ptr addrspace(5) %sp to ptr
  %a = ptrtoint ptr %gp to i64
  %b = xor i64 7, %a
  %gp2 = inttoptr i64 %b to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

define void @test3(ptr addrspace(3) %sp) {
; CHECK-LABEL: define void @test3(
; CHECK-SAME: ptr addrspace(3) [[SP:%.*]]) {
; CHECK-NEXT:    [[GP:%.*]] = addrspacecast ptr addrspace(3) [[SP]] to ptr
; CHECK-NEXT:    [[T1:%.*]] = ptrtoint ptr [[GP]] to i64
; CHECK-NEXT:    [[AND:%.*]] = lshr i64 [[T1]], 8
; CHECK-NEXT:    [[SHR:%.*]] = and i64 [[AND]], 8
; CHECK-NEXT:    [[AND1:%.*]] = lshr i64 [[T1]], 10
; CHECK-NEXT:    [[SHR2:%.*]] = and i64 [[AND1]], 4
; CHECK-NEXT:    [[OR:%.*]] = or disjoint i64 [[SHR]], [[SHR2]]
; CHECK-NEXT:    [[AND3:%.*]] = lshr i64 [[T1]], 4
; CHECK-NEXT:    [[SHR4:%.*]] = and i64 [[AND3]], 112
; CHECK-NEXT:    [[OR5:%.*]] = or disjoint i64 [[OR]], [[SHR4]]
; CHECK-NEXT:    [[XOR:%.*]] = xor i64 [[OR5]], [[T1]]
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[XOR]] to ptr addrspace(3)
; CHECK-NEXT:    store i16 0, ptr addrspace(3) [[GP2]], align 2
; CHECK-NEXT:    ret void
;
  %gp = addrspacecast ptr addrspace(3) %sp to ptr
  %t1 = ptrtoint ptr %gp to i64
  %and = lshr i64 %t1, 8
  %shr = and i64 %and, 8
  %and1 = lshr i64 %t1, 10
  %shr2 = and i64 %and1, 4
  %or = or i64 %shr, %shr2
  %and3 = lshr i64 %t1, 4
  %shr4 = and i64 %and3, 112
  %or5 = or i64 %or, %shr4
  %xor = xor i64 %or5, %t1
  %gp2 = inttoptr i64 %xor to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

define void @test4(ptr addrspace(3) %sp) {
; CHECK-LABEL: define void @test4(
; CHECK-SAME: ptr addrspace(3) [[SP:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = addrspacecast ptr addrspace(3) [[SP]] to ptr
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[XOR:%.*]] = and i64 [[TMP0]], -32
; CHECK-NEXT:    [[OR:%.*]] = xor i64 [[XOR]], 144
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[OR]] to ptr addrspace(3)
; CHECK-NEXT:    store i16 0, ptr addrspace(3) [[GP2]], align 2
; CHECK-NEXT:    ret void
;
entry:
  %a = addrspacecast ptr addrspace(3) %sp to ptr
  %0 = ptrtoint ptr %a to i64
  %xor = xor i64 %0, 128
  %and = and i64 %xor, -16
  %or = or i64 %and, 16
  %gp2 = inttoptr i64 %or to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

define void @test5(ptr %a) {
; CHECK-LABEL: define void @test5(
; CHECK-SAME: ptr [[A:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr [[A]] to i64
; CHECK-NEXT:    [[XOR:%.*]] = and i64 [[TMP0]], -32
; CHECK-NEXT:    [[OR:%.*]] = xor i64 [[XOR]], 144
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[OR]] to ptr
; CHECK-NEXT:    store i16 0, ptr [[GP2]], align 2
; CHECK-NEXT:    ret void
;
entry:
  %0 = ptrtoint ptr %a to i64
  %xor = xor i64 %0, 128
  %and = and i64 %xor, -16
  %or = or i64 %and, 16
  %gp2 = inttoptr i64 %or to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

define void @test_phi(i1 %c, ptr addrspace(3) %sp1, ptr addrspace(3) %sp2) {
; CHECK-LABEL: define void @test_phi(
; CHECK-SAME: i1 [[C:%.*]], ptr addrspace(3) [[SP1:%.*]], ptr addrspace(3) [[SP2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[C]], label %[[IF:.*]], label %[[ELSE:.*]]
; CHECK:       [[IF]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[ELSE]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[OR_IN_IN_IN:%.*]] = phi ptr addrspace(3) [ [[SP1]], %[[IF]] ], [ [[SP2]], %[[ELSE]] ]
; CHECK-NEXT:    [[OR_IN_IN:%.*]] = addrspacecast ptr addrspace(3) [[OR_IN_IN_IN]] to ptr
; CHECK-NEXT:    [[OR_IN:%.*]] = ptrtoint ptr [[OR_IN_IN]] to i64
; CHECK-NEXT:    [[OR:%.*]] = or i64 [[OR_IN]], 16
; CHECK-NEXT:    [[GP2:%.*]] = inttoptr i64 [[OR]] to ptr
; CHECK-NEXT:    store i16 0, ptr [[GP2]], align 2
; CHECK-NEXT:    ret void
;
entry:
  br i1 %c, label %if, label %else

if:
  %a1 = addrspacecast ptr addrspace(3) %sp1 to ptr
  %t1 = ptrtoint ptr %a1 to i64
  %or1 = or i64 %t1, 16
  br label %exit
else:
  %a2 = addrspacecast ptr addrspace(3) %sp2 to ptr
  %t2 = ptrtoint ptr %a2 to i64
  %or2 = or i64 %t2, 16
  br label %exit
exit:
  %or = phi i64 [%or1, %if], [%or2, %else]
  %gp2 = inttoptr i64 %or to ptr
  store i16 0, ptr %gp2, align 2
  ret void
}

@g = addrspace(1) global i32 0, align 4

define void @test_ce() {
; CHECK-LABEL: define void @test_ce() {
; CHECK-NEXT:    store i32 0, ptr inttoptr (i64 xor (i64 ptrtoint (ptr addrspacecast (ptr addrspace(1) @g to ptr) to i64), i64 7) to ptr), align 4
; CHECK-NEXT:    ret void
;
  store i32 0, ptr inttoptr (i64
  xor (i64
  ptrtoint (ptr
  addrspacecast (ptr addrspace(1) @g to ptr)
  to i64),
  i64 7)
  to ptr)
  ret void
}
