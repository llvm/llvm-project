; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes="tailcallelim" -verify-dom-info -S | FileCheck %s

; NOTE: All the following test cases are generate from the underlying C code (-O1)
;   before that the shift accumulator optimization was implemented



; InstCombine strength-reduce `f(x-1) + f(x-1)` to shl:
; int f(int x) {
;     if (x == 1) return 7;
;     return f(x-1) + f(x-1); // f(x-1) * 2
; }
define dso_local i32 @f(i32 noundef %x) local_unnamed_addr {
; CHECK-LABEL: define dso_local i32 @f(
; CHECK-SAME: i32 noundef [[X:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[TAILRECURSE:.*]]
; CHECK:       [[TAILRECURSE]]:
; CHECK-NEXT:    [[ACCUMULATOR_TR:%.*]] = phi i32 [ 7, %[[ENTRY]] ], [ [[ADD:%.*]], %[[IF_END:.*]] ]
; CHECK-NEXT:    [[X_TR:%.*]] = phi i32 [ [[X]], %[[ENTRY]] ], [ [[SUB:%.*]], %[[IF_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X_TR]], 1
; CHECK-NEXT:    br i1 [[CMP]], label %[[COMMON_RET:.*]], label %[[IF_END]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    ret i32 [[ACCUMULATOR_TR]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[SUB]] = add nsw i32 [[X_TR]], -1
; CHECK-NEXT:    [[ADD]] = shl nsw i32 [[ACCUMULATOR_TR]], 1
; CHECK-NEXT:    br label %[[TAILRECURSE]]
;
entry:
  %cmp = icmp eq i32 %x, 1
  br i1 %cmp, label %common.ret, label %if.end

common.ret:
  %common.ret.op = phi i32 [ %add, %if.end ], [ 7, %entry ]
  ret i32 %common.ret.op

if.end:
  %sub = add nsw i32 %x, -1
  %call = tail call i32 @f(i32 noundef %sub)
  %add = shl nsw i32 %call, 1
  br label %common.ret
}


; int f2(int x) {
;     if (x == 1) return 14;
;     return f2(x-1) >> 1;
; }
define dso_local i32 @f2(i32 noundef %x) local_unnamed_addr {
; CHECK-LABEL: define dso_local i32 @f2(
; CHECK-SAME: i32 noundef [[X:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[TAILRECURSE:.*]]
; CHECK:       [[TAILRECURSE]]:
; CHECK-NEXT:    [[ACCUMULATOR_TR:%.*]] = phi i32 [ 14, %[[ENTRY]] ], [ [[SHR:%.*]], %[[IF_END:.*]] ]
; CHECK-NEXT:    [[X_TR:%.*]] = phi i32 [ [[X]], %[[ENTRY]] ], [ [[SUB:%.*]], %[[IF_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X_TR]], 1
; CHECK-NEXT:    br i1 [[CMP]], label %[[COMMON_RET:.*]], label %[[IF_END]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    ret i32 [[ACCUMULATOR_TR]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[SUB]] = add nsw i32 [[X_TR]], -1
; CHECK-NEXT:    [[SHR]] = ashr i32 [[ACCUMULATOR_TR]], 1
; CHECK-NEXT:    br label %[[TAILRECURSE]]
;
entry:
  %cmp = icmp eq i32 %x, 1
  br i1 %cmp, label %common.ret, label %if.end

common.ret:
  %common.ret.op = phi i32 [ %shr, %if.end ], [ 14, %entry ]
  ret i32 %common.ret.op

if.end:
  %sub = add nsw i32 %x, -1
  %call = tail call i32 @f2(i32 noundef %sub)
  %shr = ashr i32 %call, 1
  br label %common.ret
}


; unsigned int f3(unsigned int x) {
;     if (x <= 1) return 14;
;     return f3(x - 1) >> 1;
; }
define dso_local i32 @f3(i32 noundef %x) local_unnamed_addr {
; CHECK-LABEL: define dso_local i32 @f3(
; CHECK-SAME: i32 noundef [[X:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[TAILRECURSE:.*]]
; CHECK:       [[TAILRECURSE]]:
; CHECK-NEXT:    [[ACCUMULATOR_TR:%.*]] = phi i32 [ 21, %[[ENTRY]] ], [ [[SHR:%.*]], %[[IF_END:.*]] ]
; CHECK-NEXT:    [[X_TR:%.*]] = phi i32 [ [[X]], %[[ENTRY]] ], [ [[SUB:%.*]], %[[IF_END]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[X_TR]], 2
; CHECK-NEXT:    br i1 [[CMP]], label %[[COMMON_RET:.*]], label %[[IF_END]]
; CHECK:       [[COMMON_RET]]:
; CHECK-NEXT:    ret i32 [[ACCUMULATOR_TR]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[SUB]] = add i32 [[X_TR]], -1
; CHECK-NEXT:    [[SHR]] = lshr i32 [[ACCUMULATOR_TR]], 1
; CHECK-NEXT:    br label %[[TAILRECURSE]]
;
entry:
  %cmp = icmp ult i32 %x, 2
  br i1 %cmp, label %common.ret, label %if.end

common.ret:
  %common.ret.op = phi i32 [ %shr, %if.end ], [ 21, %entry ]
  ret i32 %common.ret.op

if.end:
  %sub = add i32 %x, -1
  %call = tail call i32 @f3(i32 noundef %sub)
  %shr = lshr i32 %call, 1
  br label %common.ret
}
