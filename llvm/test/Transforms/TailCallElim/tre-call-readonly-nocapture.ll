; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=tailcallelim -verify-dom-info -S | FileCheck %s

; Test that TRE can be applied when a pointer to an alloca is stored in
; another local alloca, and that alloca is passed to a readonly nocapture
; callback. The callback only sees the address value stored in %holder,
; but does NOT dereference the stored pointer, so the original alloca
; (%data) does not escape.

declare void @callback(ptr readonly nocapture)

define i32 @recursive_with_callback(i32 %n, i32 %acc) {
; CHECK-LABEL: define i32 @recursive_with_callback(
; CHECK-SAME: i32 [[N:%.*]], i32 [[ACC:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[DATA:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[HOLDER:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    br label %[[TAILRECURSE:.*]]
; CHECK:       [[TAILRECURSE]]:
; CHECK-NEXT:    [[N_TR:%.*]] = phi i32 [ [[N]], %[[ENTRY]] ], [ [[N_DEC:%.*]], %[[RECURSE:.*]] ]
; CHECK-NEXT:    [[ACC_TR:%.*]] = phi i32 [ [[ACC]], %[[ENTRY]] ], [ [[ACC_INC:%.*]], %[[RECURSE]] ]
; CHECK-NEXT:    store i32 [[ACC_TR]], ptr [[DATA]], align 4
; CHECK-NEXT:    store ptr [[DATA]], ptr [[HOLDER]], align 8
; CHECK-NEXT:    call void @callback(ptr [[HOLDER]])
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[N_TR]], 0
; CHECK-NEXT:    br i1 [[COND]], label %[[EXIT:.*]], label %[[RECURSE]]
; CHECK:       [[RECURSE]]:
; CHECK-NEXT:    [[N_DEC]] = sub i32 [[N_TR]], 1
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[DATA]], align 4
; CHECK-NEXT:    [[ACC_INC]] = add i32 [[VAL]], 1
; CHECK-NEXT:    br label %[[TAILRECURSE]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[RESULT:%.*]] = load i32, ptr [[DATA]], align 4
; CHECK-NEXT:    ret i32 [[RESULT]]
;
entry:
  %data = alloca i32, align 4
  %holder = alloca ptr, align 8

  store i32 %acc, ptr %data, align 4
  store ptr %data, ptr %holder, align 8

  ; callback reads %holder directly (just sees an address value)
  ; but does NOT dereference the stored pointer
  call void @callback(ptr %holder)

  %cond = icmp eq i32 %n, 0
  br i1 %cond, label %exit, label %recurse

recurse:
  %n_dec = sub i32 %n, 1
  %val = load i32, ptr %data, align 4
  %acc_inc = add i32 %val, 1
  %res = call i32 @recursive_with_callback(i32 %n_dec, i32 %acc_inc)
  ret i32 %res

exit:
  %result = load i32, ptr %data, align 4
  ret i32 %result
}
