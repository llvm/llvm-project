; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=correlated-propagation -S < %s | FileCheck %s

declare void @llvm.assume(i1)

define i1 @assume_mul_nuw_square_i8(i8 %s) {
; CHECK-LABEL: @assume_mul_nuw_square_i8(
; CHECK-NEXT:    [[MUL:%.*]] = mul nuw i8 [[S:%.*]], [[S]]
; CHECK-NEXT:    [[COND:%.*]] = icmp ule i8 [[MUL]], 120
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i8 [[S]], 16
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %mul = mul nuw i8 %s, %s
  %cond = icmp ule i8 %mul, 120
  call void @llvm.assume(i1 %cond)
  %cmp = icmp ult i8 %s, 16
  ret i1 %cmp
}

define i1 @assume_mul_nuw_square_i5(i5 %s) {
; CHECK-LABEL: @assume_mul_nuw_square_i5(
; CHECK-NEXT:    [[MUL:%.*]] = mul nuw i5 [[S:%.*]], [[S]]
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i5 [[MUL]], 15
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i5 [[S]], 8
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %mul = mul nuw i5 %s, %s
  %cond = icmp ult i5 %mul, 15
  call void @llvm.assume(i1 %cond)
  %cmp = icmp ult i5 %s, 8
  ret i1 %cmp
}

define i1 @branch_mul_nuw_square(i8 %s, i8 %num) {
; CHECK-LABEL: @branch_mul_nuw_square(
; CHECK-NEXT:    [[MUL:%.*]] = mul nuw i8 [[S:%.*]], [[S]]
; CHECK-NEXT:    [[COND:%.*]] = icmp ule i8 [[MUL]], [[NUM:%.*]]
; CHECK-NEXT:    br i1 [[COND]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; CHECK:       true:
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i8 [[S]], 16
; CHECK-NEXT:    ret i1 [[CMP]]
; CHECK:       false:
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i8 [[S]], 16
; CHECK-NEXT:    ret i1 [[CMP2]]
;
  %mul = mul nuw i8 %s, %s
  %cond = icmp ule i8 %mul, %num
  br i1 %cond, label %true, label %false

true:
  %cmp = icmp ult i8 %s, 16
  ret i1 %cmp

false:
  %cmp2 = icmp ult i8 %s, 16
  ret i1 %cmp2
}

; negative test: missing nuw on the multiply.
define i1 @assume_mul_square_no_nuw(i8 %s) {
; CHECK-LABEL: @assume_mul_square_no_nuw(
; CHECK-NEXT:    [[MUL:%.*]] = mul i8 [[S:%.*]], [[S]]
; CHECK-NEXT:    [[COND:%.*]] = icmp ule i8 [[MUL]], 120
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i8 [[S]], 16
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %mul = mul i8 %s, %s
  %cond = icmp ule i8 %mul, 120
  call void @llvm.assume(i1 %cond)
  %cmp = icmp ult i8 %s, 16
  ret i1 %cmp
}

; negative test: multiply is not a square.
define i1 @assume_mul_nuw_not_square(i8 %s, i8 %t) {
; CHECK-LABEL: @assume_mul_nuw_not_square(
; CHECK-NEXT:    [[MUL:%.*]] = mul nuw i8 [[S:%.*]], [[T:%.*]]
; CHECK-NEXT:    [[COND:%.*]] = icmp ule i8 [[MUL]], 120
; CHECK-NEXT:    call void @llvm.assume(i1 [[COND]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i8 [[S]], 16
; CHECK-NEXT:    ret i1 [[CMP]]
;
  %mul = mul nuw i8 %s, %t
  %cond = icmp ule i8 %mul, 120
  call void @llvm.assume(i1 %cond)
  %cmp = icmp ult i8 %s, 16
  ret i1 %cmp
}
