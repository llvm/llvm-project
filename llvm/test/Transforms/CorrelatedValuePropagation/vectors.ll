; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=correlated-propagation < %s | FileCheck %s

define <2 x i1> @cmp1(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i1> @cmp1(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add nuw <2 x i8> [[A]], <i8 1, i8 1>
; CHECK-NEXT:    ret <2 x i1> <i1 true, i1 true>
;
  %add = add nuw <2 x i8> %a, splat (i8 1)
  %cmp = icmp ne <2 x i8> %add, zeroinitializer
  ret <2 x i1> %cmp
}

define <2 x i1> @cmp2(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i1> @cmp2(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add nuw <2 x i8> [[A]], <i8 5, i8 5>
; CHECK-NEXT:    ret <2 x i1> <i1 true, i1 true>
;
  %add = add nuw <2 x i8> %a, splat (i8 5)
  %cmp = icmp ugt <2 x i8> %add, splat (i8 2)
  ret <2 x i1> %cmp
}

define <2 x i1> @cmp_nonsplat(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i1> @cmp_nonsplat(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add nuw <2 x i8> [[A]], <i8 4, i8 5>
; CHECK-NEXT:    ret <2 x i1> <i1 true, i1 true>
;
  %add = add nuw <2 x i8> %a, <i8 4, i8 5>
  %cmp = icmp ugt <2 x i8> %add, <i8 2, i8 3>
  ret <2 x i1> %cmp
}

; Handling this would require keeping track of ranges on a per-element basis.
define <2 x i1> @cmp_nonsplat_fail(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i1> @cmp_nonsplat_fail(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ADD:%.*]] = add nuw <2 x i8> [[A]], <i8 3, i8 4>
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt <2 x i8> [[ADD]], <i8 2, i8 3>
; CHECK-NEXT:    ret <2 x i1> [[CMP]]
;
  %add = add nuw <2 x i8> %a, <i8 3, i8 4>
  %cmp = icmp ugt <2 x i8> %add, <i8 2, i8 3>
  ret <2 x i1> %cmp
}

define <2 x i1> @cmp_signedness(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i1> @cmp_signedness(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult <2 x i16> [[ZEXT]], <i16 5, i16 5>
; CHECK-NEXT:    ret <2 x i1> [[CMP]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %cmp = icmp slt <2 x i16> %zext, splat (i16 5)
  ret <2 x i1> %cmp
}

define <2 x i16> @infer_nowrap(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @infer_nowrap(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = add nuw nsw <2 x i16> [[ZEXT]], <i16 1, i16 1>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = add <2 x i16> %zext, splat (i16 1)
  ret <2 x i16> %res
}

define <2 x i16> @infer_nowrap_nonsplat(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @infer_nowrap_nonsplat(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = add nuw nsw <2 x i16> [[ZEXT]], <i16 1, i16 2>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = add <2 x i16> %zext, <i16 1, i16 2>
  ret <2 x i16> %res
}

define <vscale x 2 x i16> @infer_nowrap_scalable(<vscale x 2 x i8> %a) {
; CHECK-LABEL: define <vscale x 2 x i16> @infer_nowrap_scalable(
; CHECK-SAME: <vscale x 2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <vscale x 2 x i8> [[A]] to <vscale x 2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = add nuw nsw <vscale x 2 x i16> [[ZEXT]], shufflevector (<vscale x 2 x i16> insertelement (<vscale x 2 x i16> poison, i16 1, i64 0), <vscale x 2 x i16> poison, <vscale x 2 x i32> zeroinitializer)
; CHECK-NEXT:    ret <vscale x 2 x i16> [[RES]]
;
  %zext = zext <vscale x 2 x i8> %a to <vscale x 2 x i16>
  %res = add <vscale x 2 x i16> %zext, splat (i16 1)
  ret <vscale x 2 x i16> %res
}

define <2 x i16> @infer_nowrap_poison(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @infer_nowrap_poison(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = add nuw nsw <2 x i16> [[ZEXT]], <i16 1, i16 poison>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = add <2 x i16> %zext, <i16 1, i16 poison>
  ret <2 x i16> %res
}

define <2 x i16> @infer_nowrap_nonsplat_nsw_only(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @infer_nowrap_nonsplat_nsw_only(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = add nsw <2 x i16> [[ZEXT]], <i16 1, i16 -1>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = add <2 x i16> %zext, <i16 1, i16 -1>
  ret <2 x i16> %res
}

define <2 x i16> @abs(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @abs(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    ret <2 x i16> [[ZEXT]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = call <2 x i16> @llvm.abs(<2 x i16> %zext, i1 false)
  ret <2 x i16> %res
}

define <2 x i16> @saturating(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @saturating(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = add nuw nsw <2 x i16> [[ZEXT]], <i16 1, i16 1>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = call <2 x i16> @llvm.uadd.sat(<2 x i16> %zext, <2 x i16> splat (i16 1))
  ret <2 x i16> %res
}

define {<2 x i16>, <2 x i1>} @with_overflow(<2 x i8> %a) {
; CHECK-LABEL: define { <2 x i16>, <2 x i1> } @with_overflow(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES1:%.*]] = add nuw nsw <2 x i16> [[ZEXT]], <i16 1, i16 1>
; CHECK-NEXT:    [[RES:%.*]] = insertvalue { <2 x i16>, <2 x i1> } { <2 x i16> poison, <2 x i1> zeroinitializer }, <2 x i16> [[RES1]], 0
; CHECK-NEXT:    ret { <2 x i16>, <2 x i1> } [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = call {<2 x i16>, <2 x i1>} @llvm.uadd.with.overflow(<2 x i16> %zext, <2 x i16> splat (i16 1))
  ret {<2 x i16>, <2 x i1>} %res
}

define <2 x i16> @srem1(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @srem1(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES1_LHS_TRUNC:%.*]] = trunc <2 x i16> [[ZEXT]] to <2 x i8>
; CHECK-NEXT:    [[RES12:%.*]] = urem <2 x i8> [[RES1_LHS_TRUNC]], <i8 42, i8 42>
; CHECK-NEXT:    [[RES:%.*]] = zext <2 x i8> [[RES12]] to <2 x i16>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = srem <2 x i16> %zext, splat (i16 42)
  ret <2 x i16> %res
}

define <2 x i16> @srem2(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @srem2(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = sext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES_LHS_TRUNC:%.*]] = trunc <2 x i16> [[ZEXT]] to <2 x i8>
; CHECK-NEXT:    [[RES1:%.*]] = srem <2 x i8> [[RES_LHS_TRUNC]], <i8 42, i8 42>
; CHECK-NEXT:    [[RES:%.*]] = sext <2 x i8> [[RES1]] to <2 x i16>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = sext <2 x i8> %a to <2 x i16>
  %res = srem <2 x i16> %zext, splat (i16 42)
  ret <2 x i16> %res
}

define <2 x i16> @ashr(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @ashr(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = lshr <2 x i16> [[ZEXT]], <i16 1, i16 1>
; CHECK-NEXT:    ret <2 x i16> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = ashr <2 x i16> %zext, splat (i16 1)
  ret <2 x i16> %res
}

define <2 x i32> @sext(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i32> @sext(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = zext nneg <2 x i16> [[ZEXT]] to <2 x i32>
; CHECK-NEXT:    ret <2 x i32> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = sext <2 x i16> %zext to <2 x i32>
  ret <2 x i32> %res
}

define <2 x float> @sitofp(<2 x i8> %a) {
; CHECK-LABEL: define <2 x float> @sitofp(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    [[RES:%.*]] = uitofp nneg <2 x i16> [[ZEXT]] to <2 x float>
; CHECK-NEXT:    ret <2 x float> [[RES]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = sitofp <2 x i16> %zext to <2 x float>
  ret <2 x float> %res
}

define <2 x i16> @and(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @and(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    ret <2 x i16> [[ZEXT]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = and <2 x i16> %zext, splat (i16 u0xff)
  ret <2 x i16> %res
}

define <2 x i16> @and_with_poison(<2 x i8> %a) {
; CHECK-LABEL: define <2 x i16> @and_with_poison(
; CHECK-SAME: <2 x i8> [[A:%.*]]) {
; CHECK-NEXT:    [[ZEXT:%.*]] = zext <2 x i8> [[A]] to <2 x i16>
; CHECK-NEXT:    ret <2 x i16> [[ZEXT]]
;
  %zext = zext <2 x i8> %a to <2 x i16>
  %res = and <2 x i16> %zext, <i16 u0xff, i16 poison>
  ret <2 x i16> %res
}



define <4 x i64> @issue_97674_getConstantOnEdge(i1 %cond) {
; CHECK-LABEL: define <4 x i64> @issue_97674_getConstantOnEdge(
; CHECK-SAME: i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[COND]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[FOLDS:%.*]] = add nuw nsw <4 x i64> zeroinitializer, <i64 1, i64 1, i64 1, i64 1>
; CHECK-NEXT:    br label %[[IF_END]]
; CHECK:       [[IF_END]]:
; CHECK-NEXT:    [[R:%.*]] = phi <4 x i64> [ <i64 1, i64 1, i64 1, i64 1>, %[[IF_THEN]] ], [ zeroinitializer, %[[ENTRY]] ]
; CHECK-NEXT:    ret <4 x i64> [[R]]
;
entry:
  br i1 %cond, label %if.then, label %if.end

if.then:
  %folds = add <4 x i64> zeroinitializer, <i64 1, i64 1, i64 1, i64 1>
  br label %if.end

if.end:
  %r = phi <4 x i64> [ %folds, %if.then ], [ zeroinitializer, %entry ]
  ret <4 x i64> %r
}

define <4 x i64> @issue_97674_getConstant() {
; CHECK-LABEL: define <4 x i64> @issue_97674_getConstant() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[FOLDS:%.*]] = add nuw nsw <4 x i64> zeroinitializer, zeroinitializer
; CHECK-NEXT:    ret <4 x i64> zeroinitializer
;
entry:
  %folds = add <4 x i64> zeroinitializer, zeroinitializer
  ret <4 x i64> %folds
}
