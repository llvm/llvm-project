; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -mcpu=pwr9 -mtriple=powerpc64le-unknown-linux-gnu -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s --check-prefix=P9
; RUN: opt < %s -mcpu=pwr9 -mtriple=powerpc64-ibm-aix -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s --check-prefix=P9BE
; RUN: opt < %s -mcpu=pwr9 -mtriple=powerpc-ibm-aix -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s --check-prefix=P932
; RUN: opt < %s -mcpu=pwr10 -mtriple=powerpc64le-unknown-linux-gnu -ppc-evl -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s --check-prefix=P10
; RUN: opt < %s -mcpu=pwr10 -mtriple=powerpc64-ibm-aix -ppc-evl -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s --check-prefix=P10BE
; RUN: opt < %s -mcpu=pwr10 -mtriple=powerpc-ibm-aix -ppc-evl -passes="print<cost-model>" 2>&1 -disable-output | FileCheck %s --check-prefix=P1032
; RUN: opt < %s -mcpu=future -mtriple=powerpc64le-unknown-linux-gnu -ppc-evl -passes="print<cost-model>" 2>&1 -disable-output  | FileCheck %s --check-prefix=FUTURE
; RUN: opt < %s -mcpu=future -mtriple=powerpc64-ibm-aix -ppc-evl -passes="print<cost-model>" 2>&1 -disable-output  | FileCheck %s --check-prefix=FUTUREBE
; RUN: opt < %s -mcpu=future -mtriple=powerpc-ibm-aix -ppc-evl -passes="print<cost-model>" 2>&1 -disable-output  | FileCheck %s --check-prefix=FUTURE32

define void @bar(ptr %base, <2 x i8> %val) {
; P9-LABEL: 'bar'
; P9-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; P9-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9-NEXT:  Cost Model: Found an estimated cost of 36 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; P9-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; P9-NEXT:  Cost Model: Found an estimated cost of 32 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; P9-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; P9-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 36 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 32 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 18 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; P9-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; P9-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P9-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; P9BE-LABEL: 'bar'
; P9BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 11 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; P9BE-NEXT:  Cost Model: Found an estimated cost of 36 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; P9BE-NEXT:  Cost Model: Found an estimated cost of 32 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; P9BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 11 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 36 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 32 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 18 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; P9BE-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P9BE-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; P932-LABEL: 'bar'
; P932-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; P932-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; P932-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; P932-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; P932-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; P932-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; P932-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; P932-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; P932-NEXT:  Cost Model: Found an estimated cost of 36 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; P932-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; P932-NEXT:  Cost Model: Found an estimated cost of 28 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; P932-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; P932-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 14 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 36 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 28 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; P932-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; P932-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P932-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; P10-LABEL: 'bar'
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; P10-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; P10-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; P10-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; P10-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; P10-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P10-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; P10BE-LABEL: 'bar'
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; P10BE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; P10BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; P10BE-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P10BE-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; P1032-LABEL: 'bar'
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; P1032-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; P1032-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; P1032-NEXT:  Cost Model: Found an estimated cost of 30 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; P1032-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; P1032-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; P1032-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 30 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; P1032-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; P1032-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; P1032-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; FUTURE-LABEL: 'bar'
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; FUTURE-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; FUTURE-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; FUTUREBE-LABEL: 'bar'
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 24 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 12 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; FUTUREBE-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; FUTUREBE-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; FUTURE32-LABEL: 'bar'
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i8> %val)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i16> zeroinitializer)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i32> zeroinitializer)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr align 1 %base, <2 x i1> splat (i1 true), <2 x i64> zeroinitializer)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr align 1 %base, <2 x i1> splat (i1 true))
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 30 for instruction: %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr align 1 %base, <3 x i1> splat (i1 true), <3 x i64> zeroinitializer)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr align 1 %base, <3 x i1> splat (i1 true))
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr align 1 %base, <4 x i1> splat (i1 true), <4 x i15> zeroinitializer)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr align 1 %base, <4 x i1> splat (i1 true))
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i16.p0(<2 x i16> %x8, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 8 for instruction: call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 30 for instruction: %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 15 for instruction: call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 16 for instruction: call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> splat (i1 true), <2 x i8> zeroinitializer)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 10 for instruction: call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> splat (i1 true))
; FUTURE32-NEXT:  Cost Model: Invalid cost for instruction: %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.p0.i64(ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Invalid cost for instruction: call void @llvm.experimental.vp.strided.store.v2i8.p0.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> splat (i1 true), i32 1)
; FUTURE32-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  %x1 = call <2 x i8> @llvm.masked.load.v2i8.p0(ptr %base, i32 1, <2 x i1> <i1 1, i1 1>, <2 x i8> %val)
  call void @llvm.masked.store.v2i8.p0(<2 x i8> %x1, ptr %base, i32 1, <2 x i1> <i1 1, i1 1>)
  %x2 = call <2 x i16> @llvm.masked.load.v2i16.p0(ptr %base, i32 1, <2 x i1> <i1 1, i1 1>, <2 x i16> <i16 0, i16 0>)
  call void @llvm.masked.store.v2i16.p0(<2 x i16> %x2, ptr %base, i32 1, <2 x i1> <i1 1, i1 1>)
  %x3 = call <2 x i32> @llvm.masked.load.v2i32.p0(ptr %base, i32 1, <2 x i1> <i1 1, i1 1>, <2 x i32> <i32 0, i32 0>)
  call void @llvm.masked.store.v2i32.p0(<2 x i32> %x3, ptr %base, i32 1, <2 x i1> <i1 1, i1 1>)
  %x4 = call <2 x i64> @llvm.masked.load.v2i64.p0(ptr %base, i32 1, <2 x i1> <i1 1, i1 1>, <2 x i64> <i64 0, i64 0>)
  call void @llvm.masked.store.v2i64.p0(<2 x i64> %x4, ptr %base, i32 1, <2 x i1> <i1 1, i1 1>)
  %x5 = call <3 x i64> @llvm.masked.load.v3i64.p0(ptr %base, i32 1, <3 x i1> <i1 1, i1 1, i1 1>, <3 x i64> <i64 0, i64 0, i64 0>)
  call void @llvm.masked.store.v3i64.p0(<3 x i64> %x5, ptr %base, i32 1, <3 x i1> <i1 1, i1 1, i1 1>)
  %x6 = call <4 x i15> @llvm.masked.load.v4i15.p0(ptr %base, i32 1, <4 x i1> <i1 1, i1 1, i1 1, i1 1>, <4 x i15> <i15 0, i15 0, i15 0, i15 0>)
  call void @llvm.masked.store.v4i15.p0(<4 x i15> %x6, ptr %base, i32 1, <4 x i1> <i1 1, i1 1, i1 1, i1 1>)
  %x7 = call <2 x i8> @llvm.vp.load.v2i8.p0(ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  call void @llvm.vp.store.v2i8.p0(<2 x i8> %x7, ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  %x8 = call <2 x i16> @llvm.vp.load.v2i16.p0(ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  call void @llvm.vp.store.v2i6.p0(<2 x i16> %x8, ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  %x9 = call <2 x i32> @llvm.vp.load.v2i32.p0(ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  call void @llvm.vp.store.v2i32.p0(<2 x i32> %x9, ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  %x10 = call <2 x i64> @llvm.vp.load.v2i64.p0(ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  call void @llvm.vp.store.v2i64.p0(<2 x i64> %x10, ptr %base, <2 x i1> <i1 1, i1 1>, i32 1)
  %x11 = call <3 x i64> @llvm.vp.load.v3i64.p0(ptr %base, <3 x i1> <i1 1, i1 1, i1 1>, i32 1)
  call void @llvm.vp.store.v3i64.p0(<3 x i64> %x11, ptr %base, <3 x i1> <i1 1, i1 1, i1 1>, i32 1)
  %x12 = call <4 x i15> @llvm.vp.load.v4i15.p0(ptr %base, <4 x i1> <i1 1, i1 1, i1 1, i1 1>, i32 1)
  call void @llvm.vp.store.v4i15.p0(<4 x i15> %x12, ptr %base, <4 x i1> <i1 1, i1 1, i1 1, i1 1>, i32 1)
  %x13 = call <2 x i8> @llvm.masked.expandload.v2i8(ptr %base, <2 x i1> <i1 1, i1 1>, <2 x i8> <i8 0, i8 0>)
  call void @llvm.masked.compressstore.v2i8(<2 x i8> %x13, ptr %base, <2 x i1> <i1 1, i1 1>)
  %x14 = call <2 x i8> @llvm.experimental.vp.strided.load.v2i8.i64(ptr %base, i64 1, <2 x i1> <i1 1, i1 1>, i32 1)
  call void @llvm.experimental.vp.strided.store.v2i8.i64(<2 x i8> %x14, ptr %base, i64 1, <2 x i1> <i1 1, i1 1>, i32 1)
  ret void
}
