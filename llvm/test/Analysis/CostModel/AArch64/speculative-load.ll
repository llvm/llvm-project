; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -passes="print<cost-model>" 2>&1 -disable-output -mtriple=aarch64 < %s | FileCheck %s --check-prefixes=COMMON,NEON
; RUN: opt -passes="print<cost-model>" 2>&1 -disable-output -mtriple=aarch64 -mattr=+sve < %s | FileCheck %s --check-prefixes=COMMON,SVE

define void @speculative_load_cost_fixed(ptr %p) {
  ; Scalar types - all valid (<= 16 bytes)
; COMMON-LABEL: 'speculative_load_cost_fixed'
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = call i8 @llvm.speculative.load.i8.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = call i16 @llvm.speculative.load.i16.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = call i32 @llvm.speculative.load.i32.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = call i64 @llvm.speculative.load.i64.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: %5 = call i128 @llvm.speculative.load.i128.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = call <2 x i32> @llvm.speculative.load.v2i32.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %7 = call <4 x i32> @llvm.speculative.load.v4i32.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %8 = call <2 x i64> @llvm.speculative.load.v2i64.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %9 = call <4 x float> @llvm.speculative.load.v4f32.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %10 = call <2 x double> @llvm.speculative.load.v2f64.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %11 = call <8 x i8> @llvm.speculative.load.v8i8.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %12 = call <16 x i8> @llvm.speculative.load.v16i8.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %13 = call <4 x i16> @llvm.speculative.load.v4i16.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %14 = call <8 x i16> @llvm.speculative.load.v8i16.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Invalid cost for instruction: %15 = call <8 x i32> @llvm.speculative.load.v8i32.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Invalid cost for instruction: %16 = call <4 x i64> @llvm.speculative.load.v4i64.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Invalid cost for instruction: %17 = call <32 x i8> @llvm.speculative.load.v32i8.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Invalid cost for instruction: %18 = call <16 x i16> @llvm.speculative.load.v16i16.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Invalid cost for instruction: %19 = call <8 x float> @llvm.speculative.load.v8f32.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Invalid cost for instruction: %20 = call <4 x double> @llvm.speculative.load.v4f64.p0(ptr %p)
; COMMON-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  call i8 @llvm.speculative.load.i8.p0(ptr %p)
  call i16 @llvm.speculative.load.i16.p0(ptr %p)
  call i32 @llvm.speculative.load.i32.p0(ptr %p)
  call i64 @llvm.speculative.load.i64.p0(ptr %p)
  call i128 @llvm.speculative.load.i128.p0(ptr %p)

  ; Vector types <= 16 bytes - valid
  call <2 x i32> @llvm.speculative.load.v2i32.p0(ptr %p)
  call <4 x i32> @llvm.speculative.load.v4i32.p0(ptr %p)
  call <2 x i64> @llvm.speculative.load.v2i64.p0(ptr %p)
  call <4 x float> @llvm.speculative.load.v4f32.p0(ptr %p)
  call <2 x double> @llvm.speculative.load.v2f64.p0(ptr %p)
  call <8 x i8> @llvm.speculative.load.v8i8.p0(ptr %p)
  call <16 x i8> @llvm.speculative.load.v16i8.p0(ptr %p)
  call <4 x i16> @llvm.speculative.load.v4i16.p0(ptr %p)
  call <8 x i16> @llvm.speculative.load.v8i16.p0(ptr %p)

  ; Vector types > 16 bytes - invalid
  call <8 x i32> @llvm.speculative.load.v8i32.p0(ptr %p)
  call <4 x i64> @llvm.speculative.load.v4i64.p0(ptr %p)
  call <32 x i8> @llvm.speculative.load.v32i8.p0(ptr %p)
  call <16 x i16> @llvm.speculative.load.v16i16.p0(ptr %p)
  call <8 x float> @llvm.speculative.load.v8f32.p0(ptr %p)
  call <4 x double> @llvm.speculative.load.v4f64.p0(ptr %p)
  ret void
}

define void @speculative_load_cost_scalable(ptr %p) {
; NEON-LABEL: 'speculative_load_cost_scalable'
; NEON-NEXT:  Cost Model: Invalid cost for instruction: %1 = call <vscale x 2 x i64> @llvm.speculative.load.nxv2i64.p0(ptr %p)
; NEON-NEXT:  Cost Model: Invalid cost for instruction: %2 = call <vscale x 4 x i32> @llvm.speculative.load.nxv4i32.p0(ptr %p)
; NEON-NEXT:  Cost Model: Invalid cost for instruction: %3 = call <vscale x 8 x i16> @llvm.speculative.load.nxv8i16.p0(ptr %p)
; NEON-NEXT:  Cost Model: Invalid cost for instruction: %4 = call <vscale x 16 x i8> @llvm.speculative.load.nxv16i8.p0(ptr %p)
; NEON-NEXT:  Cost Model: Invalid cost for instruction: %5 = call <vscale x 2 x double> @llvm.speculative.load.nxv2f64.p0(ptr %p)
; NEON-NEXT:  Cost Model: Invalid cost for instruction: %6 = call <vscale x 4 x float> @llvm.speculative.load.nxv4f32.p0(ptr %p)
; NEON-NEXT:  Cost Model: Invalid cost for instruction: %7 = call <vscale x 8 x float> @llvm.speculative.load.nxv8f32.p0(ptr %p)
; NEON-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; SVE-LABEL: 'speculative_load_cost_scalable'
; SVE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %1 = call <vscale x 2 x i64> @llvm.speculative.load.nxv2i64.p0(ptr %p)
; SVE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %2 = call <vscale x 4 x i32> @llvm.speculative.load.nxv4i32.p0(ptr %p)
; SVE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %3 = call <vscale x 8 x i16> @llvm.speculative.load.nxv8i16.p0(ptr %p)
; SVE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %4 = call <vscale x 16 x i8> @llvm.speculative.load.nxv16i8.p0(ptr %p)
; SVE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %5 = call <vscale x 2 x double> @llvm.speculative.load.nxv2f64.p0(ptr %p)
; SVE-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %6 = call <vscale x 4 x float> @llvm.speculative.load.nxv4f32.p0(ptr %p)
; SVE-NEXT:  Cost Model: Invalid cost for instruction: %7 = call <vscale x 8 x float> @llvm.speculative.load.nxv8f32.p0(ptr %p)
; SVE-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  ; Scalable vector types - invalid without SVE, valid with SVE if <= 16 bytes
  call <vscale x 2 x i64> @llvm.speculative.load.nxv2i64.p0(ptr %p)
  call <vscale x 4 x i32> @llvm.speculative.load.nxv4i32.p0(ptr %p)
  call <vscale x 8 x i16> @llvm.speculative.load.nxv8i16.p0(ptr %p)
  call <vscale x 16 x i8> @llvm.speculative.load.nxv16i8.p0(ptr %p)
  call <vscale x 2 x double> @llvm.speculative.load.nxv2f64.p0(ptr %p)
  call <vscale x 4 x float> @llvm.speculative.load.nxv4f32.p0(ptr %p)
  call <vscale x 8 x float> @llvm.speculative.load.nxv8f32.p0(ptr %p)

  ret void
}
