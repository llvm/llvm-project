; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -mtriple=armv8.1m.main -mattr=+mve.fp -passes="print<cost-model>" -cost-kind=all 2>&1 -disable-output   < %s | FileCheck %s

target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"

; Test a cross-section of intrinsics for various cost-kinds.
; Other test files may check for accuracy of a particular intrinsic
; across subtargets or types. This is just a basic correctness check using an
; ARM target and a legal scalar type (i32/float) and/or an
; illegal vector type (16 x i32/float).

declare i32 @llvm.smax.i32(i32, i32)
declare <16 x i32> @llvm.smax.v16i32(<16 x i32>, <16 x i32>)

declare float @llvm.fmuladd.f32(float, float, float)
declare <16 x float> @llvm.fmuladd.v16f32(<16 x float>, <16 x float>, <16 x float>)

declare float @llvm.log2.f32(float)
declare <16 x float> @llvm.log2.v16f32(<16 x float>)

declare float @llvm.experimental.constrained.fadd.f32(float, float, metadata, metadata)
declare <16 x float> @llvm.experimental.constrained.fadd.v16f32(<16 x float>, <16 x float>, metadata, metadata)

declare float @llvm.maximum.f32(float, float)
declare <16 x float> @llvm.maximum.v16f32(<16 x float>, <16 x float>)

declare i32 @llvm.cttz.i32(i32, i1)
declare <16 x i32> @llvm.cttz.v16i32(<16 x i32>, i1)

declare i32 @llvm.ctlz.i32(i32, i1)
declare <16 x i32> @llvm.ctlz.v16i32(<16 x i32>, i1)

declare i32 @llvm.fshl.i32(i32, i32, i32)
declare <16 x i32> @llvm.fshl.v16i32(<16 x i32>, <16 x i32>, <16 x i32>)

declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr>, i32, <16 x i1>, <16 x float>)
declare void @llvm.masked.scatter.v16f32.v16p0(<16 x float>, <16 x ptr>, i32, <16 x i1>)
declare float @llvm.vector.reduce.fmax.v16f32(<16 x float>)

declare void @llvm.memcpy.p0.p0.i32(ptr, ptr, i32, i1)

declare i32 @llvm.ssa.copy.i32(i32)
declare float @llvm.ssa.copy.f32(float)
declare ptr @llvm.ssa.copy.p0(ptr)

define void @smax(i32 %a, i32 %b, <16 x i32> %va, <16 x i32> %vb) {
; CHECK-LABEL: 'smax'
; CHECK-NEXT:  Cost Model: Found costs of RThru:2 CodeSize:3 Lat:2 SizeLat:2 for: %s = call i32 @llvm.smax.i32(i32 %a, i32 %b)
; CHECK-NEXT:  Cost Model: Found costs of RThru:8 CodeSize:4 Lat:8 SizeLat:8 for: %v = call <16 x i32> @llvm.smax.v16i32(<16 x i32> %va, <16 x i32> %vb)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call i32 @llvm.smax.i32(i32 %a, i32 %b)
  %v = call <16 x i32> @llvm.smax.v16i32(<16 x i32> %va, <16 x i32> %vb)
  ret void
}

define void @fmuladd(float %a, float %b, float %c, <16 x float> %va, <16 x float> %vb, <16 x float> %vc) {
; CHECK-LABEL: 'fmuladd'
; CHECK-NEXT:  Cost Model: Found costs of 1 for: %s = call float @llvm.fmuladd.f32(float %a, float %b, float %c)
; CHECK-NEXT:  Cost Model: Found costs of 8 for: %v = call <16 x float> @llvm.fmuladd.v16f32(<16 x float> %va, <16 x float> %vb, <16 x float> %vc)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call float @llvm.fmuladd.f32(float %a, float %b, float %c)
  %v = call <16 x float> @llvm.fmuladd.v16f32(<16 x float> %va, <16 x float> %vb, <16 x float> %vc)
  ret void
}

define void @log2(float %a, <16 x float> %va) {
; CHECK-LABEL: 'log2'
; CHECK-NEXT:  Cost Model: Found costs of RThru:10 CodeSize:1 Lat:10 SizeLat:10 for: %s = call float @llvm.log2.f32(float %a)
; CHECK-NEXT:  Cost Model: Found costs of RThru:192 CodeSize:48 Lat:192 SizeLat:192 for: %v = call <16 x float> @llvm.log2.v16f32(<16 x float> %va)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call float @llvm.log2.f32(float %a)
  %v = call <16 x float> @llvm.log2.v16f32(<16 x float> %va)
  ret void
}

define void @constrained_fadd(float %a, <16 x float> %va) strictfp {
; CHECK-LABEL: 'constrained_fadd'
; CHECK-NEXT:  Cost Model: Found costs of 1 for: %s = call float @llvm.experimental.constrained.fadd.f32(float %a, float %a, metadata !"round.dynamic", metadata !"fpexcept.ignore")
; CHECK-NEXT:  Cost Model: Found costs of 48 for: %t = call <16 x float> @llvm.experimental.constrained.fadd.v16f32(<16 x float> %va, <16 x float> %va, metadata !"round.dynamic", metadata !"fpexcept.ignore")
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call float @llvm.experimental.constrained.fadd.f32(float %a, float %a, metadata !"round.dynamic", metadata !"fpexcept.ignore")
  %t = call <16 x float> @llvm.experimental.constrained.fadd.v16f32(<16 x float> %va, <16 x float> %va, metadata !"round.dynamic", metadata !"fpexcept.ignore")
  ret void
}

define void @fmaximum(float %a, float %b, <16 x float> %va, <16 x float> %vb) {
; CHECK-LABEL: 'fmaximum'
; CHECK-NEXT:  Cost Model: Found costs of RThru:10 CodeSize:1 Lat:10 SizeLat:10 for: %s = call float @llvm.maximum.f32(float %a, float %b)
; CHECK-NEXT:  Cost Model: Found costs of RThru:208 CodeSize:64 Lat:208 SizeLat:208 for: %v = call <16 x float> @llvm.maximum.v16f32(<16 x float> %va, <16 x float> %vb)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call float @llvm.maximum.f32(float %a, float %b)
  %v = call <16 x float> @llvm.maximum.v16f32(<16 x float> %va, <16 x float> %vb)
  ret void
}

define void @cttz(i32 %a, <16 x i32> %va) {
; CHECK-LABEL: 'cttz'
; CHECK-NEXT:  Cost Model: Found costs of 1 for: %s = call i32 @llvm.cttz.i32(i32 %a, i1 false)
; CHECK-NEXT:  Cost Model: Found costs of 8 for: %v = call <16 x i32> @llvm.cttz.v16i32(<16 x i32> %va, i1 false)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call i32 @llvm.cttz.i32(i32 %a, i1 false)
  %v = call <16 x i32> @llvm.cttz.v16i32(<16 x i32> %va, i1 false)
  ret void
}

define void @ctlz(i32 %a, <16 x i32> %va) {
; CHECK-LABEL: 'ctlz'
; CHECK-NEXT:  Cost Model: Found costs of 1 for: %s = call i32 @llvm.ctlz.i32(i32 %a, i1 true)
; CHECK-NEXT:  Cost Model: Found costs of 8 for: %v = call <16 x i32> @llvm.ctlz.v16i32(<16 x i32> %va, i1 true)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call i32 @llvm.ctlz.i32(i32 %a, i1 true)
  %v = call <16 x i32> @llvm.ctlz.v16i32(<16 x i32> %va, i1 true)
  ret void
}

define void @fshl(i32 %a, i32 %b, i32 %c, <16 x i32> %va, <16 x i32> %vb, <16 x i32> %vc) {
; CHECK-LABEL: 'fshl'
; CHECK-NEXT:  Cost Model: Found costs of RThru:7 CodeSize:8 Lat:7 SizeLat:7 for: %s = call i32 @llvm.fshl.i32(i32 %a, i32 %b, i32 %c)
; CHECK-NEXT:  Cost Model: Found costs of RThru:120 CodeSize:92 Lat:120 SizeLat:120 for: %v = call <16 x i32> @llvm.fshl.v16i32(<16 x i32> %va, <16 x i32> %vb, <16 x i32> %vc)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %s = call i32 @llvm.fshl.i32(i32 %a, i32 %b, i32 %c)
  %v = call <16 x i32> @llvm.fshl.v16i32(<16 x i32> %va, <16 x i32> %vb, <16 x i32> %vc)
  ret void
}

define void @maskedgather(<16 x ptr> %va, <16 x i1> %vb, <16 x float> %vc) {
; CHECK-LABEL: 'maskedgather'
; CHECK-NEXT:  Cost Model: Found costs of 176 for: %v = call <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> align 1 %va, <16 x i1> %vb, <16 x float> %vc)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %v = call <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> %va, i32 1, <16 x i1> %vb, <16 x float> %vc)
  ret void
}

define void @maskedscatter(<16 x float> %va, <16 x ptr> %vb, <16 x i1> %vc) {
; CHECK-LABEL: 'maskedscatter'
; CHECK-NEXT:  Cost Model: Found costs of 176 for: call void @llvm.masked.scatter.v16f32.v16p0(<16 x float> %va, <16 x ptr> align 1 %vb, <16 x i1> %vc)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  call void @llvm.masked.scatter.v16f32.v16p0(<16 x float> %va, <16 x ptr> %vb, i32 1, <16 x i1> %vc)
  ret void
}

define void @reduce_fmax(<16 x float> %va) {
; CHECK-LABEL: 'reduce_fmax'
; CHECK-NEXT:  Cost Model: Found costs of RThru:9 CodeSize:6 Lat:9 SizeLat:9 for: %v = call float @llvm.vector.reduce.fmax.v16f32(<16 x float> %va)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %v = call float @llvm.vector.reduce.fmax.v16f32(<16 x float> %va)
  ret void
}

define void @memcpy(ptr %a, ptr %b, i32 %c) {
; CHECK-LABEL: 'memcpy'
; CHECK-NEXT:  Cost Model: Found costs of 4 for: call void @llvm.memcpy.p0.p0.i32(ptr align 1 %a, ptr align 1 %b, i32 32, i1 false)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  call void @llvm.memcpy.p0.p0.i32(ptr align 1 %a, ptr align 1 %b, i32 32, i1 false)
  ret void
}

define void @ssa_copy() {
; CHECK-LABEL: 'ssa_copy'
; CHECK-NEXT:  Cost Model: Found costs of 0 for: %i = call i32 @llvm.ssa.copy.i32(i32 undef)
; CHECK-NEXT:  Cost Model: Found costs of 0 for: %f = call float @llvm.ssa.copy.f32(float undef)
; CHECK-NEXT:  Cost Model: Found costs of 0 for: %p = call ptr @llvm.ssa.copy.p0(ptr undef)
; CHECK-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret void
;
  %i = call i32 @llvm.ssa.copy.i32(i32 undef)
  %f = call float @llvm.ssa.copy.f32(float undef)
  %p = call ptr @llvm.ssa.copy.p0(ptr undef)
  ret void
}
