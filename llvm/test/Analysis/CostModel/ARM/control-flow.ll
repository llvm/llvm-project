; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -passes="print<cost-model>" -cost-kind=all 2>&1 -disable-output  -mtriple=thumbv8m.base   | FileCheck %s --check-prefix=CHECK-T1
; RUN: opt < %s -passes="print<cost-model>" -cost-kind=all 2>&1 -disable-output  -mtriple=thumbv8m.main   | FileCheck %s --check-prefix=CHECK-V8M
; RUN: opt < %s -passes="print<cost-model>" -cost-kind=all 2>&1 -disable-output  -mtriple=thumbv8.1m.main -mattr=+mve  | FileCheck %s --check-prefix=CHECK-MVE
; RUN: opt < %s -passes="print<cost-model>" -cost-kind=all 2>&1 -disable-output  -mtriple=armv8a -mattr=+neon  | FileCheck %s --check-prefix=CHECK-NEON

target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"

define i32 @simple_loop_cost(i32 %N) {
; CHECK-T1-LABEL: 'simple_loop_cost'
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br i1 %zero, label %exit, label %preheader
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br label %loop
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br i1 %cmp, label %loop, label %exit
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: ret i32 %res
;
; CHECK-V8M-LABEL: 'simple_loop_cost'
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br i1 %zero, label %exit, label %preheader
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br label %loop
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br i1 %cmp, label %loop, label %exit
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: ret i32 %res
;
; CHECK-MVE-LABEL: 'simple_loop_cost'
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %zero, label %exit, label %preheader
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br label %loop
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %cmp, label %loop, label %exit
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret i32 %res
;
; CHECK-NEON-LABEL: 'simple_loop_cost'
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %zero, label %exit, label %preheader
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br label %loop
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %cmp, label %loop, label %exit
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret i32 %res
;
entry:
  %zero = icmp eq i32 %N, 0
  br i1 %zero, label %exit, label %preheader

preheader:
  br label %loop

loop:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
  %iv.next = add nuw i32 %iv, 1
  %cmp = icmp ne i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  ret i32 %res
}

define i32 @simple_mul_loop(ptr %A, ptr %B, i32 %N) {
; CHECK-T1-LABEL: 'simple_mul_loop'
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br i1 %zero, label %exit, label %preheader
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br label %loop
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %addr.a = getelementptr i32, ptr %A, i32 %iv
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i32, ptr %addr.a, align 4
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %load, %load
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %addr.b = getelementptr i32, ptr %B, i32 %iv
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br i1 %cmp, label %loop, label %exit
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: ret i32 %res
;
; CHECK-V8M-LABEL: 'simple_mul_loop'
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br i1 %zero, label %exit, label %preheader
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br label %loop
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of 0 for: %addr.a = getelementptr i32, ptr %A, i32 %iv
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i32, ptr %addr.a, align 4
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %load, %load
; CHECK-V8M-NEXT:  Cost Model: Found costs of 0 for: %addr.b = getelementptr i32, ptr %B, i32 %iv
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br i1 %cmp, label %loop, label %exit
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: ret i32 %res
;
; CHECK-MVE-LABEL: 'simple_mul_loop'
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %zero, label %exit, label %preheader
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br label %loop
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %addr.a = getelementptr i32, ptr %A, i32 %iv
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i32, ptr %addr.a, align 4
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %load, %load
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %addr.b = getelementptr i32, ptr %B, i32 %iv
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %cmp, label %loop, label %exit
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret i32 %res
;
; CHECK-NEON-LABEL: 'simple_mul_loop'
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %zero, label %exit, label %preheader
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br label %loop
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %addr.a = getelementptr i32, ptr %A, i32 %iv
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i32, ptr %addr.a, align 4
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %load, %load
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %addr.b = getelementptr i32, ptr %B, i32 %iv
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %cmp, label %loop, label %exit
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret i32 %res
;
entry:
  %zero = icmp eq i32 %N, 0
  br i1 %zero, label %exit, label %preheader

preheader:
  br label %loop

loop:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
  %addr.a = getelementptr i32, ptr %A, i32 %iv
  %load = load i32, ptr %addr.a
  %mul = mul i32 %load, %load
  %addr.b = getelementptr i32, ptr %B, i32 %iv
  store i32 %mul, ptr %addr.b
  %iv.next = add nuw i32 %iv, 1
  %cmp = icmp ne i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  ret i32 %res
}

define i32 @simple_mul_ext_lsr_loop(ptr %A, ptr %B, i32 %N) {
; CHECK-T1-LABEL: 'simple_mul_ext_lsr_loop'
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br i1 %zero, label %exit, label %preheader
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br label %loop
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %addr.a = phi ptr [ %A, %preheader ], [ %addr.a, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %addr.b = phi ptr [ %B, %preheader ], [ %addr.b, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i16, ptr %addr.a, align 2
; CHECK-T1-NEXT:  Cost Model: Found costs of 0 for: %sext = sext i16 %load to i32
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %sext, 7
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-T1-NEXT:  Cost Model: Found costs of 0 for: %addr.a.next = getelementptr i16, ptr %addr.a, i32 1
; CHECK-T1-NEXT:  Cost Model: Found costs of 0 for: %addr.b.next = getelementptr i32, ptr %addr.b, i32 1
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: br i1 %cmp, label %loop, label %exit
; CHECK-T1-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-T1-NEXT:  Cost Model: Found costs of 1 for: ret i32 %res
;
; CHECK-V8M-LABEL: 'simple_mul_ext_lsr_loop'
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br i1 %zero, label %exit, label %preheader
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br label %loop
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %addr.a = phi ptr [ %A, %preheader ], [ %addr.a, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %addr.b = phi ptr [ %B, %preheader ], [ %addr.b, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i16, ptr %addr.a, align 2
; CHECK-V8M-NEXT:  Cost Model: Found costs of 0 for: %sext = sext i16 %load to i32
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %sext, 7
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-V8M-NEXT:  Cost Model: Found costs of 0 for: %addr.a.next = getelementptr i16, ptr %addr.a, i32 1
; CHECK-V8M-NEXT:  Cost Model: Found costs of 0 for: %addr.b.next = getelementptr i32, ptr %addr.b, i32 1
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: br i1 %cmp, label %loop, label %exit
; CHECK-V8M-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:0 Lat:0 SizeLat:0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-V8M-NEXT:  Cost Model: Found costs of 1 for: ret i32 %res
;
; CHECK-MVE-LABEL: 'simple_mul_ext_lsr_loop'
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %zero, label %exit, label %preheader
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br label %loop
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %addr.a = phi ptr [ %A, %preheader ], [ %addr.a, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %addr.b = phi ptr [ %B, %preheader ], [ %addr.b, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i16, ptr %addr.a, align 2
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %sext = sext i16 %load to i32
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %sext, 7
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %addr.a.next = getelementptr i16, ptr %addr.a, i32 1
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %addr.b.next = getelementptr i32, ptr %addr.b, i32 1
; CHECK-MVE-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %cmp, label %loop, label %exit
; CHECK-MVE-NEXT:  Cost Model: Found costs of 0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-MVE-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret i32 %res
;
; CHECK-NEON-LABEL: 'simple_mul_ext_lsr_loop'
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %zero = icmp eq i32 %N, 0
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %zero, label %exit, label %preheader
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br label %loop
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %addr.a = phi ptr [ %A, %preheader ], [ %addr.a, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %addr.b = phi ptr [ %B, %preheader ], [ %addr.b, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:1 CodeSize:1 Lat:4 SizeLat:1 for: %load = load i16, ptr %addr.a, align 2
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %sext = sext i16 %load to i32
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %mul = mul i32 %sext, 7
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: store i32 %mul, ptr %addr.b, align 4
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %iv.next = add nuw i32 %iv, 1
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %addr.a.next = getelementptr i16, ptr %addr.a, i32 1
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %addr.b.next = getelementptr i32, ptr %addr.b, i32 1
; CHECK-NEON-NEXT:  Cost Model: Found costs of 1 for: %cmp = icmp ne i32 %iv.next, %N
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: br i1 %cmp, label %loop, label %exit
; CHECK-NEON-NEXT:  Cost Model: Found costs of 0 for: %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEON-NEXT:  Cost Model: Found costs of RThru:0 CodeSize:1 Lat:1 SizeLat:1 for: ret i32 %res
;
entry:
  %zero = icmp eq i32 %N, 0
  br i1 %zero, label %exit, label %preheader

preheader:
  br label %loop

loop:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %loop ]
  %addr.a = phi ptr [ %A, %preheader ], [ %addr.a, %loop ]
  %addr.b = phi ptr [ %B, %preheader ], [ %addr.b, %loop ]
  %load = load i16, ptr %addr.a
  %sext = sext i16 %load to i32
  %mul = mul i32 %sext, 7
  store i32 %mul, ptr %addr.b
  %iv.next = add nuw i32 %iv, 1
  %addr.a.next = getelementptr i16, ptr %addr.a, i32 1
  %addr.b.next = getelementptr i32, ptr %addr.b, i32 1
  %cmp = icmp ne i32 %iv.next, %N
  br i1 %cmp, label %loop, label %exit

exit:
  %res = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  ret i32 %res
}
