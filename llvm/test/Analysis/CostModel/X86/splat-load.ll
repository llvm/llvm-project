; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -mtriple=x86_64-unknown-linux-gnu -passes="print<cost-model>" 2>&1 -disable-output -mattr=+sse2 | FileCheck %s -check-prefixes=SSE2
; RUN: opt < %s -mtriple=x86_64-unknown-linux-gnu -passes="print<cost-model>" 2>&1 -disable-output -mattr=+sse3 | FileCheck %s -check-prefixes=SSE3

; This test checks that the cost of a splat-load shuffle is correctly detected
; as 0, because the combined load + broadcast is lowered to a `movddup` instr.
;
; TODO: AVX `vbroadcast*` seems to support more types than the
;       2xdouble type of `movddup`:
;       - `vbroadcastss` supports 4xfloat, 8xfloat
;       - `vbroadcastsd` supports 4xdouble

; NOTE: The code in this test is a hack. Since TTI cannot currently detect a
; proper broadcast pattern from a scalar load (like the one that follows),
; we use a vector load as the shuffle's operand to trigger the pattern.
;
;  %load = load double, double *%ptr
;  %insert = insertelement <2 x double> poison, double %load, i32 0
;  %bcast = shufflevector <2 x double> %insert, <2 x double> poison, <2 x i32> zeroinitializer

define void @splat_load_2xdouble(<2 x double> *%ptr) {
; SSE2-LABEL: 'splat_load_2xdouble'
; SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %load = load <2 x double>, <2 x double>* %ptr, align 16
; SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %splat_load = shufflevector <2 x double> %load, <2 x double> poison, <2 x i32> zeroinitializer
; SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; SSE3-LABEL: 'splat_load_2xdouble'
; SSE3-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %load = load <2 x double>, <2 x double>* %ptr, align 16
; SSE3-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %splat_load = shufflevector <2 x double> %load, <2 x double> poison, <2 x i32> zeroinitializer
; SSE3-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  %load = load <2 x double>, <2 x double> *%ptr
  %splat_load = shufflevector <2 x double> %load, <2 x double> poison, <2 x i32> zeroinitializer
  ret void
}

define void @splat_load_2xfloat(<2 x float> *%ptr) {
; SSE2-LABEL: 'splat_load_2xfloat'
; SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %load = load <2 x float>, <2 x float>* %ptr, align 8
; SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %splat_load = shufflevector <2 x float> %load, <2 x float> poison, <2 x i32> zeroinitializer
; SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
; SSE3-LABEL: 'splat_load_2xfloat'
; SSE3-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %load = load <2 x float>, <2 x float>* %ptr, align 8
; SSE3-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %splat_load = shufflevector <2 x float> %load, <2 x float> poison, <2 x i32> zeroinitializer
; SSE3-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
;
  %load = load <2 x float>, <2 x float> *%ptr
  %splat_load = shufflevector <2 x float> %load, <2 x float> poison, <2 x i32> zeroinitializer
  ret void
}
