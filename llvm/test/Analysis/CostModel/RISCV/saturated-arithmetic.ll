; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -passes="print<cost-model>" 2>&1 -disable-output < %s \
; RUN:   -mtriple=riscv64 -mattr=+v | FileCheck %s

; Test that saturated arithmetic intrinsics map to correct RVV opcodes
; This test verifies the fix for ssub_sat incorrectly using VSSUBU_VV 
; instead of VSSUB_VV (signed vs unsigned saturated subtract)

define void @test_saturated_arithmetic(<4 x i32> %a, <4 x i32> %b) {
; CHECK-LABEL: 'test_saturated_arithmetic'

; Test signed saturated addition (should use VSADD_VV)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %sadd_sat = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
  %sadd_sat = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %a, <4 x i32> %b)

; Test signed saturated subtraction (should use VSSUB_VV, not VSSUBU_VV)
; This is the main bug being fixed
; CHECK-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %ssub_sat = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
  %ssub_sat = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %a, <4 x i32> %b)

; Test unsigned saturated addition (should use VSADDU_VV)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %uadd_sat = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
  %uadd_sat = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %a, <4 x i32> %b)

; Test unsigned saturated subtraction (should use VSSUBU_VV)
; CHECK-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: %usub_sat = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
  %usub_sat = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %a, <4 x i32> %b)

; CHECK-NEXT:  Cost Model: Found an estimated cost of 0 for instruction: ret void
  ret void
}

; Declare intrinsic functions
declare <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32>, <4 x i32>)
declare <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32>, <4 x i32>)
declare <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32>, <4 x i32>)
declare <4 x i32> @llvm.usub.sat.v4i32(<4 x i32>, <4 x i32>)
