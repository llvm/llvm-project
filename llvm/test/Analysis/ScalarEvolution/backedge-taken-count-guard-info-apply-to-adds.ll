; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes='print<scalar-evolution>' -scalar-evolution-classify-expressions=0 -disable-output %s 2>&1 | FileCheck %s

define void @ptrtoint_based_trip_count_known_via_guards_applied_to_add_subexpr(ptr %start, ptr %end) {
; CHECK-LABEL: 'ptrtoint_based_trip_count_known_via_guards_applied_to_add_subexpr'
; CHECK-NEXT:  Determining loop execution counts for: @ptrtoint_based_trip_count_known_via_guards_applied_to_add_subexpr
; CHECK-NEXT:  Loop %loop: backedge-taken count is i64 0
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 0
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is i64 0
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;
entry:
  %end.i = ptrtoint ptr %end to i64
  %start.i = ptrtoint ptr %start to i64
  %sub = sub i64 %end.i, %start.i
  %pre.1 = icmp eq i64 %sub, 4
  call void @llvm.assume(i1 %pre.1)
  br label %loop

loop:
  %iv = phi ptr [ %start, %entry ], [ %iv.next, %loop ]
  store i32 0, ptr %iv
  %iv.next = getelementptr inbounds nuw i8, ptr %iv, i64 4
  %ec = icmp eq ptr %iv.next, %end
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

declare void @clobber()

define void @test_add_sub_1_guard(ptr %src, i32 %n) {
; CHECK-LABEL: 'test_add_sub_1_guard'
; CHECK-NEXT:  Determining loop execution counts for: @test_add_sub_1_guard
; CHECK-NEXT:  Loop %loop: backedge-taken count is (zext i32 (-1 + (%n /u 2))<nsw> to i64)
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 4294967295
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is (zext i32 (-1 + (%n /u 2))<nsw> to i64)
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;
entry:
  %shr = lshr i32 %n, 1
  %sub.1 = add i32 %shr, -1
  %sub.ext = zext i32 %sub.1 to i64
  %pre = icmp eq i32 %shr, 1
  %end = getelementptr i8, ptr %src, i64 %sub.ext
  br i1 %pre, label %loop, label %exit

loop:
  %iv = phi ptr [ %src, %entry ], [ %iv.next, %loop ]
  call void @clobber()
  %iv.next = getelementptr i8, ptr %iv, i64 1
  %ec = icmp eq ptr %iv, %end
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

declare void @use(ptr)

define i32 @test_3_op_add(i32 %x, i32 %y, ptr %A) {
; CHECK-LABEL: 'test_3_op_add'
; CHECK-NEXT:  Determining loop execution counts for: @test_3_op_add
; CHECK-NEXT:  Loop %loop: backedge-taken count is (-1 + (zext i32 (1 + (-1 * %x) + %y) to i64))<nsw>
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 2147483647
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is (-1 + (zext i32 (1 + (-1 * %x) + %y) to i64))<nsw>
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;
entry:
  %pre.0 = icmp ugt i32 %x, 0
  br i1 %pre.0, label %then, label %exit

then:
  %y.sub.x = sub i32 %y, %x
  %pre.1 = icmp slt i32 %y.sub.x, 0
  %add.1 = add i32 %y.sub.x, 1
  %add.ext = zext i32 %add.1 to i64
  br i1 %pre.1, label %exit, label %loop

loop:
  %iv = phi i64 [ %iv.next, %loop ], [ 0, %then ]
  %and = and i64 %iv, 1
  %gep = getelementptr i8, ptr %A, i64 %and
  call void @use(ptr %gep)
  %iv.next = add i64 %iv, 1
  %ec = icmp eq i64 %iv.next, %add.ext
  br i1 %ec, label %exit, label %loop

exit:
  ret i32 0
}
