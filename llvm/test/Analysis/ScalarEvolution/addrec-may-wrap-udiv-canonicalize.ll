; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes='print<scalar-evolution>' -disable-output 2>&1 | FileCheck %s

declare void @use(i64)

define void @test_step2_div4(i64 %n) {
; CHECK-LABEL: 'test_step2_div4'
; CHECK-NEXT:  Classifying expressions for: @test_step2_div4
; CHECK-NEXT:    %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    --> {0,+,2}<%loop> U: [0,-1) S: [-9223372036854775808,9223372036854775807) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.0 = udiv i64 %iv, 4
; CHECK-NEXT:    --> ({0,+,2}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.1 = add i64 %iv, 1
; CHECK-NEXT:    --> {1,+,2}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.1 = udiv i64 %iv.1, 4
; CHECK-NEXT:    --> ({0,+,2}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.2 = add i64 %iv, 2
; CHECK-NEXT:    --> {2,+,2}<%loop> U: [0,-1) S: [-9223372036854775808,9223372036854775807) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.2 = udiv i64 %iv.2, 4
; CHECK-NEXT:    --> ({2,+,2}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.neg.1 = add i64 %iv, -1
; CHECK-NEXT:    --> {-1,+,2}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.neg.1 = udiv i64 %iv.neg.1, 4
; CHECK-NEXT:    --> ({-2,+,2}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.next = add i64 %iv, 2
; CHECK-NEXT:    --> {2,+,2}<%loop> U: [0,-1) S: [-9223372036854775808,9223372036854775807) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_step2_div4
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %div.0 = udiv i64 %iv, 4
  call void @use(i64 %div.0)
  %iv.1 = add i64 %iv, 1
  %div.1 = udiv i64 %iv.1, 4
  call void @use(i64 %div.1)
  %iv.2 = add i64 %iv, 2
  %div.2 = udiv i64 %iv.2, 4
  call void @use(i64 %div.2)
  %iv.neg.1 = add i64 %iv, -1
  %div.neg.1 = udiv i64 %iv.neg.1, 4
  call void @use(i64 %div.neg.1)
  %iv.next = add i64 %iv, 2
  %cond = icmp slt i64 %iv, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

define void @test_step3_div6(i64 %n) {
; CHECK-LABEL: 'test_step3_div6'
; CHECK-NEXT:  Classifying expressions for: @test_step3_div6
; CHECK-NEXT:    %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    --> {0,+,3}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.0 = udiv i64 %iv, 6
; CHECK-NEXT:    --> ({0,+,3}<%loop> /u 6) U: [0,3074457345618258603) S: [0,3074457345618258603) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.1 = add i64 %iv, 1
; CHECK-NEXT:    --> {1,+,3}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.1 = udiv i64 %iv.1, 6
; CHECK-NEXT:    --> ({1,+,3}<%loop> /u 6) U: [0,3074457345618258603) S: [0,3074457345618258603) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.2 = add i64 %iv, 2
; CHECK-NEXT:    --> {2,+,3}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.2 = udiv i64 %iv.2, 6
; CHECK-NEXT:    --> ({2,+,3}<%loop> /u 6) U: [0,3074457345618258603) S: [0,3074457345618258603) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.neg.1 = add i64 %iv, -1
; CHECK-NEXT:    --> {-1,+,3}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.neg.1 = udiv i64 %iv.neg.1, 6
; CHECK-NEXT:    --> ({-1,+,3}<%loop> /u 6) U: [0,3074457345618258603) S: [0,3074457345618258603) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.next = add i64 %iv, 3
; CHECK-NEXT:    --> {3,+,3}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_step3_div6
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %div.0 = udiv i64 %iv, 6
  call void @use(i64 %div.0)
  %iv.1 = add i64 %iv, 1
  %div.1 = udiv i64 %iv.1, 6
  call void @use(i64 %div.1)
  %iv.2 = add i64 %iv, 2
  %div.2 = udiv i64 %iv.2, 6
  call void @use(i64 %div.2)
  %iv.neg.1 = add i64 %iv, -1
  %div.neg.1 = udiv i64 %iv.neg.1, 6
  call void @use(i64 %div.neg.1)
  %iv.next = add i64 %iv, 3
  %cond = icmp slt i64 %iv, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}


define void @test_step4_div4(i64 %n) {
; CHECK-LABEL: 'test_step4_div4'
; CHECK-NEXT:  Classifying expressions for: @test_step4_div4
; CHECK-NEXT:    %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    --> {0,+,4}<%loop> U: [0,-3) S: [-9223372036854775808,9223372036854775805) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.0 = udiv i64 %iv, 4
; CHECK-NEXT:    --> ({0,+,4}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.1 = add i64 %iv, 1
; CHECK-NEXT:    --> {1,+,4}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.1 = udiv i64 %iv.1, 4
; CHECK-NEXT:    --> ({0,+,4}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.2 = add i64 %iv, 2
; CHECK-NEXT:    --> {2,+,4}<%loop> U: [0,-1) S: [-9223372036854775808,9223372036854775807) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.2 = udiv i64 %iv.2, 4
; CHECK-NEXT:    --> ({0,+,4}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.3 = add i64 %iv, 3
; CHECK-NEXT:    --> {3,+,4}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.3 = udiv i64 %iv.3, 4
; CHECK-NEXT:    --> ({0,+,4}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.4 = add i64 %iv, 4
; CHECK-NEXT:    --> {4,+,4}<%loop> U: [0,-3) S: [-9223372036854775808,9223372036854775805) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.4 = udiv i64 %iv.4, 4
; CHECK-NEXT:    --> ({4,+,4}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.5 = add i64 %iv, 5
; CHECK-NEXT:    --> {5,+,4}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %div.5 = udiv i64 %iv.5, 4
; CHECK-NEXT:    --> ({4,+,4}<%loop> /u 4) U: [0,4611686018427387904) S: [0,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.next = add i64 %iv, 4
; CHECK-NEXT:    --> {4,+,4}<%loop> U: [0,-3) S: [-9223372036854775808,9223372036854775805) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_step4_div4
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %div.0 = udiv i64 %iv, 4
  call void @use(i64 %div.0)
  %iv.1 = add i64 %iv, 1
  %div.1 = udiv i64 %iv.1, 4
  call void @use(i64 %div.1)
  %iv.2 = add i64 %iv, 2
  %div.2 = udiv i64 %iv.2, 4
  call void @use(i64 %div.2)
  %iv.3 = add i64 %iv, 3
  %div.3 = udiv i64 %iv.3, 4
  call void @use(i64 %div.3)
  %iv.4 = add i64 %iv, 4
  %div.4 = udiv i64 %iv.4, 4
  call void @use(i64 %div.4)
  %iv.5 = add i64 %iv, 5
  %div.5 = udiv i64 %iv.5, 4
  call void @use(i64 %div.5)
  %iv.next = add i64 %iv, 4
  %cond = icmp slt i64 %iv, %n
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}
