; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes='loop(loop-deletion),loop-mssa(loop-predication,licm<allowspeculation>,simple-loop-unswitch<nontrivial>),loop(loop-predication)' -S < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128-ni:1-p2:32:8:8:32-ni:2"
target triple = "x86_64-unknown-linux-gnu"

define void @test(i32 %arg) {
; CHECK-LABEL: define void @test
; CHECK-SAME: (i32 [[ARG:%.*]]) {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[BB2:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    br i1 false, label [[BB3_PREHEADER:%.*]], label [[BB1]]
; CHECK:       bb3.preheader:
; CHECK-NEXT:    [[LOAD_LE:%.*]] = load i32, ptr null, align 4
; CHECK-NEXT:    br label [[BB3:%.*]]
; CHECK:       bb3.loopexit:
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD:%.*]], [[BB3_LOOPEXIT:%.*]] ], [ 0, [[BB3_PREHEADER]] ]
; CHECK-NEXT:    [[ADD]] = add i32 [[PHI]], 1
; CHECK-NEXT:    [[ICMP:%.*]] = icmp ult i32 [[PHI]], [[LOAD_LE]]
; CHECK-NEXT:    br i1 [[ICMP]], label [[BB5:%.*]], label [[BB4:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    ret void
; CHECK:       bb5:
; CHECK-NEXT:    [[CALL:%.*]] = call i1 @llvm.experimental.widenable.condition()
; CHECK-NEXT:    br i1 [[CALL]], label [[BB9_PREHEADER:%.*]], label [[BB14:%.*]]
; CHECK:       bb9.preheader:
; CHECK-NEXT:    br label [[BB9:%.*]]
; CHECK:       bb6:
; CHECK-NEXT:    [[ADD7:%.*]] = add i32 [[PHI10:%.*]], 1
; CHECK-NEXT:    [[ICMP8:%.*]] = icmp ugt i32 [[PHI10]], 1
; CHECK-NEXT:    br i1 [[ICMP8]], label [[BB3_LOOPEXIT]], label [[BB9]]
; CHECK:       bb9:
; CHECK-NEXT:    [[PHI10]] = phi i32 [ [[ADD7]], [[BB6:%.*]] ], [ [[PHI]], [[BB9_PREHEADER]] ]
; CHECK-NEXT:    [[ICMP11:%.*]] = icmp ult i32 [[PHI10]], [[ARG]]
; CHECK-NEXT:    [[CALL12:%.*]] = call i1 @llvm.experimental.widenable.condition()
; CHECK-NEXT:    [[AND:%.*]] = and i1 [[ICMP11]], true
; CHECK-NEXT:    br i1 [[AND]], label [[BB6]], label [[BB13:%.*]]
; CHECK:       bb13:
; CHECK-NEXT:    ret void
; CHECK:       bb14:
; CHECK-NEXT:    ret void
;
bb:
  br label %bb1

bb1:                                              ; preds = %bb2, %bb
  %load = load i32, ptr null, align 4
  br label %bb2

bb2:                                              ; preds = %bb1
  br i1 false, label %bb3, label %bb1

bb3:                                              ; preds = %bb6, %bb2
  %phi = phi i32 [ %add, %bb6 ], [ 0, %bb2 ]
  %add = add i32 %phi, 1
  %icmp = icmp ult i32 %phi, %load
  br i1 %icmp, label %bb5, label %bb4

bb4:                                              ; preds = %bb3
  ret void

bb5:                                              ; preds = %bb3
  %call = call i1 @llvm.experimental.widenable.condition()
  br i1 %call, label %bb9, label %bb14

bb6:                                              ; preds = %bb9
  %add7 = add i32 %phi10, 1
  %icmp8 = icmp ugt i32 %phi10, 1
  br i1 %icmp8, label %bb3, label %bb9

bb9:                                              ; preds = %bb6, %bb5
  %phi10 = phi i32 [ %add7, %bb6 ], [ %phi, %bb5 ]
  %icmp11 = icmp ult i32 %phi10, %arg
  %call12 = call i1 @llvm.experimental.widenable.condition()
  %and = and i1 %icmp11, %call12
  br i1 %and, label %bb6, label %bb13

bb13:                                             ; preds = %bb9
  ret void

bb14:                                             ; preds = %bb5
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(inaccessiblemem: readwrite)
declare noundef i1 @llvm.experimental.widenable.condition() #0

attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(inaccessiblemem: readwrite) }
