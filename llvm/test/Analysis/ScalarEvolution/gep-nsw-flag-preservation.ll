; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -disable-output "-passes=print<scalar-evolution>" 2>&1 | FileCheck %s

; Test that SCEV preserves NSW flags when combining AddRec expressions
; from GEP operations. Previously, the NSW flags would be lost when
; combining offset calculations like:
; {-2400,+,1200}<nsw> + {-24,+,12}<nsw> = {-2424,+,1212}<nsw>
; This test ensures the fix in getAddExpr properly preserves flags.

define void @test_gep_nsw_preservation(ptr %A) {
; CHECK-LABEL: 'test_gep_nsw_preservation'
; CHECK-NEXT:  Classifying expressions for: @test_gep_nsw_preservation
; CHECK-NEXT:    %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
; CHECK-NEXT:    --> {0,+,1}<nuw><nsw><%loop> U: [0,50) S: [0,50) Exits: 49 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %mul = mul nsw i64 %i, 3
; CHECK-NEXT:    --> {0,+,3}<nuw><nsw><%loop> U: [0,148) S: [0,148) Exits: 147 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %sub = add nsw i64 %mul, -6
; CHECK-NEXT:    --> {-6,+,3}<nsw><%loop> U: [-6,142) S: [-6,142) Exits: 141 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub
; CHECK-NEXT:    --> {(-2424 + %A),+,1212}<nw><%loop> U: full-set S: full-set Exits: (56964 + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %i.next = add nsw i64 %i, 1
; CHECK-NEXT:    --> {1,+,1}<nuw><nsw><%loop> U: [1,51) S: [1,51) Exits: 50 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_gep_nsw_preservation
; CHECK-NEXT:  Loop %loop: backedge-taken count is i64 49
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 49
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is i64 49
; CHECK-NEXT:  Loop %loop: Trip multiple is 50
;
entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]

  ; Create NSW-flagged arithmetic that gets used in GEP indices
  %mul = mul nsw i64 %i, 3
  %sub = add nsw i64 %mul, -6

  ; GEP with inbounds using the NSW-flagged expressions as indices
  ; This should result in SCEV: {(-2424 + %A),+,1212}<nw>
  ; The <nw> flag should be preserved from the NSW flags on the indices
  %gep = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub

  %i.next = add nsw i64 %i, 1
  %cond = icmp ult i64 %i.next, 50
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

; Test that the preserved flags enable dependence analysis
define void @test_dependence_analysis(ptr %A) {
; This test should show that dependence analysis works correctly
; when SCEV preserves NSW flags, preventing false "wrapping" detection
; CHECK-LABEL: 'test_dependence_analysis'
; CHECK-NEXT:  Classifying expressions for: @test_dependence_analysis
; CHECK-NEXT:    %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
; CHECK-NEXT:    --> {0,+,1}<nuw><nsw><%loop> U: [0,50) S: [0,50) Exits: 49 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %mul = mul nsw i64 %i, 3
; CHECK-NEXT:    --> {0,+,3}<nuw><nsw><%loop> U: [0,148) S: [0,148) Exits: 147 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %sub = add nsw i64 %mul, -6
; CHECK-NEXT:    --> {-6,+,3}<nsw><%loop> U: [-6,142) S: [-6,142) Exits: 141 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep1 = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub
; CHECK-NEXT:    --> {(-2424 + %A),+,1212}<nw><%loop> U: full-set S: full-set Exits: (56964 + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep2 = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub
; CHECK-NEXT:    --> {(-2424 + %A),+,1212}<nw><%loop> U: full-set S: full-set Exits: (56964 + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %val = load i32, ptr %gep2, align 4
; CHECK-NEXT:    --> %val U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:    %i.next = add nsw i64 %i, 1
; CHECK-NEXT:    --> {1,+,1}<nuw><nsw><%loop> U: [1,51) S: [1,51) Exits: 50 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_dependence_analysis
; CHECK-NEXT:  Loop %loop: backedge-taken count is i64 49
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 49
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is i64 49
; CHECK-NEXT:  Loop %loop: Trip multiple is 50
;
entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]

  %mul = mul nsw i64 %i, 3
  %sub = add nsw i64 %mul, -6

  ; Two identical GEPs - should be detected as same location (no dependence)
  %gep1 = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub
  %gep2 = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub

  %val = load i32, ptr %gep2
  store i32 %val, ptr %gep1

  %i.next = add nsw i64 %i, 1
  %cond = icmp ult i64 %i.next, 50
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}
