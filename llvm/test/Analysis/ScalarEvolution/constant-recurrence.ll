; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 4
; RUN:  opt -disable-output "-passes=print<scalar-evolution>" %s 2>&1 | FileCheck %s

define i32 @simple(i32 %a, i32 %k) {
; CHECK-LABEL: 'simple'
; CHECK-NEXT:  Classifying expressions for: @simple
; CHECK-NEXT:    %j.0 = phi i32 [ %a, %entry ], [ %sub, %for.body ]
; CHECK-NEXT:    --> %j.0 U: full-set S: full-set
; CHECK-NEXT:    %i = phi i32 [ %inc, %for.body ], [ 0, %entry ]
; CHECK-NEXT:    --> {0,+,1}<nuw><%for.body> U: [0,-1) S: [0,-1) Exits: (-1 + %k) LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:    %j = phi i32 [ %sub, %for.body ], [ %a, %entry ]
; CHECK-NEXT:    --> %a U: full-set S: full-set Exits: %a LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %add = shl nsw i32 %j, 1
; CHECK-NEXT:    --> (2 * %a) U: [0,-1) S: [-2147483648,2147483647) Exits: (2 * %a) LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %sub = sub nsw i32 %add, %a
; CHECK-NEXT:    --> %a U: full-set S: full-set Exits: %a LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %inc = add nuw i32 %i, 1
; CHECK-NEXT:    --> {1,+,1}<nuw><%for.body> U: [1,0) S: [1,0) Exits: %k LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @simple
; CHECK-NEXT:  Loop %for.body: backedge-taken count is (-1 + %k)
; CHECK-NEXT:  Loop %for.body: constant max backedge-taken count is i32 -2
; CHECK-NEXT:  Loop %for.body: symbolic max backedge-taken count is (-1 + %k)
; CHECK-NEXT:  Loop %for.body: Trip multiple is 1
;
entry:
    %cmp6.not = icmp eq i32 %k, 0
    br i1 %cmp6.not, label %for.cleanup, label %for.body
for.cleanup:
    %j.0 = phi i32 [ %a, %entry ], [ %sub, %for.body ]
    ret i32 %j.0
for.body:
    %i = phi i32 [ %inc, %for.body ], [ 0, %entry ]

    %j = phi i32 [ %sub, %for.body ], [ %a, %entry ]
    %add = shl nsw i32 %j, 1
    %sub = sub nsw i32 %add, %a

    %inc = add nuw i32 %i, 1
    %exitcond.not = icmp eq i32 %inc, %k
    br i1 %exitcond.not, label %for.cleanup, label %for.body
}

define i32 @harder(i32 %a, i32 %b, i32 %k) {
; CHECK-LABEL: 'harder'
; CHECK-NEXT:  Classifying expressions for: @harder
; CHECK-NEXT:    %j.0 = phi i32 [ %a, %entry ], [ %sub, %for.body ]
; CHECK-NEXT:    --> %j.0 U: full-set S: full-set
; CHECK-NEXT:    %i = phi i32 [ %inc, %for.body ], [ 0, %entry ]
; CHECK-NEXT:    --> {0,+,1}<nuw><%for.body> U: [0,-1) S: [0,-1) Exits: (-1 + %k) LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:    %j = phi i32 [ %sub, %for.body ], [ %a, %entry ]
; CHECK-NEXT:    --> %a U: full-set S: full-set Exits: %a LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %mul = mul nsw i32 %j, %b
; CHECK-NEXT:    --> (%a * %b) U: full-set S: full-set Exits: (%a * %b) LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %b_1 = sub nsw i32 %b, 1
; CHECK-NEXT:    --> (-1 + %b) U: full-set S: full-set Exits: (-1 + %b) LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %a_1 = mul nsw i32 %a, %b_1
; CHECK-NEXT:    --> ((-1 + %b) * %a) U: full-set S: full-set Exits: ((-1 + %b) * %a) LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %sub = sub nsw i32 %mul, %a_1
; CHECK-NEXT:    --> %a U: full-set S: full-set Exits: %a LoopDispositions: { %for.body: Invariant }
; CHECK-NEXT:    %inc = add nuw i32 %i, 1
; CHECK-NEXT:    --> {1,+,1}<nuw><%for.body> U: [1,0) S: [1,0) Exits: %k LoopDispositions: { %for.body: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @harder
; CHECK-NEXT:  Loop %for.body: backedge-taken count is (-1 + %k)
; CHECK-NEXT:  Loop %for.body: constant max backedge-taken count is i32 -2
; CHECK-NEXT:  Loop %for.body: symbolic max backedge-taken count is (-1 + %k)
; CHECK-NEXT:  Loop %for.body: Trip multiple is 1
;
entry:
    %cmp6.not = icmp eq i32 %k, 0
    br i1 %cmp6.not, label %for.cleanup, label %for.body
for.cleanup:
    %j.0 = phi i32 [ %a, %entry ], [ %sub, %for.body ]
    ret i32 %j.0
for.body:
    %i = phi i32 [ %inc, %for.body ], [ 0, %entry ]

    %j = phi i32 [ %sub, %for.body ], [ %a, %entry ]
    %mul = mul nsw i32 %j, %b
    %b_1 = sub nsw i32 %b, 1
    %a_1 = mul nsw i32 %a, %b_1
    %sub = sub nsw i32 %mul, %a_1

    %inc = add nuw i32 %i, 1
    %exitcond.not = icmp eq i32 %inc, %k
    br i1 %exitcond.not, label %for.cleanup, label %for.body
}

