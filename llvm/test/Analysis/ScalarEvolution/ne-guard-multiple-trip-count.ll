; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='print<scalar-evolution>' -disable-output %s 2>&1 | FileCheck %s

declare void @foo()

; Tests with multiple guards for the same value and different values.

define void @test_guard_order_b_then_c_and_d(ptr %a, ptr %b, ptr %c, ptr %d) {
; CHECK-LABEL: 'test_guard_order_b_then_c_and_d'
; CHECK-NEXT:  Classifying expressions for: @test_guard_order_b_then_c_and_d
; CHECK-NEXT:    %iv = phi ptr [ %a, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    --> {%a,+,1}<%loop> U: full-set S: full-set Exits: (-1 + (-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64) + %a) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.next = getelementptr i8, ptr %iv, i64 1
; CHECK-NEXT:    --> {(1 + %a),+,1}<%loop> U: full-set S: full-set Exits: ((-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64) + %a) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_guard_order_b_then_c_and_d
; CHECK-NEXT:  Loop %loop: backedge-taken count is (-1 + (-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64))
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 -2
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is (-1 + (-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64))
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;
entry:
  %cmp.eq.b = icmp ne ptr %a, %b
  %cmp.eq.c = icmp ne ptr %a, %c
  %cmp.eq.d = icmp ne ptr %b, %d
  call void @llvm.assume(i1 %cmp.eq.b)
  call void @llvm.assume(i1 %cmp.eq.c)
  call void @llvm.assume(i1 %cmp.eq.d)
  br label %loop

loop:
  %iv = phi ptr [ %a, %entry ], [ %iv.next, %loop ]
  %iv.next = getelementptr i8, ptr %iv, i64 1
  call void @foo()
  %ec = icmp eq ptr %iv.next, %b
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

define void @test_guard_order_d_then_c_and_b(ptr %a, ptr %b, ptr %c, ptr %d) {
; CHECK-LABEL: 'test_guard_order_d_then_c_and_b'
; CHECK-NEXT:  Classifying expressions for: @test_guard_order_d_then_c_and_b
; CHECK-NEXT:    %iv = phi ptr [ %a, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    --> {%a,+,1}<%loop> U: full-set S: full-set Exits: (-1 + (-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64) + %a) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.next = getelementptr i8, ptr %iv, i64 1
; CHECK-NEXT:    --> {(1 + %a),+,1}<%loop> U: full-set S: full-set Exits: ((-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64) + %a) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_guard_order_d_then_c_and_b
; CHECK-NEXT:  Loop %loop: backedge-taken count is (-1 + (-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64))
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 -2
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is (-1 + (-1 * (ptrtoint ptr %a to i64)) + (ptrtoint ptr %b to i64))
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;
entry:
  %cmp.eq.b = icmp ne ptr %a, %b
  %cmp.eq.c = icmp ne ptr %a, %c
  %cmp.eq.d = icmp ne ptr %b, %d
  call void @llvm.assume(i1 %cmp.eq.d)
  call void @llvm.assume(i1 %cmp.eq.c)
  call void @llvm.assume(i1 %cmp.eq.b)
  br label %loop

loop:
  %iv = phi ptr [ %a, %entry ], [ %iv.next, %loop ]
  %iv.next = getelementptr i8, ptr %iv, i64 1
  call void @foo()
  %ec = icmp eq ptr %iv.next, %b
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}
