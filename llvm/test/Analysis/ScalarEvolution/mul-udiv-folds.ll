; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='print<scalar-evolution>' -disable-output %s 2>&1 | FileCheck %s

declare void @use(ptr)

define void @udiv4_and_udiv2(i1 %c, ptr %A) {
; CHECK-LABEL: 'udiv4_and_udiv2'
; CHECK-NEXT:  Classifying expressions for: @udiv4_and_udiv2
; CHECK-NEXT:    %start = select i1 %c, i32 512, i32 0
; CHECK-NEXT:    --> %start U: [0,513) S: [0,513)
; CHECK-NEXT:    %div.2 = lshr i32 %start, 1
; CHECK-NEXT:    --> (%start /u 2) U: [0,257) S: [0,257)
; CHECK-NEXT:    %div.4 = lshr i32 %start, 2
; CHECK-NEXT:    --> (%start /u 4) U: [0,129) S: [0,129)
; CHECK-NEXT:    %iv.start = zext i32 %div.4 to i64
; CHECK-NEXT:    --> ((zext i32 %start to i64) /u 4) U: [0,129) S: [0,129)
; CHECK-NEXT:    %wide.trip.count = zext i32 %div.2 to i64
; CHECK-NEXT:    --> ((zext i32 %start to i64) /u 2) U: [0,257) S: [0,257)
; CHECK-NEXT:    %iv = phi i64 [ %iv.start, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    --> {((zext i32 %start to i64) /u 4),+,1}<%loop> U: full-set S: full-set Exits: ((zext i32 %start to i64) /u 2) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.8 = getelementptr i8, ptr %A, i64 %iv
; CHECK-NEXT:    --> {(((zext i32 %start to i64) /u 4) + %A),+,1}<%loop> U: full-set S: full-set Exits: (((zext i32 %start to i64) /u 2) + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.16 = getelementptr i16, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((2 * ((zext i32 %start to i64) /u 4))<nuw><nsw> + %A),+,2}<%loop> U: full-set S: full-set Exits: ((zext i32 %start to i64) + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.32 = getelementptr i32, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((zext i32 %start to i64) + %A),+,4}<%loop> U: full-set S: full-set Exits: ((3 * (zext i32 %start to i64))<nuw><nsw> + (-4 * ((zext i32 %start to i64) /u 4))<nsw> + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.40 = getelementptr <{ i32, i8 }>, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((5 * ((zext i32 %start to i64) /u 4))<nuw><nsw> + %A),+,5}<%loop> U: full-set S: full-set Exits: ((5 * ((zext i32 %start to i64) /u 2))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.48 = getelementptr <{ i32, i16 }>, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((6 * ((zext i32 %start to i64) /u 4))<nuw><nsw> + %A),+,6}<%loop> U: full-set S: full-set Exits: ((6 * ((zext i32 %start to i64) /u 2))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.next = add i64 %iv, 1
; CHECK-NEXT:    --> {(1 + ((zext i32 %start to i64) /u 4))<nuw><nsw>,+,1}<%loop> U: full-set S: full-set Exits: (1 + ((zext i32 %start to i64) /u 2))<nuw><nsw> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @udiv4_and_udiv2
; CHECK-NEXT:  Loop %loop: backedge-taken count is ((-1 * ((zext i32 %start to i64) /u 4))<nsw> + ((zext i32 %start to i64) /u 2))
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 -1
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is ((-1 * ((zext i32 %start to i64) /u 4))<nsw> + ((zext i32 %start to i64) /u 2))
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;
entry:
  %start = select i1 %c, i32 512, i32 0
  %div.2 = lshr i32 %start, 1
  %div.4 = lshr i32 %start, 2
  %iv.start = zext i32 %div.4 to i64
  %wide.trip.count = zext i32 %div.2 to i64
  br label %loop

loop:
  %iv = phi i64 [ %iv.start, %entry ], [ %iv.next, %loop ]
  %gep.8 = getelementptr i8, ptr %A, i64 %iv
  call void @use(ptr %gep.8)
  %gep.16 = getelementptr i16, ptr %A, i64 %iv
  call void @use(ptr %gep.16)
  %gep.32 = getelementptr i32, ptr %A, i64 %iv
  call void @use(ptr %gep.32)
  %gep.40 = getelementptr <{i32, i8}>, ptr %A, i64 %iv
  call void @use(ptr %gep.40)
  %gep.48 = getelementptr <{i32, i16}>, ptr %A, i64 %iv
  call void @use(ptr %gep.48)
  %iv.next = add i64 %iv, 1
  %ec = icmp eq i64 %iv, %wide.trip.count
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}
define void @udiv3_and_udiv5_mul_4(i1 %c, ptr %A) {
; CHECK-LABEL: 'udiv3_and_udiv5_mul_4'
; CHECK-NEXT:  Classifying expressions for: @udiv3_and_udiv5_mul_4
; CHECK-NEXT:    %start = select i1 %c, i32 512, i32 0
; CHECK-NEXT:    --> %start U: [0,513) S: [0,513)
; CHECK-NEXT:    %div.3 = udiv i32 %start, 3
; CHECK-NEXT:    --> (%start /u 3) U: [0,171) S: [0,171)
; CHECK-NEXT:    %div.5 = udiv i32 %start, 5
; CHECK-NEXT:    --> (%start /u 5) U: [0,103) S: [0,103)
; CHECK-NEXT:    %iv.start = zext i32 %div.5 to i64
; CHECK-NEXT:    --> ((zext i32 %start to i64) /u 5) U: [0,103) S: [0,103)
; CHECK-NEXT:    %wide.trip.count = zext i32 %div.3 to i64
; CHECK-NEXT:    --> ((zext i32 %start to i64) /u 3) U: [0,171) S: [0,171)
; CHECK-NEXT:    %iv = phi i64 [ %iv.start, %entry ], [ %iv.next, %loop ]
; CHECK-NEXT:    --> {((zext i32 %start to i64) /u 5),+,1}<%loop> U: full-set S: full-set Exits: ((zext i32 %start to i64) /u 3) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.8 = getelementptr i8, ptr %A, i64 %iv
; CHECK-NEXT:    --> {(((zext i32 %start to i64) /u 5) + %A),+,1}<%loop> U: full-set S: full-set Exits: (((zext i32 %start to i64) /u 3) + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.16 = getelementptr i16, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((2 * ((zext i32 %start to i64) /u 5))<nuw><nsw> + %A),+,2}<%loop> U: full-set S: full-set Exits: ((2 * ((zext i32 %start to i64) /u 3))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.32 = getelementptr i32, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((4 * ((zext i32 %start to i64) /u 5))<nuw><nsw> + %A),+,4}<%loop> U: full-set S: full-set Exits: ((4 * ((zext i32 %start to i64) /u 3))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.40 = getelementptr <{ i32, i8 }>, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((5 * ((zext i32 %start to i64) /u 5))<nuw><nsw> + %A),+,5}<%loop> U: full-set S: full-set Exits: ((5 * ((zext i32 %start to i64) /u 3))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %gep.48 = getelementptr <{ i32, i16 }>, ptr %A, i64 %iv
; CHECK-NEXT:    --> {((6 * ((zext i32 %start to i64) /u 5))<nuw><nsw> + %A),+,6}<%loop> U: full-set S: full-set Exits: ((6 * ((zext i32 %start to i64) /u 3))<nuw><nsw> + %A) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.next = add i64 %iv, 1
; CHECK-NEXT:    --> {(1 + ((zext i32 %start to i64) /u 5))<nuw><nsw>,+,1}<%loop> U: full-set S: full-set Exits: (1 + ((zext i32 %start to i64) /u 3))<nuw><nsw> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @udiv3_and_udiv5_mul_4
; CHECK-NEXT:  Loop %loop: backedge-taken count is ((-1 * ((zext i32 %start to i64) /u 5))<nsw> + ((zext i32 %start to i64) /u 3))
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i64 -1
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is ((-1 * ((zext i32 %start to i64) /u 5))<nsw> + ((zext i32 %start to i64) /u 3))
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;
entry:
  %start = select i1 %c, i32 512, i32 0
  %div.3 = udiv i32 %start, 3
  %div.5 = udiv i32 %start, 5
  %iv.start = zext i32 %div.5 to i64
  %wide.trip.count = zext i32 %div.3 to i64
  br label %loop

loop:
  %iv = phi i64 [ %iv.start, %entry ], [ %iv.next, %loop ]
  %gep.8 = getelementptr i8, ptr %A, i64 %iv
  call void @use(ptr %gep.8)
  %gep.16 = getelementptr i16, ptr %A, i64 %iv
  call void @use(ptr %gep.16)
  %gep.32 = getelementptr i32, ptr %A, i64 %iv
  call void @use(ptr %gep.32)
  %gep.40 = getelementptr <{i32, i8}>, ptr %A, i64 %iv
  call void @use(ptr %gep.40)
  %gep.48 = getelementptr <{i32, i16}>, ptr %A, i64 %iv
  call void @use(ptr %gep.48)
  %iv.next = add i64 %iv, 1
  %ec = icmp eq i64 %iv, %wide.trip.count
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}
