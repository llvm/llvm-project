; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='print<scalar-evolution>' -disable-output %s 2>&1 | FileCheck %s

; Check that SCEV is able to recognize and use guards to prove
; conditions gaurding loop entries and backedges.  This isn't intended
; to be a comprehensive test of SCEV's simplification capabilities,
; tests directly testing e.g. if SCEV can elide a sext should go
; elsewhere.

target datalayout = "n8:16:32:64"

declare void @llvm.experimental.guard(i1, ...)

declare void @use(i64 %x)

define void @test_1(ptr %cond_buf, ptr %len_buf) {
; CHECK-LABEL: 'test_1'
; CHECK-NEXT:  Classifying expressions for: @test_1
; CHECK-NEXT:    %len = load i32, ptr %len_buf, align 4, !range !0
; CHECK-NEXT:    --> %len U: [1,-2147483648) S: [1,-2147483648)
; CHECK-NEXT:    %iv = phi i32 [ 0, %entry ], [ %iv.inc, %loop ]
; CHECK-NEXT:    --> {0,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.inc = add i32 %iv, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %becond = load volatile i1, ptr %cond_buf, align 1
; CHECK-NEXT:    --> %becond U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:  Determining loop execution counts for: @test_1
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
;
entry:
  %len = load i32, ptr %len_buf, !range !{i32 1, i32 2147483648}
  br label %loop

loop:

  %iv = phi i32 [ 0, %entry ], [ %iv.inc, %loop ]
  %iv.inc = add i32 %iv, 1

  %iv.cmp = icmp slt i32 %iv, %len
  call void(i1, ...) @llvm.experimental.guard(i1 %iv.cmp) [ "deopt"() ]

  %iv.inc.cmp = icmp slt i32 %iv.inc, %len
  call void(i1, ...) @llvm.experimental.guard(i1 %iv.inc.cmp) [ "deopt"() ]

  %becond = load volatile i1, ptr %cond_buf
  br i1 %becond, label %loop, label %leave

leave:
  ret void
}

define void @test_2(i32 %n, ptr %len_buf) {
; CHECK-LABEL: 'test_2'
; CHECK-NEXT:  Classifying expressions for: @test_2
; CHECK-NEXT:    %len = load i32, ptr %len_buf, align 4, !range !0
; CHECK-NEXT:    --> %len U: [0,-2147483648) S: [0,-2147483648)
; CHECK-NEXT:    %iv = phi i32 [ 0, %entry ], [ %iv.inc, %loop ]
; CHECK-NEXT:    --> {0,+,1}<%loop> U: full-set S: full-set Exits: %n LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.inc = add i32 %iv, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: full-set S: full-set Exits: (1 + %n) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.sext = sext i32 %iv to i64
; CHECK-NEXT:    --> {0,+,1}<nuw><nsw><%loop> U: [0,4294967296) S: [0,4294967296) Exits: (zext i32 %n to i64) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @test_2
; CHECK-NEXT:  Loop %loop: backedge-taken count is %n
; CHECK-NEXT:  Loop %loop: constant max backedge-taken count is i32 -1
; CHECK-NEXT:  Loop %loop: symbolic max backedge-taken count is %n
; CHECK-NEXT:  Loop %loop: Trip multiple is 1
;

entry:
  %len = load i32, ptr %len_buf, !range !{i32 0, i32 2147483648}
  br label %loop

loop:

  %iv = phi i32 [ 0, %entry ], [ %iv.inc, %loop ]
  %iv.inc = add i32 %iv, 1

  %iv.sext = sext i32 %iv to i64
  call void @use(i64 %iv.sext)

  %iv.inc.cmp = icmp slt i32 %iv.inc, %len
  call void(i1, ...) @llvm.experimental.guard(i1 %iv.inc.cmp) [ "deopt"() ]

  %becond = icmp ne i32 %iv, %n
  br i1 %becond, label %loop, label %leave

leave:
  ret void
}

define void @test_3(ptr %cond_buf, ptr %len_buf) {
; CHECK-LABEL: 'test_3'
; CHECK-NEXT:  Classifying expressions for: @test_3
; CHECK-NEXT:    %len = load i32, ptr %len_buf, align 4
; CHECK-NEXT:    --> %len U: full-set S: full-set
; CHECK-NEXT:    %iv = phi i32 [ 0, %entry ], [ %iv.inc, %loop ]
; CHECK-NEXT:    --> {0,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.inc = add i32 %iv, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %becond = load volatile i1, ptr %cond_buf, align 1
; CHECK-NEXT:    --> %becond U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:  Determining loop execution counts for: @test_3
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
;

entry:
  %len = load i32, ptr %len_buf
  %entry.cond = icmp sgt i32 %len, 0
  call void(i1, ...) @llvm.experimental.guard(i1 %entry.cond) [ "deopt"() ]
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.inc, %loop ]
  %iv.inc = add i32 %iv, 1

  %iv.cmp = icmp slt i32 %iv, %len
  call void(i1, ...) @llvm.experimental.guard(i1 %iv.cmp) [ "deopt"() ]

  %iv.inc.cmp = icmp slt i32 %iv.inc, %len
  call void(i1, ...) @llvm.experimental.guard(i1 %iv.inc.cmp) [ "deopt"() ]

  %becond = load volatile i1, ptr %cond_buf
  br i1 %becond, label %loop, label %leave

leave:
  ret void
}

define void @test_4(ptr %cond_buf, ptr %len_buf) {
; CHECK-LABEL: 'test_4'
; CHECK-NEXT:  Classifying expressions for: @test_4
; CHECK-NEXT:    %len = load i32, ptr %len_buf, align 4
; CHECK-NEXT:    --> %len U: full-set S: full-set
; CHECK-NEXT:    %iv = phi i32 [ 0, %entry ], [ %iv.inc, %be ]
; CHECK-NEXT:    --> {0,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.inc = add i32 %iv, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %cond = load volatile i1, ptr %cond_buf, align 1
; CHECK-NEXT:    --> %cond U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:    %becond = load volatile i1, ptr %cond_buf, align 1
; CHECK-NEXT:    --> %becond U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:  Determining loop execution counts for: @test_4
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
;

entry:
  %len = load i32, ptr %len_buf
  %entry.cond = icmp sgt i32 %len, 0
  call void(i1, ...) @llvm.experimental.guard(i1 %entry.cond) [ "deopt"() ]
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.inc, %be ]
  %iv.inc = add i32 %iv, 1

  %cond = load volatile i1, ptr %cond_buf
  br i1 %cond, label %left, label %be

left:
  ; Does not dominate the backedge, so cannot be used in the inductive proof
  %iv.inc.cmp = icmp slt i32 %iv.inc, %len
  call void(i1, ...) @llvm.experimental.guard(i1 %iv.inc.cmp) [ "deopt"() ]
  br label %be

be:

  %iv.cmp = icmp slt i32 %iv, %len
  call void(i1, ...) @llvm.experimental.guard(i1 %iv.cmp) [ "deopt"() ]

  %becond = load volatile i1, ptr %cond_buf
  br i1 %becond, label %loop, label %leave

leave:
  ret void
}
