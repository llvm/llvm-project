; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s --data-layout="e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128" -S -analyze -enable-new-pm=0 -scalar-evolution | FileCheck --check-prefixes=ALL,X64 %s
; RUN: opt < %s --data-layout="e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128" -S -disable-output "-passes=print<scalar-evolution>" 2>&1 | FileCheck --check-prefixes=ALL,X64 %s
; RUN: opt < %s --data-layout="e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128" -S -analyze -enable-new-pm=0 -scalar-evolution | FileCheck --check-prefixes=ALL,X32 %s
; RUN: opt < %s --data-layout="e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128" -S -disable-output "-passes=print<scalar-evolution>" 2>&1 | FileCheck --check-prefixes=ALL,X32 %s

; While we can't treat inttoptr/ptrtoint casts as fully transparent,
; for ptrtoint cast, instead of modelling it as fully opaque (unknown),
; we can at least model it as zext/trunc/self of an unknown,
; iff it it's argument would be modelled as unknown anyways.

declare void @useptr(i8*)

; Simple ptrtoint of an argument, with casts to potentially different bit widths.
define void @ptrtoint(i8* %in, i64* %out0, i32* %out1, i16* %out2, i128* %out3) {
; X64-LABEL: 'ptrtoint'
; X64-NEXT:  Classifying expressions for: @ptrtoint
; X64-NEXT:    %p0 = ptrtoint i8* %in to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:    %p1 = ptrtoint i8* %in to i32
; X64-NEXT:    --> %p1 U: full-set S: full-set
; X64-NEXT:    %p2 = ptrtoint i8* %in to i16
; X64-NEXT:    --> %p2 U: full-set S: full-set
; X64-NEXT:    %p3 = ptrtoint i8* %in to i128
; X64-NEXT:    --> %p3 U: [0,18446744073709551616) S: [-18446744073709551616,18446744073709551616)
; X64-NEXT:  Determining loop execution counts for: @ptrtoint
;
; X32-LABEL: 'ptrtoint'
; X32-NEXT:  Classifying expressions for: @ptrtoint
; X32-NEXT:    %p0 = ptrtoint i8* %in to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:    %p1 = ptrtoint i8* %in to i32
; X32-NEXT:    --> %p1 U: full-set S: full-set
; X32-NEXT:    %p2 = ptrtoint i8* %in to i16
; X32-NEXT:    --> %p2 U: full-set S: full-set
; X32-NEXT:    %p3 = ptrtoint i8* %in to i128
; X32-NEXT:    --> %p3 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint
;
  %p0 = ptrtoint i8* %in to i64
  %p1 = ptrtoint i8* %in to i32
  %p2 = ptrtoint i8* %in to i16
  %p3 = ptrtoint i8* %in to i128
  store i64  %p0, i64*  %out0
  store i32  %p1, i32*  %out1
  store i16  %p2, i16*  %out2
  store i128 %p3, i128* %out3
  ret void
}

; Same, but from non-zero/non-default address space.
define void @ptrtoint_as1(i8 addrspace(1)* %in, i64* %out0, i32* %out1, i16* %out2, i128* %out3) {
; X64-LABEL: 'ptrtoint_as1'
; X64-NEXT:  Classifying expressions for: @ptrtoint_as1
; X64-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:    %p1 = ptrtoint i8 addrspace(1)* %in to i32
; X64-NEXT:    --> %p1 U: full-set S: full-set
; X64-NEXT:    %p2 = ptrtoint i8 addrspace(1)* %in to i16
; X64-NEXT:    --> %p2 U: full-set S: full-set
; X64-NEXT:    %p3 = ptrtoint i8 addrspace(1)* %in to i128
; X64-NEXT:    --> %p3 U: [0,18446744073709551616) S: [-18446744073709551616,18446744073709551616)
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_as1
;
; X32-LABEL: 'ptrtoint_as1'
; X32-NEXT:  Classifying expressions for: @ptrtoint_as1
; X32-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:    %p1 = ptrtoint i8 addrspace(1)* %in to i32
; X32-NEXT:    --> %p1 U: full-set S: full-set
; X32-NEXT:    %p2 = ptrtoint i8 addrspace(1)* %in to i16
; X32-NEXT:    --> %p2 U: full-set S: full-set
; X32-NEXT:    %p3 = ptrtoint i8 addrspace(1)* %in to i128
; X32-NEXT:    --> %p3 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_as1
;
  %p0 = ptrtoint i8 addrspace(1)* %in to i64
  %p1 = ptrtoint i8 addrspace(1)* %in to i32
  %p2 = ptrtoint i8 addrspace(1)* %in to i16
  %p3 = ptrtoint i8 addrspace(1)* %in to i128
  store i64  %p0, i64*  %out0
  store i32  %p1, i32*  %out1
  store i16  %p2, i16*  %out2
  store i128 %p3, i128* %out3
  ret void
}

; Likewise, ptrtoint of a bitcast is fine, we simply skip it.
define void @ptrtoint_of_bitcast(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_bitcast'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast
; X64-NEXT:    %in_casted = bitcast i8* %in to float*
; X64-NEXT:    --> %in U: full-set S: full-set
; X64-NEXT:    %p0 = ptrtoint float* %in_casted to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast
;
; X32-LABEL: 'ptrtoint_of_bitcast'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast
; X32-NEXT:    %in_casted = bitcast i8* %in to float*
; X32-NEXT:    --> %in U: full-set S: full-set
; X32-NEXT:    %p0 = ptrtoint float* %in_casted to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast
;
  %in_casted = bitcast i8* %in to float*
  %p0 = ptrtoint float* %in_casted to i64
  store i64 %p0, i64* %out0
  ret void
}

; addrspacecast is fine too, but We don't model addrspacecast, so we stop there.
define void @ptrtoint_of_addrspacecast(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_addrspacecast'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_addrspacecast
; X64-NEXT:    %in_casted = addrspacecast i8* %in to i8 addrspace(1)*
; X64-NEXT:    --> %in_casted U: full-set S: full-set
; X64-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in_casted to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_addrspacecast
;
; X32-LABEL: 'ptrtoint_of_addrspacecast'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_addrspacecast
; X32-NEXT:    %in_casted = addrspacecast i8* %in to i8 addrspace(1)*
; X32-NEXT:    --> %in_casted U: full-set S: full-set
; X32-NEXT:    %p0 = ptrtoint i8 addrspace(1)* %in_casted to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_addrspacecast
;
  %in_casted = addrspacecast i8* %in to i8 addrspace(1)*
  %p0 = ptrtoint i8 addrspace(1)* %in_casted to i64
  store i64 %p0, i64* %out0
  ret void
}

; inttoptr is fine too, but we don't (and can't) model inttoptr, so we stop there.
define void @ptrtoint_of_inttoptr(i64 %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_inttoptr'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_inttoptr
; X64-NEXT:    %in_casted = inttoptr i64 %in to i8*
; X64-NEXT:    --> %in_casted U: full-set S: full-set
; X64-NEXT:    %p0 = ptrtoint i8* %in_casted to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_inttoptr
;
; X32-LABEL: 'ptrtoint_of_inttoptr'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_inttoptr
; X32-NEXT:    %in_casted = inttoptr i64 %in to i8*
; X32-NEXT:    --> %in_casted U: full-set S: full-set
; X32-NEXT:    %p0 = ptrtoint i8* %in_casted to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_inttoptr
;
  %in_casted = inttoptr i64 %in to i8*
  %p0 = ptrtoint i8* %in_casted to i64
  store i64 %p0, i64* %out0
  ret void
}

; However, GEP is something SCEV knows how to model, so in this case ptrtoint
; can't be modelled as a cast, only as an unknown.
define void @ptrtoint_of_gep(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_gep'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_gep
; X64-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X64-NEXT:    --> (42 + %in)<nsw> U: [-9223372036854775766,-9223372036854775808) S: [-9223372036854775766,-9223372036854775808)
; X64-NEXT:    %p0 = ptrtoint i8* %in_adj to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_gep
;
; X32-LABEL: 'ptrtoint_of_gep'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_gep
; X32-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X32-NEXT:    --> (42 + %in)<nsw> U: [-2147483606,-2147483648) S: [-2147483606,-2147483648)
; X32-NEXT:    %p0 = ptrtoint i8* %in_adj to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_gep
;
  %in_adj = getelementptr inbounds i8, i8* %in, i64 42
  %p0 = ptrtoint i8* %in_adj to i64
  store i64  %p0, i64*  %out0
  ret void
}

; A constant pointer is fine
define void @ptrtoint_of_nullptr(i64* %out0) {
; ALL-LABEL: 'ptrtoint_of_nullptr'
; ALL-NEXT:  Classifying expressions for: @ptrtoint_of_nullptr
; ALL-NEXT:    %p0 = ptrtoint i8* null to i64
; ALL-NEXT:    --> %p0 U: [0,1) S: [-1,1)
; ALL-NEXT:  Determining loop execution counts for: @ptrtoint_of_nullptr
;
  %p0 = ptrtoint i8* null to i64
  store i64 %p0, i64* %out0
  ret void
}

; A constant inttoptr argument of an ptrtoint is still bad.
define void @ptrtoint_of_constantexpr_inttoptr(i64* %out0) {
; ALL-LABEL: 'ptrtoint_of_constantexpr_inttoptr'
; ALL-NEXT:  Classifying expressions for: @ptrtoint_of_constantexpr_inttoptr
; ALL-NEXT:    %p0 = ptrtoint i8* inttoptr (i64 42 to i8*) to i64
; ALL-NEXT:    --> %p0 U: [42,43) S: [-64,64)
; ALL-NEXT:  Determining loop execution counts for: @ptrtoint_of_constantexpr_inttoptr
;
  %p0 = ptrtoint i8* inttoptr (i64 42 to i8*) to i64
  store i64 %p0, i64* %out0
  ret void
}

; However, while bitcast would be fine, GEP we can model, so we are back
; to modelling the whole cast as unknown..
define void @ptrtoint_of_bitcast_of_gep(i8* %in, i64* %out0) {
; X64-LABEL: 'ptrtoint_of_bitcast_of_gep'
; X64-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast_of_gep
; X64-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X64-NEXT:    --> (42 + %in)<nsw> U: [-9223372036854775766,-9223372036854775808) S: [-9223372036854775766,-9223372036854775808)
; X64-NEXT:    %in_adj_casted = bitcast i8* %in_adj to float*
; X64-NEXT:    --> (42 + %in)<nsw> U: [-9223372036854775766,-9223372036854775808) S: [-9223372036854775766,-9223372036854775808)
; X64-NEXT:    %p0 = ptrtoint float* %in_adj_casted to i64
; X64-NEXT:    --> %p0 U: full-set S: full-set
; X64-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast_of_gep
;
; X32-LABEL: 'ptrtoint_of_bitcast_of_gep'
; X32-NEXT:  Classifying expressions for: @ptrtoint_of_bitcast_of_gep
; X32-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; X32-NEXT:    --> (42 + %in)<nsw> U: [-2147483606,-2147483648) S: [-2147483606,-2147483648)
; X32-NEXT:    %in_adj_casted = bitcast i8* %in_adj to float*
; X32-NEXT:    --> (42 + %in)<nsw> U: [-2147483606,-2147483648) S: [-2147483606,-2147483648)
; X32-NEXT:    %p0 = ptrtoint float* %in_adj_casted to i64
; X32-NEXT:    --> %p0 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:  Determining loop execution counts for: @ptrtoint_of_bitcast_of_gep
;
  %in_adj = getelementptr inbounds i8, i8* %in, i64 42
  %in_adj_casted = bitcast i8* %in_adj to float*
  %p0 = ptrtoint float* %in_adj_casted to i64
  store i64 %p0, i64* %out0
  ret void
}

; void pr46786_c26_char(char* start, char *end, char *other) {
;   for (char* cur = start; cur != end; ++cur)
;     other[cur - start] += *cur;
; }
define void @pr46786_c26_char(i8* %arg, i8* %arg1, i8* %arg2) {
; X64-LABEL: 'pr46786_c26_char'
; X64-NEXT:  Classifying expressions for: @pr46786_c26_char
; X64-NEXT:    %i4 = ptrtoint i8* %arg to i64
; X64-NEXT:    --> %i4 U: full-set S: full-set
; X64-NEXT:    %i7 = phi i8* [ %arg, %bb3 ], [ %i14, %bb6 ]
; X64-NEXT:    --> {%arg,+,1}<nuw><%bb6> U: full-set S: full-set Exits: (-1 + %arg1) LoopDispositions: { %bb6: Computable }
; X64-NEXT:    %i8 = load i8, i8* %i7, align 1
; X64-NEXT:    --> %i8 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i9 = ptrtoint i8* %i7 to i64
; X64-NEXT:    --> %i9 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i10 = sub i64 %i9, %i4
; X64-NEXT:    --> ((-1 * %i4) + %i9) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i11 = getelementptr inbounds i8, i8* %arg2, i64 %i10
; X64-NEXT:    --> ((-1 * %i4) + %i9 + %arg2) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i12 = load i8, i8* %i11, align 1
; X64-NEXT:    --> %i12 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i13 = add i8 %i12, %i8
; X64-NEXT:    --> (%i12 + %i8) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i14 = getelementptr inbounds i8, i8* %i7, i64 1
; X64-NEXT:    --> {(1 + %arg)<nsw>,+,1}<nuw><%bb6> U: full-set S: full-set Exits: %arg1 LoopDispositions: { %bb6: Computable }
; X64-NEXT:  Determining loop execution counts for: @pr46786_c26_char
; X64-NEXT:  Loop %bb6: backedge-taken count is (-1 + (-1 * %arg) + %arg1)
; X64-NEXT:  Loop %bb6: max backedge-taken count is -2
; X64-NEXT:  Loop %bb6: Predicated backedge-taken count is (-1 + (-1 * %arg) + %arg1)
; X64-NEXT:   Predicates:
; X64:       Loop %bb6: Trip multiple is 1
;
; X32-LABEL: 'pr46786_c26_char'
; X32-NEXT:  Classifying expressions for: @pr46786_c26_char
; X32-NEXT:    %i4 = ptrtoint i8* %arg to i64
; X32-NEXT:    --> %i4 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:    %i7 = phi i8* [ %arg, %bb3 ], [ %i14, %bb6 ]
; X32-NEXT:    --> {%arg,+,1}<nuw><%bb6> U: full-set S: full-set Exits: (-1 + %arg1) LoopDispositions: { %bb6: Computable }
; X32-NEXT:    %i8 = load i8, i8* %i7, align 1
; X32-NEXT:    --> %i8 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i9 = ptrtoint i8* %i7 to i64
; X32-NEXT:    --> %i9 U: [0,4294967296) S: [-4294967296,4294967296) Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i10 = sub i64 %i9, %i4
; X32-NEXT:    --> ((-1 * %i4)<nsw> + %i9) U: [-4294967295,4294967296) S: [-8589934591,8589934592) Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i11 = getelementptr inbounds i8, i8* %arg2, i64 %i10
; X32-NEXT:    --> ((trunc i64 %i9 to i32) + (-1 * (trunc i64 %i4 to i32)) + %arg2) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i12 = load i8, i8* %i11, align 1
; X32-NEXT:    --> %i12 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i13 = add i8 %i12, %i8
; X32-NEXT:    --> (%i12 + %i8) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i14 = getelementptr inbounds i8, i8* %i7, i64 1
; X32-NEXT:    --> {(1 + %arg)<nsw>,+,1}<nuw><%bb6> U: full-set S: full-set Exits: %arg1 LoopDispositions: { %bb6: Computable }
; X32-NEXT:  Determining loop execution counts for: @pr46786_c26_char
; X32-NEXT:  Loop %bb6: backedge-taken count is (-1 + (-1 * %arg) + %arg1)
; X32-NEXT:  Loop %bb6: max backedge-taken count is -2
; X32-NEXT:  Loop %bb6: Predicated backedge-taken count is (-1 + (-1 * %arg) + %arg1)
; X32-NEXT:   Predicates:
; X32:       Loop %bb6: Trip multiple is 1
;
  %i = icmp eq i8* %arg, %arg1
  br i1 %i, label %bb5, label %bb3

bb3:
  %i4 = ptrtoint i8* %arg to i64
  br label %bb6

bb6:
  %i7 = phi i8* [ %arg, %bb3 ], [ %i14, %bb6 ]
  %i8 = load i8, i8* %i7
  %i9 = ptrtoint i8* %i7 to i64
  %i10 = sub i64 %i9, %i4
  %i11 = getelementptr inbounds i8, i8* %arg2, i64 %i10
  %i12 = load i8, i8* %i11
  %i13 = add i8 %i12, %i8
  store i8 %i13, i8* %i11
  %i14 = getelementptr inbounds i8, i8* %i7, i64 1
  %i15 = icmp eq i8* %i14, %arg1
  br i1 %i15, label %bb5, label %bb6

bb5:
  ret void
}

; void pr46786_c26_int(int* start, int *end, int *other) {
;   for (int* cur = start; cur != end; ++cur)
;     other[cur - start] += *cur;
; }
;
; FIXME: 4 * (%i10 EXACT/s 4) is just %i10
define void @pr46786_c26_int(i32* %arg, i32* %arg1, i32* %arg2) {
; X64-LABEL: 'pr46786_c26_int'
; X64-NEXT:  Classifying expressions for: @pr46786_c26_int
; X64-NEXT:    %i4 = ptrtoint i32* %arg to i64
; X64-NEXT:    --> %i4 U: full-set S: full-set
; X64-NEXT:    %i7 = phi i32* [ %arg, %bb3 ], [ %i15, %bb6 ]
; X64-NEXT:    --> {%arg,+,4}<nuw><%bb6> U: full-set S: full-set Exits: ((4 * ((-4 + (-1 * %arg) + %arg1) /u 4))<nuw> + %arg) LoopDispositions: { %bb6: Computable }
; X64-NEXT:    %i8 = load i32, i32* %i7, align 4
; X64-NEXT:    --> %i8 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i9 = ptrtoint i32* %i7 to i64
; X64-NEXT:    --> %i9 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i10 = sub i64 %i9, %i4
; X64-NEXT:    --> ((-1 * %i4) + %i9) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i11 = ashr exact i64 %i10, 2
; X64-NEXT:    --> (((((-1 * %i4) + %i9) smax ((-1 * %i9) + %i4)) /u 4) * (1 smin (-1 smax ((-1 * %i4) + %i9))))<nsw> U: [-4611686018427387903,4611686018427387904) S: [-4611686018427387903,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i12 = getelementptr inbounds i32, i32* %arg2, i64 %i11
; X64-NEXT:    --> ((4 * ((((-1 * %i4) + %i9) smax ((-1 * %i9) + %i4)) /u 4) * (1 smin (-1 smax ((-1 * %i4) + %i9)))) + %arg2)<nsw> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i13 = load i32, i32* %i12, align 4
; X64-NEXT:    --> %i13 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i14 = add nsw i32 %i13, %i8
; X64-NEXT:    --> (%i13 + %i8) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X64-NEXT:    %i15 = getelementptr inbounds i32, i32* %i7, i64 1
; X64-NEXT:    --> {(4 + %arg)<nsw>,+,4}<nuw><%bb6> U: full-set S: full-set Exits: (4 + (4 * ((-4 + (-1 * %arg) + %arg1) /u 4))<nuw> + %arg) LoopDispositions: { %bb6: Computable }
; X64-NEXT:  Determining loop execution counts for: @pr46786_c26_int
; X64-NEXT:  Loop %bb6: backedge-taken count is ((-4 + (-1 * %arg) + %arg1) /u 4)
; X64-NEXT:  Loop %bb6: max backedge-taken count is 4611686018427387903
; X64-NEXT:  Loop %bb6: Predicated backedge-taken count is ((-4 + (-1 * %arg) + %arg1) /u 4)
; X64-NEXT:   Predicates:
; X64:       Loop %bb6: Trip multiple is 1
;
; X32-LABEL: 'pr46786_c26_int'
; X32-NEXT:  Classifying expressions for: @pr46786_c26_int
; X32-NEXT:    %i4 = ptrtoint i32* %arg to i64
; X32-NEXT:    --> %i4 U: [0,4294967296) S: [-4294967296,4294967296)
; X32-NEXT:    %i7 = phi i32* [ %arg, %bb3 ], [ %i15, %bb6 ]
; X32-NEXT:    --> {%arg,+,4}<nuw><%bb6> U: full-set S: full-set Exits: ((4 * ((-4 + (-1 * %arg) + %arg1) /u 4))<nuw> + %arg) LoopDispositions: { %bb6: Computable }
; X32-NEXT:    %i8 = load i32, i32* %i7, align 4
; X32-NEXT:    --> %i8 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i9 = ptrtoint i32* %i7 to i64
; X32-NEXT:    --> %i9 U: [0,4294967296) S: [-4294967296,4294967296) Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i10 = sub i64 %i9, %i4
; X32-NEXT:    --> ((-1 * %i4)<nsw> + %i9) U: [-4294967295,4294967296) S: [-8589934591,8589934592) Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i11 = ashr exact i64 %i10, 2
; X32-NEXT:    --> (((((-1 * %i4)<nsw> + %i9) smax ((-1 * %i9)<nsw> + %i4)) /u 4) * (1 smin (-1 smax ((-1 * %i4)<nsw> + %i9))))<nsw> U: [-4611686018427387903,4611686018427387904) S: [-4611686018427387903,4611686018427387904) Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i12 = getelementptr inbounds i32, i32* %arg2, i64 %i11
; X32-NEXT:    --> ((4 * (trunc i64 (((((-1 * %i4)<nsw> + %i9) smax ((-1 * %i9)<nsw> + %i4)) /u 4) * (1 smin (-1 smax ((-1 * %i4)<nsw> + %i9))))<nsw> to i32))<nsw> + %arg2)<nsw> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i13 = load i32, i32* %i12, align 4
; X32-NEXT:    --> %i13 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i14 = add nsw i32 %i13, %i8
; X32-NEXT:    --> (%i13 + %i8) U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %bb6: Variant }
; X32-NEXT:    %i15 = getelementptr inbounds i32, i32* %i7, i64 1
; X32-NEXT:    --> {(4 + %arg)<nsw>,+,4}<nuw><%bb6> U: full-set S: full-set Exits: (4 + (4 * ((-4 + (-1 * %arg) + %arg1) /u 4))<nuw> + %arg) LoopDispositions: { %bb6: Computable }
; X32-NEXT:  Determining loop execution counts for: @pr46786_c26_int
; X32-NEXT:  Loop %bb6: backedge-taken count is ((-4 + (-1 * %arg) + %arg1) /u 4)
; X32-NEXT:  Loop %bb6: max backedge-taken count is 1073741823
; X32-NEXT:  Loop %bb6: Predicated backedge-taken count is ((-4 + (-1 * %arg) + %arg1) /u 4)
; X32-NEXT:   Predicates:
; X32:       Loop %bb6: Trip multiple is 1
;
  %i = icmp eq i32* %arg, %arg1
  br i1 %i, label %bb5, label %bb3

bb3:
  %i4 = ptrtoint i32* %arg to i64
  br label %bb6

bb6:
  %i7 = phi i32* [ %arg, %bb3 ], [ %i15, %bb6 ]
  %i8 = load i32, i32* %i7
  %i9 = ptrtoint i32* %i7 to i64
  %i10 = sub i64 %i9, %i4
  %i11 = ashr exact i64 %i10, 2
  %i12 = getelementptr inbounds i32, i32* %arg2, i64 %i11
  %i13 = load i32, i32* %i12
  %i14 = add nsw i32 %i13, %i8
  store i32 %i14, i32* %i12
  %i15 = getelementptr inbounds i32, i32* %i7, i64 1
  %i16 = icmp eq i32* %i15, %arg1
  br i1 %i16, label %bb5, label %bb6

bb5:
  ret void
}
