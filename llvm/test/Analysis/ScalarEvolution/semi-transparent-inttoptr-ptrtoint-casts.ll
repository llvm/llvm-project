; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -S -analyze -enable-new-pm=0 -scalar-evolution | FileCheck %s
; RUN: opt < %s -S -disable-output "-passes=print<scalar-evolution>" 2>&1 | FileCheck %s

; While we can't treat inttoptr/ptrtoint casts as fully transparent,
; instead of modelling them as fully opaque (unknown), we can at least model
; their source values are opaque (unknown). Which, given e.g.:
;   %x = ???
;   %y = inttoptr %x
;   %z = inttoptr %x
; at least allows us to tell that %y and %z are identical.
; Note that we must stop at that, we can not further analyze %x itself.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

define dso_local void @ptrtoint(i8* %in, i64* %out0, i64* %out1, i32* %out2, i128* %out3) {
; CHECK-LABEL: 'ptrtoint'
; CHECK-NEXT:  Classifying expressions for: @ptrtoint
; CHECK-NEXT:    %in_adj = getelementptr inbounds i8, i8* %in, i64 42
; CHECK-NEXT:    --> (42 + %in)<nsw> U: [-9223372036854775766,-9223372036854775808) S: [-9223372036854775766,-9223372036854775808)
; CHECK-NEXT:    %p0 = ptrtoint i8* %in_adj to i64
; CHECK-NEXT:    --> %p0 U: full-set S: full-set
; CHECK-NEXT:    %p1 = ptrtoint i8* %in_adj to i64
; CHECK-NEXT:    --> %p1 U: full-set S: full-set
; CHECK-NEXT:    %p2 = ptrtoint i8* %in_adj to i32
; CHECK-NEXT:    --> %p2 U: full-set S: full-set
; CHECK-NEXT:    %p3 = ptrtoint i8* %in_adj to i128
; CHECK-NEXT:    --> %p3 U: [0,18446744073709551616) S: [-18446744073709551616,18446744073709551616)
; CHECK-NEXT:  Determining loop execution counts for: @ptrtoint
;
  %in_adj = getelementptr inbounds i8, i8* %in, i64 42
  %p0 = ptrtoint i8* %in_adj to i64
  %p1 = ptrtoint i8* %in_adj to i64
  %p2 = ptrtoint i8* %in_adj to i32
  %p3 = ptrtoint i8* %in_adj to i128
  store i64  %p0, i64* %out0
  store i64  %p1, i64* %out1
  store i32  %p2, i32* %out2
  store i128 %p3, i128* %out3
  ret void
}

define dso_local void @inttoptr(i64 %in0, i8** %out0, i8** %out1) {
; CHECK-LABEL: 'inttoptr'
; CHECK-NEXT:  Classifying expressions for: @inttoptr
; CHECK-NEXT:    %in_adj = add i64 %in0, 42
; CHECK-NEXT:    --> (42 + %in0) U: full-set S: full-set
; CHECK-NEXT:    %i0 = inttoptr i64 %in_adj to i8*
; CHECK-NEXT:    --> %i0 U: full-set S: full-set
; CHECK-NEXT:    %i1 = inttoptr i64 %in_adj to i8*
; CHECK-NEXT:    --> %i1 U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @inttoptr
;
  %in_adj = add i64 %in0, 42
  %i0 = inttoptr i64 %in_adj to i8*
  %i1 = inttoptr i64 %in_adj to i8*
  store i8* %i0, i8** %out0
  store i8* %i1, i8** %out1
  ret void
}
define dso_local void @inttoptr_widening(i32 %in1, i8** %out2) {
; CHECK-LABEL: 'inttoptr_widening'
; CHECK-NEXT:  Classifying expressions for: @inttoptr_widening
; CHECK-NEXT:    %in_adj = add i32 %in1, 42
; CHECK-NEXT:    --> (42 + %in1) U: full-set S: full-set
; CHECK-NEXT:    %i0 = inttoptr i32 %in_adj to i8*
; CHECK-NEXT:    --> %i0 U: [0,4294967296) S: [-4294967296,4294967296)
; CHECK-NEXT:  Determining loop execution counts for: @inttoptr_widening
;
  %in_adj = add i32 %in1, 42
  %i0 = inttoptr i32 %in_adj to i8*
  store i8* %i0, i8** %out2
  ret void
}
define dso_local void @inttoptr_narrowing(i128 %in2, i8** %out3) {
; CHECK-LABEL: 'inttoptr_narrowing'
; CHECK-NEXT:  Classifying expressions for: @inttoptr_narrowing
; CHECK-NEXT:    %in_adj = add i128 %in2, 42
; CHECK-NEXT:    --> (42 + %in2) U: full-set S: full-set
; CHECK-NEXT:    %i0 = inttoptr i128 %in_adj to i8*
; CHECK-NEXT:    --> %i0 U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @inttoptr_narrowing
;
  %in_adj = add i128 %in2, 42
  %i0 = inttoptr i128 %in_adj to i8*
  store i8* %i0, i8** %out3
  ret void
}

; Note that we never try to analyze the value of the ptrtoint/inttoptr!
define i8* @onlysemitransparency(i8* %in) {
; CHECK-LABEL: 'onlysemitransparency'
; CHECK-NEXT:  Classifying expressions for: @onlysemitransparency
; CHECK-NEXT:    %i0 = ptrtoint i8* %in to i64
; CHECK-NEXT:    --> %i0 U: full-set S: full-set
; CHECK-NEXT:    %i1 = inttoptr i64 %i0 to i8*
; CHECK-NEXT:    --> %i1 U: full-set S: full-set
; CHECK-NEXT:    %i2 = ptrtoint i8* %i1 to i64
; CHECK-NEXT:    --> %i2 U: full-set S: full-set
; CHECK-NEXT:    %i3 = inttoptr i64 %i2 to i8*
; CHECK-NEXT:    --> %i3 U: full-set S: full-set
; CHECK-NEXT:    %i4 = ptrtoint i8* %i3 to i64
; CHECK-NEXT:    --> %i4 U: full-set S: full-set
; CHECK-NEXT:    %i5 = inttoptr i64 %i4 to i8*
; CHECK-NEXT:    --> %i5 U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @onlysemitransparency
;
  %i0 = ptrtoint i8* %in to i64
  %i1 = inttoptr i64 %i0 to i8*
  %i2 = ptrtoint i8* %i1 to i64
  %i3 = inttoptr i64 %i2 to i8*
  %i4 = ptrtoint i8* %i3 to i64
  %i5 = inttoptr i64 %i4 to i8*
  ret i8* %i5
}
