; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 2
; RUN: opt -disable-output "-passes=print<scalar-evolution>" < %s 2>&1 | FileCheck %s

declare i1 @use(i64)

define void @f_0() {
; CHECK-LABEL: 'f_0'
; CHECK-NEXT:  Classifying expressions for: @f_0
; CHECK-NEXT:    %iv = phi i32 [ 0, %entry ], [ %iv.inc.nowrap, %be ]
; CHECK-NEXT:    --> {0,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.inc.maywrap = add i32 %iv, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.inc.maywrap.sext = sext i32 %iv.inc.maywrap to i64
; CHECK-NEXT:    --> (sext i32 {1,+,1}<%loop> to i64) U: [-2147483648,2147483648) S: [-2147483648,2147483648) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %cond0 = call i1 @use(i64 %iv.inc.maywrap.sext)
; CHECK-NEXT:    --> %cond0 U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:    %iv.inc.nowrap = add nsw i32 %iv, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %be.cond = call i1 @use(i64 0)
; CHECK-NEXT:    --> %be.cond U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:  Determining loop execution counts for: @f_0
; CHECK-NEXT:  Loop %loop: <multiple exits> Unpredictable backedge-taken count.
; CHECK-NEXT:    exit count for loop: ***COULDNOTCOMPUTE***
; CHECK-NEXT:    exit count for be: ***COULDNOTCOMPUTE***
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
; CHECK-NEXT:    symbolic max exit count for loop: ***COULDNOTCOMPUTE***
; CHECK-NEXT:    symbolic max exit count for be: ***COULDNOTCOMPUTE***
; CHECK-NEXT:  Loop %loop: Unpredictable predicated backedge-taken count.
;

entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.inc.nowrap, %be ]
  %iv.inc.maywrap = add i32 %iv, 1
  %iv.inc.maywrap.sext = sext i32 %iv.inc.maywrap to i64
  %cond0 = call i1 @use(i64 %iv.inc.maywrap.sext)
  br i1 %cond0, label %be, label %leave

be:
  %iv.inc.nowrap = add nsw i32 %iv, 1
  %be.cond = call i1 @use(i64 0) ;; Get an unanalyzable value
  br i1 %be.cond, label %loop, label %leave

leave:
  ret void
}
