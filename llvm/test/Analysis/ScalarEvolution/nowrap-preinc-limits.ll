; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 2
; RUN: opt -disable-output "-passes=print<scalar-evolution>" < %s 2>&1 | FileCheck %s

define void @f(ptr %condition) {
; CHECK-LABEL: 'f'
; CHECK-NEXT:  Classifying expressions for: @f
; CHECK-NEXT:    %idx = phi i32 [ 0, %entry ], [ %idx.inc, %loop ]
; CHECK-NEXT:    --> {0,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %idx.inc = add nsw i32 %idx, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %idx.inc2 = add i32 %idx.inc, 1
; CHECK-NEXT:    --> {2,+,1}<%loop> U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %idx.inc2.zext = zext i32 %idx.inc2 to i64
; CHECK-NEXT:    --> (zext i32 {2,+,1}<%loop> to i64) U: [0,4294967296) S: [0,4294967296) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %c = load volatile i1, ptr %condition, align 1
; CHECK-NEXT:    --> %c U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:  Determining loop execution counts for: @f
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable predicated backedge-taken count.
;
  entry:
  br label %loop

  loop:
  %idx = phi i32 [ 0, %entry ], [ %idx.inc, %loop ]
  %idx.inc = add nsw i32 %idx, 1

  %idx.inc2 = add i32 %idx.inc, 1
  %idx.inc2.zext = zext i32 %idx.inc2 to i64


  %c = load volatile i1, ptr %condition
  br i1 %c, label %loop, label %exit

  exit:
  ret void
}

define void @g(ptr %condition) {
; CHECK-LABEL: 'g'
; CHECK-NEXT:  Classifying expressions for: @g
; CHECK-NEXT:    %idx = phi i32 [ 0, %entry ], [ %idx.inc, %loop ]
; CHECK-NEXT:    --> {0,+,3}<nuw><nsw><%loop> U: [0,-2147483648) S: [0,-2147483648) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %idx.inc = add nsw i32 %idx, 3
; CHECK-NEXT:    --> {3,+,3}<nuw><nsw><%loop> U: [3,-2147483648) S: [3,-2147483648) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %idx.inc2 = add i32 %idx.inc, -1
; CHECK-NEXT:    --> {2,+,3}<nuw><nsw><%loop> U: [2,-2147483648) S: [2,-2147483648) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %idx.inc2.sext = sext i32 %idx.inc2 to i64
; CHECK-NEXT:    --> {2,+,3}<nuw><nsw><%loop> U: [2,-9223372036854775808) S: [2,-9223372036854775808) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %cond.gep = getelementptr inbounds i1, ptr %condition, i32 %idx.inc
; CHECK-NEXT:    --> {(3 + %condition)<nuw>,+,3}<nuw><%loop> U: [3,0) S: [3,0) Exits: <<Unknown>> LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %c = load volatile i1, ptr %cond.gep, align 1
; CHECK-NEXT:    --> %c U: full-set S: full-set Exits: <<Unknown>> LoopDispositions: { %loop: Variant }
; CHECK-NEXT:  Determining loop execution counts for: @g
; CHECK-NEXT:  Loop %loop: Unpredictable backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable constant max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable symbolic max backedge-taken count.
; CHECK-NEXT:  Loop %loop: Unpredictable predicated backedge-taken count.
;
  entry:
  br label %loop

  loop:
  %idx = phi i32 [ 0, %entry ], [ %idx.inc, %loop ]
  %idx.inc = add nsw i32 %idx, 3

  %idx.inc2 = add i32 %idx.inc, -1
  %idx.inc2.sext = sext i32 %idx.inc2 to i64

  %cond.gep = getelementptr inbounds i1, ptr %condition, i32 %idx.inc
  %c = load volatile i1, ptr %cond.gep
  br i1 %c, label %loop, label %exit

  exit:
  ret void
}
