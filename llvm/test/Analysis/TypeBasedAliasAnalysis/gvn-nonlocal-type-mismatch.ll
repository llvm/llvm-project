; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -aa-pipeline=tbaa,basic-aa -passes=gvn -S < %s | FileCheck %s --check-prefixes=CHECK,CHECK-MEMDEP
; RUN: opt -aa-pipeline=tbaa,basic-aa -passes='gvn<memoryssa>' -S < %s | FileCheck %s --check-prefixes=CHECK,CHECK-MEMSSA

target datalayout = "e-p:64:64:64"

; GVN should ignore the store to p1 to see that the load from p is
; fully redundant.

define void @yes(i1 %c, ptr %p, ptr %p1, ptr %q) nounwind {
; CHECK-MEMDEP-LABEL: define void @yes(
; CHECK-MEMDEP-SAME: i1 [[C:%.*]], ptr [[P:%.*]], ptr [[P1:%.*]], ptr [[Q:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-MEMDEP-NEXT:  [[ENTRY:.*:]]
; CHECK-MEMDEP-NEXT:    store i32 0, ptr [[P]], align 4, !tbaa [[RED_TBAA0:![0-9]+]]
; CHECK-MEMDEP-NEXT:    store i32 1, ptr [[P1]], align 4, !tbaa [[BLU_TBAA3:![0-9]+]]
; CHECK-MEMDEP-NEXT:    br i1 [[C]], label %[[IF_ELSE:.*]], label %[[IF_THEN:.*]]
; CHECK-MEMDEP:       [[IF_THEN]]:
; CHECK-MEMDEP-NEXT:    store i32 0, ptr [[Q]], align 4
; CHECK-MEMDEP-NEXT:    ret void
; CHECK-MEMDEP:       [[IF_ELSE]]:
; CHECK-MEMDEP-NEXT:    ret void
;
; CHECK-MEMSSA-LABEL: define void @yes(
; CHECK-MEMSSA-SAME: i1 [[C:%.*]], ptr [[P:%.*]], ptr [[P1:%.*]], ptr [[Q:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-MEMSSA-NEXT:  [[ENTRY:.*:]]
; CHECK-MEMSSA-NEXT:    store i32 0, ptr [[P]], align 4, !tbaa [[RED_TBAA0:![0-9]+]]
; CHECK-MEMSSA-NEXT:    store i32 1, ptr [[P1]], align 4, !tbaa [[BLU_TBAA3:![0-9]+]]
; CHECK-MEMSSA-NEXT:    br i1 [[C]], label %[[IF_ELSE:.*]], label %[[IF_THEN:.*]]
; CHECK-MEMSSA:       [[IF_THEN]]:
; CHECK-MEMSSA-NEXT:    [[T:%.*]] = load i32, ptr [[P]], align 4, !tbaa [[RED_TBAA0]]
; CHECK-MEMSSA-NEXT:    store i32 [[T]], ptr [[Q]], align 4
; CHECK-MEMSSA-NEXT:    ret void
; CHECK-MEMSSA:       [[IF_ELSE]]:
; CHECK-MEMSSA-NEXT:    ret void
;
entry:
  store i32 0, ptr %p, !tbaa !1
  store i32 1, ptr %p1, !tbaa !2
  br i1 %c, label %if.else, label %if.then

if.then:
  %t = load i32, ptr %p, !tbaa !1
  store i32 %t, ptr %q
  ret void

if.else:
  ret void
}

; GVN should ignore the store to p1 to see that the first load from p is
; fully redundant. However, the second load uses a different type. Theoretically
; the other type could be unified with the first type, however for now, GVN
; should just be conservative.

define void @watch_out_for_type_change(i1 %c, ptr %p, ptr %p1, ptr %q) nounwind {
; CHECK-LABEL: define void @watch_out_for_type_change(
; CHECK-SAME: i1 [[C:%.*]], ptr [[P:%.*]], ptr [[P1:%.*]], ptr [[Q:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    store i32 0, ptr [[P]], align 4, !tbaa [[RED_TBAA0:![0-9]+]]
; CHECK-NEXT:    store i32 1, ptr [[P1]], align 4, !tbaa [[BLU_TBAA3:![0-9]+]]
; CHECK-NEXT:    br i1 [[C]], label %[[IF_ELSE:.*]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[T:%.*]] = load i32, ptr [[P]], align 4, !tbaa [[OUTER_SPACE_TBAA5:![0-9]+]]
; CHECK-NEXT:    store i32 [[T]], ptr [[Q]], align 4
; CHECK-NEXT:    ret void
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    [[U:%.*]] = load i32, ptr [[P]], align 4, !tbaa [[BRICK_RED_TBAA8:![0-9]+]]
; CHECK-NEXT:    store i32 [[U]], ptr [[Q]], align 4
; CHECK-NEXT:    ret void
;
entry:
  store i32 0, ptr %p, !tbaa !1
  store i32 1, ptr %p1, !tbaa !2
  br i1 %c, label %if.else, label %if.then

if.then:
  %t = load i32, ptr %p, !tbaa !3
  store i32 %t, ptr %q
  ret void

if.else:
  %u = load i32, ptr %p, !tbaa !4
  store i32 %u, ptr %q
  ret void
}

; As before, but the types are swapped. This time GVN does managed to
; eliminate one of the loads before noticing the type mismatch.

define void @watch_out_for_another_type_change(i1 %c, ptr %p, ptr %p1, ptr %q) nounwind {
; CHECK-MEMDEP-LABEL: define void @watch_out_for_another_type_change(
; CHECK-MEMDEP-SAME: i1 [[C:%.*]], ptr [[P:%.*]], ptr [[P1:%.*]], ptr [[Q:%.*]]) #[[ATTR0]] {
; CHECK-MEMDEP-NEXT:  [[ENTRY:.*:]]
; CHECK-MEMDEP-NEXT:    store i32 0, ptr [[P]], align 4, !tbaa [[RED_TBAA0]]
; CHECK-MEMDEP-NEXT:    store i32 1, ptr [[P1]], align 4, !tbaa [[BLU_TBAA3]]
; CHECK-MEMDEP-NEXT:    br i1 [[C]], label %[[IF_ELSE:.*]], label %[[IF_THEN:.*]]
; CHECK-MEMDEP:       [[IF_THEN]]:
; CHECK-MEMDEP-NEXT:    store i32 0, ptr [[Q]], align 4
; CHECK-MEMDEP-NEXT:    ret void
; CHECK-MEMDEP:       [[IF_ELSE]]:
; CHECK-MEMDEP-NEXT:    [[U:%.*]] = load i32, ptr [[P]], align 4, !tbaa [[OUTER_SPACE_TBAA5]]
; CHECK-MEMDEP-NEXT:    store i32 [[U]], ptr [[Q]], align 4
; CHECK-MEMDEP-NEXT:    ret void
;
; CHECK-MEMSSA-LABEL: define void @watch_out_for_another_type_change(
; CHECK-MEMSSA-SAME: i1 [[C:%.*]], ptr [[P:%.*]], ptr [[P1:%.*]], ptr [[Q:%.*]]) #[[ATTR0]] {
; CHECK-MEMSSA-NEXT:  [[ENTRY:.*:]]
; CHECK-MEMSSA-NEXT:    store i32 0, ptr [[P]], align 4, !tbaa [[RED_TBAA0]]
; CHECK-MEMSSA-NEXT:    store i32 1, ptr [[P1]], align 4, !tbaa [[BLU_TBAA3]]
; CHECK-MEMSSA-NEXT:    br i1 [[C]], label %[[IF_ELSE:.*]], label %[[IF_THEN:.*]]
; CHECK-MEMSSA:       [[IF_THEN]]:
; CHECK-MEMSSA-NEXT:    [[T:%.*]] = load i32, ptr [[P]], align 4, !tbaa [[BRICK_RED_TBAA8]]
; CHECK-MEMSSA-NEXT:    store i32 [[T]], ptr [[Q]], align 4
; CHECK-MEMSSA-NEXT:    ret void
; CHECK-MEMSSA:       [[IF_ELSE]]:
; CHECK-MEMSSA-NEXT:    [[U:%.*]] = load i32, ptr [[P]], align 4, !tbaa [[OUTER_SPACE_TBAA5]]
; CHECK-MEMSSA-NEXT:    store i32 [[U]], ptr [[Q]], align 4
; CHECK-MEMSSA-NEXT:    ret void
;
entry:
  store i32 0, ptr %p, !tbaa !1
  store i32 1, ptr %p1, !tbaa !2
  br i1 %c, label %if.else, label %if.then

if.then:
  %t = load i32, ptr %p, !tbaa !4
  store i32 %t, ptr %q
  ret void

if.else:
  %u = load i32, ptr %p, !tbaa !3
  store i32 %u, ptr %q
  ret void
}

!0 = !{}
!1 = !{!5, !5, i64 0}
!2 = !{!6, !6, i64 0}
!3 = !{!7, !7, i64 0}
!4 = !{!8, !8, i64 0}
!5 = !{!"red", !0}
!6 = !{!"blu", !0}
!7 = !{!"outer space", !9}
!8 = !{!"brick red", !5}
!9 = !{!"observable universe"}
;.
; CHECK-MEMDEP: [[RED_TBAA0]] = !{[[META1:![0-9]+]], [[META1]], i64 0}
; CHECK-MEMDEP: [[META1]] = !{!"red", [[META2:![0-9]+]]}
; CHECK-MEMDEP: [[META2]] = !{}
; CHECK-MEMDEP: [[BLU_TBAA3]] = !{[[META4:![0-9]+]], [[META4]], i64 0}
; CHECK-MEMDEP: [[META4]] = !{!"blu", [[META2]]}
; CHECK-MEMDEP: [[OUTER_SPACE_TBAA5]] = !{[[META6:![0-9]+]], [[META6]], i64 0}
; CHECK-MEMDEP: [[META6]] = !{!"outer space", [[META7:![0-9]+]]}
; CHECK-MEMDEP: [[META7]] = !{!"observable universe"}
; CHECK-MEMDEP: [[BRICK_RED_TBAA8]] = !{[[META9:![0-9]+]], [[META9]], i64 0}
; CHECK-MEMDEP: [[META9]] = !{!"brick red", [[META1]]}
;.
; CHECK-MEMSSA: [[RED_TBAA0]] = !{[[META1:![0-9]+]], [[META1]], i64 0}
; CHECK-MEMSSA: [[META1]] = !{!"red", [[META2:![0-9]+]]}
; CHECK-MEMSSA: [[META2]] = !{}
; CHECK-MEMSSA: [[BLU_TBAA3]] = !{[[META4:![0-9]+]], [[META4]], i64 0}
; CHECK-MEMSSA: [[META4]] = !{!"blu", [[META2]]}
; CHECK-MEMSSA: [[OUTER_SPACE_TBAA5]] = !{[[META6:![0-9]+]], [[META6]], i64 0}
; CHECK-MEMSSA: [[META6]] = !{!"outer space", [[META7:![0-9]+]]}
; CHECK-MEMSSA: [[META7]] = !{!"observable universe"}
; CHECK-MEMSSA: [[BRICK_RED_TBAA8]] = !{[[META9:![0-9]+]], [[META9]], i64 0}
; CHECK-MEMSSA: [[META9]] = !{!"brick red", [[META1]]}
;.
