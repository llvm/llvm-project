; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -aa-pipeline=tbaa,basic-aa -passes=memcpyopt,instcombine < %s | FileCheck %s

target datalayout = "e-p:64:64:64"

; The second memcpy is redundant and can be deleted. There's an intervening store, but
; it has a TBAA tag which declares that it is unrelated.

define void @foo(ptr nocapture %p, ptr nocapture %q, ptr nocapture %s) nounwind {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: ptr captures(none) [[P:%.*]], ptr captures(none) [[Q:%.*]], ptr captures(none) [[S:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(16) [[P]], ptr noundef nonnull align 1 dereferenceable(16) [[Q]], i64 16, i1 false), !tbaa [[B_TBAA0:![0-9]+]]
; CHECK-NEXT:    store i8 2, ptr [[S]], align 1, !tbaa [[A_TBAA3:![0-9]+]]
; CHECK-NEXT:    ret void
;
  tail call void @llvm.memcpy.p0.p0.i64(ptr %p, ptr %q, i64 16, i1 false), !tbaa !2
  store i8 2, ptr %s, align 1, !tbaa !1
  tail call void @llvm.memcpy.p0.p0.i64(ptr %q, ptr %p, i64 16, i1 false), !tbaa !2
  ret void
}

declare void @llvm.memcpy.p0.p0.i64(ptr nocapture, ptr nocapture, i64, i1) nounwind

!0 = !{!"tbaa root"}
!1 = !{!3, !3, i64 0}
!2 = !{!4, !4, i64 0}
!3 = !{!"A", !0}
!4 = !{!"B", !0}
;.
; CHECK: [[B_TBAA0]] = !{[[META1:![0-9]+]], [[META1]], i64 0}
; CHECK: [[META1]] = !{!"B", [[META2:![0-9]+]]}
; CHECK: [[META2]] = !{!"tbaa root"}
; CHECK: [[A_TBAA3]] = !{[[META4:![0-9]+]], [[META4]], i64 0}
; CHECK: [[META4]] = !{!"A", [[META2]]}
;.
