; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -alloc-limit-32bit=true -passes=instcombine < %s -S | FileCheck %s

define i1 @recursiveGEP_withPtrSubTrunc(ptr noundef %val1) {
; CHECK-LABEL: @recursiveGEP_withPtrSubTrunc(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq ptr [[VAL1:%.*]], null
; CHECK-NEXT:    br i1 [[CMP_I]], label [[_Z9STRINGLENPKS_EXIT:%.*]], label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[A_PN_I:%.*]] = phi ptr [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ], [ [[VAL1]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[A_PN_I]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[TEST_0_I]], align 2
; CHECK-NEXT:    [[CMP3_NOT_I:%.*]] = icmp eq i8 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP3_NOT_I]], label [[WHILE_END_I:%.*]], label [[WHILE_COND_I]]
; CHECK:       while.end.i:
; CHECK-NEXT:    br label [[_Z9STRINGLENPKS_EXIT]]
; CHECK:       _Z9stringlenPKs.exit:
; CHECK-NEXT:    ret i1 [[CMP_I]]
;
entry:
  %cmp.i = icmp eq ptr %val1, null
  br i1 %cmp.i, label %_Z9stringlenPKs.exit, label %while.cond.i

while.cond.i:
  %a.pn.i = phi ptr [ %test.0.i, %while.cond.i ], [ %val1, %entry ]
  %test.0.i = getelementptr inbounds i8, ptr %a.pn.i, i64 1
  %0 = load i8, ptr %test.0.i, align 2
  %cmp3.not.i = icmp eq i8 %0, 0
  br i1 %cmp3.not.i, label %while.end.i, label %while.cond.i

while.end.i:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %val1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv4 = trunc i64 %sub.ptr.sub.i to i32
  br label %_Z9stringlenPKs.exit

_Z9stringlenPKs.exit:
  %retval.0.i = phi i32 [ %conv4, %while.end.i ], [ 0, %entry ]
  %bool = icmp eq i32 %retval.0.i, 0
  ret i1 %bool
}

define i1 @recursiveGEP_withPtrSubAshrTrunc(ptr noundef %val1) {
; CHECK-LABEL: @recursiveGEP_withPtrSubAshrTrunc(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq ptr [[VAL1:%.*]], null
; CHECK-NEXT:    br i1 [[CMP_I]], label [[_Z9STRINGLENPKS_EXIT:%.*]], label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[A_PN_I:%.*]] = phi ptr [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ], [ [[VAL1]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[A_PN_I]], i64 2
; CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr [[TEST_0_I]], align 2
; CHECK-NEXT:    [[CMP3_NOT_I:%.*]] = icmp eq i16 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP3_NOT_I]], label [[WHILE_END_I:%.*]], label [[WHILE_COND_I]]
; CHECK:       while.end.i:
; CHECK-NEXT:    br label [[_Z9STRINGLENPKS_EXIT]]
; CHECK:       _Z9stringlenPKs.exit:
; CHECK-NEXT:    ret i1 [[CMP_I]]
;
entry:
  %cmp.i = icmp eq ptr %val1, null
  br i1 %cmp.i, label %_Z9stringlenPKs.exit, label %while.cond.i

while.cond.i:
  %a.pn.i = phi ptr [ %test.0.i, %while.cond.i ], [ %val1, %entry ]
  %test.0.i = getelementptr inbounds i16, ptr %a.pn.i, i64 1
  %0 = load i16, ptr %test.0.i, align 2
  %cmp3.not.i = icmp eq i16 %0, 0
  br i1 %cmp3.not.i, label %while.end.i, label %while.cond.i

while.end.i:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %val1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %sub.ptr.div = ashr exact i64 %sub.ptr.sub.i, 1
  %conv4 = trunc i64 %sub.ptr.div to i32
  br label %_Z9stringlenPKs.exit

_Z9stringlenPKs.exit:
  %retval.0.i = phi i32 [ %conv4, %while.end.i ], [ 0, %entry ]
  %bool = icmp eq i32 %retval.0.i, 0
  ret i1 %bool
}

define i1 @recursiveGEP_withPtrSubTrunc_StartNotEqualtoB(ptr noundef %val1) {
; CHECK-LABEL: @recursiveGEP_withPtrSubTrunc_StartNotEqualtoB(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq ptr [[VAL1:%.*]], null
; CHECK-NEXT:    br i1 [[CMP_I]], label [[_Z9STRINGLENPKS_EXIT:%.*]], label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[A_PN_I:%.*]] = phi ptr [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ], [ [[VAL1]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[A_PN_I]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[TEST_0_I]], align 2
; CHECK-NEXT:    [[CMP3_NOT_I:%.*]] = icmp eq i8 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP3_NOT_I]], label [[WHILE_END_I:%.*]], label [[WHILE_COND_I]]
; CHECK:       while.end.i:
; CHECK-NEXT:    [[SUB_PTR_LHS_CAST_I:%.*]] = ptrtoint ptr [[TEST_0_I]] to i64
; CHECK-NEXT:    [[TEST_1_I:%.*]] = getelementptr inbounds i8, ptr [[VAL1]], i64 -5
; CHECK-NEXT:    [[SUB_PTR_RHS_CAST_I:%.*]] = ptrtoint ptr [[TEST_1_I]] to i64
; CHECK-NEXT:    [[SUB_PTR_SUB_I:%.*]] = sub i64 [[SUB_PTR_LHS_CAST_I]], [[SUB_PTR_RHS_CAST_I]]
; CHECK-NEXT:    [[CONV4:%.*]] = trunc i64 [[SUB_PTR_SUB_I]] to i32
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[CONV4]], 0
; CHECK-NEXT:    br label [[_Z9STRINGLENPKS_EXIT]]
; CHECK:       _Z9stringlenPKs.exit:
; CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi i1 [ [[TMP1]], [[WHILE_END_I]] ], [ true, [[ENTRY]] ]
; CHECK-NEXT:    ret i1 [[RETVAL_0_I]]
;
entry:
  %cmp.i = icmp eq ptr %val1, null
  br i1 %cmp.i, label %_Z9stringlenPKs.exit, label %while.cond.i

while.cond.i:
  %a.pn.i = phi ptr [ %test.0.i, %while.cond.i ], [ %val1, %entry ]
  %test.0.i = getelementptr inbounds i8, ptr %a.pn.i, i64 1
  %0 = load i8, ptr %test.0.i, align 2
  %cmp3.not.i = icmp eq i8 %0, 0
  br i1 %cmp3.not.i, label %while.end.i, label %while.cond.i

while.end.i:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %test.1.i = getelementptr inbounds i8, ptr %val1, i64 -5
  %sub.ptr.rhs.cast.i = ptrtoint ptr %test.1.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv4 = trunc i64 %sub.ptr.sub.i to i32
  br label %_Z9stringlenPKs.exit

_Z9stringlenPKs.exit:
  %retval.0.i = phi i32 [ %conv4, %while.end.i ], [ 0, %entry ]
  %bool = icmp eq i32 %retval.0.i, 0
  ret i1 %bool
}

define i1 @recursiveGEP_withPtrSubTrunc_PhiOperandsCommuted(ptr noundef %val1) {
; CHECK-LABEL: @recursiveGEP_withPtrSubTrunc_PhiOperandsCommuted(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq ptr [[VAL1:%.*]], null
; CHECK-NEXT:    br i1 [[CMP_I]], label [[_Z9STRINGLENPKS_EXIT:%.*]], label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[A_PN_I:%.*]] = phi ptr [ [[VAL1]], [[ENTRY:%.*]] ], [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[A_PN_I]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[TEST_0_I]], align 2
; CHECK-NEXT:    [[CMP3_NOT_I:%.*]] = icmp eq i8 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP3_NOT_I]], label [[WHILE_END_I:%.*]], label [[WHILE_COND_I]]
; CHECK:       while.end.i:
; CHECK-NEXT:    br label [[_Z9STRINGLENPKS_EXIT]]
; CHECK:       _Z9stringlenPKs.exit:
; CHECK-NEXT:    ret i1 [[CMP_I]]
;
entry:
  %cmp.i = icmp eq ptr %val1, null
  br i1 %cmp.i, label %_Z9stringlenPKs.exit, label %while.cond.i

while.cond.i:
  %a.pn.i = phi ptr [ %val1, %entry ], [ %test.0.i, %while.cond.i ]
  %test.0.i = getelementptr inbounds i8, ptr %a.pn.i, i64 1
  %0 = load i8, ptr %test.0.i, align 2
  %cmp3.not.i = icmp eq i8 %0, 0
  br i1 %cmp3.not.i, label %while.end.i, label %while.cond.i

while.end.i:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %val1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv4 = trunc i64 %sub.ptr.sub.i to i32
  br label %_Z9stringlenPKs.exit

_Z9stringlenPKs.exit:
  %retval.0.i = phi i32 [ %conv4, %while.end.i ], [ 0, %entry ]
  %bool = icmp eq i32 %retval.0.i, 0
  ret i1 %bool
}

define i1 @recursiveGEP_withPtrSubTrunc_SubOperandsCommuted(ptr noundef %val1) {
; CHECK-LABEL: @recursiveGEP_withPtrSubTrunc_SubOperandsCommuted(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq ptr [[VAL1:%.*]], null
; CHECK-NEXT:    br i1 [[CMP_I]], label [[_Z9STRINGLENPKS_EXIT:%.*]], label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[A_PN_I:%.*]] = phi ptr [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ], [ [[VAL1]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[A_PN_I]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[TEST_0_I]], align 2
; CHECK-NEXT:    [[CMP3_NOT_I:%.*]] = icmp eq i8 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP3_NOT_I]], label [[WHILE_END_I:%.*]], label [[WHILE_COND_I]]
; CHECK:       while.end.i:
; CHECK-NEXT:    br label [[_Z9STRINGLENPKS_EXIT]]
; CHECK:       _Z9stringlenPKs.exit:
; CHECK-NEXT:    ret i1 [[CMP_I]]
;
entry:
  %cmp.i = icmp eq ptr %val1, null
  br i1 %cmp.i, label %_Z9stringlenPKs.exit, label %while.cond.i

while.cond.i:
  %a.pn.i = phi ptr [ %test.0.i, %while.cond.i ], [ %val1, %entry ]
  %test.0.i = getelementptr inbounds i8, ptr %a.pn.i, i64 1
  %0 = load i8, ptr %test.0.i, align 2
  %cmp3.not.i = icmp eq i8 %0, 0
  br i1 %cmp3.not.i, label %while.end.i, label %while.cond.i

while.end.i:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %val1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.rhs.cast.i, %sub.ptr.lhs.cast.i
  %conv4 = trunc i64 %sub.ptr.sub.i to i32
  br label %_Z9stringlenPKs.exit

_Z9stringlenPKs.exit:
  %retval.0.i = phi i32 [ %conv4, %while.end.i ], [ 0, %entry ]
  %bool = icmp eq i32 %retval.0.i, 0
  ret i1 %bool
}

define i1 @recursiveGEP_withPtrSubTrunc64to16(ptr noundef %val1) {
; CHECK-LABEL: @recursiveGEP_withPtrSubTrunc64to16(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq ptr [[VAL1:%.*]], null
; CHECK-NEXT:    br i1 [[CMP_I]], label [[_Z9STRINGLENPKS_EXIT:%.*]], label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[A_PN_I:%.*]] = phi ptr [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ], [ [[VAL1]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[A_PN_I]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[TEST_0_I]], align 2
; CHECK-NEXT:    [[CMP3_NOT_I:%.*]] = icmp eq i8 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP3_NOT_I]], label [[WHILE_END_I:%.*]], label [[WHILE_COND_I]]
; CHECK:       while.end.i:
; CHECK-NEXT:    [[SUB_PTR_LHS_CAST_I:%.*]] = ptrtoint ptr [[TEST_0_I]] to i64
; CHECK-NEXT:    [[SUB_PTR_RHS_CAST_I:%.*]] = ptrtoint ptr [[VAL1]] to i64
; CHECK-NEXT:    [[SUB_PTR_SUB_I:%.*]] = sub i64 [[SUB_PTR_LHS_CAST_I]], [[SUB_PTR_RHS_CAST_I]]
; CHECK-NEXT:    [[CONV4:%.*]] = trunc i64 [[SUB_PTR_SUB_I]] to i16
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i16 [[CONV4]], 0
; CHECK-NEXT:    br label [[_Z9STRINGLENPKS_EXIT]]
; CHECK:       _Z9stringlenPKs.exit:
; CHECK-NEXT:    [[RETVAL_0_I:%.*]] = phi i1 [ [[TMP1]], [[WHILE_END_I]] ], [ true, [[ENTRY]] ]
; CHECK-NEXT:    ret i1 [[RETVAL_0_I]]
;
entry:
  %cmp.i = icmp eq ptr %val1, null
  br i1 %cmp.i, label %_Z9stringlenPKs.exit, label %while.cond.i

while.cond.i:
  %a.pn.i = phi ptr [ %test.0.i, %while.cond.i ], [ %val1, %entry ]
  %test.0.i = getelementptr inbounds i8, ptr %a.pn.i, i64 1
  %0 = load i8, ptr %test.0.i, align 2
  %cmp3.not.i = icmp eq i8 %0, 0
  br i1 %cmp3.not.i, label %while.end.i, label %while.cond.i

while.end.i:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %val1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %conv4 = trunc i64 %sub.ptr.sub.i to i16
  br label %_Z9stringlenPKs.exit

_Z9stringlenPKs.exit:
  %retval.0.i = phi i16 [ %conv4, %while.end.i ], [ 0, %entry ]
  %bool = icmp eq i16 %retval.0.i, 0
  ret i1 %bool
}

%struct.Foo = type { [256 x i8] }
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)

define i1 @recursiveGEP_withPtrSubTrunc_knownObject() {
; CHECK-LABEL: @recursiveGEP_withPtrSubTrunc_knownObject(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[FOO:%.*]] = alloca [[STRUCT_FOO:%.*]], align 1
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 256, ptr nonnull [[FOO]])
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(256) [[FOO]], i8 97, i64 255, i1 false)
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[FOO]], i64 255
; CHECK-NEXT:    store i8 0, ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    br label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[F_PN_I:%.*]] = phi ptr [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ], [ [[FOO]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[F_PN_I]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[TEST_0_I]], align 1
; CHECK-NEXT:    [[CMP5_NOT_I:%.*]] = icmp eq i8 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP5_NOT_I]], label [[LEN_EXIT:%.*]], label [[WHILE_COND_I]]
; CHECK:       len.exit:
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 256, ptr nonnull [[FOO]])
; CHECK-NEXT:    ret i1 false
;
entry:
  %foo = alloca %struct.Foo, align 1
  call void @llvm.lifetime.start.p0(i64 256, ptr nonnull %foo)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(256) %foo, i8 97, i64 255, i1 false)
  %arrayidx = getelementptr inbounds [256 x i8], ptr %foo, i64 0, i64 255
  store i8 0, ptr %arrayidx, align 1
  br label %while.cond.i

while.cond.i:
  %f.pn.i = phi ptr [ %test.0.i, %while.cond.i ], [ %foo, %entry ]
  %test.0.i = getelementptr inbounds i8, ptr %f.pn.i, i64 1
  %0 = load i8, ptr %test.0.i, align 1
  %cmp5.not.i = icmp eq i8 %0, 0
  br i1 %cmp5.not.i, label %len.exit, label %while.cond.i

len.exit:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %foo to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %1 = trunc i64 %sub.ptr.sub.i to i32
  %cmp = icmp eq i32 %1, 0
  call void @llvm.lifetime.end.p0(i64 256, ptr nonnull %foo)
  ret i1 %cmp
}

define i1 @recursiveGEP_withPtrSubTrunc_knownObject_ObjSize0() {
; CHECK-LABEL: @recursiveGEP_withPtrSubTrunc_knownObject_ObjSize0(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[FOO:%.*]] = alloca [[STRUCT_FOO:%.*]], align 1
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 256, ptr nonnull [[FOO]])
; CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(256) [[FOO]], i8 97, i64 255, i1 false)
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[FOO]], i64 255
; CHECK-NEXT:    store i8 0, ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[FOO2:%.*]] = getelementptr inbounds i8, ptr [[FOO]], i64 256
; CHECK-NEXT:    br label [[WHILE_COND_I:%.*]]
; CHECK:       while.cond.i:
; CHECK-NEXT:    [[F_PN_I:%.*]] = phi ptr [ [[TEST_0_I:%.*]], [[WHILE_COND_I]] ], [ [[FOO2]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[TEST_0_I]] = getelementptr inbounds i8, ptr [[F_PN_I]], i64 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[TEST_0_I]], align 1
; CHECK-NEXT:    [[CMP5_NOT_I:%.*]] = icmp eq i8 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[CMP5_NOT_I]], label [[LEN_EXIT:%.*]], label [[WHILE_COND_I]]
; CHECK:       len.exit:
; CHECK-NEXT:    [[SUB_PTR_LHS_CAST_I:%.*]] = ptrtoint ptr [[TEST_0_I]] to i64
; CHECK-NEXT:    [[SUB_PTR_RHS_CAST_I:%.*]] = ptrtoint ptr [[FOO2]] to i64
; CHECK-NEXT:    [[SUB_PTR_SUB_I:%.*]] = sub i64 [[SUB_PTR_LHS_CAST_I]], [[SUB_PTR_RHS_CAST_I]]
; CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[SUB_PTR_SUB_I]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP1]], 0
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 256, ptr nonnull [[FOO]])
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  %foo = alloca %struct.Foo, align 1
  call void @llvm.lifetime.start.p0(i64 256, ptr nonnull %foo)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(256) %foo, i8 97, i64 255, i1 false)
  %arrayidx = getelementptr inbounds [256 x i8], ptr %foo, i64 0, i64 255
  store i8 0, ptr %arrayidx, align 1
  %foo2 = getelementptr inbounds i8, ptr %foo, i64 256
  br label %while.cond.i

while.cond.i:
  %f.pn.i = phi ptr [ %test.0.i, %while.cond.i ], [ %foo2, %entry ]
  %test.0.i = getelementptr inbounds i8, ptr %f.pn.i, i64 1
  %0 = load i8, ptr %test.0.i, align 1
  %cmp5.not.i = icmp eq i8 %0, 0
  br i1 %cmp5.not.i, label %len.exit, label %while.cond.i

len.exit:
  %sub.ptr.lhs.cast.i = ptrtoint ptr %test.0.i to i64
  %sub.ptr.rhs.cast.i = ptrtoint ptr %foo2 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %1 = trunc i64 %sub.ptr.sub.i to i32
  %cmp = icmp eq i32 %1, 0
  call void @llvm.lifetime.end.p0(i64 256, ptr nonnull %foo)
  ret i1 %cmp
}

declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg)

