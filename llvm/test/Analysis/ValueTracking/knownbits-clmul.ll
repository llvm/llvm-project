; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=instcombine -S < %s | FileCheck %s

define i1 @clmul_zero(i8 %a) nounwind {
; CHECK-LABEL: @clmul_zero(
; CHECK-NEXT:    ret i1 false
;
  %clmul = call i8 @llvm.clmul.i8(i8 %a, i8 0)
  %r = icmp eq i8 %clmul, 1
  ret i1 %r
}

define i1 @clmul_low_bits(i8 %a) nounwind {
; CHECK-LABEL: @clmul_low_bits(
; CHECK-NEXT:    ret i1 true
;
  %clmul = call i8 @llvm.clmul.i8(i8 %a, i8 4)
  %and = and i8 %clmul, 3
  %r = icmp eq i8 %and, 0
  ret i1 %r
}

define i1 @clmul_low_bits_negative(i8 %a) nounwind {
; CHECK-LABEL: @clmul_low_bits_negative(
; CHECK-NEXT:    [[CLMUL:%.*]] = call i8 @llvm.clmul.i8(i8 [[A:%.*]], i8 4)
; CHECK-NEXT:    [[AND:%.*]] = and i8 [[CLMUL]], 4
; CHECK-NEXT:    [[R:%.*]] = icmp eq i8 [[AND]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %clmul = call i8 @llvm.clmul.i8(i8 %a, i8 4)
  %and = and i8 %clmul, 4
  %r = icmp eq i8 %and, 0
  ret i1 %r
}

define <2 x i1> @clmul_low_bits_vector(<2 x i8> %a) nounwind {
; CHECK-LABEL: @clmul_low_bits_vector(
; CHECK-NEXT:    ret <2 x i1> splat (i1 true)
;
  %clmul = call <2 x i8> @llvm.clmul.v2i8(<2 x i8> %a, <2 x i8> splat (i8 4))
  %and = and <2 x i8> %clmul, splat (i8 3)
  %r = icmp eq <2 x i8> %and, zeroinitializer
  ret <2 x i1> %r
}

define <2 x i1> @clmul_low_bits_vector_negative(<2 x i8> %a) nounwind {
; CHECK-LABEL: @clmul_low_bits_vector_negative(
; CHECK-NEXT:    [[CLMUL:%.*]] = call <2 x i8> @llvm.clmul.v2i8(<2 x i8> [[A:%.*]], <2 x i8> splat (i8 4))
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i8> [[CLMUL]], splat (i8 4)
; CHECK-NEXT:    [[R:%.*]] = icmp eq <2 x i8> [[AND]], zeroinitializer
; CHECK-NEXT:    ret <2 x i1> [[R]]
;
  %clmul = call <2 x i8> @llvm.clmul.v2i8(<2 x i8> %a, <2 x i8> splat (i8 4))
  %and = and <2 x i8> %clmul, splat (i8 4)
  %r = icmp eq <2 x i8> %and, zeroinitializer
  ret <2 x i1> %r
}

define i1 @clmul_high_bits(i8 %a, i8 %b) nounwind {
; CHECK-LABEL: @clmul_high_bits(
; CHECK-NEXT:    ret i1 true
;
  %zext_a = zext i8 %a to i16
  %zext_b = zext i8 %b to i16
  %clmul = call i16 @llvm.clmul.i16(i16 %zext_a, i16 %zext_b)
  %and = and i16 %clmul, u0x8000
  %r = icmp eq i16 %and, 0
  ret i1 %r
}

define i1 @clmul_high_bits_boundary(i8 %a, i8 %b) nounwind {
; CHECK-LABEL: @clmul_high_bits_boundary(
; CHECK-NEXT:    [[ZEXT_A:%.*]] = zext i8 [[A:%.*]] to i16
; CHECK-NEXT:    [[ZEXT_B:%.*]] = zext i8 [[B:%.*]] to i16
; CHECK-NEXT:    [[CLMUL:%.*]] = call i16 @llvm.clmul.i16(i16 [[ZEXT_A]], i16 [[ZEXT_B]])
; CHECK-NEXT:    [[R:%.*]] = icmp samesign ult i16 [[CLMUL]], 16384
; CHECK-NEXT:    ret i1 [[R]]
;
  %zext_a = zext i8 %a to i16
  %zext_b = zext i8 %b to i16
  %clmul = call i16 @llvm.clmul.i16(i16 %zext_a, i16 %zext_b)
  %and = and i16 %clmul, u0x4000
  %r = icmp eq i16 %and, 0
  ret i1 %r
}

define i1 @clmul_high_bits_negative(i8 %a, i8 %b) nounwind {
; CHECK-LABEL: @clmul_high_bits_negative(
; CHECK-NEXT:    [[ZEXT_A:%.*]] = zext i8 [[A:%.*]] to i16
; CHECK-NEXT:    [[ZEXT_B:%.*]] = zext i8 [[B:%.*]] to i16
; CHECK-NEXT:    [[CLMUL:%.*]] = call i16 @llvm.clmul.i16(i16 [[ZEXT_A]], i16 [[ZEXT_B]])
; CHECK-NEXT:    [[AND:%.*]] = and i16 [[CLMUL]], 8192
; CHECK-NEXT:    [[R:%.*]] = icmp eq i16 [[AND]], 0
; CHECK-NEXT:    ret i1 [[R]]
;
  %zext_a = zext i8 %a to i16
  %zext_b = zext i8 %b to i16
  %clmul = call i16 @llvm.clmul.i16(i16 %zext_a, i16 %zext_b)
  %and = and i16 %clmul, u0x2000
  %r = icmp eq i16 %and, 0
  ret i1 %r
}

define <2 x i1> @clmul_high_bits_vector(<2 x i8> %a, <2 x i8> %b) nounwind {
; CHECK-LABEL: @clmul_high_bits_vector(
; CHECK-NEXT:    ret <2 x i1> splat (i1 true)
;
  %zext_a = zext <2 x i8> %a to <2 x i16>
  %zext_b = zext <2 x i8> %b to <2 x i16>
  %clmul = call <2 x i16> @llvm.clmul.v2i16(<2 x i16> %zext_a, <2 x i16> %zext_b)
  %and = and <2 x i16> %clmul, splat (i16 u0x8000)
  %r = icmp eq <2 x i16> %and, zeroinitializer
  ret <2 x i1> %r
}

define <2 x i1> @clmul_high_bits_boundary_vector(<2 x i8> %a, <2 x i8> %b) nounwind {
; CHECK-LABEL: @clmul_high_bits_boundary_vector(
; CHECK-NEXT:    [[ZEXT_A:%.*]] = zext <2 x i8> [[A:%.*]] to <2 x i16>
; CHECK-NEXT:    [[ZEXT_B:%.*]] = zext <2 x i8> [[B:%.*]] to <2 x i16>
; CHECK-NEXT:    [[CLMUL:%.*]] = call <2 x i16> @llvm.clmul.v2i16(<2 x i16> [[ZEXT_A]], <2 x i16> [[ZEXT_B]])
; CHECK-NEXT:    [[R:%.*]] = icmp samesign ult <2 x i16> [[CLMUL]], splat (i16 16384)
; CHECK-NEXT:    ret <2 x i1> [[R]]
;
  %zext_a = zext <2 x i8> %a to <2 x i16>
  %zext_b = zext <2 x i8> %b to <2 x i16>
  %clmul = call <2 x i16> @llvm.clmul.v2i16(<2 x i16> %zext_a, <2 x i16> %zext_b)
  %and = and <2 x i16> %clmul, splat (i16 u0x4000)
  %r = icmp eq <2 x i16> %and, zeroinitializer
  ret <2 x i1> %r
}

define <2 x i1> @clmul_high_bits_negative_vector(<2 x i8> %a, <2 x i8> %b) nounwind {
; CHECK-LABEL: @clmul_high_bits_negative_vector(
; CHECK-NEXT:    [[ZEXT_A:%.*]] = zext <2 x i8> [[A:%.*]] to <2 x i16>
; CHECK-NEXT:    [[ZEXT_B:%.*]] = zext <2 x i8> [[B:%.*]] to <2 x i16>
; CHECK-NEXT:    [[CLMUL:%.*]] = call <2 x i16> @llvm.clmul.v2i16(<2 x i16> [[ZEXT_A]], <2 x i16> [[ZEXT_B]])
; CHECK-NEXT:    [[AND:%.*]] = and <2 x i16> [[CLMUL]], splat (i16 8192)
; CHECK-NEXT:    [[R:%.*]] = icmp eq <2 x i16> [[AND]], zeroinitializer
; CHECK-NEXT:    ret <2 x i1> [[R]]
;
  %zext_a = zext <2 x i8> %a to <2 x i16>
  %zext_b = zext <2 x i8> %b to <2 x i16>
  %clmul = call <2 x i16> @llvm.clmul.v2i16(<2 x i16> %zext_a, <2 x i16> %zext_b)
  %and = and <2 x i16> %clmul, splat (i16 u0x2000)
  %r = icmp eq <2 x i16> %and, zeroinitializer
  ret <2 x i1> %r
}
