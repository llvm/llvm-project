; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -passes="print<delinearization>" -disable-output 2>&1 | FileCheck %s

define void @test_alloca_2d() {
; CHECK-LABEL: 'test_alloca_2d'
; CHECK-NEXT:  Inst: %0 = load double, ptr %arrayidx, align 8
; CHECK-NEXT:  LinearAccessFunction: {%arr,+,8}<nw><%for.cond>
; CHECK-NEXT:  ArrayDecl[2500] with elements of 8 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.cond>]
; CHECK-EMPTY:
; CHECK-NEXT:  Inst: store double %mul, ptr %arrayidx, align 8
; CHECK-NEXT:  LinearAccessFunction: {%arr,+,8}<nw><%for.cond>
; CHECK-NEXT:  ArrayDecl[2500] with elements of 8 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.cond>]
;
entry:
  %arr = alloca [2500 x double], align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i64 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i64 %i.0, 2500
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds [2500 x double], ptr %arr, i64 0, i64 %i.0
  %0 = load double, ptr %arrayidx, align 8
  %mul = fmul double %0, 2.000000e+00
  store double %mul, ptr %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i64 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define void @test_alloca_3d() {
; CHECK-LABEL: 'test_alloca_3d'
; CHECK-NEXT:  Inst: %0 = load double, ptr %arrayidx, align 8
; CHECK-NEXT:  LinearAccessFunction: {{\{\{\{}}%arr,+,4800}<nw><%for.i>,+,240}<nw><%for.j>,+,8}<nw><%for.k>
; CHECK-NEXT:  ArrayDecl[10][20][30] with elements of 8 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.i>][{0,+,1}<nuw><nsw><%for.j>][{0,+,1}<nuw><nsw><%for.k>]
; CHECK-EMPTY:
; CHECK-NEXT:  Inst: store double %mul, ptr %arrayidx, align 8
; CHECK-NEXT:  LinearAccessFunction: {{\{\{\{}}%arr,+,4800}<nw><%for.i>,+,240}<nw><%for.j>,+,8}<nw><%for.k>
; CHECK-NEXT:  ArrayDecl[10][20][30] with elements of 8 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.i>][{0,+,1}<nuw><nsw><%for.j>][{0,+,1}<nuw><nsw><%for.k>]
;
entry:
  %arr = alloca [10 x [20 x [30 x double]]], align 8
  br label %for.i

for.i:                                            ; preds = %for.i.inc, %entry
  %i.0 = phi i64 [ 0, %entry ], [ %i.inc, %for.i.inc ]
  %i.cmp = icmp ult i64 %i.0, 10
  br i1 %i.cmp, label %for.j, label %for.i.end

for.j:                                            ; preds = %for.j.inc, %for.i
  %j.0 = phi i64 [ 0, %for.i ], [ %j.inc, %for.j.inc ]
  %j.cmp = icmp ult i64 %j.0, 20
  br i1 %j.cmp, label %for.k, label %for.j.end

for.k:                                            ; preds = %for.k.inc, %for.j
  %k.0 = phi i64 [ 0, %for.j ], [ %k.inc, %for.k.inc ]
  %k.cmp = icmp ult i64 %k.0, 30
  br i1 %k.cmp, label %for.body, label %for.k.end

for.body:                                         ; preds = %for.k
  %arrayidx = getelementptr inbounds [10 x [20 x [30 x double]]], ptr %arr, i64 0, i64 %i.0, i64 %j.0, i64 %k.0
  %0 = load double, ptr %arrayidx, align 8
  %mul = fmul double %0, 2.000000e+00
  store double %mul, ptr %arrayidx, align 8
  br label %for.k.inc

for.k.inc:                                        ; preds = %for.body
  %k.inc = add nuw nsw i64 %k.0, 1
  br label %for.k

for.k.end:                                        ; preds = %for.k
  br label %for.j.inc

for.j.inc:                                        ; preds = %for.k.end
  %j.inc = add nuw nsw i64 %j.0, 1
  br label %for.j

for.j.end:                                        ; preds = %for.j
  br label %for.i.inc

for.i.inc:                                        ; preds = %for.j.end
  %i.inc = add nuw nsw i64 %i.0, 1
  br label %for.i

for.i.end:                                        ; preds = %for.i
  ret void
}

; Global 3D array similar to what flang generates.
@global_3d_array = local_unnamed_addr global [54 x [54 x [54 x double]]] zeroinitializer

define void @test_global_3d() {
; CHECK-LABEL: 'test_global_3d'
; CHECK-NEXT:  Inst: %0 = load double, ptr %arrayidx, align 8
; CHECK-NEXT:  LinearAccessFunction: {{\{\{\{}}@global_3d_array,+,23328}<nw><%for.i>,+,432}<nw><%for.j>,+,8}<nw><%for.k>
; CHECK-NEXT:  ArrayDecl[54][54][54] with elements of 8 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.i>][{0,+,1}<nuw><nsw><%for.j>][{0,+,1}<nuw><nsw><%for.k>]
; CHECK-EMPTY:
; CHECK-NEXT:  Inst: store double %mul, ptr %arrayidx, align 8
; CHECK-NEXT:  LinearAccessFunction: {{\{\{\{}}@global_3d_array,+,23328}<nw><%for.i>,+,432}<nw><%for.j>,+,8}<nw><%for.k>
; CHECK-NEXT:  ArrayDecl[54][54][54] with elements of 8 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.i>][{0,+,1}<nuw><nsw><%for.j>][{0,+,1}<nuw><nsw><%for.k>]
;
entry:
  br label %for.i

for.i:                                            ; preds = %for.i.inc, %entry
  %i.0 = phi i64 [ 0, %entry ], [ %i.inc, %for.i.inc ]
  %i.cmp = icmp ult i64 %i.0, 54
  br i1 %i.cmp, label %for.j, label %for.i.end

for.j:                                            ; preds = %for.j.inc, %for.i
  %j.0 = phi i64 [ 0, %for.i ], [ %j.inc, %for.j.inc ]
  %j.cmp = icmp ult i64 %j.0, 54
  br i1 %j.cmp, label %for.k, label %for.j.end

for.k:                                            ; preds = %for.k.inc, %for.j
  %k.0 = phi i64 [ 0, %for.j ], [ %k.inc, %for.k.inc ]
  %k.cmp = icmp ult i64 %k.0, 54
  br i1 %k.cmp, label %for.body, label %for.k.end

for.body:                                         ; preds = %for.k
  %arrayidx = getelementptr inbounds [54 x [54 x [54 x double]]], ptr @global_3d_array, i64 0, i64 %i.0, i64 %j.0, i64 %k.0
  %0 = load double, ptr %arrayidx, align 8
  %mul = fmul double %0, 3.000000e+00
  store double %mul, ptr %arrayidx, align 8
  br label %for.k.inc

for.k.inc:                                        ; preds = %for.body
  %k.inc = add nuw nsw i64 %k.0, 1
  br label %for.k

for.k.end:                                        ; preds = %for.k
  br label %for.j.inc

for.j.inc:                                        ; preds = %for.k.end
  %j.inc = add nuw nsw i64 %j.0, 1
  br label %for.j

for.j.end:                                        ; preds = %for.j
  br label %for.i.inc

for.i.inc:                                        ; preds = %for.j.end
  %i.inc = add nuw nsw i64 %i.0, 1
  br label %for.i

for.i.end:                                        ; preds = %for.i
  ret void
}

define void @test_0() {
; CHECK-LABEL: 'test_0'
; CHECK-NEXT:  Inst: %0 = load i32, ptr %arrayidx, align 4
; CHECK-NEXT:  LinearAccessFunction: {{\{\{}}%matrix,+,200}<nw><%for.i>,+,4}<nw><%for.j>
; CHECK-NEXT:  ArrayDecl[100][50] with elements of 4 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.i>][{0,+,1}<nuw><nsw><%for.j>]
; CHECK-EMPTY:
; CHECK-NEXT:  Inst: store i32 %add, ptr %arrayidx, align 4
; CHECK-NEXT:  LinearAccessFunction: {{\{\{}}%matrix,+,200}<nw><%for.i>,+,4}<nw><%for.j>
; CHECK-NEXT:  ArrayDecl[100][50] with elements of 4 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.i>][{0,+,1}<nuw><nsw><%for.j>]
;
entry:
  %matrix = alloca [100 x [50 x i32]], align 4
  br label %for.i

for.i:                                            ; preds = %for.i.inc, %entry
  %i.0 = phi i64 [ 0, %entry ], [ %i.inc, %for.i.inc ]
  %i.cmp = icmp ult i64 %i.0, 100
  br i1 %i.cmp, label %for.j, label %for.i.end

for.j:                                            ; preds = %for.j.inc, %for.i
  %j.0 = phi i64 [ 0, %for.i ], [ %j.inc, %for.j.inc ]
  %j.cmp = icmp ult i64 %j.0, 50
  br i1 %j.cmp, label %for.body, label %for.j.end

for.body:                                         ; preds = %for.j
  %arrayidx = getelementptr inbounds [100 x [50 x i32]], ptr %matrix, i64 0, i64 %i.0, i64 %j.0
  %0 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %0, 1
  store i32 %add, ptr %arrayidx, align 4
  br label %for.j.inc

for.j.inc:                                        ; preds = %for.body
  %j.inc = add nuw nsw i64 %j.0, 1
  br label %for.j

for.j.end:                                        ; preds = %for.j
  br label %for.i.inc

for.i.inc:                                        ; preds = %for.j.end
  %i.inc = add nuw nsw i64 %i.0, 1
  br label %for.i

for.i.end:                                        ; preds = %for.i
  ret void
}
