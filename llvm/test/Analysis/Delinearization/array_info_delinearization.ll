; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes='print<delinearization>' -disable-output 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"

@test_array_10x20 = global [10 x [20 x i32]] zeroinitializer

; Function that accesses a 2D array with dimensions [10][20].
define void @test_2d_array(i64 %i, i64 %j) {
; CHECK-LABEL: 'test_2d_array'
; CHECK-NEXT:  Inst: %val = load i32, ptr %ptr, align 4
; CHECK-NEXT:  LinearAccessFunction: {{\{\{}}@test_array_10x20,+,80}<nw><%for.i>,+,4}<%for.j>
; CHECK-NEXT:  ArrayDecl[10][20] with elements of 4 bytes.
; CHECK-NEXT:  ArrayRef[{0,+,1}<nuw><nsw><%for.i>][{0,+,1}<nuw><nsw><%for.j>]
;
entry:
  %arr = getelementptr inbounds [10 x [20 x i32]], ptr @test_array_10x20, i32 0, i32 0
  br label %for.i

for.i:                                            ; preds = %for.j.end, %entry
  %i.cur = phi i64 [ 0, %entry ], [ %i.next, %for.j.end ]
  %i.cmp = icmp slt i64 %i.cur, 10
  br i1 %i.cmp, label %for.j, label %exit

for.j:                                            ; preds = %for.j, %for.i
  %j.cur = phi i64 [ 0, %for.i ], [ %j.next, %for.j ]

  ; Compute linear access: arr[i][j] = arr + i*20 + j
  %i.mul = mul i64 %i.cur, 20
  %idx = add i64 %i.mul, %j.cur
  %ptr = getelementptr inbounds i32, ptr %arr, i64 %idx

  ; Load from the computed address
  %val = load i32, ptr %ptr, align 4

  %j.next = add i64 %j.cur, 1
  %j.cmp = icmp slt i64 %j.next, 20
  br i1 %j.cmp, label %for.j, label %for.j.end

for.j.end:                                        ; preds = %for.j
  %i.next = add i64 %i.cur, 1
  br label %for.i

exit:                                             ; preds = %for.i
  ret void
}

attributes #0 = { nocallback nofree nosync nounwind willreturn inaccessiblememonly }
