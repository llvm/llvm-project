; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='print<access-info>' -disable-output %s 2>&1 | FileCheck %s


define void @dependency_check_and_runtime_checks_needed_select_of_invariant_ptrs(ptr %a, ptr %b, ptr %c, i64 %offset, i64 %n) {
; CHECK-LABEL: 'dependency_check_and_runtime_checks_needed_select_of_invariant_ptrs'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: cannot check memory dependencies at runtime
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %gep.a.iv = getelementptr inbounds float, ptr %a, i64 %iv
  %l1 = load float, ptr %gep.a.iv, align 4
  %iv.offset = add i64 %iv, %offset
  %gep.a.iv.off = getelementptr inbounds float, ptr %a, i64 %iv.offset
  %l2 = load float, ptr %gep.a.iv.off, align 4
  %ad = fadd fast float %l1, %l2
  store float %ad, ptr %gep.a.iv, align 4
  %cmp = fcmp ult float %l1, 10.0
  %select = select i1 %cmp, ptr %b, ptr %c
  store float 0.0, ptr %select
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %exit, label %loop

exit:
  ret void
}

define void @dependency_check_and_runtime_checks_needed_select_of_ptr_add_recs(ptr %a, ptr %b, ptr %c, i64 %offset, i64 %n) {
; CHECK-LABEL: 'dependency_check_and_runtime_checks_needed_select_of_ptr_add_recs'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: cannot check memory dependencies at runtime
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %gep.a.iv = getelementptr inbounds float, ptr %a, i64 %iv
  %l1 = load float, ptr %gep.a.iv, align 4
  %iv.offset = add i64 %iv, %offset
  %gep.a.iv.off = getelementptr inbounds float, ptr %a, i64 %iv.offset
  %l2 = load float, ptr %gep.a.iv.off, align 4
  %ad = fadd fast float %l1, %l2
  store float %ad, ptr %gep.a.iv, align 4
  %gep.b = getelementptr inbounds float, ptr %b, i64 %iv
  %gep.c = getelementptr inbounds float, ptr %c, i64 %iv
  %cmp = fcmp ult float %l1, 10.0
  %select = select i1 %cmp, ptr %gep.b, ptr %gep.c
  store float 0.0, ptr %select
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %exit, label %loop

exit:
  ret void
}

define void @dependency_check_and_runtime_checks_needed_select_of_ptr_add_recs_may_wrap_1(ptr %a, ptr %b, ptr %c, i64 %offset, i64 %n) {
; CHECK-LABEL: 'dependency_check_and_runtime_checks_needed_select_of_ptr_add_recs_may_wrap_1'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: cannot check memory dependencies at runtime
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv2 = phi i64 [ 0, %entry ], [ %iv2.next, %loop ]
  %gep.a.iv = getelementptr inbounds float, ptr %a, i64 %iv
  %l1 = load float, ptr %gep.a.iv, align 4
  %iv.offset = add i64 %iv, %offset
  %gep.a.iv.off = getelementptr inbounds float, ptr %a, i64 %iv.offset
  %l2 = load float, ptr %gep.a.iv.off, align 4
  %ad = fadd fast float %l1, %l2
  store float %ad, ptr %gep.a.iv, align 4
  %gep.b = getelementptr float, ptr %b, i64 %iv2
  %gep.c = getelementptr inbounds float, ptr %c, i64 %iv
  %cmp = fcmp ult float %l1, 10.0
  %select = select i1 %cmp, ptr %gep.b, ptr %gep.c
  store float 0.0, ptr %select
  %iv.next = add nuw nsw i64 %iv, 1
  %iv2.next = add i64 %iv2, 2
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %exit, label %loop

exit:
  ret void
}


define void @dependency_check_and_runtime_checks_needed_select_of_ptr_add_recs_may_wrap_2(ptr %a, ptr %b, ptr %c, i64 %offset, i64 %n) {
; CHECK-LABEL: 'dependency_check_and_runtime_checks_needed_select_of_ptr_add_recs_may_wrap_2'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: cannot check memory dependencies at runtime
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv2 = phi i64 [ 0, %entry ], [ %iv2.next, %loop ]
  %gep.a.iv = getelementptr inbounds float, ptr %a, i64 %iv
  %l1 = load float, ptr %gep.a.iv, align 4
  %iv.offset = add i64 %iv, %offset
  %gep.a.iv.off = getelementptr inbounds float, ptr %a, i64 %iv.offset
  %l2 = load float, ptr %gep.a.iv.off, align 4
  %ad = fadd fast float %l1, %l2
  store float %ad, ptr %gep.a.iv, align 4
  %gep.b = getelementptr inbounds float, ptr %b, i64 %iv
  %gep.c = getelementptr inbounds float, ptr %c, i64 %iv2
  %cmp = fcmp ult float %l1, 10.0
  %select = select i1 %cmp, ptr %gep.b, ptr %gep.c
  store float 0.0, ptr %select
  %iv.next = add nuw nsw i64 %iv, 1
  %iv2.next = add i64 %iv2, 2
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %exit, label %loop

exit:
  ret void
}
