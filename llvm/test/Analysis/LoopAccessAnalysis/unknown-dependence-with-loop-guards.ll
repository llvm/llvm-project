; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes='print<access-info>' -disable-output %s 2>&1 | FileCheck %s

define void @unsafe_dep_loopguards(ptr %a, ptr %b, ptr %c) {
; CHECK-LABEL: 'unsafe_dep_loopguards'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            %ld.a = load [4 x i32], ptr %gep.a.offset.2, align 4 ->
; CHECK-NEXT:            store i32 0, ptr %gep.a.offset.4, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Check 0:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:        ptr %c
; CHECK-NEXT:        Against group GRP1:
; CHECK-NEXT:          %gep.a.offset.2 = getelementptr i32, ptr %gep.a.offset, i32 4
; CHECK-NEXT:      Check 1:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:        ptr %c
; CHECK-NEXT:        Against group GRP2:
; CHECK-NEXT:          %gep.a.offset.4 = getelementptr i32, ptr %a, i32 %offset.4
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: %c High: (16 + %c))
; CHECK-NEXT:            Member: %c
; CHECK-NEXT:        Group GRP1:
; CHECK-NEXT:          (Low: (16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a) High: (64 + (4 * (sext i32 %ld.b to i64))<nsw> + %a))
; CHECK-NEXT:            Member: {(16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a),+,32}<%loop>
; CHECK-NEXT:        Group GRP2:
; CHECK-NEXT:          (Low: ((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a) High: (36 + (4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a))
; CHECK-NEXT:            Member: {((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a),+,32}<%loop>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-NEXT:      {(4 + %ld.b),+,8}<nw><%loop> Added Flags: <nssw>
; CHECK-NEXT:      {((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a),+,32}<%loop> Added Flags: <nusw>
; CHECK-NEXT:      {%ld.b,+,8}<nw><%loop> Added Flags: <nssw>
; CHECK-NEXT:      {(16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a),+,32}<%loop> Added Flags: <nusw>
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
; CHECK-NEXT:      [PSE] %gep.a.offset.2 = getelementptr i32, ptr %gep.a.offset, i32 4:
; CHECK-NEXT:        (16 + (4 * (sext i32 {%ld.b,+,8}<nw><%loop> to i64))<nsw> + %a)
; CHECK-NEXT:        --> {(16 + (4 * (sext i32 %ld.b to i64))<nsw> + %a),+,32}<%loop>
; CHECK-NEXT:      [PSE] %gep.a.offset.4 = getelementptr i32, ptr %a, i32 %offset.4:
; CHECK-NEXT:        ((4 * (sext i32 {(4 + %ld.b),+,8}<nw><%loop> to i64))<nsw> + %a)
; CHECK-NEXT:        --> {((4 * (sext i32 (4 + %ld.b) to i64))<nsw> + %a),+,32}<%loop>
;
entry:
  %ld.b = load i32, ptr %b
  %guard.cond = icmp slt i32 0, %ld.b
  br i1 %guard.cond, label %exit, label %loop

loop:
  %iv = phi i32 [ %iv.next, %loop ], [ 0, %entry ]
  %offset = add i32 %ld.b, %iv
  %gep.a.offset = getelementptr i32, ptr %a, i32 %offset
  %gep.a.offset.2 = getelementptr i32, ptr %gep.a.offset, i32 4
  %ld.a = load [4 x i32], ptr %gep.a.offset.2
  store [4 x i32] %ld.a, ptr %c
  %offset.4 = add i32 %offset, 4
  %gep.a.offset.4 = getelementptr i32, ptr %a, i32 %offset.4
  store i32 0, ptr %gep.a.offset.4
  %iv.next = add i32 %iv, 8
  %exit.cond = icmp eq i32 %iv.next, 16
  br i1 %exit.cond, label %exit, label %loop

exit:
  ret void
}
