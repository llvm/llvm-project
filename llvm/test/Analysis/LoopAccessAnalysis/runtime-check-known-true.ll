; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='print<access-info>' -disable-output %s 2>&1 | FileCheck %s

; TODO: Accesses are known completely before or after.
define void @test_runtime_check_known_false_after_construction(ptr %start.1, ptr %start.2, ptr %end) {
; CHECK-LABEL: 'test_runtime_check_known_false_after_construction'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Memory dependences are safe with run-time checks
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Check 0:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:          %ptr.iv.1 = phi ptr [ %ptr.iv.1.next, %loop ], [ %start.1, %entry ]
; CHECK-NEXT:        Against group GRP1:
; CHECK-NEXT:          %ptr.iv.2 = phi ptr [ %ptr.iv.2.next, %loop ], [ %start.2.diff, %entry ]
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: ((-8 * ((2305843009213693951 * (8 + (-1 * (ptrtoint ptr %start.1 to i64)) + (ptrtoint ptr %end to i64))) /u 8)) + %start.1) High: (8 + %start.1))
; CHECK-NEXT:            Member: {%start.1,+,-8}<%loop>
; CHECK-NEXT:        Group GRP1:
; CHECK-NEXT:          (Low: (-8 + (-8 * ((2305843009213693951 * (8 + (-1 * (ptrtoint ptr %start.1 to i64)) + (ptrtoint ptr %end to i64))) /u 8)) + (-1 * (ptrtoint ptr %start.2 to i64)) + (ptrtoint ptr %start.1 to i64) + %start.2) High: ((-1 * (ptrtoint ptr %start.2 to i64)) + (ptrtoint ptr %start.1 to i64) + %start.2))
; CHECK-NEXT:            Member: {(-8 + (-1 * (ptrtoint ptr %start.2 to i64)) + (ptrtoint ptr %start.1 to i64) + %start.2),+,-8}<%loop>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-NEXT:      Equal predicate: (zext i3 ((trunc i64 (ptrtoint ptr %end to i64) to i3) + (-1 * (trunc i64 (ptrtoint ptr %start.1 to i64) to i3))) to i64) == 0
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %gep.start.2 = getelementptr i8, ptr %start.2, i64 8
  %start.1.int = ptrtoint ptr %start.1 to i64
  %start.2.int = ptrtoint ptr %gep.start.2 to i64
  %diff = sub i64 %start.1.int, %start.2.int
  %start.2.diff = getelementptr i8, ptr %start.2, i64 %diff
  br label %loop

loop:
  %ptr.iv.1 = phi ptr [ %ptr.iv.1.next, %loop ], [ %start.1, %entry ]
  %ptr.iv.2 = phi ptr [ %ptr.iv.2.next, %loop ], [ %start.2.diff, %entry ]
  %ptr.iv.2.next = getelementptr i8, ptr %ptr.iv.2, i64 -8
  %ptr.iv.1.next = getelementptr i8, ptr %ptr.iv.1, i64 -8
  %l = load i64, ptr %ptr.iv.2, align 8
  store i64 %l, ptr %ptr.iv.1, align 8
  %ec = icmp eq ptr %ptr.iv.2, %end
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}
