; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -disable-output -passes='print<access-info>' < %s 2>&1 | FileCheck %s


; In the function below some of the accesses are done as float types and some
; are done as i32 types. When doing dependence analysis the type should not
; matter if it can be determined that they are the same size.

%int_pair = type { i32, i32 }

define void @backdep_type_size_equivalence(ptr nocapture %vec, i64 %n) {
; CHECK-LABEL: 'backdep_type_size_equivalence'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Memory dependences are safe with a maximum safe vector width of 3200 bits
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Forward:
; CHECK-NEXT:            %ld.f32 = load float, ptr %gep.iv, align 8 ->
; CHECK-NEXT:            store i32 %indvars.iv.i32, ptr %gep.iv, align 8
; CHECK-EMPTY:
; CHECK-NEXT:        Forward:
; CHECK-NEXT:            %ld.f32 = load float, ptr %gep.iv, align 8 ->
; CHECK-NEXT:            store float %val, ptr %gep.iv.min.100, align 8
; CHECK-EMPTY:
; CHECK-NEXT:        BackwardVectorizable:
; CHECK-NEXT:            store float %val, ptr %gep.iv.min.100, align 8 ->
; CHECK-NEXT:            store i32 %indvars.iv.i32, ptr %gep.iv, align 8
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %loop ]

  ;; Load from vec[indvars.iv].x as float
  %gep.iv = getelementptr inbounds %int_pair, ptr %vec, i64 %indvars.iv, i32 0
  %ld.f32 = load float, ptr %gep.iv, align 8
  %val = fmul fast float %ld.f32, 5.0

  ;; Store to vec[indvars.iv - 100].x as float
  %indvars.iv.min.100 = add nsw i64 %indvars.iv, -100
  %gep.iv.min.100 = getelementptr inbounds %int_pair, ptr %vec, i64 %indvars.iv.min.100, i32 0
  store float %val, ptr %gep.iv.min.100, align 8

  ;; Store to vec[indvars.iv].x as i32, creating a backward dependency between
  ;; the two stores with different element types but the same element size.
  %indvars.iv.i32 = trunc i64 %indvars.iv to i32
  store i32 %indvars.iv.i32, ptr %gep.iv, align 8

  ;; Store to vec[indvars.iv].y as i32, strided accesses should be independent
  ;; between the two stores with different element types but the same element size.
  %gep.iv.1 = getelementptr inbounds %int_pair, ptr %vec, i64 %indvars.iv, i32 1
  store i32 %indvars.iv.i32, ptr %gep.iv.1, align 8

  ;; Store to vec[indvars.iv + n].y as i32, to verify no dependence in the case
  ;; of unknown dependence distance.
  %indvars.iv.n = add nuw nsw i64 %indvars.iv, %n
  %gep.iv.n = getelementptr inbounds %int_pair, ptr %vec, i64 %indvars.iv.n, i32 1
  store i32 %indvars.iv.i32, ptr %gep.iv.n, align 8

  ;; Loop condition.
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cond = icmp eq i64 %indvars.iv.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret void
}

; In the function below one of the accesses is done as i19 type, which has a
; different store size than the i32 type, even though their alloc sizes are
; equivalent. This is a negative test to ensure that they are not analyzed as
; in the tests above.

define void @backdep_type_store_size_equivalence(ptr nocapture %vec, i64 %n) {
; CHECK-LABEL: 'backdep_type_store_size_equivalence'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            %ld.f32 = load float, ptr %gep.iv, align 8 ->
; CHECK-NEXT:            store i19 %indvars.iv.i19, ptr %gep.iv, align 8
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %loop ]

  ;; Load from vec[indvars.iv].x as float
  %gep.iv = getelementptr inbounds %int_pair, ptr %vec, i64 %indvars.iv, i32 0
  %ld.f32 = load float, ptr %gep.iv, align 8
  %val = fmul fast float %ld.f32, 5.0

  ;; Store to vec[indvars.iv].x as i19.
  %indvars.iv.i19 = trunc i64 %indvars.iv to i19
  store i19 %indvars.iv.i19, ptr %gep.iv, align 8

  ;; Loop condition.
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cond = icmp eq i64 %indvars.iv.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret void
}

; In the function below some of the accesses are done as double types and some
; are done as i64 and i32 types. This is a negative test to ensure that they
; are not analyzed as in the tests above.

define void @neg_dist_dep_type_size_equivalence(ptr nocapture %vec, i64 %n) {
; CHECK-LABEL: 'neg_dist_dep_type_size_equivalence'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Backward loop carried data dependence that prevents store-to-load forwarding.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        BackwardVectorizableButPreventsForwarding:
; CHECK-NEXT:            %ld.f64 = load double, ptr %gep.iv, align 8 ->
; CHECK-NEXT:            store double %val, ptr %gep.iv.101.i64, align 8
; CHECK-EMPTY:
; CHECK-NEXT:        ForwardButPreventsForwarding:
; CHECK-NEXT:            store double %val, ptr %gep.iv.101.i64, align 8 ->
; CHECK-NEXT:            %ld.i64 = load i64, ptr %gep.iv, align 8
; CHECK-EMPTY:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            store double %val, ptr %gep.iv.101.i64, align 8 ->
; CHECK-NEXT:            store i32 %ld.i64.i32, ptr %gep.iv.n.i64, align 8
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %loop ]

  ;; Load from vec[indvars.iv] as double
  %gep.iv = getelementptr i64, ptr %vec, i64 %indvars.iv
  %ld.f64 = load double, ptr %gep.iv, align 8
  %val = fmul fast double %ld.f64, 5.0

  ;; Store to vec[indvars.iv + 101] as double
  %indvars.iv.101 = add nsw i64 %indvars.iv, 101
  %gep.iv.101.i64 = getelementptr i64, ptr %vec, i64 %indvars.iv.101
  store double %val, ptr %gep.iv.101.i64, align 8

  ;; Read from vec[indvars.iv] as i64 creating
  ;; a forward but prevents forwarding dependence
  ;; with different types but same sizes.
  %ld.i64 = load i64, ptr %gep.iv, align 8

  ;; Different sizes
  %indvars.iv.n = add nuw nsw i64 %indvars.iv, %n
  %gep.iv.n.i64 = getelementptr inbounds i64, ptr %vec, i64 %indvars.iv.n
  %ld.i64.i32 = trunc i64 %ld.i64 to i32
  store i32 %ld.i64.i32, ptr %gep.iv.n.i64, align 8

  ;; Loop condition.
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cond = icmp eq i64 %indvars.iv.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret void
}

; In the following test, the sink is loop-invariant.

define void @type_size_equivalence_sink_loopinv(ptr nocapture %vec, i64 %n) {
; CHECK-LABEL: 'type_size_equivalence_sink_loopinv'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Memory dependences are safe
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %gep.n = getelementptr inbounds i64, ptr %vec, i64 %n
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]

  %gep.iv = getelementptr i64, ptr %vec, i64 %iv
  %ld.i64 = load i64, ptr %gep.iv, align 8

  %ld.i64.i32 = trunc i64 %ld.i64 to i32
  store i32 %ld.i64.i32, ptr %gep.n, align 8

  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp eq i64 %iv.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret void
}

; Variant of the above, with a negative induction step and a gep exposing
; type-mismtach.

define void @type_size_equivalence_sink_loopinv_negind(ptr nocapture %vec, i64 %n) {
; CHECK-LABEL: 'type_size_equivalence_sink_loopinv_negind'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Memory dependences are safe
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %minus.n = sub nsw i64 0, %n
  %gep.minus.n = getelementptr inbounds i64, ptr %vec, i64 %minus.n
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]

  %minus.iv = sub nsw i64 0, %iv
  %gep.minus.iv = getelementptr i64, ptr %vec, i64 %minus.iv
  %gep.minus.iv.4 = getelementptr i8, ptr %gep.minus.iv, i64 -4
  %ld.i64 = load i64, ptr %gep.minus.iv.4, align 8

  %ld.i64.i32 = trunc i64 %ld.i64 to i32
  store i32 %ld.i64.i32, ptr %gep.minus.n, align 8

  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp eq i64 %iv.next, %n
  br i1 %cond, label %exit, label %loop

exit:
  ret void
}

;       i16       i32
; [ . . 0 0 . . 1 1] [ 1 1 0 0 . . 1 1 ]
;  ^~~^ gep i8 = 1
;  ^ ~~ ^ iv.2 = iv + 2
;       ^ ~~~~~ ^ dependence distance = 4
;              ^ ~~~~~~~~~~~~~~~~~ ^ 8
;       ^ ~~~~~~~~~~~~~~~~ ^ 8
;   ^ ~~~~~~~~~~~~~~~~ ^ iv.next = iv + 8
;
; Measurements are in bytes.
;
; TODO: Relax the HasSameSize check; the strided accesses are
; independent, as determined by both the source size and the sink size.
; This test should report no dependencies.
define void @different_type_sizes_strided_accesses_independent(ptr %dst) {
; CHECK-LABEL: 'different_type_sizes_strided_accesses_independent'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            store i16 0, ptr %gep.iv, align 2 ->
; CHECK-NEXT:            store i32 1, ptr %gep.4.iv, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %gep.4 = getelementptr nuw i8, ptr %dst, i64 4
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.2 = add nuw nsw i64 %iv, 2
  %gep.iv = getelementptr i8, ptr %dst, i64 %iv.2
  store i16 0, ptr %gep.iv
  %gep.4.iv = getelementptr i8, ptr %gep.4, i64 %iv.2
  store i32 1, ptr %gep.4.iv
  %iv.next = add nuw nsw i64 %iv, 8
  %ec = icmp eq i64 %iv.next, 64
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}


;     i16      i64
; [ . 0 0 . 1 1 1 1] [ 1 x x 1 1 1 1 1 ]
;  ^~~^ gep i8 = 1
;  ^~~^ iv.1 = iv + 1
;     ^ ~~ ^ dependence distance = 3
;     ^ ~~~~~~~~~~~~~~~~ ^ 8
;           ^ ~~~~~~~~~~~~~~~~ ^ 8
;   ^ ~~~~~~~~~~~~~~~~ ^ iv.next = iv + 8
;
; TODO: Relax the HasSameSize check; this test should report a backward
; loop-carried dependence.
define void @different_type_sizes_strided_accesses_dependent(ptr %dst) {
; CHECK-LABEL: 'different_type_sizes_strided_accesses_dependent'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            store i16 0, ptr %gep.iv, align 2 ->
; CHECK-NEXT:            store i64 1, ptr %gep.3.iv, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %gep.3 = getelementptr nuw i8, ptr %dst, i64 3
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %iv.1 = add nuw nsw i64 %iv, 1
  %gep.iv = getelementptr i8, ptr %dst, i64 %iv.1
  store i16 0, ptr %gep.iv
  %gep.3.iv = getelementptr i8, ptr %gep.3, i64 %iv.1
  store i64 1, ptr %gep.3.iv
  %iv.next = add nuw nsw i64 %iv, 8
  %ec = icmp eq i64 %iv.next, 64
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

; Variant of the above, where the store size exceeds the dependence
; distance.
define void @different_type_sizes_strided_accesses_store_size_exceeds_depdist(ptr %dst) {
; CHECK-LABEL: 'different_type_sizes_strided_accesses_store_size_exceeds_depdist'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unsafe indirect dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        IndirectUnsafe:
; CHECK-NEXT:            store i16 0, ptr %gep.iv, align 2 ->
; CHECK-NEXT:            store i128 1, ptr %gep.10.iv, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %gep.10 = getelementptr nuw i8, ptr %dst, i64 10
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %gep.iv = getelementptr i8, ptr %dst, i64 %iv
  store i16 0, ptr %gep.iv
  %gep.10.iv = getelementptr i8, ptr %gep.10, i64 %iv
  store i128 1, ptr %gep.10.iv
  %iv.next = add i64 %iv, 8
  %ec = icmp eq i64 %iv.next, 64
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}


; Source type-size differs from that of the sink, but when
; determining backward dependence, only the source size
; is relevant.
; TODO: Relax the HasSameSize check; this test should report
; BackwardVectorizable.
define void @different_type_sizes_source_size_backwardvectorizible(ptr %dst) {
; CHECK-LABEL: 'different_type_sizes_source_size_backwardvectorizible'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            store i16 0, ptr %gep.iv, align 2 ->
; CHECK-NEXT:            store i32 1, ptr %gep.10.iv, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %gep.10 = getelementptr nuw i8, ptr %dst, i64 10
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %gep.iv = getelementptr i8, ptr %dst, i64 %iv
  store i16 0, ptr %gep.iv
  %gep.10.iv = getelementptr i8, ptr %gep.10, i64 %iv
  store i32 1, ptr %gep.10.iv
  %iv.next = add i64 %iv, 8
  %ec = icmp eq i64 %iv.next, 64
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

; Source type-size differs from that of the sink, and when
; determining forward dependence, the source size can
; prevent forwarding.
define void @different_type_sizes_forward(ptr %dst) {
; CHECK-LABEL: 'different_type_sizes_forward'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Memory dependences are safe
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Forward:
; CHECK-NEXT:            store i32 0, ptr %gep.10.iv, align 4 ->
; CHECK-NEXT:            store i16 1, ptr %gep.iv, align 2
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %gep.10 = getelementptr nuw i8, ptr %dst, i64 10
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %gep.10.iv = getelementptr i8, ptr %gep.10, i64 %iv
  store i32 0, ptr %gep.10.iv
  %gep.iv = getelementptr i8, ptr %dst, i64 %iv
  store i16 1, ptr %gep.iv
  %iv.next = add i64 %iv, 8
  %ec = icmp eq i64 %iv.next, 64
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

; Same as the above, but here, the store size should not prevent
; ld->st forwarding.
; TODO: Relax the HasSameSize check; this test should report a
; forward dependence.
define void @different_type_sizes_store_size_cannot_prevent_forwarding(ptr %A, ptr noalias %B) {
; CHECK-LABEL: 'different_type_sizes_store_size_cannot_prevent_forwarding'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Forward loop carried data dependence that prevents store-to-load forwarding.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        ForwardButPreventsForwarding:
; CHECK-NEXT:            store i32 0, ptr %gep.A, align 4 ->
; CHECK-NEXT:            %l = load i16, ptr %gep.A.1, align 2
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %A.1 = getelementptr i32, ptr %A, i64 1
  br label %loop

loop:
  %iv = phi i64 [ 1022, %entry ], [ %iv.next, %loop ]
  %gep.A = getelementptr inbounds i32, ptr %A, i64 %iv
  store i32 0, ptr %gep.A
  %gep.A.1 = getelementptr i32, ptr %A.1, i64 %iv
  %l = load i16, ptr %gep.A.1
  store i16 %l, ptr %B
  %iv.next = add nsw i64 %iv, -1
  %cmp = icmp eq i64 %iv, 0
  br i1 %cmp, label %exit, label %loop

exit:
  ret void
}

; Same as the above, but here, the load size prevents
; ld->st forwarding.
define void @different_type_sizes_load_size_prevents_forwarding(ptr %A, ptr noalias %B) {
; CHECK-LABEL: 'different_type_sizes_load_size_prevents_forwarding'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Forward loop carried data dependence that prevents store-to-load forwarding.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        ForwardButPreventsForwarding:
; CHECK-NEXT:            store i16 0, ptr %gep.A, align 2 ->
; CHECK-NEXT:            %l = load i32, ptr %gep.A.1, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %A.1 = getelementptr i32, ptr %A, i64 1
  br label %loop

loop:
  %iv = phi i64 [ 1022, %entry ], [ %iv.next, %loop ]
  %gep.A = getelementptr inbounds i32, ptr %A, i64 %iv
  store i16 0, ptr %gep.A
  %gep.A.1 = getelementptr i32, ptr %A.1, i64 %iv
  %l = load i32, ptr %gep.A.1
  store i32 %l, ptr %B
  %iv.next = add nsw i64 %iv, -1
  %cmp = icmp eq i64 %iv, 0
  br i1 %cmp, label %exit, label %loop

exit:
  ret void
}
