; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes='print<access-info>' -disable-output %s 2>&1 | FileCheck %s

; unsigned long long s0 = 0, s1 = 0;
; for (int i = 0; i < 100; i++) {
;   if (i % 4 == 0) {
;     A[s0] = 2;  // A[0], A[4], A[8], A[12], ...
;     A[s1] = 1;  // A[0], A[8], A[16], A[24], ...
;   }
;   s0 += (1ULL << 62) + 1;
;   s1 += (1ULL << 62) + 2;
; }
; We cannot use inbounds on idx.0, idx.1 to infer no-wrap (and determine
; there are no dependences), as the pointers are not dereferenced in all loop iterations.
define void @test_inbounds_gep_used_in_predicated_block(ptr %A, i64 %n) {
; CHECK-LABEL: 'test_inbounds_gep_used_in_predicated_block'
; CHECK-NEXT:    loop.header:
; CHECK-NEXT:      Memory dependences are safe
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: %A High: (-4611686018427387705 + %A))
; CHECK-NEXT:            Member: {%A,+,4611686018427387906}<%loop.header>
; CHECK-NEXT:            Member: {%A,+,4611686018427387905}<%loop.header>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-NEXT:      {%A,+,4611686018427387906}<%loop.header> Added Flags: <nusw>
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop.header

loop.header:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop.latch ]
  %offset.0 = phi i64 [ 0, %entry ], [ %offset.0.next, %loop.latch ]
  %offset.1 = phi i64 [ 0, %entry ], [ %offset.1.next, %loop.latch ]
  %idx.0 = getelementptr inbounds i8, ptr %A, i64 %offset.0
  %idx.1 = getelementptr inbounds i8, ptr %A, i64 %offset.1
  %mask = and i64 %i, 3
  %cond = icmp eq i64 %mask, 0
  br i1 %cond, label %if.then, label %loop.latch

if.then:
  store i8 2, ptr %idx.0
  store i8 1, ptr %idx.1
  br label %loop.latch

loop.latch:
  %i.next = add nuw nsw i64 %i, 1
  %offset.0.next = add i64 %offset.0, 4611686018427387905 ; 2^62 + 1
  %offset.1.next = add i64 %offset.1, 4611686018427387906 ; 2^62 + 2
  %cond.exit = icmp eq i64 %i.next, 100
  br i1 %cond.exit, label %exit, label %loop.header

exit:
  ret void
}

; Same as @test_inbounds_gep_used_in_predicated_block, but also storing the
; pointer values in the header.
define void @test_inbounds_gep_used_in_predicated_block_stored_value_operand(ptr %A, i64 %n, ptr noalias %B) {
; CHECK-LABEL: 'test_inbounds_gep_used_in_predicated_block_stored_value_operand'
; CHECK-NEXT:    loop.header:
; CHECK-NEXT:      Memory dependences are safe
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: %A High: (-4611686018427387705 + %A))
; CHECK-NEXT:            Member: {%A,+,4611686018427387906}<%loop.header>
; CHECK-NEXT:            Member: {%A,+,4611686018427387905}<%loop.header>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-NEXT:      {%A,+,4611686018427387906}<%loop.header> Added Flags: <nusw>
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop.header

loop.header:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop.latch ]
  %offset.0 = phi i64 [ 0, %entry ], [ %offset.0.next, %loop.latch ]
  %offset.1 = phi i64 [ 0, %entry ], [ %offset.1.next, %loop.latch ]
  %idx.0 = getelementptr inbounds i8, ptr %A, i64 %offset.0
  %idx.1 = getelementptr inbounds i8, ptr %A, i64 %offset.1
  %mask = and i64 %i, 3
  %cond = icmp eq i64 %mask, 0
  store ptr %idx.0, ptr %B
  store ptr %idx.1, ptr %B
  br i1 %cond, label %if.then, label %loop.latch

if.then:
  store i8 2, ptr %idx.0
  store i8 1, ptr %idx.1
  br label %loop.latch

loop.latch:
  %i.next = add nuw nsw i64 %i, 1
  %offset.0.next = add i64 %offset.0, 4611686018427387905 ; 2^62 + 1
  %offset.1.next = add i64 %offset.1, 4611686018427387906 ; 2^62 + 2
  %cond.exit = icmp eq i64 %i.next, 100
  br i1 %cond.exit, label %exit, label %loop.header

exit:
  ret void
}

; Same as @test_inbounds_gep_used_in_predicated_block_non_memop_user, but with
; extra GEP users in the header.
define void @test_inbounds_gep_used_in_predicated_block_non_memop_user(ptr %A, i64 %n) {
; CHECK-LABEL: 'test_inbounds_gep_used_in_predicated_block_non_memop_user'
; CHECK-NEXT:    loop.header:
; CHECK-NEXT:      Memory dependences are safe
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: %A High: (-4611686018427387705 + %A))
; CHECK-NEXT:            Member: {%A,+,4611686018427387906}<%loop.header>
; CHECK-NEXT:            Member: {%A,+,4611686018427387905}<%loop.header>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-NEXT:      {%A,+,4611686018427387906}<%loop.header> Added Flags: <nusw>
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop.header

loop.header:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop.latch ]
  %offset.0 = phi i64 [ 0, %entry ], [ %offset.0.next, %loop.latch ]
  %offset.1 = phi i64 [ 0, %entry ], [ %offset.1.next, %loop.latch ]
  %idx.0 = getelementptr inbounds i8, ptr %A, i64 %offset.0
  %idx.1 = getelementptr inbounds i8, ptr %A, i64 %offset.1
  %mask = and i64 %i, 3
  %cond = icmp eq i64 %mask, 0
  %gep.idx.0 = getelementptr inbounds i8, ptr %idx.0, i8 1
  %gep.idx.1 = getelementptr inbounds i8, ptr %idx.1, i8 1
  br i1 %cond, label %if.then, label %loop.latch

if.then:
  store i8 2, ptr %idx.0
  store i8 1, ptr %idx.1
  br label %loop.latch

loop.latch:
  %i.next = add nuw nsw i64 %i, 1
  %offset.0.next = add i64 %offset.0, 4611686018427387905 ; 2^62 + 1
  %offset.1.next = add i64 %offset.1, 4611686018427387906 ; 2^62 + 2
  %cond.exit = icmp eq i64 %i.next, 100
  br i1 %cond.exit, label %exit, label %loop.header

exit:
  store i32 0, ptr %gep.idx.0
  store i32 0, ptr %gep.idx.1
  ret void
}

; Test for nusw GEP with load user outside the loop.
; https://github.com/llvm/llvm-project/issues/174760
define i32 @test_nusw_gep_with_load_user_outside_loop(ptr %A) {
; CHECK-LABEL: 'test_nusw_gep_with_load_user_outside_loop'
; CHECK-NEXT:    loop.header:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop.
; CHECK-NEXT:      Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            store i32 0, ptr %A, align 4 ->
; CHECK-NEXT:            store i32 0, ptr %gep, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: (-392 + %A) High: (8 + %A))
; CHECK-NEXT:            Member: {(4 + %A),+,-4}<%loop.header>
; CHECK-NEXT:            Member: %A
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-NEXT:      {true,+,true}<%loop.header> Added Flags: <nusw>
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
; CHECK-NEXT:      [PSE]  %gep = getelementptr nusw i32, ptr %A, i64 %and:
; CHECK-NEXT:        ((4 * (zext i1 {true,+,true}<%loop.header> to i64))<nuw><nsw> + %A)
; CHECK-NEXT:        --> {(4 + %A),+,-4}<%loop.header>
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i64 [ 1, %entry ], [ %iv.next, %loop.latch ]
  %and = and i64 %iv, 1
  %cond = icmp eq i64 %and, 0
  br i1 %cond, label %if.then, label %loop.latch

if.then:
  store i32 0, ptr %A, align 4
  br label %loop.latch

loop.latch:
  %gep = getelementptr nusw i32, ptr %A, i64 %and
  store i32 0, ptr %gep, align 4
  %iv.next = add i64 %iv, 1
  %cmp = icmp ult i64 %iv, 100
  br i1 %cmp, label %loop.header, label %exit

exit:
  ; Load user of %gep is outside the loop. blockNeedsPredication should not be
  ; called on exit block.
  %l = load i32, ptr %gep, align 4
  ret i32 %l
}

define void @test_header_existing(ptr %src, ptr %dst, i64 %start) {
; CHECK-LABEL: 'test_header_existing'
; CHECK-NEXT:    loop.header:
; CHECK-NEXT:      Memory dependences are safe with run-time checks
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Check 0:
; CHECK-NEXT:        Comparing group GRP0:
; CHECK-NEXT:        ptr %dst
; CHECK-NEXT:        Against group GRP1:
; CHECK-NEXT:          %gep.src = getelementptr nusw { i8, i8, i32 }, ptr %src, i64 %iv.next
; CHECK-NEXT:      Grouped accesses:
; CHECK-NEXT:        Group GRP0:
; CHECK-NEXT:          (Low: %dst High: (1 + %dst))
; CHECK-NEXT:            Member: %dst
; CHECK-NEXT:        Group GRP1:
; CHECK-NEXT:          (Low: (8 + (8 * %start) + %src) High: (809 + %src))
; CHECK-NEXT:            Member: {(8 + (8 * %start) + %src),+,8}<%loop.header>
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  br label %loop.header

loop.header:
  %iv = phi i64 [ %start, %entry ], [ %iv.next, %loop.latch ]
  %ec = icmp eq i64 %iv, 100
  br i1 %ec, label %exit, label %loop.latch

loop.latch:
  %iv.next = add i64 %iv, 1
  %gep.src = getelementptr nusw { i8, i8, i32 }, ptr %src, i64 %iv.next
  %l = load i8, ptr %gep.src, align 1
  store i8 %l, ptr %dst, align 1
  br label %loop.header

exit:
  ret void
}
