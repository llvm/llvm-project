; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='print<access-info>' -disable-output %s 2>&1 | FileCheck %s

; Test that LAA correctly identifies Write-After-Write dependencies with negative
; distances as unsafe. Previously, LAA would incorrectly classify negative distance
; WAW dependencies as safe Forward dependencies, allowing inappropriate vectorization.
;
; This corresponds to the loop:
;   for(int i = 0; i < n; ++i) {
;       A[(i+1)*4] = 10;   // First store: A[4, 8, 12, 16, ...]
;       A[i] = 100;        // Second store: A[0, 1, 2, 3, 4, ...]
;   }
;
; The dependence distance from first store to second store is negative:
; A[i] - A[(i+1)*4] = {0,+,4} - {16,+,16} = {-16,+,-12}
; However, the dependence from second store to first store in the next iteration
; would be positive: A[(i+1)*4] - A[i] = {16,+,16} - {0,+,4} = {16,+,12}
;
; This bidirectional dependence pattern (negative in one direction, positive in the
; other) creates a Write-After-Write dependency that is unsafe for vectorization.
; DependenceAnalysis would report this as "output [<>]!" indicating the complex
; dependence direction. LAA must detect this as unsafe even when only checking
; the negative distance direction.

define void @test_waw_negative_dependence(i64 %n, ptr nocapture %A) {
; CHECK-LABEL: 'test_waw_negative_dependence'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            store i32 10, ptr %arrayidx1, align 4 ->
; CHECK-NEXT:            store i32 100, ptr %arrayidx2, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %cmp8 = icmp sgt i64 %n, 0
  br i1 %cmp8, label %loop, label %exit

loop:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1

  ; First store: A[(i+1)*4] = 10
  %0 = shl nsw i64 %indvars.iv.next, 2  ; (i+1)*4
  %arrayidx1 = getelementptr inbounds i32, ptr %A, i64 %0
  store i32 10, ptr %arrayidx1, align 4

  ; Second store: A[i] = 100
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %indvars.iv
  store i32 100, ptr %arrayidx2, align 4

  %exitcond.not = icmp eq i64 %indvars.iv.next, %n
  br i1 %exitcond.not, label %exit, label %loop

exit:
  ret void
}

; Test a similar case but with different stride to ensure the fix is general.
define void @test_waw_negative_dependence_different_stride(i64 %n, ptr nocapture %A) {
; CHECK-LABEL: 'test_waw_negative_dependence_different_stride'
; CHECK-NEXT:    loop:
; CHECK-NEXT:      Report: unsafe dependent memory operations in loop. Use #pragma clang loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
; CHECK-NEXT:  Unknown data dependence.
; CHECK-NEXT:      Dependences:
; CHECK-NEXT:        Unknown:
; CHECK-NEXT:            store i32 10, ptr %arrayidx1, align 4 ->
; CHECK-NEXT:            store i32 100, ptr %arrayidx2, align 4
; CHECK-EMPTY:
; CHECK-NEXT:      Run-time memory checks:
; CHECK-NEXT:      Grouped accesses:
; CHECK-EMPTY:
; CHECK-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; CHECK-NEXT:      SCEV assumptions:
; CHECK-EMPTY:
; CHECK-NEXT:      Expressions re-written:
;
entry:
  %cmp8 = icmp sgt i64 %n, 0
  br i1 %cmp8, label %loop, label %exit

loop:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %loop ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1

  ; First store: A[(i+2)*2] = 10
  %0 = add nsw i64 %indvars.iv, 2       ; i+2
  %1 = shl nsw i64 %0, 1                ; (i+2)*2
  %arrayidx1 = getelementptr inbounds i32, ptr %A, i64 %1
  store i32 10, ptr %arrayidx1, align 4

  ; Second store: A[i] = 100
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %indvars.iv
  store i32 100, ptr %arrayidx2, align 4

  %exitcond.not = icmp eq i64 %indvars.iv.next, %n
  br i1 %exitcond.not, label %exit, label %loop

exit:
  ret void
}
