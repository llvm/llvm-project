; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes='print<access-info>' -disable-output %s 2>&1 | FileCheck --check-prefix=DEFAULT %s
; RUN: opt -passes='print<access-info>' -disable-output -max-dependences=5 %s 2>&1 | FileCheck --check-prefix=MAXDEP5 %s

define void @dependences_with_strides(ptr %dst, i64 %stride) {
; DEFAULT-LABEL: 'dependences_with_strides'
; DEFAULT-NEXT:    loop:
; DEFAULT-NEXT:      Memory dependences are safe with run-time checks
; DEFAULT-NEXT:      Dependences:
; DEFAULT-NEXT:      Run-time memory checks:
; DEFAULT-NEXT:      Check 0:
; DEFAULT-NEXT:        Comparing group GRP0:
; DEFAULT-NEXT:          %ptr.iv = phi ptr [ %dst, %entry ], [ %ptr.iv.next, %loop ]
; DEFAULT-NEXT:        Against group GRP1:
; DEFAULT-NEXT:          %gep.stride = getelementptr i16, ptr %ptr.iv, i64 %stride
; DEFAULT-NEXT:      Check 1:
; DEFAULT-NEXT:        Comparing group GRP0:
; DEFAULT-NEXT:          %ptr.iv = phi ptr [ %dst, %entry ], [ %ptr.iv.next, %loop ]
; DEFAULT-NEXT:        Against group GRP2:
; DEFAULT-NEXT:        ptr %dst
; DEFAULT-NEXT:      Check 2:
; DEFAULT-NEXT:        Comparing group GRP1:
; DEFAULT-NEXT:          %gep.stride = getelementptr i16, ptr %ptr.iv, i64 %stride
; DEFAULT-NEXT:        Against group GRP2:
; DEFAULT-NEXT:        ptr %dst
; DEFAULT-NEXT:      Grouped accesses:
; DEFAULT-NEXT:        Group GRP0:
; DEFAULT-NEXT:          (Low: %dst High: (4 + %dst))
; DEFAULT-NEXT:            Member: {%dst,+,2}<nw><%loop>
; DEFAULT-NEXT:        Group GRP1:
; DEFAULT-NEXT:          (Low: ((2 * %stride) + %dst) High: (4 + (2 * %stride) + %dst))
; DEFAULT-NEXT:            Member: {((2 * %stride) + %dst),+,2}<nw><%loop>
; DEFAULT-NEXT:        Group GRP2:
; DEFAULT-NEXT:          (Low: %dst High: (2 + %dst))
; DEFAULT-NEXT:            Member: %dst
; DEFAULT-EMPTY:
; DEFAULT-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; DEFAULT-NEXT:      SCEV assumptions:
; DEFAULT-EMPTY:
; DEFAULT-NEXT:      Expressions re-written:
;
; MAXDEP5-LABEL: 'dependences_with_strides'
; MAXDEP5-NEXT:    loop:
; MAXDEP5-NEXT:      Memory dependences are safe with run-time checks
; MAXDEP5-NEXT:      Too many dependences, not recorded
; MAXDEP5-NEXT:      Run-time memory checks:
; MAXDEP5-NEXT:      Check 0:
; MAXDEP5-NEXT:        Comparing group GRP0:
; MAXDEP5-NEXT:          %ptr.iv = phi ptr [ %dst, %entry ], [ %ptr.iv.next, %loop ]
; MAXDEP5-NEXT:        Against group GRP1:
; MAXDEP5-NEXT:          %gep.stride = getelementptr i16, ptr %ptr.iv, i64 %stride
; MAXDEP5-NEXT:      Check 1:
; MAXDEP5-NEXT:        Comparing group GRP0:
; MAXDEP5-NEXT:          %ptr.iv = phi ptr [ %dst, %entry ], [ %ptr.iv.next, %loop ]
; MAXDEP5-NEXT:        Against group GRP2:
; MAXDEP5-NEXT:        ptr %dst
; MAXDEP5-NEXT:      Check 2:
; MAXDEP5-NEXT:        Comparing group GRP1:
; MAXDEP5-NEXT:          %gep.stride = getelementptr i16, ptr %ptr.iv, i64 %stride
; MAXDEP5-NEXT:        Against group GRP2:
; MAXDEP5-NEXT:        ptr %dst
; MAXDEP5-NEXT:      Grouped accesses:
; MAXDEP5-NEXT:        Group GRP0:
; MAXDEP5-NEXT:          (Low: %dst High: (4 + %dst))
; MAXDEP5-NEXT:            Member: {%dst,+,2}<nw><%loop>
; MAXDEP5-NEXT:        Group GRP1:
; MAXDEP5-NEXT:          (Low: ((2 * %stride) + %dst) High: (4 + (2 * %stride) + %dst))
; MAXDEP5-NEXT:            Member: {((2 * %stride) + %dst),+,2}<nw><%loop>
; MAXDEP5-NEXT:        Group GRP2:
; MAXDEP5-NEXT:          (Low: %dst High: (2 + %dst))
; MAXDEP5-NEXT:            Member: %dst
; MAXDEP5-EMPTY:
; MAXDEP5-NEXT:      Non vectorizable stores to invariant address were not found in loop.
; MAXDEP5-NEXT:      SCEV assumptions:
; MAXDEP5-EMPTY:
; MAXDEP5-NEXT:      Expressions re-written:
;
entry:
  br label %loop

loop:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
  %ptr.iv = phi ptr [ %dst, %entry ], [ %ptr.iv.next, %loop ]
  store i16 0, ptr %ptr.iv, align 2
  %gep.stride = getelementptr i16, ptr %ptr.iv, i64 %stride
  store i16 0, ptr %gep.stride, align 2
  store i16 0, ptr %dst, align 2
  store i16 0, ptr %ptr.iv, align 2
  %ptr.iv.next = getelementptr i8, ptr %ptr.iv, i64 2
  %iv.next = add i32 %iv, 1
  %exitcond.not = icmp eq i32 %iv, 1
  br i1 %exitcond.not, label %exit, label %loop

exit:
  ret void
}
