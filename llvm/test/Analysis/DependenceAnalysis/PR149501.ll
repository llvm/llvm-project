; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -disable-output "-passes=print<da>" 2>&1 | FileCheck %s

; Test case for GitHub issue #149501: DA bound check with symbolic expressions.
; The issue occurs when symbolic upper bounds and deltas create impossible runtime assumptions.
; Our fix improves the bound check logic to handle these cases more gracefully.

; Case 1: Symbolic case that was problematic - improved bound checking.
define void @f_symbolic(ptr %a, i64 %n, i64 %m) {
; CHECK-LABEL: 'f_symbolic'
; CHECK-NEXT:  Src: store i8 40, ptr %idx.0, align 1 --> Dst: store i8 40, ptr %idx.0, align 1
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i8 40, ptr %idx.0, align 1 --> Dst: store i8 42, ptr %idx.1, align 1
; CHECK-NEXT:    da analyze - consistent output [*|<]!
; CHECK-NEXT:  Src: store i8 42, ptr %idx.1, align 1 --> Dst: store i8 42, ptr %idx.1, align 1
; CHECK-NEXT:    da analyze - none!
;
entry:
  %bound = sub i64 %m, %n
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
  %subscript.0 = add i64 %i, %n
  %subscript.1 = add i64 %i, %m
  %idx.0 = getelementptr i8, ptr %a, i64 %subscript.0
  %idx.1 = getelementptr i8, ptr %a, i64 %subscript.1
  store i8 40, ptr %idx.0
  store i8 42, ptr %idx.1
  %i.next = add i64 %i, 1
  %cond.exit = icmp eq i64 %i.next, %bound
  br i1 %cond.exit, label %exit, label %loop

exit:
  ret void
}

; Case 2: Case with negative bound - correctly handled by improved bound check.
define void @f_negative_bound(ptr %a) {
; CHECK-LABEL: 'f_negative_bound'
; CHECK-NEXT:  Src: store i8 40, ptr %idx.0, align 1 --> Dst: store i8 40, ptr %idx.0, align 1
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i8 40, ptr %idx.0, align 1 --> Dst: store i8 42, ptr %idx.1, align 1
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i8 42, ptr %idx.1, align 1 --> Dst: store i8 42, ptr %idx.1, align 1
; CHECK-NEXT:    da analyze - none!
;
entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
  %idx.0 = getelementptr i8, ptr %a, i64 %i
  %idx.1 = getelementptr i8, ptr %a, i64 %i
  store i8 40, ptr %idx.0
  store i8 42, ptr %idx.1
  %i.next = add i64 %i, 1
  %cond.exit = icmp eq i64 %i.next, 0    ; bound = 0 (negative upper bound)
  br i1 %cond.exit, label %exit, label %loop

exit:
  ret void
}

; Case 3: Same location access with positive bound - should show output dependence.
define void @f_same_location(ptr %a) {
; CHECK-LABEL: 'f_same_location'
; CHECK-NEXT:  Src: store i8 40, ptr %idx.0, align 1 --> Dst: store i8 40, ptr %idx.0, align 1
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i8 40, ptr %idx.0, align 1 --> Dst: store i8 42, ptr %idx.1, align 1
; CHECK-NEXT:    da analyze - consistent output [0|<]!
; CHECK-NEXT:  Src: store i8 42, ptr %idx.1, align 1 --> Dst: store i8 42, ptr %idx.1, align 1
; CHECK-NEXT:    da analyze - none!
;
entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
  %idx.0 = getelementptr i8, ptr %a, i64 %i      ; a[i]
  %idx.1 = getelementptr i8, ptr %a, i64 %i      ; a[i] - same location!
  store i8 40, ptr %idx.0
  store i8 42, ptr %idx.1
  %i.next = add i64 %i, 1
  %cond.exit = icmp eq i64 %i.next, 10   ; positive bound
  br i1 %cond.exit, label %exit, label %loop

exit:
  ret void
}
