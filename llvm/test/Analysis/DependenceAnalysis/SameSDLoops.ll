; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -disable-output "-passes=print<da>" 2>&1 \
; RUN:   -da-disable-delinearization-checks | FileCheck %s


;;  for (long int i = 0; i < 10; i++) {
;;    for (long int j = 0; j < 10; j++) {
;;      for (long int k = 0; k < 10; k++) {
;;        for (long int l = 0; l < 10; l++)
;;          A[i][j][k][l] = i;
;;      }
;;      for (long int k = 1; k < 11; k++) {
;;        for (long int l = 0; l < 10; l++)
;;          A[i + 4][j + 3][k + 2][l + 1] = l;

define void @samebd0(ptr %A) nounwind uwtable ssp {
; CHECK-LABEL: 'samebd0'
; CHECK-NEXT:  Src: store i64 %i.013, ptr %arrayidx12, align 8 --> Dst: store i64 %i.013, ptr %arrayidx12, align 8
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i64 %i.013, ptr %arrayidx12, align 8 --> Dst: store i64 %l17.04, ptr %arrayidx24, align 8
; CHECK-NEXT:    da analyze - output [-4 -3]! / assuming 2 loop level(s) fused: [-4 -3 -3 -1]!
; CHECK-NEXT:  Src: store i64 %l17.04, ptr %arrayidx24, align 8 --> Dst: store i64 %l17.04, ptr %arrayidx24, align 8
; CHECK-NEXT:    da analyze - none!
;
entry:
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.inc33
  %i.013 = phi i64 [ %inc34, %for.inc33 ], [ 0, %entry ]
  br label %for.cond4.preheader

for.cond4.preheader:                              ; preds = %for.cond1.preheader, %for.inc30
  %j.09 = phi i64 [ %inc31, %for.inc30 ], [ 0, %for.cond1.preheader ]
  br label %for.cond7.preheader

for.cond7.preheader:                              ; preds = %for.cond4.preheader, %for.inc12
  %k.07 = phi i64 [ %inc13, %for.inc12 ], [ 0, %for.cond4.preheader ]
  br label %for.body9

for.body9:                                        ; preds = %for.cond7.preheader, %for.body9
  %l.02 = phi i64 [ %inc11, %for.body9 ], [ 0, %for.cond7.preheader ]
  %arrayidx12 = getelementptr inbounds [100 x [100 x [100 x i64]]], ptr %A, i64 %i.013, i64 %j.09, i64 %k.07, i64 %l.02
  store i64 %i.013, ptr %arrayidx12, align 8
  %inc11 = add nsw i64 %l.02, 1
  %exitcond15 = icmp ne i64 %inc11, 10
  br i1 %exitcond15, label %for.body9, label %for.inc12

for.inc12:                                        ; preds = %for.body9
  %inc13 = add nsw i64 %k.07, 1
  %exitcond16 = icmp ne i64 %inc13, 10
  br i1 %exitcond16, label %for.cond7.preheader, label %for.cond18.preheader

for.cond18.preheader:                             ; preds = %for.inc12, %for.inc27
  %k14.06 = phi i64 [ %inc28, %for.inc27 ], [ 1, %for.inc12 ]
  br label %for.body20

for.body20:                                       ; preds = %for.cond18.preheader, %for.body20
  %l17.04 = phi i64 [ %inc25, %for.body20 ], [ 0, %for.cond18.preheader ]
  %add = add nsw i64 %l17.04, 1
  %add21 = add nsw i64 %k14.06, 2
  %add22 = add nsw i64 %j.09, 3
  %add23 = add nsw i64 %i.013, 4
  %arrayidx24 = getelementptr inbounds [100 x [100 x [100 x i64]]], ptr %A, i64 %add23, i64 %add22, i64 %add21, i64 %add
  store i64 %l17.04, ptr %arrayidx24, align 8
  %inc25 = add nsw i64 %l17.04, 1
  %exitcond = icmp ne i64 %inc25, 10
  br i1 %exitcond, label %for.body20, label %for.inc27

for.inc27:                                        ; preds = %for.body20
  %inc28 = add nsw i64 %k14.06, 1
  %exitcond17 = icmp ne i64 %inc28, 11
  br i1 %exitcond17, label %for.cond18.preheader, label %for.inc30

for.inc30:                                        ; preds = %for.inc27
  %inc31 = add nsw i64 %j.09, 1
  %exitcond18 = icmp ne i64 %inc31, 10
  br i1 %exitcond18, label %for.cond4.preheader, label %for.inc33

for.inc33:                                        ; preds = %for.inc30
  %inc34 = add nsw i64 %i.013, 1
  %exitcond19 = icmp ne i64 %inc34, 10
  br i1 %exitcond19, label %for.cond1.preheader, label %for.end35

for.end35:                                        ; preds = %for.inc33
  ret void
}


;;  for (long int i = 0; i < 10; i++)
;;    A[4*i + 2] = i;
;;  for (long int j = 0; j < 10; j++)
;;    tmp = A[j + 2];

define void @samebd1(ptr %A) nounwind uwtable ssp {
; CHECK-LABEL: 'samebd1'
; CHECK-NEXT:  Src: store i64 %i.03, ptr %arrayidx, align 4 --> Dst: store i64 %i.03, ptr %arrayidx, align 4
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i64 %i.03, ptr %arrayidx, align 4 --> Dst: %0 = load i64, ptr %arrayidx7, align 4
; CHECK-NEXT:    da analyze - flow [|<]! / assuming 1 loop level(s) fused: [<=|<]!
; CHECK-NEXT:  Src: %0 = load i64, ptr %arrayidx7, align 4 --> Dst: %0 = load i64, ptr %arrayidx7, align 4
; CHECK-NEXT:    da analyze - none!
;
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.03 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %mul = shl nsw i64 %i.03, 2
  %add = add nsw i64 %mul, 2

  %arrayidx = getelementptr inbounds i64, ptr %A, i64 %add
  store i64 %i.03, ptr %arrayidx, align 4
  %inc = add nsw i64 %i.03, 1
  %exitcond5 = icmp ne i64 %inc, 10
  br i1 %exitcond5, label %for.body, label %for.body4.preheader

for.body4.preheader:                              ; preds = %for.body
  br label %for.body4

for.body4:                                        ; preds = %for.body4.preheader, %for.body4
  %j.02 = phi i64 [ %inc9, %for.body4 ], [ 0, %for.body4.preheader ]
  %add64 = add nsw i64 %j.02, 2
  %arrayidx7 = getelementptr inbounds i64, ptr %A, i64 %add64
  %0 = load i64, ptr %arrayidx7, align 4
  %inc9 = add nsw i64 %j.02, 1
  %exitcond = icmp ne i64 %inc9, 10
  br i1 %exitcond, label %for.body4, label %for.end10

for.end10:                                        ; preds = %for.body4
  ret void
}


;; No information for SameSD loops is generated as MIV test is not supported
;; on separate loops yet.
;;  for (long int i = 0; i < 10; i++) {
;;    for (long int j = 0; j < 10; j++) {
;;      for (long int k = 0; k < 10; k++) {
;;        for (long int l = 0; l < 10; l++)
;;          A[i][j][k][l] = i;
;;      }
;;      for (long int k = 1; k < 11; k++) {
;;        for (long int l = 0; l < 10; l++)
;;          A[i + 4][j + 3][k + 2][k + l] = l;

define void @non_samebd0(ptr %A) nounwind uwtable ssp {
; CHECK-LABEL: 'non_samebd0'
; CHECK-NEXT:  Src: store i64 %i.013, ptr %arrayidx12, align 8 --> Dst: store i64 %i.013, ptr %arrayidx12, align 8
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i64 %i.013, ptr %arrayidx12, align 8 --> Dst: store i64 %l17.04, ptr %arrayidx24, align 8
; CHECK-NEXT:    da analyze - output [-4 -3]!{{$}}
; CHECK-NEXT:  Src: store i64 %l17.04, ptr %arrayidx24, align 8 --> Dst: store i64 %l17.04, ptr %arrayidx24, align 8
; CHECK-NEXT:    da analyze - none!
;
entry:
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.inc33
  %i.013 = phi i64 [ %inc34, %for.inc33 ], [ 0, %entry ]
  br label %for.cond4.preheader

for.cond4.preheader:                              ; preds = %for.cond1.preheader, %for.inc30
  %j.09 = phi i64 [ %inc31, %for.inc30 ], [ 0, %for.cond1.preheader ]
  br label %for.cond7.preheader

for.cond7.preheader:                              ; preds = %for.cond4.preheader, %for.inc12
  %k.07 = phi i64 [ %inc13, %for.inc12 ], [ 0, %for.cond4.preheader ]
  br label %for.body9

for.body9:                                        ; preds = %for.cond7.preheader, %for.body9
  %l.02 = phi i64 [ %inc11, %for.body9 ], [ 0, %for.cond7.preheader ]
  %arrayidx12 = getelementptr inbounds [100 x [100 x [100 x i64]]], ptr %A, i64 %i.013, i64 %j.09, i64 %k.07, i64 %l.02
  store i64 %i.013, ptr %arrayidx12, align 8
  %inc11 = add nsw i64 %l.02, 1
  %exitcond15 = icmp ne i64 %inc11, 10
  br i1 %exitcond15, label %for.body9, label %for.inc12

for.inc12:                                        ; preds = %for.body9
  %inc13 = add nsw i64 %k.07, 1
  %exitcond16 = icmp ne i64 %inc13, 10
  br i1 %exitcond16, label %for.cond7.preheader, label %for.cond18.preheader

for.cond18.preheader:                             ; preds = %for.inc12, %for.inc27
  %k14.06 = phi i64 [ %inc28, %for.inc27 ], [ 1, %for.inc12 ]
  br label %for.body20

for.body20:                                       ; preds = %for.cond18.preheader, %for.body20
  %l17.04 = phi i64 [ %inc25, %for.body20 ], [ 0, %for.cond18.preheader ]
  %add = add nsw i64 %k14.06, %l17.04
  %add21 = add nsw i64 %k14.06, 2
  %add22 = add nsw i64 %j.09, 3
  %add23 = add nsw i64 %i.013, 4
  %arrayidx24 = getelementptr inbounds [100 x [100 x [100 x i64]]], ptr %A, i64 %add23, i64 %add22, i64 %add21, i64 %add
  store i64 %l17.04, ptr %arrayidx24, align 8
  %inc25 = add nsw i64 %l17.04, 1
  %exitcond = icmp ne i64 %inc25, 10
  br i1 %exitcond, label %for.body20, label %for.inc27

for.inc27:                                        ; preds = %for.body20
  %inc28 = add nsw i64 %k14.06, 1
  %exitcond17 = icmp ne i64 %inc28, 11
  br i1 %exitcond17, label %for.cond18.preheader, label %for.inc30

for.inc30:                                        ; preds = %for.inc27
  %inc31 = add nsw i64 %j.09, 1
  %exitcond18 = icmp ne i64 %inc31, 10
  br i1 %exitcond18, label %for.cond4.preheader, label %for.inc33

for.inc33:                                        ; preds = %for.inc30
  %inc34 = add nsw i64 %i.013, 1
  %exitcond19 = icmp ne i64 %inc34, 10
  br i1 %exitcond19, label %for.cond1.preheader, label %for.end35

for.end35:                                        ; preds = %for.inc33
  ret void
}


;; Loops with different tripcounts are not considered as SameBD
;;  for (long int i = 0; i < 10; i++)
;;    A[4*i + 2] = i;
;;  for (long int j = 0; j < 11; j++)
;;    tmp = A[j + 2];

define void @non_samebd1(ptr %A) nounwind uwtable ssp {
; CHECK-LABEL: 'non_samebd1'
; CHECK-NEXT:  Src: store i64 %i.03, ptr %arrayidx, align 4 --> Dst: store i64 %i.03, ptr %arrayidx, align 4
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i64 %i.03, ptr %arrayidx, align 4 --> Dst: %0 = load i64, ptr %arrayidx7, align 4
; CHECK-NEXT:    da analyze - flow [|<]!{{$}}
; CHECK-NEXT:  Src: %0 = load i64, ptr %arrayidx7, align 4 --> Dst: %0 = load i64, ptr %arrayidx7, align 4
; CHECK-NEXT:    da analyze - none!
;
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.03 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %mul = shl nsw i64 %i.03, 2
  %add = add nsw i64 %mul, 2

  %arrayidx = getelementptr inbounds i64, ptr %A, i64 %add
  store i64 %i.03, ptr %arrayidx, align 4
  %inc = add nsw i64 %i.03, 1
  %exitcond5 = icmp ne i64 %inc, 10
  br i1 %exitcond5, label %for.body, label %for.body4.preheader

for.body4.preheader:                              ; preds = %for.body
  br label %for.body4

for.body4:                                        ; preds = %for.body4.preheader, %for.body4
  %j.02 = phi i64 [ %inc9, %for.body4 ], [ 0, %for.body4.preheader ]
  %add64 = add nsw i64 %j.02, 2
  %arrayidx7 = getelementptr inbounds i64, ptr %A, i64 %add64
  %0 = load i64, ptr %arrayidx7, align 4
  %inc9 = add nsw i64 %j.02, 1
  %exitcond = icmp ne i64 %inc9, 11
  br i1 %exitcond, label %for.body4, label %for.end10

for.end10:                                        ; preds = %for.body4
  ret void
}
