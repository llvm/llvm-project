; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -disable-output "-passes=print<da>" 2>&1 | FileCheck %s

; Test case for wrapping AddRec detection using constant max backedge taken count.
; This ensures that wrapping detection works even when exact BTC is not available
; but we can get a conservative upper bound.

; Test case where loop has variable bound but SCEV can provide max BTC estimate.
; The i2 type can only represent 0,1,2,3, so if we iterate more than 4 times
; with step=1, we'll get wrapping: 0,1,2,3,0,1,2,3...

define void @test_wrapping_with_maxbtc(ptr %a, i32 %n) {
; CHECK-LABEL: 'test_wrapping_with_maxbtc'
; CHECK-NEXT:  Src: store i8 0, ptr %idx, align 1 --> Dst: store i8 0, ptr %idx, align 1
; CHECK-NEXT:    da analyze - output [*]!
;
entry:
  %bound = and i32 %n, 1023    ; Limit n to at most 1024
  %cmp = icmp sgt i32 %bound, 0
  br i1 %cmp, label %loop, label %exit

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %i.narrow = trunc i32 %i to i2      ; Only 2 bits: wraps after 4 iterations
  %zext = zext i2 %i.narrow to i64
  %idx = getelementptr inbounds [8 x i8], ptr %a, i64 0, i64 %zext
  store i8 0, ptr %idx
  %i.next = add i32 %i, 1
  %exitcond = icmp slt i32 %i.next, %bound  ; Variable upper bound
  br i1 %exitcond, label %loop, label %exit

exit:
  ret void
}
