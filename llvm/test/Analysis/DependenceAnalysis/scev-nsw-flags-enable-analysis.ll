; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -disable-output "-passes=print<da>" -aa-pipeline=basic-aa 2>&1 | FileCheck %s

; Test that SCEV NSW flag preservation enables dependence analysis to work
; correctly. Previously, SCEV would lose NSW flags when combining AddRec
; expressions from GEP operations, causing dependence analysis to incorrectly
; classify expressions as "wrapping" and fail analysis.

define void @test_da_with_scev_flags(ptr %A) {
; This test verifies that dependence analysis now correctly identifies
; self-dependences when SCEV preserves NSW flags from GEP index computations.
; CHECK-LABEL: 'test_da_with_scev_flags'
; CHECK-NEXT:  Src: %val = load i32, ptr %gep, align 4 --> Dst: %val = load i32, ptr %gep, align 4
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: %val = load i32, ptr %gep, align 4 --> Dst: store i32 %val, ptr %gep, align 4
; CHECK-NEXT:    da analyze - consistent anti [0|<]!
; CHECK-NEXT:  Src: store i32 %val, ptr %gep, align 4 --> Dst: store i32 %val, ptr %gep, align 4
; CHECK-NEXT:    da analyze - none!
;

entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]

  ; Create NSW-flagged index computation
  %mul = mul nsw i64 %i, 3
  %sub = add nsw i64 %mul, -6

  ; GEP that should result in SCEV: {(-2424 + %A),+,1212}<nw>
  ; The <nw> flag should prevent false "wrapping" detection in DA
  %gep = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub

  ; Self-dependence: should be detected as "none" (no dependence)
  %val = load i32, ptr %gep
  store i32 %val, ptr %gep

  %i.next = add nsw i64 %i, 1
  %cond = icmp ult i64 %i.next, 50
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}
