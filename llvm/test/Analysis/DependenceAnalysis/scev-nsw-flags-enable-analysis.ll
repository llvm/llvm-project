; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -disable-output "-passes=print<da>" -aa-pipeline=basic-aa 2>&1 | FileCheck %s

; Test that SCEV NSW flag preservation enables dependence analysis to work
; correctly. Previously, SCEV would lose NSW flags when combining AddRec
; expressions from GEP operations, causing dependence analysis to incorrectly
; classify expressions as "wrapping" and fail analysis.

; Test showing different GEPs with same pattern work correctly
define void @test_da_different_geps(ptr %A) {
; CHECK-LABEL: 'test_da_different_geps'
; CHECK-NEXT:  Src: store i32 %conv, ptr %gep1, align 4 --> Dst: store i32 %conv, ptr %gep1, align 4
; CHECK-NEXT:    da analyze - none!
; CHECK-NEXT:  Src: store i32 %conv, ptr %gep1, align 4 --> Dst: %val = load i32, ptr %gep2, align 4
; CHECK-NEXT:    da analyze - flow [*|<]!
; CHECK-NEXT:  Src: %val = load i32, ptr %gep2, align 4 --> Dst: %val = load i32, ptr %gep2, align 4
; CHECK-NEXT:    da analyze - none!
;

entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]

  ; NSW-flagged arithmetic
  %mul = mul nsw i64 %i, 3
  %sub = add nsw i64 %mul, -6

  ; Two different access patterns that DA can now analyze correctly
  %gep1 = getelementptr inbounds [100 x i32], ptr %A, i64 %sub, i64 %sub
  %gep2 = getelementptr inbounds [100 x i32], ptr %A, i64 %i, i64 %i

  %conv = trunc i64 %i to i32
  store i32 %conv, ptr %gep1
  %val = load i32, ptr %gep2

  %i.next = add nsw i64 %i, 1
  %cond = icmp ult i64 %i.next, 50
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}
