; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -disable-output "-passes=print<da>" 2>&1 | FileCheck %s

; Test case for bug #148435 - SIV test assertion failure.
; This test ensures that testSIV handles the case where neither Src nor Dst
; expressions contain AddRec after propagation, which can happen when
; constraints simplify the expressions to non-AddRec forms.

define void @_Z1cb(ptr %a) {
; CHECK-LABEL: '_Z1cb'
; CHECK-NEXT:  Src: store i8 0, ptr %arrayidx9, align 1 --> Dst: store i8 0, ptr %arrayidx9, align 1
; CHECK-NEXT:    da analyze - output [*]!
;
entry:
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  ret void

for.body:                                         ; preds = %for.body, %entry
  %indvars.iv23 = phi i64 [ 0, %entry ], [ %indvars.iv.next24, %for.body ]
  %idxprom = and i64 %indvars.iv23, 1
  %arrayidx9 = getelementptr inbounds [0 x [12 x [12 x i8]]], ptr %a, i64 0, i64 %idxprom, i64 0, i64 %indvars.iv23
  store i8 0, ptr %arrayidx9, align 1
  %indvars.iv.next24 = add i64 %indvars.iv23, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next24, 0
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

@a = external global [0 x [12 x [12 x i8]]], align 1

define void @test_siv_no_addrec(i1 %d, i32 %b) {
; CHECK-LABEL: 'test_siv_no_addrec'
; CHECK-NEXT:  Src: store i8 0, ptr %arrayidx7, align 1 --> Dst: store i8 0, ptr %arrayidx7, align 1
; CHECK-NEXT:    da analyze - output [* *]!
;
entry:
  %conv.val = select i1 %d, i16 1, i16 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc8, %entry
  %e.0 = phi i32 [ %b, %entry ], [ %inc9, %for.inc8 ]
  %cmp = icmp ult i32 %e.0, 10
  br i1 %cmp, label %for.cond1, label %for.end10

for.cond1:                                        ; preds = %for.inc, %for.cond
  %f.0 = phi i16 [ %conv.val, %for.cond ], [ %add, %for.inc ]
  %cmp2 = icmp slt i16 %f.0, 10
  br i1 %cmp2, label %for.body4, label %for.inc8

for.body4:                                        ; preds = %for.cond1
  %sub = add i32 %e.0, -3
  %idxprom = zext i32 %sub to i64
  %idxprom5 = sext i16 %f.0 to i64
  %idxprom6 = zext i32 %e.0 to i64
  %arrayidx7 = getelementptr inbounds [0 x [12 x [12 x i8]]], ptr @a, i64 0, i64 %idxprom, i64 %idxprom5, i64 %idxprom6
  store i8 0, ptr %arrayidx7, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %add = add i16 %f.0, 2
  br label %for.cond1

for.inc8:                                         ; preds = %for.cond1
  %inc9 = add i32 %e.0, 1
  br label %for.cond

for.end10:                                        ; preds = %for.cond
  ret void
}

define void @f1(ptr %a) {
; CHECK-LABEL: 'f1'
; CHECK-NEXT:  Src: store i8 0, ptr %idx, align 1 --> Dst: store i8 0, ptr %idx, align 1
; CHECK-NEXT:    da analyze - consistent output [*]!
;
entry:
  br label %loop

loop:
  %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
  %and = and i64 %i, 1
  %idx = getelementptr inbounds [4 x [4 x i8]], ptr %a, i64 0, i64 %and, i64 %and
  store i8 0, ptr %idx
  %i.next = add i64 %i, 1
  %exitcond.not = icmp slt i64 %i.next, 8
  br i1 %exitcond.not, label %loop, label %exit

exit:
  ret void
}
