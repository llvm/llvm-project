; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes="correlated-propagation" -S | FileCheck %s

; This test is reduced from b2ShapeCast@box2d/distance.ll, where correlated-propagation
; performs different behavior under different orderings of the IVs in phi.
define void @foo(i32 %v) {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i32 [[V:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 false, label %[[CASE2:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    switch i32 [[V]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 3, label %[[EXIT:.*]]
; CHECK-NEXT:      i32 2, label %[[CASE2]]
; CHECK-NEXT:      i32 1, label %[[CASE1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE2]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 1, %[[CASE1]] ], [ 2, %[[CASE2]] ], [ [[V]], %[[IF_ELSE]] ]
; CHECK-NEXT:    br label %[[SWITCH:.*]]
; CHECK:       [[SWITCH]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[UNREACH:.*:]]
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 false, label %case2, label %if.else

if.else:                                          ; preds = %entry
  switch i32 %v, label %default [
  i32 3, label %exit
  i32 2, label %case2
  i32 1, label %case1
  ]

case1:                                            ; preds = %if.else
  br label %default

case2:                                            ; preds = %if.else, %entry
  br label %default

default:                                          ; preds = %case2, %case1, %if.else
  %phi = phi i32 [ 1, %case1 ], [ 2, %case2 ], [ %v, %if.else ]
  br label %switch

switch:                                           ; preds = %default
  switch i32 %phi, label %exit [
  i32 3, label %unreach
  ]

unreach:                                          ; preds = %switch
  br label %exit

exit:                                             ; preds = %unreach, %switch, %if.else
  ret void
}

define void @foo_with_diff_IV_order(i32 %v) {
; CHECK-LABEL: define void @foo_with_diff_IV_order(
; CHECK-SAME: i32 [[V:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 false, label %[[CASE2:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    switch i32 [[V]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 3, label %[[EXIT:.*]]
; CHECK-NEXT:      i32 2, label %[[CASE2]]
; CHECK-NEXT:      i32 1, label %[[CASE1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE2]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 2, %[[CASE2]] ], [ [[V]], %[[IF_ELSE]] ], [ 1, %[[CASE1]] ]
; CHECK-NEXT:    br label %[[SWITCH:.*]]
; CHECK:       [[SWITCH]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[UNREACH:.*:]]
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  br i1 false, label %case2, label %if.else

if.else:                                          ; preds = %entry
  switch i32 %v, label %default [
  i32 3, label %exit
  i32 2, label %case2
  i32 1, label %case1
  ]

case1:                                            ; preds = %if.else
  br label %default

case2:                                            ; preds = %if.else, %entry
  br label %default

default:                                          ; preds = %case2, %case1, %if.else
  %phi = phi i32 [ 2, %case2 ], [ %v, %if.else ], [ 1, %case1 ]
  br label %switch

switch:                                           ; preds = %default
  switch i32 %phi, label %exit [
  i32 3, label %unreach
  ]

unreach:                                          ; preds = %switch
  br label %exit

exit:                                             ; preds = %unreach, %switch, %if.else
  ret void
}

define void @foo_nonlocal(i32 %v) {
; CHECK-LABEL: define void @foo_nonlocal(
; CHECK-SAME: i32 [[V:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    switch i32 [[V]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 3, label %[[EXIT:.*]]
; CHECK-NEXT:      i32 2, label %[[CASE2:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE2]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    br label %[[SWITCH:.*]]
; CHECK:       [[SWITCH]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[UNREACH:.*:]]
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  switch i32 %v, label %default [
  i32 3, label %exit
  i32 2, label %case2
  i32 1, label %case1
  ]

case1:                                            ; preds = %entry
  br label %default

case2:                                            ; preds = %entry
  br label %default

default:                                          ; preds = %case2, %case1, %entry
  br label %switch

switch:                                           ; preds = %default
  switch i32 %v, label %exit [
  i32 3, label %unreach
  ]

unreach:                                          ; preds = %switch
  br label %exit

exit:                                             ; preds = %unreach, %switch, %entry
  ret void
}

define void @foo_with_diff_pred_order(i32 %v) {
; CHECK-LABEL: define void @foo_with_diff_pred_order(
; CHECK-SAME: i32 [[V:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    switch i32 [[V]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i32 3, label %[[EXIT:.*]]
; CHECK-NEXT:      i32 2, label %[[CASE2:.*]]
; CHECK-NEXT:      i32 1, label %[[CASE1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    br label %[[SWITCH:.*]]
; CHECK:       [[CASE2]]:
; CHECK-NEXT:    br label %[[CASE1]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    br label %[[CASE1]]
; CHECK:       [[SWITCH]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[UNREACH:.*:]]
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  switch i32 %v, label %default [
  i32 3, label %exit
  i32 2, label %case2
  i32 1, label %case1
  ]

case1:                                            ; preds = %default, %case2, %entry
  br label %switch

case2:                                            ; preds = %entry
  br label %case1

default:                                          ; preds = %entry
  br label %case1

switch:                                           ; preds = %case1
  switch i32 %v, label %exit [
  i32 3, label %unreach
  ]

unreach:                                          ; preds = %switch
  br label %exit

exit:                                             ; preds = %unreach, %switch, %entry
  ret void
}

define i32 @bar(i32 range(i32 4, 1) %v1, i8 %v2) {
; CHECK-LABEL: define range(i32 4, 3) i32 @bar(
; CHECK-SAME: i32 range(i32 4, 1) [[V1:%.*]], i8 [[V2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    switch i8 [[V2]], label %[[DEFAULT:.*]] [
; CHECK-NEXT:      i8 0, label %[[CASE0:.*]]
; CHECK-NEXT:      i8 1, label %[[CASE1:.*]]
; CHECK-NEXT:    ]
; CHECK:       [[CASE0]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[CASE1]]:
; CHECK-NEXT:    br label %[[DEFAULT]]
; CHECK:       [[DEFAULT]]:
; CHECK-NEXT:    [[RET:%.*]] = phi i32 [ 2, %[[CASE1]] ], [ [[V1]], %[[ENTRY]] ], [ 1, %[[CASE0]] ]
; CHECK-NEXT:    ret i32 [[RET]]
;
entry:
  switch i8 %v2, label %default [
  i8 0, label %case0
  i8 1, label %case1
  ]

case0:                                            ; preds = %entry
  br label %default

case1:                                            ; preds = %entry
  br label %default

default:                                          ; preds = %case1, %case0, %entry
  %ret = phi i32 [ 2, %case1 ], [ %v1, %entry ], [ 1, %case0 ]
  ret i32 %ret
}

define <2 x i8> @phi_vector_merge(i1 %c) {
; CHECK-LABEL: define range(i8 2, -72) <2 x i8> @phi_vector_merge(
; CHECK-SAME: i1 [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br i1 [[C]], label %[[IF:.*]], label %[[JOIN:.*]]
; CHECK:       [[IF]]:
; CHECK-NEXT:    br label %[[JOIN]]
; CHECK:       [[JOIN]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi <2 x i8> [ <i8 0, i8 -76>, %[[ENTRY]] ], [ <i8 60, i8 120>, %[[IF]] ]
; CHECK-NEXT:    [[ADD:%.*]] = add nuw <2 x i8> [[PHI]], <i8 2, i8 3>
; CHECK-NEXT:    ret <2 x i8> [[ADD]]
;
entry:
  br i1 %c, label %if, label %join

if:                                               ; preds = %entry
  br label %join

join:                                             ; preds = %if, %entry
  %phi = phi <2 x i8> [ <i8 0, i8 -76>, %entry ], [ <i8 60, i8 120>, %if ]
  %add = add <2 x i8> %phi, <i8 2, i8 3>
  ret <2 x i8> %add
}
