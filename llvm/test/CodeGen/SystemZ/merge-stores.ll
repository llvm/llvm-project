; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc < %s -mtriple=s390x-linux-gnu -stop-after finalize-isel | FileCheck %s

target datalayout = "E-m:e-i1:8:16-i8:8:16-i64:64-f128:64-v128:64-a:8:16-n32:64"

%struct.a = type { i16, i32 }

@e = dso_local global %struct.a { i16 9, i32 0 }, align 8
@f = dso_local local_unnamed_addr global ptr @e, align 8
@d = dso_local local_unnamed_addr global i32 0, align 4

; FIXME: This shows a miscompile caused by merging truncated
; stores if there is a 64-bit store (stg) of the load from '@e'.

define signext i32 @main() {
  ; CHECK-LABEL: name: main
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   [[LGRL:%[0-9]+]]:gr64bit = LGRL @e :: (dereferenceable load (s64) from @e)
  ; CHECK-NEXT:   [[SRLG:%[0-9]+]]:gr64bit = SRLG [[LGRL]], $noreg, 32
  ; CHECK-NEXT:   [[LGRL1:%[0-9]+]]:addr64bit = LGRL @f :: (dereferenceable load (s64) from @f)
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gr32bit = COPY [[SRLG]].subreg_l32
  ; CHECK-NEXT:   ST killed [[COPY]], [[LGRL1]], 0, $noreg :: (store (s32) into %ir.t1)
  ; CHECK-NEXT:   STG [[LGRL]], [[LGRL1]], 0, $noreg :: (store (s64) into %ir.t1, align 4)
  ; CHECK-NEXT:   [[LHI:%[0-9]+]]:gr32bit = LHI 0
  ; CHECK-NEXT:   STHRL killed [[LHI]], @e :: (store (s16) into @e, align 8)
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gr32bit = COPY [[LGRL]].subreg_l32
  ; CHECK-NEXT:   STRL killed [[COPY1]], @d :: (store (s32) into @d)
  ; CHECK-NEXT:   [[LGHI:%[0-9]+]]:gr64bit = LGHI 0
  ; CHECK-NEXT:   $r2d = COPY [[LGHI]]
  ; CHECK-NEXT:   Return implicit $r2d
  %e = load i64, ptr @e, align 8
  %esh = lshr i64 %e, 32
  %ehi = trunc i64 %esh to i32
  %elo = trunc i64 %e to i32
  %t1 = load ptr, ptr @f, align 8
  store i32 %ehi, ptr %t1, align 4
  %f4 = getelementptr inbounds i8, ptr %t1, i64 4
  store i32 %elo, ptr %f4, align 4
  store i16 0, ptr @e, align 8
  store i32 %elo, ptr @d, align 4
  ret i32 0
}
