# RUN: llc -o - %s -mtriple=s390x-linux-gnu -mcpu=z16 -verify-machineinstrs \
# RUN:   -run-pass=machine-scheduler -debug-only=machine-scheduler 2>&1\
# RUN:   | FileCheck %s

# The CDFBR has a longer latency than the VL64, so schedule it above.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun0:%bb.0
# CHECK:      Region is not tiny.
# CHECK:      Latency scheduling enabled.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK-NEXT: SU(0):   %0:gr32bit = COPY $r2l
# CHECK-NEXT: SU(2):   %2:fp64bit = nofpexcept CDFBR %0:gr32bit, implicit $fpc
# CHECK-NEXT: SU(1):   %1:vr64bit = VL64 $noreg, 0, $noreg
# CHECK-NEXT: SU(3):   undef %3.subreg_h64:vr128bit = nofpexcept WFDDB %1:vr64bit,
---
name:            fun0
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $r2l
  
    %0:gr32bit = COPY $r2l
    %1:vr64bit = VL64 $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    %2:fp64bit = nofpexcept CDFBR %0, implicit $fpc
    undef %3.subreg_h64:vr128bit = nofpexcept WFDDB %1, %2, implicit $fpc
    %4:vr128bit = VGBM 0
    %5:vr128bit = VMRHG %3, %4
    VST %5, $noreg, 0, $noreg :: (store (s128) into `ptr null`, align 8)
    Return
...

# The TMLMux will be scheduled first even though the LA is available and of lesser
# height, because the TMLMux Depth equals the remaining latency (on CP).
# Then, the AGHIK will follow even though it also have a Height of 1, because
# it does not increase the scheduled latency as the TMLMux also has a Height of 1.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun1:%bb.0
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun1:%bb.1
# CHECK:      Region is not tiny.
# CHECK:      Latency scheduling enabled.
# CHECK:      SU(2):   %3:addr64bit = LA %3:addr64bit, 1, $noreg
# CHECK:        Depth              : 0
# CHECK:        Height             : 0
# CHECK:      SU(9):   dead %13:gr64bit = AGHIK %12:gr64bit, -1,
# CHECK:        Depth              : 6
# CHECK:        Height             : 1
# CHECK:      SU(10):   TMLMux %0:gr32bit, 1, implicit-def $cc
# CHECK:        Depth              : 6
# CHECK:        Height             : 1
# CHECK:      Queue BotQ.A: 2 10
# CHECK:      Scheduling SU(10)
# CHECK:      Queue BotQ.A: 2 9 1
# CHECK:      Scheduling SU(9)
# CHECK:      *** Final schedule for %bb.1 ***
# CHECK:      SU(2):   %3:addr64bit = LA %3:addr64bit, 1, $noreg
# CHECK-NEXT: SU(9):   dead %13:gr64bit = AGHIK %12:gr64bit, -1,
# CHECK-NEXT: SU(10):  TMLMux %0:gr32bit, 1, implicit-def $cc
---
name:            fun1
tracksRegLiveness: true
body:             |
  bb.0:
    successors: %bb.1(0x80000000)
    liveins: $r2l, $r3l
  
    %0:gr32bit = COPY $r3l
    %1:gr32bit = COPY $r2l
    %2:gr32bit = COPY %0
    %3:addr64bit = LGHI 0
    %4:gr64bit = COPY %3
    %5:gr32bit = COPY %2
    J %bb.1
  
  bb.1:
    successors: %bb.1(0x80000000)
  
    %6:gr32bit = MSRKC %1, %5, implicit-def dead $cc
    %2:gr32bit = ORK %6, %2, implicit-def dead $cc
    %3:addr64bit = LA %3, 1, $noreg
    %7:gr64bit = COPY %4   ; Make region non-tiny.
    %8:gr64bit = COPY %7   ;
    %9:gr64bit = COPY %8   ;
    %10:gr64bit = COPY %9  ;
    %11:gr64bit = COPY %10 ;
    %12:gr64bit = COPY %11 ;
    %13:gr64bit = AGHIK %12, -1, implicit-def dead $cc
    TMLMux %0, 1, implicit-def $cc
    BRC 15, 7, %bb.1, implicit killed $cc
    Return
...

# This region has many nodes compared to the maximum height: Don't
# care about heights/latencies. The AGRKs will remain interleaved with
# the COPYs instead of all ending up at the bottom.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun2:%bb.0
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling disabled.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK-NEXT: SU(0):   %0:gr64bit = COPY undef %1:gr64bit
# CHECK-NEXT: SU(1):   dead %2:gr64bit = AGRK %0:gr64bit, %0:gr64bit,
# CHECK-NEXT: SU(2):   %3:gr64bit = COPY undef %1:gr64bit
# CHECK-NEXT: SU(3):   dead %4:gr64bit = AGRK %3:gr64bit, %3:gr64bit,
# CHECK-NEXT: SU(4):   %5:gr64bit = COPY undef %1:gr64bit
# CHECK-NEXT: SU(5):   dead %6:gr64bit = AGRK %5:gr64bit, %5:gr64bit,
# CHECK-NEXT: SU(6):   %7:gr64bit = COPY undef %1:gr64bit
# CHECK-NEXT: SU(7):   dead %8:gr64bit = AGRK %7:gr64bit, %7:gr64bit,
# CHECK-NEXT: SU(8):   %9:gr64bit = COPY undef %1:gr64bit
# CHECK-NEXT: SU(9):   dead %10:gr64bit = AGRK %9:gr64bit, %9:gr64bit,
# CHECK-NEXT: SU(10):  %11:gr64bit = COPY undef %1:gr64bit
# CHECK-NEXT: SU(11):  dead %12:gr64bit = AGRK %11:gr64bit, %11:gr64bit,
---
name:            fun2
tracksRegLiveness: true
body:             |
  bb.0:
    %1:gr64bit = COPY undef %0:gr64bit
    %2:gr64bit = AGRK %1, %1, implicit-def dead $cc
    %3:gr64bit = COPY undef %0:gr64bit
    %4:gr64bit = AGRK %3, %3, implicit-def dead $cc
    %5:gr64bit = COPY undef %0:gr64bit
    %6:gr64bit = AGRK %5, %5, implicit-def dead $cc
    %7:gr64bit = COPY undef %0:gr64bit
    %8:gr64bit = AGRK %7, %7, implicit-def dead $cc
    %9:gr64bit = COPY undef %0:gr64bit
    %10:gr64bit = AGRK %9, %9, implicit-def dead $cc
    %11:gr64bit = COPY undef %0:gr64bit
    %12:gr64bit = AGRK %11, %11, implicit-def dead $cc
    Return
...

# The first WFDDB is scheduled first as it is on the Critical Path below the
# other WFDDB. The CDFBR is then scheduled below the VL64 per the original order
# even though it has a greater height as neither of these SUs would extend the
# scheduled latency.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun3:%bb.0
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling enabled.
# CHECK:      SU(1):   dead %1:vr64bit = VL64 $noreg, 0, $noreg ::
# CHECK:        Height             : 3
# CHECK:      SU(2):   dead %2:fp64bit = nofpexcept CDFBR %0:gr32bit,
# CHECK:        Height             : 6
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK:      SU(5):   undef %6.subreg_h64:vr128bit = WFDDB %3:vr64bit, %4:vr64bit,
# CHECK-NEXT: SU(1):   dead %1:vr64bit = VL64 $noreg, 0, $noreg ::
# CHECK-NEXT: SU(2):   dead %2:fp64bit = nofpexcept CDFBR %0:gr32bit,
# CHECK:      SU(8):   dead undef %10.subreg_h64:vr128bit = WFDDB %7:vr64bit,
---
name:            fun3
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $r2l

    %0:gr32bit = COPY $r2l
    %1:vr64bit = VL64 $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    %2:fp64bit = nofpexcept CDFBR %0, implicit $fpc
    %3:vr64bit = COPY undef %3:vr64bit
    %5:vr64bit = COPY undef %4:vr64bit
    undef %6.subreg_h64:vr128bit = WFDDB %3, %5, implicit $fpc
    %7:vr64bit = COPY %6.subreg_h64:vr128bit
    %9:vr64bit = COPY undef %8:vr64bit
    undef %10.subreg_h64:vr128bit = WFDDB %7, %9, implicit $fpc
    Return
...
