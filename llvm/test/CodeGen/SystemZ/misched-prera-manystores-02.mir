# RUN: llc -o - %s -mtriple=s390x-linux-gnu -mcpu=z196 -verify-machineinstrs \
# RUN:   -run-pass=machine-scheduler -debug-only=machine-scheduler 2>&1 \
# RUN:   | FileCheck %s
# REQUIRES: asserts

--- |
  define void @fun0(ptr noalias %src1, ptr noalias %dest) { ret void }
  define void @fun1(ptr noalias %src1, ptr noalias %dest) { ret void }
  define void @fun2(ptr noalias %src1, ptr noalias %dest) { ret void }
...

# Test that stores in a group are not scheduled high if the register is live
# already. After the first 'STE %7', the second one will be scheduled above
# it.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun0:%bb.0
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling enabled.
# CHECK:      Has StoresGroup of 9 stores.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK-NEXT: SU(0):   %0:addr64bit = COPY $r3d
# CHECK-NEXT: SU(1):   %1:addr64bit = COPY $r2d
# CHECK-NEXT: SU(2):   %2:fp32bit = LE %1:addr64bit, 28, $noreg ::
# CHECK-NEXT: SU(17):  %2:fp32bit = nofpexcept AEBR %2:fp32bit(tied-def 0), %2:fp32bit,
# CHECK-NEXT: SU(18):  STE %2:fp32bit, %0:addr64bit, 28, $noreg ::
# CHECK-NEXT: SU(3):   %3:fp32bit = LE %1:addr64bit, 24, $noreg ::
# CHECK-NEXT: SU(16):  %3:fp32bit = nofpexcept AEBR %3:fp32bit(tied-def 0), %3:fp32bit,
# CHECK-NEXT: SU(19):  STE %3:fp32bit, %0:addr64bit, 24, $noreg ::
# CHECK-NEXT: SU(4):   %4:fp32bit = LE %1:addr64bit, 20, $noreg ::
# CHECK-NEXT: SU(15):  %4:fp32bit = nofpexcept AEBR %4:fp32bit(tied-def 0), %4:fp32bit,
# CHECK-NEXT: SU(20):  STE %4:fp32bit, %0:addr64bit, 20, $noreg ::
# CHECK-NEXT: SU(5):   %5:fp32bit = LE %1:addr64bit, 16, $noreg ::
# CHECK-NEXT: SU(14):  %5:fp32bit = nofpexcept AEBR %5:fp32bit(tied-def 0), %5:fp32bit,
# CHECK-NEXT: SU(21):  STE %5:fp32bit, %0:addr64bit, 16, $noreg ::
# CHECK-NEXT: SU(6):   %6:fp32bit = LE %1:addr64bit, 12, $noreg ::
# CHECK-NEXT: SU(13):  %6:fp32bit = nofpexcept AEBR %6:fp32bit(tied-def 0), %6:fp32bit,
# CHECK-NEXT: SU(22):  STE %6:fp32bit, %0:addr64bit, 12, $noreg ::
# CHECK-NEXT: SU(8):   %8:fp32bit = LE %1:addr64bit, 4, $noreg ::
# CHECK-NEXT: SU(11):  %8:fp32bit = nofpexcept AEBR %8:fp32bit(tied-def 0), %8:fp32bit,
# CHECK-NEXT: SU(24):  STE %8:fp32bit, %0:addr64bit, 4, $noreg ::
# CHECK-NEXT: SU(9):   %9:fp32bit = LE %1:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(10):  %9:fp32bit = nofpexcept AEBR %9:fp32bit(tied-def 0), %9:fp32bit,
# CHECK-NEXT: SU(25):  STE %9:fp32bit, %0:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(7):   %7:fp32bit = LE %1:addr64bit, 8, $noreg ::
# CHECK-NEXT: SU(12):  %7:fp32bit = nofpexcept AEBR %7:fp32bit(tied-def 0), %7:fp32bit,
# CHECK-NEXT: SU(23):  STE %7:fp32bit, %0:addr64bit, 8, $noreg ::
# CHECK-NEXT: SU(26):  STE %7:fp32bit, %0:addr64bit, 0, $noreg ::
---
name:            fun0
tracksRegLiveness: true
body:             |
  bb.0 (%ir-block.0):
    liveins: $r2d, $r3d
  
    %0:addr64bit = COPY $r3d
    %1:addr64bit = COPY $r2d
    %2:fp32bit = LE %1, 28, $noreg :: (load (s32) from %ir.src1 + 28, basealign 64)
    %3:fp32bit = LE %1, 24, $noreg :: (load (s32) from %ir.src1 + 24, align 8, basealign 64)
    %4:fp32bit = LE %1, 20, $noreg :: (load (s32) from %ir.src1 + 20, basealign 64)
    %5:fp32bit = LE %1, 16, $noreg :: (load (s32) from %ir.src1 + 16, align 16, basealign 64)
    %6:fp32bit = LE %1, 12, $noreg :: (load (s32) from %ir.src1 + 12, basealign 64)
    %7:fp32bit = LE %1, 8, $noreg :: (load (s32) from %ir.src1 + 8, align 8, basealign 64)
    %8:fp32bit = LE %1, 4, $noreg :: (load (s32) from %ir.src1 + 4, basealign 64)
    %9:fp32bit = LE %1, 0, $noreg :: (load (s32) from %ir.src1, align 64)
    %9:fp32bit = nofpexcept AEBR %9, %9, implicit-def dead $cc, implicit $fpc
    %8:fp32bit = nofpexcept AEBR %8, %8, implicit-def dead $cc, implicit $fpc
    %7:fp32bit = nofpexcept AEBR %7, %7, implicit-def dead $cc, implicit $fpc
    %6:fp32bit = nofpexcept AEBR %6, %6, implicit-def dead $cc, implicit $fpc
    %5:fp32bit = nofpexcept AEBR %5, %5, implicit-def dead $cc, implicit $fpc
    %4:fp32bit = nofpexcept AEBR %4, %4, implicit-def dead $cc, implicit $fpc
    %3:fp32bit = nofpexcept AEBR %3, %3, implicit-def dead $cc, implicit $fpc
    %2:fp32bit = nofpexcept AEBR %2, %2, implicit-def dead $cc, implicit $fpc
    STE %2, %0, 28, $noreg :: (store (s32) into %ir.dest + 28, basealign 64)
    STE %3, %0, 24, $noreg :: (store (s32) into %ir.dest + 24, align 8, basealign 64)
    STE %4, %0, 20, $noreg :: (store (s32) into %ir.dest + 20, basealign 64)
    STE %5, %0, 16, $noreg :: (store (s32) into %ir.dest + 16, align 16, basealign 64)
    STE %6, %0, 12, $noreg :: (store (s32) into %ir.dest + 12, basealign 64)
    STE %7, %0, 8, $noreg :: (store (s32) into %ir.dest + 8, align 8, basealign 64)
    STE %8, %0, 4, $noreg :: (store (s32) into %ir.dest + 4, basealign 64)
    STE %9, %0, 0, $noreg :: (store (s32) into %ir.dest, align 64)
    STE %7, %0, 0, $noreg :: (store (s32) into %ir.dest + 8, align 8, basealign 64)
    Return
...

# Test that stores in a group are scheduled regardless of making an address
# register live.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun1:%bb.0
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling enabled.
# CHECK:      Has StoresGroup of 8 stores.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK-NEXT: SU(0):   %0:addr64bit = COPY $r3d
# CHECK-NEXT: SU(1):   %1:addr64bit = COPY $r2d
# CHECK-NEXT: SU(3):   %3:fp32bit = LE %1:addr64bit, 28, $noreg ::
# CHECK-NEXT: SU(18):  %3:fp32bit = nofpexcept AEBR %3:fp32bit(tied-def 0), %3:fp32bit,
# CHECK-NEXT: SU(19):  STE %3:fp32bit, %0:addr64bit, 28, $noreg ::
# CHECK-NEXT: SU(4):   %4:fp32bit = LE %1:addr64bit, 24, $noreg ::
# CHECK-NEXT: SU(17):  %4:fp32bit = nofpexcept AEBR %4:fp32bit(tied-def 0), %4:fp32bit,
# CHECK-NEXT: SU(20):  STE %4:fp32bit, %0:addr64bit, 24, $noreg ::
# CHECK-NEXT: SU(5):   %5:fp32bit = LE %1:addr64bit, 20, $noreg ::
# CHECK-NEXT: SU(16):  %5:fp32bit = nofpexcept AEBR %5:fp32bit(tied-def 0), %5:fp32bit,
# CHECK-NEXT: SU(21):  STE %5:fp32bit, %0:addr64bit, 20, $noreg ::
# CHECK-NEXT: SU(6):   %6:fp32bit = LE %1:addr64bit, 16, $noreg ::
# CHECK-NEXT: SU(15):  %6:fp32bit = nofpexcept AEBR %6:fp32bit(tied-def 0), %6:fp32bit,
# CHECK-NEXT: SU(22):  STE %6:fp32bit, %0:addr64bit, 16, $noreg ::
# CHECK-NEXT: SU(7):   %7:fp32bit = LE %1:addr64bit, 12, $noreg ::
# CHECK-NEXT: SU(14):  %7:fp32bit = nofpexcept AEBR %7:fp32bit(tied-def 0), %7:fp32bit,
# CHECK-NEXT: SU(23):  STE %7:fp32bit, %0:addr64bit, 12, $noreg ::
# CHECK-NEXT: SU(8):   %8:fp32bit = LE %1:addr64bit, 8, $noreg ::
# CHECK-NEXT: SU(13):  %8:fp32bit = nofpexcept AEBR %8:fp32bit(tied-def 0), %8:fp32bit,
# CHECK-NEXT: SU(2):   %OffsReg:addr64bit = LGHI 8
# CHECK-NEXT: SU(24):  STE %8:fp32bit, %0:addr64bit, 0, %OffsReg:addr64bit ::
# CHECK-NEXT: SU(9):   %9:fp32bit = LE %1:addr64bit, 4, $noreg ::
# CHECK-NEXT: SU(12):  %9:fp32bit = nofpexcept AEBR %9:fp32bit(tied-def 0), %9:fp32bit,
# CHECK-NEXT: SU(25):  STE %9:fp32bit, %0:addr64bit, 4, $noreg ::
# CHECK-NEXT: SU(10):  %10:fp32bit = LE %1:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(11):  %10:fp32bit = nofpexcept AEBR %10:fp32bit(tied-def 0), %10:fp32bit,
# CHECK-NEXT: SU(26):  STE %10:fp32bit, %0:addr64bit, 0, $noreg ::
---
name:            fun1
tracksRegLiveness: true
body:             |
  bb.0 (%ir-block.0):
    liveins: $r2d, $r3d
  
    %0:addr64bit = COPY $r3d
    %1:addr64bit = COPY $r2d
    %OffsReg:addr64bit = LGHI 8
    %3:fp32bit = LE %1, 28, $noreg :: (load (s32) from %ir.src1 + 28, basealign 64)
    %4:fp32bit = LE %1, 24, $noreg :: (load (s32) from %ir.src1 + 24, align 8, basealign 64)
    %5:fp32bit = LE %1, 20, $noreg :: (load (s32) from %ir.src1 + 20, basealign 64)
    %6:fp32bit = LE %1, 16, $noreg :: (load (s32) from %ir.src1 + 16, align 16, basealign 64)
    %7:fp32bit = LE %1, 12, $noreg :: (load (s32) from %ir.src1 + 12, basealign 64)
    %8:fp32bit = LE %1, 8, $noreg :: (load (s32) from %ir.src1 + 8, align 8, basealign 64)
    %9:fp32bit = LE %1, 4, $noreg :: (load (s32) from %ir.src1 + 4, basealign 64)
    %10:fp32bit = LE %1, 0, $noreg :: (load (s32) from %ir.src1, align 64)
    %10:fp32bit = nofpexcept AEBR %10, %10, implicit-def dead $cc, implicit $fpc
    %9:fp32bit = nofpexcept AEBR %9, %9, implicit-def dead $cc, implicit $fpc
    %8:fp32bit = nofpexcept AEBR %8, %8, implicit-def dead $cc, implicit $fpc
    %7:fp32bit = nofpexcept AEBR %7, %7, implicit-def dead $cc, implicit $fpc
    %6:fp32bit = nofpexcept AEBR %6, %6, implicit-def dead $cc, implicit $fpc
    %5:fp32bit = nofpexcept AEBR %5, %5, implicit-def dead $cc, implicit $fpc
    %4:fp32bit = nofpexcept AEBR %4, %4, implicit-def dead $cc, implicit $fpc
    %3:fp32bit = nofpexcept AEBR %3, %3, implicit-def dead $cc, implicit $fpc
    STE %3, %0, 28, $noreg :: (store (s32) into %ir.dest + 28, basealign 64)
    STE %4, %0, 24, $noreg :: (store (s32) into %ir.dest + 24, align 8, basealign 64)
    STE %5, %0, 20, $noreg :: (store (s32) into %ir.dest + 20, basealign 64)
    STE %6, %0, 16, $noreg :: (store (s32) into %ir.dest + 16, align 16, basealign 64)
    STE %7, %0, 12, $noreg :: (store (s32) into %ir.dest + 12, basealign 64)
    STE %8, %0, 0, %OffsReg :: (store (s32) into %ir.dest + 8, align 8, basealign 64)
    STE %9, %0, 4, $noreg :: (store (s32) into %ir.dest + 4, basealign 64)
    STE %10, %0, 0, $noreg :: (store (s32) into %ir.dest, align 64)
    Return
...

# Test that stores are not rescheduled in smaller groups.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun2:%bb.0
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling enabled.
# CHECK:      No StoresGroup.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK-NEXT: SU(0):   %0:addr64bit = COPY $r3d
# CHECK-NEXT: SU(1):   %1:addr64bit = COPY $r2d
# CHECK-NEXT: SU(2):   %2:fp32bit = LE %1:addr64bit, 12, $noreg ::
# CHECK-NEXT: SU(3):   %3:fp32bit = LE %1:addr64bit, 8, $noreg ::
# CHECK-NEXT: SU(4):   %4:fp32bit = LE %1:addr64bit, 4, $noreg ::
# CHECK-NEXT: SU(5):   %5:fp32bit = LE %1:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(6):   %5:fp32bit = nofpexcept AEBR %5:fp32bit(tied-def 0), %5:fp32bit,
# CHECK-NEXT: SU(7):   %4:fp32bit = nofpexcept AEBR %4:fp32bit(tied-def 0), %4:fp32bit,
# CHECK-NEXT: SU(8):   %3:fp32bit = nofpexcept AEBR %3:fp32bit(tied-def 0), %3:fp32bit,
# CHECK-NEXT: SU(9):   %2:fp32bit = nofpexcept AEBR %2:fp32bit(tied-def 0), %2:fp32bit,
# CHECK-NEXT: SU(10):  STE %2:fp32bit, %0:addr64bit, 12, $noreg ::
# CHECK-NEXT: SU(11):  STE %3:fp32bit, %0:addr64bit, 8, $noreg ::
# CHECK-NEXT: SU(12):  STE %4:fp32bit, %0:addr64bit, 4, $noreg ::
# CHECK-NEXT: SU(13):  STE %5:fp32bit, %0:addr64bit, 0, $noreg ::
---
name:            fun2
tracksRegLiveness: true
body:             |
  bb.0 (%ir-block.0):
    liveins: $r2d, $r3d
  
    %0:addr64bit = COPY $r3d
    %1:addr64bit = COPY $r2d
    %2:fp32bit = LE %1, 12, $noreg :: (load (s32) from %ir.src1 + 12, basealign 64)
    %3:fp32bit = LE %1, 8, $noreg :: (load (s32) from %ir.src1 + 8, align 8, basealign 64)
    %4:fp32bit = LE %1, 4, $noreg :: (load (s32) from %ir.src1 + 4, basealign 64)
    %5:fp32bit = LE %1, 0, $noreg :: (load (s32) from %ir.src1, align 64)
    %5:fp32bit = nofpexcept AEBR %5, %5, implicit-def dead $cc, implicit $fpc
    %4:fp32bit = nofpexcept AEBR %4, %4, implicit-def dead $cc, implicit $fpc
    %3:fp32bit = nofpexcept AEBR %3, %3, implicit-def dead $cc, implicit $fpc
    %2:fp32bit = nofpexcept AEBR %2, %2, implicit-def dead $cc, implicit $fpc
    STE %2, %0, 12, $noreg :: (store (s32) into %ir.dest + 12, basealign 64)
    STE %3, %0, 8, $noreg :: (store (s32) into %ir.dest + 8, align 8, basealign 64)
    STE %4, %0, 4, $noreg :: (store (s32) into %ir.dest + 4, basealign 64)
    STE %5, %0, 0, $noreg :: (store (s32) into %ir.dest, align 64)
    Return
...
