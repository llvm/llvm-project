; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; Test Flag Output Operands with 14 combinations of CCMASK and optimizations.
; Different ways of parenthesizing with mix of == and != operator for
; AND/OR/XOR combinations.

; RUN: llc < %s -verify-machineinstrs -mtriple=s390x-linux-gnu -O3 | FileCheck %s

; Test ((cc == 0) || (cc != 1)) ^ (cc != 2)
define signext range(i32 0, 43) i32 @bar_012_OR_XOR(i32 noundef signext %x){
; CHECK-LABEL: bar_012_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %xor6 = icmp ult i32 %2, 2
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

declare void @llvm.assume(i1 noundef) #1

; Test ((cc == 0) || (cc != 1)) ^ (cc != 3)
define signext range(i32 0, 43) i32 @bar_013_OR_XOR(i32 noundef signext %x){
; CHECK-LABEL: bar_013_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnher %r14
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2 = icmp ne i32 %asmresult1, 1
  %cmp3 = icmp ne i32 %asmresult1, 3
  %xor6 = xor i1 %cmp2, %cmp3
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) || (cc != 2)) ^ (cc != 3)
define signext range(i32 0, 43) i32 @bar_023_OR_XOR(i32 noundef signext %x){
; CHECK-LABEL: bar_023_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB2_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor6 = icmp samesign ugt i32 %asmresult1, 1
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 1) || (cc != 2)) ^ (cc != 3)
define signext range(i32 0, 43) i32 @bar_123_OR_XOR(i32 noundef signext %x){
; CHECK-LABEL: bar_123_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB3_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor6 = icmp samesign ugt i32 %asmresult1, 1
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) ^ (cc == 1)) || (cc != 2)
define signext range(i32 0, 43) i32 @foo_012_XOR_OR(i32 noundef signext %x){
; CHECK-LABEL: foo_012_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB4_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 0) ^ (cc == 1)) || (cc != 3)
define signext range(i32 0, 43) i32 @foo_013_XOR_OR(i32 noundef signext %x){
; CHECK-LABEL: foo_013_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB5_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 0) ^ (cc == 2)) || (cc != 3)
define signext range(i32 0, 43) i32 @foo_023_XOR_OR(i32 noundef signext %x){
; CHECK-LABEL: foo_023_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB6_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 1) ^ (cc == 2)) || (cc != 3)
define signext range(i32 0, 43) i32 @foo_123_XOR_OR(i32 noundef signext %x){
; CHECK-LABEL: foo_123_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB7_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) || (cc != 1)) && (cc != 2))
define signext range(i32 0, 43) i32 @bar_012_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB8_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %3 = icmp ult i32 %2, 2
  %cond = select i1 %3, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) || (cc != 1)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_013_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB9_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %.not = icmp eq i32 %2, 0
  %cond = select i1 %.not, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) || (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB10_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %.not, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 1) || (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB11_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %.not, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc != 1)) || (cc != 2))
define signext range(i32 0, 43) i32 @bar_012_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB12_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 2
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test (((cc == 0) && (cc != 1)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar_013_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB13_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test (((cc == 0) && (cc != 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB14_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test (((cc == 1) && (cc != 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB15_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test ((cc == 0) && ((cc != 1)) || (cc != 2))
define signext range(i32 0, 43) i32 @bar_012_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB16_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 2
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test ((cc == 0) && ((cc != 1)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar_013_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB17_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test ((cc == 0) && ((cc != 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB18_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test ((cc == 1) && ((cc != 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB19_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %2 = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %2
}

; Test ((cc == 1) && ((cc != 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar_012_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB20_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) ^ (cc != 1)) && (cc != 2))
define signext range(i32 0, 43) i32 @bar_013_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB21_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor8 = icmp samesign ugt i32 %asmresult1, 1
  %cmp4 = icmp ne i32 %asmresult1, 3
  %2 = and i1 %xor8, %cmp4
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) ^ (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB22_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %tobool = icmp ne i32 %2, 0
  %cmp4 = icmp ne i32 %asmresult1, 3
  %3 = and i1 %cmp4, %tobool
  %cond = select i1 %3, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 1) ^ (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB23_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp eq i32 %asmresult1, 0
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc != 1)) ^ (cc != 2))
define signext range(i32 0, 43) i32 @bar_012_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB24_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %tobool.not = icmp eq i32 %2, 0
  %cond = select i1 %tobool.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) && (cc != 1)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar_013_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB25_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp ne i32 %asmresult1, 0
  %cmp3 = icmp ne i32 %asmresult1, 3
  %xor6 = and i1 %cmp, %cmp3
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc != 2)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB26_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp ne i32 %asmresult1, 0
  %cmp3 = icmp ne i32 %asmresult1, 3
  %xor6 = and i1 %cmp, %cmp3
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 1) && (cc != 1)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB27_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %tobool.not.not = icmp eq i32 %2, 0
  %cond = select i1 %tobool.not.not, i32 42, i32 0
  ret i32 %cond
}

; ((cc == 0) && ((cc != 1)) ^ (cc != 2))
define noundef signext i32 @bar_012_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 0) && ((cc != 1)) ^ (cc != 3))
define noundef signext i32 @bar_013_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 0) && ((cc != 2)) ^ (cc != 3))
define noundef signext i32 @bar_023_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 1) && ((cc != 2)) ^ (cc != 3))
define noundef signext i32 @bar_123_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test (((cc == 0) || (cc == 1)) && (cc != 2))
define signext range(i32 0, 43) i32 @bar1_012_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB32_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %or.cond = icmp samesign ult i32 %asmresult1, 2
  %spec.select = select i1 %or.cond, i32 42, i32 0
  ret i32 %spec.select
}

; Test (((cc == 0) || (cc == 1)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar1_013_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB33_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %or.cond = icmp samesign ult i32 %asmresult1, 2
  %spec.select = select i1 %or.cond, i32 42, i32 0
  ret i32 %spec.select
}

; Test (((cc == 0) || (cc == 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar1_023_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lhi %r0, 0
; CHECK-NEXT:    jno .LBB34_3
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    jnhe .LBB34_4
; CHECK-NEXT:  .LBB34_2: # %entry
; CHECK-NEXT:    llgfr %r2, %r0
; CHECK-NEXT:    br %r14
; CHECK-NEXT:  .LBB34_3: # %entry
; CHECK-NEXT:    lhi %r0, 42
; CHECK-NEXT:    jhe .LBB34_2
; CHECK-NEXT:  .LBB34_4: # %entry
; CHECK-NEXT:    lhi %r0, 0
; CHECK-NEXT:    llgfr %r2, %r0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %or.cond = icmp eq i32 %2, 0
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %3 = select i1 %cmp3.not, i32 0, i32 42
  %cond = select i1 %or.cond, i32 %3, i32 0
  ret i32 %cond
}

; Test (((cc == 1) || (cc == 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar1_123_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB35_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %or.cond = icmp ult i32 %2, 2
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %3 = select i1 %cmp3.not, i32 0, i32 42
  %cond = select i1 %or.cond, i32 %3, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 1)) || (cc != 2))
define signext range(i32 0, 43) i32 @bar1_012_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB36_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 1)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar1_013_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_013_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB37_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar1_023_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB38_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 1) && (cc == 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar1_123_AND_OR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB39_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 0) && ((cc == 1)) || (cc != 2))
define signext range(i32 0, 43) i32 @bar1_012_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB40_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 0) && ((cc == 1)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar1_013_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB41_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 0) && ((cc == 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar1_023_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB42_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 1) && ((cc == 2)) || (cc != 3))
define signext range(i32 0, 43) i32 @bar1_123_AND_OR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB43_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 1)) ^ (cc != 2))
define signext range(i32 0, 43) i32 @bar1_012_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB44_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor8 = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 1)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar1_013_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB45_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor8 = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 2)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar1_023_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB46_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 0
  %cmp2 = icmp eq i32 %asmresult1, 2
  %xor8 = xor i1 %cmp, %cmp2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 1) && (cc == 2)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar1_123_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar1_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB47_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %xor8 = icmp ult i32 %2, 2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 1)) ^ (cc != 2)
define signext range(i32 0, 43) i32 @bar1_012_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB48_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 1)) ^ (cc != 3)
define signext range(i32 0, 43) i32 @bar1_013_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_013_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB49_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 2)) ^ (cc != 3)
define signext range(i32 0, 43) i32 @bar1_023_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB50_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc == 1) && (cc == 2)) ^ (cc != 3)
define signext range(i32 0, 43) i32 @bar1_123_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar1_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB51_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test  ((cc == 0) && ((cc == 1)) ^ (cc != 2))
define signext range(i32 0, 43) i32 @bar1_012_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB52_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 0
  %spec.select = select i1 %cmp, i32 42, i32 0
  ret i32 %spec.select
}

; Test  ((cc == 0) && ((cc == 1)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar1_013_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB53_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 0
  %spec.select = select i1 %cmp, i32 42, i32 0
  ret i32 %spec.select
}

; Test  ((cc == 0) && ((cc == 2)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar1_023_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB54_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 0
  %spec.select = select i1 %cmp, i32 42, i32 0
  ret i32 %spec.select
}

; Test  ((cc == 1) && ((cc == 2)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar1_123_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar1_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB55_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 1
  %spec.select = select i1 %cmp, i32 42, i32 0
  ret i32 %spec.select
}

@a = global i32 0, align 4
;  Test ((cc == 0) || (cc != 1)) && (cc != 2)
define range(i64 5, 9) i64 @fua_012_OR_AND() {
; CHECK-LABEL: fua_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB56_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -1
  %narrow = icmp ult i32 %2, 2
  %. = select i1 %narrow, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) && (cc != 1)) || (cc != 2)
define range(i64 5, 9) i64 @fua_012_AND_OR_a() {
; CHECK-LABEL: fua_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB57_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc != 1) || (cc != 2))
define range(i64 5, 9) i64 @fua_012_AND_OR_b() {
; CHECK-LABEL: fua_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB58_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) || (cc != 1)) && (cc != 3)
define range(i64 5, 9) i64 @fua_013_OR_AND() {
; CHECK-LABEL: fua_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB59_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) && (cc != 1)) || (cc != 3).
define range(i64 5, 9) i64 @fua_013_AND_OR_a() {
; CHECK-LABEL: fua_013_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB60_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc != 1) || (cc != 3))
define range(i64 5, 9) i64 @fua_013_AND_OR_b() {
; CHECK-LABEL: fua_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB61_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) || (cc != 2)) && (cc != 3)
define range(i64 5, 9) i64 @fua_023_OR_AND() {
; CHECK-LABEL: fua_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB62_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %narrow = icmp samesign ugt i32 %2, -3
  %. = select i1 %narrow, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) && (cc != 2)) || (cc != 3)
define range(i64 5, 9) i64 @fua_023_AND_OR_a() {
; CHECK-LABEL: fua_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB63_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc != 2) || (cc != 3)).
define range(i64 5, 9) i64 @fua_023_AND_OR_b() {
; CHECK-LABEL: fua_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB64_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 1) || (cc != 2)) && (cc != 3)
define range(i64 5, 9) i64 @fua_123_OR_AND() {
; CHECK-LABEL: fua_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB65_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %narrow = icmp samesign ugt i32 %2, -3
  %. = select i1 %narrow, i64 8, i64 5
  ret i64 %.
}

; Tset ((cc == 1) && (cc != 2)) || (cc != 3).
define range(i64 5, 9) i64 @fua_123_AND_OR_a() {
; CHECK-LABEL: fua_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB66_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 1) && ((cc != 2) || (cc != 3)).
define range(i64 5, 9) i64 @fua_123_AND_OR_b() {
; CHECK-LABEL: fua_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB67_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) ^ (cc != 1)) && (cc != 2)
define range(i64 5, 9) i64 @fua_012_XOR_AND() {
; CHECK-LABEL: fua_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB68_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %0, 3
  %. = select i1 %.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) && (cc != 1)) ^ (cc != 2)
define range(i64 5, 9) i64 @fua_012_AND_XOR_a() {
; CHECK-LABEL: fua_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB69_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc != 1)) && (cc != 3).
define noundef i64 @fua_012_AND_XOR_b() {
; CHECK-LABEL: fua_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) && (cc != 1)) ^ (cc != 3).
define range(i64 5, 9) i64 @fua_013_XOR_AND() {
; CHECK-LABEL: fua_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnhr %r14
; CHECK-NEXT:  .LBB71_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ult i32 %0, 2
  %cmp3.i = icmp eq i32 %0, 3
  %.not = or i1 %xor7.i, %cmp3.i
  %. = select i1 %.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc != 1) ^ (cc != 3))
define range(i64 5, 9) i64 @fua_013_XOR_AND_XOR_a() {
; CHECK-LABEL: fua_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB72_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp eq i32 %0, 0
  %cmp2.i = icmp eq i32 %0, 3
  %xor5.i.not = or i1 %cmp.i, %cmp2.i
  %. = select i1 %xor5.i.not, i64 8, i64 5
  ret i64 %.
}

; Test  (cc == 0) && ((cc != 1) ^ (cc != 3)).
define noundef i64 @fua_013_AND_XOR_b() {
; CHECK-LABEL: fua_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) && (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fua_023_XOR_AND() {
; CHECK-LABEL: fua_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB74_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp eq i32 %0, 0
  %cmp2.i = icmp eq i32 %0, 3
  %xor5.i.not = or i1 %cmp.i, %cmp2.i
  %. = select i1 %xor5.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) && (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fua_023_AND_XOR_a() {
; CHECK-LABEL: fua_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB75_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp eq i32 %0, 0
  %cmp2.i = icmp eq i32 %0, 3
  %xor5.i.not = or i1 %cmp.i, %cmp2.i
  %. = select i1 %xor5.i.not, i64 8, i64 5
  ret i64 %.
}

; Test  (cc == 0) && ((cc != 2) ^ (cc != 3)).
define noundef i64 @fua_023_AND_XOR_b() {
; CHECK-LABEL: fua_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 1) ^ (cc != 2)) && (cc != 3).
define range(i64 5, 9) i64 @fua_123_XOR_AND() {
; CHECK-LABEL: fua_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB77_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %0, 0
  %. = select i1 %.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 1) && (cc != 2)) ^ (cc != 3).
define range(i64 5, 9) i64 @fua_123_AND_XOR_a() {
; CHECK-LABEL: fua_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB78_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 1) && ((cc != 2) ^ (cc != 3))
define noundef i64 @fua_123_AND_XOR_b() {
; CHECK-LABEL: fua_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) || (cc != 1)) && (cc != 2)
define i64 @bar1a_012_OR_AND() {
; CHECK-LABEL: bar1a_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnlh dummy@PLT
; CHECK-NEXT:  .LBB80_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -1
  %narrow = icmp ult i32 %2, 2
  br i1 %narrow, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

declare void @dummy() local_unnamed_addr #1

; Test ((cc == 0) && (cc != 1)) || (cc != 2)
define i64 @bar1a_012_AND_OR_a() {
; CHECK-LABEL: bar1a_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB81_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc != 1) || (cc != 2))
define i64 @bar1a_012_AND_OR_b() {
; CHECK-LABEL: bar1a_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB82_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc != 1)) && (cc != 3)
define i64 @bar1a_013_OR_AND() {
; CHECK-LABEL: bar1a_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jghe dummy@PLT
; CHECK-NEXT:  .LBB83_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc != 1)) || (cc != 3).
define i64 @bar1a_013_XOR_AND_OR_a() {
; CHECK-LABEL: bar1a_013_XOR_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB84_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc != 1) || (cc != 3))
define i64 @bar1a_013_AND_OR_b() {
; CHECK-LABEL: bar1a_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB85_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc != 2)) && (cc != 3)
define i64 @bar1a_023_OR_AND() {
; CHECK-LABEL: bar1a_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB86_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %narrow = icmp samesign ugt i32 %2, -3
  br i1 %narrow, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc != 2)) || (cc != 3)
define i64 @bar1a_023_AND_OR_a() {
; CHECK-LABEL: bar1a_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB87_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc != 2) || (cc != 3)).
define i64 @bar1a_023_AND_OR_b() {
; CHECK-LABEL: bar1a_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB88_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) || (cc != 2)) && (cc != 3)
define i64 @bar1a_123_OR_AND() {
; CHECK-LABEL: bar1a_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB89_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %narrow = icmp samesign ugt i32 %2, -3
  br i1 %narrow, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Tset ((cc == 1) && (cc != 2)) || (cc != 3).
define i64 @bar1a_123_AND_OR_a() {
; CHECK-LABEL: bar1a_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB90_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) && ((cc != 2) || (cc != 3))
define i64 @bar1a_123_AND_OR_b() {
; CHECK-LABEL: bar1a_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgl dummy@PLT
; CHECK-NEXT:  .LBB91_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc != 1)) && (cc != 2)
define i64 @bar1a_012_XOR_AND() {
; CHECK-LABEL: bar1a_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB92_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %0, 3
  br i1 %.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc != 1)) ^ (cc != 2)
define i64 @bar1a_012_AND_XOR_a() {
; CHECK-LABEL: bar1a_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnhe dummy@PLT
; CHECK-NEXT:  .LBB93_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not = icmp eq i32 %2, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc != 1)) && (cc != 3).
define i64 @bar1a_012_AND_XOR_b() {
; CHECK-LABEL: bar1a_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

define i64 @bar1a_013_XOR_AND() {
; CHECK-LABEL: bar1a_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgh dummy@PLT
; CHECK-NEXT:  .LBB95_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %switch = icmp eq i32 %0, 2
  br i1 %switch, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret i64 undef
}

; Test (cc == 0) && ((cc != 1) ^ (cc != 3))
; TODO: DAGCombiner is not able to optimize srl/ipm/cc sequence because of
; switch table created by simplifyBranchOnICmpChain.
define i64 @bar1a_013_XOR_AND_XOR_a() {
; CHECK-LABEL: bar1a_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    ipm %r0
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB96_1: # %entry
; CHECK-NEXT:    srl %r0, 28
; CHECK-NEXT:    chi %r0, 3
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB96_2: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  switch i32 %0, label %if.then [
    i32 3, label %if.end
    i32 0, label %if.end
  ]

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %entry, %if.then
  ret i64 undef
}

; Test  (cc == 0) && ((cc != 1) ^ (cc != 3)).
define i64 @bar1a_013_AND_XOR_b() {
; CHECK-LABEL: bar1a_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) && (cc != 2)) ^ (cc != 3)
; TODO: DAGCombiner is not able to optimize srl/ipm/cc sequence because of
; switch table created by simplifyBranchOnICmpChain.
define i64 @bar1a_023_XOR_AND() {
; CHECK-LABEL: bar1a_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    ipm %r0
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB98_1: # %entry
; CHECK-NEXT:    srl %r0, 28
; CHECK-NEXT:    chi %r0, 3
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB98_2: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  switch i32 %0, label %if.then [
    i32 3, label %if.end
    i32 0, label %if.end
  ]

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %entry, %if.then
  ret i64 undef
}

; Test ((cc == 0) && (cc != 2)) ^ (cc != 3)
; TODO: DAGCombiner is not able to optimize srl/ipm/cc sequence because of
; switch table created by simplifyBranchOnICmpChain.
define i64 @bar1a_023_AND_XOR_a() {
; CHECK-LABEL: bar1a_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    ipm %r0
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB99_1: # %entry
; CHECK-NEXT:    srl %r0, 28
; CHECK-NEXT:    chi %r0, 3
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB99_2: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  switch i32 %0, label %if.then [
    i32 3, label %if.end
    i32 0, label %if.end
  ]

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %entry, %if.then
  ret i64 undef
}

; Test  (cc == 0) && ((cc != 2) ^ (cc != 3)).
define i64 @bar1a_023_AND_XOR_b() {
; CHECK-LABEL: bar1a_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 1) ^ (cc != 2)) && (cc != 3).
define i64 @bar1a_123_XOR_AND() {
; CHECK-LABEL: bar1a_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB101_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %0, 0
  br i1 %.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) && (cc != 2)) ^ (cc != 3)
define i64 @bar1a_123_AND_XOR_a() {
; CHECK-LABEL: bar1a_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jghe dummy@PLT
; CHECK-NEXT:  .LBB102_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) && ((cc != 2) ^ (cc != 3))
define i64 @bar1a_123_AND_XOR_b() {
; CHECK-LABEL: bar1a_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) || (cc == 1)) && (cc != 2)
define range(i64 5, 9) i64 @fuaa_012_OR_AND() {
; CHECK-LABEL: fuaa_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB104_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %or.cond.i = icmp samesign ugt i32 %0, 1
  %. = select i1 %or.cond.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) && (cc == 1)) || (cc != 2)
define range(i64 5, 9) i64 @fuaa_012_AND_OR_a() {
; CHECK-LABEL: fuaa_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB105_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc == 1) || (cc != 2)).
define range(i64 5, 9) i64 @fuaa_012_AND_OR_b() {
; CHECK-LABEL: fuaa_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB106_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) || (cc == 1)) && (cc != 3)
define range(i64 5, 9) i64 @fuaa_013_OR_AND() {
; CHECK-LABEL: fuaa_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB107_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %or.cond.i = icmp samesign ugt i32 %0, 1
  %. = select i1 %or.cond.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) && (cc == 1)) || (cc != 3)
define range(i64 5, 9) i64 @fuaa_013_AND_OR_a() {
; CHECK-LABEL: fuaa_013_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB108_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc == 1) || (cc != 3))
define range(i64 5, 9) i64 @fuaa_013_AND_OR_b() {
; CHECK-LABEL: fuaa_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB109_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) || (cc == 2)) && (cc != 3)
define range(i64 5, 9) i64 @fuaa_023_OR_AND() {
; CHECK-LABEL: fuaa_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB110_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) && (cc == 2)) || (cc != 3)
define range(i64 5, 9) i64 @fuaa_023_AND_OR_a() {
; CHECK-LABEL: fuaa_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB111_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc == 2) || (cc != 3))
define range(i64 5, 9) i64 @fuaa_023_AND_OR_b() {
; CHECK-LABEL: fuaa_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB112_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 1) || (cc == 2)) && (cc != 3)
define range(i64 5, 9) i64 @fuaa_123_OR_AND() {
; CHECK-LABEL: fuaa_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB113_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %or.cond.i = icmp ult i32 %2, -2
  %. = select i1 %or.cond.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 1) && (cc == 2)) || (cc != 3)
define range(i64 5, 9) i64 @fuaa_123_AND_OR_a() {
; CHECK-LABEL: fuaa_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB114_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 1) && ((cc == 2) || (cc != 3))
define range(i64 5, 9) i64 @fuaa_123_AND_OR_b() {
; CHECK-LABEL: fuaa_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB115_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test  ((cc == 0) ^ (cc == 1)) && (cc != 2).
define range(i64 5, 9) i64 @fuaa_012_XOR_AND() {
; CHECK-LABEL: fuaa_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB116_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  %. = select i1 %xor7.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) && (cc == 1)) ^ (cc != 2)
define range(i64 5, 9) i64 @fuaa_012_AND_XOR_a() {
; CHECK-LABEL: fuaa_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB117_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc == 1) ^ (cc != 2))
define range(i64 5, 9) i64 @fuaa_012_AND_XOR_b() {
; CHECK-LABEL: fuaa_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB118_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) ^ (cc == 1)) && (cc != 3)
define range(i64 5, 9) i64 @fuaa_013_XOR_AND() {
; CHECK-LABEL: fuaa_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB119_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  %. = select i1 %xor7.i, i64 8, i64 5
  ret i64 %.
}

; ((cc == 0) && (cc == 1)) ^ (cc != 3)
define range(i64 5, 9) i64 @fuaa_013_XOR_AND_XOR_a() {
; CHECK-LABEL: fuaa_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB120_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc == 1) ^ (cc != 3)
define range(i64 5, 9) i64 @fuaa_013_AND_XOR_b() {
; CHECK-LABEL: fuaa_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB121_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) && (cc == 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fuaa_023_XOR_AND() {
; CHECK-LABEL: fuaa_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB122_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) && (cc == 2)) ^ (cc != 3).
define range(i64 5, 9) i64 @fuaa_023_AND_XOR_a() {
; CHECK-LABEL: fuaa_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB123_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) && ((cc == 2) ^ (cc != 3)).
define range(i64 5, 9) i64 @fuaa_023_AND_XOR_b() {
; CHECK-LABEL: fuaa_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB124_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 1) ^ (cc == 2)) && (cc != 3)
define range(i64 5, 9) i64 @fuaa_123_XOR_AND() {
; CHECK-LABEL: fuaa_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB125_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %xor7.i = icmp ult i32 %2, -2
  %. = select i1 %xor7.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 1) && (cc == 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fuaa_123_AND_XOR_a() {
; CHECK-LABEL: fuaa_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB126_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 1) && ((cc == 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fuaa_123_AND_XOR_b() {
; CHECK-LABEL: fuaa_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB127_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) || (cc == 1)) && (cc != 2)
define i64 @bar2a_012_OR_AND() {
; CHECK-LABEL: bar2a_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB128_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %or.cond.i = icmp samesign ugt i32 %0, 1
  br i1 %or.cond.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 1)) || (cc != 2)
define i64 @bar2a_012_AND_OR_a() {
; CHECK-LABEL: bar2a_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB129_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 1) || (cc != 2)).
define i64 @bar2a_012_AND_OR_b() {
; CHECK-LABEL: bar2a_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB130_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc == 1)) && (cc != 3)
define i64 @bar2a_013_OR_AND() {
; CHECK-LABEL: bar2a_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB131_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %or.cond.i = icmp samesign ugt i32 %0, 1
  br i1 %or.cond.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 1)) || (cc != 3)
define i64 @bar2a_013_XOR_AND_OR_a() {
; CHECK-LABEL: bar2a_013_XOR_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB132_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 1) || (cc != 3))
define i64 @bar2a_013_AND_OR_b() {
; CHECK-LABEL: bar2a_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB133_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc == 2)) && (cc != 3)
define i64 @bar2a_023_OR_AND() {
; CHECK-LABEL: bar2a_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jghe dummy@PLT
; CHECK-NEXT:  .LBB134_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 2)) || (cc != 3)
define i64 @bar2a_023_AND_OR_a() {
; CHECK-LABEL: bar2a_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB135_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 2) || (cc != 3))
define i64 @bar2a_023_AND_OR_b() {
; CHECK-LABEL: bar2a_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB136_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) || (cc == 2)) && (cc != 3)
define i64 @bar2a_123_OR_AND() {
; CHECK-LABEL: bar2a_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB137_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %or.cond.i = icmp ult i32 %2, -2
  br i1 %or.cond.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) && (cc == 2)) || (cc != 3)
define i64 @bar2a_123_AND_OR_a() {
; CHECK-LABEL: bar2a_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB138_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) && ((cc == 2) || (cc != 3))
define i64 @bar2a_123_AND_OR_b() {
; CHECK-LABEL: bar2a_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgl dummy@PLT
; CHECK-NEXT:  .LBB139_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test  ((cc == 0) ^ (cc == 1)) && (cc != 2).
define i64 @bar2a_012_XOR_AND() {
; CHECK-LABEL: bar2a_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB140_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  br i1 %xor7.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 1)) ^ (cc != 2)
define i64 @bar2a_012_AND_XOR_a() {
; CHECK-LABEL: bar2a_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB141_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 1) ^ (cc != 2))
define i64 @bar2a_012_AND_XOR_b() {
; CHECK-LABEL: bar2a_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB142_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) && (cc != 3)
define i64 @bar2a_013_XOR_AND() {
; CHECK-LABEL: bar2a_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB143_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  br i1 %xor7.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 1)) ^ (cc != 3)
define i64 @bar2a_013_XOR_AND_XOR_a() {
; CHECK-LABEL: bar2a_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB144_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 1) ^ (cc != 3)
define i64 @bar2a_013_AND_XOR_b() {
; CHECK-LABEL: bar2a_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB145_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (((cc == 0) ^ (cc != 2)) && (cc != 3))
define i64 @bar2a_023_XOR_AND() {
; CHECK-LABEL: bar2a_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB146_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 2)) ^ (cc != 3)
define i64 @bar2a_023_AND_XOR_a() {
; CHECK-LABEL: bar2a_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB147_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 2) ^ (cc != 3)).
define i64 @bar2a_023_AND_XOR_b() {
; CHECK-LABEL: bar2a_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB148_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) ^ (cc == 2)) && (cc != 3)
define i64 @bar2a_123_XOR_AND() {
; CHECK-LABEL: bar2a_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB149_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %xor7.i = icmp ult i32 %2, -2
  br i1 %xor7.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) && (cc == 2)) ^ (cc != 3)
define i64 @bar2a_123_AND_XOR_a() {
; CHECK-LABEL: bar2a_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB150_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) && ((cc == 2) ^ (cc != 3))
define i64 @bar2a_123_AND_XOR_b() {
; CHECK-LABEL: bar2a_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgl dummy@PLT
; CHECK-NEXT:  .LBB151_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) || ((cc != 1) ^ (cc != 2))
define range(i64 5, 9) i64 @fu1a_012_OR_XOR_a() {
; CHECK-LABEL: fu1a_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB152_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 3
  %. = select i1 %xor6.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) || (cc != 1)) ^ (cc != 2)
define range(i64 5, 9) i64 @fu1a_012_OR_XOR_c() {
; CHECK-LABEL: fu1a_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB153_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %xor5.i = icmp ult i32 %2, -2
  %. = select i1 %xor5.i, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) ^ ((cc != 1) || (cc != 2))
define range(i64 5, 9) i64 @fu1a_012_XOR_OR_a() {
; CHECK-LABEL: fu1a_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB154_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc != 1)) || (cc != 2)
define noundef range(i64 5, 9) i64 @fu1a_012_XOR_OR_c() {
; CHECK-LABEL: fu1a_012_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test (cc == 0) || ((cc != 1) ^ (cc != 3))
define range(i64 5, 9) i64 @fu1a_013_OR_XOR_a() {
; CHECK-LABEL: fu1a_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB156_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp ne i32 %0, 0
  %2 = and i32 %0, 1
  %xor6.i.not = icmp eq i32 %2, 0
  %narrow.not = and i1 %cmp.i, %xor6.i.not
  %. = select i1 %narrow.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) || (cc != 1)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu1a_013_OR_XOR_c() {
; CHECK-LABEL: fu1a_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB157_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not.not, i64 8, i64 5
  ret i64 %.
}

; Test  (cc == 0) ^ ((cc != 1) || (cc != 3))
define range(i64 5, 9) i64 @fu1a_013_XOR_OR_a() {
; CHECK-LABEL: fu1a_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB158_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc != 1)) || (cc != 3)
define noundef range(i64 5, 9) i64 @fu1a_013_XOR_OR_c() {
; CHECK-LABEL: fu1a_013_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test (cc == 0) || ((cc != 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fu1a_023_OR_XOR_a() {
; CHECK-LABEL: fu1a_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB160_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 1
  %. = select i1 %xor6.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) || (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu1a_023_OR_XOR_c() {
; CHECK-LABEL: fu1a_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB161_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i = icmp samesign ult i32 %0, 2
  %. = select i1 %xor5.i, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) ^ ((cc != 2) || (cc != 3))
define range(i64 5, 9) i64 @fu1a_023_XOR_OR_a() {
; CHECK-LABEL: fu1a_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB162_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc != 2)) || (cc != 3)
define noundef range(i64 5, 9) i64 @fu1a_023_XOR_OR_c() {
; CHECK-LABEL: fu1a_023_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test (cc == 1) || ((cc != 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fu1a_123_OR_XOR_a() {
; CHECK-LABEL: fu1a_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB164_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 0
  %. = select i1 %xor6.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 1) || (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu1a_123_OR_XOR_c() {
; CHECK-LABEL: fu1a_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB165_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i = icmp samesign ult i32 %0, 2
  %. = select i1 %xor5.i, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 1 ) ^ ((cc != 2) || (cc != 3))
define range(i64 5, 9) i64 @fu1a_123_XOR_OR_a() {
; CHECK-LABEL: fu1a_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB166_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 1) ^ (cc != 2)) || (cc != 3)
define noundef range(i64 5, 9) i64 @fu1a_123_XOR_OR_c() {
; CHECK-LABEL: fu1a_123_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test (cc == 0) || ((cc != 1) ^ (cc != 2))
define i64 @bar3a_012_OR_XOR_a() {
; CHECK-LABEL: bar3a_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB168_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 3
  br i1 %xor6.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc != 1)) ^ (cc != 2)
define i64 @bar3a_012_OR_XOR_c() {
; CHECK-LABEL: bar3a_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB169_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %xor5.i = icmp ult i32 %2, -2
  br i1 %xor5.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) ^ ((cc != 1) || (cc != 2))
define i64 @bar3a_012_XOR_OR_a() {
; CHECK-LABEL: bar3a_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB170_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc != 1)) || (cc != 2)
define i64 @bar3a_012_XOR_OR_c() {
; CHECK-LABEL: bar3a_012_XOR_OR_c:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
if.end:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test (cc == 0) || ((cc != 1) ^ (cc != 3))
define i64 @bar3a_013_OR_XOR_a() {
; CHECK-LABEL: bar3a_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB172_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp ne i32 %0, 0
  %2 = and i32 %0, 1
  %xor6.i.not = icmp eq i32 %2, 0
  %narrow.not = and i1 %cmp.i, %xor6.i.not
  br i1 %narrow.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc != 1)) ^ (cc != 3)
define i64 @bar3a_013_OR_XOR_c() {
; CHECK-LABEL: bar3a_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnhe dummy@PLT
; CHECK-NEXT:  .LBB173_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test  (cc == 0) ^ ((cc != 1) || (cc != 3))
define i64 @bar3a_013_XOR_OR_a() {
; CHECK-LABEL: bar3a_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB174_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc != 1)) || (cc != 3)
define i64 @bar3a_013_XOR_OR_c() {
; CHECK-LABEL: bar3a_013_XOR_OR_c:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
if.end:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test (cc == 0) || ((cc != 2) ^ (cc != 3))
define i64 @bar3a_023_OR_XOR_a() {
; CHECK-LABEL: bar3a_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB176_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 1
  br i1 %xor6.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc != 2)) ^ (cc != 3)
define i64 @bar3a_023_OR_XOR_c() {
; CHECK-LABEL: bar3a_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnle dummy@PLT
; CHECK-NEXT:  .LBB177_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i = icmp samesign ult i32 %0, 2
  br i1 %xor5.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) ^ ((cc != 2) || (cc != 3))
define i64 @bar3a_023_XOR_OR_a() {
; CHECK-LABEL: bar3a_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB178_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc != 2)) || (cc != 3)
define i64 @bar3a_023_XOR_OR_c() {
; CHECK-LABEL: bar3a_023_XOR_OR_c:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
if.end:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test (cc == 1) || ((cc != 2) ^ (cc != 3))
define i64 @bar3a_123_OR_XOR_a() {
; CHECK-LABEL: bar3a_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB180_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 0
  br i1 %xor6.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) || (cc != 2)) ^ (cc != 3)
define i64 @bar3a_123_OR_XOR_c() {
; CHECK-LABEL: bar3a_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnle dummy@PLT
; CHECK-NEXT:  .LBB181_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i = icmp samesign ult i32 %0, 2
  br i1 %xor5.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1 ) ^ ((cc != 2) || (cc != 3))
define i64 @bar3a_123_XOR_OR_a() {
; CHECK-LABEL: bar3a_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB182_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  br i1 %cmp.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) ^ (cc != 2)) || (cc != 3
define i64 @bar3a_123_XOR_OR_c() {
; CHECK-LABEL: bar3a_123_XOR_OR_c:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
if.end:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test (cc == 0) || ((cc == 1) ^ (cc != 2))
define range(i64 5, 9) i64 @fu2a_012_OR_XOR_a() {
; CHECK-LABEL: fu2a_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB184_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -1
  %xor6.i = icmp ult i32 %2, 2
  %. = select i1 %xor6.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) || (cc == 1)) ^ (cc != 2)
define range(i64 5, 9) i64 @fu2a_012_OR_XOR_c() {
; CHECK-LABEL: fu2a_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB185_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 3
  %. = select i1 %xor5.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) ^ ((cc == 1) || (cc != 2))
define range(i64 5, 9) i64 @fu2a_012_XOR_OR_a() {
; CHECK-LABEL: fu2a_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB186_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc == 1)) || (cc != 2)
define range(i64 5, 9) i64 @fu2a_012_XOR_OR_c() {
; CHECK-LABEL: fu2a_012_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB187_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test  (cc == 0) || ((cc == 1) ^ (cc != 3))
define range(i64 5, 9) i64 @fu2a_013_OR_XOR_a() {
; CHECK-LABEL: fu2a_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB188_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) || (cc == 1)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu2a_013_OR_XOR_c() {
; CHECK-LABEL: fu2a_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnhr %r14
; CHECK-NEXT:  .LBB189_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ult i32 %0, 2
  %cmp2.i = icmp eq i32 %0, 3
  %xor5.i.not = or i1 %2, %cmp2.i
  %. = select i1 %xor5.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) ^ ((cc == 1) || (cc != 3))
define range(i64 5, 9) i64 @fu2a_013_XOR_OR_a() {
; CHECK-LABEL: fu2a_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB190_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp eq i32 %0, 0
  %cmp3.i = icmp eq i32 %0, 3
  %xor7.i.not = or i1 %cmp.i, %cmp3.i
  %. = select i1 %xor7.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc == 1)) || (cc != 3)
define range(i64 5, 9) i64 @fu2a_013_XOR_OR_c() {
; CHECK-LABEL: fu2a_013_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB191_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) || ((cc == 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fu2a_023_OR_XOR_a() {
; CHECK-LABEL: fu2a_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB192_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %xor6.i = icmp samesign ugt i32 %2, -3
  %. = select i1 %xor6.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) || (cc == 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu2a_023_OR_XOR_c() {
; CHECK-LABEL: fu2a_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB193_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp eq i32 %0, 3
  %tobool.not.not = xor i1 %3, %2
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) ^ ((cc == 2) || (cc != 3))
define range(i64 5, 9) i64 @fu2a_023_XOR_OR_a() {
; CHECK-LABEL: fu2a_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB194_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp eq i32 %0, 0
  %cmp3.i = icmp eq i32 %0, 3
  %xor7.i.not = or i1 %cmp.i, %cmp3.i
  %. = select i1 %xor7.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc == 2)) || (cc != 3)
define range(i64 5, 9) i64 @fu2a_023_XOR_OR_c() {
; CHECK-LABEL: fu2a_023_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB195_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 1) || ((cc == 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fu2a_123_OR_XOR_a() {
; CHECK-LABEL: fu2a_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB196_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %xor6.i = icmp samesign ugt i32 %2, -3
  %. = select i1 %xor6.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 1) || (cc == 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu2a_123_OR_XOR_c() {
; CHECK-LABEL: fu2a_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB197_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 0
  %. = select i1 %xor5.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 1 ) ^ ((cc == 2) || (cc != 3))
define range(i64 5, 9) i64 @fu2a_123_XOR_OR_a() {
; CHECK-LABEL: fu2a_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB198_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 1) ^ (cc == 2)) || (cc != 3)
define range(i64 5, 9) i64 @fu2a_123_XOR_OR_c() {
; CHECK-LABEL: fu2a_123_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB199_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) || ((cc == 1) ^ (cc != 2))
define i64 @bar4a_012_OR_XOR_a() {
; CHECK-LABEL: bar4a_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnlh dummy@PLT
; CHECK-NEXT:  .LBB200_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -1
  %xor6.i = icmp ult i32 %2, 2
  br i1 %xor6.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc == 1)) ^ (cc != 2)
define i64 @bar4a_012_OR_XOR_c() {
; CHECK-LABEL: bar4a_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB201_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 3
  br i1 %xor5.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) ^ ((cc == 1) || (cc != 2))
define i64 @bar4a_012_XOR_OR_a() {
; CHECK-LABEL: bar4a_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnhe dummy@PLT
; CHECK-NEXT:  .LBB202_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not = icmp eq i32 %2, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) || (cc != 2)
define i64 @bar4a_012_XOR_OR_c() {
; CHECK-LABEL: bar4a_012_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB203_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 2
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test  (cc == 0) || ((cc == 1) ^ (cc != 3)
define i64 @bar4a_013_OR_XOR_a() {
; CHECK-LABEL: bar4a_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jghe dummy@PLT
; CHECK-NEXT:  .LBB204_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc == 1)) ^ (cc != 3)
define i64 @bar4a_013_OR_XOR_c() {
; CHECK-LABEL: bar4a_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgh dummy@PLT
; CHECK-NEXT:  .LBB205_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %switch = icmp eq i32 %0, 2
  br i1 %switch, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret i64 undef
}

; Test (cc == 0) ^ ((cc == 1) || (cc != 3))
; TODO: DAGCombiner is not able to optimize srl/ipm/cc sequence because of
; switch table created by simplifyBranchOnICmpChain.
define i64 @bar4a_013_XOR_OR_a() {
; CHECK-LABEL: bar4a_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    ipm %r0
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB206_1: # %entry
; CHECK-NEXT:    srl %r0, 28
; CHECK-NEXT:    chi %r0, 3
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB206_2: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  switch i32 %0, label %if.then [
    i32 3, label %if.end
    i32 0, label %if.end
  ]

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %entry, %if.then
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) || (cc != 3)
define i64 @bar4a_013_XOR_OR_c() {
; CHECK-LABEL: bar4a_013_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB207_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) || ((cc == 2) ^ (cc != 3))
define i64 @bar4a_023_OR_XOR_a() {
; CHECK-LABEL: bar4a_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB208_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %xor6.i = icmp samesign ugt i32 %2, -3
  br i1 %xor6.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc == 2)) ^ (cc != 3)
define i64 @bar4a_023_OR_XOR_c() {
; CHECK-LABEL: bar4a_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgl dummy@PLT
; CHECK-NEXT:  .LBB209_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp eq i32 %0, 3
  %tobool.not.not = xor i1 %3, %2
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) ^ ((cc == 2) || (cc != 3))
; TODO: DAGCombiner is not able to optimize srl/ipm/cc sequence because of
; switch table created by simplifyBranchOnICmpChain.
define i64 @bar4a_023_XOR_OR_a() {
; CHECK-LABEL: bar4a_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    ipm %r0
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB210_1: # %entry
; CHECK-NEXT:    srl %r0, 28
; CHECK-NEXT:    chi %r0, 3
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB210_2: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  switch i32 %0, label %if.then [
    i32 3, label %if.end
    i32 0, label %if.end
  ]

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %entry, %if.then
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 2)) || (cc != 3)
define i64 @bar4a_023_XOR_OR_c() {
; CHECK-LABEL: bar4a_023_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB211_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) || ((cc == 2) ^ (cc != 3))
define i64 @bar4a_123_OR_XOR_a() {
; CHECK-LABEL: bar4a_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB212_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = or disjoint i32 %0, -4
  %xor6.i = icmp samesign ugt i32 %2, -3
  br i1 %xor6.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) || (cc == 2)) ^ (cc != 3)
define i64 @bar4a_123_OR_XOR_c() {
; CHECK-LABEL: bar4a_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB213_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 0
  br i1 %xor5.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1 ) ^ ((cc == 2) || (cc != 3))
define i64 @bar4a_123_XOR_OR_a() {
; CHECK-LABEL: bar4a_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jghe dummy@PLT
; CHECK-NEXT:  .LBB214_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) ^ (cc == 2)) || (cc != 3)
define i64 @bar4a_123_XOR_OR_c() {
; CHECK-LABEL: bar4a_123_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB215_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}
