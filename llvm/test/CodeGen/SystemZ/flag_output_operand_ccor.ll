; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; Test Flag Output Operands with 14 combinations of CCMASK and optimizations
; for OR for 3 three different functions, including two test cases from heiko.

; RUN: llc < %s -verify-machineinstrs -mtriple=s390x-linux-gnu -O2 | FileCheck %s

; Test CC == 0.
define signext range(i32 0, 43) i32 @foo_0(i32 noundef signext %x) {
; CHECK-LABEL: foo_0:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 0
  %cond = select i1 %cmp, i32 42, i32 0
  ret i32 %cond
}

;declare void @llvm.assume(i1 noundef)

; Test CC == 1.
define signext range(i32 0, 43) i32 @foo_1(i32 noundef signext %x) {
; CHECK-LABEL: foo_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 1
  %cond = select i1 %cmp, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 2.
define signext range(i32 0, 43) i32 @foo_2(i32 noundef signext %x) {
; CHECK-LABEL: foo_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB2_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 3.
define signext range(i32 0, 43) i32 @foo_3(i32 noundef signext %x) {
; CHECK-LABEL: foo_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB3_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 0 || CC == 1.
define signext range(i32 0, 43) i32 @foo_01(i32 noundef signext %x) {
; CHECK-LABEL: foo_01:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB4_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 0 || CC == 2.
define signext range(i32 0, 43) i32 @foo_02(i32 noundef signext %x) {
; CHECK-LABEL: foo_02:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB5_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %3 = icmp eq i32 %2, 0
  %cond = select i1 %3, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 0 || CC == 3.
define signext range(i32 0, 43) i32 @foo_03(i32 noundef signext %x) {
; CHECK-LABEL: foo_03:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB6_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 0
  %cmp2 = icmp eq i32 %asmresult1, 3
  %2 = or i1 %cmp, %cmp2
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 1 || CC == 2.
define signext range(i32 0, 43) i32 @foo_12(i32 noundef signext %x) {
; CHECK-LABEL: foo_12:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB7_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %3 = icmp ult i32 %2, 2
  %cond = select i1 %3, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 1 || CC == 3.
define signext range(i32 0, 43) i32 @foo_13(i32 noundef signext %x) {
; CHECK-LABEL: foo_13:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB8_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %.not = icmp eq i32 %2, 0
  %cond = select i1 %.not, i32 0, i32 42
  ret i32 %cond
}

; Test CC == 2 || CC == 3.
define signext range(i32 0, 43) i32 @foo_23(i32 noundef signext %x) {
; CHECK-LABEL: foo_23:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB9_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %.not, i32 0, i32 42
  ret i32 %cond
}

; Test CC == 0 || CC == 1 || CC == 2.
define signext range(i32 0, 43) i32 @foo_012(i32 noundef signext %x) {
; CHECK-LABEL: foo_012:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB10_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %.not, i32 0, i32 42
  ret i32 %cond
}

; Test CC == 0 || CC == 1 || CC == 3.
define signext range(i32 0, 43) i32 @foo_013(i32 noundef signext %x) {
; CHECK-LABEL: foo_013:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnhr %r14
; CHECK-NEXT:  .LBB11_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %or.cond = icmp samesign ult i32 %asmresult1, 2
  %cmp3 = icmp eq i32 %asmresult1, 3
  %2 = or i1 %or.cond, %cmp3
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 0 || CC == 2 || CC == 3.
define signext range(i32 0, 43) i32 @foo_023(i32 noundef signext %x) {
; CHECK-LABEL: foo_023:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnlr %r14
; CHECK-NEXT:  .LBB12_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %asmresult1, 1
  %or.cond = icmp eq i32 %2, 0
  %cmp3 = icmp eq i32 %asmresult1, 3
  %3 = or i1 %cmp3, %or.cond
  %cond = select i1 %3, i32 42, i32 0
  ret i32 %cond
}

; Test CC == 1 || CC == 2 || CC == 3.
define signext range(i32 0, 43) i32 @foo_123(i32 noundef signext %x) {
; CHECK-LABEL: foo_123:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bner %r14
; CHECK-NEXT:  .LBB13_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %3 = icmp ult i32 %2, 3
  %cond = select i1 %3, i32 42, i32 0
  ret i32 %cond
}


; Test Flag Output Operands with 14 combinations of CCMask and optimizations.
; These test cases are from heiko kernel and 14 variations of CCMask for OR.

@a = dso_local global i32 0, align 4

; Test CC == 0.
define range(i64 5, 9) i64 @fu_0() {
; CHECK-LABEL: fu_0:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB14_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test CC == 1.
define range(i64 5, 9) i64 @fu_1() {
; CHECK-LABEL: fu_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB15_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test CC == 2.
define range(i64 5, 9) i64 @fu_2() {
; CHECK-LABEL: fu_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB16_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test CC == 3.
define range(i64 5, 9) i64 @fu_3() {
; CHECK-LABEL: fu_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB17_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test CC == 0 || CC == 1.
define range(i64 5, 9) i64 @fu_01() {
; CHECK-LABEL: fu_01:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB18_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ugt i32 %0, 1
  %. = select i1 %2, i64 8, i64 5
  ret i64 %.
}

; Test CC == 0 || CC == 2.
define range(i64 5, 9) i64 @fu_02() {
; CHECK-LABEL: fu_02:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB19_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test CC == 0 || CC == 3.
define range(i64 5, 9) i64 @fu_03() {
; CHECK-LABEL: fu_03:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB20_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp ne i32 %0, 0
  %cmp1.i = icmp ne i32 %0, 3
  %.not = and i1 %cmp.i, %cmp1.i
  %. = select i1 %.not, i64 8, i64 5
  ret i64 %.
}

; Test CC == 1 || CC == 2.
define range(i64 5, 9) i64 @fu_12() {
; CHECK-LABEL: fu_12:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB21_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %3 = icmp ult i32 %2, -2
  %. = select i1 %3, i64 8, i64 5
  ret i64 %.
}

; Test CC == 1 || CC == 3.
define range(i64 5, 9) i64 @fu_13() {
; CHECK-LABEL: fu_13:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB22_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test CC == 2 || CC == 3.
define range(i64 5, 9) i64 @fu_23() {
; CHECK-LABEL: fu_23:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB23_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ult i32 %0, 2
  %. = select i1 %2, i64 8, i64 5
  ret i64 %.
}

; Test CC == 0 || CC == 1 || CC == 2.
define range(i64 5, 9) i64 @fu_012() {
; CHECK-LABEL: fu_012:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB24_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %narrow.not = icmp eq i32 %0, 3
  %. = select i1 %narrow.not, i64 8, i64 5
  ret i64 %.
}

; Test CC == 0 || CC == 1 || CC == 3.
define range(i64 5, 9) i64 @fu_013() {
; CHECK-LABEL: fu_013:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB25_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i = icmp ne i32 %0, 3
  %or.cond.i.inv = icmp samesign ugt i32 %0, 1
  %narrow.not = and i1 %or.cond.i.inv, %cmp2.i
  %. = select i1 %narrow.not, i64 8, i64 5
  ret i64 %.
}

; Test CC == 0 || CC == 2 || CC == 3.
define range(i64 5, 9) i64 @fu_023() {
; CHECK-LABEL: fu_023:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB26_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %or.cond.i = icmp ne i32 %2, 0
  %cmp2.i = icmp ne i32 %0, 3
  %narrow.not = and i1 %cmp2.i, %or.cond.i
  %. = select i1 %narrow.not, i64 8, i64 5
  ret i64 %.
}

; Test Flag Output Operands with 14 combinations of CCMask and optimizations.
; These test cases are from heiko kernel and 14 variations of CCMask for OR.

; Test CC == 0.
define void @bar_0() {
; CHECK-LABEL: bar_0:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB27_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @dummy()

; Test CC == 1.
define void @bar_1() {
; CHECK-LABEL: bar_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgl dummy@PLT
; CHECK-NEXT:  .LBB28_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 2.
define void @bar_2() {
; CHECK-LABEL: bar_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgh dummy@PLT
; CHECK-NEXT:  .LBB29_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 2
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 3.
define void @bar_3() {
; CHECK-LABEL: bar_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB30_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 3
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 0 || CC == 1.
define void @bar_01() {
; CHECK-LABEL: bar_01:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB31_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ugt i32 %0, 1
  br i1 %2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 0 || CC == 2.
define void @bar_02() {
; CHECK-LABEL: bar_02:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jghe dummy@PLT
; CHECK-NEXT:  .LBB32_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 0 || CC == 3.
define void @bar_03() {
; CHECK-LABEL: bar_03:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnlh dummy@PLT
; CHECK-NEXT:  .LBB33_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  switch i32 %0, label %if.end [
    i32 3, label %if.then
    i32 0, label %if.then
  ]

if.then:                                          ; preds = %entry, %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Test CC == 1 || CC == 2.
define void @bar_12() {
; CHECK-LABEL: bar_12:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB34_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %3 = icmp ult i32 %2, -2
  br i1 %3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 1 || CC == 3.
define void @bar_13() {
; CHECK-LABEL: bar_13:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnhe dummy@PLT
; CHECK-NEXT:  .LBB35_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not = icmp eq i32 %2, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 2 || CC == 3.
define void @bar_23() {
; CHECK-LABEL: bar_23:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnle dummy@PLT
; CHECK-NEXT:  .LBB36_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ult i32 %0, 2
  br i1 %2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 0 || CC == 1 || CC == 2.
define void @bar_012() {
; CHECK-LABEL: bar_012:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB37_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %narrow.not = icmp eq i32 %0, 3
  br i1 %narrow.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 0 || CC == 1 || CC == 3.
define void @bar_013() {
; CHECK-LABEL: bar_013:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB38_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %switch = icmp eq i32 %0, 2
  br i1 %switch, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

; Test CC == 0 || CC == 2 || CC == 3.
define void @bar_023() {
; CHECK-LABEL: bar_023:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB39_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %or.cond.i = icmp ne i32 %2, 0
  %cmp2.i = icmp ne i32 %0, 3
  %narrow.not = and i1 %cmp2.i, %or.cond.i
  br i1 %narrow.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Test CC == 1 || CC == 2 || CC == 3.
define void @bar_123() {
; CHECK-LABEL: bar_123:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB40_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %narrow = icmp eq i32 %0, 0
  br i1 %narrow, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

