; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; Test Flag Output Operands with 14 combinations of CCMASK and optimizations.
; This tests mixing XOR wirh OR, XOR with AND and OR with AND  with
; different ways of parenthesizing with == operator.

; RUN: llc < %s -verify-machineinstrs -mtriple=s390x-linux-gnu -O3 | FileCheck %s

declare void @llvm.assume(i1 noundef)

@a = dso_local global i32 0, align 4

; Test ((cc == 0) || (cc == 1)) ^ (cc == 2)
define signext range(i32 0, 43) i32 @bar_012_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %xor6.not, i32 0, i32 42
  ret i32 %cond
}


; Test ((cc == 0) || (cc == 1)) ^ (cc == 3)
define signext range(i32 0, 43) i32 @bar_013_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnhr %r14
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ult i32 %asmresult1, 2
  %cmp3 = icmp eq i32 %asmresult1, 3
  %xor6 = xor i1 %2, %cmp3
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) || (cc == 2)) ^ (cc == 3)
define signext range(i32 0, 43) i32 @bar_023_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnlr %r14
; CHECK-NEXT:  .LBB2_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %asmresult1 to i1
  %3 = icmp ne i32 %asmresult1, 3
  %tobool.not.not = xor i1 %3, %2
  %cond = select i1 %tobool.not.not, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 1) || (cc == 2)) ^ (cc == 3)
define signext range(i32 0, 43) i32 @bar_123_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bner %r14
; CHECK-NEXT:  .LBB3_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %3 = icmp ult i32 %2, 2
  %cmp3 = icmp eq i32 %asmresult1, 3
  %xor6 = xor i1 %cmp3, %3
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) ^ (cc == 1)) || (cc == 2)
define signext range(i32 0, 43) i32 @foo_012_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_012_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB4_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc == 0) ^ (cc == 1)) || (cc == 3)
define signext range(i32 0, 43) i32 @foo_013_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_013_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnhr %r14
; CHECK-NEXT:  .LBB5_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor8 = icmp samesign ult i32 %asmresult1, 2
  %cmp4 = icmp eq i32 %asmresult1, 3
  %2 = or i1 %xor8, %cmp4
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) ^ (cc == 2)) || (cc == 3)
define signext range(i32 0, 43) i32 @foo_023_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_023_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnlr %r14
; CHECK-NEXT:  .LBB6_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp eq i32 %asmresult1, 0
  %cmp2 = icmp eq i32 %asmresult1, 2
  %xor8 = xor i1 %cmp, %cmp2
  %cmp4 = icmp eq i32 %asmresult1, 3
  %2 = or i1 %cmp4, %xor8
  %cond = select i1 %2, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 1) ^ (cc == 2)) || (cc == 3)
define signext range(i32 0, 43) i32 @foo_123_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_123_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bner %r14
; CHECK-NEXT:  .LBB7_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %3 = icmp ult i32 %2, 3
  %cond = select i1 %3, i32 42, i32 0
  ret i32 %cond
}

; Test (cc == 0) || ((cc == 1) ^ (cc == 2))
define range(i64 5, 9) i64 @fu_012_OR_XOR_a() {
; CHECK-LABEL: fu_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB8_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 3
  %. = select i1 %xor6.i.not, i64 8, i64 5
  ret i64 %.
}

; Test  ((cc == 0) || (cc == 1)) ^ (cc == 2)
define range(i64 5, 9) i64 @fu_012_OR_XOR_c() {
; CHECK-LABEL: fu_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB9_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 3
  %. = select i1 %xor5.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) ^ ((cc == 1) || (cc == 2))
define range(i64 5, 9) i64 @fu_012_XOR_OR_a() {
; CHECK-LABEL: fu_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB10_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %tobool.not = icmp eq i32 %0, 3
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc == 1)) || (cc == 2)
define range(i64 5, 9) i64 @fu_012_XOR_OR_c() {
; CHECK-LABEL: fu_012_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB11_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %0, 3
  %. = select i1 %.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) || ((cc == 1) ^ (cc == 3))
define range(i64 5, 9) i64 @fu_013_OR_XOR_a() {
; CHECK-LABEL: fu_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB12_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp ne i32 %0, 0
  %2 = and i32 %0, 1
  %xor6.i.not = icmp eq i32 %2, 0
  %narrow.not = and i1 %cmp.i, %xor6.i.not
  %. = select i1 %narrow.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) || (cc == 1)) ^ (cc == 3)
define range(i64 5, 9) i64 @fu_013_OR_XOR_c() {
; CHECK-LABEL: fu_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB13_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ugt i32 %0, 1
  %3 = icmp ne i32 %0, 3
  %tobool.not = and i1 %2, %3
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) ^ ((cc == 1) || (cc == 3))
define range(i64 5, 9) i64 @fu_013_XOR_OR_a() {
; CHECK-LABEL: fu_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB14_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp ne i32 %0, 0
  %tobool.not = xor i1 %3, %2
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) ^ (cc == 1)) || (cc == 3)
define range(i64 5, 9) i64 @fu_013_XOR_OR_c() {
; CHECK-LABEL: fu_013_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB15_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  %cmp3.i = icmp ne i32 %0, 3
  %.not = and i1 %xor7.i, %cmp3.i
  %. = select i1 %.not, i64 8, i64 5
  ret i64 %.
}

; Test  (cc == 0) || ((cc == 2) ^ (cc == 3))
define range(i64 5, 9) i64 @fu_023_OR_XOR_a() {
; CHECK-LABEL: fu_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB16_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 1
  %. = select i1 %xor6.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 0) || (cc == 2)) ^ (cc == 3)
define range(i64 5, 9) i64 @fu_023_OR_XOR_c() {
; CHECK-LABEL: fu_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bnlr %r14
; CHECK-NEXT:  .LBB17_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp ne i32 %0, 3
  %tobool.not.not = xor i1 %3, %2
  %. = select i1 %tobool.not.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) ^ ((cc == 2) || (cc == 3)).
define range(i64 5, 9) i64 @fu_023_XOR_OR_a() {
; CHECK-LABEL: fu_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB18_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i.not = icmp eq i32 %0, 1
  %. = select i1 %xor7.i.not, i64 8, i64 5
  ret i64 %.
}

; ((cc == 0) ^ (cc == 2)) || (cc == 3)
define range(i64 5, 9) i64 @fu_023_XOR_OR_c() {
; CHECK-LABEL: fu_023_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB19_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %xor7.i.not = icmp ne i32 %2, 0
  %cmp3.i = icmp ne i32 %0, 3
  %.not = and i1 %cmp3.i, %xor7.i.not
  %. = select i1 %.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 1) || ((cc == 2) ^ (cc == 3))
define range(i64 5, 9) i64 @fu_123_OR_XOR_a() {
; CHECK-LABEL: fu_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB20_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 0
  %. = select i1 %xor6.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 1) || (cc == 2)) ^ (cc == 3)
define range(i64 5, 9) i64 @fu_123_OR_XOR_c() {
; CHECK-LABEL: fu_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB21_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %tobool.not = icmp eq i32 %0, 0
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 1 ) ^ ((cc == 2) || (cc == 3)).
define range(i64 5, 9) i64 @fu_123_XOR_OR_a() {
; CHECK-LABEL: fu_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB22_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i.not = icmp eq i32 %0, 0
  %. = select i1 %xor7.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc == 1) ^ (cc == 2)) || (cc == 3)
define range(i64 5, 9) i64 @fu_123_XOR_OR_c() {
; CHECK-LABEL: fu_123_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB23_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp eq i32 %0, 0
  %. = select i1 %2, i64 8, i64 5
  ret i64 %.
}

; Test (cc == 0) || ((cc == 1) ^ (cc == 2))
define i64 @bar_012_OR_XOR_a() {
; CHECK-LABEL: bar_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB24_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 3
  br i1 %xor6.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test  ((cc == 0) || (cc == 1)) ^ (cc == 2)
define i64 @bar_012_OR_XOR_c() {
; CHECK-LABEL: bar_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB25_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 3
  br i1 %xor5.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) ^ ((cc == 1) || (cc == 2))
define i64 @bar_012_XOR_OR_a() {
; CHECK-LABEL: bar_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB26_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %tobool.not = icmp eq i32 %0, 3
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) || (cc == 2)
define i64 @bar_012_XOR_OR_c() {
; CHECK-LABEL: bar_012_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB27_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %.not = icmp eq i32 %0, 3
  br i1 %.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) || ((cc == 1) ^ (cc == 3))
define i64 @bar_013_OR_XOR_a() {
; CHECK-LABEL: bar_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB28_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i = icmp ne i32 %0, 0
  %2 = and i32 %0, 1
  %xor6.i.not = icmp eq i32 %2, 0
  %narrow.not = and i1 %cmp.i, %xor6.i.not
  br i1 %narrow.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc == 1)) ^ (cc == 3)
define i64 @bar_013_OR_XOR_c() {
; CHECK-LABEL: bar_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB29_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %switch = icmp eq i32 %0, 2
  br i1 %switch, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret i64 undef
}

; Test (cc == 0) ^ ((cc == 1) || (cc == 3))
define i64 @bar_013_XOR_OR_a() {
; CHECK-LABEL: bar_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB30_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp ne i32 %0, 0
  %tobool.not = xor i1 %3, %2
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) || (cc == 3)
define i64 @bar_013_XOR_OR_c() {
; CHECK-LABEL: bar_013_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB31_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %switch = icmp eq i32 %0, 2
  br i1 %switch, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret i64 undef
}

; Test  (cc == 0) || ((cc == 2) ^ (cc == 3))
define i64 @bar_023_OR_XOR_a() {
; CHECK-LABEL: bar_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB32_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 1
  br i1 %xor6.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc == 2)) ^ (cc == 3)
define i64 @bar_023_OR_XOR_c() {
; CHECK-LABEL: bar_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB33_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp ne i32 %0, 3
  %tobool.not.not = xor i1 %3, %2
  br i1 %tobool.not.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) ^ ((cc == 2) || (cc == 3))
define i64 @bar_023_XOR_OR_a() {
; CHECK-LABEL: bar_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB34_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i.not = icmp eq i32 %0, 1
  br i1 %xor7.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 2)) || (cc == 3)
define i64 @bar_023_XOR_OR_c() {
; CHECK-LABEL: bar_023_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB35_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %xor7.i.not = icmp ne i32 %2, 0
  %cmp3.i = icmp ne i32 %0, 3
  %.not = and i1 %cmp3.i, %xor7.i.not
  br i1 %.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) || ((cc == 2) ^ (cc == 3))
define i64 @bar_123_OR_XOR_a() {
; CHECK-LABEL: bar_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB36_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.i.not = icmp eq i32 %0, 0
  br i1 %xor6.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) || (cc == 2)) ^ (cc == 3)
define i64 @bar_123_OR_XOR_c() {
; CHECK-LABEL: bar_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB37_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1 ) ^ ((cc == 2) || (cc == 3))
define i64 @bar_123_XOR_OR_a() {
; CHECK-LABEL: bar_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB38_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i.not = icmp eq i32 %0, 0
  br i1 %xor7.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) ^ (cc == 2)) || (cc == 3)
define i64 @bar_123_XOR_OR_c() {
; CHECK-LABEL: bar_123_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB39_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp eq i32 %0, 0
  br i1 %2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test OR_AND and AND_OR
; Test (((cc == 0) || (cc == 1)) && (cc == 3))
define  noundef signext range(i32 0, 43) i32 @bar_013_OR_AND(i32 noundef signext %x)  {
; CHECK-LABEL: bar_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test (((cc == 0) || (cc == 2)) && (cc == 3))
define  noundef signext range(i32 0, 43) i32 @bar_023_OR_AND(i32 noundef signext %x)  {
; CHECK-LABEL: bar_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test (((cc == 1) || (cc == 2)) && (cc == 3))
define  noundef signext range(i32 0, 43) i32 @bar_123_OR_AND(i32 noundef signext %x)  {
; CHECK-LABEL: bar_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test (((cc == 0) && (cc == 1)) || (cc == 2))
define  signext range(i32 0, 43) i32 @bar_012_AND_OR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB43_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 1)) || (cc == 3))
define  signext range(i32 0, 43) i32 @bar_013_AND_OR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_013_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB44_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) && (cc == 2)) || (cc == 3))
define  signext range(i32 0, 43) i32 @bar_023_AND_OR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB45_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 1) && (cc == 2)) || (cc == 3))
define  signext range(i32 0, 43) i32 @bar_123_AND_OR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB46_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) && ((cc == 1)) || (cc == 2))
define  signext range(i32 0, 43) i32 @bar_012_AND_OR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB47_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) && ((cc == 1)) || (cc == 3))
define  signext range(i32 0, 43) i32 @bar_013_AND_OR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB48_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) && ((cc == 2)) || (cc == 3))
define  signext range(i32 0, 43) i32 @bar_023_AND_OR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB49_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 1) && ((cc == 2)) || (cc == 3))
define  signext range(i32 0, 43) i32 @bar_123_AND_OR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB50_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc == 0) ^ (cc == 1)) && (cc == 2))
define  noundef signext range(i32 0, 43) i32 @bar_012_XOR_AND(i32 noundef signext %x)  {
; CHECK-LABEL: bar_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test (((cc == 0) ^ (cc == 1)) && (cc == 3))
define  noundef signext range(i32 0, 43) i32 @bar_013_XOR_AND(i32 noundef signext %x)  {
; CHECK-LABEL: bar_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test (((cc == 0) ^ (cc == 2)) && (cc == 3))
define  noundef signext range(i32 0, 43) i32 @bar_023_XOR_AND(i32 noundef signext %x)  {
; CHECK-LABEL: bar_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test (((cc == 1) ^ (cc == 2)) && (cc == 3))
define  noundef signext range(i32 0, 43) i32 @bar_123_XOR_AND(i32 noundef signext %x)  {
; CHECK-LABEL: bar_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 0) && (cc == 1)) ^ (cc == 2))
define  signext range(i32 0, 43) i32 @bar_012_AND_XOR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB55_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) && (cc == 1)) ^ (cc == 3))
define  signext range(i32 0, 43) i32 @bar_013_AND_XOR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_013_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB56_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) && (cc == 2)) ^ (cc == 3))
define  signext range(i32 0, 43) i32 @bar_023_AND_XOR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB57_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 1) && (cc == 2)) ^ (cc == 3))
define  signext range(i32 0, 43) i32 @bar_123_AND_XOR_a(i32 noundef signext %x)  {
; CHECK-LABEL: bar_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB58_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc == 0) && ((cc == 1)) ^ (cc == 2))
define  noundef signext i32 @bar_012_AND_XOR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 0) && ((cc == 1)) ^ (cc == 3))
define  noundef signext i32 @bar_013_AND_XOR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 0) && ((cc == 2)) ^ (cc == 3))
define  noundef signext i32 @bar_023_AND_XOR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 1) && ((cc == 2)) ^ (cc == 3))
define  noundef signext i32 @bar_123_AND_XOR_b(i32 noundef signext %x)  {
; CHECK-LABEL: bar_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  ret i32 0
}

; Test ((cc == 0) || (cc == 1)) && (cc == 2)
define noundef range(i64 5, 9) i64 @fu_012_OR_AND() {
; CHECK-LABEL: fu_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) && (cc == 1)) || (cc == 2)
define range(i64 5, 9) i64 @fu_012_AND_OR_a() {
; CHECK-LABEL: fu_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB64_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) && ((cc == 1) || (cc == 2)
define noundef i64 @fu_012_AND_OR_b() {
; CHECK-LABEL: fu_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) || (cc == 1)) && (cc == 3)
define noundef range(i64 5, 9) i64 @fu_013_OR_AND() {
; CHECK-LABEL: fu_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) && (cc == 1)) || (cc == 3)
define range(i64 5, 9) i64 @fu_013_XOR_AND_OR_a() {
; CHECK-LABEL: fu_013_XOR_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB67_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) && ((cc == 1) || (cc == 3))
define noundef i64 @fu_013_AND_OR_b() {
; CHECK-LABEL: fu_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) || (cc == 2)) && (cc == 3)
define noundef range(i64 5, 9) i64 @fu_023_OR_AND() {
; CHECK-LABEL: fu_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) && (cc == 2)) || (cc == 3)
define range(i64 5, 9) i64 @fu_023_AND_OR_a() {
; CHECK-LABEL: fu_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB70_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) && ((cc == 2) || (cc == 3)
define noundef i64 @fu_023_AND_OR_b() {
; CHECK-LABEL: fu_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 1) || (cc == 2)) && (cc == 3)
define noundef range(i64 5, 9) i64 @fu_123_OR_AND() {
; CHECK-LABEL: fu_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 1) && (cc == 2)) || (cc == 3)
define range(i64 5, 9) i64 @fu_123_AND_OR_a() {
; CHECK-LABEL: fu_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB73_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 1) && ((cc == 2) || (cc == 3))
define noundef i64 @fu_123_AND_OR_b() {
; CHECK-LABEL: fu_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) ^ (cc == 1)) && (cc == 2)
define noundef range(i64 5, 9) i64 @fu_012_XOR_AND() {
; CHECK-LABEL: fu_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) && (cc == 1)) ^ (cc == 2)
define range(i64 5, 9) i64 @fu_012_AND_XOR_a() {
; CHECK-LABEL: fu_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB76_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) && ((cc == 1) ^ (cc == 2))
define noundef i64 @fu_012_AND_XOR_b() {
; CHECK-LABEL: fu_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) ^ (cc == 1)) && (cc == 3)
define noundef range(i64 5, 9) i64 @fu_013_XOR_AND() {
; CHECK-LABEL: fu_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) ^ (cc == 1)) && (cc == 3)
define range(i64 5, 9) i64 @fu_013_XOR_AND_XOR_a() {
; CHECK-LABEL: fu_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB79_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc == 0) && (cc == 1)) ^ (cc == 3)
define noundef i64 @fu_013_AND_XOR_b() {
; CHECK-LABEL: fu_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) || (cc == 2)) ^ (cc == 3)
define range(i64 5, 9) i64 @fu_023_XOR_AND() {
; CHECK-LABEL: fu_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) && (cc == 2)) ^ (cc == 3)
define range(i64 5, 9) i64 @fu_023_AND_XOR_a() {
; CHECK-LABEL: fu_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB82_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc == 0) && ((cc == 2) ^ (cc == 3))
define noundef i64 @fu_023_AND_XOR_b() {
; CHECK-LABEL: fu_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 1) ^ (cc == 2)) && (cc == 3)
define noundef range(i64 5, 9) i64 @fu_123_XOR_AND() {
; CHECK-LABEL: fu_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 1) && (cc == 2)) ^ (cc == 3)
define range(i64 5, 9) i64 @fu_123_AND_XOR_a() {
; CHECK-LABEL: fu_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB85_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test  (cc == 1) && ((cc == 2) ^ (cc == 3))
define noundef i64 @fu_123_AND_XOR_b() {
; CHECK-LABEL: fu_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 8
}

; Test ((cc == 0) || (cc == 1)) && (cc == 2
define i64 @bar1_012_OR_AND() {
; CHECK-LABEL: bar1_012_OR_AND:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
if.end:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

declare void @dummy() local_unnamed_addr #1

; Test ((cc == 0) && (cc == 1)) || (cc == 2)
define i64 @bar1_012_AND_OR_a() {
; CHECK-LABEL: bar1_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgh dummy@PLT
; CHECK-NEXT:  .LBB88_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 1) || (cc == 2)
define i64 @bar1_012_AND_OR_b() {
; CHECK-LABEL: bar1_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) || (cc == 1)) && (cc == 3)
define i64 @bar1_013_OR_AND() {
; CHECK-LABEL: bar1_013_OR_AND:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
if.end:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) && (cc == 1)) || (cc == 3)
define i64 @bar1_013_XOR_AND_OR_a() {
; CHECK-LABEL: bar1_013_XOR_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB91_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 1) || (cc == 3))
define i64 @bar1_013_AND_OR_b() {
; CHECK-LABEL: bar1_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) || (cc == 2)) && (cc == 3)
define i64 @bar1_023_OR_AND() {
; CHECK-LABEL: bar1_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) && (cc == 2)) || (cc == 3)
define i64 @bar1_023_AND_OR_a() {
; CHECK-LABEL: bar1_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB94_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 2) || (cc == 3)
define i64 @bar1_023_AND_OR_b() {
; CHECK-LABEL: bar1_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 1) || (cc == 2)) && (cc == 3)
define i64 @bar1_123_OR_AND() {
; CHECK-LABEL: bar1_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 1) && (cc == 2)) || (cc == 3)
define i64 @bar1_123_AND_OR_a() {
; CHECK-LABEL: bar1_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB97_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) && ((cc == 2) || (cc == 3))
define i64 @bar1_123_AND_OR_b() {
; CHECK-LABEL: bar1_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) && (cc == 2)
define i64 @bar1_012_XOR_AND() {
; CHECK-LABEL: bar1_012_XOR_AND:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
if.end:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) && (cc == 1)) ^ (cc == 2)
define i64 @bar1_012_AND_XOR_a() {
; CHECK-LABEL: bar1_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgh dummy@PLT
; CHECK-NEXT:  .LBB100_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc == 1) ^ (cc == 2))
define i64 @bar1_012_AND_XOR_b() {
; CHECK-LABEL: bar1_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) && (cc == 3)
define i64 @bar1_013_XOR_AND() {
; CHECK-LABEL: bar1_013_XOR_AND:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
if.end:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) ^ (cc == 1)) && (cc == 3)
define i64 @bar1_013_XOR_AND_XOR_a() {
; CHECK-LABEL: bar1_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB103_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 1)) ^ (cc == 3)
define i64 @bar1_013_AND_XOR_b() {
; CHECK-LABEL: bar1_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) || (cc == 2)) ^ (cc == 3)
define i64 @bar1_023_XOR_AND() {
; CHECK-LABEL: bar1_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #2
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 0) && (cc == 2)) ^ (cc == 3)
define i64 @bar1_023_AND_XOR_a() {
; CHECK-LABEL: bar1_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB106_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc == 2)) ^ (cc == 3)
define i64 @bar1_023_AND_XOR_b() {
; CHECK-LABEL: bar1_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 1) ^ (cc == 2)) && (cc == 3)
define i64 @bar1_123_XOR_AND() {
; CHECK-LABEL: bar1_123_XOR_AND:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
if.end:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

; Test ((cc == 1) && (cc == 2)) ^ (cc == 3)
define i64 @bar1_123_AND_XOR_a() {
; CHECK-LABEL: bar1_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB109_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test  (cc == 1) && ((cc == 2) ^ (cc == 3))
define i64 @bar1_123_AND_XOR_b() {
; CHECK-LABEL: bar1_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    larl %r1, a
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 undef
}

