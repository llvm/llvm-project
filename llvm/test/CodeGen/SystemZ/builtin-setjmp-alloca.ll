; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; Test setjmp  store to jmp_buf when frame pointer is used and saved
; because of variable size alloca.
; Frame Pointer is stored in slot 1.
; Return address in slot 2.
; Backchain value is stored in slot 3 for -mbackchain option.
; Stack Pointer in slot 4.
; Clobber %r6-%r15, %f8-%f15.

; RUN: llc < %s -verify-machineinstrs -mtriple=s390x-linux-gnu | FileCheck %s

declare i32 @llvm.eh.sjlj.setjmp(ptr)
@buf = global [20 x ptr] zeroinitializer, align 8

define signext i32 @foo() "frame-pointer"="all" {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    stmg %r6, %r15, 48(%r15)
; CHECK-NEXT:    .cfi_offset %r6, -112
; CHECK-NEXT:    .cfi_offset %r7, -104
; CHECK-NEXT:    .cfi_offset %r8, -96
; CHECK-NEXT:    .cfi_offset %r9, -88
; CHECK-NEXT:    .cfi_offset %r10, -80
; CHECK-NEXT:    .cfi_offset %r11, -72
; CHECK-NEXT:    .cfi_offset %r12, -64
; CHECK-NEXT:    .cfi_offset %r13, -56
; CHECK-NEXT:    .cfi_offset %r14, -48
; CHECK-NEXT:    .cfi_offset %r15, -40
; CHECK-NEXT:    aghi %r15, -240
; CHECK-NEXT:    .cfi_def_cfa_offset 400
; CHECK-NEXT:    lgr %r11, %r15
; CHECK-NEXT:    .cfi_def_cfa_register %r11
; CHECK-NEXT:    std %f8, 232(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f9, 224(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f10, 216(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f11, 208(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f12, 200(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f13, 192(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f14, 184(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f15, 176(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset %f8, -168
; CHECK-NEXT:    .cfi_offset %f9, -176
; CHECK-NEXT:    .cfi_offset %f10, -184
; CHECK-NEXT:    .cfi_offset %f11, -192
; CHECK-NEXT:    .cfi_offset %f12, -200
; CHECK-NEXT:    .cfi_offset %f13, -208
; CHECK-NEXT:    .cfi_offset %f14, -216
; CHECK-NEXT:    .cfi_offset %f15, -224
; CHECK-NEXT:    la %r0, 160(%r11)
; CHECK-NEXT:    lgrl %r1, buf@GOT
; CHECK-NEXT:    stg %r0, 168(%r11)
; CHECK-NEXT:    mvhi 160(%r11), 10
; CHECK-NEXT:    larl %r0, .LBB0_1
; CHECK-NEXT:    stg %r0, 8(%r1)
; CHECK-NEXT:    stg %r11, 0(%r1)
; CHECK-NEXT:    stg %r15, 24(%r1)
; CHECK-NEXT:  .LBB0_1: # Block address taken
; CHECK-NEXT:    # %entry
; CHECK-NEXT:  .LBB0_2: # %entry
; CHECK-NEXT:    lg %r1, 168(%r11)
; CHECK-NEXT:    lgf %r2, 0(%r1)
; CHECK-NEXT:    ld %f8, 232(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f9, 224(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f10, 216(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f11, 208(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f12, 200(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f13, 192(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f14, 184(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f15, 176(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    lmg %r6, %r15, 288(%r11)
; CHECK-NEXT:    br %r14
entry:
  %val = alloca ptr, align 8
  %0 = alloca i8, i64 4, align 8
  store ptr %0, ptr %val, align 8
  %1 = load ptr, ptr %val, align 8
  store volatile i32 10, ptr %1, align 4
  %2 = call i32 @llvm.eh.sjlj.setjmp(ptr @buf)
  %3 = load ptr, ptr %val, align 8
  %4 = load volatile i32, ptr %3, align 4
  ret i32 %4
}

define signext i32 @foo1() "backchain" "frame-pointer"="all" {
; CHECK-LABEL: foo1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    stmg %r6, %r15, 48(%r15)
; CHECK-NEXT:    .cfi_offset %r6, -112
; CHECK-NEXT:    .cfi_offset %r7, -104
; CHECK-NEXT:    .cfi_offset %r8, -96
; CHECK-NEXT:    .cfi_offset %r9, -88
; CHECK-NEXT:    .cfi_offset %r10, -80
; CHECK-NEXT:    .cfi_offset %r11, -72
; CHECK-NEXT:    .cfi_offset %r12, -64
; CHECK-NEXT:    .cfi_offset %r13, -56
; CHECK-NEXT:    .cfi_offset %r14, -48
; CHECK-NEXT:    .cfi_offset %r15, -40
; CHECK-NEXT:    lgr %r1, %r15
; CHECK-NEXT:    aghi %r15, -240
; CHECK-NEXT:    .cfi_def_cfa_offset 400
; CHECK-NEXT:    stg %r1, 0(%r15)
; CHECK-NEXT:    lgr %r11, %r15
; CHECK-NEXT:    .cfi_def_cfa_register %r11
; CHECK-NEXT:    std %f8, 232(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f9, 224(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f10, 216(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f11, 208(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f12, 200(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f13, 192(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f14, 184(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    std %f15, 176(%r11) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset %f8, -168
; CHECK-NEXT:    .cfi_offset %f9, -176
; CHECK-NEXT:    .cfi_offset %f10, -184
; CHECK-NEXT:    .cfi_offset %f11, -192
; CHECK-NEXT:    .cfi_offset %f12, -200
; CHECK-NEXT:    .cfi_offset %f13, -208
; CHECK-NEXT:    .cfi_offset %f14, -216
; CHECK-NEXT:    .cfi_offset %f15, -224
; CHECK-NEXT:    la %r0, 160(%r11)
; CHECK-NEXT:    lgrl %r1, buf@GOT
; CHECK-NEXT:    stg %r0, 168(%r11)
; CHECK-NEXT:    mvhi 160(%r11), 10
; CHECK-NEXT:    larl %r0, .LBB1_1
; CHECK-NEXT:    stg %r0, 8(%r1)
; CHECK-NEXT:    stg %r11, 0(%r1)
; CHECK-NEXT:    stg %r15, 24(%r1)
; CHECK-NEXT:    lg %r0, 0(%r15)
; CHECK-NEXT:    stg %r0, 16(%r1)
; CHECK-NEXT:  .LBB1_1: # Block address taken
; CHECK-NEXT:    # %entry
; CHECK-NEXT:  .LBB1_2: # %entry
; CHECK-NEXT:    lg %r1, 168(%r11)
; CHECK-NEXT:    lgf %r2, 0(%r1)
; CHECK-NEXT:    ld %f8, 232(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f9, 224(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f10, 216(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f11, 208(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f12, 200(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f13, 192(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f14, 184(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    ld %f15, 176(%r11) # 8-byte Folded Reload
; CHECK-NEXT:    lmg %r6, %r15, 288(%r11)
; CHECK-NEXT:    br %r14
entry:
  %val = alloca ptr, align 8
  %0 = alloca i8, i64 4, align 8
  store ptr %0, ptr %val, align 8
  %1 = load ptr, ptr %val, align 8
  store volatile i32 10, ptr %1, align 4
  %2 = call i32 @llvm.eh.sjlj.setjmp(ptr @buf)
  %3 = load ptr, ptr %val, align 8
  %4 = load volatile i32, ptr %3, align 4
  ret i32 %4
}

