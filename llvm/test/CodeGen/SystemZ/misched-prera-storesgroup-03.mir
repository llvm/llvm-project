# RUN: llc -o - %s -mtriple=s390x-linux-gnu -mcpu=z16 -verify-machineinstrs \
# RUN:   -run-pass=machine-scheduler -debug-only=machine-scheduler 2>&1 \
# RUN:   | FileCheck %s

--- |
  define void @fun0(ptr noalias %Arg0, ptr noalias %Arg2, ptr noalias %Arg4) {
    ret void
  }
  define void @fun1() { ret void }
  define void @fun2(ptr %Arg0, ptr %Arg2, ptr noalias %Arg4) { ret void }
...

# Test that a group of stores is only rescheduled if they all have the same
# opcode. There are 8 stores of same depth, but of different opcodes so
# therefore not considered as a group.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun0:%bb.0
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling not enabled for data sequences.
# CHECK:      No StoresGroup.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK:      SU(10):   STG %2:gr64bit, %0:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(11):   STD %3:fp64bit, %1:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(12):   STG %4:gr64bit, %0:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(13):   STD %5:fp64bit, %1:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(14):   STG %6:gr64bit, %0:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(15):   STD %7:fp64bit, %1:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(16):   STG %8:gr64bit, %0:addr64bit, 0, $noreg ::
# CHECK-NEXT: SU(17):   STD %9:fp64bit, %1:addr64bit, 0, $noreg ::
---
name:            fun0
tracksRegLiveness: true
fixedStack:
  - { id: 0, type: default, offset: 0, size: 8, alignment: 8, stack-id: default }
body:             |
  bb.0:
    liveins: $r2d, $r3d
  
    %1:addr64bit = COPY $r3d
    %0:addr64bit = COPY $r2d
    %2:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %3:fp64bit = LD $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %4:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %5:fp64bit = LD $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %6:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %7:fp64bit = LD $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %8:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %9:fp64bit = LD $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    STG %2, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STD %3, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    STG %4, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STD %5, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    STG %6, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STD %7, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    STG %8, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STD %9, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    Return
...

# Test that stores that are not at the bottom (depth-wise) are not rescheduled.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun1:%bb.0
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun1:%bb.1
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling not enabled for data sequences.
# CHECK:      No StoresGroup.
# CHECK:      *** Final schedule for %bb.1 ***
# CHECK:      SU(6):   VST32 %8:fp32bit, %3:addr64bit, 0, $noreg
# CHECK-NEXT: SU(7):   VST32 %8:fp32bit, $noreg, 0, $noreg
# CHECK-NEXT: SU(8):   VST32 %8:fp32bit, %1:addr64bit, 0, $noreg
# CHECK-NEXT: SU(9):   VST32 %9:vr32bit, %0:addr64bit, 0, $noreg
# CHECK-NEXT: SU(10):  VST32 %8:fp32bit, %3:addr64bit, 0, $noreg
# CHECK-NEXT: SU(11):  VST32 %8:fp32bit, %1:addr64bit, 0, $noreg
# CHECK-NEXT: SU(12):  VST32 %8:fp32bit, %3:addr64bit, 0, $noreg
# CHECK-NEXT: SU(13):  VST32 %8:fp32bit, %1:addr64bit, 0, $noreg
# CHECK-NEXT: SU(14):  $r2l = LHI 0
---
name:            fun1
tracksRegLiveness: true
body:             |
  bb.0:
    successors: %bb.1(0x80000000)
    liveins: $r2d, $f0s, $r3d, $r4d

    %0:addr64bit = COPY $r4d
    %1:addr64bit = COPY $r3d
    %2:fp32bit = COPY $f0s
    %3:addr64bit = COPY $r2d
    %4:vr32bit = VL32 %1, 4, $noreg

  bb.1:
    %5:fp32bit = WFLPSB %2
    dead %6:fp32bit = nofpexcept LTEBR %5, implicit-def $cc, implicit $fpc
    %7:grx32bit = LHIMux 0
    %7:grx32bit = LOCHIMux %7, 1, 15, 2, implicit killed $cc
    %8:fp32bit = COPY %2
    %9:vr32bit = COPY %4
    VST32 %8, %3, 0, $noreg
    VST32 %8, $noreg, 0, $noreg
    VST32 %8, %1, 0, $noreg
    VST32 %9, %0, 0, $noreg
    VST32 %8, %3, 0, $noreg
    VST32 %8, %1, 0, $noreg
    VST32 %8, %3, 0, $noreg
    VST32 %8, %1, 0, $noreg
    $r2l = LHI 0
    Return implicit $r2l
...

# Test that a group of stores is only rescheduled if they all have the same
# depth. There are 8 stores, but of different depths so therefore not considered
# as a group.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun2:%bb.0
# CHECK:      Region is not tiny.
# CHECK-NEXT: Latency scheduling not enabled for data sequences.
# CHECK:      No StoresGroup.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK:      SU(10):   STG %2:gr64bit, %0:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg2)
# CHECK-NEXT: SU(11):   STG %3:gr64bit, %1:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg0)
# CHECK-NEXT: SU(12):   STG %4:gr64bit, %0:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg2)
# CHECK-NEXT: SU(13):   STG %5:gr64bit, %1:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg0)
# CHECK-NEXT: SU(14):   STG %6:gr64bit, %0:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg2)
# CHECK-NEXT: SU(15):   STG %7:gr64bit, %1:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg0)
# CHECK-NEXT: SU(16):   STG %8:gr64bit, %0:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg2)
# CHECK-NEXT: SU(17):   STG %9:gr64bit, %1:addr64bit, 0, $noreg :: (store (s64) into %ir.Arg0)
---
name:            fun2
tracksRegLiveness: true
fixedStack:
  - { id: 0, type: default, offset: 0, size: 8, alignment: 8, stack-id: default }
body:             |
  bb.0:
    liveins: $r2d, $r3d
  
    %1:addr64bit = COPY $r3d
    %0:addr64bit = COPY $r2d
    %2:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %3:gr64bit = LGF $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %4:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %5:gr64bit = LGF $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %6:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %7:gr64bit = LGF $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %8:gr64bit = LG $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    %9:gr64bit = LGF $noreg, 0, $noreg :: (load (s64) from %ir.Arg4)
    STG %2, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STG %3, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    STG %4, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STG %5, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    STG %6, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STG %7, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    STG %8, %1, 0, $noreg :: (store (s64) into %ir.Arg2)
    STG %9, %0, 0, $noreg :: (store (s64) into %ir.Arg0)
    Return
...
