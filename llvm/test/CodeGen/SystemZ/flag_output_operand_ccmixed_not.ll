; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; Test Flag Output Operands with 14 combinations of CCMASK and optimizations.
; This tests mixing XOR wirh OR, XOR with AND and OR with AND  with
; different ways of parenthesizing with != operator.

; RUN: llc < %s -verify-machineinstrs -mtriple=s390x-linux-gnu -O3 | FileCheck %s

; Test ((cc != 0) || (cc != 1)) ^ (cc != 2).
define signext range(i32 0, 43) i32 @bar_012_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

declare void @llvm.assume(i1 noundef) #1

; Test ((cc != 0) || (cc != 1)) ^ (cc != 3).
define signext range(i32 0, 43) i32 @bar_013_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc != 0) || (cc != 2)) ^ (cc != 3).
define signext range(i32 0, 43) i32 @bar_023_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB2_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc != 1) || (cc != 2)) ^ (cc != 3).
define signext range(i32 0, 43) i32 @bar_123_OR_XOR(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_OR_XOR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB3_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3 = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3, i32 42, i32 0
  ret i32 %cond
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 2)
define signext range(i32 0, 43) i32 @foo_012_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_012_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB4_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 3)
define signext range(i32 0, 43) i32 @foo_013_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_013_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB5_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc != 0) ^ (cc != 2)) || (cc != 3)
define signext range(i32 0, 43) i32 @foo_023_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_023_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB6_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test ((cc != 1) ^ (cc != 2)) || (cc != 3)
define signext range(i32 0, 43) i32 @foo_123_XOR_OR(i32 noundef signext %x) {
; CHECK-LABEL: foo_123_XOR_OR:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB7_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp4.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp4.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc != 0) || (cc != 1)) && (cc != 2))
define signext range(i32 0, 43) i32 @bar_012_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB8_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 2
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc != 0) || (cc != 1)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_013_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB9_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc != 0) || (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB10_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc != 1) || (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_OR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB11_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %cmp3.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc != 0) ^ (cc != 1)) && (cc != 2))
define signext range(i32 0, 43) i32 @bar_012_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB12_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor8 = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc != 0) ^ (cc != 1)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_013_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB13_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor8 = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc != 0) ^ (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB14_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp = icmp ne i32 %asmresult1, 0
  %cmp2 = icmp ne i32 %asmresult1, 2
  %xor8 = xor i1 %cmp, %cmp2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc != 1) ^ (cc != 2)) && (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_XOR_AND(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    blhr %r14
; CHECK-NEXT:  .LBB15_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -1
  %xor8 = icmp ult i32 %2, 2
  %cond = select i1 %xor8, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc != 0) && (cc != 1)) ^ (cc != 2)).
define signext range(i32 0, 43) i32 @bar_012_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB16_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %xor6.not = icmp eq i32 %asmresult1, 3
  %cond = select i1 %xor6.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc != 0) && (cc != 1)) ^ (cc != 3)).
define signext range(i32 0, 43) i32 @bar_013_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnhr %r14
; CHECK-NEXT:  .LBB17_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ugt i32 %asmresult1, 1
  %cmp3 = icmp ne i32 %asmresult1, 3
  %xor6 = xor i1 %2, %cmp3
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; Test (((cc != 0) && (cc != 2)) ^ (cc != 3)).
define signext range(i32 0, 43) i32 @bar_023_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB18_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %asmresult1 to i1
  %3 = icmp eq i32 %asmresult1, 3
  %tobool.not = xor i1 %3, %2
  %cond = select i1 %tobool.not, i32 0, i32 42
  ret i32 %cond
}

; Test (((cc != 1) && (cc != 2)) ^ (cc != 3)).
define signext range(i32 0, 43) i32 @bar_123_AND_XOR_a(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bner %r14
; CHECK-NEXT:  .LBB19_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %asmresult1, -3
  %3 = icmp ult i32 %2, -2
  %cmp3 = icmp ne i32 %asmresult1, 3
  %xor6 = xor i1 %cmp3, %3
  %cond = select i1 %xor6, i32 42, i32 0
  ret i32 %cond
}

; ((cc != 0) && ((cc != 1)) ^ (cc != 2))
define signext range(i32 0, 43) i32 @bar_012_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB20_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not = icmp eq i32 %asmresult1, 0
  %xor7.not = icmp eq i32 %asmresult1, 3
  %2 = or i1 %cmp.not, %xor7.not
  %cond = select i1 %2, i32 0, i32 42
  ret i32 %cond
}

; ((cc != 0) && ((cc != 1)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar_013_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    bnher %r14
; CHECK-NEXT:  .LBB21_1: # %entry
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2 = icmp ne i32 %asmresult1, 1
  %cmp3 = icmp ne i32 %asmresult1, 3
  %xor7 = xor i1 %cmp2, %cmp3
  %2 = select i1 %xor7, i32 42, i32 0
  ret i32 %2
}

; ((cc != 0) && ((cc != 2)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar_023_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB22_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %2, i32 0, i32 42
  ret i32 %cond
}

; ((cc != 1) && ((cc != 2)) ^ (cc != 3))
define signext range(i32 0, 43) i32 @bar_123_AND_XOR_b(i32 noundef signext %x) {
; CHECK-LABEL: bar_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    #APP
; CHECK-NEXT:    ahi %r2, 42
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 0
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB23_1: # %entry
; CHECK-NEXT:    lghi %r2, 42
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call { i32, i32 } asm "ahi $0,42\0A", "=d,={@cc},0"(i32 %x) #2
  %asmresult1 = extractvalue { i32, i32 } %0, 1
  %1 = icmp ult i32 %asmresult1, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ult i32 %asmresult1, 2
  %cond = select i1 %2, i32 0, i32 42
  ret i32 %cond
}


@a = global i32 0, align 4

; Test ((cc != 0) || (cc != 1)) && (cc != 2)
define range(i64 5, 9) i64 @fu_012_OR_AND() {
; CHECK-LABEL: fu_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB24_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) && (cc != 1)) || (cc != 2)
define noundef range(i64 5, 9) i64 @fu_012_AND_OR_a() {
; CHECK-LABEL: fu_012_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test  (cc != 0) && ((cc != 1) || (cc != 2))
define range(i64 5, 9) i64 @fu_012_AND_OR_b() {
; CHECK-LABEL: fu_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB26_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) || (cc != 1)) && (cc != 3).
define range(i64 5, 9) i64 @fu_013_OR_AND() {
; CHECK-LABEL: fu_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB27_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) && (cc != 1)) || (cc != 3)
define noundef range(i64 5, 9) i64 @fu_013_AND_OR_a() {
; CHECK-LABEL: fu_013_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test (cc != 0) && ((cc != 1) || (cc != 3))
define range(i64 5, 9) i64 @fu_013_AND_OR_b() {
; CHECK-LABEL: fu_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB29_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test  ((cc != 0) || (cc != 2)) && (cc != 3)
define range(i64 5, 9) i64 @fu_023_OR_AND() {
; CHECK-LABEL: fu_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB30_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; (cc != 0) && (cc != 2)) || (cc != 3
define noundef range(i64 5, 9) i64 @fu_023_AND_OR_a() {
; CHECK-LABEL: fu_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test (cc != 0) && ((cc != 2) || (cc != 3)).
define range(i64 5, 9) i64 @fu_023_AND_OR_b() {
; CHECK-LABEL: fu_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB32_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 1) || (cc != 2)) && (cc != 3)
define range(i64 5, 9) i64 @fu_123_OR_AND() {
; CHECK-LABEL: fu_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB33_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc != 1) && (cc != 2)) || (cc != 3)
define noundef range(i64 5, 9) i64 @fu_123_AND_OR_a() {
; CHECK-LABEL: fu_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  ret i64 5
}

; Test (cc != 1) && ((cc != 2) || (cc != 3)
define range(i64 5, 9) i64 @fu_123_AND_OR_b() {
; CHECK-LABEL: fu_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB35_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) ^ (cc != 1)) && (cc != 2)
define range(i64 5, 9) i64 @fu_012_XOR_AND() {
; CHECK-LABEL: fu_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB36_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  %. = select i1 %xor7.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) && (cc != 1)) ^ (cc != 2)
define range(i64 5, 9) i64 @fu_012_AND_XOR_a() {
; CHECK-LABEL: fu_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB37_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 3
  %. = select i1 %xor5.i.not, i64 8, i64 5
  ret i64 %.
}

; Test  (cc != 0) && ((cc != 1) ^ (cc != 2))
define range(i64 5, 9) i64 @fu_012_AND_XOR_b() {
; CHECK-LABEL: fu_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB38_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i = icmp eq i32 %0, 0
  %xor6.i = icmp eq i32 %0, 3
  %narrow.not = or i1 %cmp.not.i, %xor6.i
  %. = select i1 %narrow.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) ^ (cc != 1)) && (cc != 3)
define range(i64 5, 9) i64 @fu_013_XOR_AND() {
; CHECK-LABEL: fu_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnler %r14
; CHECK-NEXT:  .LBB39_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  %. = select i1 %xor7.i, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) && (cc != 1)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_013_XOR_AND_XOR_a() {
; CHECK-LABEL: fu_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB40_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = icmp samesign ugt i32 %0, 1
  %3 = icmp ne i32 %0, 3
  %tobool.not = and i1 %2, %3
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; (cc != 0) && ((cc != 1) ^ (cc != 3))
define range(i64 5, 9) i64 @fu_013_AND_XOR_b() {
; CHECK-LABEL: fu_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bher %r14
; CHECK-NEXT:  .LBB41_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not.not = icmp eq i32 %2, 0
  %. = select i1 %tobool.not.not.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) && (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_023_XOR_AND() {
; CHECK-LABEL: fu_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB42_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp eq i32 %0, 3
  %tobool.not = xor i1 %3, %2
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) && (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_023_AND_XOR_a() {
; CHECK-LABEL: fu_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB43_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp eq i32 %0, 3
  %tobool.not = xor i1 %3, %2
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc != 0) && ((cc != 2) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_023_AND_XOR_b() {
; CHECK-LABEL: fu_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB44_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %narrow = icmp samesign ult i32 %0, 2
  %. = select i1 %narrow, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 1) ^ (cc != 2)) && (cc != 3)
define range(i64 5, 9) i64 @fu_123_XOR_AND() {
; CHECK-LABEL: fu_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bnlhr %r14
; CHECK-NEXT:  .LBB45_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %xor7.i = icmp ult i32 %2, -2
  %. = select i1 %xor7.i, i64 8, i64 5
  ret i64 %.
}

; ((cc != 1) && (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_123_AND_XOR_a() {
; CHECK-LABEL: fu_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB46_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %tobool.not = icmp eq i32 %0, 0
  %. = select i1 %tobool.not, i64 8, i64 5
  ret i64 %.
}

; (cc != 1) && ((cc != 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fu_123_AND_XOR_b() {
; CHECK-LABEL: fu_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bler %r14
; CHECK-NEXT:  .LBB47_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %narrow = icmp samesign ult i32 %0, 2
  %. = select i1 %narrow, i64 8, i64 5
  ret i64 %.
}

; Test (((cc != 0) || (cc != 1)) && (cc != 2))
define i64 @bar1_012_OR_AND() {
; CHECK-LABEL: bar1_012_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB48_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

declare void @dummy() local_unnamed_addr #1

; Test (((cc == 0) && (cc != 1)) || (cc != 2))
define i64 @bar1_012_AND_OR_a() {
; CHECK-LABEL: bar1_012_AND_OR_a:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
if.end:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test (cc == 0) && ((cc != 1) || (cc != 2))
define i64 @bar1_012_AND_OR_b() {
; CHECK-LABEL: bar1_012_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB50_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}


; Test (((cc == 0) && (cc != 1)) || (cc != 3))
define i64 @bar1_013_OR_AND() {
; CHECK-LABEL: bar1_013_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB51_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (((cc == 0) && (cc != 1)) || (cc != 3)
define i64 @bar1_013_XOR_AND_OR_a() {
; CHECK-LABEL: bar1_013_XOR_AND_OR_a:
; CHECK:       # %bb.0: # %if.end
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
if.end:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test ((cc == 0) && (cc != 1)) || (cc != 3).
define i64 @bar1_013_AND_OR_b() {
; CHECK-LABEL: bar1_013_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB53_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) || (cc != 2)) && (cc != 3)
define i64 @bar1_023_OR_AND() {
; CHECK-LABEL: bar1_023_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB54_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc != 2)) || (cc != 3)
define i64 @bar1_023_AND_OR_a() {
; CHECK-LABEL: bar1_023_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test (cc == 0) && ((cc != 2) || (cc != 3))
define i64 @bar1_023_AND_OR_b() {
; CHECK-LABEL: bar1_023_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB56_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) || (cc != 2)) && (cc != 3)
define i64 @bar1_123_OR_AND() {
; CHECK-LABEL: bar1_123_OR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB57_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Tset ((cc == 1) && (cc != 2)) || (cc != 3).
define i64 @bar1_123_AND_OR_a() {
; CHECK-LABEL: bar1_123_AND_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jg dummy@PLT
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  tail call void @dummy() #3
  ret i64 undef
}

; Test (cc == 1) && ((cc != 2) || (cc != 3)).
define i64 @bar1_123_AND_OR_b() {
; CHECK-LABEL: bar1_123_AND_OR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB59_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 1
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc != 1)) && (cc != 2
define i64 @bar1_012_XOR_AND() {
; CHECK-LABEL: bar1_012_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB60_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  br i1 %xor7.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc != 1)) ^ (cc != 2)
define i64 @bar1_012_AND_XOR_a() {
; CHECK-LABEL: bar1_012_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB61_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor5.i.not = icmp eq i32 %0, 3
  br i1 %xor5.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) ^ (cc != 1)) && (cc != 3).
; TODO: DAGCombiner is not able to optimize srl/ipm/cc sequence because of
; switch table created by simplifyBranchOnICmpChain.
define i64 @bar1_012_AND_XOR_b() {
; CHECK-LABEL: bar1_012_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    ipm %r0
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB62_1: # %entry
; CHECK-NEXT:    srl %r0, 28
; CHECK-NEXT:    chi %r0, 3
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB62_2: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  switch i32 %0, label %if.then [
    i32 3, label %if.end
    i32 0, label %if.end
  ]

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %entry, %if.then
  ret i64 undef
}

; Test ((cc == 0) && (cc != 1)) ^ (cc != 3).
define i64 @bar1_013_XOR_AND() {
; CHECK-LABEL: bar1_013_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgle dummy@PLT
; CHECK-NEXT:  .LBB63_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %xor7.i = icmp samesign ugt i32 %0, 1
  br i1 %xor7.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 0) && ((cc != 1) ^ (cc != 3))
define i64 @bar1_013_XOR_AND_XOR_a() {
; CHECK-LABEL: bar1_013_XOR_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB64_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %switch = icmp eq i32 %0, 2
  br i1 %switch, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret i64 undef
}

; Test  (cc == 0) && ((cc != 1) ^ (cc != 3)).
define i64 @bar1_013_AND_XOR_b() {
; CHECK-LABEL: bar1_013_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnhe dummy@PLT
; CHECK-NEXT:  .LBB65_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = and i32 %0, 1
  %tobool.not.not.not = icmp eq i32 %2, 0
  br i1 %tobool.not.not.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc != 2)) ^ (cc != 3)
define i64 @bar1_023_XOR_AND() {
; CHECK-LABEL: bar1_023_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB66_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp eq i32 %0, 3
  %tobool.not = xor i1 %3, %2
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 0) && (cc != 2)) ^ (cc != 3)
define i64 @bar1_023_AND_XOR_a() {
; CHECK-LABEL: bar1_023_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB67_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = trunc i32 %0 to i1
  %3 = icmp eq i32 %0, 3
  %tobool.not = xor i1 %3, %2
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test  (cc == 0) && ((cc != 2) ^ (cc != 3)).
define i64 @bar1_023_AND_XOR_b() {
; CHECK-LABEL: bar1_023_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnle dummy@PLT
; CHECK-NEXT:  .LBB68_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %narrow = icmp samesign ult i32 %0, 2
  br i1 %narrow, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) ^ (cc != 2)) && (cc != 3).
define i64 @bar1_123_XOR_AND() {
; CHECK-LABEL: bar1_123_XOR_AND:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jglh dummy@PLT
; CHECK-NEXT:  .LBB69_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %2 = add nsw i32 %0, -3
  %xor7.i = icmp ult i32 %2, -2
  br i1 %xor7.i, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc == 1) && (cc != 2)) ^ (cc != 3).
define i64 @bar1_123_AND_XOR_a() {
; CHECK-LABEL: bar1_123_AND_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB70_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc == 1) && ((cc != 2) ^ (cc != 3))
define i64 @bar1_123_AND_XOR_b() {
; CHECK-LABEL: bar1_123_AND_XOR_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnle dummy@PLT
; CHECK-NEXT:  .LBB71_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %narrow = icmp samesign ult i32 %0, 2
  br i1 %narrow, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc != 0) || ((cc != 1) ^ (cc != 2))
define range(i64 5, 9) i64 @fu_012_OR_XOR_a() {
; CHECK-LABEL: fu_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB72_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) || (cc != 1)) ^ (cc != 2)
define range(i64 5, 9) i64 @fu_012_OR_XOR_c() {
; CHECK-LABEL: fu_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB73_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc != 0) ^ ((cc != 1) || (cc != 2));
define range(i64 5, 9) i64 @fu_012_XOR_OR_a() {
; CHECK-LABEL: fu_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB74_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 2)
define range(i64 5, 9) i64 @fu_012_XOR_OR_c() {
; CHECK-LABEL: fu_012_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bhr %r14
; CHECK-NEXT:  .LBB75_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 2
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 2)
define range(i64 5, 9) i64 @fu_013_OR_XOR_a() {
; CHECK-LABEL: fu_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB76_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) || (cc != 1)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_013_OR_XOR_c() {
; CHECK-LABEL: fu_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB77_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc != 0) ^ ((cc != 1) || (cc != 3))
define range(i64 5, 9) i64 @fu_013_XOR_OR_a() {
; CHECK-LABEL: fu_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB78_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 3)
define range(i64 5, 9) i64 @fu_013_XOR_OR_c() {
; CHECK-LABEL: fu_013_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB79_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test  (cc != 0) || ((cc != 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fu_023_OR_XOR_a() {
; CHECK-LABEL: fu_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB80_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 0) || (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_023_OR_XOR_c() {
; CHECK-LABEL: fu_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB81_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc != 0) ^ ((cc != 2) || (cc != 3))
define range(i64 5, 9) i64 @fu_023_XOR_OR_a() {
; CHECK-LABEL: fu_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    ber %r14
; CHECK-NEXT:  .LBB82_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc != 0) ^ (cc != 2)) || (cc != 3)
define range(i64 5, 9) i64 @fu_023_XOR_OR_c() {
; CHECK-LABEL: fu_023_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB83_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc != 1) || ((cc != 2) ^ (cc != 3))
define range(i64 5, 9) i64 @fu_123_OR_XOR_a() {
; CHECK-LABEL: fu_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB84_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.not.i.not, i64 8, i64 5
  ret i64 %.
}

; Test ((cc != 1) || (cc != 2)) ^ (cc != 3)
define range(i64 5, 9) i64 @fu_123_OR_XOR_c() {
; CHECK-LABEL: fu_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB85_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp2.i.not, i64 5, i64 8
  ret i64 %.
}

; Test (cc != 1 ) ^ ((cc != 2) || (cc != 3))
define range(i64 5, 9) i64 @fu_123_XOR_OR_a() {
; CHECK-LABEL: fu_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    blr %r14
; CHECK-NEXT:  .LBB86_1: # %entry
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  %. = select i1 %cmp.i.not, i64 5, i64 8
  ret i64 %.
}

; Test ((cc != 1) ^ (cc != 2)) || (cc != 3)
define range(i64 5, 9) i64 @fu_123_XOR_OR_c() {
; CHECK-LABEL: fu_123_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    lghi %r2, 8
; CHECK-NEXT:    bor %r14
; CHECK-NEXT:  .LBB87_1: # %entry
; CHECK-NEXT:    lghi %r2, 5
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  %. = select i1 %cmp3.i.not, i64 8, i64 5
  ret i64 %.
}

; Test (cc != 0) || ((cc != 1) ^ (cc != 2))
define i64 @bar_012_OR_XOR_a() {
; CHECK-LABEL: bar_012_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB88_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 0) || (cc != 1)) ^ (cc != 2)
define i64 @bar_012_OR_XOR_c() {
; CHECK-LABEL: bar_012_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgh dummy@PLT
; CHECK-NEXT:  .LBB89_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 2
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc != 0) ^ ((cc != 1) || (cc != 2));
define i64 @bar_012_XOR_OR_a() {
; CHECK-LABEL: bar_012_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB90_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 2)
define i64 @bar_012_XOR_OR_c() {
; CHECK-LABEL: bar_012_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnh dummy@PLT
; CHECK-NEXT:  .LBB91_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 2
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 2)
define i64 @bar_013_OR_XOR_a() {
; CHECK-LABEL: bar_013_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB92_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 0) || (cc != 1)) ^ (cc != 3)
define i64 @bar_013_OR_XOR_c() {
; CHECK-LABEL: bar_013_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB93_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc != 0) ^ ((cc != 1) || (cc != 3))
define i64 @bar_013_XOR_OR_a() {
; CHECK-LABEL: bar_013_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB94_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 0) ^ (cc != 1)) || (cc != 3)
define i64 @bar_013_XOR_OR_c() {
; CHECK-LABEL: bar_013_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB95_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test  (cc != 0) || ((cc != 2) ^ (cc != 3))
define i64 @bar_023_OR_XOR_a() {
; CHECK-LABEL: bar_023_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgne dummy@PLT
; CHECK-NEXT:  .LBB96_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 0
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 0) || (cc != 2)) ^ (cc != 3)
define i64 @bar_023_OR_XOR_c() {
; CHECK-LABEL: bar_023_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB97_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc != 0) ^ ((cc != 2) || (cc != 3))
define i64 @bar_023_XOR_OR_a() {
; CHECK-LABEL: bar_023_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jge dummy@PLT
; CHECK-NEXT:  .LBB98_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 0
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; ; Test ((cc != 0) ^ (cc != 2)) || (cc != 3)
define i64 @bar_023_XOR_OR_c() {
; CHECK-LABEL: bar_023_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB99_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc != 1) || ((cc != 2) ^ (cc != 3))
define i64 @bar_123_OR_XOR_a() {
; CHECK-LABEL: bar_123_OR_XOR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgnl dummy@PLT
; CHECK-NEXT:  .LBB100_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.not.i.not = icmp eq i32 %0, 1
  br i1 %cmp.not.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 1) || (cc != 2)) ^ (cc != 3)
define i64 @bar_123_OR_XOR_c() {
; CHECK-LABEL: bar_123_OR_XOR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgo dummy@PLT
; CHECK-NEXT:  .LBB101_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp2.i.not = icmp eq i32 %0, 3
  br i1 %cmp2.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test (cc != 1 ) ^ ((cc != 2) || (cc != 3))
define i64 @bar_123_XOR_OR_a() {
; CHECK-LABEL: bar_123_XOR_OR_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgl dummy@PLT
; CHECK-NEXT:  .LBB102_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp.i.not = icmp eq i32 %0, 1
  br i1 %cmp.i.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

; Test ((cc != 1) ^ (cc != 2)) || (cc != 3)
define i64 @bar_123_XOR_OR_c() {
; CHECK-LABEL: bar_123_XOR_OR_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lgrl %r1, a@GOT
; CHECK-NEXT:    #APP
; CHECK-NEXT:    alsi 0(%r1), -1
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    jgno dummy@PLT
; CHECK-NEXT:  .LBB103_1: # %if.end
; CHECK-NEXT:    br %r14
entry:
  %0 = tail call i32 asm sideeffect "       alsi    $1,-1\0A", "={@cc},=*QS,*QS,~{memory}"(ptr nonnull elementtype(i32) @a, ptr nonnull elementtype(i32) @a) #3
  %1 = icmp ult i32 %0, 4
  tail call void @llvm.assume(i1 %1)
  %cmp3.i.not = icmp eq i32 %0, 3
  br i1 %cmp3.i.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dummy() #3
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 undef
}

