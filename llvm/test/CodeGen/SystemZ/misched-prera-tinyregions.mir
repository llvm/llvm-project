# RUN: llc -o - %s -mtriple=s390x-linux-gnu -mcpu=z16 \
# RUN:   -verify-machineinstrs -run-pass=machine-scheduler 2>&1 \
# RUN:   -debug-only=machine-scheduler | FileCheck %s
# REQUIRES: asserts

# Don't move things around in this tiny region with just 7 instructions (it has
# a good input order in the sense that %0 and %1 do not overlap and both have
# COPYs involving $r2d).
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun0:%bb.0 
# CHECK: Region is tiny.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK-NEXT: SU(0):   %0:addr64bit = COPY $r2d
# CHECK-NEXT: SU(1):   STG %0:addr64bit, $noreg, 0, $noreg :: (store (s64) into
# CHECK-NEXT: SU(2):   %1:gr64bit = LA %0:addr64bit, 24, $noreg
# CHECK-NEXT: SU(3):   $r1d = LGHI 0
# CHECK-NEXT: SU(4):   $r2d = COPY %1:gr64bit
# CHECK-NEXT: SU(5):   $r3d = LGHI 0
# CHECK-NEXT: SU(6):   $r4l = LHIMux 0
---
name:            fun0
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $r2d
    %0:addr64bit = COPY $r2d
    STG %0, $noreg, 0, $noreg :: (store (s64) into `ptr null`)
    %1:gr64bit = LA %0, 24, $noreg
    $r1d = LGHI 0
    $r2d = COPY %1
    $r3d = LGHI 0
    $r4l = LHIMux 0
    CallBR killed $r1d, csr_systemz_elf, implicit $r2d, implicit killed $r3d, implicit killed $r4l
...

# A blocking long-latency (FP divide) is moved up also in a tiny region.
# CHECK:      ********** MI Scheduling **********
# CHECK-NEXT: fun1:%bb.0
# CHECK: Region is tiny.
# CHECK:      *** Final schedule for %bb.0 ***
# CHECK-NEXT: SU(0):   dead %0:gr64bit = COPY $r3d
# CHECK-NEXT: SU(1):   %1:gr64bit = COPY $r2d
# CHECK-NEXT: SU(4):   %2:fp64bit = COPY undef %3:fp64bit
# CHECK-NEXT: SU(5):   dead %2:fp64bit = DDB %2:fp64bit(tied-def 0), {{.*}}
# CHECK-NEXT: SU(2):   %1:gr64bit = AGRK %1:gr64bit, %1:gr64bit, {{.*}}
# CHECK-NEXT: SU(3):   dead %1:gr64bit = AGRK %1:gr64bit, %1:gr64bit, {{.*}}
---
name:            fun1
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $r2d, $r3d

    %0:gr64bit = COPY $r3d
    %1:gr64bit = COPY $r2d
    %1:gr64bit = AGRK %1, %1, implicit-def dead $cc
    %1:gr64bit = AGRK %1, %1, implicit-def dead $cc
    %2:fp64bit = COPY undef %3:fp64bit
    %2:fp64bit = DDB %2, $noreg, 0, $noreg, implicit $fpc
    Return
...
