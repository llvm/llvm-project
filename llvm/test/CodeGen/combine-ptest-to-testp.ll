; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=x86_64-- -mattr=+avx2  | FileCheck %s

define void @combine_ptest_to_vtestps_1(<4 x i32> noundef %a) {
; CHECK-LABEL: combine_ptest_to_vtestps_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestps %xmm0, %xmm0
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <4 x i32> %a, splat (i32 -2147483648)
  %rdx.or = tail call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %and)
  %cmp.not = icmp eq i32 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestps_2(<4 x i32> noundef %a, <4 x i32> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestps_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestps %xmm1, %xmm0
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <4 x i32> %a, splat (i32 -2147483648)
  %and1 = and <4 x i32> %and, %b
  %rdx.or = tail call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %and1)
  %cmp.not = icmp eq i32 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestps_3(<4 x i32> noundef %a, <4 x i32> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestps_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestps %xmm1, %xmm0
; CHECK-NEXT:    jae foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %not = and <4 x i32> %a, splat (i32 -2147483648)
  %and = xor <4 x i32> %not, splat (i32 -2147483648)
  %and1 = and <4 x i32> %and, %b
  %rdx.or = tail call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %and1)
  %cmp.not = icmp eq i32 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestps_4(<8 x i32> noundef %a) {
; CHECK-LABEL: combine_ptest_to_vtestps_4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestps %ymm0, %ymm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <8 x i32> %a, splat (i32 -2147483648)
  %rdx.or = tail call i32 @llvm.vector.reduce.or.v8i32(<8 x i32> %and)
  %cmp.not = icmp eq i32 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestps_5(<8 x i32> noundef %a, <8 x i32> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestps_5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestps %ymm1, %ymm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <8 x i32> %a, splat (i32 -2147483648)
  %and1 = and <8 x i32> %and, %b
  %rdx.or = tail call i32 @llvm.vector.reduce.or.v8i32(<8 x i32> %and1)
  %cmp.not = icmp eq i32 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestps_6(<8 x i32> noundef %a, <8 x i32> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestps_6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestps %ymm1, %ymm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jae foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %not = and <8 x i32> %a, splat (i32 -2147483648)
  %and = xor <8 x i32> %not, splat (i32 -2147483648)
  %and1 = and <8 x i32> %and, %b
  %rdx.or = tail call i32 @llvm.vector.reduce.or.v8i32(<8 x i32> %and1)
  %cmp.not = icmp eq i32 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestpd_1(<2 x i64> noundef %a) {
; CHECK-LABEL: combine_ptest_to_vtestpd_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestpd %xmm0, %xmm0
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <2 x i64> %a, splat (i64 -9223372036854775808)
  %rdx.or = tail call i64 @llvm.vector.reduce.or.v2i64(<2 x i64> %and)
  %cmp.not = icmp eq i64 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestpd_2(<2 x i64> noundef %a, <2 x i64> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestpd_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestpd %xmm1, %xmm0
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <2 x i64> %a, splat (i64 -9223372036854775808)
  %and1 = and <2 x i64> %and, %b
  %rdx.or = tail call i64 @llvm.vector.reduce.or.v2i64(<2 x i64> %and1)
  %cmp.not = icmp eq i64 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestpd_3(<2 x i64> noundef %a, <2 x i64> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestpd_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpandn {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
; CHECK-NEXT:    vptest %xmm1, %xmm0
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %not = and <2 x i64> %a, splat (i64 -9223372036854775808)
  %and = xor <2 x i64> %not, splat (i64 -9223372036854775808)
  %and1 = and <2 x i64> %and, %b
  %rdx.or = tail call i64 @llvm.vector.reduce.or.v2i64(<2 x i64> %and1)
  %cmp.not = icmp eq i64 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestpd_4(<4 x i64> noundef %a) {
; CHECK-LABEL: combine_ptest_to_vtestpd_4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestpd %ymm0, %ymm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <4 x i64> %a, splat (i64 -9223372036854775808)
  %rdx.or = tail call i64 @llvm.vector.reduce.or.v4i64(<4 x i64> %and)
  %cmp.not = icmp eq i64 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestpd_5(<4 x i64> noundef %a, <4 x i64> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestpd_5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vtestpd %ymm1, %ymm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %and = and <4 x i64> %a, splat (i64 -9223372036854775808)
  %and1 = and <4 x i64> %and, %b
  %rdx.or = tail call i64 @llvm.vector.reduce.or.v4i64(<4 x i64> %and1)
  %cmp.not = icmp eq i64 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

define void @combine_ptest_to_vtestpd_6(<4 x i64> noundef %a, <4 x i64> noundef %b) {
; CHECK-LABEL: combine_ptest_to_vtestpd_6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq {{.*#+}} ymm2 = [9223372036854775808,9223372036854775808,9223372036854775808,9223372036854775808]
; CHECK-NEXT:    vpandn %ymm2, %ymm0, %ymm0
; CHECK-NEXT:    vptest %ymm1, %ymm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.end
; CHECK-NEXT:    retq
entry:
  %not = and <4 x i64> %a, splat (i64 -9223372036854775808)
  %and = xor <4 x i64> %not, splat (i64 -9223372036854775808)
  %and1 = and <4 x i64> %and, %b
  %rdx.or = tail call i64 @llvm.vector.reduce.or.v4i64(<4 x i64> %and1)
  %cmp.not = icmp eq i64 %rdx.or, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:
  tail call void @foo()
  br label %if.end

if.end:
  ret void
}

declare void @foo()
declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32>)
declare i32 @llvm.vector.reduce.or.v8i32(<8 x i32>)
declare i64 @llvm.vector.reduce.or.v2i64(<2 x i64>)
declare i64 @llvm.vector.reduce.or.v4i64(<4 x i64>)
