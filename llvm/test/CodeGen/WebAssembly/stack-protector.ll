; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs -mtriple=wasm32-unknown-unknown < %s | FileCheck -check-prefix=WASM32 %s

@"\01LC" = internal constant [11 x i8] c"buf == %s\0A\00"		; <ptr> [#uses=1]

define void @test(ptr %a) nounwind ssp {
; WASM32-LABEL: test:
; WASM32:         .functype test (i32) -> ()
; WASM32-NEXT:    .local i32
; WASM32-NEXT:  # %bb.0: # %entry
; WASM32-NEXT:    global.get __stack_pointer
; WASM32-NEXT:    i32.const 32
; WASM32-NEXT:    i32.sub
; WASM32-NEXT:    local.tee 1
; WASM32-NEXT:    global.set __stack_pointer
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    local.get 0
; WASM32-NEXT:    i32.store 16
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 0
; WASM32-NEXT:    i32.load __stack_chk_guard
; WASM32-NEXT:    i32.store 28
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 20
; WASM32-NEXT:    i32.add
; WASM32-NEXT:    local.get 0
; WASM32-NEXT:    call strcpy
; WASM32-NEXT:    drop
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 20
; WASM32-NEXT:    i32.add
; WASM32-NEXT:    i32.store 0
; WASM32-NEXT:    i32.const LC
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    call printf
; WASM32-NEXT:    drop
; WASM32-NEXT:    block
; WASM32-NEXT:    i32.const 0
; WASM32-NEXT:    i32.load __stack_chk_guard
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.load 28
; WASM32-NEXT:    i32.eq
; WASM32-NEXT:    br_if 0 # 0: down to label0
; WASM32-NEXT:  # %bb.1: # %return
; WASM32-NEXT:    call __stack_chk_fail
; WASM32-NEXT:    unreachable
; WASM32-NEXT:  .LBB0_2: # %return
; WASM32-NEXT:    end_block # label0:
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 32
; WASM32-NEXT:    i32.add
; WASM32-NEXT:    global.set __stack_pointer
; WASM32-NEXT:    # fallthrough-return
entry:
	%a_addr = alloca ptr		; <ptr> [#uses=2]
	%buf = alloca [8 x i8]		; <ptr> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32		; <i32> [#uses=0]
	store ptr %a, ptr %a_addr
	%0 = load ptr, ptr %a_addr, align 4		; <ptr> [#uses=1]
	%1 = call ptr @strcpy(ptr %buf, ptr %0) nounwind		; <ptr> [#uses=0]
	%2 = call i32 (ptr, ...) @printf(ptr @"\01LC", ptr %buf) nounwind		; <i32> [#uses=0]
	br label %return

return:		; preds = %entry
	ret void
}

define i32 @test_return_i32(ptr %a) nounwind ssp {
; WASM32-LABEL: test_return_i32:
; WASM32:         .functype test_return_i32 (i32) -> (i32)
; WASM32-NEXT:    .local i32
; WASM32-NEXT:  # %bb.0: # %entry
; WASM32-NEXT:    global.get __stack_pointer
; WASM32-NEXT:    i32.const 32
; WASM32-NEXT:    i32.sub
; WASM32-NEXT:    local.tee 1
; WASM32-NEXT:    global.set __stack_pointer
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    local.get 0
; WASM32-NEXT:    i32.store 16
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 0
; WASM32-NEXT:    i32.load __stack_chk_guard
; WASM32-NEXT:    i32.store 28
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 20
; WASM32-NEXT:    i32.add
; WASM32-NEXT:    local.get 0
; WASM32-NEXT:    call strcpy
; WASM32-NEXT:    drop
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 20
; WASM32-NEXT:    i32.add
; WASM32-NEXT:    i32.store 0
; WASM32-NEXT:    i32.const LC
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    call printf
; WASM32-NEXT:    drop
; WASM32-NEXT:    block
; WASM32-NEXT:    i32.const 0
; WASM32-NEXT:    i32.load __stack_chk_guard
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.load 28
; WASM32-NEXT:    i32.eq
; WASM32-NEXT:    br_if 0 # 0: down to label1
; WASM32-NEXT:  # %bb.1: # %return
; WASM32-NEXT:    call __stack_chk_fail
; WASM32-NEXT:    unreachable
; WASM32-NEXT:  .LBB1_2: # %return
; WASM32-NEXT:    end_block # label1:
; WASM32-NEXT:    local.get 1
; WASM32-NEXT:    i32.const 32
; WASM32-NEXT:    i32.add
; WASM32-NEXT:    global.set __stack_pointer
; WASM32-NEXT:    i32.const 0
; WASM32-NEXT:    # fallthrough-return
entry:
  %a_addr = alloca ptr    ; <ptr> [#uses=2]
  %buf = alloca [8 x i8]    ; <ptr> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32    ; <i32> [#uses=0]
  store ptr %a, ptr %a_addr
  %0 = load ptr, ptr %a_addr, align 4    ; <ptr> [#uses=1]
  %1 = call ptr @strcpy(ptr %buf, ptr %0) nounwind    ; <ptr> [#uses=0]
  %2 = call i32 (ptr, ...) @printf(ptr @"\01LC", ptr %buf) nounwind    ; <i32> [#uses=0]
  br label %return

return:    ; preds = %entry
  ret i32 0
}

declare ptr @strcpy(ptr, ptr) nounwind

declare i32 @printf(ptr, ...) nounwind
