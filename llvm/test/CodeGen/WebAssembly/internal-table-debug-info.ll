; RUN: llc < %s --mtriple=wasm32-unknown-emscripten -o - | FileCheck %s

; Test that declaring __indirect_function_table as a funcref table doesn't cause
; an error in getOrCreateFunctionTableSymbol() when there is an indirect call in
; the module.
;
; The __indirect_function_table symbol was generated by the debug info with no
; type which made getOrCreateFunctionTableSymbol() angry. The fix was to set the
; type of the table in getOrCreateFunctionTableSymbol() if it's undefined.

target triple = "wasm32-unknown-emscripten"

; CHECK: .tabletype __indirect_function_table, funcref
@__indirect_function_table = internal addrspace(1) global [0 x ptr addrspace(20)] zeroinitializer, !dbg !0

declare ptr addrspace(20) @llvm.wasm.table.get.funcref(ptr addrspace(1), i32)

; CHECK-LABEL: g:
; CHECK: call_indirect __indirect_function_table, () -> ()
; CHECK: table.get __indirect_function_table

define ptr addrspace(20) @g(ptr %f) {
  call void %f()
  %idx = ptrtoint ptr %f to i32
  %result = call ptr addrspace(20) @llvm.wasm.table.get.funcref(ptr addrspace(1) @__indirect_function_table, i32 %idx)
  ret ptr addrspace(20) %result
}

!llvm.dbg.cu = !{!2}
!llvm.module.flags = !{!5, !6}

!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
!1 = distinct !DIGlobalVariable(name: "table", scope: !2, file: !3, type: !4, isLocal: true, isDefinition: true)
!2 = distinct !DICompileUnit(language: DW_LANG_C11, file: !3, emissionKind: FullDebug, globals: !{!0})
!3 = !DIFile(filename: "test.c", directory: "")
!4 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
!5 = !{i32 7, !"Dwarf Version", i32 4}
!6 = !{i32 2, !"Debug Info Version", i32 3}
