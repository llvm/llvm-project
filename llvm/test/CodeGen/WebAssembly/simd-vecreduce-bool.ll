; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s -verify-machineinstrs -disable-wasm-fallthrough-return-opt -wasm-disable-explicit-locals -wasm-keep-registers -mattr=+simd128 | FileCheck %s

; Tests that bool vecreduce produces anytrue and alltrue instructions

target triple = "wasm32-unknown-unknown"

declare i1 @llvm.vector.reduce.or.v2i1(<2 x i1>)
declare i1 @llvm.vector.reduce.or.v4i1(<4 x i1>)
declare i1 @llvm.vector.reduce.or.v7i1(<7 x i1>)
declare i1 @llvm.vector.reduce.or.v8i1(<8 x i1>)
declare i1 @llvm.vector.reduce.or.v16i1(<16 x i1>)
declare i1 @llvm.vector.reduce.and.v2i1(<2 x i1>)
declare i1 @llvm.vector.reduce.and.v4i1(<4 x i1>)
declare i1 @llvm.vector.reduce.and.v7i1(<7 x i1>)
declare i1 @llvm.vector.reduce.and.v8i1(<8 x i1>)
declare i1 @llvm.vector.reduce.and.v16i1(<16 x i1>)

; =====================
; Regular vectors of i1
; =====================

define i1 @test_any_v8i1(<8 x i1> %x) {
; CHECK-LABEL: test_any_v8i1:
; CHECK:         .functype test_any_v8i1 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 15
; CHECK-NEXT:    i16x8.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 15
; CHECK-NEXT:    i16x8.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    v128.any_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %ret = call i1 @llvm.vector.reduce.or.v8i1(<8 x i1> %x)
  ret i1 %ret
}

define i1 @test_all_v8i1(<8 x i1> %x) {
; CHECK-LABEL: test_all_v8i1:
; CHECK:         .functype test_all_v8i1 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 15
; CHECK-NEXT:    i16x8.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 15
; CHECK-NEXT:    i16x8.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    i16x8.all_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %ret = call i1 @llvm.vector.reduce.and.v8i1(<8 x i1> %x)
  ret i1 %ret
}

define i1 @test_none_v8i1(<8 x i1> %x) {
; CHECK-LABEL: test_none_v8i1:
; CHECK:         .functype test_none_v8i1 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 15
; CHECK-NEXT:    i16x8.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push6=, 15
; CHECK-NEXT:    i16x8.shr_s $push2=, $pop1, $pop6
; CHECK-NEXT:    v128.any_true $push3=, $pop2
; CHECK-NEXT:    i32.const $push4=, 1
; CHECK-NEXT:    i32.xor $push5=, $pop3, $pop4
; CHECK-NEXT:    return $pop5
  %any = call i1 @llvm.vector.reduce.or.v8i1(<8 x i1> %x)
  %none = xor i1 %any, 1
  ret i1 %none
}

define i1 @test_not_all_v8i1(<8 x i1> %x) {
; CHECK-LABEL: test_not_all_v8i1:
; CHECK:         .functype test_not_all_v8i1 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 15
; CHECK-NEXT:    i16x8.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push6=, 15
; CHECK-NEXT:    i16x8.shr_s $push2=, $pop1, $pop6
; CHECK-NEXT:    i16x8.all_true $push3=, $pop2
; CHECK-NEXT:    i32.const $push4=, 1
; CHECK-NEXT:    i32.xor $push5=, $pop3, $pop4
; CHECK-NEXT:    return $pop5
  %all = call i1 @llvm.vector.reduce.and.v8i1(<8 x i1> %x)
  %notall = xor i1 %all, 1
  ret i1 %notall
}

define i1 @test_any_v16i1(<16 x i1> %x) {
; CHECK-LABEL: test_any_v16i1:
; CHECK:         .functype test_any_v16i1 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 7
; CHECK-NEXT:    i8x16.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 7
; CHECK-NEXT:    i8x16.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    v128.any_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %ret = call i1 @llvm.vector.reduce.or.v16i1(<16 x i1> %x)
  ret i1 %ret
}

define i1 @test_all_v16i1(<16 x i1> %x) {
; CHECK-LABEL: test_all_v16i1:
; CHECK:         .functype test_all_v16i1 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 7
; CHECK-NEXT:    i8x16.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 7
; CHECK-NEXT:    i8x16.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    i8x16.all_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %ret = call i1 @llvm.vector.reduce.and.v16i1(<16 x i1> %x)
  ret i1 %ret
}

; ==================================
; Regular vectors of larger integers
; ==================================

define i1 @test_any_v16i8(<16 x i8> %x) {
; CHECK-LABEL: test_any_v16i8:
; CHECK:         .functype test_any_v16i8 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 7
; CHECK-NEXT:    i8x16.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 7
; CHECK-NEXT:    i8x16.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    v128.any_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <16 x i8> %x to <16 x i1>
  %ret = call i1 @llvm.vector.reduce.or.v16i1(<16 x i1> %bits)
  ret i1 %ret
}

define i1 @test_all_v16i8(<16 x i8> %x) {
; CHECK-LABEL: test_all_v16i8:
; CHECK:         .functype test_all_v16i8 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 7
; CHECK-NEXT:    i8x16.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 7
; CHECK-NEXT:    i8x16.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    i8x16.all_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <16 x i8> %x to <16 x i1>
  %ret = call i1 @llvm.vector.reduce.and.v16i1(<16 x i1> %bits)
  ret i1 %ret
}

define i1 @test_any_v8i16(<8 x i16> %x) {
; CHECK-LABEL: test_any_v8i16:
; CHECK:         .functype test_any_v8i16 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 15
; CHECK-NEXT:    i16x8.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 15
; CHECK-NEXT:    i16x8.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    v128.any_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <8 x i16> %x to <8 x i1>
  %ret = call i1 @llvm.vector.reduce.or.v8i1(<8 x i1> %bits)
  ret i1 %ret
}

define i1 @test_all_v8i16(<8 x i16> %x) {
; CHECK-LABEL: test_all_v8i16:
; CHECK:         .functype test_all_v8i16 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 15
; CHECK-NEXT:    i16x8.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 15
; CHECK-NEXT:    i16x8.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    i16x8.all_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <8 x i16> %x to <8 x i1>
  %ret = call i1 @llvm.vector.reduce.and.v8i1(<8 x i1> %bits)
  ret i1 %ret
}

define i1 @test_any_v4i32(<4 x i32> %x) {
; CHECK-LABEL: test_any_v4i32:
; CHECK:         .functype test_any_v4i32 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 31
; CHECK-NEXT:    i32x4.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 31
; CHECK-NEXT:    i32x4.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    v128.any_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <4 x i32> %x to <4 x i1>
  %ret = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> %bits)
  ret i1 %ret
}

define i1 @test_all_v4i32(<4 x i32> %x) {
; CHECK-LABEL: test_all_v4i32:
; CHECK:         .functype test_all_v4i32 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 31
; CHECK-NEXT:    i32x4.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 31
; CHECK-NEXT:    i32x4.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    i32x4.all_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <4 x i32> %x to <4 x i1>
  %ret = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> %bits)
  ret i1 %ret
}

define i1 @test_any_v2i64(<2 x i64> %x) {
; CHECK-LABEL: test_any_v2i64:
; CHECK:         .functype test_any_v2i64 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 63
; CHECK-NEXT:    i64x2.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 63
; CHECK-NEXT:    i64x2.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    v128.any_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <2 x i64> %x to <2 x i1>
  %ret = call i1 @llvm.vector.reduce.or.v2i1(<2 x i1> %bits)
  ret i1 %ret
}

define i1 @test_all_v2i64(<2 x i64> %x) {
; CHECK-LABEL: test_all_v2i64:
; CHECK:         .functype test_all_v2i64 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 63
; CHECK-NEXT:    i64x2.shl $push1=, $0, $pop0
; CHECK-NEXT:    i32.const $push4=, 63
; CHECK-NEXT:    i64x2.shr_s $push2=, $pop1, $pop4
; CHECK-NEXT:    i64x2.all_true $push3=, $pop2
; CHECK-NEXT:    return $pop3
  %bits = trunc <2 x i64> %x to <2 x i1>
  %ret = call i1 @llvm.vector.reduce.and.v2i1(<2 x i1> %bits)
  ret i1 %ret
}

; ====================
; Unusual vector sizes
; ====================

define i1 @test_any_v7i1(<7 x i1> %x) {
; CHECK-LABEL: test_any_v7i1:
; CHECK:         .functype test_any_v7i1 (i32, i32, i32, i32, i32, i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.or $push0=, $0, $1
; CHECK-NEXT:    i32.or $push1=, $pop0, $2
; CHECK-NEXT:    i32.or $push2=, $pop1, $3
; CHECK-NEXT:    i32.or $push3=, $pop2, $4
; CHECK-NEXT:    i32.or $push4=, $pop3, $5
; CHECK-NEXT:    i32.or $push5=, $pop4, $6
; CHECK-NEXT:    return $pop5
  %ret = call i1 @llvm.vector.reduce.or.v7i1(<7 x i1> %x)
  ret i1 %ret
}

define i1 @test_all_v7i1(<7 x i1> %x) {
; CHECK-LABEL: test_all_v7i1:
; CHECK:         .functype test_all_v7i1 (i32, i32, i32, i32, i32, i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.and $push0=, $0, $1
; CHECK-NEXT:    i32.and $push1=, $pop0, $2
; CHECK-NEXT:    i32.and $push2=, $pop1, $3
; CHECK-NEXT:    i32.and $push3=, $pop2, $4
; CHECK-NEXT:    i32.and $push4=, $pop3, $5
; CHECK-NEXT:    i32.and $push5=, $pop4, $6
; CHECK-NEXT:    i32.const $push6=, 1
; CHECK-NEXT:    i32.and $push7=, $pop5, $pop6
; CHECK-NEXT:    return $pop7
  %ret = call i1 @llvm.vector.reduce.and.v7i1(<7 x i1> %x)
  ret i1 %ret
}

define i1 @test_any_v8i8(<8 x i8> %x) {
; CHECK-LABEL: test_any_v8i8:
; CHECK:         .functype test_any_v8i8 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i8x16.shuffle $push0=, $0, $0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0
; CHECK-NEXT:    i32.const $push1=, 15
; CHECK-NEXT:    i16x8.shl $push2=, $pop0, $pop1
; CHECK-NEXT:    i32.const $push5=, 15
; CHECK-NEXT:    i16x8.shr_s $push3=, $pop2, $pop5
; CHECK-NEXT:    v128.any_true $push4=, $pop3
; CHECK-NEXT:    return $pop4
  %bits = trunc <8 x i8> %x to <8 x i1>
  %ret = call i1 @llvm.vector.reduce.or.v8i1(<8 x i1> %bits)
  ret i1 %ret
}

define i1 @test_all_v8i8(<8 x i8> %x) {
; CHECK-LABEL: test_all_v8i8:
; CHECK:         .functype test_all_v8i8 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i8x16.shuffle $push0=, $0, $0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0
; CHECK-NEXT:    i32.const $push1=, 15
; CHECK-NEXT:    i16x8.shl $push2=, $pop0, $pop1
; CHECK-NEXT:    i32.const $push5=, 15
; CHECK-NEXT:    i16x8.shr_s $push3=, $pop2, $pop5
; CHECK-NEXT:    i16x8.all_true $push4=, $pop3
; CHECK-NEXT:    return $pop4
  %bits = trunc <8 x i8> %x to <8 x i1>
  %ret = call i1 @llvm.vector.reduce.and.v8i1(<8 x i1> %bits)
  ret i1 %ret
}

;; =====================
;; Test reduce after cmp
;; =====================

define i1 @test_cmp_v16i8(<16 x i8> %x) {
; CHECK-LABEL: test_cmp_v16i8:
; CHECK:         .functype test_cmp_v16i8 (v128) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    v128.const $push0=, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
; CHECK-NEXT:    i8x16.eq $push1=, $0, $pop0
; CHECK-NEXT:    v128.any_true $push2=, $pop1
; CHECK-NEXT:    return $pop2
  %zero = icmp eq <16 x i8> %x, zeroinitializer
  %ret = call i1 @llvm.vector.reduce.or.v16i1(<16 x i1> %zero)
  ret i1 %ret
}
