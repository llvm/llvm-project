; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=wasm32 -wasm-keep-registers | FileCheck %s --check-prefixes=WASM32
; NOTE: did not compile on wasm64 at the time the test was created!

define { i128, i8 } @muloti_test(i128 %l, i128 %r) unnamed_addr #0 {
; WASM32-LABEL: muloti_test:
; WASM32:         .functype muloti_test (i32, i64, i64, i64, i64) -> ()
; WASM32-NEXT:    .local i32
; WASM32-NEXT:  # %bb.0: # %start
; WASM32-NEXT:    global.get $push16=, __stack_pointer
; WASM32-NEXT:    i32.const $push17=, 48
; WASM32-NEXT:    i32.sub $push38=, $pop16, $pop17
; WASM32-NEXT:    local.tee $push37=, 5, $pop38
; WASM32-NEXT:    global.set __stack_pointer, $pop37
; WASM32-NEXT:    local.get $push39=, 5
; WASM32-NEXT:    i32.const $push22=, 32
; WASM32-NEXT:    i32.add $push23=, $pop39, $pop22
; WASM32-NEXT:    local.get $push41=, 1
; WASM32-NEXT:    i64.const $push0=, 0
; WASM32-NEXT:    local.get $push40=, 3
; WASM32-NEXT:    i64.const $push36=, 0
; WASM32-NEXT:    call __multi3, $pop23, $pop41, $pop0, $pop40, $pop36
; WASM32-NEXT:    local.get $push42=, 5
; WASM32-NEXT:    i32.const $push20=, 16
; WASM32-NEXT:    i32.add $push21=, $pop42, $pop20
; WASM32-NEXT:    local.get $push44=, 4
; WASM32-NEXT:    i64.const $push35=, 0
; WASM32-NEXT:    local.get $push43=, 1
; WASM32-NEXT:    i64.const $push34=, 0
; WASM32-NEXT:    call __multi3, $pop21, $pop44, $pop35, $pop43, $pop34
; WASM32-NEXT:    local.get $push47=, 5
; WASM32-NEXT:    local.get $push46=, 2
; WASM32-NEXT:    i64.const $push33=, 0
; WASM32-NEXT:    local.get $push45=, 3
; WASM32-NEXT:    i64.const $push32=, 0
; WASM32-NEXT:    call __multi3, $pop47, $pop46, $pop33, $pop45, $pop32
; WASM32-NEXT:    local.get $push49=, 0
; WASM32-NEXT:    local.get $push48=, 5
; WASM32-NEXT:    i64.load $push1=, 32($pop48)
; WASM32-NEXT:    i64.store 0($pop49), $pop1
; WASM32-NEXT:    local.get $push53=, 0
; WASM32-NEXT:    local.get $push50=, 5
; WASM32-NEXT:    i64.load $push4=, 40($pop50)
; WASM32-NEXT:    local.get $push51=, 5
; WASM32-NEXT:    i64.load $push3=, 0($pop51)
; WASM32-NEXT:    local.get $push52=, 5
; WASM32-NEXT:    i64.load $push2=, 16($pop52)
; WASM32-NEXT:    i64.add $push31=, $pop3, $pop2
; WASM32-NEXT:    local.tee $push30=, 3, $pop31
; WASM32-NEXT:    i64.add $push29=, $pop4, $pop30
; WASM32-NEXT:    local.tee $push28=, 1, $pop29
; WASM32-NEXT:    i64.store 8($pop53), $pop28
; WASM32-NEXT:    local.get $push60=, 0
; WASM32-NEXT:    local.get $push54=, 2
; WASM32-NEXT:    i64.const $push27=, 0
; WASM32-NEXT:    i64.ne $push7=, $pop54, $pop27
; WASM32-NEXT:    local.get $push55=, 4
; WASM32-NEXT:    i64.const $push26=, 0
; WASM32-NEXT:    i64.ne $push6=, $pop55, $pop26
; WASM32-NEXT:    i32.and $push8=, $pop7, $pop6
; WASM32-NEXT:    local.get $push56=, 5
; WASM32-NEXT:    i64.load $push9=, 8($pop56)
; WASM32-NEXT:    i64.const $push25=, 0
; WASM32-NEXT:    i64.ne $push10=, $pop9, $pop25
; WASM32-NEXT:    i32.or $push11=, $pop8, $pop10
; WASM32-NEXT:    local.get $push57=, 5
; WASM32-NEXT:    i64.load $push12=, 24($pop57)
; WASM32-NEXT:    i64.const $push24=, 0
; WASM32-NEXT:    i64.ne $push13=, $pop12, $pop24
; WASM32-NEXT:    i32.or $push14=, $pop11, $pop13
; WASM32-NEXT:    local.get $push59=, 1
; WASM32-NEXT:    local.get $push58=, 3
; WASM32-NEXT:    i64.lt_u $push5=, $pop59, $pop58
; WASM32-NEXT:    i32.or $push15=, $pop14, $pop5
; WASM32-NEXT:    i32.store8 16($pop60), $pop15
; WASM32-NEXT:    local.get $push61=, 5
; WASM32-NEXT:    i32.const $push18=, 48
; WASM32-NEXT:    i32.add $push19=, $pop61, $pop18
; WASM32-NEXT:    global.set __stack_pointer, $pop19
; WASM32-NEXT:    # fallthrough-return

start:
  %0 = tail call { i128, i1 } @llvm.umul.with.overflow.i128(i128 %l, i128 %r) #2
  %1 = extractvalue { i128, i1 } %0, 0
  %2 = extractvalue { i128, i1 } %0, 1
  %3 = zext i1 %2 to i8
  %4 = insertvalue { i128, i8 } undef, i128 %1, 0
  %5 = insertvalue { i128, i8 } %4, i8 %3, 1
  ret { i128, i8 } %5
}

; Function Attrs: nounwind readnone speculatable
declare { i128, i1 } @llvm.umul.with.overflow.i128(i128, i128) #1

attributes #0 = { nounwind readnone uwtable }
attributes #1 = { nounwind readnone speculatable }
attributes #2 = { nounwind }
