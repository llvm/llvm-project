; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mattr=+reference-types,-gc | FileCheck --check-prefixes=CHECK,NOGC %s
; RUN: llc < %s -mattr=+reference-types,+gc | FileCheck --check-prefixes=CHECK,GC %s

; Test that calls through funcref lower to call_ref when GC is available

target triple = "wasm32-unknown-unknown"

%funcref = type ptr addrspace(20);

define void @call_ref_void(%funcref %callee) {
; CHECK-LABEL: call_ref_void:
; CHECK:         .functype call_ref_void (funcref) -> ()
; CHECK-NEXT:  # %bb.0:
; NOGC-NEXT:     i32.const 0
; CHECK-NEXT:    local.get 0
; NOGC-NEXT:     table.set __funcref_call_table
; NOGC-NEXT:     i32.const 0
; NOGC-NEXT:     call_indirect __funcref_call_table, () -> ()
; NOGC-NEXT:     i32.const 0
; NOGC-NEXT:     ref.null_func
; NOGC-NEXT:     table.set __funcref_call_table
; GC-NEXT:       ref.cast () -> ()
; GC-NEXT:       call_ref () -> ()
; CHECK-NEXT:    # fallthrough-return
  call addrspace(20) void %callee()
  ret void
}

define void @call_ref_with_args_and_ret(%funcref %callee) {
; CHECK-LABEL: call_ref_with_args_and_ret:
; CHECK:         .functype call_ref_with_args_and_ret (funcref) -> ()
; CHECK-NEXT:  # %bb.0:
; NOGC-NEXT:     i32.const 0
; NOGC-NEXT:     local.get 0
; NOGC-NEXT:     table.set __funcref_call_table
; CHECK-NEXT:    i32.const 1
; CHECK-NEXT:    f64.const 0x1p1
; NOGC-NEXT:     i32.const 0
; NOGC-NEXT:     call_indirect __funcref_call_table, (i32, f64) -> (i32)
; GC-NEXT:    local.get 0
; GC-NEXT:    ref.cast (i32, f64) -> (i32)
; GC-NEXT:    call_ref (i32, f64) -> (i32)
; CHECK-NEXT:    drop
; NOGC-NEXT:     i32.const 0
; NOGC-NEXT:     ref.null_func
; NOGC-NEXT:     table.set __funcref_call_table
; CHECK-NEXT:    # fallthrough-return
  %result = call addrspace(20) i32 %callee(i32 1, double 2.0)
  ret void
}
