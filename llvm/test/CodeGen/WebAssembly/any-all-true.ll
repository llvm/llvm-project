; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5

; RUN: llc < %s -verify-machineinstrs -mattr=+simd128 | FileCheck %s

target triple = "wasm32-unknown-unknown"

declare i8 @llvm.vector.reduce.and.v16i8(<16 x i8>)
declare i8 @llvm.vector.reduce.or.v16i8(<16 x i8>)
declare i16 @llvm.vector.reduce.and.v8i16(<8 x i16>)
declare i16 @llvm.vector.reduce.or.v8i16(<8 x i16>)
declare i32 @llvm.vector.reduce.and.v4i32(<4 x i32>)
declare i32 @llvm.vector.reduce.or.v4i32(<4 x i32>)
declare i64 @llvm.vector.reduce.and.v2i64(<2 x i64>)
declare i64 @llvm.vector.reduce.or.v2i64(<2 x i64>)

define zeroext i1 @manual_i8x16_all_true(<4 x i32> %a) {
; CHECK-LABEL: manual_i8x16_all_true:
; CHECK:         .functype manual_i8x16_all_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    i8x16.all_true
; CHECK-NEXT:    # fallthrough-return
start:
  %_3 = bitcast <4 x i32> %a to <16 x i8>
  %0 = tail call i8 @llvm.vector.reduce.and.v16i8(<16 x i8> %_3)
  %_0 = icmp eq i8 %0, -1
  ret i1 %_0
}

define zeroext i1 @manual_i16x8_all_true(<4 x i32> %a) {
; CHECK-LABEL: manual_i16x8_all_true:
; CHECK:         .functype manual_i16x8_all_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    i16x8.all_true
; CHECK-NEXT:    # fallthrough-return
start:
  %_3 = bitcast <4 x i32> %a to <8 x i16>
  %0 = tail call i16 @llvm.vector.reduce.and.v8i16(<8 x i16> %_3)
  %_0 = icmp eq i16 %0, -1
  ret i1 %_0
}

define zeroext i1 @manual_i32x4_all_true(<4 x i32> %a) {
; CHECK-LABEL: manual_i32x4_all_true:
; CHECK:         .functype manual_i32x4_all_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    i32x4.all_true
; CHECK-NEXT:    # fallthrough-return
start:
  %0 = tail call i32 @llvm.vector.reduce.and.v4i32(<4 x i32> %a)
  %_0 = icmp eq i32 %0, -1
  ret i1 %_0
}

define zeroext i1 @manual_i64x2_all_true(<2 x i64> %a) {
; CHECK-LABEL: manual_i64x2_all_true:
; CHECK:         .functype manual_i64x2_all_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    i64x2.all_true
; CHECK-NEXT:    # fallthrough-return
start:
  %0 = tail call i64 @llvm.vector.reduce.and.v2i64(<2 x i64> %a)
  %_0 = icmp eq i64 %0, -1
  ret i1 %_0
}

; ---

define zeroext i1 @manual_i8x16_any_true(<4 x i32> %a) {
; CHECK-LABEL: manual_i8x16_any_true:
; CHECK:         .functype manual_i8x16_any_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    v128.any_true
; CHECK-NEXT:    # fallthrough-return
start:
  %_3 = bitcast <4 x i32> %a to <16 x i8>
  %0 = tail call i8 @llvm.vector.reduce.or.v16x8(<16 x i8> %_3)
  %_0 = icmp ne i8 %0, 0
  ret i1 %_0
}

define i1 @i16x8_any_true(<4 x i32> %a) {
; CHECK-LABEL: i16x8_any_true:
; CHECK:         .functype i16x8_any_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    v128.any_true
; CHECK-NEXT:    # fallthrough-return
start:
  %_3 = bitcast <4 x i32> %a to <8 x i16>
  %0 = tail call i16 @llvm.vector.reduce.or.v8i16(<8 x i16> %_3)
  %_0 = icmp ne i16 %0, 0
  ret i1 %_0
}

define i1 @manual_i32x4_any_true(<4 x i32> %a) {
; CHECK-LABEL: manual_i32x4_any_true:
; CHECK:         .functype manual_i32x4_any_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    v128.any_true
; CHECK-NEXT:    # fallthrough-return
start:
  %0 = tail call i32 @llvm.vector.reduce.or.v4i32(<4 x i32> %a)
  %_0 = icmp ne i32 %0, 0
  ret i1 %_0
}


define zeroext i1 @manual_i64x2_any_true(<2 x i64> %a) {
; CHECK-LABEL: manual_i64x2_any_true:
; CHECK:         .functype manual_i64x2_any_true (v128) -> (i32)
; CHECK-NEXT:  # %bb.0: # %start
; CHECK-NEXT:    local.get 0
; CHECK-NEXT:    v128.any_true
; CHECK-NEXT:    # fallthrough-return
start:
  %0 = tail call i64 @llvm.vector.reduce.or.v2i64(<2 x i64> %a)
  %_0 = icmp ne i64 %0, 0
  ret i1 %_0
}
