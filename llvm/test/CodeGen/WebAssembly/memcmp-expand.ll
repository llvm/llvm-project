; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s  -O3 -verify-machineinstrs -disable-wasm-fallthrough-return-opt -wasm-disable-explicit-locals -wasm-keep-registers | FileCheck %s

target triple = "wasm32-unknown-unknown"

declare i32 @memcmp(ptr, ptr, i32)

define i1 @memcmp_expand_3(ptr %a, ptr %b) {
; CHECK-LABEL: memcmp_expand_3:
; CHECK:         .functype memcmp_expand_3 (i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 3
; CHECK-NEXT:    call $push1=, memcmp, $0, $1, $pop0
; CHECK-NEXT:    i32.eqz $push2=, $pop1
; CHECK-NEXT:    return $pop2
  %cmp_3 = call i32 @memcmp(ptr %a, ptr %b, i32 3)
  %res = icmp eq i32 %cmp_3, 0
  ret i1 %res
}

define i1 @memcmp_expand_5(ptr %a, ptr %b) {
; CHECK-LABEL: memcmp_expand_5:
; CHECK:         .functype memcmp_expand_5 (i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 5
; CHECK-NEXT:    call $push1=, memcmp, $0, $1, $pop0
; CHECK-NEXT:    i32.eqz $push2=, $pop1
; CHECK-NEXT:    return $pop2
  %cmp_5 = call i32 @memcmp(ptr %a, ptr %b, i32 5)
  %res = icmp eq i32 %cmp_5, 0
  ret i1 %res
}

define i1 @memcmp_expand_7(ptr %a, ptr %b) {
; CHECK-LABEL: memcmp_expand_7:
; CHECK:         .functype memcmp_expand_7 (i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 7
; CHECK-NEXT:    call $push1=, memcmp, $0, $1, $pop0
; CHECK-NEXT:    i32.eqz $push2=, $pop1
; CHECK-NEXT:    return $pop2
  %cmp_7 = call i32 @memcmp(ptr %a, ptr %b, i32 7)
  %res = icmp eq i32 %cmp_7, 0
  ret i1 %res
}

define i1 @memcmp_expand_2(ptr %a, ptr %b) {
; CHECK-LABEL: memcmp_expand_2:
; CHECK:         .functype memcmp_expand_2 (i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.load16_u $push1=, 0($0):p2align=0
; CHECK-NEXT:    i32.load16_u $push0=, 0($1):p2align=0
; CHECK-NEXT:    i32.eq $push2=, $pop1, $pop0
; CHECK-NEXT:    return $pop2
  %cmp_2 = call i32 @memcmp(ptr %a, ptr %b, i32 2)
  %res = icmp eq i32 %cmp_2, 0
  ret i1 %res
}


define i1 @memcmp_expand_8(ptr %a, ptr %b) {
; CHECK-LABEL: memcmp_expand_8:
; CHECK:         .functype memcmp_expand_8 (i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i64.load $push1=, 0($0):p2align=0
; CHECK-NEXT:    i64.load $push0=, 0($1):p2align=0
; CHECK-NEXT:    i64.eq $push2=, $pop1, $pop0
; CHECK-NEXT:    return $pop2
  %cmp_8 = call i32 @memcmp(ptr %a, ptr %b, i32 8)
  %res = icmp eq i32 %cmp_8, 0
  ret i1 %res
}


define i1 @memcmp_expand_16(ptr %a, ptr %b) {
; CHECK-LABEL: memcmp_expand_16:
; CHECK:         .functype memcmp_expand_16 (i32, i32) -> (i32)
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    i32.const $push0=, 16
; CHECK-NEXT:    call $push1=, memcmp, $0, $1, $pop0
; CHECK-NEXT:    i32.eqz $push2=, $pop1
; CHECK-NEXT:    return $pop2
  %cmp_16 = call i32 @memcmp(ptr %a, ptr %b, i32 16)
  %res = icmp eq i32 %cmp_16, 0
  ret i1 %res
}




