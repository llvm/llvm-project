; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=wasm32 -disable-wasm-fallthrough-return-opt -wasm-keep-registers < %s | FileCheck %s

; test expandFMINNUM_FMAXNUM on backend with FMINIMUM/FMAXIMUM.
; N -> not NaN
; S -> not SNaN
; Y -> may be NaN or SNaN

define double @test_maxnumNN(double nofpclass(nan) %f1, double nofpclass(nan) %f2) {
; CHECK-LABEL: test_maxnumNN:
; CHECK:         .functype test_maxnumNN (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    f64.max $push0=, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumSS(double nofpclass(snan) %f1, double nofpclass(snan) %f2) {
; CHECK-LABEL: test_maxnumSS:
; CHECK:         .functype test_maxnumSS (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumYY(double nofpclass(zero) %f1, double nofpclass(zero) %f2) {
; CHECK-LABEL: test_maxnumYY:
; CHECK:         .functype test_maxnumYY (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumNS(double nofpclass(nan) %f1, double nofpclass(snan) %f2) {
; CHECK-LABEL: test_maxnumNS:
; CHECK:         .functype test_maxnumNS (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumNY(double nofpclass(nan) %f1, double nofpclass(zero) %f2) {
; CHECK-LABEL: test_maxnumNY:
; CHECK:         .functype test_maxnumNY (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumSN(double nofpclass(snan) %f1, double nofpclass(nan) %f2) {
; CHECK-LABEL: test_maxnumSN:
; CHECK:         .functype test_maxnumSN (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumSY(double nofpclass(snan) %f1, double nofpclass(zero) %f2) {
; CHECK-LABEL: test_maxnumSY:
; CHECK:         .functype test_maxnumSY (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumYN(double nofpclass(zero) %f1, double nofpclass(nan) %f2) {
; CHECK-LABEL: test_maxnumYN:
; CHECK:         .functype test_maxnumYN (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_maxnumYS(double nofpclass(zero) %f1, double nofpclass(snan) %f2) {
; CHECK-LABEL: test_maxnumYS:
; CHECK:         .functype test_maxnumYS (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmax, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.maxnum.f64(double %f1, double %f2)
  ret double %0
}


define double @test_minnumNN(double nofpclass(nan) %f1, double nofpclass(nan) %f2) {
; CHECK-LABEL: test_minnumNN:
; CHECK:         .functype test_minnumNN (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    f64.min $push0=, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumSS(double nofpclass(snan) %f1, double nofpclass(snan) %f2) {
; CHECK-LABEL: test_minnumSS:
; CHECK:         .functype test_minnumSS (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumYY(double nofpclass(zero) %f1, double nofpclass(zero) %f2) {
; CHECK-LABEL: test_minnumYY:
; CHECK:         .functype test_minnumYY (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumNS(double nofpclass(nan) %f1, double nofpclass(snan) %f2) {
; CHECK-LABEL: test_minnumNS:
; CHECK:         .functype test_minnumNS (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumNY(double nofpclass(nan) %f1, double nofpclass(zero) %f2) {
; CHECK-LABEL: test_minnumNY:
; CHECK:         .functype test_minnumNY (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumSN(double nofpclass(snan) %f1, double nofpclass(nan) %f2) {
; CHECK-LABEL: test_minnumSN:
; CHECK:         .functype test_minnumSN (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumSY(double nofpclass(snan) %f1, double nofpclass(zero) %f2) {
; CHECK-LABEL: test_minnumSY:
; CHECK:         .functype test_minnumSY (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumYN(double nofpclass(zero) %f1, double nofpclass(nan) %f2) {
; CHECK-LABEL: test_minnumYN:
; CHECK:         .functype test_minnumYN (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

define double @test_minnumYS(double nofpclass(zero) %f1, double nofpclass(snan) %f2) {
; CHECK-LABEL: test_minnumYS:
; CHECK:         .functype test_minnumYS (f64, f64) -> (f64)
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    local.get $push2=, 0
; CHECK-NEXT:    local.get $push1=, 1
; CHECK-NEXT:    call $push0=, fmin, $pop2, $pop1
; CHECK-NEXT:    return $pop0
entry:
  %0 = tail call double @llvm.minnum.f64(double %f1, double %f2)
  ret double %0
}

