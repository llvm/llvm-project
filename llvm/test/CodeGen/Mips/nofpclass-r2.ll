; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc --mtriple=mips-linux-gnu < %s | FileCheck %s --check-prefix=MIPS32R2

define float @min(float nofpclass(nan zero) %a, float nofpclass(nan zero) %b) {
; MIPS32R2-LABEL: min:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    c.olt.s $f12, $f14
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movt.s $f0, $f12, $fcc0
entry:
  %0 = tail call float @llvm.minimum.f32(float %a, float %b)
  ret float %0
}

define float @minN(float nofpclass(nan nzero) %a, float nofpclass(nan nzero) %b) {
; MIPS32R2-LABEL: minN:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    c.olt.s $f12, $f14
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movt.s $f0, $f12, $fcc0
entry:
  %0 = tail call float @llvm.minimum.f32(float %a, float %b)
  ret float %0
}

define float @minP(float nofpclass(nan pzero) %a, float nofpclass(nan pzero) %b) {
; MIPS32R2-LABEL: minP:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    c.olt.s $f12, $f14
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movt.s $f0, $f12, $fcc0
entry:
  %0 = tail call float @llvm.minimum.f32(float %a, float %b)
  ret float %0
}

define float @minNP(float nofpclass(nan nzero) %a, float nofpclass(nan pzero) %b) {
; MIPS32R2-LABEL: minNP:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    c.olt.s $f12, $f14
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    movt.s $f0, $f12, $fcc0
; MIPS32R2-NEXT:    mfc1 $1, $f12
; MIPS32R2-NEXT:    lui $2, 32768
; MIPS32R2-NEXT:    xor $1, $1, $2
; MIPS32R2-NEXT:    mov.s $f1, $f0
; MIPS32R2-NEXT:    movz.s $f1, $f12, $1
; MIPS32R2-NEXT:    mfc1 $1, $f14
; MIPS32R2-NEXT:    xor $1, $1, $2
; MIPS32R2-NEXT:    movz.s $f1, $f14, $1
; MIPS32R2-NEXT:    mtc1 $zero, $f2
; MIPS32R2-NEXT:    c.eq.s $f0, $f2
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movt.s $f0, $f1, $fcc0
entry:
  %0 = tail call float @llvm.minimum.f32(float %a, float %b)
  ret float %0
}

define float @max(float nofpclass(nan zero) %a, float nofpclass(nan zero) %b) {
; MIPS32R2-LABEL: max:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    c.ule.s $f12, $f14
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movf.s $f0, $f12, $fcc0
entry:
  %0 = tail call float @llvm.maximum.f32(float %a, float %b)
  ret float %0
}

define float @maxN(float nofpclass(nan nzero) %a, float nofpclass(nan nzero) %b) {
; MIPS32R2-LABEL: maxN:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    c.ule.s $f12, $f14
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movf.s $f0, $f12, $fcc0
entry:
  %0 = tail call float @llvm.maximum.f32(float %a, float %b)
  ret float %0
}

define float @maxP(float nofpclass(nan pzero) %a, float nofpclass(nan pzero) %b) {
; MIPS32R2-LABEL: maxP:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    c.ule.s $f12, $f14
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movf.s $f0, $f12, $fcc0
entry:
  %0 = tail call float @llvm.maximum.f32(float %a, float %b)
  ret float %0
}

define float @maxNP(float nofpclass(nan nzero) %a, float nofpclass(nan pzero) %b) {
; MIPS32R2-LABEL: maxNP:
; MIPS32R2:       # %bb.0: # %entry
; MIPS32R2-NEXT:    c.ule.s $f12, $f14
; MIPS32R2-NEXT:    mov.s $f0, $f14
; MIPS32R2-NEXT:    movf.s $f0, $f12, $fcc0
; MIPS32R2-NEXT:    mfc1 $1, $f12
; MIPS32R2-NEXT:    mov.s $f1, $f0
; MIPS32R2-NEXT:    movz.s $f1, $f12, $1
; MIPS32R2-NEXT:    mfc1 $1, $f14
; MIPS32R2-NEXT:    movz.s $f1, $f14, $1
; MIPS32R2-NEXT:    mtc1 $zero, $f2
; MIPS32R2-NEXT:    c.eq.s $f0, $f2
; MIPS32R2-NEXT:    jr $ra
; MIPS32R2-NEXT:    movt.s $f0, $f1, $fcc0
entry:
  %0 = tail call float @llvm.maximum.f32(float %a, float %b)
  ret float %0
}
