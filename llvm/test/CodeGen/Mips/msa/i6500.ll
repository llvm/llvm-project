; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; Test the MSA intrinsics that are encoded with the SPECIAL instruction format.

; RUN: llc -mtriple=mips-elf -mcpu=i6500 < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS32
; RUN: llc -mtriple=mips-elf -mcpu=i6500 -mattr=-msa < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS32-NO-LSA

; RUN: llc -mtriple=mips64-elf -mcpu=i6500 < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS64
; RUN: llc -mtriple=mips64-elf -mcpu=i6500 -mattr=-msa < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS64-NO-DLSA

; RUN: llc -mtriple=mips-elf -mcpu=i6400 < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS32
; RUN: llc -mtriple=mips-elf -mcpu=i6400 -mattr=-msa < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS32-NO-LSA

; RUN: llc -mtriple=mips64-elf -mcpu=i6400 < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS64
; RUN: llc -mtriple=mips64-elf -mcpu=i6400 -mattr=-msa < %s | \
; RUN:   FileCheck %s --check-prefix=MIPS64-NO-DLSA

define i32 @llvm_mips_lsa_test(i32 %a, i32 %b) nounwind {
; MIPS32-LABEL: llvm_mips_lsa_test:
; MIPS32:       # %bb.0: # %entry
; MIPS32-NEXT:    jr $ra
; MIPS32-NEXT:    lsa $2, $5, $4, 2
;
; MIPS32-NO-LSA-LABEL: llvm_mips_lsa_test:
; MIPS32-NO-LSA:       # %bb.0: # %entry
; MIPS32-NO-LSA-NEXT:    sll $1, $5, 2
; MIPS32-NO-LSA-NEXT:    jr $ra
; MIPS32-NO-LSA-NEXT:    addu $2, $4, $1
;
; MIPS64-LABEL: llvm_mips_lsa_test:
; MIPS64:       # %bb.0: # %entry
; MIPS64-NEXT:    sll $1, $4, 0
; MIPS64-NEXT:    sll $2, $5, 0
; MIPS64-NEXT:    jr $ra
; MIPS64-NEXT:    lsa $2, $2, $1, 2
;
; MIPS64-NO-DLSA-LABEL: llvm_mips_lsa_test:
; MIPS64-NO-DLSA:       # %bb.0: # %entry
; MIPS64-NO-DLSA-NEXT:    sll $1, $4, 0
; MIPS64-NO-DLSA-NEXT:    sll $2, $5, 0
; MIPS64-NO-DLSA-NEXT:    sll $2, $2, 2
; MIPS64-NO-DLSA-NEXT:    jr $ra
; MIPS64-NO-DLSA-NEXT:    addu $2, $1, $2
entry:
  %0 = tail call i32 @llvm.mips.lsa(i32 %a, i32 %b, i32 2)
  ret i32 %0
}
declare i32 @llvm.mips.lsa(i32, i32, i32) nounwind

define i64 @llvm_mips_dlsa_test(i64 %a, i64 %b) nounwind {
; MIPS32-LABEL: llvm_mips_dlsa_test:
; MIPS32:       # %bb.0: # %entry
; MIPS32-NEXT:    dmfc1 $1, $f14
; MIPS32-NEXT:    dmfc1 $2, $f12
; MIPS32-NEXT:    dlsa $1, $1, $2, 2
; MIPS32-NEXT:    jr $ra
; MIPS32-NEXT:    sd $1, 0($4)
;
; MIPS32-NO-LSA-LABEL: llvm_mips_dlsa_test:
; MIPS32-NO-LSA:       # %bb.0: # %entry
; MIPS32-NO-LSA-NEXT:    dmfc1 $1, $f14
; MIPS32-NO-LSA-NEXT:    dmfc1 $2, $f12
; MIPS32-NO-LSA-NEXT:    dsll $1, $1, 2
; MIPS32-NO-LSA-NEXT:    daddu $1, $2, $1
; MIPS32-NO-LSA-NEXT:    jr $ra
; MIPS32-NO-LSA-NEXT:    sd $1, 0($4)
;
; MIPS64-LABEL: llvm_mips_dlsa_test:
; MIPS64:       # %bb.0: # %entry
; MIPS64-NEXT:    jr $ra
; MIPS64-NEXT:    dlsa $2, $5, $4, 2
;
; MIPS64-NO-DLSA-LABEL: llvm_mips_dlsa_test:
; MIPS64-NO-DLSA:       # %bb.0: # %entry
; MIPS64-NO-DLSA-NEXT:    dsll $1, $5, 2
; MIPS64-NO-DLSA-NEXT:    jr $ra
; MIPS64-NO-DLSA-NEXT:    daddu $2, $4, $1
entry:
  %0 = tail call i64 @llvm.mips.dlsa(i64 %a, i64 %b, i32 2)
  ret i64 %0
}
declare i64 @llvm.mips.dlsa(i64, i64, i32) nounwind
