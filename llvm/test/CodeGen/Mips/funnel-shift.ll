; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=mips-linux-gnu -mcpu=mips32 | FileCheck %s --check-prefixes=CHECK,CHECK-BE
; RUN: llc < %s -mtriple=mipsel-linux-gnu -mcpu=mips32 | FileCheck %s --check-prefixes=CHECK,CHECK-LE

declare i8 @llvm.fshl.i8(i8, i8, i8)
declare i16 @llvm.fshl.i16(i16, i16, i16)
declare i32 @llvm.fshl.i32(i32, i32, i32)
declare i64 @llvm.fshl.i64(i64, i64, i64)
declare <4 x i32> @llvm.fshl.v4i32(<4 x i32>, <4 x i32>, <4 x i32>)

declare i8 @llvm.fshr.i8(i8, i8, i8)
declare i16 @llvm.fshr.i16(i16, i16, i16)
declare i32 @llvm.fshr.i32(i32, i32, i32)
declare i64 @llvm.fshr.i64(i64, i64, i64)
declare <4 x i32> @llvm.fshr.v4i32(<4 x i32>, <4 x i32>, <4 x i32>)

; General case - all operands can be variables.

define i16 @fshl_i16(i16 %x, i16 %y, i16 %z) {
; CHECK-LABEL: fshl_i16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andi $1, $5, 65535
; CHECK-NEXT:    sll $2, $4, 16
; CHECK-NEXT:    or $1, $2, $1
; CHECK-NEXT:    andi $2, $6, 15
; CHECK-NEXT:    sllv $1, $1, $2
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    srl $2, $1, 16
  %f = call i16 @llvm.fshl.i16(i16 %x, i16 %y, i16 %z)
  ret i16 %f
}

define i32 @fshl_i32(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: fshl_i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllv $1, $4, $6
; CHECK-NEXT:    not $2, $6
; CHECK-NEXT:    srl $3, $5, 1
; CHECK-NEXT:    srlv $2, $3, $2
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    or $2, $1, $2
  %f = call i32 @llvm.fshl.i32(i32 %x, i32 %y, i32 %z)
  ret i32 %f
}

; Verify that weird types are minimally supported.
declare i37 @llvm.fshl.i37(i37, i37, i37)
define i37 @fshl_i37(i37 %x, i37 %y, i37 %z) {
; CHECK-BE-LABEL: fshl_i37:
; CHECK-BE:       # %bb.0:
; CHECK-BE-NEXT:    lui $1, 1771
; CHECK-BE-NEXT:    ori $1, $1, 15941
; CHECK-BE-NEXT:    lw $2, 20($sp)
; CHECK-BE-NEXT:    multu $2, $1
; CHECK-BE-NEXT:    mfhi $3
; CHECK-BE-NEXT:    mflo $8
; CHECK-BE-NEXT:    lui $9, 12398
; CHECK-BE-NEXT:    ori $9, $9, 46053
; CHECK-BE-NEXT:    multu $2, $9
; CHECK-BE-NEXT:    mfhi $10
; CHECK-BE-NEXT:    lw $11, 16($sp)
; CHECK-BE-NEXT:    andi $11, $11, 31
; CHECK-BE-NEXT:    multu $11, $9
; CHECK-BE-NEXT:    mflo $9
; CHECK-BE-NEXT:    mfhi $12
; CHECK-BE-NEXT:    addu $8, $10, $8
; CHECK-BE-NEXT:    sltu $10, $8, $10
; CHECK-BE-NEXT:    addu $9, $8, $9
; CHECK-BE-NEXT:    sltu $8, $9, $8
; CHECK-BE-NEXT:    addu $3, $3, $10
; CHECK-BE-NEXT:    srl $9, $7, 5
; CHECK-BE-NEXT:    sll $6, $6, 27
; CHECK-BE-NEXT:    or $6, $6, $9
; CHECK-BE-NEXT:    addu $3, $3, $12
; CHECK-BE-NEXT:    sll $7, $7, 27
; CHECK-BE-NEXT:    addu $3, $3, $8
; CHECK-BE-NEXT:    mul $1, $11, $1
; CHECK-BE-NEXT:    addu $1, $3, $1
; CHECK-BE-NEXT:    sll $3, $1, 2
; CHECK-BE-NEXT:    addu $3, $3, $1
; CHECK-BE-NEXT:    sll $1, $1, 5
; CHECK-BE-NEXT:    addu $1, $1, $3
; CHECK-BE-NEXT:    subu $1, $2, $1
; CHECK-BE-NEXT:    andi $2, $1, 32
; CHECK-BE-NEXT:    srl $3, $2, 5
; CHECK-BE-NEXT:    movn $4, $5, $3
; CHECK-BE-NEXT:    sllv $2, $4, $1
; CHECK-BE-NEXT:    not $4, $1
; CHECK-BE-NEXT:    movn $5, $6, $3
; CHECK-BE-NEXT:    srl $8, $5, 1
; CHECK-BE-NEXT:    srlv $8, $8, $4
; CHECK-BE-NEXT:    or $2, $2, $8
; CHECK-BE-NEXT:    sllv $1, $5, $1
; CHECK-BE-NEXT:    movn $6, $7, $3
; CHECK-BE-NEXT:    srl $3, $6, 1
; CHECK-BE-NEXT:    srlv $3, $3, $4
; CHECK-BE-NEXT:    jr $ra
; CHECK-BE-NEXT:    or $3, $1, $3
;
; CHECK-LE-LABEL: fshl_i37:
; CHECK-LE:       # %bb.0:
; CHECK-LE-NEXT:    lui $1, 1771
; CHECK-LE-NEXT:    ori $1, $1, 15941
; CHECK-LE-NEXT:    lw $2, 16($sp)
; CHECK-LE-NEXT:    multu $2, $1
; CHECK-LE-NEXT:    mfhi $3
; CHECK-LE-NEXT:    mflo $8
; CHECK-LE-NEXT:    lui $9, 12398
; CHECK-LE-NEXT:    ori $9, $9, 46053
; CHECK-LE-NEXT:    multu $2, $9
; CHECK-LE-NEXT:    mfhi $10
; CHECK-LE-NEXT:    lw $11, 20($sp)
; CHECK-LE-NEXT:    andi $11, $11, 31
; CHECK-LE-NEXT:    multu $11, $9
; CHECK-LE-NEXT:    mflo $9
; CHECK-LE-NEXT:    mfhi $12
; CHECK-LE-NEXT:    addu $8, $10, $8
; CHECK-LE-NEXT:    sltu $10, $8, $10
; CHECK-LE-NEXT:    addu $9, $8, $9
; CHECK-LE-NEXT:    sltu $8, $9, $8
; CHECK-LE-NEXT:    addu $3, $3, $10
; CHECK-LE-NEXT:    srl $9, $6, 5
; CHECK-LE-NEXT:    sll $7, $7, 27
; CHECK-LE-NEXT:    or $7, $7, $9
; CHECK-LE-NEXT:    sll $6, $6, 27
; CHECK-LE-NEXT:    addu $3, $3, $12
; CHECK-LE-NEXT:    addu $3, $3, $8
; CHECK-LE-NEXT:    mul $1, $11, $1
; CHECK-LE-NEXT:    addu $1, $3, $1
; CHECK-LE-NEXT:    sll $3, $1, 2
; CHECK-LE-NEXT:    addu $3, $3, $1
; CHECK-LE-NEXT:    sll $1, $1, 5
; CHECK-LE-NEXT:    addu $1, $1, $3
; CHECK-LE-NEXT:    subu $1, $2, $1
; CHECK-LE-NEXT:    andi $2, $1, 32
; CHECK-LE-NEXT:    srl $3, $2, 5
; CHECK-LE-NEXT:    move $8, $4
; CHECK-LE-NEXT:    movn $8, $7, $3
; CHECK-LE-NEXT:    sllv $2, $8, $1
; CHECK-LE-NEXT:    not $9, $1
; CHECK-LE-NEXT:    movn $7, $6, $3
; CHECK-LE-NEXT:    srl $6, $7, 1
; CHECK-LE-NEXT:    srlv $6, $6, $9
; CHECK-LE-NEXT:    or $2, $2, $6
; CHECK-LE-NEXT:    movn $5, $4, $3
; CHECK-LE-NEXT:    sllv $1, $5, $1
; CHECK-LE-NEXT:    srl $3, $8, 1
; CHECK-LE-NEXT:    srlv $3, $3, $9
; CHECK-LE-NEXT:    jr $ra
; CHECK-LE-NEXT:    or $3, $1, $3
  %f = call i37 @llvm.fshl.i37(i37 %x, i37 %y, i37 %z)
  ret i37 %f
}

; extract(concat(0b1110000, 0b1111111) << 2) = 0b1000011

declare i7 @llvm.fshl.i7(i7, i7, i7)
define i7 @fshl_i7_const_fold() {
; CHECK-LABEL: fshl_i7_const_fold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 67
  %f = call i7 @llvm.fshl.i7(i7 112, i7 127, i7 2)
  ret i7 %f
}

define i8 @fshl_i8_const_fold_overshift_1() {
; CHECK-LABEL: fshl_i8_const_fold_overshift_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 128
  %f = call i8 @llvm.fshl.i8(i8 255, i8 0, i8 15)
  ret i8 %f
}

define i8 @fshl_i8_const_fold_overshift_2() {
; CHECK-LABEL: fshl_i8_const_fold_overshift_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 120
  %f = call i8 @llvm.fshl.i8(i8 15, i8 15, i8 11)
  ret i8 %f
}

define i8 @fshl_i8_const_fold_overshift_3() {
; CHECK-LABEL: fshl_i8_const_fold_overshift_3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 0
  %f = call i8 @llvm.fshl.i8(i8 0, i8 225, i8 8)
  ret i8 %f
}

; With constant shift amount, this is 'extr'.

define i32 @fshl_i32_const_shift(i32 %x, i32 %y) {
; CHECK-LABEL: fshl_i32_const_shift:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srl $1, $5, 23
; CHECK-NEXT:    sll $2, $4, 9
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    or $2, $2, $1
  %f = call i32 @llvm.fshl.i32(i32 %x, i32 %y, i32 9)
  ret i32 %f
}

; Check modulo math on shift amount.

define i32 @fshl_i32_const_overshift(i32 %x, i32 %y) {
; CHECK-LABEL: fshl_i32_const_overshift:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srl $1, $5, 23
; CHECK-NEXT:    sll $2, $4, 9
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    or $2, $2, $1
  %f = call i32 @llvm.fshl.i32(i32 %x, i32 %y, i32 41)
  ret i32 %f
}

; 64-bit should also work.

define i64 @fshl_i64_const_overshift(i64 %x, i64 %y) {
; CHECK-BE-LABEL: fshl_i64_const_overshift:
; CHECK-BE:       # %bb.0:
; CHECK-BE-NEXT:    srl $1, $6, 23
; CHECK-BE-NEXT:    sll $2, $5, 9
; CHECK-BE-NEXT:    or $2, $2, $1
; CHECK-BE-NEXT:    srl $1, $7, 23
; CHECK-BE-NEXT:    sll $3, $6, 9
; CHECK-BE-NEXT:    jr $ra
; CHECK-BE-NEXT:    or $3, $3, $1
;
; CHECK-LE-LABEL: fshl_i64_const_overshift:
; CHECK-LE:       # %bb.0:
; CHECK-LE-NEXT:    srl $1, $6, 23
; CHECK-LE-NEXT:    sll $2, $7, 9
; CHECK-LE-NEXT:    or $2, $2, $1
; CHECK-LE-NEXT:    srl $1, $7, 23
; CHECK-LE-NEXT:    sll $3, $4, 9
; CHECK-LE-NEXT:    jr $ra
; CHECK-LE-NEXT:    or $3, $3, $1
  %f = call i64 @llvm.fshl.i64(i64 %x, i64 %y, i64 105)
  ret i64 %f
}

; This should work without any node-specific logic.

define i8 @fshl_i8_const_fold() {
; CHECK-LABEL: fshl_i8_const_fold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 128
  %f = call i8 @llvm.fshl.i8(i8 255, i8 0, i8 7)
  ret i8 %f
}

; Repeat everything for funnel shift right.

; General case - all operands can be variables.

define i16 @fshr_i16(i16 %x, i16 %y, i16 %z) {
; CHECK-LABEL: fshr_i16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andi $1, $5, 65535
; CHECK-NEXT:    sll $2, $4, 16
; CHECK-NEXT:    or $1, $2, $1
; CHECK-NEXT:    andi $2, $6, 15
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    srlv $2, $1, $2
  %f = call i16 @llvm.fshr.i16(i16 %x, i16 %y, i16 %z)
  ret i16 %f
}

define i32 @fshr_i32(i32 %x, i32 %y, i32 %z) {
; CHECK-LABEL: fshr_i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlv $1, $5, $6
; CHECK-NEXT:    not $2, $6
; CHECK-NEXT:    sll $3, $4, 1
; CHECK-NEXT:    sllv $2, $3, $2
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    or $2, $2, $1
  %f = call i32 @llvm.fshr.i32(i32 %x, i32 %y, i32 %z)
  ret i32 %f
}

; Verify that weird types are minimally supported.
declare i37 @llvm.fshr.i37(i37, i37, i37)
define i37 @fshr_i37(i37 %x, i37 %y, i37 %z) {
; CHECK-BE-LABEL: fshr_i37:
; CHECK-BE:       # %bb.0:
; CHECK-BE-NEXT:    lui $1, 1771
; CHECK-BE-NEXT:    ori $1, $1, 15941
; CHECK-BE-NEXT:    lw $2, 20($sp)
; CHECK-BE-NEXT:    multu $2, $1
; CHECK-BE-NEXT:    mfhi $3
; CHECK-BE-NEXT:    mflo $8
; CHECK-BE-NEXT:    lui $9, 12398
; CHECK-BE-NEXT:    ori $9, $9, 46053
; CHECK-BE-NEXT:    multu $2, $9
; CHECK-BE-NEXT:    mfhi $10
; CHECK-BE-NEXT:    lw $11, 16($sp)
; CHECK-BE-NEXT:    andi $11, $11, 31
; CHECK-BE-NEXT:    multu $11, $9
; CHECK-BE-NEXT:    mflo $9
; CHECK-BE-NEXT:    mfhi $12
; CHECK-BE-NEXT:    addu $8, $10, $8
; CHECK-BE-NEXT:    sltu $10, $8, $10
; CHECK-BE-NEXT:    addu $9, $8, $9
; CHECK-BE-NEXT:    sltu $8, $9, $8
; CHECK-BE-NEXT:    addu $3, $3, $10
; CHECK-BE-NEXT:    srl $9, $7, 5
; CHECK-BE-NEXT:    sll $6, $6, 27
; CHECK-BE-NEXT:    or $6, $6, $9
; CHECK-BE-NEXT:    sll $7, $7, 27
; CHECK-BE-NEXT:    addu $3, $3, $12
; CHECK-BE-NEXT:    addu $3, $3, $8
; CHECK-BE-NEXT:    mul $1, $11, $1
; CHECK-BE-NEXT:    addu $1, $3, $1
; CHECK-BE-NEXT:    sll $3, $1, 2
; CHECK-BE-NEXT:    addu $3, $3, $1
; CHECK-BE-NEXT:    sll $1, $1, 5
; CHECK-BE-NEXT:    addu $1, $1, $3
; CHECK-BE-NEXT:    subu $1, $2, $1
; CHECK-BE-NEXT:    addiu $1, $1, 27
; CHECK-BE-NEXT:    andi $3, $1, 32
; CHECK-BE-NEXT:    movz $4, $5, $3
; CHECK-BE-NEXT:    movz $5, $6, $3
; CHECK-BE-NEXT:    srlv $2, $5, $1
; CHECK-BE-NEXT:    not $8, $1
; CHECK-BE-NEXT:    sll $4, $4, 1
; CHECK-BE-NEXT:    sllv $4, $4, $8
; CHECK-BE-NEXT:    or $2, $4, $2
; CHECK-BE-NEXT:    movz $6, $7, $3
; CHECK-BE-NEXT:    srlv $1, $6, $1
; CHECK-BE-NEXT:    sll $3, $5, 1
; CHECK-BE-NEXT:    sllv $3, $3, $8
; CHECK-BE-NEXT:    jr $ra
; CHECK-BE-NEXT:    or $3, $3, $1
;
; CHECK-LE-LABEL: fshr_i37:
; CHECK-LE:       # %bb.0:
; CHECK-LE-NEXT:    lui $1, 1771
; CHECK-LE-NEXT:    ori $1, $1, 15941
; CHECK-LE-NEXT:    lw $2, 16($sp)
; CHECK-LE-NEXT:    multu $2, $1
; CHECK-LE-NEXT:    mfhi $3
; CHECK-LE-NEXT:    mflo $8
; CHECK-LE-NEXT:    lui $9, 12398
; CHECK-LE-NEXT:    ori $9, $9, 46053
; CHECK-LE-NEXT:    multu $2, $9
; CHECK-LE-NEXT:    mfhi $10
; CHECK-LE-NEXT:    lw $11, 20($sp)
; CHECK-LE-NEXT:    andi $11, $11, 31
; CHECK-LE-NEXT:    multu $11, $9
; CHECK-LE-NEXT:    mflo $9
; CHECK-LE-NEXT:    mfhi $12
; CHECK-LE-NEXT:    addu $8, $10, $8
; CHECK-LE-NEXT:    sltu $10, $8, $10
; CHECK-LE-NEXT:    addu $9, $8, $9
; CHECK-LE-NEXT:    sltu $8, $9, $8
; CHECK-LE-NEXT:    addu $3, $3, $10
; CHECK-LE-NEXT:    srl $9, $6, 5
; CHECK-LE-NEXT:    sll $7, $7, 27
; CHECK-LE-NEXT:    or $7, $7, $9
; CHECK-LE-NEXT:    sll $6, $6, 27
; CHECK-LE-NEXT:    addu $3, $3, $12
; CHECK-LE-NEXT:    addu $3, $3, $8
; CHECK-LE-NEXT:    mul $1, $11, $1
; CHECK-LE-NEXT:    addu $1, $3, $1
; CHECK-LE-NEXT:    sll $3, $1, 2
; CHECK-LE-NEXT:    addu $3, $3, $1
; CHECK-LE-NEXT:    sll $1, $1, 5
; CHECK-LE-NEXT:    addu $1, $1, $3
; CHECK-LE-NEXT:    subu $1, $2, $1
; CHECK-LE-NEXT:    addiu $1, $1, 27
; CHECK-LE-NEXT:    andi $3, $1, 32
; CHECK-LE-NEXT:    move $8, $4
; CHECK-LE-NEXT:    movz $8, $7, $3
; CHECK-LE-NEXT:    movz $7, $6, $3
; CHECK-LE-NEXT:    srlv $2, $7, $1
; CHECK-LE-NEXT:    not $6, $1
; CHECK-LE-NEXT:    sll $7, $8, 1
; CHECK-LE-NEXT:    sllv $7, $7, $6
; CHECK-LE-NEXT:    or $2, $7, $2
; CHECK-LE-NEXT:    srlv $1, $8, $1
; CHECK-LE-NEXT:    movz $5, $4, $3
; CHECK-LE-NEXT:    sll $3, $5, 1
; CHECK-LE-NEXT:    sllv $3, $3, $6
; CHECK-LE-NEXT:    jr $ra
; CHECK-LE-NEXT:    or $3, $3, $1
  %f = call i37 @llvm.fshr.i37(i37 %x, i37 %y, i37 %z)
  ret i37 %f
}

; extract(concat(0b1110000, 0b1111111) >> 2) = 0b0011111

declare i7 @llvm.fshr.i7(i7, i7, i7)
define i7 @fshr_i7_const_fold() {
; CHECK-LABEL: fshr_i7_const_fold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 31
  %f = call i7 @llvm.fshr.i7(i7 112, i7 127, i7 2)
  ret i7 %f
}

define i8 @fshr_i8_const_fold_overshift_1() {
; CHECK-LABEL: fshr_i8_const_fold_overshift_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 254
  %f = call i8 @llvm.fshr.i8(i8 255, i8 0, i8 15)
  ret i8 %f
}

define i8 @fshr_i8_const_fold_overshift_2() {
; CHECK-LABEL: fshr_i8_const_fold_overshift_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 225
  %f = call i8 @llvm.fshr.i8(i8 15, i8 15, i8 11)
  ret i8 %f
}

define i8 @fshr_i8_const_fold_overshift_3() {
; CHECK-LABEL: fshr_i8_const_fold_overshift_3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 255
  %f = call i8 @llvm.fshr.i8(i8 0, i8 255, i8 8)
  ret i8 %f
}

; With constant shift amount, this is 'extr'.

define i32 @fshr_i32_const_shift(i32 %x, i32 %y) {
; CHECK-LABEL: fshr_i32_const_shift:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srl $1, $5, 9
; CHECK-NEXT:    sll $2, $4, 23
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    or $2, $2, $1
  %f = call i32 @llvm.fshr.i32(i32 %x, i32 %y, i32 9)
  ret i32 %f
}

; Check modulo math on shift amount. 41-32=9.

define i32 @fshr_i32_const_overshift(i32 %x, i32 %y) {
; CHECK-LABEL: fshr_i32_const_overshift:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srl $1, $5, 9
; CHECK-NEXT:    sll $2, $4, 23
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    or $2, $2, $1
  %f = call i32 @llvm.fshr.i32(i32 %x, i32 %y, i32 41)
  ret i32 %f
}

; 64-bit should also work. 105-64 = 41.

define i64 @fshr_i64_const_overshift(i64 %x, i64 %y) {
; CHECK-BE-LABEL: fshr_i64_const_overshift:
; CHECK-BE:       # %bb.0:
; CHECK-BE-NEXT:    srl $1, $5, 9
; CHECK-BE-NEXT:    sll $2, $4, 23
; CHECK-BE-NEXT:    or $2, $2, $1
; CHECK-BE-NEXT:    srl $1, $6, 9
; CHECK-BE-NEXT:    sll $3, $5, 23
; CHECK-BE-NEXT:    jr $ra
; CHECK-BE-NEXT:    or $3, $3, $1
;
; CHECK-LE-LABEL: fshr_i64_const_overshift:
; CHECK-LE:       # %bb.0:
; CHECK-LE-NEXT:    srl $1, $7, 9
; CHECK-LE-NEXT:    sll $2, $4, 23
; CHECK-LE-NEXT:    or $2, $2, $1
; CHECK-LE-NEXT:    srl $1, $4, 9
; CHECK-LE-NEXT:    sll $3, $5, 23
; CHECK-LE-NEXT:    jr $ra
; CHECK-LE-NEXT:    or $3, $3, $1
  %f = call i64 @llvm.fshr.i64(i64 %x, i64 %y, i64 105)
  ret i64 %f
}

; This should work without any node-specific logic.

define i8 @fshr_i8_const_fold() {
; CHECK-LABEL: fshr_i8_const_fold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $2, $zero, 254
  %f = call i8 @llvm.fshr.i8(i8 255, i8 0, i8 7)
  ret i8 %f
}

define i32 @fshl_i32_shift_by_bitwidth(i32 %x, i32 %y) {
; CHECK-LABEL: fshl_i32_shift_by_bitwidth:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    move $2, $4
  %f = call i32 @llvm.fshl.i32(i32 %x, i32 %y, i32 32)
  ret i32 %f
}

define i32 @fshr_i32_shift_by_bitwidth(i32 %x, i32 %y) {
; CHECK-LABEL: fshr_i32_shift_by_bitwidth:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    move $2, $5
  %f = call i32 @llvm.fshr.i32(i32 %x, i32 %y, i32 32)
  ret i32 %f
}

define <4 x i32> @fshl_v4i32_shift_by_bitwidth(<4 x i32> %x, <4 x i32> %y) {
; CHECK-LABEL: fshl_v4i32_shift_by_bitwidth:
; CHECK:       # %bb.0:
; CHECK-NEXT:    move $2, $4
; CHECK-NEXT:    move $3, $5
; CHECK-NEXT:    move $4, $6
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    move $5, $7
  %f = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> <i32 32, i32 32, i32 32, i32 32>)
  ret <4 x i32> %f
}

define <4 x i32> @fshr_v4i32_shift_by_bitwidth(<4 x i32> %x, <4 x i32> %y) {
; CHECK-LABEL: fshr_v4i32_shift_by_bitwidth:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lw $5, 28($sp)
; CHECK-NEXT:    lw $4, 24($sp)
; CHECK-NEXT:    lw $3, 20($sp)
; CHECK-NEXT:    lw $2, 16($sp)
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
  %f = call <4 x i32> @llvm.fshr.v4i32(<4 x i32> %x, <4 x i32> %y, <4 x i32> <i32 32, i32 32, i32 32, i32 32>)
  ret <4 x i32> %f
}

