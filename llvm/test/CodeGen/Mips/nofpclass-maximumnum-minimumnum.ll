; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --mtriple=mipsisa64r6 < %s | FileCheck %s --check-prefix=MIPS64R6
; RUN: llc --mtriple=mips64 < %s | FileCheck %s --check-prefix=MIPS64R2

declare float @llvm.maximumnum.f32(float, float)
declare double @llvm.maximumnum.f64(double, double)
declare float @llvm.minimumnum.f32(float, float)
declare double @llvm.minimumnum.f64(double, double)

define float @maximumnum_float_nnan(float nofpclass(nan) %x, float nofpclass(nan) %y) {
; MIPS64R6-LABEL: maximumnum_float_nnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    max.s $f0, $f12, $f13
;
; MIPS64R2-LABEL: maximumnum_float_nnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.ule.s $f12, $f13
; MIPS64R2-NEXT:    mov.s $f0, $f13
; MIPS64R2-NEXT:    movf.s $f0, $f12, $fcc0
; MIPS64R2-NEXT:    mfc1 $1, $f12
; MIPS64R2-NEXT:    mov.s $f1, $f0
; MIPS64R2-NEXT:    movz.s $f1, $f12, $1
; MIPS64R2-NEXT:    mfc1 $1, $f13
; MIPS64R2-NEXT:    movz.s $f1, $f13, $1
; MIPS64R2-NEXT:    mtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.s $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.s $f0, $f1, $fcc0
  %z = call float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}

define float @maximumnum_float_nsnan(float nofpclass(snan) %x, float nofpclass(snan) %y) {
; MIPS64R6-LABEL: maximumnum_float_nsnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    max.s $f0, $f12, $f13
;
; MIPS64R2-LABEL: maximumnum_float_nsnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.un.s $f12, $f12
; MIPS64R2-NEXT:    movt.s $f12, $f13, $fcc0
; MIPS64R2-NEXT:    c.un.s $f13, $f13
; MIPS64R2-NEXT:    movt.s $f13, $f12, $fcc0
; MIPS64R2-NEXT:    c.ule.s $f12, $f13
; MIPS64R2-NEXT:    mov.s $f0, $f13
; MIPS64R2-NEXT:    movf.s $f0, $f12, $fcc0
; MIPS64R2-NEXT:    mfc1 $1, $f12
; MIPS64R2-NEXT:    mov.s $f1, $f0
; MIPS64R2-NEXT:    movz.s $f1, $f12, $1
; MIPS64R2-NEXT:    mfc1 $1, $f13
; MIPS64R2-NEXT:    movz.s $f1, $f13, $1
; MIPS64R2-NEXT:    mtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.s $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.s $f0, $f1, $fcc0
  %z = call float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}

define float @minimumnum_float_nnan(float nofpclass(nan) %x, float nofpclass(nan) %y) {
; MIPS64R6-LABEL: minimumnum_float_nnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    min.s $f0, $f12, $f13
;
; MIPS64R2-LABEL: minimumnum_float_nnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.olt.s $f12, $f13
; MIPS64R2-NEXT:    mov.s $f0, $f13
; MIPS64R2-NEXT:    movt.s $f0, $f12, $fcc0
; MIPS64R2-NEXT:    mfc1 $1, $f12
; MIPS64R2-NEXT:    lui $2, 32768
; MIPS64R2-NEXT:    xor $1, $1, $2
; MIPS64R2-NEXT:    mov.s $f1, $f0
; MIPS64R2-NEXT:    movz.s $f1, $f12, $1
; MIPS64R2-NEXT:    mfc1 $1, $f13
; MIPS64R2-NEXT:    xor $1, $1, $2
; MIPS64R2-NEXT:    movz.s $f1, $f13, $1
; MIPS64R2-NEXT:    mtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.s $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.s $f0, $f1, $fcc0
  %z = call float @llvm.minimumnum.f32(float %x, float %y)
  ret float %z
}

define float @minimumnum_float_nsnan(float nofpclass(snan) %x, float nofpclass(snan) %y) {
; MIPS64R6-LABEL: minimumnum_float_nsnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    max.s $f0, $f12, $f13
;
; MIPS64R2-LABEL: minimumnum_float_nsnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.un.s $f12, $f12
; MIPS64R2-NEXT:    movt.s $f12, $f13, $fcc0
; MIPS64R2-NEXT:    c.un.s $f13, $f13
; MIPS64R2-NEXT:    movt.s $f13, $f12, $fcc0
; MIPS64R2-NEXT:    c.ule.s $f12, $f13
; MIPS64R2-NEXT:    mov.s $f0, $f13
; MIPS64R2-NEXT:    movf.s $f0, $f12, $fcc0
; MIPS64R2-NEXT:    mfc1 $1, $f12
; MIPS64R2-NEXT:    mov.s $f1, $f0
; MIPS64R2-NEXT:    movz.s $f1, $f12, $1
; MIPS64R2-NEXT:    mfc1 $1, $f13
; MIPS64R2-NEXT:    movz.s $f1, $f13, $1
; MIPS64R2-NEXT:    mtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.s $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.s $f0, $f1, $fcc0
  %z = call float @llvm.maximumnum.f32(float %x, float %y)
  ret float %z
}



define double @maximumnum_double_nnan(double nofpclass(nan) %x, double nofpclass(nan) %y) {
; MIPS64R6-LABEL: maximumnum_double_nnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    max.d $f0, $f12, $f13
;
; MIPS64R2-LABEL: maximumnum_double_nnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.ule.d $f12, $f13
; MIPS64R2-NEXT:    mov.d $f0, $f13
; MIPS64R2-NEXT:    movf.d $f0, $f12, $fcc0
; MIPS64R2-NEXT:    dmfc1 $1, $f12
; MIPS64R2-NEXT:    mov.d $f1, $f0
; MIPS64R2-NEXT:    movz.d $f1, $f12, $1
; MIPS64R2-NEXT:    dmfc1 $1, $f13
; MIPS64R2-NEXT:    movz.d $f1, $f13, $1
; MIPS64R2-NEXT:    dmtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.d $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.d $f0, $f1, $fcc0
  %z = call double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define double @maximumnum_double_nsnan(double nofpclass(snan) %x, double nofpclass(snan) %y) {
; MIPS64R6-LABEL: maximumnum_double_nsnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    max.d $f0, $f12, $f13
;
; MIPS64R2-LABEL: maximumnum_double_nsnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.un.d $f12, $f12
; MIPS64R2-NEXT:    movt.d $f12, $f13, $fcc0
; MIPS64R2-NEXT:    c.un.d $f13, $f13
; MIPS64R2-NEXT:    movt.d $f13, $f12, $fcc0
; MIPS64R2-NEXT:    c.ule.d $f12, $f13
; MIPS64R2-NEXT:    mov.d $f0, $f13
; MIPS64R2-NEXT:    movf.d $f0, $f12, $fcc0
; MIPS64R2-NEXT:    dmfc1 $1, $f12
; MIPS64R2-NEXT:    mov.d $f1, $f0
; MIPS64R2-NEXT:    movz.d $f1, $f12, $1
; MIPS64R2-NEXT:    dmfc1 $1, $f13
; MIPS64R2-NEXT:    movz.d $f1, $f13, $1
; MIPS64R2-NEXT:    dmtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.d $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.d $f0, $f1, $fcc0
  %z = call double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}

define double @minimumnum_double_nnan(double nofpclass(nan) %x, double nofpclass(nan) %y) {
; MIPS64R6-LABEL: minimumnum_double_nnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    min.d $f0, $f12, $f13
;
; MIPS64R2-LABEL: minimumnum_double_nnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.olt.d $f12, $f13
; MIPS64R2-NEXT:    mov.d $f0, $f13
; MIPS64R2-NEXT:    movt.d $f0, $f12, $fcc0
; MIPS64R2-NEXT:    daddiu $1, $zero, 1
; MIPS64R2-NEXT:    dsll $1, $1, 63
; MIPS64R2-NEXT:    dmfc1 $2, $f12
; MIPS64R2-NEXT:    xor $2, $2, $1
; MIPS64R2-NEXT:    mov.d $f1, $f0
; MIPS64R2-NEXT:    movz.d $f1, $f12, $2
; MIPS64R2-NEXT:    dmfc1 $2, $f13
; MIPS64R2-NEXT:    xor $1, $2, $1
; MIPS64R2-NEXT:    movz.d $f1, $f13, $1
; MIPS64R2-NEXT:    dmtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.d $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.d $f0, $f1, $fcc0
  %z = call double @llvm.minimumnum.f64(double %x, double %y)
  ret double %z
}

define double @minimumnum_double_nsnan(double nofpclass(snan) %x, double nofpclass(snan) %y) {
; MIPS64R6-LABEL: minimumnum_double_nsnan:
; MIPS64R6:       # %bb.0:
; MIPS64R6-NEXT:    jr $ra
; MIPS64R6-NEXT:    max.d $f0, $f12, $f13
;
; MIPS64R2-LABEL: minimumnum_double_nsnan:
; MIPS64R2:       # %bb.0:
; MIPS64R2-NEXT:    c.un.d $f12, $f12
; MIPS64R2-NEXT:    movt.d $f12, $f13, $fcc0
; MIPS64R2-NEXT:    c.un.d $f13, $f13
; MIPS64R2-NEXT:    movt.d $f13, $f12, $fcc0
; MIPS64R2-NEXT:    c.ule.d $f12, $f13
; MIPS64R2-NEXT:    mov.d $f0, $f13
; MIPS64R2-NEXT:    movf.d $f0, $f12, $fcc0
; MIPS64R2-NEXT:    dmfc1 $1, $f12
; MIPS64R2-NEXT:    mov.d $f1, $f0
; MIPS64R2-NEXT:    movz.d $f1, $f12, $1
; MIPS64R2-NEXT:    dmfc1 $1, $f13
; MIPS64R2-NEXT:    movz.d $f1, $f13, $1
; MIPS64R2-NEXT:    dmtc1 $zero, $f2
; MIPS64R2-NEXT:    c.eq.d $f0, $f2
; MIPS64R2-NEXT:    jr $ra
; MIPS64R2-NEXT:    movt.d $f0, $f1, $fcc0
  %z = call double @llvm.maximumnum.f64(double %x, double %y)
  ret double %z
}
