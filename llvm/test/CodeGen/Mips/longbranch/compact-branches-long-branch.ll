; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -march=mips -mcpu=mips32r6 -force-mips-long-branch | FileCheck %s

; Check that when MIPS32R6 with the static relocation model with the usage of
; long branches, that there is a nop between any compact branch and the static
; relocation method of expanding branches. Previously, it could result in 'j'
; following a b(ne|eq)zc, which would raise a reserved instruction exception.

declare i32 @f(i32)

declare i32 @g()

define i32 @test1(i32 %a) {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    bnezc $4, $BB0_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB0_3
; CHECK-NEXT:  $BB0_2: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB0_3: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp eq i32 %a, 0
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}


define i32 @test2(i32 %a) {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    bgezc $4, $BB1_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB1_3
; CHECK-NEXT:  $BB1_2: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB1_3: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp sge i32 %a, 0
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}


define i32 @test3(i32 %a) {
; CHECK-LABEL: test3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    blezc $4, $BB2_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB2_3
; CHECK-NEXT:  $BB2_2: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB2_3: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp sle i32 %a, 0
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}


define i32 @test4(i32 %a) {
; CHECK-LABEL: test4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    bgtzc $4, $BB3_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB3_3
; CHECK-NEXT:  $BB3_2: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB3_3: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp sgt i32 %a, 0
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}

define i32 @test5(i32 %a) {
; CHECK-LABEL: test5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    bgezc $4, $BB4_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB4_3
; CHECK-NEXT:  $BB4_2: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB4_3: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp slt i32 %a, 0
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}

define i32 @test6(i32 %a, i32 %b) {
; CHECK-LABEL: test6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    sltu $1, $5, $4
; CHECK-NEXT:    bnezc $1, $BB5_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB5_3
; CHECK-NEXT:  $BB5_2: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB5_3: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp ugt i32 %a, %b
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}


define i32 @test7(i32 %a, i32 %b) {
; CHECK-LABEL: test7:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    sltu $1, $4, $5
; CHECK-NEXT:    bnezc $1, $BB6_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB6_3
; CHECK-NEXT:  $BB6_2: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB6_3: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp uge i32 %a, %b
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}


define i32 @test8(i32 %a, i32 %b) {
; CHECK-LABEL: test8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    sltu $1, $4, $5
; CHECK-NEXT:    bnezc $1, $BB7_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB7_3
; CHECK-NEXT:  $BB7_2: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB7_3: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp ult i32 %a, %b
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}


define i32 @test9(i32 %a, i32 %b) {
; CHECK-LABEL: test9:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addiu $sp, $sp, -24
; CHECK-NEXT:    .cfi_def_cfa_offset 24
; CHECK-NEXT:    sw $ra, 20($sp) # 4-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -4
; CHECK-NEXT:    sltu $1, $5, $4
; CHECK-NEXT:    bnezc $1, $BB8_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    bc $BB8_3
; CHECK-NEXT:  $BB8_2: # %cond.false
; CHECK-NEXT:    jal g
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
; CHECK-NEXT:  $BB8_3: # %cond.true
; CHECK-NEXT:    jal f
; CHECK-NEXT:    nop
; CHECK-NEXT:    lw $ra, 20($sp) # 4-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    addiu $sp, $sp, 24
entry:
  %0 = icmp ule i32 %a, %b
  br i1 %0, label %cond.true, label %cond.false
cond.true:
  %1 = call i32 @f(i32 %a)
  ret i32 %1
cond.false:
  %2 = call i32 @g()
  ret i32 %2
}
