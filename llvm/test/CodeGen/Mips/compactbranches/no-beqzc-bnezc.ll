; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -march=mipsel -mcpu=mips32r6 -disable-mips-delay-filler < %s | FileCheck %s --check-prefixes=ENCODING,MIPSEL32
; RUN: llc -march=mips -mcpu=mips32r6 -disable-mips-delay-filler < %s | FileCheck %s --check-prefixes=ENCODING,MIPS32
; RUN: llc -march=mipsel -mcpu=mips64r6 -disable-mips-delay-filler -target-abi=n64 < %s | FileCheck %s --check-prefixes=ENCODING,MIPSEL64
; RUN: llc -march=mips -mcpu=mips64r6 -disable-mips-delay-filler -target-abi=n64 < %s | FileCheck %s --check-prefixes=ENCODING,MIPS64

; bnezc and beqzc have restriction that $rt != 0

define i32 @f() {
; CHECK-LABEL: f:
; CHECK-NOT:   bnezc $0
; MIPSEL32-LABEL: f:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    bnez $zero, $BB0_2
; MIPSEL32-NEXT:    nop
; MIPSEL32-NEXT:  # %bb.1: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB0_2: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    bnez $zero, $BB0_2
; MIPS32-NEXT:    nop
; MIPS32-NEXT:  # %bb.1: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 1
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB0_2: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    bnez $zero, .LBB0_2
; MIPSEL64-NEXT:    nop
; MIPSEL64-NEXT:  # %bb.1: # %if.then
; MIPSEL64-NEXT:    addiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB0_2: # %if.end
; MIPSEL64-NEXT:    addiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    bnez $zero, .LBB0_2
; MIPS64-NEXT:    nop
; MIPS64-NEXT:  # %bb.1: # %if.then
; MIPS64-NEXT:    addiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB0_2: # %if.end
; MIPS64-NEXT:    addiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
  %cmp = icmp eq i32 1, 1
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i32 1

  if.end:
    ret i32 0
}

define i32 @f1() {
; CHECK-LABEL: f1:
; CHECK-NOT:   beqzc $0
; MIPSEL32-LABEL: f1:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    b $BB1_2
; MIPSEL32-NEXT:    nop
; MIPSEL32-NEXT:  # %bb.1: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB1_2: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f1:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    b $BB1_2
; MIPS32-NEXT:    nop
; MIPS32-NEXT:  # %bb.1: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB1_2: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 1
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f1:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    b .LBB1_2
; MIPSEL64-NEXT:    nop
; MIPSEL64-NEXT:  # %bb.1: # %if.end
; MIPSEL64-NEXT:    addiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB1_2: # %if.then
; MIPSEL64-NEXT:    addiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f1:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    b .LBB1_2
; MIPS64-NEXT:    nop
; MIPS64-NEXT:  # %bb.1: # %if.end
; MIPS64-NEXT:    addiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB1_2: # %if.then
; MIPS64-NEXT:    addiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra
  %cmp = icmp eq i32 0, 0
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i32 1

  if.end:
    ret i32 0
}

; We silently fixup cases where the register allocator or user has given us
; an instruction with incorrect operands that is trivially acceptable.
; beqc and bnec have the restriction that $rs < $rt.

define i32 @f2(i32 %a, i32 %b) {
; MIPSEL32-LABEL: f2:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    beqc $5, $4, $BB2_2
; MIPSEL32-NEXT:  # %bb.1: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB2_2: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f2:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    beqc $5, $4, $BB2_2
; MIPS32-NEXT:  # %bb.1: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB2_2: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 1
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f2:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    sll $1, $4, 0
; MIPSEL64-NEXT:    sll $2, $5, 0
; MIPSEL64-NEXT:    beqc $2, $1, .LBB2_2
; MIPSEL64-NEXT:  # %bb.1: # %if.end
; MIPSEL64-NEXT:    addiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB2_2: # %if.then
; MIPSEL64-NEXT:    addiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f2:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    sll $1, $4, 0
; MIPS64-NEXT:    sll $2, $5, 0
; MIPS64-NEXT:    beqc $2, $1, .LBB2_2
; MIPS64-NEXT:  # %bb.1: # %if.end
; MIPS64-NEXT:    addiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB2_2: # %if.then
; MIPS64-NEXT:    addiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra

  %cmp = icmp eq i32 %b, %a
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i32 1

  if.end:
    ret i32 0
}

define i64 @f3() {
; CHECK-LABEL: f3:
; CHECK-NOT:   bnezc $0
; MIPSEL32-LABEL: f3:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    bnez $zero, $BB3_2
; MIPSEL32-NEXT:    nop
; MIPSEL32-NEXT:  # %bb.1: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    addiu $3, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB3_2: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    addiu $3, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f3:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    bnez $zero, $BB3_2
; MIPS32-NEXT:    nop
; MIPS32-NEXT:  # %bb.1: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    addiu $3, $zero, 1
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB3_2: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    addiu $3, $zero, 0
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f3:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    bnez $zero, .LBB3_2
; MIPSEL64-NEXT:    nop
; MIPSEL64-NEXT:  # %bb.1: # %if.then
; MIPSEL64-NEXT:    daddiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB3_2: # %if.end
; MIPSEL64-NEXT:    daddiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f3:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    bnez $zero, .LBB3_2
; MIPS64-NEXT:    nop
; MIPS64-NEXT:  # %bb.1: # %if.then
; MIPS64-NEXT:    daddiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB3_2: # %if.end
; MIPS64-NEXT:    daddiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
  %cmp = icmp eq i64 1, 1
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i64 1

  if.end:
    ret i64 0
}

define i64 @f4() {
; CHECK-LABEL: f4:
; CHECK-NOT:   beqzc $0
; MIPSEL32-LABEL: f4:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    b $BB4_2
; MIPSEL32-NEXT:    nop
; MIPSEL32-NEXT:  # %bb.1: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    addiu $3, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB4_2: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    addiu $3, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f4:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    b $BB4_2
; MIPS32-NEXT:    nop
; MIPS32-NEXT:  # %bb.1: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    addiu $3, $zero, 0
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB4_2: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    addiu $3, $zero, 1
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f4:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    b .LBB4_2
; MIPSEL64-NEXT:    nop
; MIPSEL64-NEXT:  # %bb.1: # %if.end
; MIPSEL64-NEXT:    daddiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB4_2: # %if.then
; MIPSEL64-NEXT:    daddiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f4:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    b .LBB4_2
; MIPS64-NEXT:    nop
; MIPS64-NEXT:  # %bb.1: # %if.end
; MIPS64-NEXT:    daddiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB4_2: # %if.then
; MIPS64-NEXT:    daddiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra
  %cmp = icmp eq i64 0, 0
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i64 1

  if.end:
    ret i64 0
}

; We silently fixup cases where the register allocator or user has given us
; an instruction with incorrect operands that is trivially acceptable.
; beqc and bnec have the restriction that $rs < $rt.

define i64 @f5(i64 %a, i64 %b) {
; MIPSEL32-LABEL: f5:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    xor $1, $7, $5
; MIPSEL32-NEXT:    xor $2, $6, $4
; MIPSEL32-NEXT:    or $1, $2, $1
; MIPSEL32-NEXT:    beqzc $1, $BB5_2
; MIPSEL32-NEXT:  # %bb.1: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    addiu $3, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB5_2: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    addiu $3, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f5:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    xor $1, $6, $4
; MIPS32-NEXT:    xor $2, $7, $5
; MIPS32-NEXT:    or $1, $2, $1
; MIPS32-NEXT:    beqzc $1, $BB5_2
; MIPS32-NEXT:  # %bb.1: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    addiu $3, $zero, 0
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB5_2: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    addiu $3, $zero, 1
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f5:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    beqc $5, $4, .LBB5_2
; MIPSEL64-NEXT:  # %bb.1: # %if.end
; MIPSEL64-NEXT:    daddiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB5_2: # %if.then
; MIPSEL64-NEXT:    daddiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f5:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    beqc $5, $4, .LBB5_2
; MIPS64-NEXT:  # %bb.1: # %if.end
; MIPS64-NEXT:    daddiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB5_2: # %if.then
; MIPS64-NEXT:    daddiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra

  %cmp = icmp eq i64 %b, %a
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i64 1

  if.end:
    ret i64 0
}

define i32 @f6(i32 %a) {
; CHECK-LABEL: f6:
; CHECK: beqzc ${{[0-9]+}}, {{((\$)|(\.L))}}BB
; MIPSEL32-LABEL: f6:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    beqzc $4, $BB6_2
; MIPSEL32-NEXT:  # %bb.1: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB6_2: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f6:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    beqzc $4, $BB6_2
; MIPS32-NEXT:  # %bb.1: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB6_2: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 1
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f6:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    sll $1, $4, 0
; MIPSEL64-NEXT:    beqzc $1, .LBB6_2
; MIPSEL64-NEXT:  # %bb.1: # %if.end
; MIPSEL64-NEXT:    addiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB6_2: # %if.then
; MIPSEL64-NEXT:    addiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f6:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    sll $1, $4, 0
; MIPS64-NEXT:    beqzc $1, .LBB6_2
; MIPS64-NEXT:  # %bb.1: # %if.end
; MIPS64-NEXT:    addiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB6_2: # %if.then
; MIPS64-NEXT:    addiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra
  %cmp = icmp eq i32 %a, 0
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i32 1

  if.end:
    ret i32 0
}

define i32 @f7(i32 %a) {
; CHECK-LABEL: f7:
; CHECK: bnezc ${{[0-9]+}}, {{((\$)|(\.L))}}BB
; MIPSEL32-LABEL: f7:
; MIPSEL32:       # %bb.0:
; MIPSEL32-NEXT:    beqzc $4, $BB7_2
; MIPSEL32-NEXT:  # %bb.1: # %if.end
; MIPSEL32-NEXT:    addiu $2, $zero, 0
; MIPSEL32-NEXT:    jrc $ra
; MIPSEL32-NEXT:  $BB7_2: # %if.then
; MIPSEL32-NEXT:    addiu $2, $zero, 1
; MIPSEL32-NEXT:    jrc $ra
;
; MIPS32-LABEL: f7:
; MIPS32:       # %bb.0:
; MIPS32-NEXT:    beqzc $4, $BB7_2
; MIPS32-NEXT:  # %bb.1: # %if.end
; MIPS32-NEXT:    addiu $2, $zero, 0
; MIPS32-NEXT:    jrc $ra
; MIPS32-NEXT:  $BB7_2: # %if.then
; MIPS32-NEXT:    addiu $2, $zero, 1
; MIPS32-NEXT:    jrc $ra
;
; MIPSEL64-LABEL: f7:
; MIPSEL64:       # %bb.0:
; MIPSEL64-NEXT:    sll $1, $4, 0
; MIPSEL64-NEXT:    beqzc $1, .LBB7_2
; MIPSEL64-NEXT:  # %bb.1: # %if.end
; MIPSEL64-NEXT:    addiu $2, $zero, 0
; MIPSEL64-NEXT:    jrc $ra
; MIPSEL64-NEXT:  .LBB7_2: # %if.then
; MIPSEL64-NEXT:    addiu $2, $zero, 1
; MIPSEL64-NEXT:    jrc $ra
;
; MIPS64-LABEL: f7:
; MIPS64:       # %bb.0:
; MIPS64-NEXT:    sll $1, $4, 0
; MIPS64-NEXT:    beqzc $1, .LBB7_2
; MIPS64-NEXT:  # %bb.1: # %if.end
; MIPS64-NEXT:    addiu $2, $zero, 0
; MIPS64-NEXT:    jrc $ra
; MIPS64-NEXT:  .LBB7_2: # %if.then
; MIPS64-NEXT:    addiu $2, $zero, 1
; MIPS64-NEXT:    jrc $ra
  %cmp = icmp eq i32 0, %a
  br i1 %cmp, label %if.then, label %if.end

  if.then:
    ret i32 1

  if.end:
    ret i32 0
}
