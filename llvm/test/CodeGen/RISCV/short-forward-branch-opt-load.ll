; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+a | FileCheck %s --check-prefixes=RV32I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+a | FileCheck %s --check-prefixes=RV64I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+a,+short-forward-branch-ialu | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+a,+short-forward-branch-ialu | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+a,+short-forward-branch-iload | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFBILOAD
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+a,+short-forward-branch-iload | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFBILOAD

define i32 @test_i8_s(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB0_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lb a2, 4(a0)
; RV32I-NEXT:  .LBB0_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB0_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lb a2, 4(a0)
; RV64I-NEXT:  .LBB0_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB0_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB0_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB0_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB0_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB0_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB0_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB0_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB0_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB1_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lbu a2, 4(a0)
; RV32I-NEXT:  .LBB1_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB1_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lbu a2, 4(a0)
; RV64I-NEXT:  .LBB1_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB1_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB1_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB1_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB1_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB1_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB1_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB1_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB1_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB2_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lh a2, 8(a0)
; RV32I-NEXT:  .LBB2_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB2_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lh a2, 8(a0)
; RV64I-NEXT:  .LBB2_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB2_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB2_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB2_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB2_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB2_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB2_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB2_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB2_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB3_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lhu a2, 8(a0)
; RV32I-NEXT:  .LBB3_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB3_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lhu a2, 8(a0)
; RV64I-NEXT:  .LBB3_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB3_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB3_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB3_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB3_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB3_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB3_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB3_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB3_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i32:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB4_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lw a2, 16(a0)
; RV32I-NEXT:  .LBB4_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB4_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lw a2, 16(a0)
; RV64I-NEXT:  .LBB4_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB4_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB4_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB4_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB4_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB4_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB4_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB4_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB4_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i32 @test_i8_s_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_s_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB5_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB5_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB5_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB5_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB5_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB5_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB5_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB5_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB5_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB5_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_store:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB5_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB5_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_z_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB6_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB6_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB6_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB6_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB6_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB6_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB6_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB6_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB6_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB6_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_store:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB6_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB6_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_s_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB7_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB7_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB7_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB7_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB7_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB7_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB7_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB7_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB7_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB7_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_store:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB7_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB7_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_z_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB8_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB8_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB8_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB8_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB8_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB8_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB8_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB8_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB8_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB8_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_store:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB8_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB8_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i32_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB9_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB9_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lw a0, 16(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB9_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB9_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB9_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB9_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB9_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB9_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB9_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB9_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_store:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB9_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB9_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i64 @test_i8_s_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_s_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB10_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lb a2, 4(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB10_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB10_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lb a2, 4(a0)
; RV64I-NEXT:  .LBB10_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB10_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB10_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB10_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB10_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB10_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB10_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB10_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB10_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB10_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB10_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB10_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB10_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i8_z_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB11_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lbu a2, 4(a0)
; RV32I-NEXT:  .LBB11_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB11_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lbu a2, 4(a0)
; RV64I-NEXT:  .LBB11_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB11_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB11_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB11_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB11_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB11_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB11_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB11_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB11_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB11_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB11_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB11_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB11_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_s_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_s_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB12_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lh a2, 8(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB12_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB12_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lh a2, 8(a0)
; RV64I-NEXT:  .LBB12_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB12_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB12_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB12_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB12_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB12_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB12_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB12_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB12_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB12_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB12_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB12_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB12_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_z_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB13_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lhu a2, 8(a0)
; RV32I-NEXT:  .LBB13_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB13_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lhu a2, 8(a0)
; RV64I-NEXT:  .LBB13_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB13_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB13_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB13_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB13_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB13_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB13_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB13_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB13_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB13_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB13_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB13_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB13_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i32_z_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i32_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB14_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lw a2, 16(a0)
; RV32I-NEXT:  .LBB14_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB14_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lwu a2, 16(a0)
; RV64I-NEXT:  .LBB14_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB14_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB14_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB14_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB14_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB14_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB14_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB14_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB14_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB14_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB14_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB14_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB14_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i64_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i64_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB15_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lw a2, 32(a0)
; RV32I-NEXT:    lw a3, 36(a0)
; RV32I-NEXT:  .LBB15_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB15_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    ld a2, 32(a0)
; RV64I-NEXT:  .LBB15_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a4, 32(a0)
; RV32I-SFB-NEXT:    lw a5, 36(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB15_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a4, a2
; RV32I-SFB-NEXT:  .LBB15_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB15_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a5, a3
; RV32I-SFB-NEXT:  .LBB15_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a4
; RV32I-SFB-NEXT:    mv a1, a5
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB15_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB15_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB15_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 32(a0)
; RV32I-SFBILOAD-NEXT:  .LBB15_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB15_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 36(a0)
; RV32I-SFBILOAD-NEXT:  .LBB15_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB15_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    ld a2, 32(a0)
; RV64I-SFBILOAD-NEXT:  .LBB15_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  %res = select i1 %x, i64 %val, i64 %b
  ret i64 %res
}

define i64 @test_i8_s_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB16_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB16_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB16_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB16_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB16_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB16_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB16_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB16_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB16_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB16_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store_64:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB16_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB16_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB16_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB16_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_store_64:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB16_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB16_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i8_z_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB17_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB17_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB17_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB17_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB17_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB17_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB17_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB17_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB17_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB17_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store_64:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB17_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB17_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB17_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB17_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_store_64:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB17_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB17_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_s_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB18_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB18_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB18_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB18_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB18_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB18_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB18_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB18_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB18_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB18_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store_64:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB18_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB18_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB18_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB18_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_store_64:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB18_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB18_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_z_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB19_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB19_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB19_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB19_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB19_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB19_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB19_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB19_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB19_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB19_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store_64:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB19_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB19_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB19_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB19_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_store_64:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB19_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB19_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i32_z_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i32_z_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB20_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB20_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lwu a0, 16(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB20_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB20_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB20_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB20_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB20_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB20_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB20_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB20_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_store_64:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB20_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB20_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB20_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB20_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_store_64:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB20_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB20_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i64_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i64_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    mv a7, a1
; RV32I-NEXT:    mv a1, a0
; RV32I-NEXT:    lw a0, 32(a0)
; RV32I-NEXT:    lw a1, 36(a1)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a7, .LBB21_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:  .LBB21_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    ld a0, 32(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB21_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB21_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a7, 32(a0)
; RV32I-SFB-NEXT:    lw t0, 36(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB21_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a7, a2
; RV32I-SFB-NEXT:  .LBB21_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB21_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv t0, a3
; RV32I-SFB-NEXT:  .LBB21_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a7
; RV32I-SFB-NEXT:    mv a1, t0
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB21_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB21_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_store_64:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a7, 32(a0)
; RV32I-SFBILOAD-NEXT:    lw t0, 36(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB21_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a7, a2
; RV32I-SFBILOAD-NEXT:  .LBB21_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB21_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv t0, a3
; RV32I-SFBILOAD-NEXT:  .LBB21_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a7
; RV32I-SFBILOAD-NEXT:    mv a1, t0
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_store_64:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a0, 32(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB21_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB21_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %val, i64 %b
  ret i64 %res
}

define i32 @test_i8_s_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a4, 4(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB22_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB22_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a4, 4(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB22_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB22_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB22_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB22_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB22_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB22_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB22_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB22_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB22_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB22_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_z_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a4, 4(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB23_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB23_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a4, 4(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB23_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB23_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB23_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB23_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB23_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB23_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB23_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB23_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB23_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB23_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_s_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a4, 8(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB24_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB24_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a4, 8(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB24_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB24_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB24_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB24_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB24_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB24_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB24_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB24_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB24_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB24_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_z_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a4, 8(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB25_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB25_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a4, 8(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB25_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB25_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB25_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB25_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB25_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB25_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB25_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB25_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB25_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB25_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i32_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a4, 16(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB26_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB26_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lw a4, 16(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB26_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB26_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB26_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB26_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB26_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB26_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB26_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB26_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB26_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB26_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}


define i64 @test_i8_s_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a6, 4(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB27_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:    j .LBB27_3
; RV32I-NEXT:  .LBB27_2:
; RV32I-NEXT:    srai a3, a6, 31
; RV32I-NEXT:  .LBB27_3: # %entry
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    sltu a1, a0, a6
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a3, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a4, 4(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB27_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB27_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB27_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB27_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB27_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB27_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a3, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB27_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB27_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB27_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB27_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB27_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB27_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB27_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB27_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i8_z_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a6, 4(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB28_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:  .LBB28_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a6
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a4, 4(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB28_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB28_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a5, 4(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB28_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB28_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB28_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB28_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB28_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB28_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB28_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB28_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB28_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB28_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a1, a5, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB28_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB28_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_s_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a6, 8(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB29_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:    j .LBB29_3
; RV32I-NEXT:  .LBB29_2:
; RV32I-NEXT:    srai a3, a6, 31
; RV32I-NEXT:  .LBB29_3: # %entry
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    sltu a1, a0, a6
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a3, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a4, 8(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB29_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB29_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB29_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB29_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB29_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB29_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a3, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB29_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB29_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB29_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB29_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB29_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB29_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB29_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB29_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_z_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a6, 8(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB30_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:  .LBB30_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a6
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a4, 8(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB30_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB30_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a5, 8(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB30_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB30_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB30_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB30_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB30_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB30_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB30_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB30_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB30_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB30_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a1, a5, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB30_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB30_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i32_z_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a6, 16(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB31_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:  .LBB31_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a6
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lwu a4, 16(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB31_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB31_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a5, 16(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB31_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB31_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB31_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB31_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB31_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB31_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB31_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB31_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB31_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB31_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a1, a5, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB31_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB31_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i64_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i64_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a7, 32(a0)
; RV32I-NEXT:    lw a6, 36(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB32_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a3
; RV32I-NEXT:    mv a7, a2
; RV32I-NEXT:  .LBB32_2: # %entry
; RV32I-NEXT:    add a0, a7, a0
; RV32I-NEXT:    sltu a1, a0, a7
; RV32I-NEXT:    add a5, a6, a5
; RV32I-NEXT:    add a1, a5, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    ld a4, 32(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB32_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB32_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a5, 32(a0)
; RV32I-SFB-NEXT:    lw a6, 36(a0)
; RV32I-SFB-NEXT:    lw a7, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB32_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a6, a3
; RV32I-SFB-NEXT:  .LBB32_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB32_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB32_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a6, a6, a7
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB32_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB32_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB32_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 32(a0)
; RV32I-SFBILOAD-NEXT:  .LBB32_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB32_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 36(a0)
; RV32I-SFBILOAD-NEXT:  .LBB32_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB32_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    ld a2, 32(a0)
; RV64I-SFBILOAD-NEXT:  .LBB32_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  %val1 = load volatile i64, ptr %base1
  %res = select i1 %x, i64 %val, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i32 @test_i8_s_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_s_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB33_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lb a2, 4(a0)
; RV32I-NEXT:  .LBB33_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB33_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lb a2, 4(a0)
; RV64I-NEXT:  .LBB33_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB33_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB33_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB33_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB33_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB33_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB33_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB33_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB33_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i8_z_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_z_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB34_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lbu a2, 4(a0)
; RV32I-NEXT:  .LBB34_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB34_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lbu a2, 4(a0)
; RV64I-NEXT:  .LBB34_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB34_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB34_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB34_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB34_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB34_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB34_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB34_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB34_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_s_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_s_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB35_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lh a2, 8(a0)
; RV32I-NEXT:  .LBB35_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB35_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lh a2, 8(a0)
; RV64I-NEXT:  .LBB35_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB35_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB35_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB35_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB35_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB35_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB35_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB35_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB35_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_z_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_z_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB36_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lhu a2, 8(a0)
; RV32I-NEXT:  .LBB36_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB36_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lhu a2, 8(a0)
; RV64I-NEXT:  .LBB36_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB36_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB36_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB36_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB36_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB36_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB36_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB36_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB36_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i32_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i32_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB37_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lw a2, 16(a0)
; RV32I-NEXT:  .LBB37_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB37_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lw a2, 16(a0)
; RV64I-NEXT:  .LBB37_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB37_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB37_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB37_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB37_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB37_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB37_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB37_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB37_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %res = select i1 %x, i32 %b, i32 %val
  ret i32 %res
}

define i32 @test_i8_s_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB38_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB38_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB38_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB38_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB38_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB38_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB38_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB38_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB38_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB38_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_store_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB38_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB38_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i8_z_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB39_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB39_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB39_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB39_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB39_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB39_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB39_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB39_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB39_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB39_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_store_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB39_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB39_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_s_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB40_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB40_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB40_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB40_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB40_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB40_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB40_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB40_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB40_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB40_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_store_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB40_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB40_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_z_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB41_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB41_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB41_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB41_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB41_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB41_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB41_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB41_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB41_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB41_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_store_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB41_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB41_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i32_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i32_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB42_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB42_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lw a0, 16(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB42_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB42_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB42_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB42_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB42_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB42_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB42_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB42_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_store_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB42_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB42_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %val
  ret i32 %res
}

define i64 @test_i8_s_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_s_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB43_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lb a2, 4(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB43_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB43_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lb a2, 4(a0)
; RV64I-NEXT:  .LBB43_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB43_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB43_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB43_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB43_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB43_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB43_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_1_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB43_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB43_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB43_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB43_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_1_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB43_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB43_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i8_z_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_z_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB44_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lbu a2, 4(a0)
; RV32I-NEXT:  .LBB44_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB44_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lbu a2, 4(a0)
; RV64I-NEXT:  .LBB44_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB44_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB44_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB44_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB44_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB44_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB44_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_1_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB44_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB44_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB44_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB44_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_1_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB44_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB44_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_s_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_s_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB45_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lh a2, 8(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB45_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB45_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lh a2, 8(a0)
; RV64I-NEXT:  .LBB45_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB45_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB45_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB45_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB45_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB45_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB45_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_1_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB45_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB45_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB45_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB45_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_1_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB45_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB45_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_z_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_z_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB46_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lhu a2, 8(a0)
; RV32I-NEXT:  .LBB46_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB46_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lhu a2, 8(a0)
; RV64I-NEXT:  .LBB46_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB46_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB46_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB46_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB46_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB46_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB46_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_1_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB46_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB46_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB46_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB46_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_1_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB46_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB46_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i32_z_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i32_z_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB47_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lw a2, 16(a0)
; RV32I-NEXT:  .LBB47_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB47_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lwu a2, 16(a0)
; RV64I-NEXT:  .LBB47_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB47_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB47_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB47_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB47_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB47_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB47_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_1_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB47_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB47_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB47_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB47_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_1_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB47_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB47_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i64_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i64_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB48_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lw a2, 32(a0)
; RV32I-NEXT:    lw a3, 36(a0)
; RV32I-NEXT:  .LBB48_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB48_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    ld a2, 32(a0)
; RV64I-NEXT:  .LBB48_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a4, 32(a0)
; RV32I-SFB-NEXT:    lw a5, 36(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB48_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a4, a2
; RV32I-SFB-NEXT:  .LBB48_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB48_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a5, a3
; RV32I-SFB-NEXT:  .LBB48_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a4
; RV32I-SFB-NEXT:    mv a1, a5
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB48_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB48_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_1_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB48_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 32(a0)
; RV32I-SFBILOAD-NEXT:  .LBB48_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB48_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 36(a0)
; RV32I-SFBILOAD-NEXT:  .LBB48_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_1_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB48_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    ld a2, 32(a0)
; RV64I-SFBILOAD-NEXT:  .LBB48_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  %res = select i1 %x, i64 %b, i64 %val
  ret i64 %res
}

define i64 @test_i8_s_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB49_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a0, 31
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB49_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB49_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB49_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB49_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB49_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB49_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB49_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB49_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB49_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store_64_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB49_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB49_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB49_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB49_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_store_64_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB49_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB49_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i8_z_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB50_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB50_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB50_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB50_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB50_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB50_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB50_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB50_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB50_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB50_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store_64_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB50_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB50_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB50_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB50_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_store_64_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB50_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB50_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_s_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB51_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a0, 31
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB51_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB51_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB51_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB51_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB51_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB51_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB51_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB51_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB51_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store_64_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB51_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB51_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB51_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB51_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_store_64_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB51_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB51_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_z_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB52_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB52_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB52_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB52_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB52_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB52_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB52_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB52_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB52_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB52_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store_64_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB52_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB52_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB52_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB52_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_store_64_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB52_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB52_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i32_z_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i32_z_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB53_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB53_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lwu a0, 16(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB53_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB53_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB53_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB53_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB53_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB53_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB53_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB53_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_store_64_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB53_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB53_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB53_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB53_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_store_64_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB53_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB53_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i64_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i64_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a7, 32(a0)
; RV32I-NEXT:    lw a0, 36(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB54_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a7
; RV32I-NEXT:    mv a3, a0
; RV32I-NEXT:  .LBB54_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    ld a0, 32(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB54_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB54_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a7, 32(a0)
; RV32I-SFB-NEXT:    lw t0, 36(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB54_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a7, a2
; RV32I-SFB-NEXT:  .LBB54_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB54_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv t0, a3
; RV32I-SFB-NEXT:  .LBB54_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a7
; RV32I-SFB-NEXT:    mv a1, t0
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB54_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB54_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_store_64_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a7, 32(a0)
; RV32I-SFBILOAD-NEXT:    lw t0, 36(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB54_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a7, a2
; RV32I-SFBILOAD-NEXT:  .LBB54_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB54_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv t0, a3
; RV32I-SFBILOAD-NEXT:  .LBB54_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a7
; RV32I-SFBILOAD-NEXT:    mv a1, t0
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_store_64_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a0, 32(a0)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB54_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB54_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %val
  ret i64 %res
}

define i32 @test_i8_s_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a4, 4(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB55_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB55_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a4, 4(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB55_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB55_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB55_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB55_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB55_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB55_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB55_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB55_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB55_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB55_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_z_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a4, 4(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB56_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB56_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a4, 4(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB56_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB56_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB56_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB56_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB56_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB56_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB56_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB56_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB56_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB56_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_s_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a4, 8(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB57_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB57_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a4, 8(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB57_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB57_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB57_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB57_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB57_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB57_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB57_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB57_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB57_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB57_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_z_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a4, 8(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB58_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB58_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a4, 8(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB58_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB58_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB58_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB58_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB58_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB58_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB58_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB58_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB58_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB58_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i32_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a4, 16(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB59_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB59_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lw a4, 16(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB59_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB59_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB59_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB59_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB59_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB59_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB59_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB59_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB59_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB59_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %val
  %res1 = add i32 %res, %val1
  ret i32 %res1
}


define i64 @test_i8_s_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a6, 4(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB60_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a6, 31
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB60_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    sltu a1, a0, a2
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a3, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a4, 4(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB60_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB60_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB60_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB60_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB60_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB60_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a3, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB60_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB60_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_1_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB60_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB60_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB60_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB60_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_1_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB60_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB60_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i8_z_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a6, 4(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB61_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB61_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a2
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a4, 4(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB61_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB61_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a5, 4(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB61_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB61_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB61_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB61_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB61_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB61_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_1_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB61_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB61_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB61_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB61_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a1, a5, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_1_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB61_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB61_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_s_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a6, 8(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB62_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a6, 31
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB62_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    sltu a1, a0, a2
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a3, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a4, 8(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB62_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB62_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB62_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB62_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB62_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB62_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a3, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB62_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB62_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_1_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB62_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB62_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB62_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB62_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_1_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB62_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB62_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_z_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a6, 8(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB63_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB63_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a2
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a4, 8(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB63_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB63_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a5, 8(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB63_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB63_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB63_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB63_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB63_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB63_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_1_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB63_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB63_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB63_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB63_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a1, a5, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_1_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB63_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB63_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i32_z_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_z_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a6, 16(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB64_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB64_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a2
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lwu a4, 16(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB64_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB64_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a5, 16(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB64_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB64_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB64_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB64_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB64_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB64_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_1_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB64_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB64_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB64_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB64_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a1, a5, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_1_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB64_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB64_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i64_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i64_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a6, 32(a0)
; RV32I-NEXT:    lw a7, 36(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB65_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a3, a7
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB65_2: # %entry
; RV32I-NEXT:    add a0, a2, a0
; RV32I-NEXT:    sltu a1, a0, a2
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a3, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    ld a4, 32(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB65_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB65_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a5, 32(a0)
; RV32I-SFB-NEXT:    lw a6, 36(a0)
; RV32I-SFB-NEXT:    lw a7, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB65_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a6, a3
; RV32I-SFB-NEXT:  .LBB65_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB65_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB65_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a6, a6, a7
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB65_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB65_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_1_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB65_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 32(a0)
; RV32I-SFBILOAD-NEXT:  .LBB65_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB65_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 36(a0)
; RV32I-SFBILOAD-NEXT:  .LBB65_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_1_volatile_op:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB65_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    ld a2, 32(a0)
; RV64I-SFBILOAD-NEXT:  .LBB65_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  %val1 = load volatile i64, ptr %base1
  %res = select i1 %x, i64 %b, i64 %val
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i32 @test_i8_s_2(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_s_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    bnez a1, .LBB66_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB66_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    bnez a1, .LBB66_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB66_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB66_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB66_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB66_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB66_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB66_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB66_2: # %entry
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB66_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB66_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z_2(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_z_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    bnez a1, .LBB67_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB67_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    bnez a1, .LBB67_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB67_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB67_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB67_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB67_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB67_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB67_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB67_2: # %entry
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB67_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB67_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s_2(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_s_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    bnez a1, .LBB68_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB68_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    bnez a1, .LBB68_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB68_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB68_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB68_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB68_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB68_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB68_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB68_2: # %entry
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB68_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB68_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z_2(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_z_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    bnez a1, .LBB69_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB69_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    bnez a1, .LBB69_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB69_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB69_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB69_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB69_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB69_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB69_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB69_2: # %entry
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB69_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB69_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32_2(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i32_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    bnez a1, .LBB70_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB70_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lw a0, 16(a0)
; RV64I-NEXT:    bnez a1, .LBB70_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB70_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB70_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB70_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB70_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB70_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB70_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB70_2: # %entry
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB70_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB70_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i32, ptr %addr monotonic, align 4          ; load 32-bit value
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i32 @test_i8_s_store_2(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB71_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB71_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB71_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB71_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB71_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB71_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB71_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB71_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB71_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB71_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_store_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB71_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB71_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z_store_2(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB72_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB72_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB72_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB72_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB72_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB72_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB72_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB72_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB72_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB72_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_store_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB72_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB72_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s_store_2(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB73_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB73_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB73_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB73_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB73_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB73_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB73_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB73_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB73_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB73_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_store_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB73_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB73_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z_store_2(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB74_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB74_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB74_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB74_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB74_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB74_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB74_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB74_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB74_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB74_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_store_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB74_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB74_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32_store_2(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i32_store_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB75_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB75_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_store_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lw a0, 16(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB75_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB75_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_store_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB75_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB75_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_store_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB75_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB75_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_store_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB75_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB75_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_store_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB75_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB75_2: # %entry
; RV64I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load atomic i32, ptr %addr monotonic, align 4          ; load 32-bit value
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i64 @test_i8_s_1_2(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_s_1_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    bnez a1, .LBB76_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB76_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    bnez a1, .LBB76_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB76_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB76_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB76_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB76_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB76_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB76_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB76_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_1_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB76_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB76_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB76_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB76_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_1_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB76_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB76_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i8_z_1_2(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_z_1_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    bnez a1, .LBB77_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB77_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    bnez a1, .LBB77_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB77_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB77_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB77_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB77_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB77_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB77_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB77_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_1_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB77_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB77_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB77_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB77_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_1_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB77_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB77_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_s_1_2(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_s_1_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    bnez a1, .LBB78_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB78_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    bnez a1, .LBB78_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB78_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB78_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB78_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB78_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB78_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB78_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB78_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_1_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB78_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB78_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB78_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB78_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_1_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB78_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB78_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_z_1_2(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_z_1_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    bnez a1, .LBB79_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB79_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    bnez a1, .LBB79_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB79_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB79_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB79_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB79_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB79_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB79_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB79_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_1_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB79_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB79_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB79_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB79_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_1_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB79_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB79_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i32_z_1_2(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i32_z_1_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    bnez a1, .LBB80_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB80_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lwu a0, 16(a0)
; RV64I-NEXT:    bnez a1, .LBB80_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB80_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB80_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB80_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB80_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB80_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB80_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB80_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_1_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB80_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB80_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB80_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB80_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_1_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB80_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB80_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i32, ptr %addr monotonic, align 4          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i64_1_2(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i64_1_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 0(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a3
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    addi a0, a0, 32
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_load_8
; RV32I-NEXT:    bnez s2, .LBB81_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    mv a1, s0
; RV32I-NEXT:  .LBB81_2: # %entry
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 0(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    ld a0, 32(a0)
; RV64I-NEXT:    bnez a1, .LBB81_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB81_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    addi sp, sp, -16
; RV32I-SFB-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s2, 0(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    mv s0, a3
; RV32I-SFB-NEXT:    mv s1, a2
; RV32I-SFB-NEXT:    mv s2, a1
; RV32I-SFB-NEXT:    addi a0, a0, 32
; RV32I-SFB-NEXT:    li a1, 0
; RV32I-SFB-NEXT:    call __atomic_load_8
; RV32I-SFB-NEXT:    bnez s2, .LBB81_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, s1
; RV32I-SFB-NEXT:  .LBB81_2: # %entry
; RV32I-SFB-NEXT:    bnez s2, .LBB81_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a1, s0
; RV32I-SFB-NEXT:  .LBB81_4: # %entry
; RV32I-SFB-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s2, 0(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    addi sp, sp, 16
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB81_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB81_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_1_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    addi sp, sp, -16
; RV32I-SFBILOAD-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s2, 0(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    mv s0, a3
; RV32I-SFBILOAD-NEXT:    mv s1, a2
; RV32I-SFBILOAD-NEXT:    mv s2, a1
; RV32I-SFBILOAD-NEXT:    addi a0, a0, 32
; RV32I-SFBILOAD-NEXT:    li a1, 0
; RV32I-SFBILOAD-NEXT:    call __atomic_load_8
; RV32I-SFBILOAD-NEXT:    bnez s2, .LBB81_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, s1
; RV32I-SFBILOAD-NEXT:  .LBB81_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez s2, .LBB81_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a1, s0
; RV32I-SFBILOAD-NEXT:  .LBB81_4: # %entry
; RV32I-SFBILOAD-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s2, 0(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    addi sp, sp, 16
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_1_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a0, 32(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB81_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB81_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i64, ptr %addr monotonic, align 8          ; load 64-bit value
  %res = select i1 %x, i64 %val, i64 %b
  ret i64 %res
}

define i64 @test_i8_s_store_64_2(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_64_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a0, 4(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB82_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB82_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_64_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a0, 4(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB82_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB82_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_64_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB82_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB82_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB82_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB82_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_64_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB82_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB82_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store_64_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB82_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB82_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB82_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB82_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_store_64_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB82_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB82_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i8_z_store_64_2(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_64_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a0, 4(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB83_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB83_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_64_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a0, 4(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB83_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB83_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_64_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB83_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB83_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB83_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB83_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_64_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB83_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB83_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store_64_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB83_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB83_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB83_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB83_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_store_64_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a0, 4(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB83_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB83_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i8, ptr %addr monotonic, align 1          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_s_store_64_2(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_64_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a0, 8(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB84_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB84_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_64_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a0, 8(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB84_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB84_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_64_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB84_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB84_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB84_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB84_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_64_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB84_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB84_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store_64_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB84_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB84_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB84_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB84_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_store_64_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB84_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB84_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_z_store_64_2(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_64_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a0, 8(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB85_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB85_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_64_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a0, 8(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB85_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB85_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_64_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB85_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB85_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB85_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB85_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_64_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB85_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB85_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store_64_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB85_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB85_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB85_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB85_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_store_64_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a0, 8(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB85_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB85_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i16, ptr %addr monotonic, align 2          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i32_z_store_64_2(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i32_z_store_64_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a0, 16(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB86_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB86_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_store_64_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lwu a0, 16(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB86_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB86_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_store_64_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB86_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB86_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB86_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB86_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_store_64_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB86_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB86_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_store_64_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a0, 16(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB86_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    li a3, 0
; RV32I-SFBILOAD-NEXT:  .LBB86_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB86_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB86_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBILOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_store_64_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a0, 16(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB86_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB86_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i32, ptr %addr monotonic, align 4          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i64_store_64_2(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i64_store_64_2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s4, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s5, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s2, a6
; RV32I-NEXT:    mv s3, a5
; RV32I-NEXT:    mv s4, a4
; RV32I-NEXT:    mv s0, a3
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s5, a1
; RV32I-NEXT:    addi a0, a0, 32
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_load_8
; RV32I-NEXT:    sw s3, 0(s4)
; RV32I-NEXT:    sw s2, 4(s4)
; RV32I-NEXT:    bnez s5, .LBB87_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    mv a1, s0
; RV32I-NEXT:  .LBB87_2: # %entry
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s4, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s5, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_store_64_2:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    ld a0, 32(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB87_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB87_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_store_64_2:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    addi sp, sp, -32
; RV32I-SFB-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s4, 8(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    sw s5, 4(sp) # 4-byte Folded Spill
; RV32I-SFB-NEXT:    mv s0, a6
; RV32I-SFB-NEXT:    mv s1, a5
; RV32I-SFB-NEXT:    mv s2, a4
; RV32I-SFB-NEXT:    mv s3, a3
; RV32I-SFB-NEXT:    mv s4, a2
; RV32I-SFB-NEXT:    mv s5, a1
; RV32I-SFB-NEXT:    addi a0, a0, 32
; RV32I-SFB-NEXT:    li a1, 0
; RV32I-SFB-NEXT:    call __atomic_load_8
; RV32I-SFB-NEXT:    sw s1, 0(s2)
; RV32I-SFB-NEXT:    bnez s5, .LBB87_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, s4
; RV32I-SFB-NEXT:  .LBB87_2: # %entry
; RV32I-SFB-NEXT:    bnez s5, .LBB87_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a1, s3
; RV32I-SFB-NEXT:  .LBB87_4: # %entry
; RV32I-SFB-NEXT:    sw s0, 4(s2)
; RV32I-SFB-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s4, 8(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    lw s5, 4(sp) # 4-byte Folded Reload
; RV32I-SFB-NEXT:    addi sp, sp, 32
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_store_64_2:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB87_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB87_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_store_64_2:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    addi sp, sp, -32
; RV32I-SFBILOAD-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s4, 8(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    sw s5, 4(sp) # 4-byte Folded Spill
; RV32I-SFBILOAD-NEXT:    mv s0, a6
; RV32I-SFBILOAD-NEXT:    mv s1, a5
; RV32I-SFBILOAD-NEXT:    mv s2, a4
; RV32I-SFBILOAD-NEXT:    mv s3, a3
; RV32I-SFBILOAD-NEXT:    mv s4, a2
; RV32I-SFBILOAD-NEXT:    mv s5, a1
; RV32I-SFBILOAD-NEXT:    addi a0, a0, 32
; RV32I-SFBILOAD-NEXT:    li a1, 0
; RV32I-SFBILOAD-NEXT:    call __atomic_load_8
; RV32I-SFBILOAD-NEXT:    sw s1, 0(s2)
; RV32I-SFBILOAD-NEXT:    bnez s5, .LBB87_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, s4
; RV32I-SFBILOAD-NEXT:  .LBB87_2: # %entry
; RV32I-SFBILOAD-NEXT:    bnez s5, .LBB87_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a1, s3
; RV32I-SFBILOAD-NEXT:  .LBB87_4: # %entry
; RV32I-SFBILOAD-NEXT:    sw s0, 4(s2)
; RV32I-SFBILOAD-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s4, 8(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    lw s5, 4(sp) # 4-byte Folded Reload
; RV32I-SFBILOAD-NEXT:    addi sp, sp, 32
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_store_64_2:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a0, 32(a0)
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB87_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB87_2: # %entry
; RV64I-SFBILOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load atomic i64, ptr %addr monotonic, align 8          ; load 64-bit value
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %val, i64 %b
  ret i64 %res
}

