; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 | FileCheck %s --check-prefixes=RV32I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 | FileCheck %s --check-prefixes=RV64I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+short-forward-branch-opt | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+short-forward-branch-opt | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+short-forward-branch-i-load | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFBILOAD
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+short-forward-branch-i-load | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFBILOAD

define i32 @test_i8_s(ptr %base, i1 %x, i32 %b) {
; RV32I-LABEL: test_i8_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB0_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lb a2, 4(a0)
; RV32I-NEXT:  .LBB0_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB0_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lb a2, 4(a0)
; RV64I-NEXT:  .LBB0_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB0_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB0_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB0_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB0_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB0_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB0_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB0_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB0_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z(ptr %base, i1 %x, i32 %b) {
; RV32I-LABEL: test_i8_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB1_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lbu a2, 4(a0)
; RV32I-NEXT:  .LBB1_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB1_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lbu a2, 4(a0)
; RV64I-NEXT:  .LBB1_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB1_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB1_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB1_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB1_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB1_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB1_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB1_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB1_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s(ptr %base, i1 %x, i32 %b) {
; RV32I-LABEL: test_i16_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB2_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lh a2, 8(a0)
; RV32I-NEXT:  .LBB2_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB2_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lh a2, 8(a0)
; RV64I-NEXT:  .LBB2_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB2_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB2_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB2_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB2_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB2_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB2_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB2_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB2_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z(ptr %base, i1 %x, i32 %b) {
; RV32I-LABEL: test_i16_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB3_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lhu a2, 8(a0)
; RV32I-NEXT:  .LBB3_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB3_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lhu a2, 8(a0)
; RV64I-NEXT:  .LBB3_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB3_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB3_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB3_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB3_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB3_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB3_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB3_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB3_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32(ptr %base, i1 %x, i32 %b) {
; RV32I-LABEL: test_i32:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB4_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lw a2, 16(a0)
; RV32I-NEXT:  .LBB4_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB4_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lw a2, 16(a0)
; RV64I-NEXT:  .LBB4_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB4_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB4_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB4_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB4_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB4_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB4_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB4_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB4_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i64 @test_i8_s_1(ptr %base, i1 %x, i64 %b) {
; RV32I-LABEL: test_i8_s_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB5_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lb a2, 4(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB5_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB5_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lb a2, 4(a0)
; RV64I-NEXT:  .LBB5_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    beqz a1, .LBB5_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB5_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB5_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB5_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB5_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB5_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB5_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB5_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB5_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB5_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB5_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB5_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i8_z_1(ptr %base, i1 %x, i64 %b) {
; RV32I-LABEL: test_i8_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB6_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lbu a2, 4(a0)
; RV32I-NEXT:  .LBB6_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB6_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lbu a2, 4(a0)
; RV64I-NEXT:  .LBB6_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB6_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB6_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB6_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB6_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB6_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB6_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a4, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a4, .LBB6_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB6_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    beqz a4, .LBB6_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a1, 0
; RV32I-SFBILOAD-NEXT:  .LBB6_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB6_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB6_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_s_1(ptr %base, i1 %x, i64 %b) {
; RV32I-LABEL: test_i16_s_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB7_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lh a2, 8(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB7_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB7_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lh a2, 8(a0)
; RV64I-NEXT:  .LBB7_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    beqz a1, .LBB7_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB7_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB7_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB7_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB7_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB7_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB7_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB7_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB7_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB7_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB7_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB7_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_z_1(ptr %base, i1 %x, i64 %b) {
; RV32I-LABEL: test_i16_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB8_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lhu a2, 8(a0)
; RV32I-NEXT:  .LBB8_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB8_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lhu a2, 8(a0)
; RV64I-NEXT:  .LBB8_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB8_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB8_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB8_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB8_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB8_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB8_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a4, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a4, .LBB8_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB8_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    beqz a4, .LBB8_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    li a1, 0
; RV32I-SFBILOAD-NEXT:  .LBB8_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB8_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB8_2: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i64_1(ptr %base, i1 %x, i64 %b) {
; RV32I-LABEL: test_i64_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    beqz a1, .LBB9_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lw a2, 32(a0)
; RV32I-NEXT:    lw a3, 36(a0)
; RV32I-NEXT:  .LBB9_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    beqz a1, .LBB9_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    ld a2, 32(a0)
; RV64I-NEXT:  .LBB9_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a4, 32(a0)
; RV32I-SFB-NEXT:    lw a5, 36(a0)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB9_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a4, a2
; RV32I-SFB-NEXT:  .LBB9_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB9_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a5, a3
; RV32I-SFB-NEXT:  .LBB9_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a4
; RV32I-SFB-NEXT:    mv a1, a5
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB9_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB9_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_1:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB9_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 32(a0)
; RV32I-SFBILOAD-NEXT:  .LBB9_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB9_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 36(a0)
; RV32I-SFBILOAD-NEXT:  .LBB9_4: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    mv a1, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_1:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    ld a0, 32(a0)
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    bnez a1, .LBB9_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    mv a0, a2
; RV64I-SFBILOAD-NEXT:  .LBB9_2: # %entry
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  %res = select i1 %x, i64 %val, i64 %b
  ret i64 %res
}
