# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc -mtriple=riscv32 -mattr=+zilsd -run-pass=greedy,virtregrewriter %s -o - | FileCheck --check-prefix=WITHOUT-HINT %s
# RUN: llc -mtriple=riscv32 -mattr=+zilsd,+zilsd-4byte-align -run-pass=riscv-prera-zilsd-opt,greedy,virtregrewriter %s -o - | FileCheck --check-prefix=WITH-HINT %s

--- |
  define i32 @test_load_pair_hints(ptr %p) {
    %v1 = load i32, ptr %p, align 4
    %p2 = getelementptr inbounds i8, ptr %p, i32 4
    %v2 = load i32, ptr %p2, align 4
    %sum = add i32 %v1, %v2
    ret i32 %sum
  }

  define void @test_store_pair_hints(ptr %p, i32 %a, i32 %b) {
    store i32 %a, ptr %p, align 4
    %p2 = getelementptr inbounds i8, ptr %p, i32 4
    store i32 %b, ptr %p2, align 4
    ret void
  }
...
---
# Test that load pairs get register hints and allocate consecutive registers
# After register allocation, should either keep LD_RV32 or split back to LW
name: test_load_pair_hints
tracksRegLiveness: true
body: |
  bb.0:
    liveins: $x10

    ; WITHOUT-HINT-LABEL: name: test_load_pair_hints
    ; WITHOUT-HINT: liveins: $x10
    ; WITHOUT-HINT-NEXT: {{  $}}
    ; WITHOUT-HINT-NEXT: renamable $x11 = LW renamable $x10, 0 :: (load (s32) from %ir.p)
    ; WITHOUT-HINT-NEXT: renamable $x10 = LW killed renamable $x10, 4 :: (load (s32) from %ir.p2)
    ; WITHOUT-HINT-NEXT: renamable $x10 = ADD killed renamable $x11, killed renamable $x10
    ; WITHOUT-HINT-NEXT: PseudoRET implicit $x10
    ;
    ; WITH-HINT-LABEL: name: test_load_pair_hints
    ; WITH-HINT: liveins: $x10
    ; WITH-HINT-NEXT: {{  $}}
    ; WITH-HINT-NEXT: renamable $x10, renamable $x11 = PseudoLD_RV32_OPT killed renamable $x10, 0 :: (load (s32) from %ir.p), (load (s32) from %ir.p2)
    ; WITH-HINT-NEXT: renamable $x10 = ADD killed renamable $x10, killed renamable $x11
    ; WITH-HINT-NEXT: PseudoRET implicit $x10
    %10:gpr = COPY $x10
    ; These two LW instructions at offset 0 and 4 should be combined
    %0:gpr = LW %10, 0 :: (load (s32) from %ir.p)
    %1:gpr = LW %10, 4 :: (load (s32) from %ir.p2)
    %2:gpr = ADD %0, %1
    $x10 = COPY %2
    PseudoRET implicit $x10

...
---
# Test that store pairs get register hints and allocate consecutive registers
# After register allocation, should either keep SD_RV32 or split back to SW
name: test_store_pair_hints
tracksRegLiveness: true
body: |
  bb.0:
    liveins: $x10, $x11, $x12

    ; WITHOUT-HINT-LABEL: name: test_store_pair_hints
    ; WITHOUT-HINT: liveins: $x10, $x11, $x12
    ; WITHOUT-HINT-NEXT: {{  $}}
    ; WITHOUT-HINT-NEXT: SW killed renamable $x11, renamable $x10, 0 :: (store (s32) into %ir.p)
    ; WITHOUT-HINT-NEXT: SW killed renamable $x12, killed renamable $x10, 4 :: (store (s32) into %ir.p2)
    ; WITHOUT-HINT-NEXT: PseudoRET
    ;
    ; WITH-HINT-LABEL: name: test_store_pair_hints
    ; WITH-HINT: liveins: $x10, $x11, $x12
    ; WITH-HINT-NEXT: {{  $}}
    ; WITH-HINT-NEXT: renamable $x14 = COPY $x11
    ; WITH-HINT-NEXT: renamable $x15 = COPY $x12
    ; WITH-HINT-NEXT: PseudoSD_RV32_OPT killed renamable $x14, killed renamable $x15, killed renamable $x10, 0 :: (store (s32) into %ir.p), (store (s32) into %ir.p2)
    ; WITH-HINT-NEXT: PseudoRET
    %10:gpr = COPY $x10
    %11:gpr = COPY $x11
    %12:gpr = COPY $x12
    ; These two SW instructions at offset 0 and 4 should be combined
    SW %11, %10, 0 :: (store (s32) into %ir.p)
    SW %12, %10, 4 :: (store (s32) into %ir.p2)
    PseudoRET
...
