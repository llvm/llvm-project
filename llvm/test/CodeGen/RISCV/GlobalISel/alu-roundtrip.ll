; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -mattr=+m -global-isel -verify-machineinstrs < %s \
; RUN:   | FileCheck %s --check-prefix=RV32IM
; RUN: llc -mtriple=riscv64 -mattr=+m -global-isel -verify-machineinstrs < %s \
; RUN:   | FileCheck %s --check-prefix=RV64IM

; Extends to 32 bits exhaustively tested for add only.

define i8 @add_i8(i8 %a, i8 %b) {
; RV32IM-LABEL: add_i8:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    add a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: add_i8:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    addw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = add i8 %a, %b
  ret i8 %0
}

define i32 @add_i8_signext_i32(i8 %a, i8 %b) {
; RV32IM-LABEL: add_i8_signext_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    slli a0, a0, 24
; RV32IM-NEXT:    srai a0, a0, 24
; RV32IM-NEXT:    slli a1, a1, 24
; RV32IM-NEXT:    srai a1, a1, 24
; RV32IM-NEXT:    add a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: add_i8_signext_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    li a2, 24
; RV64IM-NEXT:    sllw a0, a0, a2
; RV64IM-NEXT:    sraw a0, a0, a2
; RV64IM-NEXT:    sllw a1, a1, a2
; RV64IM-NEXT:    sraw a1, a1, a2
; RV64IM-NEXT:    addw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = sext i8 %a to i32
  %1 = sext i8 %b to i32
  %2 = add i32 %0, %1
  ret i32 %2
}

define i32 @add_i8_zeroext_i32(i8 %a, i8 %b) {
; RV32IM-LABEL: add_i8_zeroext_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    andi a0, a0, 255
; RV32IM-NEXT:    andi a1, a1, 255
; RV32IM-NEXT:    add a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: add_i8_zeroext_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    andi a0, a0, 255
; RV64IM-NEXT:    andi a1, a1, 255
; RV64IM-NEXT:    addw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = zext i8 %a to i32
  %1 = zext i8 %b to i32
  %2 = add i32 %0, %1
  ret i32 %2
}

; TODO: Handle G_IMPLICIT_DEF, which is needed to have i8 -> i64 extends working
; on RV32.

define i32 @add_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: add_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    add a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: add_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    addw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = add i32 %a, %b
  ret i32 %0
}

define i32 @sub_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: sub_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    sub a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: sub_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    subw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = sub i32 %a, %b
  ret i32 %0
}

define i32 @shl_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: shl_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    sll a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: shl_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    sllw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = shl i32 %a, %b
  ret i32 %0
}

define i32 @ashr_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: ashr_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    sra a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: ashr_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    sraw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = ashr i32 %a, %b
  ret i32 %0
}

define i32 @lshr_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: lshr_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    srl a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: lshr_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    srlw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = lshr i32 %a, %b
  ret i32 %0
}

define i32 @and_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: and_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    and a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: and_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    and a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = and i32 %a, %b
  ret i32 %0
}

define i32 @or_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: or_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    or a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: or_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    or a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = or i32 %a, %b
  ret i32 %0
}

define i32 @xor_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: xor_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    xor a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: xor_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    xor a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = xor i32 %a, %b
  ret i32 %0
}

define i32 @mul_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: mul_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    mul a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: mul_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    mulw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = mul i32 %a, %b
  ret i32 %0
}

define i32 @sdiv_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: sdiv_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    div a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: sdiv_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    divw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = sdiv i32 %a, %b
  ret i32 %0
}

define i32 @srem_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: srem_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    rem a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: srem_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    remw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = srem i32 %a, %b
  ret i32 %0
}

define i32 @udiv_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: udiv_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    divu a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: udiv_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    divuw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = udiv i32 %a, %b
  ret i32 %0
}

define i32 @urem_i32(i32 %a, i32 %b) {
; RV32IM-LABEL: urem_i32:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    remu a0, a0, a1
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: urem_i32:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    remuw a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = urem i32 %a, %b
  ret i32 %0
}

define i64 @add_i64(i64 %a, i64 %b) {
; RV32IM-LABEL: add_i64:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    add a0, a0, a2
; RV32IM-NEXT:    sltu a2, a0, a2
; RV32IM-NEXT:    add a1, a1, a3
; RV32IM-NEXT:    andi a2, a2, 1
; RV32IM-NEXT:    add a1, a1, a2
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: add_i64:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    add a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = add i64 %a, %b
  ret i64 %0
}

define i64 @sub_i64(i64 %a, i64 %b) {
; RV32IM-LABEL: sub_i64:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    sub a4, a0, a2
; RV32IM-NEXT:    sltu a0, a0, a2
; RV32IM-NEXT:    sub a1, a1, a3
; RV32IM-NEXT:    andi a0, a0, 1
; RV32IM-NEXT:    sub a1, a1, a0
; RV32IM-NEXT:    mv a0, a4
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: sub_i64:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    sub a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = sub i64 %a, %b
  ret i64 %0
}

; TODO: Handle G_SELECT, which is needed to have i64 shifts working on RV32.

define i64 @and_i64(i64 %a, i64 %b) {
; RV32IM-LABEL: and_i64:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    and a0, a0, a2
; RV32IM-NEXT:    and a1, a1, a3
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: and_i64:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    and a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = and i64 %a, %b
  ret i64 %0
}

define i64 @or_i64(i64 %a, i64 %b) {
; RV32IM-LABEL: or_i64:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    or a0, a0, a2
; RV32IM-NEXT:    or a1, a1, a3
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: or_i64:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    or a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = or i64 %a, %b
  ret i64 %0
}

define i64 @xor_i64(i64 %a, i64 %b) {
; RV32IM-LABEL: xor_i64:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    xor a0, a0, a2
; RV32IM-NEXT:    xor a1, a1, a3
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: xor_i64:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    xor a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = xor i64 %a, %b
  ret i64 %0
}

define i64 @mul_i64(i64 %a, i64 %b) {
; RV32IM-LABEL: mul_i64:
; RV32IM:       # %bb.0: # %entry
; RV32IM-NEXT:    mul a4, a0, a2
; RV32IM-NEXT:    mul a1, a1, a2
; RV32IM-NEXT:    mul a3, a0, a3
; RV32IM-NEXT:    mulhu a0, a0, a2
; RV32IM-NEXT:    add a1, a1, a3
; RV32IM-NEXT:    add a1, a1, a0
; RV32IM-NEXT:    mv a0, a4
; RV32IM-NEXT:    ret
;
; RV64IM-LABEL: mul_i64:
; RV64IM:       # %bb.0: # %entry
; RV64IM-NEXT:    mul a0, a0, a1
; RV64IM-NEXT:    ret
entry:
  %0 = mul i64 %a, %b
  ret i64 %0
}

; TODO: Handle G_SDIV, G_SREM, G_UDIV, G_UREM for i64 on RV32. Likely will be
; dispatched to a libcall?
