; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -mattr=+zbc -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=RV32ZBC
; RUN: llc -mtriple=riscv32 -mattr=+zbkc -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=RV32ZBC
; RUN: llc -mtriple=riscv64 -mattr=+zbc -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=RV64ZBC
; RUN: llc -mtriple=riscv64 -mattr=+zbkc -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=RV64ZBC

; Test generic llvm.clmul intrinsic

declare i8 @llvm.clmul.i8(i8 %a, i8 %b)
declare i16 @llvm.clmul.i16(i16 %a, i16 %b)  
declare i32 @llvm.clmul.i32(i32 %a, i32 %b)
declare i64 @llvm.clmul.i64(i64 %a, i64 %b)

define i8 @clmul_i8(i8 %a, i8 %b) nounwind {
; RV32ZBC-LABEL: clmul_i8:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    clmul a0, a0, a1
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i8:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    clmul a0, a0, a1
; RV64ZBC-NEXT:    ret
  %result = call i8 @llvm.clmul.i8(i8 %a, i8 %b)
  ret i8 %result
}

define i16 @clmul_i16(i16 %a, i16 %b) nounwind {
; RV32ZBC-LABEL: clmul_i16:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    clmul a0, a0, a1
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i16:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    clmul a0, a0, a1
; RV64ZBC-NEXT:    ret
  %result = call i16 @llvm.clmul.i16(i16 %a, i16 %b)
  ret i16 %result
}

define i32 @clmul_i32(i32 %a, i32 %b) nounwind {
; RV32ZBC-LABEL: clmul_i32:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    clmul a0, a0, a1
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i32:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    clmul a0, a0, a1
; RV64ZBC-NEXT:    ret
  %result = call i32 @llvm.clmul.i32(i32 %a, i32 %b)
  ret i32 %result
}

define i64 @clmul_i64_rv32(i64 %a, i64 %b) nounwind {
; RV32ZBC-LABEL: clmul_i64_rv32:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    addi sp, sp, -16
; RV32ZBC-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32ZBC-NEXT:    call __clmuldi3
; RV32ZBC-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32ZBC-NEXT:    addi sp, sp, 16
; RV32ZBC-NEXT:    ret
  %result = call i64 @llvm.clmul.i64(i64 %a, i64 %b)
  ret i64 %result
}

define i64 @clmul_i64_rv64(i64 %a, i64 %b) nounwind {
; RV64ZBC-LABEL: clmul_i64_rv64:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    clmul a0, a0, a1
; RV64ZBC-NEXT:    ret
  %result = call i64 @llvm.clmul.i64(i64 %a, i64 %b)
  ret i64 %result
}

; Test with constants
define i32 @clmul_i32_const() nounwind {
; RV32ZBC-LABEL: clmul_i32_const:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    li a0, 14
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i32_const:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    li a0, 14
; RV64ZBC-NEXT:    ret
  %result = call i32 @llvm.clmul.i32(i32 5, i32 6)
  ret i32 %result
}

; Test with zero operands
define i32 @clmul_i32_zero_left(i32 %b) nounwind {
; RV32ZBC-LABEL: clmul_i32_zero_left:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    li a0, 0
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i32_zero_left:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    li a0, 0
; RV64ZBC-NEXT:    ret
  %result = call i32 @llvm.clmul.i32(i32 0, i32 %b)
  ret i32 %result
}

define i32 @clmul_i32_zero_right(i32 %a) nounwind {
; RV32ZBC-LABEL: clmul_i32_zero_right:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    li a0, 0
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i32_zero_right:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    li a0, 0
; RV64ZBC-NEXT:    ret
  %result = call i32 @llvm.clmul.i32(i32 %a, i32 0)
  ret i32 %result
}

; Test with identity (multiplying by 1)
define i32 @clmul_i32_identity_left(i32 %a) nounwind {
; RV32ZBC-LABEL: clmul_i32_identity_left:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i32_identity_left:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    ret
  %result = call i32 @llvm.clmul.i32(i32 1, i32 %a)
  ret i32 %result
}

define i32 @clmul_i32_identity_right(i32 %a) nounwind {
; RV32ZBC-LABEL: clmul_i32_identity_right:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i32_identity_right:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    ret
  %result = call i32 @llvm.clmul.i32(i32 %a, i32 1)
  ret i32 %result
}

; Test commutativity
define i32 @clmul_i32_commutative(i32 %a, i32 %b) nounwind {
; RV32ZBC-LABEL: clmul_i32_commutative:
; RV32ZBC:       # %bb.0:
; RV32ZBC-NEXT:    clmul a0, a0, a1
; RV32ZBC-NEXT:    ret
;
; RV64ZBC-LABEL: clmul_i32_commutative:
; RV64ZBC:       # %bb.0:
; RV64ZBC-NEXT:    clmul a0, a0, a1
; RV64ZBC-NEXT:    ret
  %result1 = call i32 @llvm.clmul.i32(i32 %a, i32 %b)
  %result2 = call i32 @llvm.clmul.i32(i32 %b, i32 %a)
  %xor = xor i32 %result1, %result2
  ret i32 %xor
}