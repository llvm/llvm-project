; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: sed 's/iXLen/i32/g' %s | llc -mtriple=riscv32 -mattr=+v -verify-machineinstrs | FileCheck %s --check-prefixes=CHECK,RV32
; RUN: sed 's/iXLen/i32/g' %s | llc -mtriple=riscv64 -mattr=+v -verify-machineinstrs | FileCheck %s --check-prefixes=CHECK,RV64

declare i32 @llvm.experimental.get.vector.length.i16(i16, i32, i1)
declare i32 @llvm.experimental.get.vector.length.i32(i32, i32, i1)
declare i32 @llvm.experimental.get.vector.length.i64(i64, i32, i1)

define i32 @vector_length_i16(i16 zeroext %tc) {
; CHECK-LABEL: vector_length_i16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a1, vlenb
; CHECK-NEXT:    srli a1, a1, 2
; CHECK-NEXT:    bltu a0, a1, .LBB0_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    mv a0, a1
; CHECK-NEXT:  .LBB0_2:
; CHECK-NEXT:    ret
  %a = call i32 @llvm.experimental.get.vector.length.i16(i16 %tc, i32 2, i1 true)
  ret i32 %a
}

define i32 @vector_length_i32(i32 zeroext %tc) {
; RV32-LABEL: vector_length_i32:
; RV32:       # %bb.0:
; RV32-NEXT:    csrr a1, vlenb
; RV32-NEXT:    srli a1, a1, 2
; RV32-NEXT:    bltu a0, a1, .LBB1_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:  .LBB1_2:
; RV32-NEXT:    ret
;
; RV64-LABEL: vector_length_i32:
; RV64:       # %bb.0:
; RV64-NEXT:    sext.w a0, a0
; RV64-NEXT:    csrr a1, vlenb
; RV64-NEXT:    srli a1, a1, 2
; RV64-NEXT:    bltu a0, a1, .LBB1_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:  .LBB1_2:
; RV64-NEXT:    ret
  %a = call i32 @llvm.experimental.get.vector.length.i32(i32 %tc, i32 2, i1 true)
  ret i32 %a
}

define i32 @vector_length_XLen(iXLen zeroext %tc) {
; RV32-LABEL: vector_length_XLen:
; RV32:       # %bb.0:
; RV32-NEXT:    csrr a1, vlenb
; RV32-NEXT:    srli a1, a1, 2
; RV32-NEXT:    bltu a0, a1, .LBB2_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:  .LBB2_2:
; RV32-NEXT:    ret
;
; RV64-LABEL: vector_length_XLen:
; RV64:       # %bb.0:
; RV64-NEXT:    sext.w a0, a0
; RV64-NEXT:    csrr a1, vlenb
; RV64-NEXT:    srli a1, a1, 2
; RV64-NEXT:    bltu a0, a1, .LBB2_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:  .LBB2_2:
; RV64-NEXT:    ret
  %a = call i32 @llvm.experimental.get.vector.length.iXLen(iXLen %tc, i32 2, i1 true)
  ret i32 %a
}

define i32 @vector_length_i16_fixed(i16 zeroext %tc) {
; CHECK-LABEL: vector_length_i16_fixed:
; CHECK:       # %bb.0:
; CHECK-NEXT:    li a1, 2
; CHECK-NEXT:    bltu a0, a1, .LBB3_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    li a0, 2
; CHECK-NEXT:  .LBB3_2:
; CHECK-NEXT:    ret
  %a = call i32 @llvm.experimental.get.vector.length.i16(i16 %tc, i32 2, i1 false)
  ret i32 %a
}

define i32 @vector_length_i32_fixed(i32 zeroext %tc) {
; RV32-LABEL: vector_length_i32_fixed:
; RV32:       # %bb.0:
; RV32-NEXT:    li a1, 2
; RV32-NEXT:    bltu a0, a1, .LBB4_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    li a0, 2
; RV32-NEXT:  .LBB4_2:
; RV32-NEXT:    ret
;
; RV64-LABEL: vector_length_i32_fixed:
; RV64:       # %bb.0:
; RV64-NEXT:    sext.w a0, a0
; RV64-NEXT:    li a1, 2
; RV64-NEXT:    bltu a0, a1, .LBB4_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    li a0, 2
; RV64-NEXT:  .LBB4_2:
; RV64-NEXT:    ret
  %a = call i32 @llvm.experimental.get.vector.length.i32(i32 %tc, i32 2, i1 false)
  ret i32 %a
}

define i32 @vector_length_XLen_fixed(iXLen zeroext %tc) {
; RV32-LABEL: vector_length_XLen_fixed:
; RV32:       # %bb.0:
; RV32-NEXT:    li a1, 2
; RV32-NEXT:    bltu a0, a1, .LBB5_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    li a0, 2
; RV32-NEXT:  .LBB5_2:
; RV32-NEXT:    ret
;
; RV64-LABEL: vector_length_XLen_fixed:
; RV64:       # %bb.0:
; RV64-NEXT:    sext.w a0, a0
; RV64-NEXT:    li a1, 2
; RV64-NEXT:    bltu a0, a1, .LBB5_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    li a0, 2
; RV64-NEXT:  .LBB5_2:
; RV64-NEXT:    ret
  %a = call i32 @llvm.experimental.get.vector.length.iXLen(iXLen %tc, i32 2, i1 false)
  ret i32 %a
}
