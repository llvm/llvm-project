; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=riscv64 -mattr=+v -verify-machineinstrs | FileCheck %s

; Use cttz to test if we properly prove never-zero. There is a very
; simple transform from cttz -> cttz_zero_undef if its operand is
; known never zero.

; Even without vscale_range, vscale is always guaranteed to be non-zero.
define i32 @vscale_known_nonzero() {
; CHECK-LABEL: vscale_known_nonzero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    csrr a0, vlenb
; CHECK-NEXT:    srli a1, a0, 3
; CHECK-NEXT:    slli a2, a0, 1
; CHECK-NEXT:    slli a3, a0, 3
; CHECK-NEXT:    slli a4, a0, 5
; CHECK-NEXT:    slli a5, a0, 7
; CHECK-NEXT:    sub a1, a1, a2
; CHECK-NEXT:    slli a2, a0, 9
; CHECK-NEXT:    add a3, a3, a4
; CHECK-NEXT:    slli a4, a0, 13
; CHECK-NEXT:    sub a5, a5, a2
; CHECK-NEXT:    slli a2, a0, 15
; CHECK-NEXT:    sub a4, a4, a2
; CHECK-NEXT:    add a1, a1, a3
; CHECK-NEXT:    slli a2, a0, 11
; CHECK-NEXT:    sub a5, a5, a2
; CHECK-NEXT:    slli a2, a0, 20
; CHECK-NEXT:    sub a4, a4, a2
; CHECK-NEXT:    slli a0, a0, 24
; CHECK-NEXT:    add a1, a1, a5
; CHECK-NEXT:    add a0, a4, a0
; CHECK-NEXT:    add a0, a1, a0
; CHECK-NEXT:    srliw a0, a0, 27
; CHECK-NEXT:    lui a1, %hi(.LCPI0_0)
; CHECK-NEXT:    addi a1, a1, %lo(.LCPI0_0)
; CHECK-NEXT:    add a0, a1, a0
; CHECK-NEXT:    lbu a0, 0(a0)
; CHECK-NEXT:    ret
  %x = call i32 @llvm.vscale()
  %r = call i32 @llvm.cttz.i32(i32 %x, i1 false)
  ret i32 %r
}
