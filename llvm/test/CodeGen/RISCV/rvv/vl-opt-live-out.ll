; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=riscv64 -mattr=+v -verify-machineinstrs < %s | FileCheck %s

define i32 @loop_live_out(ptr %p, i64 %n) {
; CHECK-LABEL: loop_live_out:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mv a2, a0
; CHECK-NEXT:  .LBB0_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    vsetvli a3, a1, e32, m2, ta, ma
; CHECK-NEXT:    vle32.v v8, (a2)
; CHECK-NEXT:    sub a1, a1, a3
; CHECK-NEXT:    vadd.vi v8, v8, 1
; CHECK-NEXT:    vse32.v v8, (a2)
; CHECK-NEXT:    slli a2, a3, 2
; CHECK-NEXT:    add a2, a0, a2
; CHECK-NEXT:    bnez a1, .LBB0_1
; CHECK-NEXT:  # %bb.2: # %exit
; CHECK-NEXT:    addi a3, a3, -1
; CHECK-NEXT:    vsetivli zero, 1, e32, m2, ta, ma
; CHECK-NEXT:    vslidedown.vx v8, v8, a3
; CHECK-NEXT:    vmv.x.s a0, v8
; CHECK-NEXT:    ret
entry:
  br label %loop

loop:
  %avl = phi i64 [%n, %entry], [%avl.next, %loop]
  %gep = phi ptr [%p, %entry], [%gep.next, %loop]
  %vl = call i32 @llvm.experimental.get.vector.length(i64 %avl, i32 4, i1 true)
  %x = call <vscale x 4 x i32> @llvm.vp.load(ptr %gep, <vscale x 4 x i1> splat (i1 true), i32 %vl)
  %y = add <vscale x 4 x i32> %x, splat (i32 1)
  call void @llvm.vp.store(<vscale x 4 x i32> %y, ptr %gep, <vscale x 4 x i1> splat (i1 true), i32 %vl)
  %vl.zext = zext i32 %vl to i64
  %avl.next = sub i64 %avl, %vl.zext
  %gep.next = getelementptr i32, ptr %p, i32 %vl
  %ec = icmp eq i64 %avl.next, 0
  br i1 %ec, label %exit, label %loop

exit:
  %lastidx = sub i64 %vl.zext, 1
  %lastelt = extractelement <vscale x 4 x i32> %y, i64 %lastidx
  ret i32 %lastelt
}
