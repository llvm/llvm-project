# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 4
# RUN: llc -mtriple=riscv64 -mattr=+v -verify-machineinstrs -run-pass=machine-cse -o - %s | FileCheck %s

# FIXME: MachineCSE propagates the copy of %mask to %pt, since the tied-def
# means we will end up constraining the def to vmv0. This results in an
# unallocatable instruction where we have to allocate two vmv0 registers because
# of the early clobber, but vmv0 only has one register available (v0):
#
# %mask:vmv0 = COPY $v0
# %res:vmv0 = COPY %mask
# early-clobber %res:vmv0 = PseudoVMSNE_VV_M2_MASK %res, $noreg, $noreg, %mask, $noreg, 3 /* e8 */, implicit $vl, implicit $vtype

---
name: early_clobber_tied_def
body: |
  bb.0:
    liveins: $v0
    ; CHECK-LABEL: name: early_clobber_tied_def
    ; CHECK: liveins: $v0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: %mask:vmv0 = COPY $v0
    ; CHECK-NEXT: early-clobber %res:vr = PseudoVMSEQ_VV_M2_MASK %mask, $noreg, $noreg, %mask, $noreg, 3 /* e8 */, implicit $vl, implicit $vtype
    ; CHECK-NEXT: $v0 = COPY %res
    ; CHECK-NEXT: PseudoRET implicit $v0
    %mask:vmv0 = COPY $v0
    %pt:vr = COPY %mask
    %res:vr = PseudoVMSEQ_VV_M2_MASK %pt:vr, $noreg, $noreg, %mask:vmv0, $noreg, 3, implicit $vl, implicit $vtype
    $v0 = COPY %res:vr
    PseudoRET implicit $v0
