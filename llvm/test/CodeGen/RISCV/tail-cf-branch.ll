; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV32I %s
; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV64I %s
; RUN: llc -code-model=large -mtriple=riscv32 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV32I-LARGE %s
; RUN: llc -code-model=large -mtriple=riscv64 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV64I-LARGE %s

; Test tail call generation with cf-protection-branch enabled.
; This tests landing pad generation and NonX7 variants for indirect tail calls.

declare i32 @callee_tail(i32 %i)

define i32 @caller_tail(i32 %i) nounwind {
; RV32I-LABEL: caller_tail:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lpad 0
; RV32I-NEXT:    tail callee_tail
;
; RV64I-LABEL: caller_tail:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lpad 0
; RV64I-NEXT:    tail callee_tail
;
; RV32I-LARGE-LABEL: caller_tail:
; RV32I-LARGE:       # %bb.0: # %entry
; RV32I-LARGE-NEXT:    lpad 0
; RV32I-LARGE-NEXT:  .Lpcrel_hi0:
; RV32I-LARGE-NEXT:    auipc a1, %pcrel_hi(.LCPI0_0)
; RV32I-LARGE-NEXT:    lw t2, %pcrel_lo(.Lpcrel_hi0)(a1)
; RV32I-LARGE-NEXT:    jr t2
;
; RV64I-LARGE-LABEL: caller_tail:
; RV64I-LARGE:       # %bb.0: # %entry
; RV64I-LARGE-NEXT:    lpad 0
; RV64I-LARGE-NEXT:  .Lpcrel_hi0:
; RV64I-LARGE-NEXT:    auipc a1, %pcrel_hi(.LCPI0_0)
; RV64I-LARGE-NEXT:    ld t2, %pcrel_lo(.Lpcrel_hi0)(a1)
; RV64I-LARGE-NEXT:    jr t2
entry:
  %r = tail call i32 @callee_tail(i32 %i)
  ret i32 %r
}

@dest = global [2 x i8] zeroinitializer

define void @caller_extern(ptr %src) optsize {
; RV32I-LABEL: caller_extern:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lpad 0
; RV32I-NEXT:    lui a1, %hi(dest)
; RV32I-NEXT:    addi a1, a1, %lo(dest)
; RV32I-NEXT:    li a2, 7
; RV32I-NEXT:    mv a3, a0
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    tail memcpy
;
; RV64I-LABEL: caller_extern:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lpad 0
; RV64I-NEXT:    lui a1, %hi(dest)
; RV64I-NEXT:    addi a1, a1, %lo(dest)
; RV64I-NEXT:    li a2, 7
; RV64I-NEXT:    mv a3, a0
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    mv a1, a3
; RV64I-NEXT:    tail memcpy
;
; RV32I-LARGE-LABEL: caller_extern:
; RV32I-LARGE:       # %bb.0: # %entry
; RV32I-LARGE-NEXT:    lpad 0
; RV32I-LARGE-NEXT:  .Lpcrel_hi1:
; RV32I-LARGE-NEXT:    auipc a1, %pcrel_hi(.LCPI1_0)
; RV32I-LARGE-NEXT:  .Lpcrel_hi2:
; RV32I-LARGE-NEXT:    auipc a2, %pcrel_hi(.LCPI1_1)
; RV32I-LARGE-NEXT:    lw a1, %pcrel_lo(.Lpcrel_hi1)(a1)
; RV32I-LARGE-NEXT:    lw t2, %pcrel_lo(.Lpcrel_hi2)(a2)
; RV32I-LARGE-NEXT:    li a2, 7
; RV32I-LARGE-NEXT:    mv a3, a0
; RV32I-LARGE-NEXT:    mv a0, a1
; RV32I-LARGE-NEXT:    mv a1, a3
; RV32I-LARGE-NEXT:    jr t2
;
; RV64I-LARGE-LABEL: caller_extern:
; RV64I-LARGE:       # %bb.0: # %entry
; RV64I-LARGE-NEXT:    lpad 0
; RV64I-LARGE-NEXT:  .Lpcrel_hi1:
; RV64I-LARGE-NEXT:    auipc a1, %pcrel_hi(.LCPI1_0)
; RV64I-LARGE-NEXT:  .Lpcrel_hi2:
; RV64I-LARGE-NEXT:    auipc a2, %pcrel_hi(.LCPI1_1)
; RV64I-LARGE-NEXT:    ld a1, %pcrel_lo(.Lpcrel_hi1)(a1)
; RV64I-LARGE-NEXT:    ld t2, %pcrel_lo(.Lpcrel_hi2)(a2)
; RV64I-LARGE-NEXT:    li a2, 7
; RV64I-LARGE-NEXT:    mv a3, a0
; RV64I-LARGE-NEXT:    mv a0, a1
; RV64I-LARGE-NEXT:    mv a1, a3
; RV64I-LARGE-NEXT:    jr t2
entry:
  tail call void @llvm.memcpy.p0.p0.i32(ptr @dest, ptr %src, i32 7, i1 false)
  ret void
}

declare void @llvm.memcpy.p0.p0.i32(ptr, ptr, i32, i1)

; Indirect tail call
declare void @callee_indirect1()
declare void @callee_indirect2()

define void @caller_indirect_tail(i32 %a) nounwind {
; RV32I-LABEL: caller_indirect_tail:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lpad 0
; RV32I-NEXT:    beqz a0, .LBB2_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lui t1, %hi(callee_indirect2)
; RV32I-NEXT:    addi t1, t1, %lo(callee_indirect2)
; RV32I-NEXT:    jr t1
; RV32I-NEXT:  .LBB2_2:
; RV32I-NEXT:    lui t1, %hi(callee_indirect1)
; RV32I-NEXT:    addi t1, t1, %lo(callee_indirect1)
; RV32I-NEXT:    jr t1
;
; RV64I-LABEL: caller_indirect_tail:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lpad 0
; RV64I-NEXT:    sext.w a0, a0
; RV64I-NEXT:    beqz a0, .LBB2_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui t1, %hi(callee_indirect2)
; RV64I-NEXT:    addi t1, t1, %lo(callee_indirect2)
; RV64I-NEXT:    jr t1
; RV64I-NEXT:  .LBB2_2:
; RV64I-NEXT:    lui t1, %hi(callee_indirect1)
; RV64I-NEXT:    addi t1, t1, %lo(callee_indirect1)
; RV64I-NEXT:    jr t1
;
; RV32I-LARGE-LABEL: caller_indirect_tail:
; RV32I-LARGE:       # %bb.0: # %entry
; RV32I-LARGE-NEXT:    lpad 0
; RV32I-LARGE-NEXT:    beqz a0, .LBB2_2
; RV32I-LARGE-NEXT:  # %bb.1: # %entry
; RV32I-LARGE-NEXT:  .Lpcrel_hi4:
; RV32I-LARGE-NEXT:    auipc a0, %pcrel_hi(.LCPI2_0)
; RV32I-LARGE-NEXT:    lw t1, %pcrel_lo(.Lpcrel_hi4)(a0)
; RV32I-LARGE-NEXT:    jr t1
; RV32I-LARGE-NEXT:  .LBB2_2:
; RV32I-LARGE-NEXT:  .Lpcrel_hi3:
; RV32I-LARGE-NEXT:    auipc a0, %pcrel_hi(.LCPI2_1)
; RV32I-LARGE-NEXT:    lw t1, %pcrel_lo(.Lpcrel_hi3)(a0)
; RV32I-LARGE-NEXT:    jr t1
;
; RV64I-LARGE-LABEL: caller_indirect_tail:
; RV64I-LARGE:       # %bb.0: # %entry
; RV64I-LARGE-NEXT:    lpad 0
; RV64I-LARGE-NEXT:    sext.w a0, a0
; RV64I-LARGE-NEXT:    beqz a0, .LBB2_2
; RV64I-LARGE-NEXT:  # %bb.1: # %entry
; RV64I-LARGE-NEXT:  .Lpcrel_hi4:
; RV64I-LARGE-NEXT:    auipc a0, %pcrel_hi(.LCPI2_0)
; RV64I-LARGE-NEXT:    ld t1, %pcrel_lo(.Lpcrel_hi4)(a0)
; RV64I-LARGE-NEXT:    jr t1
; RV64I-LARGE-NEXT:  .LBB2_2:
; RV64I-LARGE-NEXT:  .Lpcrel_hi3:
; RV64I-LARGE-NEXT:    auipc a0, %pcrel_hi(.LCPI2_1)
; RV64I-LARGE-NEXT:    ld t1, %pcrel_lo(.Lpcrel_hi3)(a0)
; RV64I-LARGE-NEXT:    jr t1
entry:
  %tobool = icmp eq i32 %a, 0
  %callee = select i1 %tobool, ptr @callee_indirect1, ptr @callee_indirect2
  tail call void %callee()
  ret void
}

; Make sure we don't use t0 as the source for jr as that is a hint to pop the
; return address stack on some microarchitectures.
define i32 @caller_indirect_no_t0(ptr %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7) nounwind {
; RV32I-LABEL: caller_indirect_no_t0:
; RV32I:       # %bb.0:
; RV32I-NEXT:    lpad 0
; RV32I-NEXT:    mv t1, a0
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    mv a1, a2
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    mv a3, a4
; RV32I-NEXT:    mv a4, a5
; RV32I-NEXT:    mv a5, a6
; RV32I-NEXT:    mv a6, a7
; RV32I-NEXT:    jr t1
;
; RV64I-LABEL: caller_indirect_no_t0:
; RV64I:       # %bb.0:
; RV64I-NEXT:    lpad 0
; RV64I-NEXT:    mv t1, a0
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    mv a1, a2
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    mv a3, a4
; RV64I-NEXT:    mv a4, a5
; RV64I-NEXT:    mv a5, a6
; RV64I-NEXT:    mv a6, a7
; RV64I-NEXT:    jr t1
;
; RV32I-LARGE-LABEL: caller_indirect_no_t0:
; RV32I-LARGE:       # %bb.0:
; RV32I-LARGE-NEXT:    lpad 0
; RV32I-LARGE-NEXT:    mv t1, a0
; RV32I-LARGE-NEXT:    mv a0, a1
; RV32I-LARGE-NEXT:    mv a1, a2
; RV32I-LARGE-NEXT:    mv a2, a3
; RV32I-LARGE-NEXT:    mv a3, a4
; RV32I-LARGE-NEXT:    mv a4, a5
; RV32I-LARGE-NEXT:    mv a5, a6
; RV32I-LARGE-NEXT:    mv a6, a7
; RV32I-LARGE-NEXT:    jr t1
;
; RV64I-LARGE-LABEL: caller_indirect_no_t0:
; RV64I-LARGE:       # %bb.0:
; RV64I-LARGE-NEXT:    lpad 0
; RV64I-LARGE-NEXT:    mv t1, a0
; RV64I-LARGE-NEXT:    mv a0, a1
; RV64I-LARGE-NEXT:    mv a1, a2
; RV64I-LARGE-NEXT:    mv a2, a3
; RV64I-LARGE-NEXT:    mv a3, a4
; RV64I-LARGE-NEXT:    mv a4, a5
; RV64I-LARGE-NEXT:    mv a5, a6
; RV64I-LARGE-NEXT:    mv a6, a7
; RV64I-LARGE-NEXT:    jr t1
  %9 = tail call i32 %0(i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7)
  ret i32 %9
}

!llvm.module.flags = !{!0}
!0 = !{i32 8, !"cf-protection-branch", i32 1}
