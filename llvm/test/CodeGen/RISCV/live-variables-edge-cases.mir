# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=riscv64 -riscv-enable-live-variables -verify-machineinstrs -o - %s | FileCheck %s
#
# Test live variable analysis edge cases and special scenarios
# Including: dead code, unreachable blocks, critical edges, and complex phi nodes

--- |
  define i64 @test_dead_code(i64 %a, i64 %b) {
  entry:
    %dead = add i64 %a, %b
    ret i64 %a
  }

  define i64 @test_critical_edge(i64 %a, i64 %b, i64 %c) {
  entry:
    %cmp1 = icmp sgt i64 %a, 0
    br i1 %cmp1, label %then, label %check2

  check2:
    %cmp2 = icmp sgt i64 %b, 0
    br i1 %cmp2, label %then, label %else

  then:
    %mul = mul i64 %a, %b
    br label %end

  else:
    %sub = sub i64 %a, %c
    br label %end

  end:
    %result = phi i64 [ %mul, %then ], [ %sub, %else ]
    ret i64 %result
  }

  define i64 @test_complex_phi(i64 %a, i64 %b, i64 %c, i64 %d) {
  entry:
    %cmp1 = icmp sgt i64 %a, 0
    br i1 %cmp1, label %path1, label %path2

  path1:
    %v1 = add i64 %a, %b
    br label %merge

  path2:
    %cmp2 = icmp sgt i64 %c, 0
    br i1 %cmp2, label %path2a, label %path2b

  path2a:
    %v2a = mul i64 %c, %d
    br label %merge

  path2b:
    %v2b = sub i64 %c, %d
    br label %merge

  merge:
    %result = phi i64 [ %v1, %path1 ], [ %v2a, %path2a ], [ %v2b, %path2b ]
    ret i64 %result
  }

  define i64 @test_use_after_def(i64 %a) {
  entry:
    %v1 = add i64 %a, 1
    %v2 = add i64 %v1, 2
    %v3 = add i64 %v2, 3
    %v4 = add i64 %v1, %v3
    ret i64 %v4
  }

  define i64 @test_implicit_defs(i64 %a, i64 %b) {
  entry:
    %div = sdiv i64 %a, %b
    %rem = srem i64 %a, %b
    %sum = add i64 %div, %rem
    ret i64 %sum
  }
...
---
name:            test_dead_code
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_dead_code
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11
    ; %2 is dead - never used, should not affect liveness of inputs

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    ; Dead instruction - result never used
    %2:gpr = ADD %0, %1
    ; Only %0 should be live here
    $x10 = COPY %0
    PseudoRET implicit $x10
...
---
name:            test_critical_edge
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
  - { reg: '$x12', virtual-reg: '%2' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11, $x12
    ; CHECK-LABEL: name: test_critical_edge
    ; CHECK: bb.0.entry:

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    %2:gpr = COPY $x12
    %3:gpr = SLTI %0, 1
    BEQ %3, $x0, %bb.2

  bb.1.check2:
    ; CHECK: bb.1.check2:
    ; %0, %1, %2 should all be live-in

    %4:gpr = SLTI %1, 1
    BEQ %4, $x0, %bb.3

  bb.2.then:
    ; CHECK: bb.2.then:
    ; %0, %1 should be live-in (used in mul)

    %5:gpr = MUL %0, %1
    PseudoBR %bb.4

  bb.3.else:
    ; CHECK: bb.3.else:
    ; %0, %2 should be live-in (used in sub)

    %6:gpr = SUB %0, %2
    PseudoBR %bb.4

  bb.4.end:
    ; CHECK: bb.4.end:
    ; Either %5 or %6 should be live-in

    %7:gpr = PHI %5, %bb.2, %6, %bb.3
    $x10 = COPY %7
    PseudoRET implicit $x10
...
---
name:            test_complex_phi
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
  - { id: 9, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
  - { reg: '$x12', virtual-reg: '%2' }
  - { reg: '$x13', virtual-reg: '%3' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11, $x12, $x13
    ; CHECK-LABEL: name: test_complex_phi
    ; CHECK: bb.0.entry:

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    %2:gpr = COPY $x12
    %3:gpr = COPY $x13
    %4:gpr = SLTI %0, 1
    BEQ %4, $x0, %bb.2

  bb.1.path1:
    ; CHECK: bb.1.path1:

    %5:gpr = ADD %0, %1
    PseudoBR %bb.5

  bb.2.path2:
    ; CHECK: bb.2.path2:
    ; %2, %3 should be live-in

    %6:gpr = SLTI %2, 1
    BEQ %6, $x0, %bb.4

  bb.3.path2a:
    ; CHECK: bb.3.path2a:

    %7:gpr = MUL %2, %3
    PseudoBR %bb.5

  bb.4.path2b:
    ; CHECK: bb.4.path2b:

    %8:gpr = SUB %2, %3
    PseudoBR %bb.5

  bb.5.merge:
    ; CHECK: bb.5.merge:
    ; One of %5, %7, %8 should be live-in

    %9:gpr = PHI %5, %bb.1, %7, %bb.3, %8, %bb.4
    $x10 = COPY %9
    PseudoRET implicit $x10
...
---
name:            test_use_after_def
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
body:             |
  bb.0.entry:
    liveins: $x10
    ; CHECK-LABEL: name: test_use_after_def
    ; CHECK: bb.0.entry:
    ; Test that %1 remains live even after being used in %2

    %0:gpr = COPY $x10
    %1:gpr = ADDI %0, 1
    %2:gpr = ADDI %1, 2
    %3:gpr = ADDI %2, 3
    ; %1 used again here - should have been kept live
    %4:gpr = ADD %1, %3
    $x10 = COPY %4
    PseudoRET implicit $x10
...
---
name:            test_implicit_defs
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_implicit_defs
    ; CHECK: bb.0.entry:
    ; Test handling of division which may have implicit defs/uses

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    %2:gpr = DIV %0, %1
    %3:gpr = REM %0, %1
    %4:gpr = ADD %2, %3
    $x10 = COPY %4
    PseudoRET implicit $x10
...
