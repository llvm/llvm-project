; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 | FileCheck %s --check-prefixes=RV32I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 | FileCheck %s --check-prefixes=RV64I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+short-forward-branch-opt | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+short-forward-branch-opt | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+short-forward-branch-i-load | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFBILOAD
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+short-forward-branch-i-load | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFBILOAD

define i32 @test_i8_s_volatile(ptr %base, i1 %x, i32 %b, ptr %base1) {
; RV32I-LABEL: test_i8_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a4, 4(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB0_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB0_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a4, 4(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB0_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB0_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB0_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB0_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB0_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB0_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB0_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB0_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB0_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB0_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_z_volatile(ptr %base, i1 %x, i32 %b, ptr %base1) {
; RV32I-LABEL: test_i8_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a4, 4(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB1_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB1_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a4, 4(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB1_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB1_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a0, 4(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB1_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB1_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB1_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB1_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB1_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB1_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB1_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB1_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_s_volatile(ptr %base, i1 %x, i32 %b, ptr %base1) {
; RV32I-LABEL: test_i16_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a4, 8(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB2_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB2_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a4, 8(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB2_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB2_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB2_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB2_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB2_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB2_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB2_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB2_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB2_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB2_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_z_volatile(ptr %base, i1 %x, i32 %b, ptr %base1) {
; RV32I-LABEL: test_i16_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a4, 8(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB3_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB3_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a4, 8(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB3_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB3_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a0, 8(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB3_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB3_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB3_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB3_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB3_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB3_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB3_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB3_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i32_volatile(ptr %base, i1 %x, i32 %b, ptr %base1) {
; RV32I-LABEL: test_i32_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a4, 16(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB4_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB4_2: # %entry
; RV32I-NEXT:    add a0, a4, a0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lw a4, 16(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB4_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB4_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a0, 16(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB4_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB4_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lw a0, 16(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB4_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB4_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB4_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB4_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB4_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB4_2: # %entry
; RV64I-SFBILOAD-NEXT:    addw a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}


define i64 @test_i8_s_1_volatile(ptr %base, i1 %x, i64 %b, ptr %base1) {
; RV32I-LABEL: test_i8_s_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lb a6, 4(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB5_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:    j .LBB5_3
; RV32I-NEXT:  .LBB5_2:
; RV32I-NEXT:    srai a3, a6, 31
; RV32I-NEXT:  .LBB5_3: # %entry
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    sltu a1, a0, a6
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a3, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lb a4, 4(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB5_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB5_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lb a0, 4(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    beqz a1, .LBB5_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB5_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB5_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB5_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a3, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lb a0, 4(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB5_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB5_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lb a0, 4(a0)
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB5_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB5_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB5_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB5_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_s_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB5_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lb a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB5_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i8_z_1_volatile(ptr %base, i1 %x, i64 %b, ptr %base1) {
; RV32I-LABEL: test_i8_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lbu a6, 4(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB6_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:  .LBB6_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a6
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lbu a4, 4(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB6_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB6_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lbu a5, 4(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB6_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB6_2: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a2, a0, a5
; RV32I-SFB-NEXT:    bnez a1, .LBB6_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB6_4: # %entry
; RV32I-SFB-NEXT:    add a1, a6, a2
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lbu a0, 4(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB6_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB6_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB6_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV32I-SFBILOAD-NEXT:  .LBB6_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a2, a0, a2
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB6_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB6_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a1, a5, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i8_z_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB6_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lbu a2, 4(a0)
; RV64I-SFBILOAD-NEXT:  .LBB6_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 4   ; compute base + 4
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_s_1_volatile(ptr %base, i1 %x, i64 %b, ptr %base1) {
; RV32I-LABEL: test_i16_s_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lh a6, 8(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB7_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:    j .LBB7_3
; RV32I-NEXT:  .LBB7_2:
; RV32I-NEXT:    srai a3, a6, 31
; RV32I-NEXT:  .LBB7_3: # %entry
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    sltu a1, a0, a6
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a3, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lh a4, 8(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB7_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB7_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lh a0, 8(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    beqz a1, .LBB7_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB7_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB7_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB7_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a3, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lh a0, 8(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB7_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB7_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lh a0, 8(a0)
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB7_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBILOAD-NEXT:  .LBB7_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB7_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    mv a2, a0
; RV32I-SFBILOAD-NEXT:  .LBB7_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_s_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB7_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lh a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB7_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_z_1_volatile(ptr %base, i1 %x, i64 %b, ptr %base1) {
; RV32I-LABEL: test_i16_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lhu a6, 8(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB8_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:  .LBB8_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a6
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lhu a4, 8(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB8_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB8_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lhu a5, 8(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB8_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB8_2: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a2, a0, a5
; RV32I-SFB-NEXT:    bnez a1, .LBB8_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB8_4: # %entry
; RV32I-SFB-NEXT:    add a1, a6, a2
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lhu a0, 8(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB8_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB8_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB8_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV32I-SFBILOAD-NEXT:  .LBB8_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a2, a0, a2
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB8_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB8_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a1, a5, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i16_z_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB8_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lhu a2, 8(a0)
; RV64I-SFBILOAD-NEXT:  .LBB8_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 4   ; compute base + 4
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i32_z_1_volatile(ptr %base, i1 %x, i64 %b, ptr %base1) {
; RV32I-LABEL: test_i32_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a6, 16(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB9_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a2
; RV32I-NEXT:  .LBB9_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a6, a0
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a6
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lwu a4, 16(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB9_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB9_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a5, 16(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB9_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB9_2: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a2, a0, a5
; RV32I-SFB-NEXT:    bnez a1, .LBB9_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB9_4: # %entry
; RV32I-SFB-NEXT:    add a1, a6, a2
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lwu a0, 16(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB9_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB9_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_z_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB9_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 16(a0)
; RV32I-SFBILOAD-NEXT:  .LBB9_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a2, a0, a2
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB9_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    add a5, a5, a3
; RV32I-SFBILOAD-NEXT:  .LBB9_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a1, a5, a2
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i32_z_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB9_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    lwu a2, 16(a0)
; RV64I-SFBILOAD-NEXT:  .LBB9_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 4   ; compute base + 4
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i64_1_volatile(ptr %base, i1 %x, i64 %b, ptr %base1) {
; RV32I-LABEL: test_i64_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lw a7, 32(a0)
; RV32I-NEXT:    lw a6, 36(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    andi a1, a1, 1
; RV32I-NEXT:    bnez a1, .LBB10_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a6, a3
; RV32I-NEXT:    mv a7, a2
; RV32I-NEXT:  .LBB10_2: # %entry
; RV32I-NEXT:    add a0, a7, a0
; RV32I-NEXT:    sltu a1, a0, a7
; RV32I-NEXT:    add a5, a6, a5
; RV32I-NEXT:    add a1, a5, a1
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    ld a4, 32(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    andi a1, a1, 1
; RV64I-NEXT:    bnez a1, .LBB10_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB10_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lw a5, 32(a0)
; RV32I-SFB-NEXT:    lw a6, 36(a0)
; RV32I-SFB-NEXT:    lw a7, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    andi a1, a1, 1
; RV32I-SFB-NEXT:    bnez a1, .LBB10_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a6, a3
; RV32I-SFB-NEXT:  .LBB10_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB10_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB10_4: # %entry
; RV32I-SFB-NEXT:    add a0, a5, a0
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a6, a6, a7
; RV32I-SFB-NEXT:    add a1, a6, a1
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    ld a0, 32(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    andi a1, a1, 1
; RV64I-SFB-NEXT:    bnez a1, .LBB10_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB10_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i64_1_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV32I-SFBILOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBILOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB10_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    lw a2, 32(a0)
; RV32I-SFBILOAD-NEXT:  .LBB10_2: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB10_4
; RV32I-SFBILOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 36(a0)
; RV32I-SFBILOAD-NEXT:  .LBB10_4: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a4
; RV32I-SFBILOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBILOAD-NEXT:    add a3, a3, a5
; RV32I-SFBILOAD-NEXT:    add a1, a3, a1
; RV32I-SFBILOAD-NEXT:    ret
;
; RV64I-SFBILOAD-LABEL: test_i64_1_volatile:
; RV64I-SFBILOAD:       # %bb.0: # %entry
; RV64I-SFBILOAD-NEXT:    andi a1, a1, 1
; RV64I-SFBILOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBILOAD-NEXT:    beqz a1, .LBB10_2
; RV64I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBILOAD-NEXT:    ld a2, 32(a0)
; RV64I-SFBILOAD-NEXT:  .LBB10_2: # %entry
; RV64I-SFBILOAD-NEXT:    add a0, a2, a3
; RV64I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 4   ; compute base + 4
  %val = load i64, ptr %addr          ; load 64-bit value
  %val1 = load volatile i64, ptr %base1
  %res = select i1 %x, i64 %val, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

