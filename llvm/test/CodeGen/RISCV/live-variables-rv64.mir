# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=riscv64 -run-pass=riscv-live-variables -verify-machineinstrs -o - %s | FileCheck %s
#
# Test live variable analysis for RV64-specific scenarios
# This includes 64-bit operations, wide registers, and RV64-specific instructions

--- |
  define i64 @test_64bit_ops(i64 %a, i64 %b) {
  entry:
    %shl = shl i64 %a, 32
    %or = or i64 %shl, %b
    ret i64 %or
  }

  define i64 @test_word_ops(i64 %a, i64 %b) {
  entry:
    %trunc_a = trunc i64 %a to i32
    %trunc_b = trunc i64 %b to i32
    %add = add i32 %trunc_a, %trunc_b
    %ext = sext i32 %add to i64
    ret i64 %ext
  }

  define i64 @test_mixed_width(i64 %a, i32 %b) {
  entry:
    %ext_b = sext i32 %b to i64
    %mul = mul i64 %a, %ext_b
    %trunc = trunc i64 %mul to i32
    %final = sext i32 %trunc to i64
    ret i64 %final
  }

  define double @test_float_64(double %a, double %b, i64 %selector) {
  entry:
    %cmp = icmp eq i64 %selector, 0
    br i1 %cmp, label %then, label %else

  then:
    %add = fadd double %a, %b
    br label %end

  else:
    %mul = fmul double %a, %b
    br label %end

  end:
    %result = phi double [ %add, %then ], [ %mul, %else ]
    ret double %result
  }
...
---
name:            test_64bit_ops
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_64bit_ops
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11
    ; Test 64-bit shift and or operations

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    ; SLLI for 64-bit shift (RV64-specific immediate range)
    %2:gpr = SLLI %0, 32
    %3:gpr = OR %2, %1
    $x10 = COPY %3
    PseudoRET implicit $x10
...
---
name:            test_word_ops
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_word_ops
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11
    ; Test RV64 W-suffix instructions (32-bit ops on 64-bit regs)

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    ; ADDW is RV64-specific: 32-bit add with sign-extension
    %2:gpr = ADDW %0, %1
    $x10 = COPY %2
    PseudoRET implicit $x10
...
---
name:            test_mixed_width
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11_w', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11_w
    ; CHECK-LABEL: name: test_mixed_width
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11_w
    ; Test mixed 32/64-bit operations

    %0:gpr = COPY $x10
    ; Sign-extend 32-bit value to 64-bit
    %1:gpr = COPY $x11_w
    %2:gpr = ADDIW %1, 0
    %3:gpr = MUL %0, %2
    ; Extract lower 32 bits and sign-extend
    %4:gpr = ADDIW %3, 0
    $x10 = COPY %4
    PseudoRET implicit $x10
...
---
name:            test_float_64
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: fpr64 }
  - { id: 1, class: fpr64 }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: fpr64 }
  - { id: 5, class: fpr64 }
  - { id: 6, class: fpr64 }
liveins:
  - { reg: '$f10_d', virtual-reg: '%0' }
  - { reg: '$f11_d', virtual-reg: '%1' }
  - { reg: '$x10', virtual-reg: '%2' }
body:             |
  bb.0.entry:
    liveins: $f10_d, $f11_d, $x10
    ; CHECK-LABEL: name: test_float_64
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: successors
    ; CHECK-NEXT: liveins: $f10_d, $f11_d, $x10
    ; Test 64-bit floating point register liveness

    %0:fpr64 = COPY $f10_d
    %1:fpr64 = COPY $f11_d
    %2:gpr = COPY $x10
    %3:gpr = ADDI $x0, 0
    BNE %2, %3, %bb.2

  bb.1.then:
    ; CHECK: bb.1.then:
    ; %0 and %1 should be live-in (FP registers)

    %4:fpr64 = FADD_D %0, %1, 7
    PseudoBR %bb.3

  bb.2.else:
    ; CHECK: bb.2.else:
    ; %0 and %1 should be live-in

    %5:fpr64 = FMUL_D %0, %1, 7
    PseudoBR %bb.3

  bb.3.end:
    ; CHECK: bb.3.end:
    ; Either %4 or %5 should be live-in

    %6:fpr64 = PHI %4, %bb.1, %5, %bb.2
    $f10_d = COPY %6
    PseudoRET implicit $f10_d
...
