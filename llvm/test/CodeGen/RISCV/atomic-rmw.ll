; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV32I %s
; RUN: llc -mtriple=riscv32 -mattr=+a -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV32IA %s
; RUN: llc -mtriple=riscv32 -mattr=+a,+experimental-ztso -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV32IA %s
; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV64I %s
; RUN: llc -mtriple=riscv64 -mattr=+a -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV64IA %s
; RUN: llc -mtriple=riscv64 -mattr=+a,+experimental-ztso -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV64IA %s

define i8 @atomicrmw_xchg_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB0_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB0_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB0_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB0_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_xchg_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB1_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB1_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_xchg_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB2_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB2_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB2_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB2_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_xchg_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB3_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB3_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB3_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB3_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_xchg_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB4_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a4, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB4_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB4_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a4, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB4_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 %b seq_cst
  ret i8 %1
}

; TODO: The following 'atomicrmw xchg a, 0` cases can be lowered to an amoand
; with appropriate mask.

define i8 @atomicrmw_xchg_0_i8_monotonic(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a2, 255
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB5_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB5_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a2, 255
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB5_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB5_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 0 monotonic
  ret i8 %1
}

define i8 @atomicrmw_xchg_0_i8_acquire(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a2, 255
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB6_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB6_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a2, 255
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB6_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB6_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 0 acquire
  ret i8 %1
}

define i8 @atomicrmw_xchg_0_i8_release(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a2, 255
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB7_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB7_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a2, 255
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB7_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB7_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 0 release
  ret i8 %1
}

define i8 @atomicrmw_xchg_0_i8_acq_rel(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a2, 255
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB8_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB8_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a2, 255
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB8_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB8_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 0 acq_rel
  ret i8 %1
}

define i8 @atomicrmw_xchg_0_i8_seq_cst(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a2, 255
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB9_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB9_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a2, 255
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB9_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB9_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i8 0 seq_cst
  ret i8 %1
}

define i8 @atomicrmw_add_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_add_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB10_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    add a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB10_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_add_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB10_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    add a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB10_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_add_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_add_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB11_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    add a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB11_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_add_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB11_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    add a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB11_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_add_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_add_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB12_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    add a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB12_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_add_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB12_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    add a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB12_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_add_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_add_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB13_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    add a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB13_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_add_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB13_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    add a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB13_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_add_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_add_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB14_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a4, (a2)
; RV32IA-NEXT:    add a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB14_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_add_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB14_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a4, (a2)
; RV64IA-NEXT:    add a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB14_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_sub_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_sub_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB15_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    sub a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB15_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_sub_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB15_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    sub a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB15_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_sub_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_sub_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB16_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    sub a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB16_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_sub_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB16_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    sub a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB16_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_sub_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_sub_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB17_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    sub a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB17_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_sub_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB17_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    sub a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB17_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_sub_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_sub_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB18_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    sub a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB18_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_sub_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB18_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    sub a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB18_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_sub_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_sub_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB19_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a4, (a2)
; RV32IA-NEXT:    sub a5, a4, a1
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB19_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_sub_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB19_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a4, (a2)
; RV64IA-NEXT:    sub a5, a4, a1
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB19_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_and_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_and_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a3, a1
; RV32IA-NEXT:    amoand.w a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_and_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a3, a1
; RV64IA-NEXT:    amoand.w a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_and_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_and_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a3, a1
; RV32IA-NEXT:    amoand.w.aq a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_and_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a3, a1
; RV64IA-NEXT:    amoand.w.aq a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_and_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_and_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a3, a1
; RV32IA-NEXT:    amoand.w.rl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_and_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a3, a1
; RV64IA-NEXT:    amoand.w.rl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_and_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_and_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a3, a1
; RV32IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_and_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a3, a1
; RV64IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_and_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_and_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a3, a1
; RV32IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_and_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a3, a1
; RV64IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_nand_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_nand_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB25_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    and a5, a4, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB25_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_nand_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB25_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    and a5, a4, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB25_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_nand_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_nand_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB26_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    and a5, a4, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB26_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_nand_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB26_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    and a5, a4, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB26_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_nand_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_nand_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB27_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    and a5, a4, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB27_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_nand_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB27_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    and a5, a4, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB27_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_nand_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_nand_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB28_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    and a5, a4, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB28_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_nand_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB28_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    and a5, a4, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB28_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_nand_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_nand_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB29_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a4, (a2)
; RV32IA-NEXT:    and a5, a4, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB29_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_nand_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB29_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a4, (a2)
; RV64IA-NEXT:    and a5, a4, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB29_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_or_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_or_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_or_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_or_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_or_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.aq a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_or_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.aq a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_or_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_or_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.rl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_or_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.rl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_or_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_or_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_or_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_or_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_or_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_or_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_xor_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_xor_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_xor_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_xor_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_xor_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.aq a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_xor_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.aq a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_xor_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_xor_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.rl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_xor_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.rl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_xor_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_xor_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_xor_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_xor_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_xor_1@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_xor_1@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_max_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB40_2
; RV32I-NEXT:  .LBB40_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB40_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB40_4
; RV32I-NEXT:  .LBB40_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB40_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB40_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB40_1
; RV32I-NEXT:  .LBB40_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB40_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a7, a1, .LBB40_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB40_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB40_3: # in Loop: Header=BB40_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB40_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB40_2
; RV64I-NEXT:  .LBB40_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB40_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB40_4
; RV64I-NEXT:  .LBB40_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB40_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB40_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB40_1
; RV64I-NEXT:  .LBB40_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB40_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a7, a1, .LBB40_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB40_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB40_3: # in Loop: Header=BB40_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB40_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_max_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB41_2
; RV32I-NEXT:  .LBB41_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB41_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB41_4
; RV32I-NEXT:  .LBB41_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB41_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB41_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB41_1
; RV32I-NEXT:  .LBB41_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB41_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a7, a1, .LBB41_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB41_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB41_3: # in Loop: Header=BB41_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB41_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB41_2
; RV64I-NEXT:  .LBB41_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB41_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB41_4
; RV64I-NEXT:  .LBB41_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB41_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB41_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB41_1
; RV64I-NEXT:  .LBB41_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB41_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a7, a1, .LBB41_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB41_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB41_3: # in Loop: Header=BB41_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB41_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_max_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB42_2
; RV32I-NEXT:  .LBB42_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB42_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB42_4
; RV32I-NEXT:  .LBB42_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB42_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB42_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB42_1
; RV32I-NEXT:  .LBB42_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB42_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a7, a1, .LBB42_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB42_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB42_3: # in Loop: Header=BB42_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB42_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB42_2
; RV64I-NEXT:  .LBB42_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB42_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB42_4
; RV64I-NEXT:  .LBB42_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB42_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB42_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB42_1
; RV64I-NEXT:  .LBB42_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB42_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a7, a1, .LBB42_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB42_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB42_3: # in Loop: Header=BB42_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB42_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_max_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB43_2
; RV32I-NEXT:  .LBB43_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB43_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB43_4
; RV32I-NEXT:  .LBB43_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB43_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB43_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB43_1
; RV32I-NEXT:  .LBB43_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB43_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a7, a1, .LBB43_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB43_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB43_3: # in Loop: Header=BB43_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB43_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB43_2
; RV64I-NEXT:  .LBB43_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB43_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB43_4
; RV64I-NEXT:  .LBB43_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB43_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB43_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB43_1
; RV64I-NEXT:  .LBB43_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB43_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a7, a1, .LBB43_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB43_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB43_3: # in Loop: Header=BB43_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB43_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_max_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB44_2
; RV32I-NEXT:  .LBB44_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB44_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB44_4
; RV32I-NEXT:  .LBB44_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB44_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB44_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB44_1
; RV32I-NEXT:  .LBB44_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB44_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a7, a1, .LBB44_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB44_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB44_3: # in Loop: Header=BB44_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB44_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB44_2
; RV64I-NEXT:  .LBB44_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB44_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB44_4
; RV64I-NEXT:  .LBB44_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB44_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB44_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB44_1
; RV64I-NEXT:  .LBB44_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB44_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a7, a1, .LBB44_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB44_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB44_3: # in Loop: Header=BB44_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB44_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_min_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB45_2
; RV32I-NEXT:  .LBB45_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB45_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB45_4
; RV32I-NEXT:  .LBB45_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB45_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB45_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB45_1
; RV32I-NEXT:  .LBB45_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB45_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a1, a7, .LBB45_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB45_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB45_3: # in Loop: Header=BB45_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB45_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB45_2
; RV64I-NEXT:  .LBB45_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB45_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB45_4
; RV64I-NEXT:  .LBB45_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB45_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB45_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB45_1
; RV64I-NEXT:  .LBB45_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB45_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a1, a7, .LBB45_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB45_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB45_3: # in Loop: Header=BB45_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB45_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_min_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB46_2
; RV32I-NEXT:  .LBB46_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB46_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB46_4
; RV32I-NEXT:  .LBB46_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB46_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB46_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB46_1
; RV32I-NEXT:  .LBB46_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB46_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a1, a7, .LBB46_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB46_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB46_3: # in Loop: Header=BB46_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB46_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB46_2
; RV64I-NEXT:  .LBB46_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB46_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB46_4
; RV64I-NEXT:  .LBB46_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB46_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB46_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB46_1
; RV64I-NEXT:  .LBB46_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB46_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a1, a7, .LBB46_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB46_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB46_3: # in Loop: Header=BB46_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB46_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_min_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB47_2
; RV32I-NEXT:  .LBB47_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB47_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB47_4
; RV32I-NEXT:  .LBB47_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB47_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB47_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB47_1
; RV32I-NEXT:  .LBB47_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB47_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a1, a7, .LBB47_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB47_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB47_3: # in Loop: Header=BB47_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB47_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB47_2
; RV64I-NEXT:  .LBB47_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB47_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB47_4
; RV64I-NEXT:  .LBB47_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB47_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB47_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB47_1
; RV64I-NEXT:  .LBB47_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB47_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a1, a7, .LBB47_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB47_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB47_3: # in Loop: Header=BB47_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB47_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_min_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB48_2
; RV32I-NEXT:  .LBB48_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB48_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB48_4
; RV32I-NEXT:  .LBB48_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB48_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB48_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB48_1
; RV32I-NEXT:  .LBB48_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB48_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a1, a7, .LBB48_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB48_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB48_3: # in Loop: Header=BB48_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB48_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB48_2
; RV64I-NEXT:  .LBB48_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB48_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB48_4
; RV64I-NEXT:  .LBB48_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB48_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB48_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB48_1
; RV64I-NEXT:  .LBB48_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB48_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a1, a7, .LBB48_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB48_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB48_3: # in Loop: Header=BB48_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB48_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_min_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 24
; RV32I-NEXT:    srai s2, a0, 24
; RV32I-NEXT:    j .LBB49_2
; RV32I-NEXT:  .LBB49_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB49_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB49_4
; RV32I-NEXT:  .LBB49_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 24
; RV32I-NEXT:    srai a0, a0, 24
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB49_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB49_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB49_1
; RV32I-NEXT:  .LBB49_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    li a4, 255
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 24
; RV32IA-NEXT:    srai a1, a1, 24
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    xori a3, a3, 24
; RV32IA-NEXT:  .LBB49_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a5, (a2)
; RV32IA-NEXT:    and a7, a5, a4
; RV32IA-NEXT:    mv a6, a5
; RV32IA-NEXT:    sll a7, a7, a3
; RV32IA-NEXT:    sra a7, a7, a3
; RV32IA-NEXT:    bge a1, a7, .LBB49_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB49_1 Depth=1
; RV32IA-NEXT:    xor a6, a5, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a5, a6
; RV32IA-NEXT:  .LBB49_3: # in Loop: Header=BB49_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB49_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a5, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 56
; RV64I-NEXT:    srai s2, a0, 56
; RV64I-NEXT:    j .LBB49_2
; RV64I-NEXT:  .LBB49_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB49_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB49_4
; RV64I-NEXT:  .LBB49_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 56
; RV64I-NEXT:    srai a0, a0, 56
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB49_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB49_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB49_1
; RV64I-NEXT:  .LBB49_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    li a4, 255
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 56
; RV64IA-NEXT:    srai a1, a1, 56
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    xori a3, a3, 56
; RV64IA-NEXT:  .LBB49_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a5, (a2)
; RV64IA-NEXT:    and a7, a5, a4
; RV64IA-NEXT:    mv a6, a5
; RV64IA-NEXT:    sll a7, a7, a3
; RV64IA-NEXT:    sra a7, a7, a3
; RV64IA-NEXT:    bge a1, a7, .LBB49_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB49_1 Depth=1
; RV64IA-NEXT:    xor a6, a5, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a5, a6
; RV64IA-NEXT:  .LBB49_3: # in Loop: Header=BB49_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB49_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a5, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_umax_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB50_2
; RV32I-NEXT:  .LBB50_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB50_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB50_4
; RV32I-NEXT:  .LBB50_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s2, a0, .LBB50_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB50_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB50_1
; RV32I-NEXT:  .LBB50_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB50_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a6, a1, .LBB50_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB50_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB50_3: # in Loop: Header=BB50_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB50_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB50_2
; RV64I-NEXT:  .LBB50_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB50_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB50_4
; RV64I-NEXT:  .LBB50_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a0, .LBB50_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB50_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB50_1
; RV64I-NEXT:  .LBB50_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB50_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a6, a1, .LBB50_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB50_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB50_3: # in Loop: Header=BB50_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB50_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_umax_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB51_2
; RV32I-NEXT:  .LBB51_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB51_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB51_4
; RV32I-NEXT:  .LBB51_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s2, a0, .LBB51_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB51_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB51_1
; RV32I-NEXT:  .LBB51_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB51_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a6, a1, .LBB51_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB51_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB51_3: # in Loop: Header=BB51_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB51_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB51_2
; RV64I-NEXT:  .LBB51_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB51_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB51_4
; RV64I-NEXT:  .LBB51_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a0, .LBB51_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB51_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB51_1
; RV64I-NEXT:  .LBB51_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB51_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a6, a1, .LBB51_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB51_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB51_3: # in Loop: Header=BB51_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB51_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_umax_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB52_2
; RV32I-NEXT:  .LBB52_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB52_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB52_4
; RV32I-NEXT:  .LBB52_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s2, a0, .LBB52_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB52_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB52_1
; RV32I-NEXT:  .LBB52_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB52_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a6, a1, .LBB52_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB52_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB52_3: # in Loop: Header=BB52_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB52_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB52_2
; RV64I-NEXT:  .LBB52_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB52_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB52_4
; RV64I-NEXT:  .LBB52_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a0, .LBB52_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB52_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB52_1
; RV64I-NEXT:  .LBB52_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB52_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a6, a1, .LBB52_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB52_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB52_3: # in Loop: Header=BB52_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB52_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_umax_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB53_2
; RV32I-NEXT:  .LBB53_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB53_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB53_4
; RV32I-NEXT:  .LBB53_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s2, a0, .LBB53_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB53_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB53_1
; RV32I-NEXT:  .LBB53_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB53_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a6, a1, .LBB53_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB53_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB53_3: # in Loop: Header=BB53_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB53_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB53_2
; RV64I-NEXT:  .LBB53_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB53_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB53_4
; RV64I-NEXT:  .LBB53_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a0, .LBB53_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB53_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB53_1
; RV64I-NEXT:  .LBB53_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB53_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a6, a1, .LBB53_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB53_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB53_3: # in Loop: Header=BB53_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB53_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_umax_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB54_2
; RV32I-NEXT:  .LBB54_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB54_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB54_4
; RV32I-NEXT:  .LBB54_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s2, a0, .LBB54_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB54_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB54_1
; RV32I-NEXT:  .LBB54_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB54_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a6, a1, .LBB54_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB54_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB54_3: # in Loop: Header=BB54_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB54_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB54_2
; RV64I-NEXT:  .LBB54_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB54_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB54_4
; RV64I-NEXT:  .LBB54_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a0, .LBB54_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB54_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB54_1
; RV64I-NEXT:  .LBB54_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB54_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a6, a1, .LBB54_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB54_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB54_3: # in Loop: Header=BB54_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB54_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i8 @atomicrmw_umin_i8_monotonic(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i8_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB55_2
; RV32I-NEXT:  .LBB55_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB55_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB55_4
; RV32I-NEXT:  .LBB55_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s2, a0, .LBB55_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB55_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB55_1
; RV32I-NEXT:  .LBB55_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i8_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB55_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a1, a6, .LBB55_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB55_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB55_3: # in Loop: Header=BB55_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB55_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i8_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB55_2
; RV64I-NEXT:  .LBB55_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB55_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB55_4
; RV64I-NEXT:  .LBB55_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a0, .LBB55_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB55_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB55_1
; RV64I-NEXT:  .LBB55_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i8_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB55_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a1, a6, .LBB55_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB55_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB55_3: # in Loop: Header=BB55_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB55_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i8 %b monotonic
  ret i8 %1
}

define i8 @atomicrmw_umin_i8_acquire(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i8_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB56_2
; RV32I-NEXT:  .LBB56_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB56_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB56_4
; RV32I-NEXT:  .LBB56_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s2, a0, .LBB56_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB56_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB56_1
; RV32I-NEXT:  .LBB56_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i8_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB56_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a1, a6, .LBB56_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB56_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB56_3: # in Loop: Header=BB56_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB56_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i8_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB56_2
; RV64I-NEXT:  .LBB56_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB56_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB56_4
; RV64I-NEXT:  .LBB56_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a0, .LBB56_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB56_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB56_1
; RV64I-NEXT:  .LBB56_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i8_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB56_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a1, a6, .LBB56_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB56_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB56_3: # in Loop: Header=BB56_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB56_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i8 %b acquire
  ret i8 %1
}

define i8 @atomicrmw_umin_i8_release(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i8_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB57_2
; RV32I-NEXT:  .LBB57_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB57_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB57_4
; RV32I-NEXT:  .LBB57_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s2, a0, .LBB57_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB57_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB57_1
; RV32I-NEXT:  .LBB57_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i8_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB57_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a1, a6, .LBB57_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB57_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB57_3: # in Loop: Header=BB57_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB57_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i8_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB57_2
; RV64I-NEXT:  .LBB57_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB57_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB57_4
; RV64I-NEXT:  .LBB57_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a0, .LBB57_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB57_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB57_1
; RV64I-NEXT:  .LBB57_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i8_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB57_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a1, a6, .LBB57_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB57_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB57_3: # in Loop: Header=BB57_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB57_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i8 %b release
  ret i8 %1
}

define i8 @atomicrmw_umin_i8_acq_rel(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i8_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB58_2
; RV32I-NEXT:  .LBB58_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB58_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB58_4
; RV32I-NEXT:  .LBB58_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s2, a0, .LBB58_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB58_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB58_1
; RV32I-NEXT:  .LBB58_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i8_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB58_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a1, a6, .LBB58_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB58_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB58_3: # in Loop: Header=BB58_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB58_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i8_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB58_2
; RV64I-NEXT:  .LBB58_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB58_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB58_4
; RV64I-NEXT:  .LBB58_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a0, .LBB58_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB58_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB58_1
; RV64I-NEXT:  .LBB58_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i8_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB58_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a1, a6, .LBB58_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB58_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB58_3: # in Loop: Header=BB58_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB58_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i8 %b acq_rel
  ret i8 %1
}

define i8 @atomicrmw_umin_i8_seq_cst(ptr %a, i8 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i8_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lbu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    andi s2, a1, 255
; RV32I-NEXT:    j .LBB59_2
; RV32I-NEXT:  .LBB59_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB59_2 Depth=1
; RV32I-NEXT:    sb a3, 15(sp)
; RV32I-NEXT:    addi a1, sp, 15
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_1@plt
; RV32I-NEXT:    lbu a3, 15(sp)
; RV32I-NEXT:    bnez a0, .LBB59_4
; RV32I-NEXT:  .LBB59_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    andi a0, a3, 255
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s2, a0, .LBB59_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB59_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB59_1
; RV32I-NEXT:  .LBB59_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i8_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    li a3, 255
; RV32IA-NEXT:    sll a3, a3, a0
; RV32IA-NEXT:    andi a1, a1, 255
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB59_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a4, (a2)
; RV32IA-NEXT:    and a6, a4, a3
; RV32IA-NEXT:    mv a5, a4
; RV32IA-NEXT:    bgeu a1, a6, .LBB59_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB59_1 Depth=1
; RV32IA-NEXT:    xor a5, a4, a1
; RV32IA-NEXT:    and a5, a5, a3
; RV32IA-NEXT:    xor a5, a4, a5
; RV32IA-NEXT:  .LBB59_3: # in Loop: Header=BB59_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB59_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a4, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i8_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lbu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    andi s2, a1, 255
; RV64I-NEXT:    j .LBB59_2
; RV64I-NEXT:  .LBB59_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB59_2 Depth=1
; RV64I-NEXT:    sb a3, 15(sp)
; RV64I-NEXT:    addi a1, sp, 15
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_1@plt
; RV64I-NEXT:    lbu a3, 15(sp)
; RV64I-NEXT:    bnez a0, .LBB59_4
; RV64I-NEXT:  .LBB59_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    andi a0, a3, 255
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a0, .LBB59_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB59_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB59_1
; RV64I-NEXT:  .LBB59_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i8_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    li a3, 255
; RV64IA-NEXT:    sllw a3, a3, a0
; RV64IA-NEXT:    andi a1, a1, 255
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB59_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a4, (a2)
; RV64IA-NEXT:    and a6, a4, a3
; RV64IA-NEXT:    mv a5, a4
; RV64IA-NEXT:    bgeu a1, a6, .LBB59_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB59_1 Depth=1
; RV64IA-NEXT:    xor a5, a4, a1
; RV64IA-NEXT:    and a5, a5, a3
; RV64IA-NEXT:    xor a5, a4, a5
; RV64IA-NEXT:  .LBB59_3: # in Loop: Header=BB59_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB59_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a4, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i8 %b seq_cst
  ret i8 %1
}

define i16 @atomicrmw_xchg_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB60_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB60_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB60_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB60_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_xchg_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB61_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB61_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB61_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB61_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_xchg_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB62_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB62_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB62_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB62_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_xchg_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB63_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB63_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB63_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB63_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_xchg_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB64_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    mv a5, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB64_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB64_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    mv a5, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB64_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 %b seq_cst
  ret i16 %1
}

; TODO: The following 'atomicrmw xchg a, 0` cases can be lowered to an amoand
; with appropriate mask.

define i16 @atomicrmw_xchg_0_i16_monotonic(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a2, 16
; RV32IA-NEXT:    addi a2, a2, -1
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB65_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB65_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a2, 16
; RV64IA-NEXT:    addiw a2, a2, -1
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB65_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB65_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 0 monotonic
  ret i16 %1
}

define i16 @atomicrmw_xchg_0_i16_acquire(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a2, 16
; RV32IA-NEXT:    addi a2, a2, -1
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB66_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB66_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a2, 16
; RV64IA-NEXT:    addiw a2, a2, -1
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB66_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB66_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 0 acquire
  ret i16 %1
}

define i16 @atomicrmw_xchg_0_i16_release(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a2, 16
; RV32IA-NEXT:    addi a2, a2, -1
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB67_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB67_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a2, 16
; RV64IA-NEXT:    addiw a2, a2, -1
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB67_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB67_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 0 release
  ret i16 %1
}

define i16 @atomicrmw_xchg_0_i16_acq_rel(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a2, 16
; RV32IA-NEXT:    addi a2, a2, -1
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB68_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB68_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a2, 16
; RV64IA-NEXT:    addiw a2, a2, -1
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB68_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB68_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 0 acq_rel
  ret i16 %1
}

define i16 @atomicrmw_xchg_0_i16_seq_cst(ptr %a) nounwind {
; RV32I-LABEL: atomicrmw_xchg_0_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    call __atomic_exchange_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_0_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a1, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a2, 16
; RV32IA-NEXT:    addi a2, a2, -1
; RV32IA-NEXT:    sll a2, a2, a0
; RV32IA-NEXT:  .LBB69_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a1)
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    and a4, a4, a2
; RV32IA-NEXT:    xor a4, a3, a4
; RV32IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV32IA-NEXT:    bnez a4, .LBB69_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_0_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call __atomic_exchange_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_0_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a1, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a2, 16
; RV64IA-NEXT:    addiw a2, a2, -1
; RV64IA-NEXT:    sllw a2, a2, a0
; RV64IA-NEXT:  .LBB69_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a1)
; RV64IA-NEXT:    li a4, 0
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    and a4, a4, a2
; RV64IA-NEXT:    xor a4, a3, a4
; RV64IA-NEXT:    sc.w.rl a4, a4, (a1)
; RV64IA-NEXT:    bnez a4, .LBB69_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i16 0 seq_cst
  ret i16 %1
}

define i16 @atomicrmw_add_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_add_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB70_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    add a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB70_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_add_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB70_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    add a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB70_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_add_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_add_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB71_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    add a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB71_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_add_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB71_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    add a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB71_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_add_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_add_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB72_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    add a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB72_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_add_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB72_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    add a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB72_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_add_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_add_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB73_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    add a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB73_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_add_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB73_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    add a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB73_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_add_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_add_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB74_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    add a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB74_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_add_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB74_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    add a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB74_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_sub_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_sub_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB75_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    sub a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB75_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_sub_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB75_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    sub a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB75_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_sub_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_sub_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB76_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    sub a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB76_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_sub_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB76_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    sub a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB76_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_sub_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_sub_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB77_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    sub a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB77_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_sub_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB77_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    sub a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB77_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_sub_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_sub_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB78_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    sub a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB78_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_sub_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB78_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    sub a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB78_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_sub_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_sub_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB79_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    sub a5, a3, a1
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB79_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_sub_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB79_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    sub a5, a3, a1
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB79_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_and_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_and_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    not a4, a4
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a4, a1
; RV32IA-NEXT:    amoand.w a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_and_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    not a4, a4
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a4, a1
; RV64IA-NEXT:    amoand.w a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_and_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_and_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    not a4, a4
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a4, a1
; RV32IA-NEXT:    amoand.w.aq a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_and_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    not a4, a4
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a4, a1
; RV64IA-NEXT:    amoand.w.aq a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_and_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_and_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    not a4, a4
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a4, a1
; RV32IA-NEXT:    amoand.w.rl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_and_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    not a4, a4
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a4, a1
; RV64IA-NEXT:    amoand.w.rl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_and_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_and_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    not a4, a4
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a4, a1
; RV32IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_and_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    not a4, a4
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a4, a1
; RV64IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_and_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_and_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    not a4, a4
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    or a1, a4, a1
; RV32IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_and_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    not a4, a4
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    or a1, a4, a1
; RV64IA-NEXT:    amoand.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_nand_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_nand_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB85_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a5, a3, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB85_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_nand_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB85_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a5, a3, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB85_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_nand_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_nand_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB86_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a5, a3, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB86_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_nand_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB86_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a5, a3, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB86_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_nand_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_nand_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB87_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a5, a3, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB87_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_nand_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB87_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a5, a3, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB87_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_nand_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_nand_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB88_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a5, a3, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB88_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_nand_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB88_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a5, a3, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB88_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_nand_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_nand_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB89_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    and a5, a3, a1
; RV32IA-NEXT:    not a5, a5
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB89_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_nand_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB89_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    and a5, a3, a1
; RV64IA-NEXT:    not a5, a5
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB89_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_or_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_or_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_or_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_or_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_or_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.aq a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_or_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.aq a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_or_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_or_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.rl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_or_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.rl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_or_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_or_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_or_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_or_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_or_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_or_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_xor_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_xor_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_xor_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_xor_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_xor_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.aq a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_xor_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.aq a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_xor_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_xor_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.rl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_xor_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.rl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_xor_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_xor_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_xor_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_xor_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_xor_2@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srli a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV32IA-NEXT:    srl a0, a1, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_xor_2@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srli a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    amoxor.w.aqrl a1, a1, (a2)
; RV64IA-NEXT:    srlw a0, a1, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_max_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB100_2
; RV32I-NEXT:  .LBB100_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB100_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB100_4
; RV32I-NEXT:  .LBB100_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB100_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB100_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB100_1
; RV32I-NEXT:  .LBB100_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB100_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a7, a1, .LBB100_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB100_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB100_3: # in Loop: Header=BB100_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB100_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB100_2
; RV64I-NEXT:  .LBB100_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB100_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB100_4
; RV64I-NEXT:  .LBB100_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB100_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB100_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB100_1
; RV64I-NEXT:  .LBB100_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB100_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a7, a1, .LBB100_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB100_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB100_3: # in Loop: Header=BB100_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB100_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_max_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB101_2
; RV32I-NEXT:  .LBB101_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB101_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB101_4
; RV32I-NEXT:  .LBB101_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB101_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB101_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB101_1
; RV32I-NEXT:  .LBB101_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB101_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a7, a1, .LBB101_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB101_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB101_3: # in Loop: Header=BB101_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB101_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB101_2
; RV64I-NEXT:  .LBB101_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB101_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB101_4
; RV64I-NEXT:  .LBB101_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB101_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB101_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB101_1
; RV64I-NEXT:  .LBB101_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB101_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a7, a1, .LBB101_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB101_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB101_3: # in Loop: Header=BB101_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB101_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_max_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB102_2
; RV32I-NEXT:  .LBB102_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB102_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB102_4
; RV32I-NEXT:  .LBB102_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB102_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB102_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB102_1
; RV32I-NEXT:  .LBB102_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB102_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a7, a1, .LBB102_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB102_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB102_3: # in Loop: Header=BB102_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB102_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB102_2
; RV64I-NEXT:  .LBB102_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB102_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB102_4
; RV64I-NEXT:  .LBB102_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB102_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB102_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB102_1
; RV64I-NEXT:  .LBB102_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB102_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a7, a1, .LBB102_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB102_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB102_3: # in Loop: Header=BB102_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB102_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_max_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB103_2
; RV32I-NEXT:  .LBB103_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB103_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB103_4
; RV32I-NEXT:  .LBB103_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB103_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB103_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB103_1
; RV32I-NEXT:  .LBB103_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB103_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a7, a1, .LBB103_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB103_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB103_3: # in Loop: Header=BB103_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB103_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB103_2
; RV64I-NEXT:  .LBB103_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB103_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB103_4
; RV64I-NEXT:  .LBB103_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB103_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB103_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB103_1
; RV64I-NEXT:  .LBB103_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB103_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a7, a1, .LBB103_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB103_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB103_3: # in Loop: Header=BB103_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB103_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_max_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB104_2
; RV32I-NEXT:  .LBB104_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB104_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB104_4
; RV32I-NEXT:  .LBB104_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s2, a0, .LBB104_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB104_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB104_1
; RV32I-NEXT:  .LBB104_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB104_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a7, a1, .LBB104_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB104_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB104_3: # in Loop: Header=BB104_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB104_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB104_2
; RV64I-NEXT:  .LBB104_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB104_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB104_4
; RV64I-NEXT:  .LBB104_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a0, .LBB104_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB104_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB104_1
; RV64I-NEXT:  .LBB104_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB104_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a7, a1, .LBB104_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB104_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB104_3: # in Loop: Header=BB104_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB104_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_min_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB105_2
; RV32I-NEXT:  .LBB105_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB105_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB105_4
; RV32I-NEXT:  .LBB105_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB105_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB105_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB105_1
; RV32I-NEXT:  .LBB105_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB105_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a1, a7, .LBB105_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB105_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB105_3: # in Loop: Header=BB105_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB105_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB105_2
; RV64I-NEXT:  .LBB105_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB105_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB105_4
; RV64I-NEXT:  .LBB105_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB105_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB105_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB105_1
; RV64I-NEXT:  .LBB105_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB105_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a1, a7, .LBB105_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB105_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB105_3: # in Loop: Header=BB105_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB105_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_min_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB106_2
; RV32I-NEXT:  .LBB106_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB106_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB106_4
; RV32I-NEXT:  .LBB106_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB106_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB106_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB106_1
; RV32I-NEXT:  .LBB106_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB106_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a1, a7, .LBB106_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB106_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB106_3: # in Loop: Header=BB106_1 Depth=1
; RV32IA-NEXT:    sc.w a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB106_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB106_2
; RV64I-NEXT:  .LBB106_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB106_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB106_4
; RV64I-NEXT:  .LBB106_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB106_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB106_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB106_1
; RV64I-NEXT:  .LBB106_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB106_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a1, a7, .LBB106_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB106_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB106_3: # in Loop: Header=BB106_1 Depth=1
; RV64IA-NEXT:    sc.w a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB106_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_min_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB107_2
; RV32I-NEXT:  .LBB107_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB107_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB107_4
; RV32I-NEXT:  .LBB107_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB107_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB107_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB107_1
; RV32I-NEXT:  .LBB107_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB107_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a1, a7, .LBB107_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB107_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB107_3: # in Loop: Header=BB107_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB107_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB107_2
; RV64I-NEXT:  .LBB107_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB107_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB107_4
; RV64I-NEXT:  .LBB107_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB107_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB107_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB107_1
; RV64I-NEXT:  .LBB107_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB107_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a1, a7, .LBB107_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB107_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB107_3: # in Loop: Header=BB107_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB107_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_min_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB108_2
; RV32I-NEXT:  .LBB108_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB108_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB108_4
; RV32I-NEXT:  .LBB108_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB108_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB108_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB108_1
; RV32I-NEXT:  .LBB108_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB108_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a1, a7, .LBB108_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB108_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB108_3: # in Loop: Header=BB108_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB108_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB108_2
; RV64I-NEXT:  .LBB108_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB108_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB108_4
; RV64I-NEXT:  .LBB108_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB108_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB108_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB108_1
; RV64I-NEXT:  .LBB108_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB108_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a1, a7, .LBB108_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB108_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB108_3: # in Loop: Header=BB108_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB108_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_min_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lhu a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    slli a0, a1, 16
; RV32I-NEXT:    srai s2, a0, 16
; RV32I-NEXT:    j .LBB109_2
; RV32I-NEXT:  .LBB109_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB109_2 Depth=1
; RV32I-NEXT:    sh a3, 14(sp)
; RV32I-NEXT:    addi a1, sp, 14
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a3, 14(sp)
; RV32I-NEXT:    bnez a0, .LBB109_4
; RV32I-NEXT:  .LBB109_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    slli a0, a3, 16
; RV32I-NEXT:    srai a0, a0, 16
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s2, a0, .LBB109_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB109_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB109_1
; RV32I-NEXT:  .LBB109_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    andi a3, a0, 24
; RV32IA-NEXT:    lui a4, 16
; RV32IA-NEXT:    addi a4, a4, -1
; RV32IA-NEXT:    sll a4, a4, a0
; RV32IA-NEXT:    slli a1, a1, 16
; RV32IA-NEXT:    srai a1, a1, 16
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:    li a5, 16
; RV32IA-NEXT:    sub a5, a5, a3
; RV32IA-NEXT:  .LBB109_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    and a7, a3, a4
; RV32IA-NEXT:    mv a6, a3
; RV32IA-NEXT:    sll a7, a7, a5
; RV32IA-NEXT:    sra a7, a7, a5
; RV32IA-NEXT:    bge a1, a7, .LBB109_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB109_1 Depth=1
; RV32IA-NEXT:    xor a6, a3, a1
; RV32IA-NEXT:    and a6, a6, a4
; RV32IA-NEXT:    xor a6, a3, a6
; RV32IA-NEXT:  .LBB109_3: # in Loop: Header=BB109_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV32IA-NEXT:    bnez a6, .LBB109_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lhu a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    slli a0, a1, 48
; RV64I-NEXT:    srai s2, a0, 48
; RV64I-NEXT:    j .LBB109_2
; RV64I-NEXT:  .LBB109_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB109_2 Depth=1
; RV64I-NEXT:    sh a3, 14(sp)
; RV64I-NEXT:    addi a1, sp, 14
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a3, 14(sp)
; RV64I-NEXT:    bnez a0, .LBB109_4
; RV64I-NEXT:  .LBB109_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    slli a0, a3, 48
; RV64I-NEXT:    srai a0, a0, 48
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a0, .LBB109_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB109_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB109_1
; RV64I-NEXT:  .LBB109_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    andi a3, a0, 24
; RV64IA-NEXT:    lui a4, 16
; RV64IA-NEXT:    addiw a4, a4, -1
; RV64IA-NEXT:    sllw a4, a4, a0
; RV64IA-NEXT:    slli a1, a1, 48
; RV64IA-NEXT:    srai a1, a1, 48
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:    li a5, 48
; RV64IA-NEXT:    sub a5, a5, a3
; RV64IA-NEXT:  .LBB109_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    and a7, a3, a4
; RV64IA-NEXT:    mv a6, a3
; RV64IA-NEXT:    sll a7, a7, a5
; RV64IA-NEXT:    sra a7, a7, a5
; RV64IA-NEXT:    bge a1, a7, .LBB109_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB109_1 Depth=1
; RV64IA-NEXT:    xor a6, a3, a1
; RV64IA-NEXT:    and a6, a6, a4
; RV64IA-NEXT:    xor a6, a3, a6
; RV64IA-NEXT:  .LBB109_3: # in Loop: Header=BB109_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a6, a6, (a2)
; RV64IA-NEXT:    bnez a6, .LBB109_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_umax_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB110_2
; RV32I-NEXT:  .LBB110_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB110_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB110_4
; RV32I-NEXT:  .LBB110_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bltu s3, a0, .LBB110_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB110_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB110_1
; RV32I-NEXT:  .LBB110_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB110_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a6, a1, .LBB110_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB110_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB110_3: # in Loop: Header=BB110_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB110_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB110_2
; RV64I-NEXT:  .LBB110_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB110_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB110_4
; RV64I-NEXT:  .LBB110_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bltu s3, a0, .LBB110_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB110_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB110_1
; RV64I-NEXT:  .LBB110_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB110_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a6, a1, .LBB110_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB110_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB110_3: # in Loop: Header=BB110_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB110_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_umax_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB111_2
; RV32I-NEXT:  .LBB111_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB111_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB111_4
; RV32I-NEXT:  .LBB111_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bltu s3, a0, .LBB111_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB111_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB111_1
; RV32I-NEXT:  .LBB111_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB111_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a6, a1, .LBB111_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB111_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB111_3: # in Loop: Header=BB111_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB111_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB111_2
; RV64I-NEXT:  .LBB111_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB111_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB111_4
; RV64I-NEXT:  .LBB111_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bltu s3, a0, .LBB111_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB111_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB111_1
; RV64I-NEXT:  .LBB111_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB111_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a6, a1, .LBB111_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB111_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB111_3: # in Loop: Header=BB111_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB111_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_umax_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB112_2
; RV32I-NEXT:  .LBB112_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB112_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB112_4
; RV32I-NEXT:  .LBB112_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bltu s3, a0, .LBB112_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB112_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB112_1
; RV32I-NEXT:  .LBB112_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB112_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a6, a1, .LBB112_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB112_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB112_3: # in Loop: Header=BB112_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB112_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB112_2
; RV64I-NEXT:  .LBB112_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB112_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB112_4
; RV64I-NEXT:  .LBB112_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bltu s3, a0, .LBB112_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB112_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB112_1
; RV64I-NEXT:  .LBB112_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB112_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a6, a1, .LBB112_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB112_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB112_3: # in Loop: Header=BB112_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB112_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_umax_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB113_2
; RV32I-NEXT:  .LBB113_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB113_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB113_4
; RV32I-NEXT:  .LBB113_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bltu s3, a0, .LBB113_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB113_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB113_1
; RV32I-NEXT:  .LBB113_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB113_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a6, a1, .LBB113_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB113_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB113_3: # in Loop: Header=BB113_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB113_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB113_2
; RV64I-NEXT:  .LBB113_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB113_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB113_4
; RV64I-NEXT:  .LBB113_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bltu s3, a0, .LBB113_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB113_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB113_1
; RV64I-NEXT:  .LBB113_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB113_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a6, a1, .LBB113_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB113_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB113_3: # in Loop: Header=BB113_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB113_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_umax_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB114_2
; RV32I-NEXT:  .LBB114_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB114_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB114_4
; RV32I-NEXT:  .LBB114_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bltu s3, a0, .LBB114_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB114_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB114_1
; RV32I-NEXT:  .LBB114_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB114_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a6, a1, .LBB114_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB114_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB114_3: # in Loop: Header=BB114_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB114_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB114_2
; RV64I-NEXT:  .LBB114_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB114_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB114_4
; RV64I-NEXT:  .LBB114_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bltu s3, a0, .LBB114_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB114_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB114_1
; RV64I-NEXT:  .LBB114_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB114_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a6, a1, .LBB114_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB114_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB114_3: # in Loop: Header=BB114_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB114_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i16 @atomicrmw_umin_i16_monotonic(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i16_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB115_2
; RV32I-NEXT:  .LBB115_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB115_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB115_4
; RV32I-NEXT:  .LBB115_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bgeu s3, a0, .LBB115_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB115_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB115_1
; RV32I-NEXT:  .LBB115_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i16_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB115_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a1, a6, .LBB115_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB115_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB115_3: # in Loop: Header=BB115_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB115_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i16_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB115_2
; RV64I-NEXT:  .LBB115_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB115_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB115_4
; RV64I-NEXT:  .LBB115_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bgeu s3, a0, .LBB115_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB115_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB115_1
; RV64I-NEXT:  .LBB115_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i16_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB115_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a1, a6, .LBB115_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB115_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB115_3: # in Loop: Header=BB115_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB115_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i16 %b monotonic
  ret i16 %1
}

define i16 @atomicrmw_umin_i16_acquire(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i16_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB116_2
; RV32I-NEXT:  .LBB116_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB116_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB116_4
; RV32I-NEXT:  .LBB116_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bgeu s3, a0, .LBB116_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB116_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB116_1
; RV32I-NEXT:  .LBB116_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i16_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB116_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a1, a6, .LBB116_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB116_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB116_3: # in Loop: Header=BB116_1 Depth=1
; RV32IA-NEXT:    sc.w a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB116_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i16_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB116_2
; RV64I-NEXT:  .LBB116_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB116_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB116_4
; RV64I-NEXT:  .LBB116_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bgeu s3, a0, .LBB116_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB116_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB116_1
; RV64I-NEXT:  .LBB116_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i16_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB116_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a1, a6, .LBB116_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB116_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB116_3: # in Loop: Header=BB116_1 Depth=1
; RV64IA-NEXT:    sc.w a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB116_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i16 %b acquire
  ret i16 %1
}

define i16 @atomicrmw_umin_i16_release(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i16_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB117_2
; RV32I-NEXT:  .LBB117_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB117_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB117_4
; RV32I-NEXT:  .LBB117_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bgeu s3, a0, .LBB117_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB117_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB117_1
; RV32I-NEXT:  .LBB117_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i16_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB117_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a1, a6, .LBB117_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB117_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB117_3: # in Loop: Header=BB117_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB117_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i16_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB117_2
; RV64I-NEXT:  .LBB117_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB117_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB117_4
; RV64I-NEXT:  .LBB117_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bgeu s3, a0, .LBB117_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB117_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB117_1
; RV64I-NEXT:  .LBB117_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i16_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB117_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a1, a6, .LBB117_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB117_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB117_3: # in Loop: Header=BB117_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB117_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i16 %b release
  ret i16 %1
}

define i16 @atomicrmw_umin_i16_acq_rel(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i16_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB118_2
; RV32I-NEXT:  .LBB118_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB118_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB118_4
; RV32I-NEXT:  .LBB118_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bgeu s3, a0, .LBB118_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB118_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB118_1
; RV32I-NEXT:  .LBB118_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i16_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB118_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a1, a6, .LBB118_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB118_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB118_3: # in Loop: Header=BB118_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB118_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i16_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB118_2
; RV64I-NEXT:  .LBB118_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB118_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB118_4
; RV64I-NEXT:  .LBB118_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bgeu s3, a0, .LBB118_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB118_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB118_1
; RV64I-NEXT:  .LBB118_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i16_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB118_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a1, a6, .LBB118_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB118_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB118_3: # in Loop: Header=BB118_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB118_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i16 %b acq_rel
  ret i16 %1
}

define i16 @atomicrmw_umin_i16_seq_cst(ptr %a, i16 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i16_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s3, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a1
; RV32I-NEXT:    mv s1, a0
; RV32I-NEXT:    lhu a1, 0(a0)
; RV32I-NEXT:    lui s2, 16
; RV32I-NEXT:    addi s2, s2, -1
; RV32I-NEXT:    and s3, s0, s2
; RV32I-NEXT:    j .LBB119_2
; RV32I-NEXT:  .LBB119_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB119_2 Depth=1
; RV32I-NEXT:    sh a1, 10(sp)
; RV32I-NEXT:    addi a1, sp, 10
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s1
; RV32I-NEXT:    call __atomic_compare_exchange_2@plt
; RV32I-NEXT:    lh a1, 10(sp)
; RV32I-NEXT:    bnez a0, .LBB119_4
; RV32I-NEXT:  .LBB119_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    and a0, a1, s2
; RV32I-NEXT:    mv a2, a1
; RV32I-NEXT:    bgeu s3, a0, .LBB119_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB119_2 Depth=1
; RV32I-NEXT:    mv a2, s0
; RV32I-NEXT:    j .LBB119_1
; RV32I-NEXT:  .LBB119_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a1
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s3, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i16_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    andi a2, a0, -4
; RV32IA-NEXT:    slli a0, a0, 3
; RV32IA-NEXT:    lui a3, 16
; RV32IA-NEXT:    addi a3, a3, -1
; RV32IA-NEXT:    sll a4, a3, a0
; RV32IA-NEXT:    and a1, a1, a3
; RV32IA-NEXT:    sll a1, a1, a0
; RV32IA-NEXT:  .LBB119_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a3, (a2)
; RV32IA-NEXT:    and a6, a3, a4
; RV32IA-NEXT:    mv a5, a3
; RV32IA-NEXT:    bgeu a1, a6, .LBB119_3
; RV32IA-NEXT:  # %bb.2: # in Loop: Header=BB119_1 Depth=1
; RV32IA-NEXT:    xor a5, a3, a1
; RV32IA-NEXT:    and a5, a5, a4
; RV32IA-NEXT:    xor a5, a3, a5
; RV32IA-NEXT:  .LBB119_3: # in Loop: Header=BB119_1 Depth=1
; RV32IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV32IA-NEXT:    bnez a5, .LBB119_1
; RV32IA-NEXT:  # %bb.4:
; RV32IA-NEXT:    srl a0, a3, a0
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i16_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s3, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a1
; RV64I-NEXT:    mv s1, a0
; RV64I-NEXT:    lhu a1, 0(a0)
; RV64I-NEXT:    lui s2, 16
; RV64I-NEXT:    addiw s2, s2, -1
; RV64I-NEXT:    and s3, s0, s2
; RV64I-NEXT:    j .LBB119_2
; RV64I-NEXT:  .LBB119_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB119_2 Depth=1
; RV64I-NEXT:    sh a1, 6(sp)
; RV64I-NEXT:    addi a1, sp, 6
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s1
; RV64I-NEXT:    call __atomic_compare_exchange_2@plt
; RV64I-NEXT:    lh a1, 6(sp)
; RV64I-NEXT:    bnez a0, .LBB119_4
; RV64I-NEXT:  .LBB119_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    and a0, a1, s2
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    bgeu s3, a0, .LBB119_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB119_2 Depth=1
; RV64I-NEXT:    mv a2, s0
; RV64I-NEXT:    j .LBB119_1
; RV64I-NEXT:  .LBB119_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a1
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s3, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i16_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    andi a2, a0, -4
; RV64IA-NEXT:    slli a0, a0, 3
; RV64IA-NEXT:    lui a3, 16
; RV64IA-NEXT:    addiw a3, a3, -1
; RV64IA-NEXT:    sllw a4, a3, a0
; RV64IA-NEXT:    and a1, a1, a3
; RV64IA-NEXT:    sllw a1, a1, a0
; RV64IA-NEXT:  .LBB119_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a3, (a2)
; RV64IA-NEXT:    and a6, a3, a4
; RV64IA-NEXT:    mv a5, a3
; RV64IA-NEXT:    bgeu a1, a6, .LBB119_3
; RV64IA-NEXT:  # %bb.2: # in Loop: Header=BB119_1 Depth=1
; RV64IA-NEXT:    xor a5, a3, a1
; RV64IA-NEXT:    and a5, a5, a4
; RV64IA-NEXT:    xor a5, a3, a5
; RV64IA-NEXT:  .LBB119_3: # in Loop: Header=BB119_1 Depth=1
; RV64IA-NEXT:    sc.w.rl a5, a5, (a2)
; RV64IA-NEXT:    bnez a5, .LBB119_1
; RV64IA-NEXT:  # %bb.4:
; RV64IA-NEXT:    srlw a0, a3, a0
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i16 %b seq_cst
  ret i16 %1
}

define i32 @atomicrmw_xchg_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_exchange_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoswap.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_exchange_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_xchg_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_exchange_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoswap.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_exchange_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_xchg_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_exchange_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoswap.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_exchange_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_xchg_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_exchange_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoswap.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_exchange_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_xchg_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_exchange_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoswap.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_exchange_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_add_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_add_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoadd.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_add_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_add_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_add_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoadd.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_add_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_add_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_add_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoadd.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_add_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_add_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_add_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_add_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_add_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_add_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_add_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_sub_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_sub_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    neg a1, a1
; RV32IA-NEXT:    amoadd.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_sub_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_sub_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_sub_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    neg a1, a1
; RV32IA-NEXT:    amoadd.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_sub_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_sub_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_sub_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    neg a1, a1
; RV32IA-NEXT:    amoadd.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_sub_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_sub_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_sub_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    neg a1, a1
; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_sub_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_sub_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_sub_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    neg a1, a1
; RV32IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_sub_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_and_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_and_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoand.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_and_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_and_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_and_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoand.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_and_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_and_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_and_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoand.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_and_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_and_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_and_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_and_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_and_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_and_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_and_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_nand_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_nand_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:  .LBB140_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a2, (a0)
; RV32IA-NEXT:    and a3, a2, a1
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    sc.w a3, a3, (a0)
; RV32IA-NEXT:    bnez a3, .LBB140_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    mv a0, a2
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_nand_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB140_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.w a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB140_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_nand_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_nand_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:  .LBB141_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a2, (a0)
; RV32IA-NEXT:    and a3, a2, a1
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    sc.w a3, a3, (a0)
; RV32IA-NEXT:    bnez a3, .LBB141_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    mv a0, a2
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_nand_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB141_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.w a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB141_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_nand_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_nand_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:  .LBB142_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w a2, (a0)
; RV32IA-NEXT:    and a3, a2, a1
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
; RV32IA-NEXT:    bnez a3, .LBB142_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    mv a0, a2
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_nand_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB142_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.w.rl a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB142_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_nand_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_nand_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:  .LBB143_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aq a2, (a0)
; RV32IA-NEXT:    and a3, a2, a1
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
; RV32IA-NEXT:    bnez a3, .LBB143_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    mv a0, a2
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_nand_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB143_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aq a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.w.rl a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB143_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_nand_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_nand_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:  .LBB144_1: # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    lr.w.aqrl a2, (a0)
; RV32IA-NEXT:    and a3, a2, a1
; RV32IA-NEXT:    not a3, a3
; RV32IA-NEXT:    sc.w.rl a3, a3, (a0)
; RV32IA-NEXT:    bnez a3, .LBB144_1
; RV32IA-NEXT:  # %bb.2:
; RV32IA-NEXT:    mv a0, a2
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_nand_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB144_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.w.aqrl a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.w.rl a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB144_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_or_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_or_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoor.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_or_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_or_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_or_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoor.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_or_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_or_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_or_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoor.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_or_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_or_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_or_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_or_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_or_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_or_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_or_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_xor_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:    call __atomic_fetch_xor_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoxor.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_xor_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_xor_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 2
; RV32I-NEXT:    call __atomic_fetch_xor_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoxor.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_xor_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_xor_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 3
; RV32I-NEXT:    call __atomic_fetch_xor_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoxor.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_xor_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_xor_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 4
; RV32I-NEXT:    call __atomic_fetch_xor_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_xor_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_xor_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a2, 5
; RV32I-NEXT:    call __atomic_fetch_xor_4@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_xor_4@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_max_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB155_2
; RV32I-NEXT:  .LBB155_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB155_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB155_4
; RV32I-NEXT:  .LBB155_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s1, a3, .LBB155_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB155_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB155_1
; RV32I-NEXT:  .LBB155_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomax.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB155_2
; RV64I-NEXT:  .LBB155_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB155_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB155_4
; RV64I-NEXT:  .LBB155_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a3, .LBB155_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB155_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB155_1
; RV64I-NEXT:  .LBB155_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_max_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB156_2
; RV32I-NEXT:  .LBB156_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB156_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB156_4
; RV32I-NEXT:  .LBB156_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s1, a3, .LBB156_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB156_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB156_1
; RV32I-NEXT:  .LBB156_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomax.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB156_2
; RV64I-NEXT:  .LBB156_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB156_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB156_4
; RV64I-NEXT:  .LBB156_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a3, .LBB156_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB156_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB156_1
; RV64I-NEXT:  .LBB156_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_max_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB157_2
; RV32I-NEXT:  .LBB157_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB157_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB157_4
; RV32I-NEXT:  .LBB157_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s1, a3, .LBB157_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB157_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB157_1
; RV32I-NEXT:  .LBB157_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomax.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB157_2
; RV64I-NEXT:  .LBB157_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB157_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB157_4
; RV64I-NEXT:  .LBB157_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a3, .LBB157_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB157_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB157_1
; RV64I-NEXT:  .LBB157_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_max_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB158_2
; RV32I-NEXT:  .LBB158_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB158_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB158_4
; RV32I-NEXT:  .LBB158_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s1, a3, .LBB158_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB158_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB158_1
; RV32I-NEXT:  .LBB158_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomax.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB158_2
; RV64I-NEXT:  .LBB158_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB158_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB158_4
; RV64I-NEXT:  .LBB158_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a3, .LBB158_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB158_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB158_1
; RV64I-NEXT:  .LBB158_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_max_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB159_2
; RV32I-NEXT:  .LBB159_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB159_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB159_4
; RV32I-NEXT:  .LBB159_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    blt s1, a3, .LBB159_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB159_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB159_1
; RV32I-NEXT:  .LBB159_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomax.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB159_2
; RV64I-NEXT:  .LBB159_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB159_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB159_4
; RV64I-NEXT:  .LBB159_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s2, a3, .LBB159_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB159_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB159_1
; RV64I-NEXT:  .LBB159_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_min_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB160_2
; RV32I-NEXT:  .LBB160_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB160_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB160_4
; RV32I-NEXT:  .LBB160_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s1, a3, .LBB160_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB160_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB160_1
; RV32I-NEXT:  .LBB160_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomin.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB160_2
; RV64I-NEXT:  .LBB160_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB160_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB160_4
; RV64I-NEXT:  .LBB160_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a3, .LBB160_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB160_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB160_1
; RV64I-NEXT:  .LBB160_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_min_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB161_2
; RV32I-NEXT:  .LBB161_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB161_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB161_4
; RV32I-NEXT:  .LBB161_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s1, a3, .LBB161_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB161_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB161_1
; RV32I-NEXT:  .LBB161_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomin.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB161_2
; RV64I-NEXT:  .LBB161_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB161_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB161_4
; RV64I-NEXT:  .LBB161_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a3, .LBB161_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB161_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB161_1
; RV64I-NEXT:  .LBB161_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_min_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB162_2
; RV32I-NEXT:  .LBB162_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB162_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB162_4
; RV32I-NEXT:  .LBB162_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s1, a3, .LBB162_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB162_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB162_1
; RV32I-NEXT:  .LBB162_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomin.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB162_2
; RV64I-NEXT:  .LBB162_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB162_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB162_4
; RV64I-NEXT:  .LBB162_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a3, .LBB162_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB162_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB162_1
; RV64I-NEXT:  .LBB162_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_min_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB163_2
; RV32I-NEXT:  .LBB163_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB163_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB163_4
; RV32I-NEXT:  .LBB163_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s1, a3, .LBB163_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB163_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB163_1
; RV32I-NEXT:  .LBB163_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomin.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB163_2
; RV64I-NEXT:  .LBB163_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB163_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB163_4
; RV64I-NEXT:  .LBB163_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a3, .LBB163_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB163_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB163_1
; RV64I-NEXT:  .LBB163_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_min_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB164_2
; RV32I-NEXT:  .LBB164_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB164_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB164_4
; RV32I-NEXT:  .LBB164_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bge s1, a3, .LBB164_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB164_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB164_1
; RV32I-NEXT:  .LBB164_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomin.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB164_2
; RV64I-NEXT:  .LBB164_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB164_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB164_4
; RV64I-NEXT:  .LBB164_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s2, a3, .LBB164_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB164_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB164_1
; RV64I-NEXT:  .LBB164_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_umax_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB165_2
; RV32I-NEXT:  .LBB165_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB165_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB165_4
; RV32I-NEXT:  .LBB165_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s1, a3, .LBB165_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB165_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB165_1
; RV32I-NEXT:  .LBB165_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomaxu.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB165_2
; RV64I-NEXT:  .LBB165_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB165_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB165_4
; RV64I-NEXT:  .LBB165_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a3, .LBB165_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB165_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB165_1
; RV64I-NEXT:  .LBB165_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_umax_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB166_2
; RV32I-NEXT:  .LBB166_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB166_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB166_4
; RV32I-NEXT:  .LBB166_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s1, a3, .LBB166_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB166_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB166_1
; RV32I-NEXT:  .LBB166_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomaxu.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB166_2
; RV64I-NEXT:  .LBB166_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB166_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB166_4
; RV64I-NEXT:  .LBB166_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a3, .LBB166_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB166_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB166_1
; RV64I-NEXT:  .LBB166_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_umax_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB167_2
; RV32I-NEXT:  .LBB167_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB167_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB167_4
; RV32I-NEXT:  .LBB167_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s1, a3, .LBB167_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB167_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB167_1
; RV32I-NEXT:  .LBB167_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomaxu.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB167_2
; RV64I-NEXT:  .LBB167_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB167_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB167_4
; RV64I-NEXT:  .LBB167_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a3, .LBB167_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB167_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB167_1
; RV64I-NEXT:  .LBB167_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_umax_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB168_2
; RV32I-NEXT:  .LBB168_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB168_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB168_4
; RV32I-NEXT:  .LBB168_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s1, a3, .LBB168_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB168_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB168_1
; RV32I-NEXT:  .LBB168_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomaxu.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB168_2
; RV64I-NEXT:  .LBB168_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB168_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB168_4
; RV64I-NEXT:  .LBB168_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a3, .LBB168_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB168_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB168_1
; RV64I-NEXT:  .LBB168_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_umax_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB169_2
; RV32I-NEXT:  .LBB169_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB169_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB169_4
; RV32I-NEXT:  .LBB169_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bltu s1, a3, .LBB169_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB169_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB169_1
; RV32I-NEXT:  .LBB169_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amomaxu.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB169_2
; RV64I-NEXT:  .LBB169_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB169_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB169_4
; RV64I-NEXT:  .LBB169_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s2, a3, .LBB169_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB169_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB169_1
; RV64I-NEXT:  .LBB169_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i32 @atomicrmw_umin_i32_monotonic(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i32_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB170_2
; RV32I-NEXT:  .LBB170_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB170_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB170_4
; RV32I-NEXT:  .LBB170_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s1, a3, .LBB170_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB170_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB170_1
; RV32I-NEXT:  .LBB170_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i32_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amominu.w a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i32_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB170_2
; RV64I-NEXT:  .LBB170_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB170_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB170_4
; RV64I-NEXT:  .LBB170_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a3, .LBB170_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB170_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB170_1
; RV64I-NEXT:  .LBB170_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i32_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.w a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i32 %b monotonic
  ret i32 %1
}

define i32 @atomicrmw_umin_i32_acquire(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i32_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB171_2
; RV32I-NEXT:  .LBB171_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB171_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB171_4
; RV32I-NEXT:  .LBB171_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s1, a3, .LBB171_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB171_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB171_1
; RV32I-NEXT:  .LBB171_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i32_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amominu.w.aq a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i32_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB171_2
; RV64I-NEXT:  .LBB171_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB171_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB171_4
; RV64I-NEXT:  .LBB171_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a3, .LBB171_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB171_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB171_1
; RV64I-NEXT:  .LBB171_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i32_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.w.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i32 %b acquire
  ret i32 %1
}

define i32 @atomicrmw_umin_i32_release(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i32_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB172_2
; RV32I-NEXT:  .LBB172_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB172_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB172_4
; RV32I-NEXT:  .LBB172_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s1, a3, .LBB172_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB172_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB172_1
; RV32I-NEXT:  .LBB172_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i32_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amominu.w.rl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i32_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB172_2
; RV64I-NEXT:  .LBB172_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB172_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB172_4
; RV64I-NEXT:  .LBB172_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a3, .LBB172_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB172_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB172_1
; RV64I-NEXT:  .LBB172_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i32_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.w.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i32 %b release
  ret i32 %1
}

define i32 @atomicrmw_umin_i32_acq_rel(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i32_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB173_2
; RV32I-NEXT:  .LBB173_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB173_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB173_4
; RV32I-NEXT:  .LBB173_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s1, a3, .LBB173_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB173_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB173_1
; RV32I-NEXT:  .LBB173_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i32_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amominu.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i32_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB173_2
; RV64I-NEXT:  .LBB173_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB173_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB173_4
; RV64I-NEXT:  .LBB173_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a3, .LBB173_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB173_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB173_1
; RV64I-NEXT:  .LBB173_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i32_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i32 %b acq_rel
  ret i32 %1
}

define i32 @atomicrmw_umin_i32_seq_cst(ptr %a, i32 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i32_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a3, 0(a0)
; RV32I-NEXT:    mv s1, a1
; RV32I-NEXT:    j .LBB174_2
; RV32I-NEXT:  .LBB174_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB174_2 Depth=1
; RV32I-NEXT:    sw a3, 0(sp)
; RV32I-NEXT:    mv a1, sp
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_4@plt
; RV32I-NEXT:    lw a3, 0(sp)
; RV32I-NEXT:    bnez a0, .LBB174_4
; RV32I-NEXT:  .LBB174_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    mv a2, a3
; RV32I-NEXT:    bgeu s1, a3, .LBB174_1
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB174_2 Depth=1
; RV32I-NEXT:    mv a2, s1
; RV32I-NEXT:    j .LBB174_1
; RV32I-NEXT:  .LBB174_4: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a3
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i32_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    amominu.w.aqrl a0, a1, (a0)
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i32_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -48
; RV64I-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    lw a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    sext.w s2, a1
; RV64I-NEXT:    j .LBB174_2
; RV64I-NEXT:  .LBB174_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB174_2 Depth=1
; RV64I-NEXT:    sw a3, 12(sp)
; RV64I-NEXT:    addi a1, sp, 12
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_4@plt
; RV64I-NEXT:    lw a3, 12(sp)
; RV64I-NEXT:    bnez a0, .LBB174_4
; RV64I-NEXT:  .LBB174_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s2, a3, .LBB174_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB174_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB174_1
; RV64I-NEXT:  .LBB174_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 48
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i32_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.w.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i32 %b seq_cst
  ret i32 %1
}

define i64 @atomicrmw_xchg_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    call __atomic_exchange_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 0
; RV32IA-NEXT:    call __atomic_exchange_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_exchange_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_xchg_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    call __atomic_exchange_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 2
; RV32IA-NEXT:    call __atomic_exchange_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_exchange_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_xchg_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    call __atomic_exchange_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 3
; RV32IA-NEXT:    call __atomic_exchange_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_exchange_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_xchg_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    call __atomic_exchange_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 4
; RV32IA-NEXT:    call __atomic_exchange_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_exchange_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_xchg_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xchg_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    call __atomic_exchange_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xchg_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 5
; RV32IA-NEXT:    call __atomic_exchange_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xchg_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_exchange_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xchg_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoswap.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xchg ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_add_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    call __atomic_fetch_add_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 0
; RV32IA-NEXT:    call __atomic_fetch_add_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_add_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_add_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    call __atomic_fetch_add_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 2
; RV32IA-NEXT:    call __atomic_fetch_add_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_add_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_add_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    call __atomic_fetch_add_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 3
; RV32IA-NEXT:    call __atomic_fetch_add_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_add_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_add_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    call __atomic_fetch_add_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 4
; RV32IA-NEXT:    call __atomic_fetch_add_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_add_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_add_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_add_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    call __atomic_fetch_add_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_add_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 5
; RV32IA-NEXT:    call __atomic_fetch_add_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_add_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_add_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_add_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoadd.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw add ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_sub_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    call __atomic_fetch_sub_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 0
; RV32IA-NEXT:    call __atomic_fetch_sub_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_sub_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_sub_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    call __atomic_fetch_sub_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 2
; RV32IA-NEXT:    call __atomic_fetch_sub_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_sub_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_sub_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    call __atomic_fetch_sub_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 3
; RV32IA-NEXT:    call __atomic_fetch_sub_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_sub_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_sub_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    call __atomic_fetch_sub_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 4
; RV32IA-NEXT:    call __atomic_fetch_sub_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_sub_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_sub_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_sub_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    call __atomic_fetch_sub_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_sub_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 5
; RV32IA-NEXT:    call __atomic_fetch_sub_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_sub_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_sub_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_sub_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    neg a1, a1
; RV64IA-NEXT:    amoadd.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw sub ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_and_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    call __atomic_fetch_and_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 0
; RV32IA-NEXT:    call __atomic_fetch_and_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_and_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_and_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    call __atomic_fetch_and_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 2
; RV32IA-NEXT:    call __atomic_fetch_and_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_and_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_and_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    call __atomic_fetch_and_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 3
; RV32IA-NEXT:    call __atomic_fetch_and_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_and_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_and_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    call __atomic_fetch_and_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 4
; RV32IA-NEXT:    call __atomic_fetch_and_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_and_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_and_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_and_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    call __atomic_fetch_and_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_and_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 5
; RV32IA-NEXT:    call __atomic_fetch_and_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_and_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_and_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_and_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoand.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw and ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_nand_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    call __atomic_fetch_nand_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 0
; RV32IA-NEXT:    call __atomic_fetch_nand_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_nand_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB195_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.d a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.d a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB195_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_nand_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    call __atomic_fetch_nand_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 2
; RV32IA-NEXT:    call __atomic_fetch_nand_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_nand_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB196_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.d.aq a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.d a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB196_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_nand_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    call __atomic_fetch_nand_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 3
; RV32IA-NEXT:    call __atomic_fetch_nand_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_nand_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB197_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.d a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.d.rl a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB197_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_nand_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    call __atomic_fetch_nand_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 4
; RV32IA-NEXT:    call __atomic_fetch_nand_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_nand_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB198_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.d.aq a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.d.rl a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB198_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_nand_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_nand_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    call __atomic_fetch_nand_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_nand_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 5
; RV32IA-NEXT:    call __atomic_fetch_nand_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_nand_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_nand_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_nand_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:  .LBB199_1: # =>This Inner Loop Header: Depth=1
; RV64IA-NEXT:    lr.d.aqrl a2, (a0)
; RV64IA-NEXT:    and a3, a2, a1
; RV64IA-NEXT:    not a3, a3
; RV64IA-NEXT:    sc.d.rl a3, a3, (a0)
; RV64IA-NEXT:    bnez a3, .LBB199_1
; RV64IA-NEXT:  # %bb.2:
; RV64IA-NEXT:    mv a0, a2
; RV64IA-NEXT:    ret
  %1 = atomicrmw nand ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_or_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    call __atomic_fetch_or_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 0
; RV32IA-NEXT:    call __atomic_fetch_or_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_or_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_or_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    call __atomic_fetch_or_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 2
; RV32IA-NEXT:    call __atomic_fetch_or_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_or_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_or_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    call __atomic_fetch_or_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 3
; RV32IA-NEXT:    call __atomic_fetch_or_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_or_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_or_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    call __atomic_fetch_or_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 4
; RV32IA-NEXT:    call __atomic_fetch_or_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_or_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_or_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_or_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    call __atomic_fetch_or_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_or_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 5
; RV32IA-NEXT:    call __atomic_fetch_or_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_or_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_or_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_or_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoor.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw or ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_xor_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 0
; RV32I-NEXT:    call __atomic_fetch_xor_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 0
; RV32IA-NEXT:    call __atomic_fetch_xor_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:    call __atomic_fetch_xor_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_xor_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 2
; RV32I-NEXT:    call __atomic_fetch_xor_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 2
; RV32IA-NEXT:    call __atomic_fetch_xor_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    call __atomic_fetch_xor_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_xor_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 3
; RV32I-NEXT:    call __atomic_fetch_xor_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 3
; RV32IA-NEXT:    call __atomic_fetch_xor_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 3
; RV64I-NEXT:    call __atomic_fetch_xor_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_xor_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 4
; RV32I-NEXT:    call __atomic_fetch_xor_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 4
; RV32IA-NEXT:    call __atomic_fetch_xor_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    call __atomic_fetch_xor_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_xor_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_xor_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -16
; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32I-NEXT:    li a3, 5
; RV32I-NEXT:    call __atomic_fetch_xor_8@plt
; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 16
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_xor_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -16
; RV32IA-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    li a3, 5
; RV32IA-NEXT:    call __atomic_fetch_xor_8@plt
; RV32IA-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 16
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_xor_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    li a2, 5
; RV64I-NEXT:    call __atomic_fetch_xor_8@plt
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_xor_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amoxor.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw xor ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_max_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB210_2
; RV32I-NEXT:  .LBB210_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB210_7
; RV32I-NEXT:  .LBB210_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB210_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB210_5
; RV32I-NEXT:  .LBB210_4: # in Loop: Header=BB210_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB210_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB210_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB210_1
; RV32I-NEXT:  .LBB210_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB210_2
; RV32IA-NEXT:  .LBB210_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB210_7
; RV32IA-NEXT:  .LBB210_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB210_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB210_5
; RV32IA-NEXT:  .LBB210_4: # in Loop: Header=BB210_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB210_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB210_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB210_1
; RV32IA-NEXT:  .LBB210_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB210_2
; RV64I-NEXT:  .LBB210_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB210_4
; RV64I-NEXT:  .LBB210_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s1, a3, .LBB210_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB210_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB210_1
; RV64I-NEXT:  .LBB210_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_max_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB211_2
; RV32I-NEXT:  .LBB211_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB211_7
; RV32I-NEXT:  .LBB211_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB211_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB211_5
; RV32I-NEXT:  .LBB211_4: # in Loop: Header=BB211_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB211_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB211_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB211_1
; RV32I-NEXT:  .LBB211_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB211_2
; RV32IA-NEXT:  .LBB211_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 2
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB211_7
; RV32IA-NEXT:  .LBB211_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB211_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB211_5
; RV32IA-NEXT:  .LBB211_4: # in Loop: Header=BB211_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB211_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB211_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB211_1
; RV32IA-NEXT:  .LBB211_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB211_2
; RV64I-NEXT:  .LBB211_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB211_4
; RV64I-NEXT:  .LBB211_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s1, a3, .LBB211_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB211_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB211_1
; RV64I-NEXT:  .LBB211_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_max_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB212_2
; RV32I-NEXT:  .LBB212_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB212_7
; RV32I-NEXT:  .LBB212_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB212_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB212_5
; RV32I-NEXT:  .LBB212_4: # in Loop: Header=BB212_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB212_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB212_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB212_1
; RV32I-NEXT:  .LBB212_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB212_2
; RV32IA-NEXT:  .LBB212_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 3
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB212_7
; RV32IA-NEXT:  .LBB212_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB212_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB212_5
; RV32IA-NEXT:  .LBB212_4: # in Loop: Header=BB212_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB212_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB212_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB212_1
; RV32IA-NEXT:  .LBB212_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB212_2
; RV64I-NEXT:  .LBB212_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB212_4
; RV64I-NEXT:  .LBB212_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s1, a3, .LBB212_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB212_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB212_1
; RV64I-NEXT:  .LBB212_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_max_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB213_2
; RV32I-NEXT:  .LBB213_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 4
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB213_7
; RV32I-NEXT:  .LBB213_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB213_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB213_5
; RV32I-NEXT:  .LBB213_4: # in Loop: Header=BB213_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB213_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB213_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB213_1
; RV32I-NEXT:  .LBB213_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB213_2
; RV32IA-NEXT:  .LBB213_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 4
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB213_7
; RV32IA-NEXT:  .LBB213_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB213_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB213_5
; RV32IA-NEXT:  .LBB213_4: # in Loop: Header=BB213_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB213_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB213_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB213_1
; RV32IA-NEXT:  .LBB213_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB213_2
; RV64I-NEXT:  .LBB213_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB213_4
; RV64I-NEXT:  .LBB213_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s1, a3, .LBB213_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB213_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB213_1
; RV64I-NEXT:  .LBB213_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_max_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_max_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB214_2
; RV32I-NEXT:  .LBB214_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    li a5, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB214_7
; RV32I-NEXT:  .LBB214_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB214_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB214_5
; RV32I-NEXT:  .LBB214_4: # in Loop: Header=BB214_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB214_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB214_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB214_1
; RV32I-NEXT:  .LBB214_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_max_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB214_2
; RV32IA-NEXT:  .LBB214_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 5
; RV32IA-NEXT:    li a5, 5
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB214_7
; RV32IA-NEXT:  .LBB214_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB214_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB214_5
; RV32IA-NEXT:  .LBB214_4: # in Loop: Header=BB214_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB214_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB214_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB214_1
; RV32IA-NEXT:  .LBB214_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_max_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB214_2
; RV64I-NEXT:  .LBB214_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB214_4
; RV64I-NEXT:  .LBB214_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    blt s1, a3, .LBB214_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB214_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB214_1
; RV64I-NEXT:  .LBB214_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_max_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomax.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw max ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_min_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB215_2
; RV32I-NEXT:  .LBB215_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB215_7
; RV32I-NEXT:  .LBB215_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB215_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB215_5
; RV32I-NEXT:  .LBB215_4: # in Loop: Header=BB215_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB215_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB215_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB215_1
; RV32I-NEXT:  .LBB215_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB215_2
; RV32IA-NEXT:  .LBB215_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB215_7
; RV32IA-NEXT:  .LBB215_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB215_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB215_5
; RV32IA-NEXT:  .LBB215_4: # in Loop: Header=BB215_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB215_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB215_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB215_1
; RV32IA-NEXT:  .LBB215_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB215_2
; RV64I-NEXT:  .LBB215_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB215_4
; RV64I-NEXT:  .LBB215_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s1, a3, .LBB215_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB215_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB215_1
; RV64I-NEXT:  .LBB215_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_min_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB216_2
; RV32I-NEXT:  .LBB216_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB216_7
; RV32I-NEXT:  .LBB216_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB216_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB216_5
; RV32I-NEXT:  .LBB216_4: # in Loop: Header=BB216_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB216_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB216_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB216_1
; RV32I-NEXT:  .LBB216_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB216_2
; RV32IA-NEXT:  .LBB216_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 2
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB216_7
; RV32IA-NEXT:  .LBB216_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB216_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB216_5
; RV32IA-NEXT:  .LBB216_4: # in Loop: Header=BB216_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB216_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB216_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB216_1
; RV32IA-NEXT:  .LBB216_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB216_2
; RV64I-NEXT:  .LBB216_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB216_4
; RV64I-NEXT:  .LBB216_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s1, a3, .LBB216_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB216_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB216_1
; RV64I-NEXT:  .LBB216_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_min_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB217_2
; RV32I-NEXT:  .LBB217_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB217_7
; RV32I-NEXT:  .LBB217_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB217_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB217_5
; RV32I-NEXT:  .LBB217_4: # in Loop: Header=BB217_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB217_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB217_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB217_1
; RV32I-NEXT:  .LBB217_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB217_2
; RV32IA-NEXT:  .LBB217_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 3
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB217_7
; RV32IA-NEXT:  .LBB217_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB217_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB217_5
; RV32IA-NEXT:  .LBB217_4: # in Loop: Header=BB217_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB217_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB217_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB217_1
; RV32IA-NEXT:  .LBB217_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB217_2
; RV64I-NEXT:  .LBB217_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB217_4
; RV64I-NEXT:  .LBB217_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s1, a3, .LBB217_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB217_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB217_1
; RV64I-NEXT:  .LBB217_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_min_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB218_2
; RV32I-NEXT:  .LBB218_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 4
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB218_7
; RV32I-NEXT:  .LBB218_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB218_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB218_5
; RV32I-NEXT:  .LBB218_4: # in Loop: Header=BB218_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB218_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB218_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB218_1
; RV32I-NEXT:  .LBB218_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB218_2
; RV32IA-NEXT:  .LBB218_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 4
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB218_7
; RV32IA-NEXT:  .LBB218_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB218_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB218_5
; RV32IA-NEXT:  .LBB218_4: # in Loop: Header=BB218_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB218_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB218_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB218_1
; RV32IA-NEXT:  .LBB218_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB218_2
; RV64I-NEXT:  .LBB218_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB218_4
; RV64I-NEXT:  .LBB218_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s1, a3, .LBB218_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB218_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB218_1
; RV64I-NEXT:  .LBB218_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_min_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_min_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB219_2
; RV32I-NEXT:  .LBB219_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    li a5, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB219_7
; RV32I-NEXT:  .LBB219_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB219_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32I-NEXT:    slt a0, s1, a5
; RV32I-NEXT:    j .LBB219_5
; RV32I-NEXT:  .LBB219_4: # in Loop: Header=BB219_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB219_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB219_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB219_1
; RV32I-NEXT:  .LBB219_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_min_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB219_2
; RV32IA-NEXT:  .LBB219_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 5
; RV32IA-NEXT:    li a5, 5
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB219_7
; RV32IA-NEXT:  .LBB219_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB219_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32IA-NEXT:    slt a0, s1, a5
; RV32IA-NEXT:    j .LBB219_5
; RV32IA-NEXT:  .LBB219_4: # in Loop: Header=BB219_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB219_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB219_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB219_1
; RV32IA-NEXT:  .LBB219_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_min_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB219_2
; RV64I-NEXT:  .LBB219_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB219_4
; RV64I-NEXT:  .LBB219_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bge s1, a3, .LBB219_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB219_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB219_1
; RV64I-NEXT:  .LBB219_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_min_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomin.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw min ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_umax_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB220_2
; RV32I-NEXT:  .LBB220_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB220_7
; RV32I-NEXT:  .LBB220_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB220_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB220_5
; RV32I-NEXT:  .LBB220_4: # in Loop: Header=BB220_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB220_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB220_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB220_1
; RV32I-NEXT:  .LBB220_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB220_2
; RV32IA-NEXT:  .LBB220_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB220_7
; RV32IA-NEXT:  .LBB220_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB220_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB220_5
; RV32IA-NEXT:  .LBB220_4: # in Loop: Header=BB220_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB220_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB220_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB220_1
; RV32IA-NEXT:  .LBB220_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB220_2
; RV64I-NEXT:  .LBB220_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB220_4
; RV64I-NEXT:  .LBB220_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s1, a3, .LBB220_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB220_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB220_1
; RV64I-NEXT:  .LBB220_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_umax_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB221_2
; RV32I-NEXT:  .LBB221_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB221_7
; RV32I-NEXT:  .LBB221_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB221_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB221_5
; RV32I-NEXT:  .LBB221_4: # in Loop: Header=BB221_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB221_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB221_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB221_1
; RV32I-NEXT:  .LBB221_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB221_2
; RV32IA-NEXT:  .LBB221_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 2
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB221_7
; RV32IA-NEXT:  .LBB221_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB221_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB221_5
; RV32IA-NEXT:  .LBB221_4: # in Loop: Header=BB221_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB221_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB221_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB221_1
; RV32IA-NEXT:  .LBB221_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB221_2
; RV64I-NEXT:  .LBB221_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB221_4
; RV64I-NEXT:  .LBB221_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s1, a3, .LBB221_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB221_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB221_1
; RV64I-NEXT:  .LBB221_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_umax_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB222_2
; RV32I-NEXT:  .LBB222_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB222_7
; RV32I-NEXT:  .LBB222_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB222_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB222_5
; RV32I-NEXT:  .LBB222_4: # in Loop: Header=BB222_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB222_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB222_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB222_1
; RV32I-NEXT:  .LBB222_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB222_2
; RV32IA-NEXT:  .LBB222_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 3
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB222_7
; RV32IA-NEXT:  .LBB222_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB222_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB222_5
; RV32IA-NEXT:  .LBB222_4: # in Loop: Header=BB222_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB222_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB222_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB222_1
; RV32IA-NEXT:  .LBB222_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB222_2
; RV64I-NEXT:  .LBB222_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB222_4
; RV64I-NEXT:  .LBB222_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s1, a3, .LBB222_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB222_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB222_1
; RV64I-NEXT:  .LBB222_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_umax_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB223_2
; RV32I-NEXT:  .LBB223_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 4
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB223_7
; RV32I-NEXT:  .LBB223_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB223_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB223_5
; RV32I-NEXT:  .LBB223_4: # in Loop: Header=BB223_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB223_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB223_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB223_1
; RV32I-NEXT:  .LBB223_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB223_2
; RV32IA-NEXT:  .LBB223_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 4
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB223_7
; RV32IA-NEXT:  .LBB223_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB223_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB223_5
; RV32IA-NEXT:  .LBB223_4: # in Loop: Header=BB223_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB223_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB223_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB223_1
; RV32IA-NEXT:  .LBB223_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB223_2
; RV64I-NEXT:  .LBB223_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB223_4
; RV64I-NEXT:  .LBB223_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s1, a3, .LBB223_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB223_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB223_1
; RV64I-NEXT:  .LBB223_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_umax_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umax_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB224_2
; RV32I-NEXT:  .LBB224_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    li a5, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB224_7
; RV32I-NEXT:  .LBB224_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB224_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB224_5
; RV32I-NEXT:  .LBB224_4: # in Loop: Header=BB224_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB224_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    bnez a0, .LBB224_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB224_1
; RV32I-NEXT:  .LBB224_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umax_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB224_2
; RV32IA-NEXT:  .LBB224_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 5
; RV32IA-NEXT:    li a5, 5
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB224_7
; RV32IA-NEXT:  .LBB224_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB224_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB224_5
; RV32IA-NEXT:  .LBB224_4: # in Loop: Header=BB224_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB224_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    bnez a0, .LBB224_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB224_1
; RV32IA-NEXT:  .LBB224_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umax_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB224_2
; RV64I-NEXT:  .LBB224_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB224_4
; RV64I-NEXT:  .LBB224_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bltu s1, a3, .LBB224_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB224_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB224_1
; RV64I-NEXT:  .LBB224_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umax_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amomaxu.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umax ptr %a, i64 %b seq_cst
  ret i64 %1
}

define i64 @atomicrmw_umin_i64_monotonic(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i64_monotonic:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB225_2
; RV32I-NEXT:  .LBB225_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a4, 0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB225_7
; RV32I-NEXT:  .LBB225_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB225_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB225_5
; RV32I-NEXT:  .LBB225_4: # in Loop: Header=BB225_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB225_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB225_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB225_1
; RV32I-NEXT:  .LBB225_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i64_monotonic:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB225_2
; RV32IA-NEXT:  .LBB225_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a4, 0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB225_7
; RV32IA-NEXT:  .LBB225_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB225_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB225_5
; RV32IA-NEXT:  .LBB225_4: # in Loop: Header=BB225_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB225_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB225_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB225_1
; RV32IA-NEXT:  .LBB225_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i64_monotonic:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB225_2
; RV64I-NEXT:  .LBB225_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a3, 0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB225_4
; RV64I-NEXT:  .LBB225_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s1, a3, .LBB225_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB225_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB225_1
; RV64I-NEXT:  .LBB225_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i64_monotonic:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.d a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i64 %b monotonic
  ret i64 %1
}

define i64 @atomicrmw_umin_i64_acquire(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i64_acquire:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB226_2
; RV32I-NEXT:  .LBB226_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 2
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB226_7
; RV32I-NEXT:  .LBB226_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB226_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB226_5
; RV32I-NEXT:  .LBB226_4: # in Loop: Header=BB226_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB226_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB226_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB226_1
; RV32I-NEXT:  .LBB226_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i64_acquire:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB226_2
; RV32IA-NEXT:  .LBB226_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 2
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB226_7
; RV32IA-NEXT:  .LBB226_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB226_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB226_5
; RV32IA-NEXT:  .LBB226_4: # in Loop: Header=BB226_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB226_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB226_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB226_1
; RV32IA-NEXT:  .LBB226_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i64_acquire:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB226_2
; RV64I-NEXT:  .LBB226_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 2
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB226_4
; RV64I-NEXT:  .LBB226_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s1, a3, .LBB226_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB226_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB226_1
; RV64I-NEXT:  .LBB226_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i64_acquire:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.d.aq a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i64 %b acquire
  ret i64 %1
}

define i64 @atomicrmw_umin_i64_release(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i64_release:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB227_2
; RV32I-NEXT:  .LBB227_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 3
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    li a5, 0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB227_7
; RV32I-NEXT:  .LBB227_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB227_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB227_5
; RV32I-NEXT:  .LBB227_4: # in Loop: Header=BB227_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB227_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB227_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB227_1
; RV32I-NEXT:  .LBB227_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i64_release:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB227_2
; RV32IA-NEXT:  .LBB227_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 3
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    li a5, 0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB227_7
; RV32IA-NEXT:  .LBB227_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB227_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB227_5
; RV32IA-NEXT:  .LBB227_4: # in Loop: Header=BB227_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB227_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB227_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB227_1
; RV32IA-NEXT:  .LBB227_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i64_release:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB227_2
; RV64I-NEXT:  .LBB227_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 3
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    li a4, 0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB227_4
; RV64I-NEXT:  .LBB227_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s1, a3, .LBB227_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB227_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB227_1
; RV64I-NEXT:  .LBB227_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i64_release:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.d.rl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i64 %b release
  ret i64 %1
}

define i64 @atomicrmw_umin_i64_acq_rel(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i64_acq_rel:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB228_2
; RV32I-NEXT:  .LBB228_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 4
; RV32I-NEXT:    li a5, 2
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB228_7
; RV32I-NEXT:  .LBB228_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB228_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB228_5
; RV32I-NEXT:  .LBB228_4: # in Loop: Header=BB228_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB228_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB228_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB228_1
; RV32I-NEXT:  .LBB228_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i64_acq_rel:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB228_2
; RV32IA-NEXT:  .LBB228_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 4
; RV32IA-NEXT:    li a5, 2
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB228_7
; RV32IA-NEXT:  .LBB228_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB228_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB228_5
; RV32IA-NEXT:  .LBB228_4: # in Loop: Header=BB228_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB228_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB228_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB228_1
; RV32IA-NEXT:  .LBB228_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i64_acq_rel:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB228_2
; RV64I-NEXT:  .LBB228_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 4
; RV64I-NEXT:    li a4, 2
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB228_4
; RV64I-NEXT:  .LBB228_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s1, a3, .LBB228_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB228_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB228_1
; RV64I-NEXT:  .LBB228_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i64_acq_rel:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i64 %b acq_rel
  ret i64 %1
}

define i64 @atomicrmw_umin_i64_seq_cst(ptr %a, i64 %b) nounwind {
; RV32I-LABEL: atomicrmw_umin_i64_seq_cst:
; RV32I:       # %bb.0:
; RV32I-NEXT:    addi sp, sp, -32
; RV32I-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32I-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    lw a5, 4(a0)
; RV32I-NEXT:    lw a4, 0(a0)
; RV32I-NEXT:    mv s1, a2
; RV32I-NEXT:    mv s2, a1
; RV32I-NEXT:    j .LBB229_2
; RV32I-NEXT:  .LBB229_1: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32I-NEXT:    sw a4, 8(sp)
; RV32I-NEXT:    sw a5, 12(sp)
; RV32I-NEXT:    addi a1, sp, 8
; RV32I-NEXT:    li a4, 5
; RV32I-NEXT:    li a5, 5
; RV32I-NEXT:    mv a0, s0
; RV32I-NEXT:    call __atomic_compare_exchange_8@plt
; RV32I-NEXT:    lw a5, 12(sp)
; RV32I-NEXT:    lw a4, 8(sp)
; RV32I-NEXT:    bnez a0, .LBB229_7
; RV32I-NEXT:  .LBB229_2: # %atomicrmw.start
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    beq a5, s1, .LBB229_4
; RV32I-NEXT:  # %bb.3: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32I-NEXT:    sltu a0, s1, a5
; RV32I-NEXT:    j .LBB229_5
; RV32I-NEXT:  .LBB229_4: # in Loop: Header=BB229_2 Depth=1
; RV32I-NEXT:    sltu a0, s2, a4
; RV32I-NEXT:  .LBB229_5: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:    mv a3, a5
; RV32I-NEXT:    beqz a0, .LBB229_1
; RV32I-NEXT:  # %bb.6: # %atomicrmw.start
; RV32I-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32I-NEXT:    mv a2, s2
; RV32I-NEXT:    mv a3, s1
; RV32I-NEXT:    j .LBB229_1
; RV32I-NEXT:  .LBB229_7: # %atomicrmw.end
; RV32I-NEXT:    mv a0, a4
; RV32I-NEXT:    mv a1, a5
; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32I-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32I-NEXT:    addi sp, sp, 32
; RV32I-NEXT:    ret
;
; RV32IA-LABEL: atomicrmw_umin_i64_seq_cst:
; RV32IA:       # %bb.0:
; RV32IA-NEXT:    addi sp, sp, -32
; RV32IA-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s1, 20(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    sw s2, 16(sp) # 4-byte Folded Spill
; RV32IA-NEXT:    mv s0, a0
; RV32IA-NEXT:    lw a5, 4(a0)
; RV32IA-NEXT:    lw a4, 0(a0)
; RV32IA-NEXT:    mv s1, a2
; RV32IA-NEXT:    mv s2, a1
; RV32IA-NEXT:    j .LBB229_2
; RV32IA-NEXT:  .LBB229_1: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32IA-NEXT:    sw a4, 8(sp)
; RV32IA-NEXT:    sw a5, 12(sp)
; RV32IA-NEXT:    addi a1, sp, 8
; RV32IA-NEXT:    li a4, 5
; RV32IA-NEXT:    li a5, 5
; RV32IA-NEXT:    mv a0, s0
; RV32IA-NEXT:    call __atomic_compare_exchange_8@plt
; RV32IA-NEXT:    lw a5, 12(sp)
; RV32IA-NEXT:    lw a4, 8(sp)
; RV32IA-NEXT:    bnez a0, .LBB229_7
; RV32IA-NEXT:  .LBB229_2: # %atomicrmw.start
; RV32IA-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IA-NEXT:    beq a5, s1, .LBB229_4
; RV32IA-NEXT:  # %bb.3: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32IA-NEXT:    sltu a0, s1, a5
; RV32IA-NEXT:    j .LBB229_5
; RV32IA-NEXT:  .LBB229_4: # in Loop: Header=BB229_2 Depth=1
; RV32IA-NEXT:    sltu a0, s2, a4
; RV32IA-NEXT:  .LBB229_5: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32IA-NEXT:    mv a2, a4
; RV32IA-NEXT:    mv a3, a5
; RV32IA-NEXT:    beqz a0, .LBB229_1
; RV32IA-NEXT:  # %bb.6: # %atomicrmw.start
; RV32IA-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV32IA-NEXT:    mv a2, s2
; RV32IA-NEXT:    mv a3, s1
; RV32IA-NEXT:    j .LBB229_1
; RV32IA-NEXT:  .LBB229_7: # %atomicrmw.end
; RV32IA-NEXT:    mv a0, a4
; RV32IA-NEXT:    mv a1, a5
; RV32IA-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    lw s2, 16(sp) # 4-byte Folded Reload
; RV32IA-NEXT:    addi sp, sp, 32
; RV32IA-NEXT:    ret
;
; RV64I-LABEL: atomicrmw_umin_i64_seq_cst:
; RV64I:       # %bb.0:
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    ld a3, 0(a0)
; RV64I-NEXT:    mv s1, a1
; RV64I-NEXT:    j .LBB229_2
; RV64I-NEXT:  .LBB229_1: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV64I-NEXT:    sd a3, 0(sp)
; RV64I-NEXT:    mv a1, sp
; RV64I-NEXT:    li a3, 5
; RV64I-NEXT:    li a4, 5
; RV64I-NEXT:    mv a0, s0
; RV64I-NEXT:    call __atomic_compare_exchange_8@plt
; RV64I-NEXT:    ld a3, 0(sp)
; RV64I-NEXT:    bnez a0, .LBB229_4
; RV64I-NEXT:  .LBB229_2: # %atomicrmw.start
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    mv a2, a3
; RV64I-NEXT:    bgeu s1, a3, .LBB229_1
; RV64I-NEXT:  # %bb.3: # %atomicrmw.start
; RV64I-NEXT:    # in Loop: Header=BB229_2 Depth=1
; RV64I-NEXT:    mv a2, s1
; RV64I-NEXT:    j .LBB229_1
; RV64I-NEXT:  .LBB229_4: # %atomicrmw.end
; RV64I-NEXT:    mv a0, a3
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    ret
;
; RV64IA-LABEL: atomicrmw_umin_i64_seq_cst:
; RV64IA:       # %bb.0:
; RV64IA-NEXT:    amominu.d.aqrl a0, a1, (a0)
; RV64IA-NEXT:    ret
  %1 = atomicrmw umin ptr %a, i64 %b seq_cst
  ret i64 %1
}
