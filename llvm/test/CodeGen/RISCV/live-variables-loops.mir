# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=riscv64 -riscv-enable-live-variables -verify-machineinstrs -o - %s | FileCheck %s
#
# Test live variable analysis with loops and backward edges
# Loops create interesting liveness patterns with phi nodes and variables
# that are live across backedges

--- |
  define i64 @test_simple_loop(i64 %n) {
  entry:
    br label %loop

  loop:
    %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
    %sum = phi i64 [ 0, %entry ], [ %sum.next, %loop ]
    %sum.next = add i64 %sum, %i
    %i.next = add i64 %i, 1
    %cmp = icmp slt i64 %i.next, %n
    br i1 %cmp, label %loop, label %exit

  exit:
    ret i64 %sum.next
  }

  define i64 @test_nested_loop(i64 %n, i64 %m) {
  entry:
    br label %outer.loop

  outer.loop:
    %i = phi i64 [ 0, %entry ], [ %i.next, %outer.latch ]
    %outer.sum = phi i64 [ 0, %entry ], [ %new.outer.sum, %outer.latch ]
    br label %inner.loop

  inner.loop:
    %j = phi i64 [ 0, %outer.loop ], [ %j.next, %inner.loop ]
    %inner.sum = phi i64 [ 0, %outer.loop ], [ %inner.sum.next, %inner.loop ]
    %prod = mul i64 %i, %j
    %inner.sum.next = add i64 %inner.sum, %prod
    %j.next = add i64 %j, 1
    %inner.cmp = icmp slt i64 %j.next, %m
    br i1 %inner.cmp, label %inner.loop, label %outer.latch

  outer.latch:
    %new.outer.sum = add i64 %outer.sum, %inner.sum.next
    %i.next = add i64 %i, 1
    %outer.cmp = icmp slt i64 %i.next, %n
    br i1 %outer.cmp, label %outer.loop, label %exit

  exit:
    ret i64 %new.outer.sum
  }

  define i64 @test_loop_with_invariant(i64 %n, i64 %k) {
  entry:
    %double_k = mul i64 %k, 2
    br label %loop

  loop:
    %i = phi i64 [ 0, %entry ], [ %i.next, %loop ]
    %sum = phi i64 [ 0, %entry ], [ %sum.next, %loop ]
    ; double_k is loop-invariant and should be live throughout the loop
    %scaled = mul i64 %i, %double_k
    %sum.next = add i64 %sum, %scaled
    %i.next = add i64 %i, 1
    %cmp = icmp slt i64 %i.next, %n
    br i1 %cmp, label %loop, label %exit

  exit:
    ret i64 %sum.next
  }
...
---
name:            test_simple_loop
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
body:             |
  bb.0.entry:
    liveins: $x10
    ; CHECK-LABEL: name: test_simple_loop
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: successors
    ; CHECK-NEXT: liveins: $x10

    %0:gpr = COPY $x10
    %1:gpr = ADDI $x0, 0
    %2:gpr = ADDI $x0, 0
    PseudoBR %bb.1

  bb.1.loop:
    ; CHECK: bb.1.loop:
    ; %0 should be live-in (used in comparison)
    ; %1 and %2 should be live-in from backedge or entry

    %3:gpr = PHI %1, %bb.0, %5, %bb.1
    %4:gpr = PHI %2, %bb.0, %6, %bb.1
    %6:gpr = ADD %4, %3
    %5:gpr = ADDI %3, 1
    %7:gpr = SLT %5, %0
    BNE %7, $x0, %bb.1

  bb.2.exit:
    ; CHECK: bb.2.exit:
    ; %6 should be live-in

    $x10 = COPY %6
    PseudoRET implicit $x10
...
---
name:            test_nested_loop
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
  - { id: 9, class: gpr }
  - { id: 10, class: gpr }
  - { id: 11, class: gpr }
  - { id: 12, class: gpr }
  - { id: 13, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_nested_loop
    ; CHECK: bb.0.entry:

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    %2:gpr = ADDI $x0, 0
    %3:gpr = ADDI $x0, 0
    PseudoBR %bb.1

  bb.1.outer.loop:
    ; CHECK: bb.1.outer.loop:
    ; %0 and %1 should be live-in (loop bounds)

    %4:gpr = PHI %2, %bb.0, %12, %bb.3
    %5:gpr = PHI %3, %bb.0, %11, %bb.3
    %6:gpr = ADDI $x0, 0
    %7:gpr = ADDI $x0, 0
    PseudoBR %bb.2

  bb.2.inner.loop:
    ; CHECK: bb.2.inner.loop:
    ; %1, %4, %5 should be live-in

    %8:gpr = PHI %6, %bb.1, %13, %bb.2
    %9:gpr = PHI %7, %bb.1, %10, %bb.2
    %10:gpr = MUL %4, %8
    %10:gpr = ADD %9, %10
    %13:gpr = ADDI %8, 1
    %14:gpr = SLT %13, %1
    BNE %14, $x0, %bb.2

  bb.3.outer.latch:
    ; CHECK: bb.3.outer.latch:
    ; %0, %5, %10 should be live-in

    %11:gpr = ADD %5, %10
    %12:gpr = ADDI %4, 1
    %15:gpr = SLT %12, %0
    BNE %15, $x0, %bb.1

  bb.4.exit:
    ; CHECK: bb.4.exit:

    $x10 = COPY %11
    PseudoRET implicit $x10
...
---
name:            test_loop_with_invariant
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_loop_with_invariant
    ; CHECK: bb.0.entry:

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    %2:gpr = SLLI %1, 1
    %3:gpr = ADDI $x0, 0
    %4:gpr = ADDI $x0, 0
    PseudoBR %bb.1

  bb.1.loop:
    ; CHECK: bb.1.loop:
    ; %0 and %2 should be live-in (loop bound and invariant)
    ; %2 is computed before loop but used in every iteration

    %5:gpr = PHI %3, %bb.0, %7, %bb.1
    %6:gpr = PHI %4, %bb.0, %8, %bb.1
    %9:gpr = MUL %5, %2
    %8:gpr = ADD %6, %9
    %7:gpr = ADDI %5, 1
    %10:gpr = SLT %7, %0
    BNE %10, $x0, %bb.1

  bb.2.exit:
    ; CHECK: bb.2.exit:

    $x10 = COPY %8
    PseudoRET implicit $x10
...
