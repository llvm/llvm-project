# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=riscv64 -mattr=+D -run-pass=prologepilog -x=mir < %s 2>&1 | FileCheck %s

# ===== Spill $x10 to stack =====
#   Its offset is too large to use imm, so we have to use a register ($x11),
#   which brings infinite spillings...
#   Our solution is utilizing float registers if possible.
# ===============================
# CHECK: $f15_d = FMV_D_X $x11
# CHECK-NEXT: $x11 = LUI 1
# CHECK-NEXT: $x11 = ADD $x2, killed $x11
# CHECK-NEXT: SD killed $x10, killed $x11, [[OFFSET:[0-9]+]]
# CHECK-NEXT: $x11 = FMV_X_D killed $f15_d

# ===== The original instr, which stores a register and uses $x10 to calculate its offset =====
# CHECK-NEXT: $x10 = LUI 1
# CHECK-NEXT: $x10 = ADD $x2, killed $x10
# CHECK-NEXT: SD undef renamable $x23, killed $x10

# ===== Restore $x10, similar as above =====
# CHECK-NEXT: $f15_d = FMV_D_X $x11
# CHECK-NEXT: $x10 = LUI 1
# CHECK-NEXT: $x11 = ADD $x2, killed $x10
# CHECK-NEXT: $x10 = LD killed $x11, [[OFFSET]]
# CHECK-NEXT: $x11 = FMV_X_D killed $f15_d

--- |
  ; ModuleID = 'a.mir'
  source_filename = "a.mir"
  target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
  
  define void @test() {
  entry:
    unreachable
  }
...
---
name:            test
alignment:       4
tracksRegLiveness: true
noPhis:          true
isSSA:           true
noVRegs:         true
frameInfo:
  maxAlignment:    8
  adjustsStack:    true
  hasCalls:        true
stack:
  - { id: 0, name: '', type: spill-slot, offset: 0, size: 104, alignment: 8, 
      stack-id: default, callee-saved-register: '', callee-saved-restored: true, 
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
body:             |
  bb.0:
    successors: %bb.1(0x40000000), %bb.5(0x40000000)
    liveins: $x10, $x11, $x12
  
    BEQ undef renamable $x10, $x0, %bb.5
    PseudoBR %bb.1
  
  bb.1:
    successors: %bb.2(0x80000000)
    liveins: $x10, $x11, $x12
  
  bb.2:
    successors: %bb.3(0x80000000)
    liveins: $x11, $x30
  
  bb.3:
    successors: %bb.4(0x04000000), %bb.3(0x7c000000)
    liveins: $x6, $x8, $x9, $x10, $x11, $x17, $x18, $x19, $x20, $x21, $x22, $x23, $x24, $x28, $x31, $x30
  
    SD undef renamable $x23, %stack.0, 0
    BEQ undef renamable $x30, $x0, %bb.3
    PseudoBR %bb.4
  
  bb.4:
    successors: %bb.2(0x80000000)
    liveins: $x1, $x5, $x7, $x11, $x12, $x13, $x14, $x15, $x16, $x25, $x26, $x27, $x29, $x30
  
    PseudoBR %bb.2
  
  bb.5:
    liveins: $x10
  
    ADJCALLSTACKDOWN 4808, 0, implicit-def dead $x2, implicit $x2
    ADJCALLSTACKUP 4808, 0, implicit-def dead $x2, implicit $x2
    PseudoRET
...
