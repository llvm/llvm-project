; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -S -passes=loop-unroll -mtriple=riscv64 -mcpu=nextsilicon-gen2-ecore | FileCheck %s

@a = internal unnamed_addr global [3 x [3 x float]] zeroinitializer, align 4

; Function Attrs: nofree nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none) uwtable
define dso_local signext i32 @minver(i32 noundef signext %row, i32 noundef signext %col, float noundef %eps) {
; CHECK-LABEL: @minver(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[WORK:%.*]] = alloca [500 x i32], align 4
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 2000, ptr nonnull [[WORK]])
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[ROW:%.*]], -2
; CHECK-NEXT:    [[OR_COND:%.*]] = icmp ult i32 [[TMP0]], 499
; CHECK-NEXT:    [[CMP3:%.*]] = fcmp ugt float [[EPS:%.*]], 0.000000e+00
; CHECK-NEXT:    [[OR_COND74:%.*]] = and i1 [[OR_COND]], [[CMP3]]
; CHECK-NEXT:    br i1 [[OR_COND74]], label [[WHILE_COND_PREHEADER_US_PREHEADER:%.*]], label [[CLEANUP:%.*]]
; CHECK:       while.cond.preheader.us.preheader:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[ROW]] to i64
; CHECK-NEXT:    [[TMP1:%.*]] = add i32 [[ROW]], -1
; CHECK-NEXT:    br label [[WHILE_COND_PREHEADER_US:%.*]]
; CHECK:       while.cond.preheader.us:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[WHILE_COND_PREHEADER_US_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC39_US:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX_US:%.*]] = getelementptr inbounds [500 x i32], ptr [[WORK]], i64 0, i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX_US]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = zext i32 [[TMP2]] to i64
; CHECK-NEXT:    [[CMP777_US:%.*]] = icmp eq i64 [[INDVARS_IV]], [[TMP3]]
; CHECK-NEXT:    br i1 [[CMP777_US]], label [[FOR_INC39_US]], label [[IF_END10_US_US_PREHEADER:%.*]]
; CHECK:       if.end10.us.us.preheader:
; CHECK-NEXT:    br label [[IF_END10_US_US:%.*]]
; CHECK:       for.inc39.us.loopexit:
; CHECK-NEXT:    br label [[FOR_INC39_US]]
; CHECK:       for.inc39.us:
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND81_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-NEXT:    br i1 [[EXITCOND81_NOT]], label [[CLEANUP_LOOPEXIT:%.*]], label [[WHILE_COND_PREHEADER_US]]
; CHECK:       if.end10.us.us:
; CHECK-NEXT:    [[TMP4:%.*]] = phi i32 [ [[TMP5:%.*]], [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US:%.*]] ], [ [[TMP2]], [[IF_END10_US_US_PREHEADER]] ]
; CHECK-NEXT:    [[IDXPROM11_US_US:%.*]] = sext i32 [[TMP4]] to i64
; CHECK-NEXT:    [[ARRAYIDX12_US_US:%.*]] = getelementptr inbounds [500 x i32], ptr [[WORK]], i64 0, i64 [[IDXPROM11_US_US]]
; CHECK-NEXT:    [[TMP5]] = load i32, ptr [[ARRAYIDX12_US_US]], align 4
; CHECK-NEXT:    store i32 [[TMP4]], ptr [[ARRAYIDX12_US_US]], align 4
; CHECK-NEXT:    store i32 [[TMP5]], ptr [[ARRAYIDX_US]], align 4
; CHECK-NEXT:    [[ARRAYIDX26_US_US:%.*]] = getelementptr inbounds [3 x [3 x float]], ptr @a, i64 0, i64 [[IDXPROM11_US_US]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[ARRAYIDX30_US_US:%.*]] = getelementptr inbounds [3 x [3 x float]], ptr @a, i64 0, i64 [[IDXPROM11_US_US]], i64 [[IDXPROM11_US_US]]
; CHECK-NEXT:    [[DOTPRE:%.*]] = load float, ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    [[XTRAITER:%.*]] = and i32 [[ROW]], 3
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 [[TMP1]], 3
; CHECK-NEXT:    br i1 [[TMP6]], label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US_UNR_LCSSA:%.*]], label [[IF_END10_US_US_NEW:%.*]]
; CHECK:       if.end10.us.us.new:
; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = sub i32 [[ROW]], [[XTRAITER]]
; CHECK-NEXT:    br label [[FOR_BODY22_US_US:%.*]]
; CHECK:       for.body22.us.us:
; CHECK-NEXT:    [[TMP7:%.*]] = phi float [ [[DOTPRE]], [[IF_END10_US_US_NEW]] ], [ [[TMP11:%.*]], [[FOR_BODY22_US_US]] ]
; CHECK-NEXT:    [[J_076_US_US:%.*]] = phi i32 [ 0, [[IF_END10_US_US_NEW]] ], [ [[INC_US_US_3:%.*]], [[FOR_BODY22_US_US]] ]
; CHECK-NEXT:    [[NITER:%.*]] = phi i32 [ 0, [[IF_END10_US_US_NEW]] ], [ [[NITER_NEXT_3:%.*]], [[FOR_BODY22_US_US]] ]
; CHECK-NEXT:    [[TMP8:%.*]] = load float, ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP7]], ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP8]], ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP8]], ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP9]], ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP9]], ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP10]], ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    [[TMP11]] = load float, ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP10]], ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP11]], ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    [[INC_US_US_3]] = add nuw nsw i32 [[J_076_US_US]], 4
; CHECK-NEXT:    [[NITER_NEXT_3]] = add i32 [[NITER]], 4
; CHECK-NEXT:    [[NITER_NCMP_3:%.*]] = icmp eq i32 [[NITER_NEXT_3]], [[UNROLL_ITER]]
; CHECK-NEXT:    br i1 [[NITER_NCMP_3]], label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US_UNR_LCSSA_LOOPEXIT:%.*]], label [[FOR_BODY22_US_US]]
; CHECK:       for.cond19.while.cond.loopexit_crit_edge.us.us.unr-lcssa.loopexit:
; CHECK-NEXT:    [[DOTUNR_PH:%.*]] = phi float [ [[TMP11]], [[FOR_BODY22_US_US]] ]
; CHECK-NEXT:    br label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US_UNR_LCSSA]]
; CHECK:       for.cond19.while.cond.loopexit_crit_edge.us.us.unr-lcssa:
; CHECK-NEXT:    [[DOTUNR:%.*]] = phi float [ [[DOTPRE]], [[IF_END10_US_US]] ], [ [[DOTUNR_PH]], [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US_UNR_LCSSA_LOOPEXIT]] ]
; CHECK-NEXT:    [[LCMP_MOD:%.*]] = icmp ne i32 [[XTRAITER]], 0
; CHECK-NEXT:    br i1 [[LCMP_MOD]], label [[FOR_BODY22_US_US_EPIL_PREHEADER:%.*]], label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US]]
; CHECK:       for.body22.us.us.epil.preheader:
; CHECK-NEXT:    br label [[FOR_BODY22_US_US_EPIL:%.*]]
; CHECK:       for.body22.us.us.epil:
; CHECK-NEXT:    [[TMP12:%.*]] = load float, ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[DOTUNR]], ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP12]], ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    [[EPIL_ITER_CMP:%.*]] = icmp ne i32 1, [[XTRAITER]]
; CHECK-NEXT:    br i1 [[EPIL_ITER_CMP]], label [[FOR_BODY22_US_US_EPIL_1:%.*]], label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US_EPILOG_LCSSA:%.*]]
; CHECK:       for.body22.us.us.epil.1:
; CHECK-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP12]], ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP13]], ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    [[EPIL_ITER_CMP_1:%.*]] = icmp ne i32 2, [[XTRAITER]]
; CHECK-NEXT:    br i1 [[EPIL_ITER_CMP_1]], label [[FOR_BODY22_US_US_EPIL_2:%.*]], label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US_EPILOG_LCSSA]]
; CHECK:       for.body22.us.us.epil.2:
; CHECK-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP13]], ptr [[ARRAYIDX26_US_US]], align 4
; CHECK-NEXT:    store float [[TMP14]], ptr [[ARRAYIDX30_US_US]], align 4
; CHECK-NEXT:    br label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US_EPILOG_LCSSA]]
; CHECK:       for.cond19.while.cond.loopexit_crit_edge.us.us.epilog-lcssa:
; CHECK-NEXT:    br label [[FOR_COND19_WHILE_COND_LOOPEXIT_CRIT_EDGE_US_US]]
; CHECK:       for.cond19.while.cond.loopexit_crit_edge.us.us:
; CHECK-NEXT:    [[TMP15:%.*]] = zext i32 [[TMP5]] to i64
; CHECK-NEXT:    [[CMP7_US_US:%.*]] = icmp eq i64 [[INDVARS_IV]], [[TMP15]]
; CHECK-NEXT:    br i1 [[CMP7_US_US]], label [[FOR_INC39_US_LOOPEXIT:%.*]], label [[IF_END10_US_US]]
; CHECK:       cleanup.loopexit:
; CHECK-NEXT:    br label [[CLEANUP]]
; CHECK:       cleanup:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 999, [[ENTRY:%.*]] ], [ 0, [[CLEANUP_LOOPEXIT]] ]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 2000, ptr nonnull [[WORK]])
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %work = alloca [500 x i32], align 4
  call void @llvm.lifetime.start.p0(i64 2000, ptr nonnull %work)
  %0 = add i32 %row, -2
  %or.cond = icmp ult i32 %0, 499
  %cmp3 = fcmp ugt float %eps, 0.000000e+00
  %or.cond74 = and i1 %or.cond, %cmp3
  br i1 %or.cond74, label %while.cond.preheader.us.preheader, label %cleanup

while.cond.preheader.us.preheader:                ; preds = %entry
  %wide.trip.count = zext i32 %row to i64
  br label %while.cond.preheader.us

while.cond.preheader.us:                          ; preds = %while.cond.preheader.us.preheader, %for.inc39.us
  %indvars.iv = phi i64 [ 0, %while.cond.preheader.us.preheader ], [ %indvars.iv.next, %for.inc39.us ]
  %arrayidx.us = getelementptr inbounds [500 x i32], ptr %work, i64 0, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx.us, align 4
  %2 = zext i32 %1 to i64
  %cmp777.us = icmp eq i64 %indvars.iv, %2
  br i1 %cmp777.us, label %for.inc39.us, label %if.end10.us.us

for.inc39.us:                                     ; preds = %for.cond19.while.cond.loopexit_crit_edge.us.us, %while.cond.preheader.us
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond81.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond81.not, label %cleanup, label %while.cond.preheader.us

if.end10.us.us:                                   ; preds = %while.cond.preheader.us, %for.cond19.while.cond.loopexit_crit_edge.us.us
  %3 = phi i32 [ %4, %for.cond19.while.cond.loopexit_crit_edge.us.us ], [ %1, %while.cond.preheader.us ]
  %idxprom11.us.us = sext i32 %3 to i64
  %arrayidx12.us.us = getelementptr inbounds [500 x i32], ptr %work, i64 0, i64 %idxprom11.us.us
  %4 = load i32, ptr %arrayidx12.us.us, align 4
  store i32 %3, ptr %arrayidx12.us.us, align 4
  store i32 %4, ptr %arrayidx.us, align 4
  %arrayidx26.us.us = getelementptr inbounds [3 x [3 x float]], ptr @a, i64 0, i64 %idxprom11.us.us, i64 %indvars.iv
  %arrayidx30.us.us = getelementptr inbounds [3 x [3 x float]], ptr @a, i64 0, i64 %idxprom11.us.us, i64 %idxprom11.us.us
  %.pre = load float, ptr %arrayidx30.us.us, align 4
  br label %for.body22.us.us

for.body22.us.us:                                 ; preds = %for.body22.us.us, %if.end10.us.us
  %5 = phi float [ %.pre, %if.end10.us.us ], [ %6, %for.body22.us.us ]
  %j.076.us.us = phi i32 [ 0, %if.end10.us.us ], [ %inc.us.us, %for.body22.us.us ]
  %6 = load float, ptr %arrayidx26.us.us, align 4
  store float %5, ptr %arrayidx26.us.us, align 4
  store float %6, ptr %arrayidx30.us.us, align 4
  %inc.us.us = add nuw nsw i32 %j.076.us.us, 1
  %exitcond.not = icmp eq i32 %inc.us.us, %row
  br i1 %exitcond.not, label %for.cond19.while.cond.loopexit_crit_edge.us.us, label %for.body22.us.us

for.cond19.while.cond.loopexit_crit_edge.us.us:   ; preds = %for.body22.us.us
  %7 = zext i32 %4 to i64
  %cmp7.us.us = icmp eq i64 %indvars.iv, %7
  br i1 %cmp7.us.us, label %for.inc39.us, label %if.end10.us.us

cleanup:                                          ; preds = %for.inc39.us, %entry
  %retval.0 = phi i32 [ 999, %entry ], [ 0, %for.inc39.us ]
  call void @llvm.lifetime.end.p0(i64 2000, ptr nonnull %work)
  ret i32 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)
