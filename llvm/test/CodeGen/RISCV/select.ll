; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -mattr=+m -verify-machineinstrs < %s | FileCheck --check-prefixes=CHECK,RV32 %s
; RUN: llc -mtriple=riscv64 -mattr=+m -verify-machineinstrs < %s | FileCheck --check-prefixes=CHECK,RV64,NOCONDOPS %s
; RUN: llc -mtriple=riscv64 -mattr=+m,+xventanacondops -verify-machineinstrs < %s | FileCheck --check-prefixes=CHECK,RV64,CONDOPS %s

define i16 @select_xor_1(i16 %A, i8 %cond) {
; RV32-LABEL: select_xor_1:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    andi a1, a1, 1
; RV32-NEXT:    neg a1, a1
; RV32-NEXT:    andi a1, a1, 43
; RV32-NEXT:    xor a0, a1, a0
; RV32-NEXT:    ret
;
; RV64-LABEL: select_xor_1:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    andi a1, a1, 1
; RV64-NEXT:    negw a1, a1
; RV64-NEXT:    andi a1, a1, 43
; RV64-NEXT:    xor a0, a1, a0
; RV64-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp eq i8 %and, 0
 %0 = xor i16 %A, 43
 %1 = select i1 %cmp10, i16 %A, i16 %0
 ret i16 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i16 @select_xor_1b(i16 %A, i8 %cond) {
; RV32-LABEL: select_xor_1b:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    andi a1, a1, 1
; RV32-NEXT:    neg a1, a1
; RV32-NEXT:    andi a1, a1, 43
; RV32-NEXT:    xor a0, a1, a0
; RV32-NEXT:    ret
;
; RV64-LABEL: select_xor_1b:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    andi a1, a1, 1
; RV64-NEXT:    negw a1, a1
; RV64-NEXT:    andi a1, a1, 43
; RV64-NEXT:    xor a0, a1, a0
; RV64-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp ne i8 %and, 1
 %0 = xor i16 %A, 43
 %1 = select i1 %cmp10, i16 %A, i16 %0
 ret i16 %1
}

define i32 @select_xor_2(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_xor_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    neg a2, a2
; CHECK-NEXT:    and a1, a2, a1
; CHECK-NEXT:    xor a0, a1, a0
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp eq i8 %and, 0
 %0 = xor i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i32 @select_xor_2b(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_xor_2b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    neg a2, a2
; CHECK-NEXT:    and a1, a2, a1
; CHECK-NEXT:    xor a0, a1, a0
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp ne i8 %and, 1
 %0 = xor i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

define i32 @select_or(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_or:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    neg a2, a2
; CHECK-NEXT:    and a1, a2, a1
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp eq i8 %and, 0
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i32 @select_or_b(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_or_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    neg a2, a2
; CHECK-NEXT:    and a1, a2, a1
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp ne i8 %and, 1
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

define i32 @select_or_1(i32 %A, i32 %B, i32 %cond) {
; CHECK-LABEL: select_or_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    neg a2, a2
; CHECK-NEXT:    and a1, a2, a1
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:    ret
entry:
 %and = and i32 %cond, 1
 %cmp10 = icmp eq i32 %and, 0
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i32 @select_or_1b(i32 %A, i32 %B, i32 %cond) {
; CHECK-LABEL: select_or_1b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    neg a2, a2
; CHECK-NEXT:    and a1, a2, a1
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:    ret
entry:
 %and = and i32 %cond, 1
 %cmp10 = icmp ne i32 %and, 1
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

define i32 @select_add_1(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_add_1:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    beqz a0, .LBB8_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    add a2, a1, a2
; RV32-NEXT:  .LBB8_2: # %entry
; RV32-NEXT:    mv a0, a2
; RV32-NEXT:    ret
;
; RV64-LABEL: select_add_1:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    beqz a0, .LBB8_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    addw a2, a1, a2
; RV64-NEXT:  .LBB8_2: # %entry
; RV64-NEXT:    mv a0, a2
; RV64-NEXT:    ret
entry:
  %c = add i32 %a, %b
  %res = select i1 %cond, i32 %c, i32 %b
  ret i32 %res
}

define i32 @select_add_2(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_add_2:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB9_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    add a1, a1, a2
; RV32-NEXT:  .LBB9_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_add_2:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB9_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    addw a1, a1, a2
; RV64-NEXT:  .LBB9_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = add i32 %a, %b
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_add_3(i1 zeroext %cond, i32 %a) {
; RV32-LABEL: select_add_3:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB10_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    addi a1, a1, 42
; RV32-NEXT:  .LBB10_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_add_3:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB10_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    addiw a1, a1, 42
; RV64-NEXT:  .LBB10_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = add i32 %a, 42
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_sub_1(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_sub_1:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    beqz a0, .LBB11_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    sub a2, a1, a2
; RV32-NEXT:  .LBB11_2: # %entry
; RV32-NEXT:    mv a0, a2
; RV32-NEXT:    ret
;
; RV64-LABEL: select_sub_1:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    beqz a0, .LBB11_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    subw a2, a1, a2
; RV64-NEXT:  .LBB11_2: # %entry
; RV64-NEXT:    mv a0, a2
; RV64-NEXT:    ret
entry:
  %c = sub i32 %a, %b
  %res = select i1 %cond, i32 %c, i32 %b
  ret i32 %res
}

define i32 @select_sub_2(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_sub_2:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB12_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    sub a1, a1, a2
; RV32-NEXT:  .LBB12_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_sub_2:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB12_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    subw a1, a1, a2
; RV64-NEXT:  .LBB12_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = sub i32 %a, %b
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_sub_3(i1 zeroext %cond, i32 %a) {
; RV32-LABEL: select_sub_3:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB13_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    addi a1, a1, -42
; RV32-NEXT:  .LBB13_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_sub_3:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB13_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    addiw a1, a1, -42
; RV64-NEXT:  .LBB13_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = sub i32 %a, 42
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_and_1(i1 zeroext %cond, i32 %a, i32 %b) {
; CHECK-LABEL: select_and_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    beqz a0, .LBB14_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    and a2, a1, a2
; CHECK-NEXT:  .LBB14_2: # %entry
; CHECK-NEXT:    mv a0, a2
; CHECK-NEXT:    ret
entry:
  %c = and i32 %a, %b
  %res = select i1 %cond, i32 %c, i32 %b
  ret i32 %res
}

define i32 @select_and_2(i1 zeroext %cond, i32 %a, i32 %b) {
; CHECK-LABEL: select_and_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    bnez a0, .LBB15_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    and a1, a1, a2
; CHECK-NEXT:  .LBB15_2: # %entry
; CHECK-NEXT:    mv a0, a1
; CHECK-NEXT:    ret
entry:
  %c = and i32 %a, %b
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_and_3(i1 zeroext %cond, i32 %a) {
; CHECK-LABEL: select_and_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    bnez a0, .LBB16_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    andi a1, a1, 42
; CHECK-NEXT:  .LBB16_2: # %entry
; CHECK-NEXT:    mv a0, a1
; CHECK-NEXT:    ret
entry:
  %c = and i32 %a, 42
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_udiv_1(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_udiv_1:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    beqz a0, .LBB17_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    divu a2, a1, a2
; RV32-NEXT:  .LBB17_2: # %entry
; RV32-NEXT:    mv a0, a2
; RV32-NEXT:    ret
;
; RV64-LABEL: select_udiv_1:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    beqz a0, .LBB17_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    divuw a2, a1, a2
; RV64-NEXT:  .LBB17_2: # %entry
; RV64-NEXT:    mv a0, a2
; RV64-NEXT:    ret
entry:
  %c = udiv i32 %a, %b
  %res = select i1 %cond, i32 %c, i32 %b
  ret i32 %res
}

define i32 @select_udiv_2(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_udiv_2:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB18_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    divu a1, a1, a2
; RV32-NEXT:  .LBB18_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_udiv_2:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB18_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    divuw a1, a1, a2
; RV64-NEXT:  .LBB18_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = udiv i32 %a, %b
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_udiv_3(i1 zeroext %cond, i32 %a) {
; RV32-LABEL: select_udiv_3:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB19_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    srli a0, a1, 1
; RV32-NEXT:    lui a1, 199729
; RV32-NEXT:    addi a1, a1, -975
; RV32-NEXT:    mulhu a0, a0, a1
; RV32-NEXT:    srli a1, a0, 2
; RV32-NEXT:  .LBB19_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_udiv_3:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB19_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    srliw a0, a1, 1
; RV64-NEXT:    lui a1, 199729
; RV64-NEXT:    addiw a1, a1, -975
; RV64-NEXT:    mul a0, a0, a1
; RV64-NEXT:    srli a1, a0, 34
; RV64-NEXT:  .LBB19_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = udiv i32 %a, 42
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_shl_1(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_shl_1:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    beqz a0, .LBB20_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    sll a2, a1, a2
; RV32-NEXT:  .LBB20_2: # %entry
; RV32-NEXT:    mv a0, a2
; RV32-NEXT:    ret
;
; RV64-LABEL: select_shl_1:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    beqz a0, .LBB20_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    sllw a2, a1, a2
; RV64-NEXT:  .LBB20_2: # %entry
; RV64-NEXT:    mv a0, a2
; RV64-NEXT:    ret
entry:
  %c = shl i32 %a, %b
  %res = select i1 %cond, i32 %c, i32 %b
  ret i32 %res
}

define i32 @select_shl_2(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_shl_2:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB21_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    sll a1, a1, a2
; RV32-NEXT:  .LBB21_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_shl_2:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB21_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    sllw a1, a1, a2
; RV64-NEXT:  .LBB21_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = shl i32 %a, %b
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_shl_3(i1 zeroext %cond, i32 %a) {
; CHECK-LABEL: select_shl_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mv a0, a1
; CHECK-NEXT:    ret
entry:
  %c = shl i32 %a, 42
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_ashr_1(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_ashr_1:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    beqz a0, .LBB23_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    sra a2, a1, a2
; RV32-NEXT:  .LBB23_2: # %entry
; RV32-NEXT:    mv a0, a2
; RV32-NEXT:    ret
;
; RV64-LABEL: select_ashr_1:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    beqz a0, .LBB23_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    sraw a2, a1, a2
; RV64-NEXT:  .LBB23_2: # %entry
; RV64-NEXT:    mv a0, a2
; RV64-NEXT:    ret
entry:
  %c = ashr i32 %a, %b
  %res = select i1 %cond, i32 %c, i32 %b
  ret i32 %res
}

define i32 @select_ashr_2(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_ashr_2:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB24_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    sra a1, a1, a2
; RV32-NEXT:  .LBB24_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_ashr_2:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB24_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    sraw a1, a1, a2
; RV64-NEXT:  .LBB24_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = ashr i32 %a, %b
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_ashr_3(i1 zeroext %cond, i32 %a) {
; CHECK-LABEL: select_ashr_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mv a0, a1
; CHECK-NEXT:    ret
entry:
  %c = ashr i32 %a, 42
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_lshr_1(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_lshr_1:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    beqz a0, .LBB26_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    srl a2, a1, a2
; RV32-NEXT:  .LBB26_2: # %entry
; RV32-NEXT:    mv a0, a2
; RV32-NEXT:    ret
;
; RV64-LABEL: select_lshr_1:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    beqz a0, .LBB26_2
; RV64-NEXT:  # %bb.1:
; RV64-NEXT:    srlw a2, a1, a2
; RV64-NEXT:  .LBB26_2: # %entry
; RV64-NEXT:    mv a0, a2
; RV64-NEXT:    ret
entry:
  %c = lshr i32 %a, %b
  %res = select i1 %cond, i32 %c, i32 %b
  ret i32 %res
}

define i32 @select_lshr_2(i1 zeroext %cond, i32 %a, i32 %b) {
; RV32-LABEL: select_lshr_2:
; RV32:       # %bb.0: # %entry
; RV32-NEXT:    bnez a0, .LBB27_2
; RV32-NEXT:  # %bb.1: # %entry
; RV32-NEXT:    srl a1, a1, a2
; RV32-NEXT:  .LBB27_2: # %entry
; RV32-NEXT:    mv a0, a1
; RV32-NEXT:    ret
;
; RV64-LABEL: select_lshr_2:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    bnez a0, .LBB27_2
; RV64-NEXT:  # %bb.1: # %entry
; RV64-NEXT:    srlw a1, a1, a2
; RV64-NEXT:  .LBB27_2: # %entry
; RV64-NEXT:    mv a0, a1
; RV64-NEXT:    ret
entry:
  %c = lshr i32 %a, %b
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}

define i32 @select_lshr_3(i1 zeroext %cond, i32 %a) {
; CHECK-LABEL: select_lshr_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mv a0, a1
; CHECK-NEXT:    ret
entry:
  %c = lshr i32 %a, 42
  %res = select i1 %cond, i32 %a, i32 %c
  ret i32 %res
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CONDOPS: {{.*}}
; NOCONDOPS: {{.*}}
