; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s | FileCheck %s
; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s | FileCheck %s

define i16 @select_xor_1(i16 %A, i8 %cond) {
; CHECK-LABEL: select_xor_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a1, a1, 1
; CHECK-NEXT:    beqz a1, .LBB0_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    xori a0, a0, 43
; CHECK-NEXT:  .LBB0_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp eq i8 %and, 0
 %0 = xor i16 %A, 43
 %1 = select i1 %cmp10, i16 %A, i16 %0
 ret i16 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i16 @select_xor_1b(i16 %A, i8 %cond) {
; CHECK-LABEL: select_xor_1b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a1, a1, 1
; CHECK-NEXT:    beqz a1, .LBB1_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    xori a0, a0, 43
; CHECK-NEXT:  .LBB1_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp ne i8 %and, 1
 %0 = xor i16 %A, 43
 %1 = select i1 %cmp10, i16 %A, i16 %0
 ret i16 %1
}

define i32 @select_xor_2(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_xor_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    beqz a2, .LBB2_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    xor a0, a1, a0
; CHECK-NEXT:  .LBB2_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp eq i8 %and, 0
 %0 = xor i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i32 @select_xor_2b(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_xor_2b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    beqz a2, .LBB3_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    xor a0, a1, a0
; CHECK-NEXT:  .LBB3_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp ne i8 %and, 1
 %0 = xor i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

define i32 @select_or(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_or:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    beqz a2, .LBB4_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:  .LBB4_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp eq i8 %and, 0
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i32 @select_or_b(i32 %A, i32 %B, i8 %cond) {
; CHECK-LABEL: select_or_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    beqz a2, .LBB5_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:  .LBB5_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i8 %cond, 1
 %cmp10 = icmp ne i8 %and, 1
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

define i32 @select_or_1(i32 %A, i32 %B, i32 %cond) {
; CHECK-LABEL: select_or_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    beqz a2, .LBB6_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:  .LBB6_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i32 %cond, 1
 %cmp10 = icmp eq i32 %and, 0
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}

; Equivalent to above, but with icmp ne (and %cond, 1), 1 instead of
; icmp eq (and %cond, 1), 0
define i32 @select_or_1b(i32 %A, i32 %B, i32 %cond) {
; CHECK-LABEL: select_or_1b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi a2, a2, 1
; CHECK-NEXT:    beqz a2, .LBB7_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    or a0, a1, a0
; CHECK-NEXT:  .LBB7_2: # %entry
; CHECK-NEXT:    ret
entry:
 %and = and i32 %cond, 1
 %cmp10 = icmp ne i32 %and, 1
 %0 = or i32 %B, %A
 %1 = select i1 %cmp10, i32 %A, i32 %0
 ret i32 %1
}
