; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+experimental-xqcilo | FileCheck %s --check-prefixes=RV32I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+experimental-xqcilo,+short-forward-branch-ialu | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+experimental-xqcilo,+short-forward-branch-iload | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFBILOAD

define i32 @test_i8_s(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB0_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-NEXT:  .LBB0_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB0_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB0_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB0_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB0_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB1_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-NEXT:  .LBB1_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB1_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB1_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB1_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB1_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB2_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-NEXT:  .LBB2_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB2_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB2_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB2_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB2_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB3_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-NEXT:  .LBB3_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB3_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB3_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB3_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB3_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i32:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB4_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-NEXT:  .LBB4_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB4_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB4_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB4_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB4_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i32 @test_i8_s_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_s_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB5_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB5_2: # %entry
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB5_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB5_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB5_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB5_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_z_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB6_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB6_2: # %entry
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB6_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB6_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB6_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB6_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_s_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB7_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB7_2: # %entry
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB7_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB7_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB7_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB7_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_z_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB8_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB8_2: # %entry
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB8_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB8_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB8_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB8_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i32_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB9_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB9_2: # %entry
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB9_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB9_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_store:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB9_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB9_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i32 @test_i8_s_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB10_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB10_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB10_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB10_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB10_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB10_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_z_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB11_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB11_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB11_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB11_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB11_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB11_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_s_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB12_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB12_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB12_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB12_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB12_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB12_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_z_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB13_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB13_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB13_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB13_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB13_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB13_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i32_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a4, 40000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB14_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB14_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB14_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB14_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_volatile:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB14_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB14_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_s_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_s_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB15_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-NEXT:  .LBB15_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB15_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB15_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB15_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB15_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i8_z_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_z_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB16_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-NEXT:  .LBB16_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB16_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB16_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB16_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB16_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_s_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_s_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB17_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-NEXT:  .LBB17_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB17_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB17_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB17_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB17_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_z_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_z_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB18_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-NEXT:  .LBB18_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB18_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB18_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB18_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB18_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i32_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i32_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB19_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-NEXT:  .LBB19_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB19_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB19_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB19_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB19_2: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %res = select i1 %x, i32 %b, i32 %val
  ret i32 %res
}

define i32 @test_i8_s_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB20_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB20_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB20_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB20_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB20_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB20_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i8_z_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB21_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB21_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB21_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB21_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB21_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB21_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_s_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB22_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB22_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB22_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB22_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB22_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB22_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_z_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB23_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB23_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB23_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB23_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB23_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB23_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i32_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i32_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB24_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB24_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB24_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB24_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_store_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFBILOAD-NEXT:    beqz a1, .LBB24_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    mv a0, a2
; RV32I-SFBILOAD-NEXT:  .LBB24_2: # %entry
; RV32I-SFBILOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %val
  ret i32 %res
}

define i32 @test_i8_s_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB25_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB25_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB25_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB25_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_s_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB25_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB25_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_z_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB26_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB26_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB26_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB26_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i8_z_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB26_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB26_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_s_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB27_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB27_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB27_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB27_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_s_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB27_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB27_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_z_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB28_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB28_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB28_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB28_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i16_z_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB28_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB28_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i32_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a4, 40000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB29_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB29_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB29_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB29_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV32I-SFBILOAD-LABEL: test_i32_volatile_op:
; RV32I-SFBILOAD:       # %bb.0: # %entry
; RV32I-SFBILOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBILOAD-NEXT:    bnez a1, .LBB29_2
; RV32I-SFBILOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBILOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBILOAD-NEXT:  .LBB29_2: # %entry
; RV32I-SFBILOAD-NEXT:    add a0, a2, a3
; RV32I-SFBILOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %val
  %res1 = add i32 %res, %val1
  ret i32 %res1
}
