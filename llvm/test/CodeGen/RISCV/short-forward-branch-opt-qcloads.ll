; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+experimental-xqcilo | FileCheck %s --check-prefixes=RV32I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64  | FileCheck %s --check-prefixes=RV64I
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+experimental-xqcilo,+short-forward-branch-ialu | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+short-forward-branch-ialu | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFB
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv32 -mattr=+experimental-xqcilo,+short-forward-branch-iqcload | \
; RUN:   FileCheck %s --check-prefixes=RV32I-SFBIQCLOAD
; RUN: llc < %s -verify-machineinstrs -mtriple=riscv64 -mattr=+short-forward-branch-iqcload | \
; RUN:   FileCheck %s --check-prefixes=RV64I-SFBIQCLOAD

define i32 @test_i8_s(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB0_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-NEXT:  .LBB0_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB0_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lb a2, 1808(a0)
; RV64I-NEXT:  .LBB0_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB0_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB0_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB0_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB0_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB0_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB0_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB0_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB0_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB1_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-NEXT:  .LBB1_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB1_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lbu a2, 1808(a0)
; RV64I-NEXT:  .LBB1_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB1_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB1_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB1_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB1_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB1_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB1_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB1_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB1_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_s:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB2_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-NEXT:  .LBB2_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB2_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lh a2, -480(a0)
; RV64I-NEXT:  .LBB2_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB2_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB2_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB2_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB2_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB2_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB2_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB2_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB2_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_z:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB3_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-NEXT:  .LBB3_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB3_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lhu a2, -480(a0)
; RV64I-NEXT:  .LBB3_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB3_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB3_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB3_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB3_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB3_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB3_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB3_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB3_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i32:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB4_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-NEXT:  .LBB4_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB4_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 10
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lw a2, -960(a0)
; RV64I-NEXT:  .LBB4_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB4_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB4_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 10
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lw a0, -960(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB4_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB4_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB4_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB4_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lw a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB4_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB4_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i32 @test_i8_s_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_s_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB5_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB5_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lb a0, 1808(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB5_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB5_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB5_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB5_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB5_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB5_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_store:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB5_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB5_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_store:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB5_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB5_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i8_z_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_z_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB6_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB6_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lbu a0, 1808(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB6_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB6_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB6_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB6_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB6_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB6_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_store:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB6_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB6_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_store:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB6_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB6_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_s_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_s_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB7_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB7_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lh a0, -480(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB7_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB7_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB7_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB7_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB7_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB7_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_store:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB7_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB7_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_store:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB7_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB7_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i16_z_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_z_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB8_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB8_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lhu a0, -480(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB8_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB8_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB8_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB8_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB8_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB8_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_store:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB8_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB8_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_store:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB8_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB8_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  ret i32 %res
}

define i32 @test_i32_store(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i32_store:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB9_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB9_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_store:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 10
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lw a0, -960(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB9_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB9_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_store:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB9_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB9_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_store:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 10
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lw a0, -960(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB9_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB9_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_store:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB9_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB9_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_store:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lw a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB9_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB9_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  ret i32 %res
}

define i64 @test_i8_s_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_s_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB10_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB10_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB10_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lb a2, 1808(a0)
; RV64I-NEXT:  .LBB10_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB10_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB10_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB10_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB10_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB10_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB10_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_1:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB10_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB10_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB10_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB10_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_1:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB10_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB10_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i8_z_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB11_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-NEXT:  .LBB11_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB11_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lbu a2, 1808(a0)
; RV64I-NEXT:  .LBB11_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB11_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB11_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB11_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB11_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB11_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB11_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_1:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB11_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB11_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB11_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB11_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_1:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB11_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB11_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_s_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_s_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB12_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB12_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB12_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lh a2, -480(a0)
; RV64I-NEXT:  .LBB12_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB12_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB12_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB12_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB12_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB12_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB12_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_1:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB12_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB12_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB12_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB12_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_1:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB12_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB12_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_z_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB13_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-NEXT:  .LBB13_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB13_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lhu a2, -480(a0)
; RV64I-NEXT:  .LBB13_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB13_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB13_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB13_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB13_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB13_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB13_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_1:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB13_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB13_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB13_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB13_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_1:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB13_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB13_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i32_z_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i32_z_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB14_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-NEXT:  .LBB14_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB14_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 10
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lwu a2, -960(a0)
; RV64I-NEXT:  .LBB14_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB14_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB14_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB14_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB14_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 10
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lwu a0, -960(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB14_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB14_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_z_1:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB14_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB14_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB14_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB14_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_z_1:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lwu a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB14_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB14_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i64_1(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i64_1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    beqz a1, .LBB15_2
; RV32I-NEXT:  # %bb.1:
; RV32I-NEXT:    lui a1, 20
; RV32I-NEXT:    add a1, a1, a0
; RV32I-NEXT:    lw a3, -1916(a1)
; RV32I-NEXT:    qc.e.lw a2, 80000(a0)
; RV32I-NEXT:  .LBB15_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    beqz a1, .LBB15_2
; RV64I-NEXT:  # %bb.1:
; RV64I-NEXT:    lui a1, 20
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    ld a2, -1920(a0)
; RV64I-NEXT:  .LBB15_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lui a4, 20
; RV32I-SFB-NEXT:    add a4, a4, a0
; RV32I-SFB-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-SFB-NEXT:    lw a4, -1916(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB15_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB15_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB15_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a4, a3
; RV32I-SFB-NEXT:  .LBB15_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a4
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 20
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ld a0, -1920(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB15_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB15_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i64_1:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lui a4, 20
; RV32I-SFBIQCLOAD-NEXT:    add a4, a4, a0
; RV32I-SFBIQCLOAD-NEXT:    lw a4, -1916(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB15_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 80000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB15_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB15_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a4, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB15_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a4
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i64_1:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 20
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ld a0, -1920(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB15_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB15_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 10000   ; compute base + 10000
  %val = load i64, ptr %addr          ; load 64-bit value
  %res = select i1 %x, i64 %val, i64 %b
  ret i64 %res
}

define i64 @test_i8_s_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB16_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB16_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lb a0, 1808(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB16_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB16_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB16_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB16_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB16_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB16_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB16_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB16_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_store_64:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB16_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB16_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB16_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB16_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_store_64:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB16_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB16_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i8_z_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB17_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB17_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lbu a0, 1808(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB17_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB17_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB17_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB17_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB17_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB17_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB17_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB17_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_store_64:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB17_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB17_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB17_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB17_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_store_64:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB17_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB17_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_s_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB18_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
; RV32I-NEXT:  .LBB18_2:
; RV32I-NEXT:    srai a1, a0, 31
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lh a0, -480(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB18_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB18_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB18_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB18_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB18_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB18_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB18_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB18_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_store_64:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB18_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB18_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB18_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB18_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_store_64:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB18_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB18_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i16_z_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB19_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB19_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lhu a0, -480(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB19_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB19_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB19_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB19_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB19_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB19_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB19_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB19_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_store_64:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB19_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB19_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB19_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB19_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_store_64:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB19_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB19_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i32_z_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i32_z_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB20_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:  .LBB20_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 10
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lwu a0, -960(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB20_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB20_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB20_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB20_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB20_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB20_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 10
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lwu a0, -960(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB20_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB20_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_z_store_64:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB20_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB20_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB20_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB20_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_z_store_64:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lwu a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB20_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB20_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %ext, i64 %b
  ret i64 %res
}

define i64 @test_i64_store_64(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i64_store_64:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    mv a7, a1
; RV32I-NEXT:    lui a1, 20
; RV32I-NEXT:    add a1, a1, a0
; RV32I-NEXT:    lw a1, -1916(a1)
; RV32I-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a7, .LBB21_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:  .LBB21_2: # %entry
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_store_64:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 20
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    ld a0, -1920(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB21_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:  .LBB21_2: # %entry
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_store_64:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lui a7, 20
; RV32I-SFB-NEXT:    add a7, a7, a0
; RV32I-SFB-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-SFB-NEXT:    lw a7, -1916(a7)
; RV32I-SFB-NEXT:    bnez a1, .LBB21_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB21_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB21_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a7, a3
; RV32I-SFB-NEXT:  .LBB21_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a7
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_store_64:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 20
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    ld a0, -1920(a0)
; RV64I-SFB-NEXT:    bnez a1, .LBB21_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB21_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i64_store_64:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lui a7, 20
; RV32I-SFBIQCLOAD-NEXT:    add a7, a7, a0
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-SFBIQCLOAD-NEXT:    lw a7, -1916(a7)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB21_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB21_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB21_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a7, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB21_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a7
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i64_store_64:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 20
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    ld a0, -1920(a0)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB21_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB21_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 10000   ; compute base + 10000
  %val = load i64, ptr %addr          ; load 64-bit value
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %val, i64 %b
  ret i64 %res
}

define i32 @test_i8_s_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB22_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB22_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lb a4, 1808(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB22_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB22_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB22_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB22_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB22_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB22_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB22_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB22_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB22_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB22_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_z_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB23_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB23_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lbu a4, 1808(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB23_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB23_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB23_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB23_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB23_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB23_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB23_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB23_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB23_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB23_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_s_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB24_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB24_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lh a4, -480(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB24_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB24_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB24_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB24_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB24_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB24_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB24_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB24_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB24_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB24_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_z_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB25_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB25_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lhu a4, -480(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB25_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB25_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB25_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB25_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB25_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB25_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB25_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB25_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB25_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB25_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %ext, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i32_volatile(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a4, 40000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB26_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a4, a2
; RV32I-NEXT:  .LBB26_2: # %entry
; RV32I-NEXT:    add a0, a0, a4
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 10
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lw a4, -960(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB26_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB26_2: # %entry
; RV64I-NEXT:    addw a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    bnez a1, .LBB26_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB26_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 10
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lw a0, -960(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB26_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB26_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB26_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB26_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lw a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB26_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB26_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %val, i32 %b
  %res1 = add i32 %res, %val1
  ret i32 %res1
}


define i64 @test_i8_s_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a5, 10000(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB27_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a5, a2
; RV32I-NEXT:    j .LBB27_3
; RV32I-NEXT:  .LBB27_2:
; RV32I-NEXT:    srai a3, a5, 31
; RV32I-NEXT:  .LBB27_3: # %entry
; RV32I-NEXT:    add a0, a0, a5
; RV32I-NEXT:    sltu a1, a0, a5
; RV32I-NEXT:    add a3, a3, a6
; RV32I-NEXT:    add a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lb a4, 1808(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB27_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB27_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB27_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB27_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB27_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB27_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB27_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB27_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_1_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB27_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB27_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB27_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB27_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a3, a3, a5
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_1_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB27_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB27_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i8_z_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a5, 10000(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB28_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a5, a2
; RV32I-NEXT:  .LBB28_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a0, a5
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a5
; RV32I-NEXT:    add a1, a1, a6
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lbu a4, 1808(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB28_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB28_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a5, 10000(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB28_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB28_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB28_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB28_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB28_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB28_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_1_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB28_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB28_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB28_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB28_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a5
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_1_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB28_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB28_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_s_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a5, 20000(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB29_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a5, a2
; RV32I-NEXT:    j .LBB29_3
; RV32I-NEXT:  .LBB29_2:
; RV32I-NEXT:    srai a3, a5, 31
; RV32I-NEXT:  .LBB29_3: # %entry
; RV32I-NEXT:    add a0, a0, a5
; RV32I-NEXT:    sltu a1, a0, a5
; RV32I-NEXT:    add a3, a3, a6
; RV32I-NEXT:    add a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lh a4, -480(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB29_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB29_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB29_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB29_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB29_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB29_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB29_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB29_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_1_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB29_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB29_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB29_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB29_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a3, a3, a5
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_1_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB29_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB29_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_z_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a5, 20000(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB30_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a5, a2
; RV32I-NEXT:  .LBB30_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a0, a5
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a5
; RV32I-NEXT:    add a1, a1, a6
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lhu a4, -480(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB30_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB30_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a5, 20000(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB30_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB30_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB30_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB30_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB30_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB30_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_1_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB30_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB30_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB30_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB30_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a5
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_1_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB30_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB30_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i32_z_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_z_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a5, 40000(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB31_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a5, a2
; RV32I-NEXT:  .LBB31_2: # %entry
; RV32I-NEXT:    addi a1, a1, -1
; RV32I-NEXT:    add a0, a0, a5
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a5
; RV32I-NEXT:    add a1, a1, a6
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 10
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lwu a4, -960(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB31_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB31_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a5, 40000(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB31_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB31_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB31_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB31_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 10
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lwu a0, -960(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB31_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB31_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_z_1_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB31_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB31_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB31_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB31_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a5
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_z_1_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lwu a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB31_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB31_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %ext, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i64_1_volatile(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i64_1_volatile:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lui a6, 20
; RV32I-NEXT:    qc.e.lw a5, 80000(a0)
; RV32I-NEXT:    add a0, a0, a6
; RV32I-NEXT:    lw a7, -1916(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB32_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a5, a2
; RV32I-NEXT:    mv a7, a3
; RV32I-NEXT:  .LBB32_2: # %entry
; RV32I-NEXT:    add a0, a0, a5
; RV32I-NEXT:    sltu a1, a0, a5
; RV32I-NEXT:    add a6, a6, a7
; RV32I-NEXT:    add a1, a1, a6
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_volatile:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 20
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    ld a4, -1920(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB32_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a4, a2
; RV64I-NEXT:  .LBB32_2: # %entry
; RV64I-NEXT:    add a0, a4, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_volatile:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lui a6, 20
; RV32I-SFB-NEXT:    qc.e.lw a5, 80000(a0)
; RV32I-SFB-NEXT:    add a0, a0, a6
; RV32I-SFB-NEXT:    lw a6, -1916(a0)
; RV32I-SFB-NEXT:    lw a7, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB32_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB32_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB32_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a6, a3
; RV32I-SFB-NEXT:  .LBB32_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a6, a6, a7
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_volatile:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 20
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    ld a0, -1920(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    bnez a1, .LBB32_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB32_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i64_1_volatile:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lui a5, 20
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a0
; RV32I-SFBIQCLOAD-NEXT:    lw a5, -1916(a5)
; RV32I-SFBIQCLOAD-NEXT:    lw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB32_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 80000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB32_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB32_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB32_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a1, a5, a6
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a2, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i64_1_volatile:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 20
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    ld a0, -1920(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    bnez a1, .LBB32_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB32_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 10000   ; compute base + 10000
  %val = load i64, ptr %addr          ; load 64-bit value
  %val1 = load volatile i64, ptr %base1
  %res = select i1 %x, i64 %val, i64 %b
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i32 @test_i8_s_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_s_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB33_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-NEXT:  .LBB33_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB33_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lb a2, 1808(a0)
; RV64I-NEXT:  .LBB33_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB33_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB33_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB33_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB33_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB33_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB33_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB33_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB33_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i8_z_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i8_z_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB34_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-NEXT:  .LBB34_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB34_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lbu a2, 1808(a0)
; RV64I-NEXT:  .LBB34_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB34_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB34_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB34_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB34_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB34_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB34_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB34_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB34_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_s_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_s_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB35_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-NEXT:  .LBB35_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB35_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lh a2, -480(a0)
; RV64I-NEXT:  .LBB35_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB35_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB35_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB35_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB35_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB35_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB35_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB35_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB35_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_z_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i16_z_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB36_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-NEXT:  .LBB36_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB36_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lhu a2, -480(a0)
; RV64I-NEXT:  .LBB36_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB36_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB36_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB36_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB36_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB36_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB36_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB36_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB36_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i32_op(ptr %base, i1 zeroext %x, i32 %b) nounwind {
; RV32I-LABEL: test_i32_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB37_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-NEXT:  .LBB37_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB37_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 10
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lw a2, -960(a0)
; RV64I-NEXT:  .LBB37_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB37_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB37_2: # %entry
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 10
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lw a0, -960(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB37_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB37_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB37_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB37_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lw a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB37_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB37_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %res = select i1 %x, i32 %b, i32 %val
  ret i32 %res
}

define i32 @test_i8_s_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB38_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB38_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lb a0, 1808(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB38_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB38_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB38_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB38_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB38_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB38_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_store_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB38_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB38_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_store_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB38_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB38_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i8_z_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB39_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB39_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lbu a0, 1808(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB39_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB39_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB39_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB39_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB39_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB39_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_store_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB39_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB39_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_store_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB39_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB39_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_s_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB40_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB40_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lh a0, -480(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB40_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB40_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB40_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB40_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB40_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB40_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_store_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB40_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB40_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_store_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB40_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB40_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i16_z_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB41_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB41_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lhu a0, -480(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB41_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB41_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB41_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB41_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB41_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB41_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_store_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB41_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB41_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_store_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB41_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB41_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  ret i32 %res
}

define i32 @test_i32_store_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1, i32 %c) nounwind {
; RV32I-LABEL: test_i32_store_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-NEXT:    sw a4, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB42_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB42_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_store_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 10
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lw a0, -960(a0)
; RV64I-NEXT:    sw a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB42_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB42_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_store_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    beqz a1, .LBB42_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB42_2: # %entry
; RV32I-SFB-NEXT:    sw a4, 0(a3)
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_store_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 10
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lw a0, -960(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB42_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB42_2: # %entry
; RV64I-SFB-NEXT:    sw a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_store_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB42_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB42_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_store_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lw a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB42_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB42_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sw a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  store i32 %c, ptr %base1
  %res = select i1 %x, i32 %b, i32 %val
  ret i32 %res
}

define i64 @test_i8_s_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_s_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB43_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB43_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB43_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lb a2, 1808(a0)
; RV64I-NEXT:  .LBB43_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB43_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB43_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB43_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB43_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB43_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB43_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_1_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB43_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB43_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB43_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB43_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_1_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB43_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB43_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i8_z_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i8_z_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB44_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-NEXT:  .LBB44_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB44_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lbu a2, 1808(a0)
; RV64I-NEXT:  .LBB44_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB44_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB44_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB44_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB44_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 2
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB44_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB44_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_1_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB44_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB44_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB44_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB44_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_1_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB44_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB44_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_s_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_s_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB45_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-NEXT:    srai a3, a2, 31
; RV32I-NEXT:  .LBB45_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB45_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lh a2, -480(a0)
; RV64I-NEXT:  .LBB45_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB45_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB45_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB45_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB45_4: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB45_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB45_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_1_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB45_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB45_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB45_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB45_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_1_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB45_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB45_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_z_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i16_z_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB46_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-NEXT:  .LBB46_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB46_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 5
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lhu a2, -480(a0)
; RV64I-NEXT:  .LBB46_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB46_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB46_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB46_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB46_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 5
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB46_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB46_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_1_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB46_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB46_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB46_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB46_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_1_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB46_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB46_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i32_z_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i32_z_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB47_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-NEXT:  .LBB47_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB47_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 10
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    lwu a2, -960(a0)
; RV64I-NEXT:  .LBB47_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB47_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB47_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB47_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB47_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 10
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    lwu a0, -960(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB47_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB47_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_z_1_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB47_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB47_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB47_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB47_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_z_1_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    lwu a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB47_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB47_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i64_1_op(ptr %base, i1 zeroext %x, i64 %b) nounwind {
; RV32I-LABEL: test_i64_1_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    bnez a1, .LBB48_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    lui a1, 20
; RV32I-NEXT:    add a1, a1, a0
; RV32I-NEXT:    lw a3, -1916(a1)
; RV32I-NEXT:    qc.e.lw a2, 80000(a0)
; RV32I-NEXT:  .LBB48_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    bnez a1, .LBB48_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 20
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    ld a2, -1920(a0)
; RV64I-NEXT:  .LBB48_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lui a4, 20
; RV32I-SFB-NEXT:    add a4, a4, a0
; RV32I-SFB-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-SFB-NEXT:    lw a4, -1916(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB48_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB48_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB48_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a4, a3
; RV32I-SFB-NEXT:  .LBB48_4: # %entry
; RV32I-SFB-NEXT:    mv a1, a4
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a3, 20
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ld a0, -1920(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB48_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB48_2: # %entry
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i64_1_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lui a4, 20
; RV32I-SFBIQCLOAD-NEXT:    add a4, a4, a0
; RV32I-SFBIQCLOAD-NEXT:    lw a4, -1916(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB48_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 80000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB48_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB48_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a4, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB48_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a4
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i64_1_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a3, 20
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ld a0, -1920(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB48_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB48_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 10000   ; compute base + 10000
  %val = load i64, ptr %addr          ; load 64-bit value
  %res = select i1 %x, i64 %b, i64 %val
  ret i64 %res
}

define i64 @test_i8_s_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_s_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB49_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a0, 31
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB49_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lb a0, 1808(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB49_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB49_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB49_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB49_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB49_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB49_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB49_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB49_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_store_64_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB49_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB49_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB49_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB49_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_store_64_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB49_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB49_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i8_z_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i8_z_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB50_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB50_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 2
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lbu a0, 1808(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB50_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB50_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB50_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB50_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB50_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB50_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 2
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB50_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB50_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_store_64_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB50_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB50_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB50_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB50_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_store_64_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB50_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB50_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_s_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_s_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB51_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a0, 31
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB51_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lh a0, -480(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB51_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB51_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB51_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB51_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB51_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB51_4: # %entry
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB51_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB51_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_store_64_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB51_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB51_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB51_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB51_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_store_64_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB51_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB51_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i16_z_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i16_z_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB52_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB52_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 5
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lhu a0, -480(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB52_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB52_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB52_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB52_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB52_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB52_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 5
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB52_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB52_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_store_64_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB52_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB52_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB52_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB52_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_store_64_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB52_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB52_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i32_z_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i32_z_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB53_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:  .LBB53_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 10
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    lwu a0, -960(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB53_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB53_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    bnez a1, .LBB53_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    li a3, 0
; RV32I-SFB-NEXT:  .LBB53_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB53_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB53_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 10
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    lwu a0, -960(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB53_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB53_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_z_store_64_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB53_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    li a3, 0
; RV32I-SFBIQCLOAD-NEXT:  .LBB53_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB53_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB53_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_z_store_64_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    lwu a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB53_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB53_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %ext
  ret i64 %res
}

define i64 @test_i64_store_64_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1, i64 %c) nounwind {
; RV32I-LABEL: test_i64_store_64_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    mv t0, a3
; RV32I-NEXT:    lui a3, 20
; RV32I-NEXT:    add a3, a3, a0
; RV32I-NEXT:    lw a7, -1916(a3)
; RV32I-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-NEXT:    sw a5, 0(a4)
; RV32I-NEXT:    sw a6, 4(a4)
; RV32I-NEXT:    bnez a1, .LBB54_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a0
; RV32I-NEXT:    mv t0, a7
; RV32I-NEXT:  .LBB54_2: # %entry
; RV32I-NEXT:    mv a0, a2
; RV32I-NEXT:    mv a1, t0
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_store_64_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a5, 20
; RV64I-NEXT:    add a0, a0, a5
; RV64I-NEXT:    ld a0, -1920(a0)
; RV64I-NEXT:    sd a4, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB54_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a0
; RV64I-NEXT:  .LBB54_2: # %entry
; RV64I-NEXT:    mv a0, a2
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_store_64_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lui a7, 20
; RV32I-SFB-NEXT:    add a7, a7, a0
; RV32I-SFB-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-SFB-NEXT:    lw a7, -1916(a7)
; RV32I-SFB-NEXT:    beqz a1, .LBB54_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB54_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB54_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a7, a3
; RV32I-SFB-NEXT:  .LBB54_4: # %entry
; RV32I-SFB-NEXT:    sw a5, 0(a4)
; RV32I-SFB-NEXT:    sw a6, 4(a4)
; RV32I-SFB-NEXT:    mv a1, a7
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_store_64_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a5, 20
; RV64I-SFB-NEXT:    add a0, a0, a5
; RV64I-SFB-NEXT:    ld a0, -1920(a0)
; RV64I-SFB-NEXT:    beqz a1, .LBB54_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB54_2: # %entry
; RV64I-SFB-NEXT:    sd a4, 0(a3)
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i64_store_64_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lui a7, 20
; RV32I-SFBIQCLOAD-NEXT:    add a7, a7, a0
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a0, 80000(a0)
; RV32I-SFBIQCLOAD-NEXT:    lw a7, -1916(a7)
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB54_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV32I-SFBIQCLOAD-NEXT:  .LBB54_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB54_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a7, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB54_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    sw a5, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    sw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    mv a1, a7
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i64_store_64_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a5, 20
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a5
; RV64I-SFBIQCLOAD-NEXT:    ld a0, -1920(a0)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB54_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB54_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    sd a4, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 10000   ; compute base + 10000
  %val = load i64, ptr %addr          ; load 64-bit value
  store i64 %c, ptr %base1
  %res = select i1 %x, i64 %b, i64 %val
  ret i64 %res
}

define i32 @test_i8_s_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB55_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB55_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lb a4, 1808(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB55_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB55_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB55_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB55_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB55_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB55_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB55_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB55_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB55_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB55_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = sext i8 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i8_z_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a4, 10000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB56_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB56_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lbu a4, 1808(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB56_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB56_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB56_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB56_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB56_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB56_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB56_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB56_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB56_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB56_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i32 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %ext = zext i8 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_s_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB57_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB57_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lh a4, -480(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB57_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB57_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB57_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB57_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB57_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB57_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB57_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB57_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB57_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB57_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = sext i16 %val to i32         ; sign-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i16_z_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a4, 20000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB58_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB58_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lhu a4, -480(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB58_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB58_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB58_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB58_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB58_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB58_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB58_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB58_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB58_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB58_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i32 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %ext = zext i16 %val to i32         ; zero-extend to 32 bits
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %ext
  %res1 = add i32 %res, %val1
  ret i32 %res1
}

define i32 @test_i32_volatile_op(ptr %base, i1 zeroext %x, i32 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a4, 40000(a0)
; RV32I-NEXT:    lw a0, 0(a3)
; RV32I-NEXT:    bnez a1, .LBB59_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a4
; RV32I-NEXT:  .LBB59_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 10
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lw a4, -960(a0)
; RV64I-NEXT:    lw a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB59_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB59_2: # %entry
; RV64I-NEXT:    addw a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a0, 40000(a0)
; RV32I-SFB-NEXT:    lw a3, 0(a3)
; RV32I-SFB-NEXT:    beqz a1, .LBB59_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a0, a2
; RV32I-SFB-NEXT:  .LBB59_2: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 10
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lw a0, -960(a0)
; RV64I-SFB-NEXT:    lw a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB59_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB59_2: # %entry
; RV64I-SFB-NEXT:    addw a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB59_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB59_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lw a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    lw a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB59_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB59_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    addw a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i32 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i32, ptr %base1
  %res = select i1 %x, i32 %b, i32 %val
  %res1 = add i32 %res, %val1
  ret i32 %res1
}


define i64 @test_i8_s_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_s_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lb a5, 10000(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB60_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a5, 31
; RV32I-NEXT:    mv a2, a5
; RV32I-NEXT:  .LBB60_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    sltu a1, a0, a2
; RV32I-NEXT:    add a3, a3, a6
; RV32I-NEXT:    add a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_s_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lb a4, 1808(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB60_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB60_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_s_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB60_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB60_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB60_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB60_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_s_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lb a0, 1808(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB60_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB60_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_s_1_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lb a0, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB60_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB60_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB60_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB60_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a3, a3, a5
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_s_1_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lb a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB60_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB60_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i8 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i8_z_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i8_z_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lbu a6, 10000(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB61_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB61_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a2
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i8_z_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 2
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lbu a4, 1808(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB61_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB61_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i8_z_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lbu a5, 10000(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB61_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB61_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB61_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB61_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i8_z_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 2
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lbu a0, 1808(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB61_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB61_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i8_z_1_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB61_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lbu a2, 10000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB61_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB61_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB61_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a5
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i8_z_1_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 2
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lbu a0, 1808(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB61_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB61_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i8, ptr %base, i64 10000   ; compute base + 10000
  %val = load i8, ptr %addr          ; load 8-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i8 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_s_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_s_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lh a5, 20000(a0)
; RV32I-NEXT:    lw a6, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB62_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    srai a3, a5, 31
; RV32I-NEXT:    mv a2, a5
; RV32I-NEXT:  .LBB62_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    sltu a1, a0, a2
; RV32I-NEXT:    add a3, a3, a6
; RV32I-NEXT:    add a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_s_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lh a4, -480(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB62_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB62_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_s_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFB-NEXT:    lw a5, 4(a4)
; RV32I-SFB-NEXT:    lw a4, 0(a4)
; RV32I-SFB-NEXT:    bnez a1, .LBB62_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    srai a3, a0, 31
; RV32I-SFB-NEXT:  .LBB62_2: # %entry
; RV32I-SFB-NEXT:    bnez a1, .LBB62_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a2, a0
; RV32I-SFB-NEXT:  .LBB62_4: # %entry
; RV32I-SFB-NEXT:    add a0, a2, a4
; RV32I-SFB-NEXT:    sltu a1, a0, a2
; RV32I-SFB-NEXT:    add a3, a3, a5
; RV32I-SFB-NEXT:    add a1, a1, a3
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_s_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lh a0, -480(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB62_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB62_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_s_1_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lh a0, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB62_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    srai a3, a0, 31
; RV32I-SFBIQCLOAD-NEXT:  .LBB62_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB62_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a2, a0
; RV32I-SFBIQCLOAD-NEXT:  .LBB62_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a3, a3, a5
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a3
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_s_1_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lh a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB62_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB62_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = sext i16 %val to i64         ; sign-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i16_z_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i16_z_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lhu a6, 20000(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB63_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB63_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a2
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i16_z_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 5
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lhu a4, -480(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB63_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB63_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i16_z_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lhu a5, 20000(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB63_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB63_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB63_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB63_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i16_z_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 5
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lhu a0, -480(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB63_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB63_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i16_z_1_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB63_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lhu a2, 20000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB63_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB63_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB63_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a5
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i16_z_1_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 5
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lhu a0, -480(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB63_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB63_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i16, ptr %base, i64 10000   ; compute base + 10000
  %val = load i16, ptr %addr          ; load 16-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i16 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i32_z_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i32_z_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    qc.e.lw a6, 40000(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB64_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:  .LBB64_2: # %entry
; RV32I-NEXT:    neg a1, a1
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    and a1, a1, a3
; RV32I-NEXT:    sltu a2, a0, a2
; RV32I-NEXT:    add a1, a1, a5
; RV32I-NEXT:    add a1, a1, a2
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i32_z_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 10
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    lwu a4, -960(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB64_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB64_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i32_z_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    qc.e.lw a5, 40000(a0)
; RV32I-SFB-NEXT:    lw a6, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB64_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB64_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB64_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    add a6, a6, a3
; RV32I-SFB-NEXT:  .LBB64_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i32_z_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 10
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    lwu a0, -960(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB64_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB64_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i32_z_1_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lw a5, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB64_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 40000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB64_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB64_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB64_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a1, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a5
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i32_z_1_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 10
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    lwu a0, -960(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB64_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB64_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i32, ptr %base, i64 10000   ; compute base + 10000
  %val = load i32, ptr %addr          ; load 32-bit value
  %val1 = load volatile i64, ptr %base1
  %ext = zext i32 %val to i64         ; zero-extend to 64 bits
  %res = select i1 %x, i64 %b, i64 %ext
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

define i64 @test_i64_1_volatile_op(ptr %base, i1 zeroext %x, i64 %b, ptr %base1) nounwind {
; RV32I-LABEL: test_i64_1_volatile_op:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    lui a5, 20
; RV32I-NEXT:    qc.e.lw a6, 80000(a0)
; RV32I-NEXT:    add a0, a0, a5
; RV32I-NEXT:    lw a7, -1916(a0)
; RV32I-NEXT:    lw a5, 4(a4)
; RV32I-NEXT:    lw a0, 0(a4)
; RV32I-NEXT:    bnez a1, .LBB65_2
; RV32I-NEXT:  # %bb.1: # %entry
; RV32I-NEXT:    mv a2, a6
; RV32I-NEXT:    mv a3, a7
; RV32I-NEXT:  .LBB65_2: # %entry
; RV32I-NEXT:    add a0, a0, a2
; RV32I-NEXT:    sltu a1, a0, a2
; RV32I-NEXT:    add a3, a3, a5
; RV32I-NEXT:    add a1, a1, a3
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_i64_1_volatile_op:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    lui a4, 20
; RV64I-NEXT:    add a0, a0, a4
; RV64I-NEXT:    ld a4, -1920(a0)
; RV64I-NEXT:    ld a0, 0(a3)
; RV64I-NEXT:    bnez a1, .LBB65_2
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    mv a2, a4
; RV64I-NEXT:  .LBB65_2: # %entry
; RV64I-NEXT:    add a0, a2, a0
; RV64I-NEXT:    ret
;
; RV32I-SFB-LABEL: test_i64_1_volatile_op:
; RV32I-SFB:       # %bb.0: # %entry
; RV32I-SFB-NEXT:    lui a6, 20
; RV32I-SFB-NEXT:    qc.e.lw a5, 80000(a0)
; RV32I-SFB-NEXT:    add a0, a0, a6
; RV32I-SFB-NEXT:    lw a6, -1916(a0)
; RV32I-SFB-NEXT:    lw a7, 4(a4)
; RV32I-SFB-NEXT:    lw a0, 0(a4)
; RV32I-SFB-NEXT:    beqz a1, .LBB65_2
; RV32I-SFB-NEXT:  # %bb.1: # %entry
; RV32I-SFB-NEXT:    mv a5, a2
; RV32I-SFB-NEXT:  .LBB65_2: # %entry
; RV32I-SFB-NEXT:    beqz a1, .LBB65_4
; RV32I-SFB-NEXT:  # %bb.3: # %entry
; RV32I-SFB-NEXT:    mv a6, a3
; RV32I-SFB-NEXT:  .LBB65_4: # %entry
; RV32I-SFB-NEXT:    add a0, a0, a5
; RV32I-SFB-NEXT:    sltu a1, a0, a5
; RV32I-SFB-NEXT:    add a6, a6, a7
; RV32I-SFB-NEXT:    add a1, a1, a6
; RV32I-SFB-NEXT:    ret
;
; RV64I-SFB-LABEL: test_i64_1_volatile_op:
; RV64I-SFB:       # %bb.0: # %entry
; RV64I-SFB-NEXT:    lui a4, 20
; RV64I-SFB-NEXT:    add a0, a0, a4
; RV64I-SFB-NEXT:    ld a0, -1920(a0)
; RV64I-SFB-NEXT:    ld a3, 0(a3)
; RV64I-SFB-NEXT:    beqz a1, .LBB65_2
; RV64I-SFB-NEXT:  # %bb.1: # %entry
; RV64I-SFB-NEXT:    mv a0, a2
; RV64I-SFB-NEXT:  .LBB65_2: # %entry
; RV64I-SFB-NEXT:    add a0, a0, a3
; RV64I-SFB-NEXT:    ret
;
; RV32I-SFBIQCLOAD-LABEL: test_i64_1_volatile_op:
; RV32I-SFBIQCLOAD:       # %bb.0: # %entry
; RV32I-SFBIQCLOAD-NEXT:    lui a5, 20
; RV32I-SFBIQCLOAD-NEXT:    add a5, a5, a0
; RV32I-SFBIQCLOAD-NEXT:    lw a5, -1916(a5)
; RV32I-SFBIQCLOAD-NEXT:    lw a6, 4(a4)
; RV32I-SFBIQCLOAD-NEXT:    lw a4, 0(a4)
; RV32I-SFBIQCLOAD-NEXT:    bnez a1, .LBB65_2
; RV32I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV32I-SFBIQCLOAD-NEXT:    qc.e.lw a2, 80000(a0)
; RV32I-SFBIQCLOAD-NEXT:  .LBB65_2: # %entry
; RV32I-SFBIQCLOAD-NEXT:    beqz a1, .LBB65_4
; RV32I-SFBIQCLOAD-NEXT:  # %bb.3: # %entry
; RV32I-SFBIQCLOAD-NEXT:    mv a5, a3
; RV32I-SFBIQCLOAD-NEXT:  .LBB65_4: # %entry
; RV32I-SFBIQCLOAD-NEXT:    add a1, a5, a6
; RV32I-SFBIQCLOAD-NEXT:    add a0, a2, a4
; RV32I-SFBIQCLOAD-NEXT:    sltu a2, a0, a2
; RV32I-SFBIQCLOAD-NEXT:    add a1, a1, a2
; RV32I-SFBIQCLOAD-NEXT:    ret
;
; RV64I-SFBIQCLOAD-LABEL: test_i64_1_volatile_op:
; RV64I-SFBIQCLOAD:       # %bb.0: # %entry
; RV64I-SFBIQCLOAD-NEXT:    lui a4, 20
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a4
; RV64I-SFBIQCLOAD-NEXT:    ld a0, -1920(a0)
; RV64I-SFBIQCLOAD-NEXT:    ld a3, 0(a3)
; RV64I-SFBIQCLOAD-NEXT:    beqz a1, .LBB65_2
; RV64I-SFBIQCLOAD-NEXT:  # %bb.1: # %entry
; RV64I-SFBIQCLOAD-NEXT:    mv a0, a2
; RV64I-SFBIQCLOAD-NEXT:  .LBB65_2: # %entry
; RV64I-SFBIQCLOAD-NEXT:    add a0, a0, a3
; RV64I-SFBIQCLOAD-NEXT:    ret
entry:
  %addr = getelementptr i64, ptr %base, i64 10000   ; compute base + 10000
  %val = load i64, ptr %addr          ; load 64-bit value
  %val1 = load volatile i64, ptr %base1
  %res = select i1 %x, i64 %b, i64 %val
  %res1 = add i64 %res, %val1
  ret i64 %res1
}

