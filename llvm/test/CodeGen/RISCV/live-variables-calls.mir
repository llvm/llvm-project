# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=riscv64 -riscv-enable-live-variables -verify-machineinstrs -o - %s | FileCheck %s
#
# Test live variable analysis with function calls and register clobbering
# Function calls clobber caller-saved registers, which affects liveness

# REQUIRES: Assertions

--- |
  declare i64 @external_func(i64, i64)
  declare void @void_func(i64)

  define i64 @test_call_simple(i64 %a, i64 %b) {
  entry:
    %result = call i64 @external_func(i64 %a, i64 %b)
    ret i64 %result
  }

  define i64 @test_call_with_live_values(i64 %a, i64 %b, i64 %c) {
  entry:
    %sum1 = add i64 %a, %b
    %result = call i64 @external_func(i64 %sum1, i64 %c)
    ; %b is live across the call
    %final = add i64 %result, %b
    ret i64 %final
  }

  define i64 @test_multiple_calls(i64 %a, i64 %b) {
  entry:
    %r1 = call i64 @external_func(i64 %a, i64 %b)
    call void @void_func(i64 %r1)
    %r2 = call i64 @external_func(i64 %r1, i64 %b)
    ret i64 %r2
  }

  define i64 @test_call_with_spill(i64 %a, i64 %b, i64 %c, i64 %d, i64 %e, i64 %f, i64 %g, i64 %h) {
  entry:
    %sum = add i64 %a, %b
    %result = call i64 @external_func(i64 %sum, i64 %c)
    ; Many values live across call - may require spilling
    %t1 = add i64 %result, %d
    %t2 = add i64 %t1, %e
    %t3 = add i64 %t2, %f
    %t4 = add i64 %t3, %g
    %t5 = add i64 %t4, %h
    ret i64 %t5
  }
...
---
name:            test_call_simple
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_call_simple
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    $x10 = COPY %0
    $x11 = COPY %1
    ; Call clobbers many registers per calling convention
    PseudoCALL target-flags(riscv-call) @external_func, csr_ilp32_lp64, implicit-def $x1, implicit $x10, implicit $x11, implicit-def $x10
    %2:gpr = COPY $x10
    $x10 = COPY %2
    PseudoRET implicit $x10
...
---
name:            test_call_with_live_values
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
  - { reg: '$x12', virtual-reg: '%2' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11, $x12
    ; CHECK-LABEL: name: test_call_with_live_values
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11, $x12

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    %2:gpr = COPY $x12
    %3:gpr = ADD %0, %1
    ; %1 must remain live across this call
    $x10 = COPY %3
    $x11 = COPY %2
    PseudoCALL target-flags(riscv-call) @external_func, csr_ilp32_lp64, implicit-def $x1, implicit $x10, implicit $x11, implicit-def $x10
    %4:gpr = COPY $x10
    ; %1 is used again here after the call
    %5:gpr = ADD %4, %1
    $x10 = COPY %5
    PseudoRET implicit $x10
...
---
name:            test_multiple_calls
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11
    ; CHECK-LABEL: name: test_multiple_calls
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11

    ; First call
    $x10 = COPY %0
    $x11 = COPY %1
    PseudoCALL target-flags(riscv-call) @external_func, csr_ilp32_lp64, implicit-def $x1, implicit $x10, implicit $x11, implicit-def $x10
    %2:gpr = COPY $x10

    ; Second call (void)
    $x10 = COPY %2
    PseudoCALL target-flags(riscv-call) @void_func, csr_ilp32_lp64, implicit-def $x1, implicit $x10

    ; Third call - %2 and %1 are both live here
    $x10 = COPY %2
    $x11 = COPY %1
    PseudoCALL target-flags(riscv-call) @external_func, csr_ilp32_lp64, implicit-def $x1, implicit $x10, implicit $x11, implicit-def $x10
    %3:gpr = COPY $x10

    $x10 = COPY %3
    PseudoRET implicit $x10
...
---
name:            test_call_with_spill
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gpr }
  - { id: 1, class: gpr }
  - { id: 2, class: gpr }
  - { id: 3, class: gpr }
  - { id: 4, class: gpr }
  - { id: 5, class: gpr }
  - { id: 6, class: gpr }
  - { id: 7, class: gpr }
  - { id: 8, class: gpr }
  - { id: 9, class: gpr }
  - { id: 10, class: gpr }
  - { id: 11, class: gpr }
  - { id: 12, class: gpr }
  - { id: 13, class: gpr }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$x11', virtual-reg: '%1' }
  - { reg: '$x12', virtual-reg: '%2' }
  - { reg: '$x13', virtual-reg: '%3' }
  - { reg: '$x14', virtual-reg: '%4' }
  - { reg: '$x15', virtual-reg: '%5' }
  - { reg: '$x16', virtual-reg: '%6' }
  - { reg: '$x17', virtual-reg: '%7' }
body:             |
  bb.0.entry:
    liveins: $x10, $x11, $x12, $x13, $x14, $x15, $x16, $x17
    ; CHECK-LABEL: name: test_call_with_spill
    ; CHECK: bb.0.entry:
    ; CHECK-NEXT: liveins: $x10, $x11, $x12, $x13, $x14, $x15, $x16, $x17
    ; Many registers live across call - tests register pressure

    %0:gpr = COPY $x10
    %1:gpr = COPY $x11
    %2:gpr = COPY $x12
    %3:gpr = COPY $x13
    %4:gpr = COPY $x14
    %5:gpr = COPY $x15
    %6:gpr = COPY $x16
    %7:gpr = COPY $x17

    %8:gpr = ADD %0, %1

    ; Call with many live values - %3, %4, %5, %6, %7 all live across
    $x10 = COPY %8
    $x11 = COPY %2
    PseudoCALL target-flags(riscv-call) @external_func, csr_ilp32_lp64, implicit-def $x1, implicit $x10, implicit $x11, implicit-def $x10
    %9:gpr = COPY $x10

    ; All these values should have been kept live
    %10:gpr = ADD %9, %3
    %11:gpr = ADD %10, %4
    %12:gpr = ADD %11, %5
    %13:gpr = ADD %12, %6
    %14:gpr = ADD %13, %7

    $x10 = COPY %14
    PseudoRET implicit $x10
...
