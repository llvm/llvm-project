# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc %s -mtriple=riscv64 -mattr=+v \
# RUN: -run-pass=prologepilog,cfi-instr-inserter  \
# RUN: -riscv-enable-cfi-instr-inserter=true \
# RUN: -o - | FileCheck %s
# XFAIL: *
#
# In this test prolog will be inserted in bb.3. We need to save the scalable vector register v1.
# In bb.3 the new rule for computing CFA will be (sp + 16 + 1 * vlenb) which we encode using cfi_escape. Also, $v1 will be saved at (cfa - 1 * vlenb), which we also encode using cfi_escape.
# Since the only way to get to bb.2 is from bb.3, the same cfi's should be emitted at beginning of bb.2
#
# Currently CFIInstrInserter can't handle escape, so we end up with wrong CFI.
# NOTE: if llc was compiled with NDEBUG, this will just crash. Otherwise, the output will be as in CHECK lines.

--- |

  define riscv_vector_cc void @test0(ptr %p0, ptr %p1) #0 {
    entry:
    %v = load <4 x i32>, ptr %p0, align 16
    store <4 x i32> %v, ptr %p1, align 16
    ret void
  }

  attributes #0 = { "target-features"="+v" }

...
---
name:            test0
tracksRegLiveness: true
frameInfo:
  savePoint:
    - point: '%bb.3'
  restorePoint:
    - point: '%bb.2'
body:             |
  ; CHECK-LABEL: name: test0
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT:   liveins: $x10, $x11, $v1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BEQ $x10, $x0, %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   liveins: $v1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   PseudoRET
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   CFI_INSTRUCTION def_cfa_offset 16
  ; CHECK-NEXT:   $x10 = ADDI $x2, 16
  ; CHECK-NEXT:   $v1 = frame-destroy VL1RE8_V killed $x10 :: (load (<vscale x 1 x s64>) from %stack.0)
  ; CHECK-NEXT:   $x10 = frame-destroy PseudoReadVLENB
  ; CHECK-NEXT:   $x2 = frame-destroy ADD $x2, killed $x10
  ; CHECK-NEXT:   frame-destroy CFI_INSTRUCTION def_cfa $x2, 16
  ; CHECK-NEXT:   frame-destroy CFI_INSTRUCTION restore $v1
  ; CHECK-NEXT:   $x2 = frame-destroy ADDI $x2, 16
  ; CHECK-NEXT:   frame-destroy CFI_INSTRUCTION def_cfa_offset 0
  ; CHECK-NEXT:   PseudoBR %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $x10, $x11, $v1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $x2 = frame-setup ADDI $x2, -16
  ; CHECK-NEXT:   frame-setup CFI_INSTRUCTION def_cfa_offset 16
  ; CHECK-NEXT:   $x12 = frame-setup PseudoReadVLENB
  ; CHECK-NEXT:   $x2 = frame-setup SUB $x2, killed $x12
  ; CHECK-NEXT:   frame-setup CFI_INSTRUCTION escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x10, 0x22, 0x11, 0x01, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22
  ; CHECK-NEXT:   $x12 = ADDI $x2, 16
  ; CHECK-NEXT:   frame-setup VS1R_V killed $v1, killed $x12 :: (store (<vscale x 1 x s64>) into %stack.0)
  ; CHECK-NEXT:   frame-setup CFI_INSTRUCTION escape 0x10, 0x61, 0x08, 0x11, 0x7f, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22
  ; CHECK-NEXT:   dead $x0 = PseudoVSETIVLI 4, 208 /* e32, m1, ta, ma */, implicit-def $vl, implicit-def $vtype
  ; CHECK-NEXT:   renamable $v1 = PseudoVLE32_V_M1 undef renamable $v1, killed renamable $x10, 4, 5 /* e32 */, 2 /* tu, ma */, implicit $vl, implicit $vtype
  ; CHECK-NEXT:   PseudoVSE32_V_M1 killed renamable $v1, killed renamable $x11, 4, 5 /* e32 */, implicit $vl, implicit $vtype
  ; CHECK-NEXT:   PseudoBR %bb.2
  bb.0.entry:
    liveins: $x10, $x11
    BEQ $x10, $x0, %bb.3

  bb.1:
    PseudoRET

  bb.2:
    PseudoBR %bb.1

  bb.3:
    liveins: $x10, $x11
    dead $x0 = PseudoVSETIVLI 4, 208, implicit-def $vl, implicit-def $vtype
    renamable $v1 = PseudoVLE32_V_M1 undef renamable $v1, killed renamable $x10, 4, 5, 2, implicit $vl, implicit $vtype
    PseudoVSE32_V_M1 killed renamable $v1, killed renamable $x11, 4, 5, implicit $vl, implicit $vtype
    PseudoBR %bb.2
...
