; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mattr=+v -mtriple=riscv64 | FileCheck %s --check-prefixes=RV64I

define void @main(i1 %tobool.not) {
; RV64I-LABEL: main:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    addi sp, sp, -32
; RV64I-NEXT:    .cfi_def_cfa_offset 32
; RV64I-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; RV64I-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; RV64I-NEXT:    .cfi_offset ra, -8
; RV64I-NEXT:    .cfi_offset s0, -16
; RV64I-NEXT:    csrr a1, vlenb
; RV64I-NEXT:    slli a1, a1, 1
; RV64I-NEXT:    mv a2, a1
; RV64I-NEXT:    slli a1, a1, 2
; RV64I-NEXT:    add a1, a1, a2
; RV64I-NEXT:    sub sp, sp, a1
; RV64I-NEXT:    .cfi_escape 0x0f, 0x0d, 0x72, 0x00, 0x11, 0x20, 0x22, 0x11, 0x0a, 0x92, 0xa2, 0x38, 0x00, 0x1e, 0x22 # sp + 32 + 10 * vlenb
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    andi s0, a0, 1
; RV64I-NEXT:    vsetivli zero, 0, e8, m2, ta, ma
; RV64I-NEXT:    vmv.v.i v10, 0
; RV64I-NEXT:    vmclr.m v0
; RV64I-NEXT:    vmv.v.i v12, 0
; RV64I-NEXT:    vsetivli zero, 0, e16, m1, ta, ma
; RV64I-NEXT:    vmv.v.i v16, 9
; RV64I-NEXT:    vmv2r.v v14, v10
; RV64I-NEXT:    vmv2r.v v8, v10
; RV64I-NEXT:    csrr a0, vlenb
; RV64I-NEXT:    slli a0, a0, 2
; RV64I-NEXT:    add a0, sp, a0
; RV64I-NEXT:    addi a0, a0, 16
; RV64I-NEXT:    vs4r.v v8, (a0) # vscale x 32-byte Folded Spill
; RV64I-NEXT:    csrr a2, vlenb
; RV64I-NEXT:    slli a2, a2, 2
; RV64I-NEXT:    add a0, a0, a2
; RV64I-NEXT:    vs2r.v v12, (a0) # vscale x 16-byte Folded Spill
; RV64I-NEXT:    vmv.v.i v8, 9
; RV64I-NEXT:    addi a0, sp, 16
; RV64I-NEXT:    vs4r.v v8, (a0) # vscale x 32-byte Folded Spill
; RV64I-NEXT:    vsetivli zero, 0, e8, m2, ta, ma
; RV64I-NEXT:    vsoxseg3ei16.v v10, (zero), v16, v0.t
; RV64I-NEXT:    jalr a1
; RV64I-NEXT:    bnez s0, .LBB0_2
; RV64I-NEXT:  # %bb.1: # %land.rhs
; RV64I-NEXT:    csrr a0, vlenb
; RV64I-NEXT:    slli a0, a0, 2
; RV64I-NEXT:    add a0, sp, a0
; RV64I-NEXT:    addi a0, a0, 16
; RV64I-NEXT:    vl4r.v v8, (a0) # vscale x 32-byte Folded Reload
; RV64I-NEXT:    csrr a1, vlenb
; RV64I-NEXT:    slli a1, a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    vl2r.v v12, (a0) # vscale x 16-byte Folded Reload
; RV64I-NEXT:    vsetivli zero, 0, e8, m2, ta, ma
; RV64I-NEXT:    vmv2r.v v10, v8
; RV64I-NEXT:    vmv2r.v v12, v8
; RV64I-NEXT:    vmclr.m v0
; RV64I-NEXT:    vmv2r.v v14, v8
; RV64I-NEXT:    csrr a0, vlenb
; RV64I-NEXT:    slli a0, a0, 2
; RV64I-NEXT:    add a0, sp, a0
; RV64I-NEXT:    addi a0, a0, 16
; RV64I-NEXT:    vs4r.v v8, (a0) # vscale x 32-byte Folded Spill
; RV64I-NEXT:    csrr a1, vlenb
; RV64I-NEXT:    slli a1, a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    vs2r.v v12, (a0) # vscale x 16-byte Folded Spill
; RV64I-NEXT:    vsetivli zero, 0, e16, m1, ta, ma
; RV64I-NEXT:    vmv.v.i v8, 9
; RV64I-NEXT:    vsetivli zero, 0, e8, m2, ta, ma
; RV64I-NEXT:    vsoxseg3ei16.v v10, (zero), v8, v0.t
; RV64I-NEXT:  .LBB0_2: # %land.end
; RV64I-NEXT:    li a2, 9
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    call memset
; RV64I-NEXT:    csrr a0, vlenb
; RV64I-NEXT:    slli a0, a0, 2
; RV64I-NEXT:    add a0, sp, a0
; RV64I-NEXT:    addi a0, a0, 16
; RV64I-NEXT:    vl4r.v v8, (a0) # vscale x 32-byte Folded Reload
; RV64I-NEXT:    csrr a1, vlenb
; RV64I-NEXT:    slli a1, a1, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    vl2r.v v12, (a0) # vscale x 16-byte Folded Reload
; RV64I-NEXT:    vsetivli zero, 0, e8, m2, ta, ma
; RV64I-NEXT:    vmv2r.v v10, v8
; RV64I-NEXT:    vmclr.m v0
; RV64I-NEXT:    vmv2r.v v12, v8
; RV64I-NEXT:    addi a0, sp, 16
; RV64I-NEXT:    vl4r.v v16, (a0) # vscale x 32-byte Folded Reload
; RV64I-NEXT:    vsoxseg3ei16.v v8, (zero), v16, v0.t
; RV64I-NEXT:    csrr a0, vlenb
; RV64I-NEXT:    slli a0, a0, 1
; RV64I-NEXT:    mv a1, a0
; RV64I-NEXT:    slli a0, a0, 2
; RV64I-NEXT:    add a0, a0, a1
; RV64I-NEXT:    add sp, sp, a0
; RV64I-NEXT:    .cfi_def_cfa sp, 32
; RV64I-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; RV64I-NEXT:    .cfi_restore ra
; RV64I-NEXT:    .cfi_restore s0
; RV64I-NEXT:    addi sp, sp, 32
; RV64I-NEXT:    .cfi_def_cfa_offset 0
; RV64I-NEXT:    ret
entry:
  %0 = tail call <vscale x 16 x i16> @llvm.riscv.vmv.s.x.nxv16i16.i64(<vscale x 16 x i16> poison, i16 9, i64 0)
  call void @llvm.riscv.vsoxseg3.mask.triscv.vector.tuple_nxv16i8_3t.p0.nxv16i16.nxv16i1.i64(target("riscv.vector.tuple", <vscale x 16 x i8>, 3) zeroinitializer, ptr null, <vscale x 16 x i16> %0, <vscale x 16 x i1> zeroinitializer, i64 0, i64 3)
  %call = tail call i32 null()
  br i1 %tobool.not, label %n.exit.land.end_crit_edge, label %land.rhs

n.exit.land.end_crit_edge:                        ; preds = %entry
  %.pre = tail call <vscale x 16 x i16> @llvm.riscv.vmv.s.x.nxv16i16.i64(<vscale x 16 x i16> poison, i16 9, i64 0)
  br label %land.end

land.rhs:                                         ; preds = %entry
  %1 = tail call <vscale x 16 x i16> @llvm.riscv.vmv.s.x.nxv16i16.i64(<vscale x 16 x i16> poison, i16 9, i64 0)
  call void @llvm.riscv.vsoxseg3.mask.triscv.vector.tuple_nxv16i8_3t.p0.nxv16i16.nxv16i1.i64(target("riscv.vector.tuple", <vscale x 16 x i8>, 3) zeroinitializer, ptr null, <vscale x 16 x i16> %1, <vscale x 16 x i1> zeroinitializer, i64 0, i64 3)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %n.exit.land.end_crit_edge
  %.pre-phi = phi <vscale x 16 x i16> [ %.pre, %n.exit.land.end_crit_edge ], [ %1, %land.rhs ]
  call void @llvm.memset.p0.i64(ptr poison, i8 0, i64 9, i1 false)
  call void @llvm.riscv.vsoxseg3.mask.triscv.vector.tuple_nxv16i8_3t.p0.nxv16i16.nxv16i1.i64(target("riscv.vector.tuple", <vscale x 16 x i8>, 3) zeroinitializer, ptr null, <vscale x 16 x i16> %.pre-phi, <vscale x 16 x i1> zeroinitializer, i64 0, i64 3)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare <vscale x 16 x i16> @llvm.riscv.vmv.s.x.nxv16i16.i64(<vscale x 16 x i16>, i16, i64)

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(write)
declare void @llvm.riscv.vsoxseg3.mask.triscv.vector.tuple_nxv16i8_3t.p0.nxv16i16.nxv16i1.i64(target("riscv.vector.tuple", <vscale x 16 x i8>, 3), ptr captures(none), <vscale x 16 x i16>, <vscale x 16 x i1>, i64, i64 immarg) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr writeonly captures(none), i8, i64, i1 immarg)
