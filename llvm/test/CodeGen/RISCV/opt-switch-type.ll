; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=RV64I %s

define dso_local void @test_switch_2_users(ptr nocapture noundef readonly %x) local_unnamed_addr {
; RV64I-LABEL: test_switch_2_users:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    .cfi_def_cfa_offset 16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    .cfi_offset ra, -8
; RV64I-NEXT:    lh a0, 0(a0)
; RV64I-NEXT:    li a1, 16
; RV64I-NEXT:    blt a0, a1, .LBB0_5
; RV64I-NEXT:  # %bb.1: # %if.then
; RV64I-NEXT:    addi a1, a0, -17
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    bgeu a1, a2, .LBB0_3
; RV64I-NEXT:  # %bb.2: # %sw.bb3
; RV64I-NEXT:    call foo2
; RV64I-NEXT:    j .LBB0_5
; RV64I-NEXT:  .LBB0_3: # %if.then
; RV64I-NEXT:    li a1, 16
; RV64I-NEXT:    bne a0, a1, .LBB0_5
; RV64I-NEXT:  # %bb.4: # %sw.bb
; RV64I-NEXT:    call foo1
; RV64I-NEXT:  .LBB0_5: # %if.end
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    tail foo3
entry:
  %0 = load i16, ptr %x, align 2
  %cmp = icmp sgt i16 %0, 15
  br i1 %cmp, label %if.then, label %if.end

if.then:
  switch i16 %0, label %if.end [
    i16 16, label %sw.bb
    i16 17, label %sw.bb3
    i16 18, label %sw.bb3
  ]

sw.bb:
  tail call void @foo1() #2
  br label %if.end

sw.bb3:
  tail call void @foo2() #2
  br label %if.end

if.end:
  tail call void @foo3() #2
  ret void
}

declare void @foo1(...) local_unnamed_addr #1

declare void @foo2(...) local_unnamed_addr #1

declare void @foo3(...) local_unnamed_addr #1

define dso_local void @foo(ptr nocapture noundef readonly %x) local_unnamed_addr {
; RV64I-LABEL: foo:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    addi sp, sp, -16
; RV64I-NEXT:    .cfi_def_cfa_offset 16
; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64I-NEXT:    .cfi_offset ra, -8
; RV64I-NEXT:    lh a0, 0(a0)
; RV64I-NEXT:    li a1, 16
; RV64I-NEXT:    blt a0, a1, .LBB1_6
; RV64I-NEXT:  # %bb.1: # %entry
; RV64I-NEXT:    lui a1, 16
; RV64I-NEXT:    addiw a1, a1, -4
; RV64I-NEXT:    and a1, a0, a1
; RV64I-NEXT:    li a2, 4
; RV64I-NEXT:    bne a1, a2, .LBB1_6
; RV64I-NEXT:  # %bb.2: # %if.then6
; RV64I-NEXT:    slli a0, a0, 48
; RV64I-NEXT:    srli a0, a0, 48
; RV64I-NEXT:    addi a1, a0, -17
; RV64I-NEXT:    li a2, 2
; RV64I-NEXT:    bgeu a1, a2, .LBB1_4
; RV64I-NEXT:  # %bb.3: # %sw.bb8
; RV64I-NEXT:    call baz
; RV64I-NEXT:    j .LBB1_6
; RV64I-NEXT:  .LBB1_4: # %if.then6
; RV64I-NEXT:    li a1, 16
; RV64I-NEXT:    bne a0, a1, .LBB1_6
; RV64I-NEXT:  # %bb.5: # %sw.bb
; RV64I-NEXT:    call bar
; RV64I-NEXT:  .LBB1_6: # %if.end9
; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64I-NEXT:    addi sp, sp, 16
; RV64I-NEXT:    tail bat
entry:
  %0 = load i16, ptr %x, align 2
  %1 = and i16 %0, -4
  %cmp = icmp eq i16 %1, 4
  %cmp4 = icmp sgt i16 %0, 15
  %or.cond10 = and i1 %cmp4, %cmp
  br i1 %or.cond10, label %if.then6, label %if.end9

if.then6:
  switch i16 %0, label %if.end9 [
    i16 16, label %sw.bb
    i16 17, label %sw.bb8
    i16 18, label %sw.bb8
  ]

sw.bb:
  tail call void @bar() #2
  br label %if.end9

sw.bb8:
  tail call void @baz() #2
  br label %if.end9

if.end9:
  tail call void @bat() #2
  ret void
}

declare void @bar(...) local_unnamed_addr #1

declare void @baz(...) local_unnamed_addr #1

declare void @bat(...) local_unnamed_addr #1
