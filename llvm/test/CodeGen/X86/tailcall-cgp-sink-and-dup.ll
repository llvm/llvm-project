; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=x86_64-apple-darwin | FileCheck %s
; RUN: opt -S -passes='require<profile-summary>,function(codegenprepare)' < %s -mtriple=x86_64-apple-darwin | FileCheck %s --check-prefix=OPT

define i32 @sink_and_duplicate_for_tailc(i1 %c) nounwind {
; OPT-LABEL: define i32 @sink_and_duplicate_for_tailc(
; OPT-SAME: i1 [[C:%.*]]) #[[ATTR0:[0-9]+]] {
; OPT-NEXT:  [[ENTRY:.*:]]
; OPT-NEXT:    [[C_FR:%.*]] = freeze i1 [[C]]
; OPT-NEXT:    br i1 [[C_FR]], label %[[IF_THEN:.*]], label %[[RETURN:.*]]
; OPT:       [[IF_THEN]]:
; OPT-NEXT:    [[RV1:%.*]] = tail call i32 @qux()
; OPT-NEXT:    [[TMP0:%.*]] = tail call i32 @quux()
; OPT-NEXT:    ret i32 [[RV1]]
; OPT:       [[RETURN]]:
; OPT-NEXT:    [[RV:%.*]] = tail call i32 @qux()
; OPT-NEXT:    ret i32 [[RV]]
;
; CHECK-LABEL: sink_and_duplicate_for_tailc:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    testb $1, %dil
; CHECK-NEXT:    je _qux ## TAILCALL
; CHECK-NEXT:  ## %bb.1: ## %if.then
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    callq _qux
; CHECK-NEXT:    movl %eax, %ebx
; CHECK-NEXT:    callq _quux
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    retq
entry:
  %rv = tail call i32 @qux()
  br i1 %c, label %if.then, label %return

if.then:
  tail call i32 @quux()
  br label %return

return:
  ret i32 %rv
}

define ptr @sink_and_duplicate_for_tailc_extractvalue(i1 noundef %c) nounwind {
; OPT-LABEL: define ptr @sink_and_duplicate_for_tailc_extractvalue(
; OPT-SAME: i1 noundef [[C:%.*]]) #[[ATTR0]] {
; OPT-NEXT:  [[ENTRY:.*:]]
; OPT-NEXT:    br i1 [[C]], label %[[IF_THEN:.*]], label %[[RETURN:.*]]
; OPT:       [[IF_THEN]]:
; OPT-NEXT:    [[CALL1:%.*]] = tail call { ptr, i32 } @qux_twice()
; OPT-NEXT:    [[TMP0:%.*]] = tail call { ptr, i32 } @quux_twice()
; OPT-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[CALL1]], 0
; OPT-NEXT:    ret ptr [[TMP1]]
; OPT:       [[RETURN]]:
; OPT-NEXT:    [[CALL:%.*]] = tail call { ptr, i32 } @qux_twice()
; OPT-NEXT:    [[RV:%.*]] = extractvalue { ptr, i32 } [[CALL]], 0
; OPT-NEXT:    ret ptr [[RV]]
;
; CHECK-LABEL: sink_and_duplicate_for_tailc_extractvalue:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    testb $1, %dil
; CHECK-NEXT:    je _qux_twice ## TAILCALL
; CHECK-NEXT:  ## %bb.1: ## %if.then
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    callq _qux_twice
; CHECK-NEXT:    movq %rax, %rbx
; CHECK-NEXT:    callq _quux_twice
; CHECK-NEXT:    movq %rbx, %rax
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    retq
entry:
  %call = tail call { ptr, i32 } @qux_twice()
  br i1 %c, label %if.then, label %return

if.then:
  tail call { ptr, i32 } @quux_twice()
  br label %return

return:
  %rv = extractvalue { ptr, i32 } %call, 0
  ret ptr %rv
}

define i32 @sink_and_duplicate_for_tailc_two_args(i1 noundef %c, i32 %a, i32 %b) nounwind {
; OPT-LABEL: define i32 @sink_and_duplicate_for_tailc_two_args(
; OPT-SAME: i1 noundef [[C:%.*]], i32 [[A:%.*]], i32 [[B:%.*]]) #[[ATTR0]] {
; OPT-NEXT:  [[ENTRY:.*:]]
; OPT-NEXT:    br i1 [[C]], label %[[IF_THEN:.*]], label %[[RETURN:.*]]
; OPT:       [[IF_THEN]]:
; OPT-NEXT:    [[RV1:%.*]] = tail call i32 @two_args(i32 [[A]], i32 [[B]])
; OPT-NEXT:    [[TMP0:%.*]] = tail call i32 @quux()
; OPT-NEXT:    ret i32 [[RV1]]
; OPT:       [[RETURN]]:
; OPT-NEXT:    [[RV:%.*]] = tail call i32 @two_args(i32 [[A]], i32 [[B]])
; OPT-NEXT:    ret i32 [[RV]]
;
; CHECK-LABEL: sink_and_duplicate_for_tailc_two_args:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    testb $1, %dil
; CHECK-NEXT:    je LBB2_2
; CHECK-NEXT:  ## %bb.1: ## %if.then
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %edi
; CHECK-NEXT:    movl %edx, %esi
; CHECK-NEXT:    callq _two_args
; CHECK-NEXT:    movl %eax, %ebx
; CHECK-NEXT:    callq _quux
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    retq
; CHECK-NEXT:  LBB2_2: ## %return
; CHECK-NEXT:    movl %esi, %edi
; CHECK-NEXT:    movl %edx, %esi
; CHECK-NEXT:    jmp _two_args ## TAILCALL
entry:
  %rv = tail call i32 @two_args(i32 %a, i32 %b)
  br i1 %c, label %if.then, label %return

if.then:
  tail call i32 @quux()
  br label %return

return:
  ret i32 %rv
}

; Negative tests for duplicate for tail call.

define i32 @sink_and_duplicate_for_tailc_illegal(i1 %c) {
; OPT-LABEL: define i32 @sink_and_duplicate_for_tailc_illegal(
; OPT-SAME: i1 [[C:%.*]]) {
; OPT-NEXT:  [[ENTRY:.*:]]
; OPT-NEXT:    [[RV:%.*]] = tail call i32 @qux()
; OPT-NEXT:    br i1 [[C]], label %[[NEXT:.*]], label %[[IF_THEN:.*]]
; OPT:       [[NEXT]]:
; OPT-NEXT:    br i1 [[C]], label %[[IF_THEN]], label %[[RETURN:.*]]
; OPT:       [[IF_THEN]]:
; OPT-NEXT:    [[TMP0:%.*]] = tail call i32 @quux()
; OPT-NEXT:    br label %[[RETURN]]
; OPT:       [[RETURN]]:
; OPT-NEXT:    ret i32 [[RV]]
;
entry:
  %rv = tail call i32 @qux()
  br i1 %c, label %next, label %if.then

next:
  br i1 %c, label %if.then, label %return

if.then:
  tail call i32 @quux()
  br label %return

return:
  ret i32 %rv
}

define i32 @sink_and_duplicate_for_tailc_illegal_store_between(i1 %c, ptr %p) {
; OPT-LABEL: define i32 @sink_and_duplicate_for_tailc_illegal_store_between(
; OPT-SAME: i1 [[C:%.*]], ptr [[P:%.*]]) {
; OPT-NEXT:  [[ENTRY:.*:]]
; OPT-NEXT:    [[RV:%.*]] = tail call i32 @baz(ptr [[P]], ptr null)
; OPT-NEXT:    store i32 0, ptr [[P]], align 4
; OPT-NEXT:    br i1 [[C]], label %[[IF_THEN:.*]], label %[[RETURN:.*]]
; OPT:       [[IF_THEN]]:
; OPT-NEXT:    [[TMP0:%.*]] = tail call i32 @quux()
; OPT-NEXT:    br label %[[RETURN]]
; OPT:       [[RETURN]]:
; OPT-NEXT:    ret i32 [[RV]]
;
entry:
  %rv = tail call i32 @baz(ptr %p, ptr null)
  store i32 0, ptr %p
  br i1 %c, label %if.then, label %return

if.then:
  tail call i32 @quux()
  br label %return

return:
  ret i32 %rv
}

define i32 @sink_and_duplicate_for_tailc_illegal_excessive_args(i1 %c, i32 %a, i32 %b, i32 %d) {
; OPT-LABEL: define i32 @sink_and_duplicate_for_tailc_illegal_excessive_args(
; OPT-SAME: i1 [[C:%.*]], i32 [[A:%.*]], i32 [[B:%.*]], i32 [[D:%.*]]) {
; OPT-NEXT:  [[ENTRY:.*:]]
; OPT-NEXT:    [[RV:%.*]] = tail call i32 @three_args(i32 [[A]], i32 [[B]], i32 [[D]])
; OPT-NEXT:    br i1 [[C]], label %[[IF_THEN:.*]], label %[[RETURN:.*]]
; OPT:       [[IF_THEN]]:
; OPT-NEXT:    [[TMP0:%.*]] = tail call i32 @quux()
; OPT-NEXT:    br label %[[RETURN]]
; OPT:       [[RETURN]]:
; OPT-NEXT:    ret i32 [[RV]]
;
entry:
  %rv = tail call i32 @three_args(i32 %a, i32 %b, i32 %d)
  br i1 %c, label %if.then, label %return

if.then:
  tail call i32 @quux()
  br label %return

return:
  ret i32 %rv
}

%struct.ByVal = type { [2 x i64] }
define i32 @sink_and_duplicate_for_tailc_illegal_byval(i1 %c, ptr %p) {
; OPT-LABEL: define i32 @sink_and_duplicate_for_tailc_illegal_byval(
; OPT-SAME: i1 [[C:%.*]], ptr [[P:%.*]]) {
; OPT-NEXT:  [[ENTRY:.*:]]
; OPT-NEXT:    [[RV:%.*]] = tail call i32 @func_byval(ptr byval([[STRUCT_BYVAL:%.*]]) [[P]])
; OPT-NEXT:    br i1 [[C]], label %[[IF_THEN:.*]], label %[[RETURN:.*]]
; OPT:       [[IF_THEN]]:
; OPT-NEXT:    [[TMP0:%.*]] = tail call i32 @quux()
; OPT-NEXT:    br label %[[RETURN]]
; OPT:       [[RETURN]]:
; OPT-NEXT:    ret i32 [[RV]]
;
entry:
  %rv = tail call i32 @func_byval(ptr byval(%struct.ByVal) %p)
  br i1 %c, label %if.then, label %return

if.then:
  tail call i32 @quux()
  br label %return

return:
  ret i32 %rv
}

declare i32 @two_args(i32, i32)
declare i32 @three_args(i32, i32, i32)
declare i32 @func_byval(ptr byval(%struct.ByVal))
declare ptr @baz(ptr, ptr)
declare i32 @qux()
declare i32 @quux()
declare { ptr, i32 } @qux_twice()
declare { ptr, i32 } @quux_twice()
