# Restrict the number of instructions per info to 4
# RUN: llc -mtriple=x86_64-pc-windows-msvc -o - %s \
# RUN:    -x86-wineh-unwindv2-instruction-count-threshold=4 \
# RUN:    -run-pass=x86-wineh-unwindv2 | FileCheck %s \
# RUN:    -check-prefixes=ALLOWLESS,CHECK

# Allow the default number of instructions per info
# RUN: llc -mtriple=x86_64-pc-windows-msvc -o - %s \
# RUN:    -run-pass=x86-wineh-unwindv2 | FileCheck %s \
# RUN:    -check-prefixes=ALLOWMORE,CHECK

--- |
  define dso_local void @too_many_instr() local_unnamed_addr !dbg !9 {
  entry:
    ret void, !dbg !10
  }

  !llvm.dbg.cu = !{!0}
  !llvm.module.flags = !{!2, !3, !4, !5}

  !0 = distinct !DICompileUnit(language: DW_LANG_C11, file: !1, producer: "clang", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)
  !1 = !DIFile(filename: "/app/example.c", directory: "/app")
  !2 = !{i32 1, !"winx64-eh-unwindv2", i32 2}
  !3 = !{i32 7, !"Dwarf Version", i32 4}
  !4 = !{i32 2, !"CodeView", i32 1}
  !5 = !{i32 2, !"Debug Info Version", i32 3}
  !6 = !DIFile(filename: "example.c", directory: "/app")
  !7 = !DISubroutineType(types: !8)
  !8 = !{null}
  !9 = distinct !DISubprogram(name: "too_many_instr", scope: !6, file: !6, line: 1, type: !7, scopeLine: 2, spFlags: DISPFlagDefinition, unit: !0)
  !10 = !DILocation(line: 2, column: 1, scope: !9)
  !11 = !DILocation(line: 3, column: 1, scope: !9)
  !12 = !DILocation(line: 4, column: 1, scope: !9)
  !13 = !DILocation(line: 5, column: 1, scope: !9)
...
---
name:            too_many_instr
body:             |
  bb.0.entry:
    frame-setup SEH_EndPrologue
    SEH_BeginEpilogue
    SEH_EndEpilogue
    RET64 debug-location !10
  bb.1:
    $rcx = MOV64rr $rax
    SEH_BeginEpilogue
    SEH_EndEpilogue
    RET64 debug-location !11
  bb.2:
    $rcx = MOV64rr $rax
    SEH_BeginEpilogue
    SEH_EndEpilogue
    RET64 debug-location !12
  bb.3:
    $rcx = MOV64rr $rax
    $rcx = MOV64rr $rax
    $rcx = MOV64rr $rax
    SEH_BeginEpilogue
    SEH_EndEpilogue
    RET64 debug-location !13

...

# CHECK-LABEL: too_many_instr
# CHECK-LABEL:   bb.0.entry:
# bb.1 + bb.2 have enough instructions that bb.0 has its own info.
# ALLOWLESS:      SEH_SplitChainedAtEndOfBlock
# ALLOWMORE-NOT:  SEH_SplitChainedAtEndOfBlock
# CHECK:          SEH_UnwindV2Start
# CHECK:          RET64 debug-location !10

# CHECK-LABEL:   bb.1
# bb.2 doesn't fill the current info, so bb.1 gets added as well.
# CHECK-NOT:      SEH_SplitChainedAtEndOfBlock
# CHECK:          SEH_UnwindV2Start
# CHECK:          RET64 debug-location !DILocation(line: 3, column: 1, scope: !6)

# CHECK-LABEL:   bb.2
# bb.3 has enough instructions by itself that bb.2 needs to split.
# ALLOWLESS-NEXT: SEH_SplitChainedAtEndOfBlock
# ALLOWMORE-NOT:  SEH_SplitChainedAtEndOfBlock
# CHECK:          SEH_UnwindV2Start
# CHECK:          RET64 debug-location !DILocation(line: 4, column: 1, scope: !6)

# CHECK-LABEL:   bb.3
# Never split at the end.
# CHECK-NOT:      SEH_SplitChainedAtEndOfBlock
# CHECK:          SEH_UnwindV2Start
# CHECK:          RET64 debug-location !DILocation(line: 5, column: 1, scope: !6)
