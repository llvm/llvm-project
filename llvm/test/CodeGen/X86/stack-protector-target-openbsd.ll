; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=i386--linux < %s | FileCheck -check-prefix=LINUX32 %s
; RUN: llc -mtriple=x86_64--linux < %s | FileCheck -check-prefix=LINUX64 %s
; RUN: llc -mtriple=i386--openbsd < %s | FileCheck -check-prefix=OPENBSD32 %s
; RUN: llc -mtriple=x86_64--openbsd < %s | FileCheck -check-prefix=OPENBSD64 %s

define void @func() sspreq nounwind {
; LINUX32-LABEL: func:
; LINUX32:       # %bb.0:
; LINUX32-NEXT:    subl $12, %esp
; LINUX32-NEXT:    movl %gs:20, %eax
; LINUX32-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; LINUX32-NEXT:    leal {{[0-9]+}}(%esp), %eax
; LINUX32-NEXT:    movl %eax, (%esp)
; LINUX32-NEXT:    calll capture@PLT
; LINUX32-NEXT:    movl %gs:20, %eax
; LINUX32-NEXT:    cmpl {{[0-9]+}}(%esp), %eax
; LINUX32-NEXT:    jne .LBB0_2
; LINUX32-NEXT:  # %bb.1: # %SP_return
; LINUX32-NEXT:    addl $12, %esp
; LINUX32-NEXT:    retl
; LINUX32-NEXT:  .LBB0_2: # %CallStackCheckFailBlk
; LINUX32-NEXT:    calll __stack_chk_fail@PLT
;
; LINUX64-LABEL: func:
; LINUX64:       # %bb.0:
; LINUX64-NEXT:    subq $24, %rsp
; LINUX64-NEXT:    movq %fs:40, %rax
; LINUX64-NEXT:    movq %rax, {{[0-9]+}}(%rsp)
; LINUX64-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; LINUX64-NEXT:    callq capture@PLT
; LINUX64-NEXT:    movq %fs:40, %rax
; LINUX64-NEXT:    cmpq {{[0-9]+}}(%rsp), %rax
; LINUX64-NEXT:    jne .LBB0_2
; LINUX64-NEXT:  # %bb.1: # %SP_return
; LINUX64-NEXT:    addq $24, %rsp
; LINUX64-NEXT:    retq
; LINUX64-NEXT:  .LBB0_2: # %CallStackCheckFailBlk
; LINUX64-NEXT:    callq __stack_chk_fail@PLT
;
; OPENBSD32-LABEL: func:
; OPENBSD32:       # %bb.0:
; OPENBSD32-NEXT:    subl $8, %esp
; OPENBSD32-NEXT:    movl __guard_local, %eax
; OPENBSD32-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; OPENBSD32-NEXT:    movl %esp, %eax
; OPENBSD32-NEXT:    pushl %eax
; OPENBSD32-NEXT:    calll capture@PLT
; OPENBSD32-NEXT:    addl $4, %esp
; OPENBSD32-NEXT:    movl __guard_local, %eax
; OPENBSD32-NEXT:    cmpl {{[0-9]+}}(%esp), %eax
; OPENBSD32-NEXT:    jne .LBB0_2
; OPENBSD32-NEXT:  # %bb.1: # %SP_return
; OPENBSD32-NEXT:    addl $8, %esp
; OPENBSD32-NEXT:    retl
; OPENBSD32-NEXT:  .LBB0_2: # %CallStackCheckFailBlk
; OPENBSD32-NEXT:    pushl $.LSSH
; OPENBSD32-NEXT:    calll __stack_smash_handler@PLT
;
; OPENBSD64-LABEL: func:
; OPENBSD64:       # %bb.0:
; OPENBSD64-NEXT:    subq $24, %rsp
; OPENBSD64-NEXT:    movq __guard_local(%rip), %rax
; OPENBSD64-NEXT:    movq %rax, {{[0-9]+}}(%rsp)
; OPENBSD64-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; OPENBSD64-NEXT:    callq capture@PLT
; OPENBSD64-NEXT:    movq __guard_local(%rip), %rax
; OPENBSD64-NEXT:    cmpq {{[0-9]+}}(%rsp), %rax
; OPENBSD64-NEXT:    jne .LBB0_2
; OPENBSD64-NEXT:  # %bb.1: # %SP_return
; OPENBSD64-NEXT:    addq $24, %rsp
; OPENBSD64-NEXT:    retq
; OPENBSD64-NEXT:  .LBB0_2: # %CallStackCheckFailBlk
; OPENBSD64-NEXT:    movl $.LSSH, %edi
; OPENBSD64-NEXT:    callq __stack_smash_handler@PLT
  %alloca = alloca i32, align 4
  call void @capture(ptr %alloca)
  ret void
}

declare void @capture(ptr)
