; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc < %s -mtriple=x86_64-pc-linux-gnu | FileCheck %s

; Correctly tracking COPY instructions in peephole should not crash compiler.

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

define void @foo(ptr %p1, ptr %p2, ptr %p3, ptr %p4) {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %rcx, %rax
; CHECK-NEXT:    movl $5, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    movl $5, %r8d
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    cmpl $0, (%rdi)
; CHECK-NEXT:    setle %cl
; CHECK-NEXT:    movl (%rax), %eax
; CHECK-NEXT:    shll %cl, %eax
; CHECK-NEXT:    movl %r8d, (%rdx)
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_1: # %loop2.header
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl $5, %edi
; CHECK-NEXT:    orl %eax, %edi
; CHECK-NEXT:    je .LBB0_1
; CHECK-NEXT:  # %bb.2: # %exit
; CHECK-NEXT:    movl %r8d, (%rdx)
; CHECK-NEXT:    movl %ecx, (%rsi)
; CHECK-NEXT:    retq
entry:
  %q = alloca i32, align 4
  %r = alloca i32, align 4
  store i32 5, ptr %q, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %r)
  %vq1 = load i32, ptr %q, align 4
  %vb = load i32, ptr %p1, align 4
  %cmp3 = icmp slt i32 %vb, 1
  %conv4 = zext i1 %cmp3 to i32
  %va = load i32, ptr %p4, align 4
  %shl5 = shl i32 %va, %conv4
  %vq2 = load i32, ptr %q, align 4
  %cmp = icmp slt i32 %vb, 1
  %conv = zext i1 %cmp to i32
  %shl = shl i32 %va, %conv
  %vq3 = load i32, ptr %q, align 4
  %cmp.us = icmp slt i32 %vb, 1
  %conv.us = zext i1 %cmp.us to i32
  %shl.us = shl i32 %va, %conv.us
  br label %loop2.preheader

loop2.preheader:
  store i32 %vq1, ptr %p3, align 4
  br label %loop2.header

loop2.header:
  %cond1 = icmp eq i32 %vq3, 0
  br i1 %cond1, label %loop2.body, label %exit

loop2.body:
  %cond2 = icmp eq i32 %shl.us, 0
  br i1 %cond2, label %loop2.header, label %exit

exit:
  store i32 %vq2, ptr %p3, align 4
  store i32 %conv.us, ptr %p2, align 4
  ret void
}
