; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=-cmov | FileCheck %s --check-prefix=SECURE
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=-cmov -verify-machineinstrs | FileCheck %s --check-prefix=SECURE

; Verify security properties of i386 CTSELECT post-RA expansion
; This test ensures:
; 1. No conditional branches (jcc instructions) in output
; 2. Both true and false values are always processed
; 3. No conditional memory accesses
; 4. Instructions are bundled for atomic treatment

; Test: No conditional branches should appear in constant-time path
define i32 @test_no_conditional_branches(i32 %secret, i32 %val1, i32 %val2) nounwind {
; SECURE-LABEL: test_no_conditional_branches:
; SECURE:       # %bb.0:
; SECURE-NEXT:    pushl %ebx
; SECURE-NEXT:    pushl %edi
; SECURE-NEXT:    pushl %esi
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %edx
; SECURE-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; SECURE-NEXT:    setne %al
; SECURE-NEXT:    testb %al, %al
; SECURE-NEXT:    BUNDLE
; SECURE-NEXT:    popl %esi
; SECURE-NEXT:    popl %edi
; SECURE-NEXT:    popl %ebx
; SECURE-NEXT:    retl
  %cond = icmp ne i32 %secret, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %val1, i32 %val2)
  ret i32 %result
}

; Test: Both values must always be processed (no conditional loads)
define i32 @test_always_process_both_values(i32 %secret, i32* %ptr1, i32* %ptr2) nounwind {
; SECURE-LABEL: test_always_process_both_values:
; SECURE:       # %bb.0:
; SECURE-NEXT:    pushl %ebx
; SECURE-NEXT:    pushl %edi
; SECURE-NEXT:    pushl %esi
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %eax
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; SECURE-NEXT:    movl (%ecx), %ecx
; SECURE-NEXT:    movl (%eax), %edx
; SECURE-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; SECURE-NEXT:    setne %al
; SECURE-NEXT:    testb %al, %al
; SECURE-NEXT:    BUNDLE
; SECURE-NEXT:    popl %esi
; SECURE-NEXT:    popl %edi
; SECURE-NEXT:    popl %ebx
; SECURE-NEXT:    retl
  %val1 = load i32, i32* %ptr1
  %val2 = load i32, i32* %ptr2
  %cond = icmp ne i32 %secret, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %val1, i32 %val2)
  ret i32 %result
}

; Test: 64-bit constant-time selection on i386
define i64 @test_i64_constant_time(i32 %secret, i64 %val1, i64 %val2) nounwind {
; SECURE-LABEL: test_i64_constant_time:
; SECURE:       # %bb.0:
; SECURE-NEXT:    pushl %ebp
; SECURE-NEXT:    pushl %ebx
; SECURE-NEXT:    pushl %edi
; SECURE-NEXT:    pushl %esi
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %edx
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %edi
; SECURE-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; SECURE-NEXT:    setne %al
; SECURE-NEXT:    testb %al, %al
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %esi
; SECURE-NEXT:    BUNDLE
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %esi
; SECURE-NEXT:    BUNDLE
; SECURE-NEXT:    popl %esi
; SECURE-NEXT:    popl %edi
; SECURE-NEXT:    popl %ebx
; SECURE-NEXT:    popl %ebp
; SECURE-NEXT:    retl
  %cond = icmp ne i32 %secret, 0
  %result = call i64 @llvm.ct.select.i64(i1 %cond, i64 %val1, i64 %val2)
  ret i64 %result
}

; Test: Verify instruction bundling prevents optimization between operations
define i32 @test_bundle_atomicity(i32 %secret, i32 %val1, i32 %val2) nounwind {
; SECURE-LABEL: test_bundle_atomicity:
; SECURE:       # %bb.0:
; SECURE-NEXT:    pushl %ebx
; SECURE-NEXT:    pushl %edi
; SECURE-NEXT:    pushl %esi
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %edx
; SECURE-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; SECURE-NEXT:    setne %al
; SECURE-NEXT:    testb %al, %al
; SECURE-NEXT:    BUNDLE
; SECURE-NEXT:    popl %esi
; SECURE-NEXT:    popl %edi
; SECURE-NEXT:    popl %ebx
; SECURE-NEXT:    retl
  %cond = icmp ne i32 %secret, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %val1, i32 %val2)
  ret i32 %result
}

; Test: Multiple CTSELECT operations should maintain constant-time properties
define i32 @test_multiple_ctselect(i32 %secret1, i32 %secret2, i32 %val1, i32 %val2, i32 %val3, i32 %val4) nounwind {
; SECURE-LABEL: test_multiple_ctselect:
; SECURE:       # %bb.0:
; SECURE-NEXT:    pushl %ebp
; SECURE-NEXT:    pushl %ebx
; SECURE-NEXT:    pushl %edi
; SECURE-NEXT:    pushl %esi
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %eax
; SECURE-NEXT:    movl {{[0-9]+}}(%esp), %edx
; SECURE-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; SECURE-NEXT:    setne %bl
; SECURE-NEXT:    testb %bl, %bl
; SECURE-NEXT:    BUNDLE
; SECURE-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; SECURE-NEXT:    setne %al
; SECURE-NEXT:    testb %al, %al
; SECURE-NEXT:    BUNDLE
; SECURE-NEXT:    popl %esi
; SECURE-NEXT:    popl %edi
; SECURE-NEXT:    popl %ebx
; SECURE-NEXT:    popl %ebp
; SECURE-NEXT:    retl
  %cond1 = icmp ne i32 %secret1, 0
  %tmp = call i32 @llvm.ct.select.i32(i1 %cond1, i32 %val1, i32 %val2)
  %cond2 = icmp ne i32 %secret2, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond2, i32 %tmp, i32 %val3)
  ret i32 %result
}

declare i32 @llvm.ct.select.i32(i1, i32, i32)
declare i64 @llvm.ct.select.i64(i1, i64, i64)
