; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=x86_64 -mattr=+nf -verify-machineinstrs | FileCheck %s

; This is to check no assertion raised in X86 Suppress APX for Relocation pass
; if there is a NF instruction

define fastcc void @foo(i32 %0, i1 %or.cond) nounwind {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r13
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movslq %edi, %r15
; CHECK-NEXT:    leaq (,%r15,4), %rax
; CHECK-NEXT:    leaq (%rax,%rax,4), %r14
; CHECK-NEXT:    movl %r15d, %r12d
; CHECK-NEXT:    xorl %r13d, %r13d
; CHECK-NEXT:    xorl %ebp, %ebp
; CHECK-NEXT:    jmp .LBB0_1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_3: # %if.end41
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    leaq (%r12,%rbp), %rdi
; CHECK-NEXT:    # kill: def $edi killed $edi killed $rdi
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:    movq %r14, %rdx
; CHECK-NEXT:    callq *%r13
; CHECK-NEXT:    incq %rbp
; CHECK-NEXT:    addq $20, %r14
; CHECK-NEXT:  .LBB0_1: # %for.body30
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    testb $1, %bl
; CHECK-NEXT:    je .LBB0_3
; CHECK-NEXT:  # %bb.2: # %if.then37
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    movq %r15, %rax
; CHECK-NEXT:    addq %rbp, %rax
; CHECK-NEXT:    movq 0, %rax
; CHECK-NEXT:    {nf} addq %r15, %rax
; CHECK-NEXT:    movb $0, (%rbp,%rax)
; CHECK-NEXT:    jmp .LBB0_3
entry:
  %1 = sext i32 %0 to i64
  br label %for.body30

for.body30:                                       ; preds = %if.end41, %entry
  %indvars.iv = phi i64 [ %1, %entry ], [ %indvars.iv.next, %if.end41 ]
  %.pre88 = trunc i64 %indvars.iv to i32
  br label %if.end16.i

if.then9.i:                                       ; No predecessors!
  call fastcc void null(ptr null, i32 %.pre88)
  br label %if.end16.i

if.end16.i:                                       ; preds = %if.then9.i, %for.body30
  br i1 %or.cond, label %if.then37, label %if.end41

if.then37:                                        ; preds = %if.end16.i
  %2 = load ptr, ptr null, align 8
  %arrayidx.i = getelementptr i8, ptr %2, i64 %indvars.iv
  store i8 0, ptr %arrayidx.i, align 1
  %3 = icmp eq i64 %indvars.iv, 0
  br i1 %3, label %if.end41, label %if.then.i65

if.then.i65:                                      ; preds = %if.then37
  %arraydecay.i = getelementptr [5 x float], ptr null, i64 %indvars.iv, i64 -5
  %4 = call <5 x float> @llvm.masked.load.v5f32.p0(ptr %arraydecay.i, i32 1, <5 x i1> zeroinitializer, <5 x float> zeroinitializer)
  br label %if.end41

if.end41:                                         ; preds = %if.then.i65, %if.then37, %if.end16.i
  %arraydecay44 = getelementptr [5 x float], ptr null, i64 %indvars.iv, i64 0
  call fastcc void null(i32 %.pre88, i32 0, ptr %arraydecay44)
  %indvars.iv.next = add i64 %indvars.iv, 1
  %cmp29 = icmp slt i64 %indvars.iv, 0
  br label %for.body30
}

declare <5 x float> @llvm.masked.load.v5f32.p0(ptr captures(none), i32 immarg, <5 x i1>, <5 x float>)
