; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+sse2,+ssse3,+egpr  | FileCheck %s --check-prefixes=CHECK,SSE
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+sse2,+ssse3,+egpr,+avx | FileCheck %s --check-prefixes=CHECK,AVX

define i32 @map0(ptr nocapture noundef readonly %a, i64 noundef %b) {
; CHECK-LABEL: map0:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %rsi, %r16
; CHECK-NEXT:    movq %rdi, %r17
; CHECK-NEXT:    #APP
; CHECK-NEXT:    nop
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    movl (%r17,%r16,4), %eax
; CHECK-NEXT:    retq
entry:
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %b
  tail call void asm sideeffect "nop", "~{eax},~{ecx},~{edx},~{esi},~{edi},~{r8},~{r9},~{r10},~{r11}"()
  %0 = load i32, ptr %add.ptr
  ret i32 %0
}

define i32 @map1_or_vex(<2 x double> noundef %a) nounwind {
; SSE-LABEL: map1_or_vex:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    cvtsd2si %xmm0, %r16d
; SSE-NEXT:    #APP
; SSE-NEXT:    nop
; SSE-NEXT:    #NO_APP
; SSE-NEXT:    movl %r16d, %eax
; SSE-NEXT:    retq
;
; AVX-LABEL: map1_or_vex:
; AVX:       # %bb.0: # %entry
; AVX-NEXT:    pushq %rbx
; AVX-NEXT:    vcvtsd2si %xmm0, %ebx
; AVX-NEXT:    #APP
; AVX-NEXT:    nop
; AVX-NEXT:    #NO_APP
; AVX-NEXT:    movl %ebx, %eax
; AVX-NEXT:    popq %rbx
; AVX-NEXT:    retq
entry:
  %0 = tail call i32 @llvm.x86.sse2.cvtsd2si(<2 x double> %a)
  tail call void asm sideeffect "nop", "~{eax},~{ecx},~{edx},~{esi},~{edi},~{r8},~{r9},~{r10},~{r11}"()
  ret i32 %0
}

define <2 x i64> @map2_or_vex(ptr nocapture noundef readonly %b, i64 noundef %c) nounwind {
; SSE-LABEL: map2_or_vex:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    pushq %r14
; SSE-NEXT:    pushq %rbx
; SSE-NEXT:    movq %rsi, %rbx
; SSE-NEXT:    movq %rdi, %r14
; SSE-NEXT:    #APP
; SSE-NEXT:    nop
; SSE-NEXT:    #NO_APP
; SSE-NEXT:    pabsb (%r14,%rbx,4), %xmm0
; SSE-NEXT:    popq %rbx
; SSE-NEXT:    popq %r14
; SSE-NEXT:    retq
;
; AVX-LABEL: map2_or_vex:
; AVX:       # %bb.0: # %entry
; AVX-NEXT:    pushq %r14
; AVX-NEXT:    pushq %rbx
; AVX-NEXT:    movq %rsi, %rbx
; AVX-NEXT:    movq %rdi, %r14
; AVX-NEXT:    #APP
; AVX-NEXT:    nop
; AVX-NEXT:    #NO_APP
; AVX-NEXT:    vpabsb (%r14,%rbx,4), %xmm0
; AVX-NEXT:    popq %rbx
; AVX-NEXT:    popq %r14
; AVX-NEXT:    retq
entry:
  tail call void asm sideeffect "nop", "~{eax},~{ecx},~{edx},~{esi},~{edi},~{r8},~{r9},~{r10},~{r11}"()
  %add.ptr = getelementptr inbounds i32, ptr %b, i64 %c
  %a = load <2 x i64>, ptr %add.ptr
  %0 = bitcast <2 x i64> %a to <16 x i8>
  %elt.abs.i = tail call <16 x i8> @llvm.abs.v16i8(<16 x i8> %0, i1 false)
  %1 = bitcast <16 x i8> %elt.abs.i to <2 x i64>
  ret <2 x i64> %1
}

declare i32 @llvm.x86.sse2.cvtsd2si(<2 x double>)
declare <16 x i8> @llvm.abs.v16i8(<16 x i8>, i1 immarg)
