; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+sse2,+ssse3,+egpr --show-mc-encoding | FileCheck %s --check-prefixes=CHECK,SSE
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+sse2,+ssse3,+egpr,+avx --show-mc-encoding | FileCheck %s --check-prefixes=CHECK,AVX

define i32 @map0(ptr nocapture noundef readonly %a, i64 noundef %b) {
; CHECK-LABEL: map0:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %rsi, %r16 # encoding: [0xd5,0x18,0x89,0xf0]
; CHECK-NEXT:    movq %rdi, %r17 # encoding: [0xd5,0x18,0x89,0xf9]
; CHECK-NEXT:    #APP
; CHECK-NEXT:    nop # encoding: [0x90]
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    movl (%r17,%r16,4), %eax # encoding: [0xd5,0x30,0x8b,0x04,0x81]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %add.ptr = getelementptr inbounds i32, ptr %a, i64 %b
  tail call void asm sideeffect "nop", "~{eax},~{ecx},~{edx},~{esi},~{edi},~{r8},~{r9},~{r10},~{r11}"()
  %0 = load i32, ptr %add.ptr
  ret i32 %0
}

define i32 @map1_or_vex(<2 x double> noundef %a) nounwind {
; SSE-LABEL: map1_or_vex:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    cvtsd2si %xmm0, %r16d # encoding: [0xf2,0xd5,0xc0,0x2d,0xc0]
; SSE-NEXT:    #APP
; SSE-NEXT:    nop # encoding: [0x90]
; SSE-NEXT:    #NO_APP
; SSE-NEXT:    movl %r16d, %eax # encoding: [0xd5,0x40,0x89,0xc0]
; SSE-NEXT:    retq # encoding: [0xc3]
;
; AVX-LABEL: map1_or_vex:
; AVX:       # %bb.0: # %entry
; AVX-NEXT:    pushq %rbx # encoding: [0x53]
; AVX-NEXT:    vcvtsd2si %xmm0, %ebx # encoding: [0xc5,0xfb,0x2d,0xd8]
; AVX-NEXT:    #APP
; AVX-NEXT:    nop # encoding: [0x90]
; AVX-NEXT:    #NO_APP
; AVX-NEXT:    movl %ebx, %eax # encoding: [0x89,0xd8]
; AVX-NEXT:    popq %rbx # encoding: [0x5b]
; AVX-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = tail call i32 @llvm.x86.sse2.cvtsd2si(<2 x double> %a)
  tail call void asm sideeffect "nop", "~{eax},~{ecx},~{edx},~{esi},~{edi},~{r8},~{r9},~{r10},~{r11}"()
  ret i32 %0
}

define <2 x i64> @map2_or_vex(ptr nocapture noundef readonly %b, i64 noundef %c) nounwind {
; SSE-LABEL: map2_or_vex:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    pushq %r14 # encoding: [0x41,0x56]
; SSE-NEXT:    pushq %rbx # encoding: [0x53]
; SSE-NEXT:    movq %rsi, %rbx # encoding: [0x48,0x89,0xf3]
; SSE-NEXT:    movq %rdi, %r14 # encoding: [0x49,0x89,0xfe]
; SSE-NEXT:    #APP
; SSE-NEXT:    nop # encoding: [0x90]
; SSE-NEXT:    #NO_APP
; SSE-NEXT:    pabsb (%r14,%rbx,4), %xmm0 # encoding: [0x66,0x41,0x0f,0x38,0x1c,0x04,0x9e]
; SSE-NEXT:    popq %rbx # encoding: [0x5b]
; SSE-NEXT:    popq %r14 # encoding: [0x41,0x5e]
; SSE-NEXT:    retq # encoding: [0xc3]
;
; AVX-LABEL: map2_or_vex:
; AVX:       # %bb.0: # %entry
; AVX-NEXT:    pushq %r14 # encoding: [0x41,0x56]
; AVX-NEXT:    pushq %rbx # encoding: [0x53]
; AVX-NEXT:    movq %rsi, %rbx # encoding: [0x48,0x89,0xf3]
; AVX-NEXT:    movq %rdi, %r14 # encoding: [0x49,0x89,0xfe]
; AVX-NEXT:    #APP
; AVX-NEXT:    nop # encoding: [0x90]
; AVX-NEXT:    #NO_APP
; AVX-NEXT:    vpabsb (%r14,%rbx,4), %xmm0 # encoding: [0xc4,0xc2,0x79,0x1c,0x04,0x9e]
; AVX-NEXT:    popq %rbx # encoding: [0x5b]
; AVX-NEXT:    popq %r14 # encoding: [0x41,0x5e]
; AVX-NEXT:    retq # encoding: [0xc3]
entry:
  tail call void asm sideeffect "nop", "~{eax},~{ecx},~{edx},~{esi},~{edi},~{r8},~{r9},~{r10},~{r11}"()
  %add.ptr = getelementptr inbounds i32, ptr %b, i64 %c
  %a = load <2 x i64>, ptr %add.ptr
  %0 = bitcast <2 x i64> %a to <16 x i8>
  %elt.abs.i = tail call <16 x i8> @llvm.abs.v16i8(<16 x i8> %0, i1 false)
  %1 = bitcast <16 x i8> %elt.abs.i to <2 x i64>
  ret <2 x i64> %1
}

declare i32 @llvm.x86.sse2.cvtsd2si(<2 x double>)
declare <16 x i8> @llvm.abs.v16i8(<16 x i8>, i1 immarg)
