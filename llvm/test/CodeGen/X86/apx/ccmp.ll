; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ccmp -verify-machineinstrs | FileCheck %s
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ccmp,+ndd -verify-machineinstrs | FileCheck %s --check-prefix=NDD

define void @ccmp8rr_zf(i8 noundef %a, i8 noundef %b, i8 noundef %c) {
; CHECK-LABEL: ccmp8rr_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %dl, %dil
; CHECK-NEXT:    ccmpneb {dfv=zf} %dl, %sil
; CHECK-NEXT:    jne .LBB0_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB0_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8rr_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %dl, %dil
; NDD-NEXT:    ccmpneb {dfv=zf} %dl, %sil
; NDD-NEXT:    jne .LBB0_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB0_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp eq i8 %a, %c
  %cmp1 = icmp eq i8 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp8rr_cf(i8 noundef %a, i8 noundef %b) {
; CHECK-LABEL: ccmp8rr_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb $2, %dil
; CHECK-NEXT:    ccmpgeb {dfv=cf} $2, %sil
; CHECK-NEXT:    jb .LBB1_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB1_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8rr_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb $2, %dil
; NDD-NEXT:    ccmpgeb {dfv=cf} $2, %sil
; NDD-NEXT:    jb .LBB1_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB1_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp sgt i8 %a, 1
  %tobool = icmp ugt i8 %b, 1
  %or.cond = and i1 %cmp, %tobool
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

define i8 @ccmp8rr_sf(i8 %a, i8 %b, i8* nocapture %c)  {
; CHECK-LABEL: ccmp8rr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testb %dil, %dil
; CHECK-NEXT:    ccmpneb {dfv=sf} $2, %sil
; CHECK-NEXT:    jl .LBB2_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rdx)
; CHECK-NEXT:  .LBB2_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8rr_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    testb %dil, %dil
; NDD-NEXT:    ccmpneb {dfv=sf} $2, %sil
; NDD-NEXT:    jl .LBB2_2
; NDD-NEXT:  # %bb.1: # %if.then
; NDD-NEXT:    movb %dil, (%rdx)
; NDD-NEXT:  .LBB2_2: # %if.end
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    retq
entry:
  %tobool = icmp ne i8 %a, 0
  %cmp = icmp sgt i8 %b, 1
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:
  ret i8 0
}

define i8 @ccmp8rr_none(i8 %a, i8 %b, i8* nocapture %c)  {
; CHECK-LABEL: ccmp8rr_none:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testb %dil, %dil
; CHECK-NEXT:    ccmpeb {dfv=} $2, %sil
; CHECK-NEXT:    jl .LBB3_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rdx)
; CHECK-NEXT:  .LBB3_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8rr_none:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    testb %dil, %dil
; NDD-NEXT:    ccmpeb {dfv=} $2, %sil
; NDD-NEXT:    jl .LBB3_2
; NDD-NEXT:  # %bb.1: # %if.then
; NDD-NEXT:    movb %dil, (%rdx)
; NDD-NEXT:  .LBB3_2: # %if.end
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    retq
entry:
  %tobool = icmp ne i8 %a, 0
  %cmp = icmp sgt i8 %b, 1
  %or.cond = select i1 %tobool, i1 true, i1 %cmp
  br i1 %or.cond, label %if.then, label %if.end

if.then:
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:
  ret i8 0
}

define void @ccmp16rr_sf(i16 noundef %a, i16 noundef %b, i16 noundef %c) {
; CHECK-LABEL: ccmp16rr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %dx, %di
; CHECK-NEXT:    ccmplew {dfv=sf} %dx, %si
; CHECK-NEXT:    jge .LBB4_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB4_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp16rr_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %dx, %di
; NDD-NEXT:    ccmplew {dfv=sf} %dx, %si
; NDD-NEXT:    jge .LBB4_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB4_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32rr_cf(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp32rr_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi
; CHECK-NEXT:    ccmpbl {dfv=cf} %edx, %esi
; CHECK-NEXT:    ja .LBB5_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB5_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp32rr_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %edx, %edi
; NDD-NEXT:    ccmpbl {dfv=cf} %edx, %esi
; NDD-NEXT:    ja .LBB5_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB5_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp uge i32 %a, %c
  %cmp1 = icmp ule i32 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64rr_of(i64 %a, i64 %b, i64 %c) {
; CHECK-LABEL: ccmp64rr_of:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    cmpq %rdx, %rdi
; CHECK-NEXT:    ccmpbq {dfv=of} %rsi, %rdi
; CHECK-NEXT:    jno .LBB6_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB6_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp64rr_of:
; NDD:       # %bb.0: # %bb
; NDD-NEXT:    cmpq %rdx, %rdi
; NDD-NEXT:    ccmpbq {dfv=of} %rsi, %rdi
; NDD-NEXT:    jno .LBB6_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB6_1: # %if.end
; NDD-NEXT:    retq
bb:
  %cmp = icmp uge i64 %a, %c
  %smul = call {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)
  %obit = extractvalue {i64, i1} %smul, 1
  %or.cond = or i1 %cmp, %obit
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64rr_of_crossbb(i64 %a, i64 %b) {
; CHECK-LABEL: ccmp64rr_of_crossbb:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testq %rdi, %rdi
; CHECK-NEXT:    je .LBB7_2
; CHECK-NEXT:  # %bb.1: # %bb1
; CHECK-NEXT:    cmpq %rsi, %rdi
; CHECK-NEXT:  .LBB7_2: # %bb3
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp64rr_of_crossbb:
; NDD:       # %bb.0: # %bb
; NDD-NEXT:    testq %rdi, %rdi
; NDD-NEXT:    je .LBB7_2
; NDD-NEXT:  # %bb.1: # %bb1
; NDD-NEXT:    cmpq %rsi, %rdi
; NDD-NEXT:  .LBB7_2: # %bb3
; NDD-NEXT:    retq
bb:
  %cond1 = icmp eq i64 %a, 0
  br i1 %cond1, label %bb3, label %bb1

bb1:                                              ; preds = %bb
  %smul = call {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)
  %obit = extractvalue {i64, i1} %smul, 1
  br i1 %obit, label %bb3, label %bb2

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ccmp8ri_zf(i8 noundef %a, i8 noundef %b, i8 noundef %c) {
; CHECK-LABEL: ccmp8ri_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %dl, %dil
; CHECK-NEXT:    ccmpleb {dfv=zf} $123, %sil
; CHECK-NEXT:    jne .LBB8_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB8_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8ri_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %dl, %dil
; NDD-NEXT:    ccmpleb {dfv=zf} $123, %sil
; NDD-NEXT:    jne .LBB8_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB8_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp sgt i8 %a, %c
  %cmp1 = icmp eq i8 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define i8 @ccmp8ri_zf_double(i8 %a, double %b, i8* nocapture %c)  {
; CHECK-LABEL: ccmp8ri_zf_double:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorpd %xmm1, %xmm1
; CHECK-NEXT:    ucomisd %xmm1, %xmm0
; CHECK-NEXT:    ccmpeb {dfv=zf} $123, %dil
; CHECK-NEXT:    je .LBB9_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rsi)
; CHECK-NEXT:  .LBB9_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8ri_zf_double:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    xorpd %xmm1, %xmm1
; NDD-NEXT:    ucomisd %xmm1, %xmm0
; NDD-NEXT:    ccmpeb {dfv=zf} $123, %dil
; NDD-NEXT:    je .LBB9_2
; NDD-NEXT:  # %bb.1: # %if.then
; NDD-NEXT:    movb %dil, (%rsi)
; NDD-NEXT:  .LBB9_2: # %if.end
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    retq
entry:
  %tobool = icmp ne i8 %a, 123
  %cmp = fcmp ueq double %b, 0.0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:
  ret i8 0
}

define i8 @ccmp8ri_zf_double_p(i8 %a, double %b, i8* nocapture %c)  {
; CHECK-LABEL: ccmp8ri_zf_double_p:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb $123, %dil
; CHECK-NEXT:    setne %al
; CHECK-NEXT:    ucomisd %xmm0, %xmm0
; CHECK-NEXT:    setp %cl
; CHECK-NEXT:    andb %al, %cl
; CHECK-NEXT:    cmpb $1, %cl
; CHECK-NEXT:    jne .LBB10_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rsi)
; CHECK-NEXT:  .LBB10_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8ri_zf_double_p:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb $123, %dil
; NDD-NEXT:    setne %al
; NDD-NEXT:    ucomisd %xmm0, %xmm0
; NDD-NEXT:    setp %cl
; NDD-NEXT:    andb %cl, %al
; NDD-NEXT:    cmpb $1, %al
; NDD-NEXT:    jne .LBB10_2
; NDD-NEXT:  # %bb.1: # %if.then
; NDD-NEXT:    movb %dil, (%rsi)
; NDD-NEXT:  .LBB10_2: # %if.end
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    retq
entry:
  %tobool = icmp ne i8 %a, 123
  %cmp = fcmp uno double %b, 0.0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:
  ret i8 0
}

define i8 @ccmp8ri_zf_double_np(i8 %a, double %b, i8* nocapture %c)  {
; CHECK-LABEL: ccmp8ri_zf_double_np:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb $123, %dil
; CHECK-NEXT:    setne %al
; CHECK-NEXT:    ucomisd %xmm0, %xmm0
; CHECK-NEXT:    setnp %cl
; CHECK-NEXT:    andb %al, %cl
; CHECK-NEXT:    cmpb $1, %cl
; CHECK-NEXT:    jne .LBB11_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rsi)
; CHECK-NEXT:  .LBB11_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8ri_zf_double_np:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb $123, %dil
; NDD-NEXT:    setne %al
; NDD-NEXT:    ucomisd %xmm0, %xmm0
; NDD-NEXT:    setnp %cl
; NDD-NEXT:    andb %cl, %al
; NDD-NEXT:    cmpb $1, %al
; NDD-NEXT:    jne .LBB11_2
; NDD-NEXT:  # %bb.1: # %if.then
; NDD-NEXT:    movb %dil, (%rsi)
; NDD-NEXT:  .LBB11_2: # %if.end
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    retq
entry:
  %tobool = icmp ne i8 %a, 123
  %cmp = fcmp ord double %b, 0.0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:
  ret i8 0
}

define void @ccmp16ri_zf(i16 noundef %a, i16 noundef %b, i16 noundef %c) {
; CHECK-LABEL: ccmp16ri_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %dx, %di
; CHECK-NEXT:    movswl %si, %eax
; CHECK-NEXT:    ccmpael {dfv=sf} $1234, %eax # imm = 0x4D2
; CHECK-NEXT:    jge .LBB12_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB12_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp16ri_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %dx, %di
; NDD-NEXT:    movswl %si, %eax
; NDD-NEXT:    ccmpael {dfv=sf} $1234, %eax # imm = 0x4D2
; NDD-NEXT:    jge .LBB12_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB12_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp ult i16 %a, %c
  %cmp1 = icmp slt i16 %b, 1234
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32ri_cf(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp32ri_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi
; CHECK-NEXT:    ccmpbl {dfv=cf} $123457, %esi # imm = 0x1E241
; CHECK-NEXT:    jae .LBB13_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB13_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp32ri_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %edx, %edi
; NDD-NEXT:    ccmpbl {dfv=cf} $123457, %esi # imm = 0x1E241
; NDD-NEXT:    jae .LBB13_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB13_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp uge i32 %a, %c
  %cmp1 = icmp ule i32 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64ri32_zf(i64 noundef %a, i64 noundef %b, i64 noundef %c) {
; CHECK-LABEL: ccmp64ri32_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rdx, %rdi
; CHECK-NEXT:    ccmpbeq {dfv=sf} $123456, %rsi # imm = 0x1E240
; CHECK-NEXT:    jge .LBB14_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB14_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp64ri32_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rdx, %rdi
; NDD-NEXT:    ccmpbeq {dfv=sf} $123456, %rsi # imm = 0x1E240
; NDD-NEXT:    jge .LBB14_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB14_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp ugt i64 %a, %c
  %cmp1 = icmp slt i64 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp8rm_zf(i8 noundef %a, i8 noundef %b, i8 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp8rm_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %dl, %dil
; CHECK-NEXT:    ccmpneb {dfv=zf} (%rcx), %sil
; CHECK-NEXT:    jne .LBB15_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB15_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8rm_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %dl, %dil
; NDD-NEXT:    ccmpneb {dfv=zf} (%rcx), %sil
; NDD-NEXT:    jne .LBB15_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB15_1: # %if.end
; NDD-NEXT:    retq
entry:
  %d = load i8, ptr %ptr
  %cmp = icmp eq i8 %a, %c
  %cmp1 = icmp eq i8 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16rm_sf(i16 noundef %a, i16 noundef %b, i16 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp16rm_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %dx, %di
; CHECK-NEXT:    ccmplew {dfv=sf} (%rcx), %si
; CHECK-NEXT:    jge .LBB16_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB16_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp16rm_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %dx, %di
; NDD-NEXT:    ccmplew {dfv=sf} (%rcx), %si
; NDD-NEXT:    jge .LBB16_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB16_1: # %if.end
; NDD-NEXT:    retq
entry:
  %d = load i16, ptr %ptr
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32rm_cf(i32 noundef %a, i32 noundef %b, i32 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp32rm_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi
; CHECK-NEXT:    ccmpgl {dfv=cf} (%rcx), %esi
; CHECK-NEXT:    ja .LBB17_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB17_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp32rm_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %edx, %edi
; NDD-NEXT:    ccmpgl {dfv=cf} (%rcx), %esi
; NDD-NEXT:    ja .LBB17_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB17_1: # %if.end
; NDD-NEXT:    retq
entry:
  %d = load i32, ptr %ptr
  %cmp = icmp sle i32 %a, %c
  %cmp1 = icmp ule i32 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64rm_sf(i64 noundef %a, i64 noundef %b, i64 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp64rm_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rdx, %rdi
; CHECK-NEXT:    ccmpleq {dfv=sf} (%rcx), %rsi
; CHECK-NEXT:    jge .LBB18_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB18_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp64rm_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rdx, %rdi
; NDD-NEXT:    ccmpleq {dfv=sf} (%rcx), %rsi
; NDD-NEXT:    jge .LBB18_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB18_1: # %if.end
; NDD-NEXT:    retq
entry:
  %d = load i64, ptr %ptr
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp8mr_zf(i8 noundef %a, i8 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp8mr_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %sil, %dil
; CHECK-NEXT:    ccmpgeb {dfv=zf} %sil, (%rdx)
; CHECK-NEXT:    jne .LBB19_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB19_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8mr_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %sil, %dil
; NDD-NEXT:    ccmpgeb {dfv=zf} %sil, (%rdx)
; NDD-NEXT:    jne .LBB19_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB19_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i8, ptr %ptr
  %cmp = icmp slt i8 %a, %c
  %cmp1 = icmp eq i8 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16mr_sf(i16 noundef %a, i16 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp16mr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %si, %di
; CHECK-NEXT:    ccmplew {dfv=sf} %si, (%rdx)
; CHECK-NEXT:    jge .LBB20_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB20_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp16mr_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %si, %di
; NDD-NEXT:    ccmplew {dfv=sf} %si, (%rdx)
; NDD-NEXT:    jge .LBB20_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB20_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i16, ptr %ptr
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32mr_cf(i32 noundef %a, i32 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp32mr_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %esi, %edi
; CHECK-NEXT:    ccmpll {dfv=cf} %esi, (%rdx)
; CHECK-NEXT:    ja .LBB21_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB21_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp32mr_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %esi, %edi
; NDD-NEXT:    ccmpll {dfv=cf} %esi, (%rdx)
; NDD-NEXT:    ja .LBB21_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB21_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i32, ptr %ptr
  %cmp = icmp sge i32 %a, %c
  %cmp1 = icmp ule i32 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64mr_sf(i64 noundef %a, i64 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp64mr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rsi, %rdi
; CHECK-NEXT:    ccmpleq {dfv=sf} %rsi, (%rdx)
; CHECK-NEXT:    jge .LBB22_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB22_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp64mr_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rsi, %rdi
; NDD-NEXT:    ccmpleq {dfv=sf} %rsi, (%rdx)
; NDD-NEXT:    jge .LBB22_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB22_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i64, ptr %ptr
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp8mi_zf(i8 noundef %a, i8 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp8mi_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %sil, %dil
; CHECK-NEXT:    ccmpneb {dfv=zf} $123, (%rdx)
; CHECK-NEXT:    jne .LBB23_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB23_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp8mi_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %sil, %dil
; NDD-NEXT:    ccmpneb {dfv=zf} $123, (%rdx)
; NDD-NEXT:    jne .LBB23_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB23_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i8, ptr %ptr
  %cmp = icmp eq i8 %a, %c
  %cmp1 = icmp eq i8 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16mi_zf(i16 noundef %a, i16 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp16mi_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %si, %di
; CHECK-NEXT:    ccmplew {dfv=sf} $1234, (%rdx) # imm = 0x4D2
; CHECK-NEXT:    jge .LBB24_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB24_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp16mi_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %si, %di
; NDD-NEXT:    ccmplew {dfv=sf} $1234, (%rdx) # imm = 0x4D2
; NDD-NEXT:    jge .LBB24_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB24_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i16, ptr %ptr
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, 1234
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32mi_cf(i32 noundef %a, i32 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp32mi_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %esi, %edi
; CHECK-NEXT:    ccmpnel {dfv=cf} $123457, (%rdx) # imm = 0x1E241
; CHECK-NEXT:    jae .LBB25_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB25_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp32mi_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %esi, %edi
; NDD-NEXT:    ccmpnel {dfv=cf} $123457, (%rdx) # imm = 0x1E241
; NDD-NEXT:    jae .LBB25_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB25_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i32, ptr %ptr
  %cmp = icmp eq i32 %a, %c
  %cmp1 = icmp ule i32 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64mi32_zf(i64 noundef %a, i64 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp64mi32_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rsi, %rdi
; CHECK-NEXT:    ccmpleq {dfv=sf} $123456, (%rdx) # imm = 0x1E240
; CHECK-NEXT:    jge .LBB26_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB26_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp64mi32_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rsi, %rdi
; NDD-NEXT:    ccmpleq {dfv=sf} $123456, (%rdx) # imm = 0x1E240
; NDD-NEXT:    jge .LBB26_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB26_1: # %if.end
; NDD-NEXT:    retq
entry:
  %b = load i64, ptr %ptr
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp_continous(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp_continous:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    ccmplel {dfv=} $2, %esi
; CHECK-NEXT:    ccmpll {dfv=} $3, %edx
; CHECK-NEXT:    jge .LBB27_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB27_1: # %if.end
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp_continous:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    testl %edi, %edi
; NDD-NEXT:    ccmplel {dfv=} $2, %esi
; NDD-NEXT:    ccmpll {dfv=} $3, %edx
; NDD-NEXT:    jge .LBB27_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:  .LBB27_1: # %if.end
; NDD-NEXT:    retq
entry:
  %cmp = icmp slt i32 %a, 1
  %cmp1 = icmp slt i32 %b, 2
  %or.cond = and i1 %cmp, %cmp1
  %cmp3 = icmp slt i32 %c, 3
  %or.cond4 = and i1 %or.cond, %cmp3
  br i1 %or.cond4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

define i32 @ccmp_nobranch(i32 noundef %a, i32 noundef %b) {
; CHECK-LABEL: ccmp_nobranch:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    ccmplel {dfv=} $2, %esi
; CHECK-NEXT:    setge %al
; CHECK-NEXT:    movzbl %al, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp_nobranch:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    testl %edi, %edi
; NDD-NEXT:    ccmplel {dfv=} $2, %esi
; NDD-NEXT:    setge %al
; NDD-NEXT:    movzbl %al, %eax
; NDD-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 0
  %cmp1 = icmp sgt i32 %b, 1
  %or.cond.not = or i1 %cmp, %cmp1
  %. = zext i1 %or.cond.not to i32
  ret i32 %.
}

define i32 @ccmp_continous_nobranch(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp_continous_nobranch:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $2, %edi
; CHECK-NEXT:    ccmpll {dfv=sf} $2, %esi
; CHECK-NEXT:    ccmpll {dfv=sf} $4, %edx
; CHECK-NEXT:    setge %al
; CHECK-NEXT:    movzbl %al, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: ccmp_continous_nobranch:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl $2, %edi
; NDD-NEXT:    ccmpll {dfv=sf} $2, %esi
; NDD-NEXT:    ccmpll {dfv=sf} $4, %edx
; NDD-NEXT:    setge %al
; NDD-NEXT:    movzbl %al, %eax
; NDD-NEXT:    retq
entry:
  %cmp = icmp sgt i32 %a, 1
  %cmp1 = icmp slt i32 %b, 2
  %cmp2 = icmp sgt i32 %c, 3
  %or1 = or i1 %cmp, %cmp1
  %or2 =  and i1 %or1, %cmp2
  %. = zext i1 %or2 to i32
  ret i32 %.
}

declare dso_local void @foo(...)
declare {i64, i1} @llvm.ssub.with.overflow.i64(i64, i64) nounwind readnone
