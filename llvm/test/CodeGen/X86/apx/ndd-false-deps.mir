# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc %s -mtriple=x86_64-unknown -mattr=+ndd,+egpr -run-pass=break-false-deps -verify-machineinstrs -o - | FileCheck --check-prefixes=CHECK,RCDEFAULT %s
# RUN: llc %s -mtriple=x86_64-unknown -mattr=+ndd,+egpr -run-pass=break-false-deps -partial-reg-update-clearance=1 -verify-machineinstrs -o - | FileCheck --check-prefixes=CHECK,RC1 %s
#
# Check that BreakFalseDeps detects cases where an ND instruction would cause a partial register write
# if compressed to a legacy op. MIR has been modified to force different register assignments.
#
# For partial_write, the ADD16rr_ND is compressible, but will become a partial write after compression.
# Compression is inhibited if the eax definition is within the partial-reg-update-clearance threshold.
#
# For no_partial_write, the ADD16rr_ND is incompressible hence it cannot become a partial write.
# This case checks that an implicit-def of eax is not added by breakPartialRegDependency.
#
--- |
  define signext i16 @partial_write(ptr %p, i32 %a, i32 %b, i16 signext %x, i16 signext %y) #0 {
  entry:
    %add = add nsw i32 %b, %a
    store i32 %add, ptr %p, align 4
    %add1 = trunc i32 %add to i16
    %add2 = add i16 %add1, %x
    ret i16 %add2
  }

  define signext i16 @no_partial_write(ptr %p, i32 %a, i32 %b, i16 signext %x, i16 signext %y) #0 {
  entry:
    %add = add nsw i32 %b, %a
    store i32 %add, ptr %p, align 4
    %add1 = trunc i32 %add to i16
    %add2 = add i16 %add1, %x
    ret i16 %add2
  }
  attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+egpr,+fxsr,+mmx,+ndd,+sse,+sse2,+x87" "tune-cpu"="generic" }
...
---
name:            partial_write
tracksRegLiveness: true
noVRegs:         true
noPhis:          true
isSSA:           false
body:             |
  bb.0.entry:
    liveins: $ecx, $edx, $esi, $rdi
    ; RCDEFAULT-LABEL: name: partial_write
    ; RCDEFAULT: liveins: $ecx, $edx, $esi, $rdi
    ; RCDEFAULT-NEXT: {{  $}}
    ; RCDEFAULT-NEXT: renamable $eax = nsw ADD32rr_ND killed renamable $edx, killed renamable $esi, implicit-def dead $eflags
    ; RCDEFAULT-NEXT: MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, renamable $eax :: (store (s32) into %ir.p)
    ; RCDEFAULT-NEXT: renamable $ax = ADD16rr_ND renamable $ax, renamable $cx, implicit-def dead $eflags, implicit killed $ecx, implicit $eax, implicit-def $rax
    ; RCDEFAULT-NEXT: RET64 $ax
    ;
    ; RC1-LABEL: name: partial_write
    ; RC1: liveins: $ecx, $edx, $esi, $rdi
    ; RC1-NEXT: {{  $}}
    ; RC1-NEXT: renamable $eax = nsw ADD32rr_ND killed renamable $edx, killed renamable $esi, implicit-def dead $eflags
    ; RC1-NEXT: MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, renamable $eax :: (store (s32) into %ir.p)
    ; RC1-NEXT: renamable $ax = ADD16rr_ND renamable $ax, renamable $cx, implicit-def dead $eflags, implicit killed $ecx, implicit $eax
    ; RC1-NEXT: RET64 $ax
    renamable $eax = nsw ADD32rr_ND killed renamable $edx, killed renamable $esi, implicit-def dead $eflags
    MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, renamable $eax :: (store (s32) into %ir.p)
    renamable $ax = ADD16rr_ND renamable $ax, renamable $cx, implicit-def dead $eflags, implicit killed $ecx, implicit $eax
    RET64 $ax
...
---
name:            no_partial_write
tracksRegLiveness: true
noVRegs:         true
noPhis:          true
isSSA:           false
body:             |
  bb.0.entry:
    liveins: $ecx, $edx, $esi, $rdi

    ; CHECK-LABEL: name: no_partial_write
    ; CHECK: liveins: $ecx, $edx, $esi, $rdi
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: renamable $edx = nsw ADD32rr_ND killed renamable $edx, killed renamable $esi, implicit-def dead $eflags
    ; CHECK-NEXT: MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, renamable $edx :: (store (s32) into %ir.p)
    ; CHECK-NEXT: renamable $ax = ADD16rr_ND renamable $dx, renamable $cx, implicit-def dead $eflags, implicit killed $ecx, implicit killed $edx
    ; CHECK-NEXT: RET64 $ax
    renamable $edx = nsw ADD32rr_ND killed renamable $edx, killed renamable $esi, implicit-def dead $eflags
    MOV32mr killed renamable $rdi, 1, $noreg, 0, $noreg, renamable $edx :: (store (s32) into %ir.p)
    renamable $ax = ADD16rr_ND renamable $dx, renamable $cx, implicit-def dead $eflags, implicit killed $ecx, implicit killed $edx
    RET64 $ax
...
