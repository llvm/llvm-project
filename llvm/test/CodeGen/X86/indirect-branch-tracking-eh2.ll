; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple x86_64-unknown-unknown -exception-model sjlj -verify-machineinstrs=0 < %s | FileCheck %s --check-prefix=NUM
; RUN: llc -mtriple x86_64-unknown-unknown -exception-model sjlj -verify-machineinstrs=0 < %s | FileCheck %s --check-prefix=SJLJ

@_ZTIi = external dso_local constant i8*
@_ZTIc = external dso_local constant i8*

; Function Attrs: noinline norecurse optnone uwtable
define dso_local i32 @main() #0 personality i8* bitcast (i32 (...)* @__gxx_personality_sj0 to i8*) {
; NUM-LABEL: main:
; NUM:       # %bb.0: # %entry
; NUM-NEXT:    endbr64
; NUM-NEXT:    pushq %rbp
; NUM-NEXT:    movq %rsp, %rbp
; NUM-NEXT:    pushq %r15
; NUM-NEXT:    pushq %r14
; NUM-NEXT:    pushq %r13
; NUM-NEXT:    pushq %r12
; NUM-NEXT:    pushq %rbx
; NUM-NEXT:    subq $120, %rsp
; NUM-NEXT:    movl $0, -44(%rbp)
; NUM-NEXT:    movq $__gxx_personality_sj0, -120(%rbp)
; NUM-NEXT:    movq $GCC_except_table0, -112(%rbp)
; NUM-NEXT:    movq %rbp, -104(%rbp)
; NUM-NEXT:    movq %rsp, -88(%rbp)
; NUM-NEXT:    movq $.LBB0_9, -96(%rbp)
; NUM-NEXT:    movl $1, -144(%rbp)
; NUM-NEXT:    leaq -152(%rbp), %rdi
; NUM-NEXT:    callq _Unwind_SjLj_Register
; NUM-NEXT:  .Ltmp0:
; NUM-NEXT:    callq _Z3foov
; NUM-NEXT:  .Ltmp1:
; NUM-NEXT:  # %bb.1: # %invoke.cont
; NUM-NEXT:    movl $1, -44(%rbp)
; NUM-NEXT:  .LBB0_7: # %return
; NUM-NEXT:    movl -44(%rbp), %ebx
; NUM-NEXT:    leaq -152(%rbp), %rdi
; NUM-NEXT:    callq _Unwind_SjLj_Unregister
; NUM-NEXT:    movl %ebx, %eax
; NUM-NEXT:    addq $120, %rsp
; NUM-NEXT:    popq %rbx
; NUM-NEXT:    popq %r12
; NUM-NEXT:    popq %r13
; NUM-NEXT:    popq %r14
; NUM-NEXT:    popq %r15
; NUM-NEXT:    popq %rbp
; NUM-NEXT:    retq
; NUM-NEXT:  .LBB0_9:
; NUM-NEXT:    endbr64
; NUM-NEXT:    movl -144(%rbp), %eax
; NUM-NEXT:    cmpl $1, %eax
; NUM-NEXT:    jb .LBB0_10
; NUM-NEXT:  # %bb.11:
; NUM-NEXT:    ud2
; NUM-NEXT:  .LBB0_10:
; NUM-NEXT:    leaq {{.*}}(%rip), %rcx
; NUM-NEXT:    jmpq *(%rcx,%rax,8)
; NUM-NEXT:  .LBB0_2: # %lpad
; NUM-NEXT:  .Ltmp2:
; NUM-NEXT:    endbr64
; NUM-NEXT:    movl -140(%rbp), %ecx
; NUM-NEXT:    movl -136(%rbp), %eax
; NUM-NEXT:    movq %rcx, -56(%rbp)
; NUM-NEXT:    movl %eax, -64(%rbp)
; NUM-NEXT:    cmpl $2, %eax
; NUM-NEXT:    je .LBB0_3
; NUM-NEXT:  # %bb.4: # %catch.fallthrough
; NUM-NEXT:    cmpl $1, %eax
; NUM-NEXT:    jne .LBB0_8
; NUM-NEXT:  # %bb.5: # %catch
; NUM-NEXT:    movq -56(%rbp), %rdi
; NUM-NEXT:    movl $-1, -144(%rbp)
; NUM-NEXT:    callq __cxa_begin_catch
; NUM-NEXT:    movb (%rax), %al
; NUM-NEXT:    movb %al, -45(%rbp)
; NUM-NEXT:    xorl %ecx, %ecx
; NUM-NEXT:    cmpb $3, %al
; NUM-NEXT:    jmp .LBB0_6
; NUM-NEXT:  .LBB0_3: # %catch3
; NUM-NEXT:    movq -56(%rbp), %rdi
; NUM-NEXT:    movl $-1, -144(%rbp)
; NUM-NEXT:    callq __cxa_begin_catch
; NUM-NEXT:    movl (%rax), %eax
; NUM-NEXT:    movl %eax, -60(%rbp)
; NUM-NEXT:    xorl %ecx, %ecx
; NUM-NEXT:    cmpl $5, %eax
; NUM-NEXT:  .LBB0_6: # %return
; NUM-NEXT:    setne %cl
; NUM-NEXT:    movl %ecx, -44(%rbp)
; NUM-NEXT:    movl $-1, -144(%rbp)
; NUM-NEXT:    callq __cxa_end_catch
; NUM-NEXT:    jmp .LBB0_7
; NUM-NEXT:  .LBB0_8: # %eh.resume
; NUM-NEXT:    movl $-1, -144(%rbp)
;
; SJLJ-LABEL: main:
; SJLJ:       # %bb.0: # %entry
; SJLJ-NEXT:    endbr64
; SJLJ-NEXT:    pushq %rbp
; SJLJ-NEXT:    movq %rsp, %rbp
; SJLJ-NEXT:    pushq %r15
; SJLJ-NEXT:    pushq %r14
; SJLJ-NEXT:    pushq %r13
; SJLJ-NEXT:    pushq %r12
; SJLJ-NEXT:    pushq %rbx
; SJLJ-NEXT:    subq $120, %rsp
; SJLJ-NEXT:    movl $0, -44(%rbp)
; SJLJ-NEXT:    movq $__gxx_personality_sj0, -120(%rbp)
; SJLJ-NEXT:    movq $GCC_except_table0, -112(%rbp)
; SJLJ-NEXT:    movq %rbp, -104(%rbp)
; SJLJ-NEXT:    movq %rsp, -88(%rbp)
; SJLJ-NEXT:    movq $.LBB0_9, -96(%rbp)
; SJLJ-NEXT:    movl $1, -144(%rbp)
; SJLJ-NEXT:    leaq -152(%rbp), %rdi
; SJLJ-NEXT:    callq _Unwind_SjLj_Register
; SJLJ-NEXT:  .Ltmp0:
; SJLJ-NEXT:    callq _Z3foov
; SJLJ-NEXT:  .Ltmp1:
; SJLJ-NEXT:  # %bb.1: # %invoke.cont
; SJLJ-NEXT:    movl $1, -44(%rbp)
; SJLJ-NEXT:  .LBB0_7: # %return
; SJLJ-NEXT:    movl -44(%rbp), %ebx
; SJLJ-NEXT:    leaq -152(%rbp), %rdi
; SJLJ-NEXT:    callq _Unwind_SjLj_Unregister
; SJLJ-NEXT:    movl %ebx, %eax
; SJLJ-NEXT:    addq $120, %rsp
; SJLJ-NEXT:    popq %rbx
; SJLJ-NEXT:    popq %r12
; SJLJ-NEXT:    popq %r13
; SJLJ-NEXT:    popq %r14
; SJLJ-NEXT:    popq %r15
; SJLJ-NEXT:    popq %rbp
; SJLJ-NEXT:    retq
; SJLJ-NEXT:  .LBB0_9:
; SJLJ-NEXT:    endbr64
; SJLJ-NEXT:    movl -144(%rbp), %eax
; SJLJ-NEXT:    cmpl $1, %eax
; SJLJ-NEXT:    jb .LBB0_10
; SJLJ-NEXT:  # %bb.11:
; SJLJ-NEXT:    ud2
; SJLJ-NEXT:  .LBB0_10:
; SJLJ-NEXT:    leaq {{.*}}(%rip), %rcx
; SJLJ-NEXT:    jmpq *(%rcx,%rax,8)
; SJLJ-NEXT:  .LBB0_2: # %lpad
; SJLJ-NEXT:  .Ltmp2:
; SJLJ-NEXT:    endbr64
; SJLJ-NEXT:    movl -140(%rbp), %ecx
; SJLJ-NEXT:    movl -136(%rbp), %eax
; SJLJ-NEXT:    movq %rcx, -56(%rbp)
; SJLJ-NEXT:    movl %eax, -64(%rbp)
; SJLJ-NEXT:    cmpl $2, %eax
; SJLJ-NEXT:    je .LBB0_3
; SJLJ-NEXT:  # %bb.4: # %catch.fallthrough
; SJLJ-NEXT:    cmpl $1, %eax
; SJLJ-NEXT:    jne .LBB0_8
; SJLJ-NEXT:  # %bb.5: # %catch
; SJLJ-NEXT:    movq -56(%rbp), %rdi
; SJLJ-NEXT:    movl $-1, -144(%rbp)
; SJLJ-NEXT:    callq __cxa_begin_catch
; SJLJ-NEXT:    movb (%rax), %al
; SJLJ-NEXT:    movb %al, -45(%rbp)
; SJLJ-NEXT:    xorl %ecx, %ecx
; SJLJ-NEXT:    cmpb $3, %al
; SJLJ-NEXT:    jmp .LBB0_6
; SJLJ-NEXT:  .LBB0_3: # %catch3
; SJLJ-NEXT:    movq -56(%rbp), %rdi
; SJLJ-NEXT:    movl $-1, -144(%rbp)
; SJLJ-NEXT:    callq __cxa_begin_catch
; SJLJ-NEXT:    movl (%rax), %eax
; SJLJ-NEXT:    movl %eax, -60(%rbp)
; SJLJ-NEXT:    xorl %ecx, %ecx
; SJLJ-NEXT:    cmpl $5, %eax
; SJLJ-NEXT:  .LBB0_6: # %return
; SJLJ-NEXT:    setne %cl
; SJLJ-NEXT:    movl %ecx, -44(%rbp)
; SJLJ-NEXT:    movl $-1, -144(%rbp)
; SJLJ-NEXT:    callq __cxa_end_catch
; SJLJ-NEXT:    jmp .LBB0_7
; SJLJ-NEXT:  .LBB0_8: # %eh.resume
; SJLJ-NEXT:    movl $-1, -144(%rbp)
entry:
  %retval = alloca i32, align 4
  %exn.slot = alloca i8*
  %ehselector.slot = alloca i32
  %x = alloca i8, align 1
  %x4 = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  invoke void @_Z3foov()
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  br label %try.cont

lpad:                                             ; preds = %entry
  %0 = landingpad { i8*, i32 }
          catch i8* bitcast (i8** @_ZTIi to i8*)
          catch i8* bitcast (i8** @_ZTIc to i8*)
  %1 = extractvalue { i8*, i32 } %0, 0
  store i8* %1, i8** %exn.slot, align 8
  %2 = extractvalue { i8*, i32 } %0, 1
  store i32 %2, i32* %ehselector.slot, align 4
  br label %catch.dispatch

catch.dispatch:                                   ; preds = %lpad
  %sel = load i32, i32* %ehselector.slot, align 4
  %3 = call i32 @llvm.eh.typeid.for(i8* bitcast (i8** @_ZTIi to i8*)) #3
  %matches = icmp eq i32 %sel, %3
  br i1 %matches, label %catch3, label %catch.fallthrough

catch3:                                           ; preds = %catch.dispatch
  %exn5 = load i8*, i8** %exn.slot, align 8
  %4 = call i8* @__cxa_begin_catch(i8* %exn5) #3
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5, align 4
  store i32 %6, i32* %x4, align 4
  %7 = load i32, i32* %x4, align 4
  %cmp6 = icmp ne i32 %7, 5
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, i32* %retval, align 4
  call void @__cxa_end_catch() #3
  br label %return

catch.fallthrough:                                ; preds = %catch.dispatch
  %8 = call i32 @llvm.eh.typeid.for(i8* bitcast (i8** @_ZTIc to i8*)) #3
  %matches1 = icmp eq i32 %sel, %8
  br i1 %matches1, label %catch, label %eh.resume

catch:                                            ; preds = %catch.fallthrough
  %exn = load i8*, i8** %exn.slot, align 8
  %9 = call i8* @__cxa_begin_catch(i8* %exn) #3
  %10 = load i8, i8* %9, align 1
  store i8 %10, i8* %x, align 1
  %11 = load i8, i8* %x, align 1
  %conv = sext i8 %11 to i32
  %cmp = icmp ne i32 %conv, 3
  %conv2 = zext i1 %cmp to i32
  store i32 %conv2, i32* %retval, align 4
  call void @__cxa_end_catch() #3
  br label %return

try.cont:                                         ; preds = %invoke.cont
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %try.cont, %catch3, %catch
  %12 = load i32, i32* %retval, align 4
  ret i32 %12

eh.resume:                                        ; preds = %catch.fallthrough
  %exn8 = load i8*, i8** %exn.slot, align 8
  %sel9 = load i32, i32* %ehselector.slot, align 4
  %lpad.val = insertvalue { i8*, i32 } undef, i8* %exn8, 0
  %lpad.val10 = insertvalue { i8*, i32 } %lpad.val, i32 %sel9, 1
  resume { i8*, i32 } %lpad.val10
}

declare dso_local void @_Z3foov() #1

declare dso_local i32 @__gxx_personality_sj0(...)

; Function Attrs: nounwind readnone
declare i32 @llvm.eh.typeid.for(i8*) #2

declare dso_local i8* @__cxa_begin_catch(i8*)

declare dso_local void @__cxa_end_catch()

!llvm.module.flags = !{!0, !1, !2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 4, !"cf-protection-return", i32 1}
!2 = !{i32 4, !"cf-protection-branch", i32 1}
