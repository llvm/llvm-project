# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc -mtriple=x86_64 -run-pass=register-coalescer -o - %s | FileCheck %s

# When the coalescer removes the COPY by commuting the operands of the AND, it should also update the `implicit-def` of the destination register.
---
name: implicit_def_dst
tracksRegLiveness: true
body: |
  bb.0:
    ; CHECK-LABEL: name: implicit_def_dst
    ; CHECK: [[MOV64rm:%[0-9]+]]:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    ; CHECK-NEXT: [[MOV64rm1:%[0-9]+]]:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    ; CHECK-NEXT: [[MOV64rm:%[0-9]+]].sub_32bit:gr64_with_sub_8bit = AND32rr [[MOV64rm]].sub_32bit, [[MOV64rm1]].sub_32bit, implicit-def dead $eflags, implicit-def [[MOV64rm]]
    ; CHECK-NEXT: RET 0, implicit [[MOV64rm]]
    %0:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    %1:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    %1.sub_32bit:gr64_with_sub_8bit = AND32rr %1.sub_32bit:gr64_with_sub_8bit, %0.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags, implicit-def %1:gr64_with_sub_8bit
    %0:gr64_with_sub_8bit = COPY %1:gr64_with_sub_8bit
    RET 0, implicit %0
...
# In case the MIR for some reason contains more than one implicit-def of the destination reg, then all should be updated.
---
name: two_implicit_defs_dst
tracksRegLiveness: true
body: |
  bb.0:
    ; CHECK-LABEL: name: two_implicit_defs_dst
    ; CHECK: [[MOV64rm:%[0-9]+]]:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    ; CHECK-NEXT: [[MOV64rm1:%[0-9]+]]:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    ; CHECK-NEXT: [[MOV64rm:%[0-9]+]].sub_32bit:gr64_with_sub_8bit = AND32rr [[MOV64rm]].sub_32bit, [[MOV64rm1]].sub_32bit, implicit-def dead $eflags, implicit-def [[MOV64rm]], implicit-def [[MOV64rm]]
    ; CHECK-NEXT: RET 0, implicit [[MOV64rm]]
    %0:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    %1:gr64_with_sub_8bit = MOV64rm $noreg, 1, $noreg, 0, $noreg :: (load (s64) from `ptr null`)
    %1.sub_32bit:gr64_with_sub_8bit = AND32rr %1.sub_32bit:gr64_with_sub_8bit, %0.sub_32bit:gr64_with_sub_8bit, implicit-def dead $eflags, implicit-def %1:gr64_with_sub_8bit, implicit-def %1:gr64_with_sub_8bit
    %0:gr64_with_sub_8bit = COPY %1:gr64_with_sub_8bit
    RET 0, implicit %0
...
# Commuting instruction with 3 ops is handled correctly.
---
name: commuting_3_ops
tracksRegLiveness: true
body: |
  bb.0:
    liveins: $ymm0, $ymm1

    ; CHECK-LABEL: name: commuting_3_ops
    ; CHECK: liveins: $ymm0, $ymm1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:vr256 = COPY $ymm1
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:vr256 = COPY $ymm0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:vr256 = contract nofpexcept VFMADD213PSYr [[COPY1]], [[COPY]], [[COPY]], implicit $mxcsr
    ; CHECK-NEXT: RET 0, implicit [[COPY1]]
    %0:vr256 = COPY $ymm1
    %1:vr256 = COPY $ymm0
    %0:vr256 = contract nofpexcept VFMADD231PSYr %0:vr256, %0:vr256, %1:vr256, implicit $mxcsr
    %1:vr256 = COPY %0:vr256
    RET 0, implicit %1
...
