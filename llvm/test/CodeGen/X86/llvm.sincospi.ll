; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=x86_64-apple-macosx10.9 < %s | FileCheck %s

define { half, half } @test_sincospi_f16(half %a) #0 {
; CHECK-LABEL: test_sincospi_f16:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    subq $40, %rsp
; CHECK-NEXT:    pextrw $0, %xmm0, %eax
; CHECK-NEXT:    movzwl %ax, %edi
; CHECK-NEXT:    callq ___extendhfsf2
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm0
; CHECK-NEXT:    movdqa %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill
; CHECK-NEXT:    movss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm1
; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 ## 16-byte Reload
; CHECK-NEXT:    addq $40, %rsp
; CHECK-NEXT:    retq
  %result = call { half, half } @llvm.sincospi.f16(half %a)
  ret { half, half } %result
}

define half @test_sincospi_f16_only_use_sin(half %a) #0 {
; CHECK-LABEL: test_sincospi_f16_only_use_sin:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    pextrw $0, %xmm0, %eax
; CHECK-NEXT:    movzwl %ax, %edi
; CHECK-NEXT:    callq ___extendhfsf2
; CHECK-NEXT:    movq %rsp, %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm0
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
  %result = call { half, half } @llvm.sincospi.f16(half %a)
  %result.0 = extractvalue { half, half } %result, 0
  ret half %result.0
}

define half @test_sincospi_f16_only_use_cos(half %a) #0 {
; CHECK-LABEL: test_sincospi_f16_only_use_cos:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    pextrw $0, %xmm0, %eax
; CHECK-NEXT:    movzwl %ax, %edi
; CHECK-NEXT:    callq ___extendhfsf2
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    movq %rsp, %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm0
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
  %result = call { half, half } @llvm.sincospi.f16(half %a)
  %result.1 = extractvalue { half, half } %result, 1
  ret half %result.1
}

define { <2 x half>, <2 x half> } @test_sincospi_v2f16(<2 x half> %a) #0 {
; CHECK-LABEL: test_sincospi_v2f16:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    subq $64, %rsp
; CHECK-NEXT:    pextrw $0, %xmm0, %ebx
; CHECK-NEXT:    psrld $16, %xmm0
; CHECK-NEXT:    pextrw $0, %xmm0, %eax
; CHECK-NEXT:    movzwl %ax, %edi
; CHECK-NEXT:    callq ___extendhfsf2
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    movq %rsp, %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movzwl %bx, %edi
; CHECK-NEXT:    callq ___extendhfsf2
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm0
; CHECK-NEXT:    movdqa %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill
; CHECK-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm0
; CHECK-NEXT:    movdqa %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill
; CHECK-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm0
; CHECK-NEXT:    movdqa %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill
; CHECK-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    callq ___truncsfhf2
; CHECK-NEXT:    ## kill: def $ax killed $ax def $eax
; CHECK-NEXT:    pinsrw $0, %eax, %xmm0
; CHECK-NEXT:    punpcklwd {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 ## 16-byte Folded Reload
; CHECK-NEXT:    ## xmm0 = xmm0[0],mem[0],xmm0[1],mem[1],xmm0[2],mem[2],xmm0[3],mem[3]
; CHECK-NEXT:    movdqa {{[-0-9]+}}(%r{{[sb]}}p), %xmm1 ## 16-byte Reload
; CHECK-NEXT:    punpcklwd {{[-0-9]+}}(%r{{[sb]}}p), %xmm1 ## 16-byte Folded Reload
; CHECK-NEXT:    ## xmm1 = xmm1[0],mem[0],xmm1[1],mem[1],xmm1[2],mem[2],xmm1[3],mem[3]
; CHECK-NEXT:    addq $64, %rsp
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    retq
  %result = call { <2 x half>, <2 x half> } @llvm.sincospi.v2f16(<2 x half> %a)
  ret { <2 x half>, <2 x half> } %result
}

define { float, float } @test_sincospi_f32(float %a) #0 {
; CHECK-LABEL: test_sincospi_f32:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    movq %rsp, %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    movss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
  %result = call { float, float } @llvm.sincospi.f32(float %a)
  ret { float, float } %result
}

define { <2 x float>, <2 x float> } @test_sincospi_v2f32(<2 x float> %a) #0 {
; CHECK-LABEL: test_sincospi_v2f32:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    subq $40, %rsp
; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    movq %rsp, %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 ## 16-byte Reload
; CHECK-NEXT:    shufps {{.*#+}} xmm0 = xmm0[1,1,1,1]
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    movss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    unpcklps {{.*#+}} xmm0 = xmm0[0],xmm1[0],xmm0[1],xmm1[1]
; CHECK-NEXT:    movss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    movss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    unpcklps {{.*#+}} xmm1 = xmm1[0],xmm2[0],xmm1[1],xmm2[1]
; CHECK-NEXT:    addq $40, %rsp
; CHECK-NEXT:    retq
  %result = call { <2 x float>, <2 x float> } @llvm.sincospi.v2f32(<2 x float> %a)
  ret { <2 x float>, <2 x float> } %result
}

define { <3 x float>, <3 x float> } @test_sincospi_v3f32(<3 x float> %a) #0 {
; CHECK-LABEL: test_sincospi_v3f32:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    subq $56, %rsp
; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 ## 16-byte Reload
; CHECK-NEXT:    shufps {{.*#+}} xmm0 = xmm0[1,1,1,1]
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 ## 16-byte Reload
; CHECK-NEXT:    movhlps {{.*#+}} xmm0 = xmm0[1,1]
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospif
; CHECK-NEXT:    movss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    movss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    unpcklps {{.*#+}} xmm0 = xmm0[0],xmm1[0],xmm0[1],xmm1[1]
; CHECK-NEXT:    movss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    movlhps {{.*#+}} xmm0 = xmm0[0],xmm1[0]
; CHECK-NEXT:    movss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    movss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    unpcklps {{.*#+}} xmm1 = xmm1[0],xmm2[0],xmm1[1],xmm2[1]
; CHECK-NEXT:    movss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    movlhps {{.*#+}} xmm1 = xmm1[0],xmm2[0]
; CHECK-NEXT:    addq $56, %rsp
; CHECK-NEXT:    retq
  %result = call { <3 x float>, <3 x float> } @llvm.sincospi.v3f32(<3 x float> %a)
  ret { <3 x float>, <3 x float> } %result
}

define { double, double } @test_sincospi_f64(double %a) #0 {
; CHECK-LABEL: test_sincospi_f64:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    subq $24, %rsp
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospi
; CHECK-NEXT:    movsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    movsd {{.*#+}} xmm1 = mem[0],zero
; CHECK-NEXT:    addq $24, %rsp
; CHECK-NEXT:    retq
  %result = call { double, double } @llvm.sincospi.f64(double %a)
  ret { double, double } %result
}

define { <2 x double>, <2 x double> } @test_sincospi_v2f64(<2 x double> %a) #0 {
; CHECK-LABEL: test_sincospi_v2f64:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    subq $56, %rsp
; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi
; CHECK-NEXT:    callq ___sincospi
; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 ## 16-byte Reload
; CHECK-NEXT:    movhlps {{.*#+}} xmm0 = xmm0[1,1]
; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rdi
; CHECK-NEXT:    movq %rsp, %rsi
; CHECK-NEXT:    callq ___sincospi
; CHECK-NEXT:    movsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    movhps {{.*#+}} xmm0 = xmm0[0,1],mem[0,1]
; CHECK-NEXT:    movsd {{.*#+}} xmm1 = mem[0],zero
; CHECK-NEXT:    movhps {{.*#+}} xmm1 = xmm1[0,1],mem[0,1]
; CHECK-NEXT:    addq $56, %rsp
; CHECK-NEXT:    retq
  %result = call { <2 x double>, <2 x double> } @llvm.sincospi.v2f64(<2 x double> %a)
  ret { <2 x double>, <2 x double> } %result
}

attributes #0 = { nounwind }
