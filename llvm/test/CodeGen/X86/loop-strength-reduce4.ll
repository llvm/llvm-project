; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=i686-apple-darwin -relocation-model=static | FileCheck %s -check-prefix=STATIC
; RUN: llc < %s -mtriple=i686-apple-darwin -relocation-model=pic | FileCheck %s -check-prefix=PIC

; By starting the IV at -64 instead of 0, a cmp is eliminated,
; as the flags from the add can be used directly.

@state = external global [0 x i32]		; <ptr> [#uses=4]
@S = external global [0 x i32]		; <ptr> [#uses=4]

define i32 @foo() nounwind {
; STATIC-LABEL: foo:
; STATIC:       ## %bb.0: ## %entry
; STATIC-NEXT:    xorl %ecx, %ecx
; STATIC-NEXT:    movl $-64, %eax
; STATIC-NEXT:    .p2align 4
; STATIC-NEXT:  LBB0_1: ## %bb
; STATIC-NEXT:    ## =>This Inner Loop Header: Depth=1
; STATIC-NEXT:    movl _S(,%ecx,4), %ecx
; STATIC-NEXT:    xorl _state+64(%eax), %ecx
; STATIC-NEXT:    movl %ecx, _state+64(%eax)
; STATIC-NEXT:    movl _S(,%ecx,4), %ecx
; STATIC-NEXT:    xorl _state+68(%eax), %ecx
; STATIC-NEXT:    movl %ecx, _state+68(%eax)
; STATIC-NEXT:    movl _S(,%ecx,4), %ecx
; STATIC-NEXT:    xorl _state+72(%eax), %ecx
; STATIC-NEXT:    movl %ecx, _state+72(%eax)
; STATIC-NEXT:    movl _S(,%ecx,4), %ecx
; STATIC-NEXT:    xorl _state+76(%eax), %ecx
; STATIC-NEXT:    movl %ecx, _state+76(%eax)
; STATIC-NEXT:    addl $16, %eax
; STATIC-NEXT:    jne LBB0_1
; STATIC-NEXT:  ## %bb.2: ## %bb57
; STATIC-NEXT:    movzbl %cl, %eax
; STATIC-NEXT:    retl
;
; PIC-LABEL: foo:
; PIC:       ## %bb.0: ## %entry
; PIC-NEXT:    pushl %ebx
; PIC-NEXT:    pushl %esi
; PIC-NEXT:    calll L0$pb
; PIC-NEXT:  L0$pb:
; PIC-NEXT:    popl %edx
; PIC-NEXT:    xorl %eax, %eax
; PIC-NEXT:    movl L_state$non_lazy_ptr-L0$pb(%edx), %ecx
; PIC-NEXT:    movl L_S$non_lazy_ptr-L0$pb(%edx), %edx
; PIC-NEXT:    xorl %ebx, %ebx
; PIC-NEXT:    .p2align 4
; PIC-NEXT:  LBB0_1: ## %bb
; PIC-NEXT:    ## =>This Inner Loop Header: Depth=1
; PIC-NEXT:    movl (%edx,%ebx,4), %esi
; PIC-NEXT:    xorl (%ecx,%eax), %esi
; PIC-NEXT:    movl %esi, (%ecx,%eax)
; PIC-NEXT:    movl (%edx,%esi,4), %esi
; PIC-NEXT:    xorl 4(%ecx,%eax), %esi
; PIC-NEXT:    movl %esi, 4(%ecx,%eax)
; PIC-NEXT:    movl (%edx,%esi,4), %esi
; PIC-NEXT:    xorl 8(%ecx,%eax), %esi
; PIC-NEXT:    movl %esi, 8(%ecx,%eax)
; PIC-NEXT:    movl (%edx,%esi,4), %ebx
; PIC-NEXT:    xorl 12(%ecx,%eax), %ebx
; PIC-NEXT:    movl %ebx, 12(%ecx,%eax)
; PIC-NEXT:    addl $16, %eax
; PIC-NEXT:    cmpl $64, %eax
; PIC-NEXT:    jne LBB0_1
; PIC-NEXT:  ## %bb.2: ## %bb57
; PIC-NEXT:    movzbl %bl, %eax
; PIC-NEXT:    popl %esi
; PIC-NEXT:    popl %ebx
; PIC-NEXT:    retl
entry:
	br label %bb

bb:		; preds = %bb, %entry
	%indvar = phi i32 [ 0, %entry ], [ %indvar.next, %bb ]		; <i32> [#uses=2]
	%t.063.0 = phi i32 [ 0, %entry ], [ %tmp47, %bb ]		; <i32> [#uses=1]
	%j.065.0 = shl i32 %indvar, 2		; <i32> [#uses=4]
	%tmp3 = getelementptr [0 x i32], ptr @state, i32 0, i32 %j.065.0		; <ptr> [#uses=2]
	%tmp4 = load i32, ptr %tmp3, align 4		; <i32> [#uses=1]
	%tmp6 = getelementptr [0 x i32], ptr @S, i32 0, i32 %t.063.0		; <ptr> [#uses=1]
	%tmp7 = load i32, ptr %tmp6, align 4		; <i32> [#uses=1]
	%tmp8 = xor i32 %tmp7, %tmp4		; <i32> [#uses=2]
	store i32 %tmp8, ptr %tmp3, align 4
	%tmp1378 = or disjoint i32 %j.065.0, 1		; <i32> [#uses=1]
	%tmp16 = getelementptr [0 x i32], ptr @state, i32 0, i32 %tmp1378		; <ptr> [#uses=2]
	%tmp17 = load i32, ptr %tmp16, align 4		; <i32> [#uses=1]
	%tmp19 = getelementptr [0 x i32], ptr @S, i32 0, i32 %tmp8		; <ptr> [#uses=1]
	%tmp20 = load i32, ptr %tmp19, align 4		; <i32> [#uses=1]
	%tmp21 = xor i32 %tmp20, %tmp17		; <i32> [#uses=2]
	store i32 %tmp21, ptr %tmp16, align 4
	%tmp2680 = or disjoint i32 %j.065.0, 2		; <i32> [#uses=1]
	%tmp29 = getelementptr [0 x i32], ptr @state, i32 0, i32 %tmp2680		; <ptr> [#uses=2]
	%tmp30 = load i32, ptr %tmp29, align 4		; <i32> [#uses=1]
	%tmp32 = getelementptr [0 x i32], ptr @S, i32 0, i32 %tmp21		; <ptr> [#uses=1]
	%tmp33 = load i32, ptr %tmp32, align 4		; <i32> [#uses=1]
	%tmp34 = xor i32 %tmp33, %tmp30		; <i32> [#uses=2]
	store i32 %tmp34, ptr %tmp29, align 4
	%tmp3982 = or disjoint i32 %j.065.0, 3		; <i32> [#uses=1]
	%tmp42 = getelementptr [0 x i32], ptr @state, i32 0, i32 %tmp3982		; <ptr> [#uses=2]
	%tmp43 = load i32, ptr %tmp42, align 4		; <i32> [#uses=1]
	%tmp45 = getelementptr [0 x i32], ptr @S, i32 0, i32 %tmp34		; <ptr> [#uses=1]
	%tmp46 = load i32, ptr %tmp45, align 4		; <i32> [#uses=1]
	%tmp47 = xor i32 %tmp46, %tmp43		; <i32> [#uses=3]
	store i32 %tmp47, ptr %tmp42, align 4
	%indvar.next = add i32 %indvar, 1		; <i32> [#uses=2]
	%exitcond = icmp eq i32 %indvar.next, 4		; <i1> [#uses=1]
	br i1 %exitcond, label %bb57, label %bb

bb57:		; preds = %bb
	%tmp59 = and i32 %tmp47, 255		; <i32> [#uses=1]
	ret i32 %tmp59
}
