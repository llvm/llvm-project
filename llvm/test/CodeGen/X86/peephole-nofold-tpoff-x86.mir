# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -run-pass=peephole-opt -mtriple=i386-- %s -o - | FileCheck %s

# Linkers may change `addq xx@GOTNTPOFF, %reg` to `leaq OFFSET(%reg), %reg`,
# so we must not depend upon the EFLAGS output. Verify that the TEST
# instruction won't be folded into the ADD.

# NOTE: the IR will no longer actually produce the input MIR after
# llvm.threadlocal.address intrinsic is annotated as having a nonnull
# result.

# NOTE2: the foo_nopic MIR was produced from IR with --relocation-model=static
# while foo_pic's MIR was produced with --relocation-model=pic.

--- |
  target datalayout = "e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128"
  target triple = "i386-unknown-linux-gnu"

  @x = external thread_local(initialexec) global i32, align 4

  define i32 @foo_nopic() {
    %1 = tail call ptr @llvm.threadlocal.address.p0(ptr nonnull @x)
    %cmp = icmp eq ptr %1, null
    %zext = zext i1 %cmp to i32
    ret i32 %zext
  }

  define i32 @foo_pic() {
    %1 = tail call ptr @llvm.threadlocal.address.p0(ptr nonnull @x)
    %cmp = icmp eq ptr %1, null
    %zext = zext i1 %cmp to i32
    ret i32 %zext
  }

  ; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
  declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull) #0

  attributes #0 = { nocallback nofree nosync nounwind readnone speculatable willreturn }

...
---
name:            foo_nopic
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: gr32 }
  - { id: 1, class: gr32 }
  - { id: 2, class: gr8 }
  - { id: 3, class: gr32 }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  bb.0 (%ir-block.0):
    ; CHECK-LABEL: name: foo_nopic
    ; CHECK: [[MOV32rm:%[0-9]+]]:gr32 = MOV32rm $noreg, 1, $noreg, 0, $gs :: (load (s32) from `ptr addrspace(256) null`, addrspace 256)
    ; CHECK-NEXT: [[ADD32rm:%[0-9]+]]:gr32 = ADD32rm [[MOV32rm]], $noreg, 1, $noreg, target-flags(x86-indntpoff) @x, $noreg, implicit-def dead $eflags :: (load (s32) from got)
    ; CHECK-NEXT: TEST32rr [[ADD32rm]], [[ADD32rm]], implicit-def $eflags
    ; CHECK-NEXT: [[SETCCr:%[0-9]+]]:gr8 = SETCCr 4, implicit $eflags
    ; CHECK-NEXT: [[MOVZX32rr8_:%[0-9]+]]:gr32 = MOVZX32rr8 killed [[SETCCr]]
    ; CHECK-NEXT: $eax = COPY [[MOVZX32rr8_]]
    ; CHECK-NEXT: RET 0, $eax
    %0:gr32 = MOV32rm $noreg, 1, $noreg, 0, $gs :: (load (s32) from `ptr addrspace(256) null`, addrspace 256)
    %1:gr32 = ADD32rm %0, $noreg, 1, $noreg, target-flags(x86-indntpoff) @x, $noreg, implicit-def dead $eflags :: (load (s32) from got)
    TEST32rr %1, %1, implicit-def $eflags
    %2:gr8 = SETCCr 4, implicit $eflags
    %3:gr32 = MOVZX32rr8 killed %2
    $eax = COPY %3
    RET 0, $eax

...
---
name:            foo_pic
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: gr32_nosp }
  - { id: 1, class: gr32 }
  - { id: 2, class: gr32 }
  - { id: 3, class: gr8 }
  - { id: 4, class: gr32 }
  - { id: 5, class: gr32 }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  bb.0 (%ir-block.0):
    ; CHECK-LABEL: name: foo_pic
    ; CHECK: [[MOVPC32r:%[0-9]+]]:gr32 = MOVPC32r 0, implicit $esp, implicit $ssp
    ; CHECK-NEXT: [[ADD32ri:%[0-9]+]]:gr32_nosp = ADD32ri [[MOVPC32r]], target-flags(x86-got-absolute-address) &_GLOBAL_OFFSET_TABLE_, implicit-def $eflags
    ; CHECK-NEXT: [[MOV32rm:%[0-9]+]]:gr32 = MOV32rm $noreg, 1, $noreg, 0, $gs :: (load (s32) from `ptr addrspace(256) null`, addrspace 256)
    ; CHECK-NEXT: [[ADD32rm:%[0-9]+]]:gr32 = ADD32rm [[MOV32rm]], [[ADD32ri]], 1, $noreg, target-flags(x86-gotntpoff) @x, $noreg, implicit-def dead $eflags :: (load (s32) from got)
    ; CHECK-NEXT: TEST32rr [[ADD32rm]], [[ADD32rm]], implicit-def $eflags
    ; CHECK-NEXT: [[SETCCr:%[0-9]+]]:gr8 = SETCCr 4, implicit $eflags
    ; CHECK-NEXT: [[MOVZX32rr8_:%[0-9]+]]:gr32 = MOVZX32rr8 killed [[SETCCr]]
    ; CHECK-NEXT: $eax = COPY [[MOVZX32rr8_]]
    ; CHECK-NEXT: RET 0, $eax
    %5:gr32 = MOVPC32r 0, implicit $esp, implicit $ssp
    %0:gr32_nosp = ADD32ri %5, target-flags(x86-got-absolute-address) &_GLOBAL_OFFSET_TABLE_, implicit-def $eflags
    %1:gr32 = MOV32rm $noreg, 1, $noreg, 0, $gs :: (load (s32) from `ptr addrspace(256) null`, addrspace 256)
    %2:gr32 = ADD32rm %1, %0, 1, $noreg, target-flags(x86-gotntpoff) @x, $noreg, implicit-def dead $eflags :: (load (s32) from got)
    TEST32rr %2, %2, implicit-def $eflags
    %3:gr8 = SETCCr 4, implicit $eflags
    %4:gr32 = MOVZX32rr8 killed %3
    $eax = COPY %4
    RET 0, $eax
...
