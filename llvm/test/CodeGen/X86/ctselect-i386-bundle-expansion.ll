; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=i386-unknown-linux-gnu -mattr=-cmov -print-after=pseudo-probe-inserter < %s -o /dev/null 2>&1 | FileCheck %s --check-prefix=BUNDLE
; RUN: llc -mtriple=i386-unknown-linux-gnu -mattr=-cmov < %s | FileCheck %s --check-prefix=ASM

; Test that CTSELECT expansion creates proper constant-time bundles with correct instruction sequences

define i32 @test_ctselect_i32_bundle_expansion(i1 %cond, i32 %a, i32 %b) {
; ASM-LABEL: test_ctselect_i32_bundle_expansion:
; ASM:       # %bb.0:
; ASM-NEXT:    pushl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    pushl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    pushl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 16
; ASM-NEXT:    .cfi_offset %esi, -16
; ASM-NEXT:    .cfi_offset %edi, -12
; ASM-NEXT:    .cfi_offset %ebx, -8
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %edx
; ASM-NEXT:    testb $1, {{[0-9]+}}(%esp)
; ASM-NEXT:    BUNDLE
; ASM-NEXT:    popl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    popl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    popl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 4
; ASM-NEXT:    retl


  %1 = call i32 @llvm.ct.select.i32(i1 %cond, i32 %a, i32 %b)
  ret i32 %1
}

define i16 @test_ctselect_i16_bundle_expansion(i1 %cond, i16 %a, i16 %b) {
; ASM-LABEL: test_ctselect_i16_bundle_expansion:
; ASM:       # %bb.0:
; ASM-NEXT:    pushl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    pushl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    pushl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 16
; ASM-NEXT:    .cfi_offset %esi, -16
; ASM-NEXT:    .cfi_offset %edi, -12
; ASM-NEXT:    .cfi_offset %ebx, -8
; ASM-NEXT:    movzwl {{[0-9]+}}(%esp), %ecx
; ASM-NEXT:    movzwl {{[0-9]+}}(%esp), %edx
; ASM-NEXT:    testb $1, {{[0-9]+}}(%esp)
; ASM-NEXT:    BUNDLE
; ASM-NEXT:    popl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    popl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    popl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 4
; ASM-NEXT:    retl


  %1 = call i16 @llvm.ct.select.i16(i1 %cond, i16 %a, i16 %b)
  ret i16 %1
}

define i64 @test_ctselect_i64_bundle_expansion(i1 %cond, i64 %a, i64 %b) {
; ASM-LABEL: test_ctselect_i64_bundle_expansion:
; ASM:       # %bb.0:
; ASM-NEXT:    pushl %ebp
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    pushl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    pushl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 16
; ASM-NEXT:    pushl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 20
; ASM-NEXT:    .cfi_offset %esi, -20
; ASM-NEXT:    .cfi_offset %edi, -16
; ASM-NEXT:    .cfi_offset %ebx, -12
; ASM-NEXT:    .cfi_offset %ebp, -8
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %edx
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %edi
; ASM-NEXT:    testb $1, {{[0-9]+}}(%esp)
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %esi
; ASM-NEXT:    BUNDLE
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %esi
; ASM-NEXT:    BUNDLE
; ASM-NEXT:    popl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 16
; ASM-NEXT:    popl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    popl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    popl %ebp
; ASM-NEXT:    .cfi_def_cfa_offset 4
; ASM-NEXT:    retl
; First bundle for low 32 bits
; Second bundle for high 32 bits


  %1 = call i64 @llvm.ct.select.i64(i1 %cond, i64 %a, i64 %b)
  ret i64 %1
}

define i32 @test_ctselect_different_conditions(i32 %x, i32 %y, i32 %a, i32 %b) {
; Test different comparison conditions to ensure they all use the same bundle pattern
; ASM-LABEL: test_ctselect_different_conditions:
; ASM:       # %bb.0:
; ASM-NEXT:    pushl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    pushl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    pushl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 16
; ASM-NEXT:    .cfi_offset %esi, -16
; ASM-NEXT:    .cfi_offset %edi, -12
; ASM-NEXT:    .cfi_offset %ebx, -8
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %edx
; ASM-NEXT:    movl {{[0-9]+}}(%esp), %eax
; ASM-NEXT:    cmpl {{[0-9]+}}(%esp), %eax
; ASM-NEXT:    setl %al
; ASM-NEXT:    testb %al, %al
; ASM-NEXT:    BUNDLE
; ASM-NEXT:    popl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    popl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    popl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 4
; ASM-NEXT:    retl


  %cond = icmp slt i32 %x, %y
  %1 = call i32 @llvm.ct.select.i32(i1 %cond, i32 %a, i32 %b)
  ret i32 %1
}

define i32 @test_ctselect_constant_operands(i1 %cond) {
; Test with constant operands to ensure no special optimizations break bundling
; ASM-LABEL: test_ctselect_constant_operands:
; ASM:       # %bb.0:
; ASM-NEXT:    pushl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    pushl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    pushl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 16
; ASM-NEXT:    .cfi_offset %esi, -16
; ASM-NEXT:    .cfi_offset %edi, -12
; ASM-NEXT:    .cfi_offset %ebx, -8
; ASM-NEXT:    xorl %ecx, %ecx
; ASM-NEXT:    testb $1, {{[0-9]+}}(%esp)
; ASM-NEXT:    movl $42, %edx
; ASM-NEXT:    BUNDLE
; ASM-NEXT:    popl %esi
; ASM-NEXT:    .cfi_def_cfa_offset 12
; ASM-NEXT:    popl %edi
; ASM-NEXT:    .cfi_def_cfa_offset 8
; ASM-NEXT:    popl %ebx
; ASM-NEXT:    .cfi_def_cfa_offset 4
; ASM-NEXT:    retl


  %1 = call i32 @llvm.ct.select.i32(i1 %cond, i32 42, i32 0)
  ret i32 %1
}

; Verify that each bundle contains exactly the expected constant-time sequence:
; 1. SETCCr - Set condition code to register (sete/setne/setl etc)
; 2. MOVZX32rr8 - Zero-extend 8-bit to 32-bit
; 3. NEG32r/NEG16r - Negate to create bitmask (0 -> 0, 1 -> 0xFFFFFFFF)
; 4. MOV32rr/MOV16rr - Copy mask
; 5. XOR32ri/XOR16ri - Create inverted mask (~mask)
; 6. MOV32rr/MOV16rr - Copy first operand
; 7. AND32rr/AND16rr - Mask first operand (operand & mask)
; 8. MOV32rr/MOV16rr - Copy second operand
; 9. AND32rr/AND16rr - Mask second operand (operand & ~mask)
; 10. OR32rr/OR16rr - Combine results (result = (a & mask) | (b & ~mask))

declare i16 @llvm.ct.select.i16(i1, i16, i16)
declare i32 @llvm.ct.select.i32(i1, i32, i32)
declare i64 @llvm.ct.select.i64(i1, i64, i64)
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; BUNDLE: {{.*}}
