# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 6
# RUN: llc -mtriple=x86_64-- -run-pass=livevars,phi-node-elimination %s -o - | FileCheck %s
# RUN: llc -mtriple=x86_64-- --passes='require<live-vars>,phi-node-elimination' -verify-each -o - %s | FileCheck %s

--- |
  define i64 @inlineasm_br_different_indirect_target(i1 %cmp) {
  entry:
    br label %loop

  loop:                                             ; preds = %loop.end, %loop, %entry
    %val = phi i64 [ 0, %entry ], [ %val.next, %loop.end ], [ poison, %loop ]
    br i1 %cmp, label %loop.end, label %loop

  loop.end:                                         ; preds = %loop
    %val.next = xor i64 %val, 9
    callbr void asm sideeffect "", "!i,~{dirflag},~{fpsr},~{flags}"()
            to label %exit [label %loop]

  exit:                                             ; preds = %loop.end
    ret i64 %val.next
  }
...
---
name:            inlineasm_br_different_indirect_target
alignment:       16
tracksRegLiveness: true
noPhis:          false
isSSA:           true
body:             |
  ; CHECK-LABEL: name: inlineasm_br_different_indirect_target
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $edi
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gr32 = COPY killed $edi
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gr8 = COPY killed [[COPY]].sub_8bit
  ; CHECK-NEXT:   [[MOV32r0_:%[0-9]+]]:gr32 = MOV32r0 implicit-def dead $eflags
  ; CHECK-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gr64 = SUBREG_TO_REG 0, killed [[MOV32r0_]], %subreg.sub_32bit
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gr64 = COPY killed [[SUBREG_TO_REG]]
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop (inlineasm-br-indirect-target):
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gr64 = COPY killed [[COPY2]]
  ; CHECK-NEXT:   TEST8ri [[COPY1]], 1, implicit-def $eflags
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gr64 = IMPLICIT_DEF
  ; CHECK-NEXT:   JCC_1 %bb.1, 4, implicit killed $eflags
  ; CHECK-NEXT:   JMP_1 %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.loop.end:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000), %bb.1(0x00000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[XOR64ri32_:%[0-9]+]]:gr64 = XOR64ri32 killed [[COPY3]], 9, implicit-def dead $eflags
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gr64 = COPY [[XOR64ri32_]]
  ; CHECK-NEXT:   INLINEASM_BR &"", 1 /* sideeffect attdialect */, 13 /* imm */, %bb.1, 12 /* clobber */, implicit-def dead early-clobber $df, 12 /* clobber */, implicit-def early-clobber $fpsw, 12 /* clobber */, implicit-def dead early-clobber $eflags
  ; CHECK-NEXT:   JMP_1 %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.exit:
  ; CHECK-NEXT:   $rax = COPY killed [[XOR64ri32_]]
  ; CHECK-NEXT:   RET 0, killed $rax
  bb.0.entry:
    successors: %bb.1(0x80000000)
    liveins: $edi

    %2:gr32 = COPY killed $edi
    %3:gr8 = COPY killed %2.sub_8bit
    %5:gr32 = MOV32r0 implicit-def dead $eflags
    %4:gr64 = SUBREG_TO_REG 0, killed %5, %subreg.sub_32bit

  bb.1.loop (inlineasm-br-indirect-target):
    successors: %bb.2(0x40000000), %bb.1(0x40000000)

    %0:gr64 = PHI %4, %bb.0, undef %6:gr64, %bb.1, %1, %bb.2
    TEST8ri %3, 1, implicit-def $eflags
    JCC_1 %bb.1, 4, implicit killed $eflags
    JMP_1 %bb.2

  bb.2.loop.end:
    successors: %bb.3(0x80000000), %bb.1(0x00000000)

    %1:gr64 = XOR64ri32 killed %0, 9, implicit-def dead $eflags
    INLINEASM_BR &"", 1 /* sideeffect attdialect */, 13 /* imm */, %bb.1, 12 /* clobber */, implicit-def dead early-clobber $df, 12 /* clobber */, implicit-def early-clobber $fpsw, 12 /* clobber */, implicit-def dead early-clobber $eflags
    JMP_1 %bb.3

  bb.3.exit:
    $rax = COPY killed %1
    RET 0, killed $rax
...
