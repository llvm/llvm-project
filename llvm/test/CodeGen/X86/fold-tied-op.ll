; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs -mtriple=i386--netbsd < %s | FileCheck %s

; Regression test for http://reviews.llvm.org/D5701

%struct.XXH_state64_t = type { i32, i32, i64, i64, i64 }

@a = common global i32 0, align 4
@b = common global i64 0, align 8

; Function Attrs: nounwind uwtable
define i64 @fn1() #0 {
; CHECK-LABEL: fn1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushl %ebp
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    .cfi_offset %ebp, -8
; CHECK-NEXT:    movl %esp, %ebp
; CHECK-NEXT:    .cfi_def_cfa_register %ebp
; CHECK-NEXT:    pushl %ebx
; CHECK-NEXT:    pushl %edi
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    subl $12, %esp
; CHECK-NEXT:    .cfi_offset %esi, -20
; CHECK-NEXT:    .cfi_offset %edi, -16
; CHECK-NEXT:    .cfi_offset %ebx, -12
; CHECK-NEXT:    movl $-1028477379, %ebx # imm = 0xC2B2AE3D
; CHECK-NEXT:    movl $668265295, %ecx # imm = 0x27D4EB4F
; CHECK-NEXT:    movl a, %edi
; CHECK-NEXT:    cmpl $0, (%edi)
; CHECK-NEXT:    je .LBB0_2
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movl 8(%edi), %esi
; CHECK-NEXT:    movl 12(%edi), %eax
; CHECK-NEXT:    movl %eax, %edx
; CHECK-NEXT:    shldl $1, %esi, %edx
; CHECK-NEXT:    orl %eax, %edx
; CHECK-NEXT:    leal (%esi,%esi), %eax
; CHECK-NEXT:    orl %esi, %eax
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; CHECK-NEXT:    movl 16(%edi), %ebx
; CHECK-NEXT:    movl 20(%edi), %esi
; CHECK-NEXT:    movl %esi, %eax
; CHECK-NEXT:    shldl $2, %ebx, %eax
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    shldl $31, %eax, %ebx
; CHECK-NEXT:    shll $2, %eax
; CHECK-NEXT:    orl %ebx, %eax
; CHECK-NEXT:    shrl %esi
; CHECK-NEXT:    orl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Folded Reload
; CHECK-NEXT:    addl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Folded Reload
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; CHECK-NEXT:    adcl %edx, %esi
; CHECK-NEXT:    movl %esi, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; CHECK-NEXT:    movl 24(%edi), %eax
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; CHECK-NEXT:    movl $-1028477379, %ebx # imm = 0xC2B2AE3D
; CHECK-NEXT:    imull %eax, %ebx
; CHECK-NEXT:    mull %ecx
; CHECK-NEXT:    movl %eax, %esi
; CHECK-NEXT:    addl %ebx, %edx
; CHECK-NEXT:    movl 28(%edi), %edi
; CHECK-NEXT:    imull %edi, %ecx
; CHECK-NEXT:    addl %edx, %ecx
; CHECK-NEXT:    movl $1336530590, %edx # imm = 0x4FA9D69E
; CHECK-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %ebx # 4-byte Reload
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    mull %edx
; CHECK-NEXT:    imull $-2056954758, %ebx, %ebx # imm = 0x85655C7A
; CHECK-NEXT:    addl %edx, %ebx
; CHECK-NEXT:    imull $1336530590, %edi, %edx # imm = 0x4FA9D69E
; CHECK-NEXT:    addl %ebx, %edx
; CHECK-NEXT:    shrdl $3, %ecx, %esi
; CHECK-NEXT:    sarl $3, %ecx
; CHECK-NEXT:    orl %edx, %ecx
; CHECK-NEXT:    orl %eax, %esi
; CHECK-NEXT:    movl $-66860409, %ebx # imm = 0xFC03CA87
; CHECK-NEXT:    movl %esi, %eax
; CHECK-NEXT:    mull %ebx
; CHECK-NEXT:    movl %eax, %edi
; CHECK-NEXT:    imull $326129324, %esi, %eax # imm = 0x137056AC
; CHECK-NEXT:    addl %edx, %eax
; CHECK-NEXT:    imull $-66860409, %ecx, %ecx # imm = 0xFC03CA87
; CHECK-NEXT:    addl %eax, %ecx
; CHECK-NEXT:    xorl {{[-0-9]+}}(%e{{[sb]}}p), %ecx # 4-byte Folded Reload
; CHECK-NEXT:    xorl {{[-0-9]+}}(%e{{[sb]}}p), %edi # 4-byte Folded Reload
; CHECK-NEXT:    movl %edi, b
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    mull %ebx
; CHECK-NEXT:    imull $326129324, %edi, %esi # imm = 0x137056AC
; CHECK-NEXT:    addl %edx, %esi
; CHECK-NEXT:    movl %ecx, b+4
; CHECK-NEXT:    imull $-66860409, %ecx, %ecx # imm = 0xFC03CA87
; CHECK-NEXT:    jmp .LBB0_3
; CHECK-NEXT:  .LBB0_2: # %if.else
; CHECK-NEXT:    xorl b+4, %ebx
; CHECK-NEXT:    xorl b, %ecx
; CHECK-NEXT:    movl $1419758215, %edx # imm = 0x549FCA87
; CHECK-NEXT:    movl %ecx, %eax
; CHECK-NEXT:    mull %edx
; CHECK-NEXT:    imull $93298681, %ecx, %esi # imm = 0x58F9FF9
; CHECK-NEXT:    addl %edx, %esi
; CHECK-NEXT:    imull $1419758215, %ebx, %ecx # imm = 0x549FCA87
; CHECK-NEXT:  .LBB0_3: # %if.end
; CHECK-NEXT:    addl %esi, %ecx
; CHECK-NEXT:    addl $-1028477341, %eax # imm = 0xC2B2AE63
; CHECK-NEXT:    adcl $-2048144777, %ecx # imm = 0x85EBCA77
; CHECK-NEXT:    movl %eax, b
; CHECK-NEXT:    movl %ecx, b+4
; CHECK-NEXT:    addl $12, %esp
; CHECK-NEXT:    popl %esi
; CHECK-NEXT:    popl %edi
; CHECK-NEXT:    popl %ebx
; CHECK-NEXT:    popl %ebp
; CHECK-NEXT:    .cfi_def_cfa %esp, 4
; CHECK-NEXT:    retl
entry:
  %0 = load i32, ptr @a, align 4, !tbaa !1
  %1 = inttoptr i32 %0 to ptr
  %2 = load i32, ptr %1, align 4, !tbaa !5
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %v3 = getelementptr inbounds %struct.XXH_state64_t, ptr %1, i32 0, i32 3
  %3 = load i64, ptr %v3, align 4, !tbaa !8
  %v4 = getelementptr inbounds %struct.XXH_state64_t, ptr %1, i32 0, i32 4
  %4 = load i64, ptr %v4, align 4, !tbaa !9
  %v2 = getelementptr inbounds %struct.XXH_state64_t, ptr %1, i32 0, i32 2
  %5 = load i64, ptr %v2, align 4, !tbaa !10
  %shl = shl i64 %5, 1
  %or = or i64 %shl, %5
  %shl2 = shl i64 %3, 2
  %shr = lshr i64 %3, 1
  %or3 = or i64 %shl2, %shr
  %add = add i64 %or, %or3
  %mul = mul i64 %4, -4417276706812531889
  %shl4 = mul i64 %4, -8834553413625063778
  %shr5 = ashr i64 %mul, 3
  %or6 = or i64 %shr5, %shl4
  %mul7 = mul nsw i64 %or6, 1400714785074694791
  %xor = xor i64 %add, %mul7
  store i64 %xor, ptr @b, align 8, !tbaa !11
  %mul8 = mul nsw i64 %xor, 1400714785074694791
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i64, ptr @b, align 8, !tbaa !11
  %xor10 = xor i64 %6, -4417276706812531889
  %mul11 = mul nsw i64 %xor10, 400714785074694791
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %storemerge.in = phi i64 [ %mul11, %if.else ], [ %mul8, %if.then ]
  %storemerge = add i64 %storemerge.in, -8796714831421723037
  store i64 %storemerge, ptr @b, align 8, !tbaa !11
  ret i64 undef
}

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "frame-pointer"="all" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.6 (trunk 219587)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!6, !2, i64 0}
!6 = !{!"XXH_state64_t", !2, i64 0, !2, i64 4, !7, i64 8, !7, i64 16, !7, i64 24}
!7 = !{!"long long", !3, i64 0}
!8 = !{!6, !7, i64 16}
!9 = !{!6, !7, i64 24}
!10 = !{!6, !7, i64 8}
!11 = !{!7, !7, i64 0}
