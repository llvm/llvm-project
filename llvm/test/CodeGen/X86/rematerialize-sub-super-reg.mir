# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 2
# RUN: llc -mtriple=x86_64-- -run-pass=register-coalescer -o - %s | FileCheck %s

# Test the implicit operands and operand flags on remateralized
# instructions folding into a sub or super register def.

# Test a full register def at %t1 rematerializing into a subregister
# use. The subregister dest operand should be dead, with an
# implicit-def of the full physical register.

---
name: rematerialize_super_register_into_subreg_def
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: rematerialize_super_register_into_subreg_def
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %t3:gr64 = MOV64ri32 -11
  ; CHECK-NEXT:   CMP64ri8 %t3, 1, implicit-def $eflags
  ; CHECK-NEXT:   JCC_1 %bb.2, 4, implicit killed $eflags
  ; CHECK-NEXT:   JMP_1 %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   dead $rax = MOV64ri32 -11, implicit-def $eax
  ; CHECK-NEXT:   CMP64ri8 %t3, 1, implicit-def $eflags
  ; CHECK-NEXT:   JCC_1 %bb.1, 4, implicit killed $eflags
  ; CHECK-NEXT:   RET 0, $eax
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %t3:gr64 = ADD64ri8 %t3, 10, implicit-def $eflags
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   $rax = COPY %t3
  ; CHECK-NEXT:   RET 0, $rax
  bb.0:
    %t1:gr64 = MOV64ri32 -11
    CMP64ri8 %t1, 1, implicit-def $eflags
    JCC_1 %bb.2, 4, implicit killed $eflags
    JMP_1 %bb.1

  bb.1:
    %t2:gr64 = COPY %t1
    $eax = COPY %t2.sub_32bit
    CMP64ri8 %t2, 1, implicit-def $eflags
    JCC_1 %bb.1, 4, implicit killed $eflags
    RET 0, $eax

  bb.2:
    %t3:gr64 = COPY %t1
    %t3:gr64 = ADD64ri8 %t3, 10, implicit-def $eflags

  bb.3:
    $rax = COPY %t3
    RET 0, $rax

...

# Test an undef subregister def of %t1 rematerializing into a physical
# super register def
---
name:            rematerialize_subregister_into_superreg_def
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: rematerialize_subregister_into_superreg_def
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   undef %t3.sub_32bit:gr64_with_sub_8bit = MOV32ri -11
  ; CHECK-NEXT:   CMP64ri8 %t3, 1, implicit-def $eflags
  ; CHECK-NEXT:   JCC_1 %bb.2, 4, implicit killed $eflags
  ; CHECK-NEXT:   JMP_1 %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   dead $eax = MOV32ri -11, implicit-def $rax
  ; CHECK-NEXT:   CMP64ri8 %t3, 1, implicit-def $eflags
  ; CHECK-NEXT:   JCC_1 %bb.1, 4, implicit killed $eflags
  ; CHECK-NEXT:   RET 0, $rax
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %t3:gr64_with_sub_8bit = ADD64ri8 %t3, 10, implicit-def $eflags
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   $rax = COPY %t3
  ; CHECK-NEXT:   RET 0, $rax
  bb.0:
    undef %t1.sub_32bit:gr64_with_sub_8bit = MOV32ri -11
    CMP64ri8 %t1, 1, implicit-def $eflags
    JCC_1 %bb.2, 4, implicit killed $eflags
    JMP_1 %bb.1

  bb.1:
    %t2:gr64 = COPY %t1
    $rax = COPY %t2
    CMP64ri8 %t2, 1, implicit-def $eflags
    JCC_1 %bb.1, 4, implicit killed $eflags
    RET 0, $rax

  bb.2:
    %t3:gr64 = COPY %t1
    %t3:gr64 = ADD64ri8 %t3, 10, implicit-def $eflags

  bb.3:
    $rax = COPY %t3
    RET 0, $rax

...

# Handle that rematerializing an instruction with an implicit def of a
# virtual super register into a physical register works.
#
# FIXME: Resulting rematerializing has a redundant implicit-def
---
name:            rematerialize_subregister_into_superreg_def_with_impdef_physreg
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: rematerialize_subregister_into_superreg_def_with_impdef_physreg
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   undef %t3.sub_32bit:gr64_with_sub_8bit = MOV32ri -11, implicit-def %t3
  ; CHECK-NEXT:   CMP64ri8 %t3, 1, implicit-def $eflags
  ; CHECK-NEXT:   JCC_1 %bb.2, 4, implicit killed $eflags
  ; CHECK-NEXT:   JMP_1 %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   dead $eax = MOV32ri -11, implicit-def $rax, implicit-def $rax
  ; CHECK-NEXT:   CMP64ri8 %t3, 1, implicit-def $eflags
  ; CHECK-NEXT:   JCC_1 %bb.1, 4, implicit killed $eflags
  ; CHECK-NEXT:   RET 0, $rax
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   %t3:gr64_with_sub_8bit = ADD64ri8 %t3, 10, implicit-def $eflags
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   $rax = COPY %t3
  ; CHECK-NEXT:   RET 0, $rax
  bb.0:
    undef %t1.sub_32bit:gr64_with_sub_8bit = MOV32ri -11, implicit-def %t1
    CMP64ri8 %t1, 1, implicit-def $eflags
    JCC_1 %bb.2, 4, implicit killed $eflags
    JMP_1 %bb.1

  bb.1:
    %t2:gr64 = COPY %t1
    $rax = COPY %t2
    CMP64ri8 %t2, 1, implicit-def $eflags
    JCC_1 %bb.1, 4, implicit killed $eflags
    RET 0, $rax

  bb.2:
    %t3:gr64 = COPY %t1
    %t3:gr64 = ADD64ri8 %t3, 10, implicit-def $eflags

  bb.3:
    $rax = COPY %t3
    RET 0, $rax

...
