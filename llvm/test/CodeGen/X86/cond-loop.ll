; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=x86_64 | FileCheck %s

define void @f1(i64 %a, i64 %b) {
; CHECK-LABEL: f1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cmpq %rsi, %rdi
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    jb .Ltmp0
; CHECK-NEXT:    retq
  %cmp = icmp ult i64 %a, %b
  call void @llvm.cond.loop(i1 %cmp)
  ret void
}

define void @f2() {
; CHECK-LABEL: f2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:    jne .Ltmp1
; CHECK-NEXT:    retq
  call void @llvm.cond.loop(i1 true)
  ret void
}

define void @f3(i1 %p) {
; CHECK-LABEL: f3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testb $1, %dil
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    jne .Ltmp2
; CHECK-NEXT:    retq
  call void @llvm.cond.loop(i1 %p)
  ret void
}

define void @f4(i32 %a, i32 %b) {
; CHECK-LABEL: f4:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addl %esi, %edi
; CHECK-NEXT:  .Ltmp3:
; CHECK-NEXT:    jo .Ltmp3
; CHECK-NEXT:    retq
  %add = call { i32, i1 } @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)
  %overflow = extractvalue { i32, i1 } %add, 1
  tail call void @llvm.cond.loop(i1 %overflow)
  ret void
}
