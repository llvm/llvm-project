; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -mtriple=x86_64-unknown-unknown -select-optimize -S < %s | FileCheck %s

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test base heuristic 1:
;; highly-biased selects assumed to be highly predictable, converted to branches
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; If a select is obviously predictable, turn it into a branch.
define i32 @weighted_select1(i32 %a, i32 %b, i1 %cmp) {
; CHECK-LABEL: @weighted_select1(
; CHECK-NEXT:    [[SEL_FROZEN:%.*]] = freeze i1 [[CMP:%.*]]
; CHECK-NEXT:    br i1 [[SEL_FROZEN]], label [[SELECT_END:%.*]], label [[SELECT_FALSE:%.*]], !prof [[PROF16:![0-9]+]]
; CHECK:       select.false:
; CHECK-NEXT:    br label [[SELECT_END]]
; CHECK:       select.end:
; CHECK-NEXT:    [[SEL:%.*]] = phi i32 [ [[A:%.*]], [[TMP0:%.*]] ], [ [[B:%.*]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %sel = select i1 %cmp, i32 %a, i32 %b, !prof !15
  ret i32 %sel
}

; If a select is obviously predictable (reversed profile weights),
; turn it into a branch.
define i32 @weighted_select2(i32 %a, i32 %b, i1 %cmp) {
; CHECK-LABEL: @weighted_select2(
; CHECK-NEXT:    [[SEL_FROZEN:%.*]] = freeze i1 [[CMP:%.*]]
; CHECK-NEXT:    br i1 [[SEL_FROZEN]], label [[SELECT_END:%.*]], label [[SELECT_FALSE:%.*]], !prof [[PROF17:![0-9]+]]
; CHECK:       select.false:
; CHECK-NEXT:    br label [[SELECT_END]]
; CHECK:       select.end:
; CHECK-NEXT:    [[SEL:%.*]] = phi i32 [ [[A:%.*]], [[TMP0:%.*]] ], [ [[B:%.*]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %sel = select i1 %cmp, i32 %a, i32 %b, !prof !16
  ret i32 %sel
}

; Not obvioulsy predictable select.
define i32 @weighted_select3(i32 %a, i32 %b, i1 %cmp) {
; CHECK-LABEL: @weighted_select3(
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP:%.*]], i32 [[A:%.*]], i32 [[B:%.*]], !prof [[PROF18:![0-9]+]]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %sel = select i1 %cmp, i32 %a, i32 %b, !prof !17
  ret i32 %sel
}

; Unpredictable select should not form a branch.
define i32 @unpred_select(i32 %a, i32 %b, i1 %cmp) {
; CHECK-LABEL: @unpred_select(
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP:%.*]], i32 [[A:%.*]], i32 [[B:%.*]], !unpredictable !19
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %sel = select i1 %cmp, i32 %a, i32 %b, !unpredictable !20
  ret i32 %sel
}

; Predictable select in function with optsize attribute should not form branch.
define i32 @weighted_select_optsize(i32 %a, i32 %b, i1 %cmp) optsize {
; CHECK-LABEL: @weighted_select_optsize(
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP:%.*]], i32 [[A:%.*]], i32 [[B:%.*]], !prof [[PROF16]]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %sel = select i1 %cmp, i32 %a, i32 %b, !prof !15
  ret i32 %sel
}

define i32 @weighted_select_pgso(i32 %a, i32 %b, i1 %cmp) !prof !14 {
; CHECK-LABEL: @weighted_select_pgso(
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP:%.*]], i32 [[A:%.*]], i32 [[B:%.*]], !prof [[PROF16]]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %sel = select i1 %cmp, i32 %a, i32 %b, !prof !15
  ret i32 %sel
}

; If two selects in a row are predictable, turn them into branches.
define i32 @weighted_selects(i32 %a, i32 %b) !prof !19 {
; CHECK-LABEL: @weighted_selects(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[A:%.*]], 0
; CHECK-NEXT:    [[SEL_FROZEN:%.*]] = freeze i1 [[CMP]]
; CHECK-NEXT:    br i1 [[SEL_FROZEN]], label [[SELECT_END:%.*]], label [[SELECT_FALSE:%.*]], !prof [[PROF16]]
; CHECK:       select.false:
; CHECK-NEXT:    br label [[SELECT_END]]
; CHECK:       select.end:
; CHECK-NEXT:    [[SEL:%.*]] = phi i32 [ [[A]], [[TMP0:%.*]] ], [ [[B:%.*]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[SEL]], 0
; CHECK-NEXT:    [[SEL1_FROZEN:%.*]] = freeze i1 [[CMP1]]
; CHECK-NEXT:    br i1 [[SEL1_FROZEN]], label [[SELECT_END1:%.*]], label [[SELECT_FALSE2:%.*]], !prof [[PROF16]]
; CHECK:       select.false2:
; CHECK-NEXT:    br label [[SELECT_END1]]
; CHECK:       select.end1:
; CHECK-NEXT:    [[SEL1:%.*]] = phi i32 [ [[B]], [[SELECT_END]] ], [ [[A]], [[SELECT_FALSE2]] ]
; CHECK-NEXT:    ret i32 [[SEL1]]
;
  %cmp = icmp ne i32 %a, 0
  %sel = select i1 %cmp, i32 %a, i32 %b, !prof !15
  %cmp1 = icmp ne i32 %sel, 0
  %sel1 = select i1 %cmp1, i32 %b, i32 %a, !prof !15
  ret i32 %sel1
}

; If select group predictable, turn it into a branch.
define i32 @weighted_select_group(i32 %a, i32 %b, i32 %c, i1 %cmp) !prof !19 {
; CHECK-LABEL: @weighted_select_group(
; CHECK-NEXT:    [[SEL1_FROZEN:%.*]] = freeze i1 [[CMP:%.*]]
; CHECK-NEXT:    br i1 [[SEL1_FROZEN]], label [[SELECT_END:%.*]], label [[SELECT_FALSE:%.*]], !prof [[PROF16]]
; CHECK:       select.false:
; CHECK-NEXT:    br label [[SELECT_END]]
; CHECK:       select.end:
; CHECK-NEXT:    [[SEL1:%.*]] = phi i32 [ [[A:%.*]], [[TMP0:%.*]] ], [ [[B:%.*]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    [[SEL2:%.*]] = phi i32 [ [[C:%.*]], [[TMP0]] ], [ [[A]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    call void @llvm.dbg.value(metadata i32 [[SEL1]], metadata [[META22:![0-9]+]], metadata !DIExpression()), !dbg [[DBG26:![0-9]+]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[SEL1]], [[SEL2]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
  %sel1 = select i1 %cmp, i32 %a, i32 %b, !prof !15
  call void @llvm.dbg.value(metadata i32 %sel1, metadata !24, metadata !DIExpression()), !dbg !DILocation(scope: !23)
  %sel2 = select i1 %cmp, i32 %c, i32 %a, !prof !15
  %add = add i32 %sel1, %sel2
  ret i32 %add
}

; Predictable select group with intra-group dependence converted to branch
define i32 @select_group_intra_group(i32 %a, i32 %b, i32 %c, i1 %cmp) {
; CHECK-LABEL: @select_group_intra_group(
; CHECK-NEXT:    [[SEL1_FROZEN:%.*]] = freeze i1 [[CMP:%.*]]
; CHECK-NEXT:    br i1 [[SEL1_FROZEN]], label [[SELECT_END:%.*]], label [[SELECT_FALSE:%.*]], !prof [[PROF16]]
; CHECK:       select.false:
; CHECK-NEXT:    br label [[SELECT_END]]
; CHECK:       select.end:
; CHECK-NEXT:    [[SEL1:%.*]] = phi i32 [ [[A:%.*]], [[TMP0:%.*]] ], [ [[B:%.*]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    [[SEL2:%.*]] = phi i32 [ [[C:%.*]], [[TMP0]] ], [ [[B]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[SEL1]], [[SEL2]]
; CHECK-NEXT:    ret i32 [[SUB]]
;
  %sel1 = select i1 %cmp, i32 %a, i32 %b,!prof !15
  %sel2 = select i1 %cmp, i32 %c, i32 %sel1, !prof !15
  %sub = sub i32 %sel1, %sel2
  ret i32 %sub
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test base heuristic 2:
;; look for expensive instructions in the one-use slice of the cold path
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Select with cold one-use load value operand should form branch and
; sink load
define i32 @expensive_val_operand1(i32* nocapture %a, i32 %y, i1 %cmp) {
; CHECK-LABEL: @expensive_val_operand1(
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, i32* [[A:%.*]], align 8
; CHECK-NEXT:    [[SEL_FROZEN:%.*]] = freeze i1 [[CMP:%.*]]
; CHECK-NEXT:    br i1 [[SEL_FROZEN]], label [[SELECT_END:%.*]], label [[SELECT_FALSE:%.*]], !prof [[PROF18]]
; CHECK:       select.false:
; CHECK-NEXT:    br label [[SELECT_END]]
; CHECK:       select.end:
; CHECK-NEXT:    [[SEL:%.*]] = phi i32 [ [[LOAD]], [[TMP0:%.*]] ], [ [[Y:%.*]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %load = load i32, i32* %a, align 8
  %sel = select i1 %cmp, i32 %load, i32 %y, !prof !17
  ret i32 %sel
}

; Expensive hot value operand and cheap cold value operand.
define i32 @expensive_val_operand2(i32* nocapture %a, i32 %x, i1 %cmp) {
; CHECK-LABEL: @expensive_val_operand2(
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, i32* [[A:%.*]], align 8
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP:%.*]], i32 [[X:%.*]], i32 [[LOAD]], !prof [[PROF18]]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %load = load i32, i32* %a, align 8
  %sel = select i1 %cmp, i32 %x, i32 %load, !prof !17
  ret i32 %sel
}

; Cold value operand with load in its one-use dependence slice shoud result
; into a branch with sinked dependence slice.
define i32 @expensive_val_operand3(i32* nocapture %a, i32 %b, i32 %y, i1 %cmp) {
; CHECK-LABEL: @expensive_val_operand3(
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, i32* [[A:%.*]], align 8
; CHECK-NEXT:    [[X:%.*]] = add i32 [[LOAD]], [[B:%.*]]
; CHECK-NEXT:    [[SEL_FROZEN:%.*]] = freeze i1 [[CMP:%.*]]
; CHECK-NEXT:    br i1 [[SEL_FROZEN]], label [[SELECT_END:%.*]], label [[SELECT_FALSE:%.*]], !prof [[PROF18]]
; CHECK:       select.false:
; CHECK-NEXT:    br label [[SELECT_END]]
; CHECK:       select.end:
; CHECK-NEXT:    [[SEL:%.*]] = phi i32 [ [[X]], [[TMP0:%.*]] ], [ [[Y:%.*]], [[SELECT_FALSE]] ]
; CHECK-NEXT:    ret i32 [[SEL]]
;
  %load = load i32, i32* %a, align 8
  %x = add i32 %load, %b
  %sel = select i1 %cmp, i32 %x, i32 %y, !prof !17
  ret i32 %sel
}

; Multiple uses of the load value operand.
define i32 @expensive_val_operand4(i32 %a, i32* nocapture %b, i32 %x, i1 %cmp) {
; CHECK-LABEL: @expensive_val_operand4(
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, i32* [[B:%.*]], align 4
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[CMP:%.*]], i32 [[X:%.*]], i32 [[LOAD]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[SEL]], [[LOAD]]
; CHECK-NEXT:    ret i32 [[ADD]]
;
  %load = load i32, i32* %b, align 4
  %sel = select i1 %cmp, i32 %x, i32 %load
  %add = add i32 %sel, %load
  ret i32 %add
}

; Function Attrs: nounwind readnone speculatable willreturn
declare void @llvm.dbg.value(metadata, metadata, metadata)

!llvm.module.flags = !{!0, !26, !27}
!0 = !{i32 1, !"ProfileSummary", !1}
!1 = !{!2, !3, !4, !5, !6, !7, !8, !9}
!2 = !{!"ProfileFormat", !"InstrProf"}
!3 = !{!"TotalCount", i64 10000}
!4 = !{!"MaxCount", i64 10}
!5 = !{!"MaxInternalCount", i64 1}
!6 = !{!"MaxFunctionCount", i64 1000}
!7 = !{!"NumCounts", i64 3}
!8 = !{!"NumFunctions", i64 3}
!9 = !{!"DetailedSummary", !10}
!10 = !{!11, !12, !13}
!11 = !{i32 10000, i64 100, i32 1}
!12 = !{i32 999000, i64 100, i32 1}
!13 = !{i32 999999, i64 1, i32 2}
!14 = !{!"function_entry_count", i64 0}
!15 = !{!"branch_weights", i32 1, i32 100}
!16 = !{!"branch_weights", i32 100, i32 1}
!17 = !{!"branch_weights", i32 1, i32 99}
!18 = !{!"branch_weights", i32 50, i32 50}
!19 = !{!"function_entry_count", i64 100}
!20 = !{}
!21 = !DIFile(filename: "test.c", directory: "/test")
!22 = distinct !DICompileUnit(language: DW_LANG_C99, file: !21, producer: "clang version 15.0.0", isOptimized: true, emissionKind: FullDebug, globals: !25, splitDebugInlining: false, nameTableKind: None)
!23 = distinct !DISubprogram(name: "test", scope: !21, file: !21, line: 1, unit: !22)
!24 = !DILocalVariable(name: "x", scope: !23)
!25 = !{}
!26 = !{i32 2, !"Dwarf Version", i32 4}
!27 = !{i32 1, !"Debug Info Version", i32 3}
