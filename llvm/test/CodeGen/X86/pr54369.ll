; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-- -O0 < %s | FileCheck %s
; RUN: llc -mtriple=x86_64-- -O0 -mattr=+zu < %s | FileCheck %s -check-prefix=SETZUCC
; RUN: llc -mtriple=x86_64-- -O0 -mattr=+zu,+prefer-legacy-setcc < %s | FileCheck %s -check-prefix=NO-SETZUCC

define i64 @adder(i64 %lhs, i64 %rhs) {
; CHECK-LABEL: adder:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addq %rsi, %rdi
; CHECK-NEXT:    seto %dl
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    # kill: def $rax killed $eax
; CHECK-NEXT:    movl $148, %ecx
; CHECK-NEXT:    testb $1, %dl
; CHECK-NEXT:    cmovneq %rcx, %rax
; CHECK-NEXT:    retq
;
; SETZUCC-LABEL: adder:
; SETZUCC:       # %bb.0:
; SETZUCC-NEXT:    addq %rsi, %rdi
; SETZUCC-NEXT:    setzuo %dl
; SETZUCC-NEXT:    xorl %eax, %eax
; SETZUCC-NEXT:    # kill: def $rax killed $eax
; SETZUCC-NEXT:    movl $148, %ecx
; SETZUCC-NEXT:    testb $1, %dl
; SETZUCC-NEXT:    cmovneq %rcx, %rax
; SETZUCC-NEXT:    retq
;
; NO-SETZUCC-LABEL: adder:
; NO-SETZUCC:       # %bb.0:
; NO-SETZUCC-NEXT:    addq %rsi, %rdi
; NO-SETZUCC-NEXT:    seto %dl
; NO-SETZUCC-NEXT:    xorl %eax, %eax
; NO-SETZUCC-NEXT:    # kill: def $rax killed $eax
; NO-SETZUCC-NEXT:    movl $148, %ecx
; NO-SETZUCC-NEXT:    testb $1, %dl
; NO-SETZUCC-NEXT:    cmovneq %rcx, %rax
; NO-SETZUCC-NEXT:    retq
	%res = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %lhs, i64 %rhs)
	%errorbit = extractvalue { i64, i1 } %res, 1
	%errorval = select i1 %errorbit, i64 148, i64 0
	ret i64 %errorval
}

@a = global i32 0, align 4

define i64 @adder_constexpr(i64 %lhs, i64 %rhs) {
; CHECK-LABEL: adder_constexpr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addq %rsi, %rdi
; CHECK-NEXT:    seto %dl
; CHECK-NEXT:    movq a@GOTPCREL(%rip), %rax
; CHECK-NEXT:    addq $5, %rax
; CHECK-NEXT:    movl $148, %ecx
; CHECK-NEXT:    testb $1, %dl
; CHECK-NEXT:    cmovneq %rcx, %rax
; CHECK-NEXT:    retq
;
; SETZUCC-LABEL: adder_constexpr:
; SETZUCC:       # %bb.0:
; SETZUCC-NEXT:    addq %rsi, %rdi
; SETZUCC-NEXT:    setzuo %dl
; SETZUCC-NEXT:    movq a@GOTPCREL(%rip), %rax
; SETZUCC-NEXT:    addq $5, %rax
; SETZUCC-NEXT:    movl $148, %ecx
; SETZUCC-NEXT:    testb $1, %dl
; SETZUCC-NEXT:    cmovneq %rcx, %rax
; SETZUCC-NEXT:    retq
;
; NO-SETZUCC-LABEL: adder_constexpr:
; NO-SETZUCC:       # %bb.0:
; NO-SETZUCC-NEXT:    addq %rsi, %rdi
; NO-SETZUCC-NEXT:    seto %dl
; NO-SETZUCC-NEXT:    movq a@GOTPCREL(%rip), %rax
; NO-SETZUCC-NEXT:    addq $5, %rax
; NO-SETZUCC-NEXT:    movl $148, %ecx
; NO-SETZUCC-NEXT:    testb $1, %dl
; NO-SETZUCC-NEXT:    cmovneq %rcx, %rax
; NO-SETZUCC-NEXT:    retq
  %res = call { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %lhs, i64 %rhs)
  %errorbit = extractvalue { i64, i1 } %res, 1
  %errorval = select i1 %errorbit, i64 148, i64 add (i64 ptrtoint (ptr @a to i64), i64 5)
  ret i64 %errorval
}

declare { i64, i1 } @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)
