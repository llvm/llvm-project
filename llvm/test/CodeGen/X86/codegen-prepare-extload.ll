; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: llc < %s -mtriple=x86_64-linux | FileCheck %s
; RUN: llc < %s -mtriple=x86_64-win64 | FileCheck %s
; RUN: opt -codegenprepare < %s -mtriple=x86_64-apple-macosx -S | FileCheck %s --check-prefix=OPTALL --check-prefix=OPT --check-prefix=NONSTRESS
; RUN: opt -codegenprepare < %s -mtriple=x86_64-apple-macosx -S -stress-cgp-ext-ld-promotion | FileCheck %s --check-prefix=OPTALL --check-prefix=OPT --check-prefix=STRESS
; RUN: opt -codegenprepare < %s -mtriple=x86_64-apple-macosx -S -disable-cgp-ext-ld-promotion | FileCheck %s --check-prefix=OPTALL --check-prefix=DISABLE

; rdar://7304838
; CodeGenPrepare should move the zext into the block with the load
; so that SelectionDAG can select it with the load.
;
; CHECK-LABEL: foo:
; CHECK: movsbl ({{%rdi|%rcx}}), %eax
define void @foo(ptr %p, ptr %q) {
; OPTALL-LABEL: define void @foo(
; OPTALL-SAME: ptr [[P:%.*]], ptr [[Q:%.*]]) {
; OPTALL-NEXT:  entry:
; OPTALL-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; OPTALL-NEXT:    [[S:%.*]] = zext i8 [[T]] to i32
; OPTALL-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; OPTALL-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; OPTALL:       true:
; OPTALL-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; OPTALL-NEXT:    ret void
; OPTALL:       false:
; OPTALL-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = zext i8 %t to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we manage to form a zextload is an operation with only one
; argument to explicitly extend is in the way.
; Make sure the operation is not promoted when the promotion pass is disabled.
define void @promoteOneArg(ptr %p, ptr %q) {
; OPT-LABEL: define void @promoteOneArg(
; OPT-SAME: ptr [[P:%.*]], ptr [[Q:%.*]]) {
; OPT-NEXT:  entry:
; OPT-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; OPT-NEXT:    [[S:%.*]] = zext i8 [[T]] to i32
; OPT-NEXT:    [[ADD:%.*]] = add nuw i32 [[S]], 2
; OPT-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; OPT-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; OPT:       true:
; OPT-NEXT:    store i32 [[ADD]], ptr [[Q]], align 4
; OPT-NEXT:    ret void
; OPT:       false:
; OPT-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteOneArg(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[ADD:%.*]] = add nuw i8 [[T]], 2
; DISABLE-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; DISABLE-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; DISABLE:       true:
; DISABLE-NEXT:    [[S:%.*]] = zext i8 [[ADD]] to i32
; DISABLE-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; DISABLE-NEXT:    ret void
; DISABLE:       false:
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %add = add nuw i8 %t, 2
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = zext i8 %add to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we manage to form a sextload is an operation with only one
; argument to explicitly extend is in the way.
; Version with sext.
define void @promoteOneArgSExt(ptr %p, ptr %q) {
; OPT-LABEL: define void @promoteOneArgSExt(
; OPT-SAME: ptr [[P:%.*]], ptr [[Q:%.*]]) {
; OPT-NEXT:  entry:
; OPT-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; OPT-NEXT:    [[S:%.*]] = sext i8 [[T]] to i32
; OPT-NEXT:    [[ADD:%.*]] = add nsw i32 [[S]], 2
; OPT-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; OPT-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; OPT:       true:
; OPT-NEXT:    store i32 [[ADD]], ptr [[Q]], align 4
; OPT-NEXT:    ret void
; OPT:       false:
; OPT-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteOneArgSExt(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[ADD:%.*]] = add nsw i8 [[T]], 2
; DISABLE-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; DISABLE-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; DISABLE:       true:
; DISABLE-NEXT:    [[S:%.*]] = sext i8 [[ADD]] to i32
; DISABLE-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; DISABLE-NEXT:    ret void
; DISABLE:       false:
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %add = add nsw i8 %t, 2
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = sext i8 %add to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we manage to form a zextload is an operation with two
; arguments to explicitly extend is in the way.
; Extending %add will create two extensions:
; 1. One for %b.
; 2. One for %t.
; #1 will not be removed as we do not know anything about %b.
; #2 may not be merged with the load because %t is used in a comparison.
; Since two extensions may be emitted in the end instead of one before the
; transformation, the regular heuristic does not apply the optimization.
define void @promoteTwoArgZext(ptr %p, ptr %q, i8 %b) {
; NONSTRESS-LABEL: define void @promoteTwoArgZext(
; NONSTRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]]) {
; NONSTRESS-NEXT:  entry:
; NONSTRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; NONSTRESS-NEXT:    [[ADD:%.*]] = add nuw i8 [[T]], [[B]]
; NONSTRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; NONSTRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; NONSTRESS:       true:
; NONSTRESS-NEXT:    [[S:%.*]] = zext i8 [[ADD]] to i32
; NONSTRESS-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; NONSTRESS-NEXT:    ret void
; NONSTRESS:       false:
; NONSTRESS-NEXT:    ret void
;
; STRESS-LABEL: define void @promoteTwoArgZext(
; STRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]]) {
; STRESS-NEXT:  entry:
; STRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; STRESS-NEXT:    [[S:%.*]] = zext i8 [[T]] to i32
; STRESS-NEXT:    [[PROMOTED:%.*]] = zext i8 [[B]] to i32
; STRESS-NEXT:    [[ADD:%.*]] = add nuw i32 [[S]], [[PROMOTED]]
; STRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; STRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; STRESS:       true:
; STRESS-NEXT:    store i32 [[ADD]], ptr [[Q]], align 4
; STRESS-NEXT:    ret void
; STRESS:       false:
; STRESS-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteTwoArgZext(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[ADD:%.*]] = add nuw i8 [[T]], [[B]]
; DISABLE-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; DISABLE-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; DISABLE:       true:
; DISABLE-NEXT:    [[S:%.*]] = zext i8 [[ADD]] to i32
; DISABLE-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; DISABLE-NEXT:    ret void
; DISABLE:       false:
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %add = add nuw i8 %t, %b
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = zext i8 %add to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we manage to form a sextload is an operation with two
; arguments to explicitly extend is in the way.
; Version with sext.
define void @promoteTwoArgSExt(ptr %p, ptr %q, i8 %b) {
; NONSTRESS-LABEL: define void @promoteTwoArgSExt(
; NONSTRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]]) {
; NONSTRESS-NEXT:  entry:
; NONSTRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; NONSTRESS-NEXT:    [[ADD:%.*]] = add nsw i8 [[T]], [[B]]
; NONSTRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; NONSTRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; NONSTRESS:       true:
; NONSTRESS-NEXT:    [[S:%.*]] = sext i8 [[ADD]] to i32
; NONSTRESS-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; NONSTRESS-NEXT:    ret void
; NONSTRESS:       false:
; NONSTRESS-NEXT:    ret void
;
; STRESS-LABEL: define void @promoteTwoArgSExt(
; STRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]]) {
; STRESS-NEXT:  entry:
; STRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; STRESS-NEXT:    [[S:%.*]] = sext i8 [[T]] to i32
; STRESS-NEXT:    [[PROMOTED:%.*]] = sext i8 [[B]] to i32
; STRESS-NEXT:    [[ADD:%.*]] = add nsw i32 [[S]], [[PROMOTED]]
; STRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; STRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; STRESS:       true:
; STRESS-NEXT:    store i32 [[ADD]], ptr [[Q]], align 4
; STRESS-NEXT:    ret void
; STRESS:       false:
; STRESS-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteTwoArgSExt(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[ADD:%.*]] = add nsw i8 [[T]], [[B]]
; DISABLE-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; DISABLE-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; DISABLE:       true:
; DISABLE-NEXT:    [[S:%.*]] = sext i8 [[ADD]] to i32
; DISABLE-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; DISABLE-NEXT:    ret void
; DISABLE:       false:
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %add = add nsw i8 %t, %b
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = sext i8 %add to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we do not a zextload if we need to introduce more than
; one additional extension.
define void @promoteThreeArgZext(ptr %p, ptr %q, i8 %b, i8 %c) {
; NONSTRESS-LABEL: define void @promoteThreeArgZext(
; NONSTRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]], i8 [[C:%.*]]) {
; NONSTRESS-NEXT:  entry:
; NONSTRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; NONSTRESS-NEXT:    [[TMP:%.*]] = add nuw i8 [[T]], [[B]]
; NONSTRESS-NEXT:    [[ADD:%.*]] = add nuw i8 [[TMP]], [[C]]
; NONSTRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; NONSTRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; NONSTRESS:       true:
; NONSTRESS-NEXT:    [[S:%.*]] = zext i8 [[ADD]] to i32
; NONSTRESS-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; NONSTRESS-NEXT:    ret void
; NONSTRESS:       false:
; NONSTRESS-NEXT:    ret void
;
; STRESS-LABEL: define void @promoteThreeArgZext(
; STRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]], i8 [[C:%.*]]) {
; STRESS-NEXT:  entry:
; STRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; STRESS-NEXT:    [[S:%.*]] = zext i8 [[T]] to i32
; STRESS-NEXT:    [[PROMOTED1:%.*]] = zext i8 [[B]] to i32
; STRESS-NEXT:    [[TMP:%.*]] = add nuw i32 [[S]], [[PROMOTED1]]
; STRESS-NEXT:    [[PROMOTED:%.*]] = zext i8 [[C]] to i32
; STRESS-NEXT:    [[ADD:%.*]] = add nuw i32 [[TMP]], [[PROMOTED]]
; STRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; STRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; STRESS:       true:
; STRESS-NEXT:    store i32 [[ADD]], ptr [[Q]], align 4
; STRESS-NEXT:    ret void
; STRESS:       false:
; STRESS-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteThreeArgZext(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i8 [[B:%.*]], i8 [[C:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[TMP:%.*]] = add nuw i8 [[T]], [[B]]
; DISABLE-NEXT:    [[ADD:%.*]] = add nuw i8 [[TMP]], [[C]]
; DISABLE-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; DISABLE-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; DISABLE:       true:
; DISABLE-NEXT:    [[S:%.*]] = zext i8 [[ADD]] to i32
; DISABLE-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; DISABLE-NEXT:    ret void
; DISABLE:       false:
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %tmp = add nuw i8 %t, %b
  %add = add nuw i8 %tmp, %c
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = zext i8 %add to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we manage to form a zextload after promoting and merging
; two extensions.
define void @promoteMergeExtArgZExt(ptr %p, ptr %q, i16 %b) {
; NONSTRESS-LABEL: define void @promoteMergeExtArgZExt(
; NONSTRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i16 [[B:%.*]]) {
; NONSTRESS-NEXT:  entry:
; NONSTRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; NONSTRESS-NEXT:    [[EXT:%.*]] = zext i8 [[T]] to i16
; NONSTRESS-NEXT:    [[ADD:%.*]] = add nuw i16 [[EXT]], [[B]]
; NONSTRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; NONSTRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; NONSTRESS:       true:
; NONSTRESS-NEXT:    [[S:%.*]] = zext i16 [[ADD]] to i32
; NONSTRESS-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; NONSTRESS-NEXT:    ret void
; NONSTRESS:       false:
; NONSTRESS-NEXT:    ret void
;
; STRESS-LABEL: define void @promoteMergeExtArgZExt(
; STRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i16 [[B:%.*]]) {
; STRESS-NEXT:  entry:
; STRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; STRESS-NEXT:    [[PROMOTED1:%.*]] = zext i8 [[T]] to i32
; STRESS-NEXT:    [[PROMOTED:%.*]] = zext i16 [[B]] to i32
; STRESS-NEXT:    [[ADD:%.*]] = add nuw i32 [[PROMOTED1]], [[PROMOTED]]
; STRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; STRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; STRESS:       true:
; STRESS-NEXT:    store i32 [[ADD]], ptr [[Q]], align 4
; STRESS-NEXT:    ret void
; STRESS:       false:
; STRESS-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteMergeExtArgZExt(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i16 [[B:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[EXT:%.*]] = zext i8 [[T]] to i16
; DISABLE-NEXT:    [[ADD:%.*]] = add nuw i16 [[EXT]], [[B]]
; DISABLE-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; DISABLE-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; DISABLE:       true:
; DISABLE-NEXT:    [[S:%.*]] = zext i16 [[ADD]] to i32
; DISABLE-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; DISABLE-NEXT:    ret void
; DISABLE:       false:
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %ext = zext i8 %t to i16
  %add = add nuw i16 %ext, %b
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = zext i16 %add to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we manage to form a sextload after promoting and merging
; two extensions.
; Version with sext.
define void @promoteMergeExtArgSExt(ptr %p, ptr %q, i16 %b) {
; NONSTRESS-LABEL: define void @promoteMergeExtArgSExt(
; NONSTRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i16 [[B:%.*]]) {
; NONSTRESS-NEXT:  entry:
; NONSTRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; NONSTRESS-NEXT:    [[EXT:%.*]] = zext i8 [[T]] to i16
; NONSTRESS-NEXT:    [[ADD:%.*]] = add nsw i16 [[EXT]], [[B]]
; NONSTRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; NONSTRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; NONSTRESS:       true:
; NONSTRESS-NEXT:    [[S:%.*]] = sext i16 [[ADD]] to i32
; NONSTRESS-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; NONSTRESS-NEXT:    ret void
; NONSTRESS:       false:
; NONSTRESS-NEXT:    ret void
;
; STRESS-LABEL: define void @promoteMergeExtArgSExt(
; STRESS-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i16 [[B:%.*]]) {
; STRESS-NEXT:  entry:
; STRESS-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; STRESS-NEXT:    [[PROMOTED1:%.*]] = zext i8 [[T]] to i32
; STRESS-NEXT:    [[PROMOTED:%.*]] = sext i16 [[B]] to i32
; STRESS-NEXT:    [[ADD:%.*]] = add nsw i32 [[PROMOTED1]], [[PROMOTED]]
; STRESS-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; STRESS-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; STRESS:       true:
; STRESS-NEXT:    store i32 [[ADD]], ptr [[Q]], align 4
; STRESS-NEXT:    ret void
; STRESS:       false:
; STRESS-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteMergeExtArgSExt(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i16 [[B:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[EXT:%.*]] = zext i8 [[T]] to i16
; DISABLE-NEXT:    [[ADD:%.*]] = add nsw i16 [[EXT]], [[B]]
; DISABLE-NEXT:    [[A:%.*]] = icmp slt i8 [[T]], 20
; DISABLE-NEXT:    br i1 [[A]], label [[TRUE:%.*]], label [[FALSE:%.*]]
; DISABLE:       true:
; DISABLE-NEXT:    [[S:%.*]] = sext i16 [[ADD]] to i32
; DISABLE-NEXT:    store i32 [[S]], ptr [[Q]], align 4
; DISABLE-NEXT:    ret void
; DISABLE:       false:
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %ext = zext i8 %t to i16
  %add = add nsw i16 %ext, %b
  %a = icmp slt i8 %t, 20
  br i1 %a, label %true, label %false
true:
  %s = sext i16 %add to i32
  store i32 %s, ptr %q
  ret void
false:
  ret void
}

; Check that we manage to catch all the extload opportunities that are exposed
; by the different iterations of codegen prepare.
; Moreover, check that we do not promote more than we need to.
; Here is what is happening in this test (not necessarly in this order):
; 1. We try to promote the operand of %sextadd.
;    a. This creates one sext of %ld2 and one of %zextld
;    b. The sext of %ld2 can be combine with %ld2, so we remove one sext but
;       introduced one. This is fine with the current heuristic: neutral.
;    => We have one zext of %zextld left and we created one sext of %ld2.
; 2. We try to promote the operand of %sextaddza.
;    a. This creates one sext of %zexta and one of %zextld
;    b. The sext of %zexta can be combined with the zext of %a.
;    c. The sext of %zextld leads to %ld and can be combined with it. This is
;       done by promoting %zextld. This is fine with the current heuristic:
;       neutral.
;    => We have created a new zext of %ld and we created one sext of %zexta.
; 3. We try to promote the operand of %sextaddb.
;    a. This creates one sext of %b and one of %zextld
;    b. The sext of %b is a dead-end, nothing to be done.
;    c. Same thing as 2.c. happens.
;    => We have created a new zext of %ld and we created one sext of %b.
; 4. We try to promote the operand of the zext of %zextld introduced in #1.
;    a. Same thing as 2.c. happens.
;    b. %zextld does not have any other uses. It is dead coded.
;    => We have created a new zext of %ld and we removed a zext of %zextld and
;       a zext of %ld.
; Currently we do not try to reuse existing extensions, so in the end we have
; 3 identical zext of %ld. The extensions will be CSE'ed by SDag.
define void @severalPromotions(ptr %addr1, ptr %addr2, i8 %a, i32 %b) {
; OPT-LABEL: define void @severalPromotions(
; OPT-SAME: ptr [[ADDR1:%.*]], ptr [[ADDR2:%.*]], i8 [[A:%.*]], i32 [[B:%.*]]) {
; OPT-NEXT:    [[LD:%.*]] = load i8, ptr [[ADDR1]], align 1
; OPT-NEXT:    [[PROMOTED4:%.*]] = zext i8 [[LD]] to i64
; OPT-NEXT:    [[PROMOTED3:%.*]] = zext i8 [[LD]] to i64
; OPT-NEXT:    [[LD2:%.*]] = load i32, ptr [[ADDR2]], align 4
; OPT-NEXT:    [[SEXTADD:%.*]] = sext i32 [[LD2]] to i64
; OPT-NEXT:    [[PROMOTED1:%.*]] = zext i8 [[LD]] to i64
; OPT-NEXT:    [[ADD:%.*]] = add nsw i64 [[SEXTADD]], [[PROMOTED1]]
; OPT-NEXT:    [[PROMOTED2:%.*]] = zext i8 [[A]] to i64
; OPT-NEXT:    [[ADDZA:%.*]] = add nsw i64 [[PROMOTED2]], [[PROMOTED3]]
; OPT-NEXT:    [[SEXTADDB:%.*]] = sext i32 [[B]] to i64
; OPT-NEXT:    [[ADDB:%.*]] = add nsw i64 [[SEXTADDB]], [[PROMOTED4]]
; OPT-NEXT:    call void @dummy(i64 [[ADD]], i64 [[ADDZA]], i64 [[ADDB]])
; OPT-NEXT:    ret void
;
; DISABLE-LABEL: define void @severalPromotions(
; DISABLE-SAME: ptr [[ADDR1:%.*]], ptr [[ADDR2:%.*]], i8 [[A:%.*]], i32 [[B:%.*]]) {
; DISABLE-NEXT:    [[LD:%.*]] = load i8, ptr [[ADDR1]], align 1
; DISABLE-NEXT:    [[ZEXTLD:%.*]] = zext i8 [[LD]] to i32
; DISABLE-NEXT:    [[LD2:%.*]] = load i32, ptr [[ADDR2]], align 4
; DISABLE-NEXT:    [[ADD:%.*]] = add nsw i32 [[LD2]], [[ZEXTLD]]
; DISABLE-NEXT:    [[SEXTADD:%.*]] = sext i32 [[ADD]] to i64
; DISABLE-NEXT:    [[ZEXTA:%.*]] = zext i8 [[A]] to i32
; DISABLE-NEXT:    [[ADDZA:%.*]] = add nsw i32 [[ZEXTA]], [[ZEXTLD]]
; DISABLE-NEXT:    [[SEXTADDZA:%.*]] = sext i32 [[ADDZA]] to i64
; DISABLE-NEXT:    [[ADDB:%.*]] = add nsw i32 [[B]], [[ZEXTLD]]
; DISABLE-NEXT:    [[SEXTADDB:%.*]] = sext i32 [[ADDB]] to i64
; DISABLE-NEXT:    call void @dummy(i64 [[SEXTADD]], i64 [[SEXTADDZA]], i64 [[SEXTADDB]])
; DISABLE-NEXT:    ret void
;
  %ld = load i8, ptr %addr1
  %zextld = zext i8 %ld to i32
  %ld2 = load i32, ptr %addr2
  %add = add nsw i32 %ld2, %zextld
  %sextadd = sext i32 %add to i64
  %zexta = zext i8 %a to i32
  %addza = add nsw i32 %zexta, %zextld
  %sextaddza = sext i32 %addza to i64
  %addb = add nsw i32 %b, %zextld
  %sextaddb = sext i32 %addb to i64
  call void @dummy(i64 %sextadd, i64 %sextaddza, i64 %sextaddb)
  ret void
}

declare void @dummy(i64, i64, i64)

; Make sure we do not try to promote vector types since the type promotion
; helper does not support them for now.
define void @vectorPromotion() {
; OPTALL-LABEL: define void @vectorPromotion() {
; OPTALL-NEXT:  entry:
; OPTALL-NEXT:    [[A:%.*]] = shl nuw nsw <2 x i32> zeroinitializer, <i32 8, i32 8>
; OPTALL-NEXT:    [[B:%.*]] = zext <2 x i32> [[A]] to <2 x i64>
; OPTALL-NEXT:    ret void
;
entry:
  %a = shl nuw nsw <2 x i32> zeroinitializer, <i32 8, i32 8>
  %b = zext <2 x i32> %a to <2 x i64>
  ret void
}

@a = common global i32 0, align 4
@c = common global [2 x i32] zeroinitializer, align 4

; PR21978.
; Make sure we support promotion of operands that produces a Value as opposed
; to an instruction.
; This used to cause a crash.
define i32 @promotionOfArgEndsUpInValue(ptr %addr) {
; OPT-LABEL: define i32 @promotionOfArgEndsUpInValue(
; OPT-SAME: ptr [[ADDR:%.*]]) {
; OPT-NEXT:  entry:
; OPT-NEXT:    [[VAL:%.*]] = load i16, ptr [[ADDR]], align 2
; OPT-NEXT:    [[CONV3:%.*]] = sext i16 [[VAL]] to i32
; OPT-NEXT:    [[PROMOTED:%.*]] = sext i16 zext (i1 icmp ne (ptr getelementptr inbounds ([2 x i32], ptr @c, i64 0, i64 1), ptr @a) to i16) to i32
; OPT-NEXT:    [[ADD:%.*]] = add nuw nsw i32 [[CONV3]], [[PROMOTED]]
; OPT-NEXT:    ret i32 [[ADD]]
;
; DISABLE-LABEL: define i32 @promotionOfArgEndsUpInValue(
; DISABLE-SAME: ptr [[ADDR:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[VAL:%.*]] = load i16, ptr [[ADDR]], align 2
; DISABLE-NEXT:    [[ADD:%.*]] = add nuw nsw i16 [[VAL]], zext (i1 icmp ne (ptr getelementptr inbounds ([2 x i32], ptr @c, i64 0, i64 1), ptr @a) to i16)
; DISABLE-NEXT:    [[CONV3:%.*]] = sext i16 [[ADD]] to i32
; DISABLE-NEXT:    ret i32 [[CONV3]]
;
entry:
  %val = load i16, ptr %addr
  %add = add nuw nsw i16 %val, zext (i1 icmp ne (ptr getelementptr inbounds ([2 x i32], ptr @c, i64 0, i64 1), ptr @a) to i16)
  %conv3 = sext i16 %add to i32
  ret i32 %conv3
}

; Check that we see that one zext can be derived from the other for free.
define void @promoteTwoArgZextWithSourceExtendedTwice(ptr %p, ptr %q, i32 %b, ptr %addr) {
; OPT-LABEL: define void @promoteTwoArgZextWithSourceExtendedTwice(
; OPT-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i32 [[B:%.*]], ptr [[ADDR:%.*]]) {
; OPT-NEXT:  entry:
; OPT-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; OPT-NEXT:    [[PROMOTED:%.*]] = zext i8 [[T]] to i64
; OPT-NEXT:    [[ZEXTT:%.*]] = zext i8 [[T]] to i32
; OPT-NEXT:    [[ADD:%.*]] = add nuw i32 [[ZEXTT]], [[B]]
; OPT-NEXT:    [[ADD2:%.*]] = add nuw i64 [[PROMOTED]], 12
; OPT-NEXT:    store i32 [[ADD]], ptr [[ADDR]], align 4
; OPT-NEXT:    store i64 [[ADD2]], ptr [[Q]], align 8
; OPT-NEXT:    ret void
;
; DISABLE-LABEL: define void @promoteTwoArgZextWithSourceExtendedTwice(
; DISABLE-SAME: ptr [[P:%.*]], ptr [[Q:%.*]], i32 [[B:%.*]], ptr [[ADDR:%.*]]) {
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[T:%.*]] = load i8, ptr [[P]], align 1
; DISABLE-NEXT:    [[ZEXTT:%.*]] = zext i8 [[T]] to i32
; DISABLE-NEXT:    [[ADD:%.*]] = add nuw i32 [[ZEXTT]], [[B]]
; DISABLE-NEXT:    [[ADD2:%.*]] = add nuw i32 [[ZEXTT]], 12
; DISABLE-NEXT:    store i32 [[ADD]], ptr [[ADDR]], align 4
; DISABLE-NEXT:    [[S:%.*]] = zext i32 [[ADD2]] to i64
; DISABLE-NEXT:    store i64 [[S]], ptr [[Q]], align 8
; DISABLE-NEXT:    ret void
;
entry:
  %t = load i8, ptr %p
  %zextt = zext i8 %t to i32
  %add = add nuw i32 %zextt, %b
  %add2 = add nuw i32 %zextt, 12
  store i32 %add, ptr%addr
  %s = zext i32 %add2 to i64
  store i64 %s, ptr %q
  ret void
}
