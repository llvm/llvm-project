; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse2,+bmi2 | FileCheck %s

declare i32 @llvm.x86.bmi.bzhi.32(i32, i32) nounwind readnone
declare i64 @llvm.x86.bmi.bzhi.64(i64, i64) nounwind readnone

define i32 @test_bzhi32_zero(i32 %a) nounwind {
; CHECK-LABEL: test_bzhi32_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
  %1 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 %a, i32 0)
  ret i32 %1
}

define i64 @test_bzhi64_zero(i64 %a) nounwind readnone {
; CHECK-LABEL: test_bzhi64_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
  %1 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 %a, i64 0)
  ret i64 %1
}

define i32 @test_bzhi32_constfold() nounwind readnone {
; CHECK-LABEL: test_bzhi32_constfold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    retq
  %1 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 5, i32 1)
  ret i32 %1
}

define i64 @test_bzhi64_constfold() nounwind readnone {
; CHECK-LABEL: test_bzhi64_constfold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    retq
  %1 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 5, i64 1)
  ret i64 %1
}

define i32 @test_bzhi32_minvaluefold(i32 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi32_minvaluefold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $5, %eax
; CHECK-NEXT:    retq
  %2 = or i32 %arg, 32
  %3 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 5, i32 %2)
  ret i32 %3
}

define i64 @test_bzhi64_minvaluefold(i64 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi64_minvaluefold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movabsq $30064771072, %rax # imm = 0x700000000
; CHECK-NEXT:    retq
  %2 = or i64 %arg, 64
  %3 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 30064771072, i64 %2)
  ret i64 %3
}

define i32 @test_bzhi32_range(i32 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi32_range:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $42, %eax
; CHECK-NEXT:    retq
  %2 = or i32 %arg, 6
  %3 = and i32 %2, 7
  %4 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 699050, i32 %3)
  ret i32 %4
}

define i64 @test_bzhi64_range(i64 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi64_range:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $40, %eax
; CHECK-NEXT:    retq
  %2 = or i64 %arg, 6
  %3 = and i64 %2, 7
  %4 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 30064771240, i64 %3)
  ret i64 %4
}

define i32 @test_bzhi32_mask_const_highbits(i32 %a) nounwind {
; CHECK-LABEL: test_bzhi32_mask_const_highbits:
; CHECK-NOT:   $257
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    bzhil
; CHECK-NEXT:    retq
  %1 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 %a, i32 257)
  ret i32 %1
}

define i64 @test_bzhi64_mask_const_highbits(i64 %a) nounwind {
; CHECK-LABEL: test_bzhi64_mask_const_highbits:
; CHECK-NOT:   $257
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    bzhiq
; CHECK-NEXT:    retq
  %1 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 %a, i64 257)
  ret i64 %1
}

define i32 @test_bzhi32_rule2_mask_max31_kills_topbit(i32 %a, i32 %m) nounwind {
; CHECK-LABEL: test_bzhi32_rule2_mask_max31_kills_topbit:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andl $31, %esi
; CHECK-NEXT:    bzhil
; CHECK-NEXT:    retq
  %mask = and i32 %m, 31
  %hi  = shl i32 %a, 31
  %src = or i32 %a, %hi
  %r = tail call i32 @llvm.x86.bmi.bzhi.32(i32 %src, i32 %mask)
  ret i32 %r
}

define i64 @test_bzhi64_rule2_mask_max63_kills_topbit(i64 %a, i64 %m) nounwind {
; CHECK-LABEL: test_bzhi64_rule2_mask_max63_kills_topbit:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andl $63, %esi
; CHECK-NEXT:    bzhiq
; CHECK-NEXT:    retq
  %mask = and i64 %m, 63
  %hi  = shl i64 %a, 63
  %src = or i64 %a, %hi
  %r = tail call i64 @llvm.x86.bmi.bzhi.64(i64 %src, i64 %mask)
  ret i64 %r
}
