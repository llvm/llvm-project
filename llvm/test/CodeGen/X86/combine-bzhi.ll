; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+sse2,+bmi2 | FileCheck %s

declare i32 @llvm.x86.bmi.bzhi.32(i32, i32) nounwind readnone
declare i64 @llvm.x86.bmi.bzhi.64(i64, i64) nounwind readnone

define i32 @test_bzhi32_zero(i32 %a) nounwind {
; CHECK-LABEL: test_bzhi32_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
  %1 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 %a, i32 0)
  ret i32 %1
}

define i64 @test_bzhi64_zero(i64 %a) nounwind readnone {
; CHECK-LABEL: test_bzhi64_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
  %1 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 %a, i64 0)
  ret i64 %1
}

define i32 @test_bzhi32_constfold() nounwind readnone {
; CHECK-LABEL: test_bzhi32_constfold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    retq
  %1 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 5, i32 1)
  ret i32 %1
}

define i64 @test_bzhi64_constfold() nounwind readnone {
; CHECK-LABEL: test_bzhi64_constfold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    retq
  %1 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 5, i64 1)
  ret i64 %1
}

define i32 @test_bzhi32_minvaluefold(i32 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi32_minvaluefold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $5, %eax
; CHECK-NEXT:    retq
  %2 = or i32 %arg, 32
  %3 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 5, i32 %2)
  ret i32 %3
}

define i64 @test_bzhi64_minvaluefold(i64 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi64_minvaluefold:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movabsq $30064771072, %rax # imm = 0x700000000
; CHECK-NEXT:    retq
  %2 = or i64 %arg, 64
  %3 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 30064771072, i64 %2)
  ret i64 %3
}

define i32 @test_bzhi32_range(i32 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi32_range:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $42, %eax
; CHECK-NEXT:    retq
  %2 = or i32 %arg, 6
  %3 = and i32 %2, 7
  %4 = tail call i32 @llvm.x86.bmi.bzhi.32(i32 699050, i32 %3)
  ret i32 %4
}

define i64 @test_bzhi64_range(i64 %arg) nounwind readnone {
; CHECK-LABEL: test_bzhi64_range:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl $40, %eax
; CHECK-NEXT:    retq
  %2 = or i64 %arg, 6
  %3 = and i64 %2, 7
  %4 = tail call i64 @llvm.x86.bmi.bzhi.64(i64 30064771240, i64 %3)
  ret i64 %4
}
