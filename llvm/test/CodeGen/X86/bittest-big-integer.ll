; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i686--                   | FileCheck %s --check-prefixes=X86
; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64    | FileCheck %s --check-prefixes=X64,SSE
; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64-v2 | FileCheck %s --check-prefixes=X64,SSE
; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64-v3 | FileCheck %s --check-prefixes=X64,AVX,AVX2
; RUN: llc < %s -mtriple=x86_64-- -mcpu=x86-64-v4 | FileCheck %s --check-prefixes=X64,AVX,AVX512

; bt/btc/btr/bts patterns + 'init' to set single bit value in large integers

;
; i32 bt/btc/btr/bts + init (reference)
;

define i1 @test_eq_i32(ptr %word, i32 %position) nounwind {
; X86-LABEL: test_eq_i32:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl (%eax), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    btl %ecx, %eax
; X86-NEXT:    setae %al
; X86-NEXT:    retl
;
; X64-LABEL: test_eq_i32:
; X64:       # %bb.0:
; X64-NEXT:    movl (%rdi), %eax
; X64-NEXT:    btl %esi, %eax
; X64-NEXT:    setae %al
; X64-NEXT:    retq
  %rem = and i32 %position, 31
  %bit = shl nuw i32 1, %rem
  %ld = load i32, ptr %word
  %test = and i32 %ld, %bit
  %cmp = icmp eq i32 %test, 0
  ret i1 %cmp
}

define i1 @complement_ne_i32(ptr %word, i32 %position) nounwind {
; X86-LABEL: complement_ne_i32:
; X86:       # %bb.0:
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%ecx), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    btcl %eax, %esi
; X86-NEXT:    btl %eax, %edx
; X86-NEXT:    setb %al
; X86-NEXT:    movl %esi, (%ecx)
; X86-NEXT:    popl %esi
; X86-NEXT:    retl
;
; X64-LABEL: complement_ne_i32:
; X64:       # %bb.0:
; X64-NEXT:    movl (%rdi), %eax
; X64-NEXT:    movl %eax, %ecx
; X64-NEXT:    btcl %esi, %ecx
; X64-NEXT:    btl %esi, %eax
; X64-NEXT:    setb %al
; X64-NEXT:    movl %ecx, (%rdi)
; X64-NEXT:    retq
  %ofs = and i32 %position, 31
  %bit = shl nuw i32 1, %ofs
  %ld = load i32, ptr %word
  %test = and i32 %ld, %bit
  %res = xor i32 %ld, %bit
  %cmp = icmp ne i32 %test, 0
  store i32 %res, ptr %word
  ret i1 %cmp
}

define i1 @reset_eq_i32(ptr %word, i32 %position) nounwind {
; X86-LABEL: reset_eq_i32:
; X86:       # %bb.0:
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%ecx), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    btrl %eax, %esi
; X86-NEXT:    btl %eax, %edx
; X86-NEXT:    setae %al
; X86-NEXT:    movl %esi, (%ecx)
; X86-NEXT:    popl %esi
; X86-NEXT:    retl
;
; X64-LABEL: reset_eq_i32:
; X64:       # %bb.0:
; X64-NEXT:    movl (%rdi), %eax
; X64-NEXT:    movl %eax, %ecx
; X64-NEXT:    btrl %esi, %ecx
; X64-NEXT:    btl %esi, %eax
; X64-NEXT:    setae %al
; X64-NEXT:    movl %ecx, (%rdi)
; X64-NEXT:    retq
  %ofs = and i32 %position, 31
  %bit = shl nuw i32 1, %ofs
  %mask = xor i32 %bit, -1
  %ld = load i32, ptr %word
  %test = and i32 %ld, %bit
  %res = and i32 %ld, %mask
  %cmp = icmp eq i32 %test, 0
  store i32 %res, ptr %word
  ret i1 %cmp
}

define i1 @set_ne_i32(ptr %word, i32 %position) nounwind {
; X86-LABEL: set_ne_i32:
; X86:       # %bb.0:
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%ecx), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    btsl %eax, %esi
; X86-NEXT:    btl %eax, %edx
; X86-NEXT:    setb %al
; X86-NEXT:    movl %esi, (%ecx)
; X86-NEXT:    popl %esi
; X86-NEXT:    retl
;
; X64-LABEL: set_ne_i32:
; X64:       # %bb.0:
; X64-NEXT:    movl (%rdi), %eax
; X64-NEXT:    movl %eax, %ecx
; X64-NEXT:    btsl %esi, %ecx
; X64-NEXT:    btl %esi, %eax
; X64-NEXT:    setb %al
; X64-NEXT:    movl %ecx, (%rdi)
; X64-NEXT:    retq
  %ofs = and i32 %position, 31
  %bit = shl nuw i32 1, %ofs
  %ld = load i32, ptr %word
  %test = and i32 %ld, %bit
  %res = or i32 %ld, %bit
  %cmp = icmp ne i32 %test, 0
  store i32 %res, ptr %word
  ret i1 %cmp
}

define i1 @init_eq_i32(ptr %word, i32 %position, i1 zeroext %value) nounwind {
; X86-LABEL: init_eq_i32:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    shll %cl, %eax
; X86-NEXT:    movl (%edx), %esi
; X86-NEXT:    movl %esi, %edi
; X86-NEXT:    btrl %ecx, %edi
; X86-NEXT:    orl %eax, %edi
; X86-NEXT:    btl %ecx, %esi
; X86-NEXT:    setae %al
; X86-NEXT:    movl %edi, (%edx)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; SSE-LABEL: init_eq_i32:
; SSE:       # %bb.0:
; SSE-NEXT:    movl %esi, %ecx
; SSE-NEXT:    shll %cl, %edx
; SSE-NEXT:    movl (%rdi), %eax
; SSE-NEXT:    movl %eax, %esi
; SSE-NEXT:    btrl %ecx, %esi
; SSE-NEXT:    orl %edx, %esi
; SSE-NEXT:    btl %ecx, %eax
; SSE-NEXT:    setae %al
; SSE-NEXT:    movl %esi, (%rdi)
; SSE-NEXT:    retq
;
; AVX-LABEL: init_eq_i32:
; AVX:       # %bb.0:
; AVX-NEXT:    shlxl %esi, %edx, %eax
; AVX-NEXT:    movl (%rdi), %ecx
; AVX-NEXT:    movl %ecx, %edx
; AVX-NEXT:    btrl %esi, %edx
; AVX-NEXT:    orl %eax, %edx
; AVX-NEXT:    btl %esi, %ecx
; AVX-NEXT:    setae %al
; AVX-NEXT:    movl %edx, (%rdi)
; AVX-NEXT:    retq
  %ofs = and i32 %position, 31
  %bit = shl nuw i32 1, %ofs
  %mask = xor i32 %bit, -1
  %val0 = zext i1 %value to i32
  %val = shl nuw i32 %val0, %ofs
  %ld = load i32, ptr %word
  %test = and i32 %ld, %bit
  %res0 = and i32 %ld, %mask
  %res = or i32 %res0, %val
  %cmp = icmp eq i32 %test, 0
  store i32 %res, ptr %word
  ret i1 %cmp
}

;
; i64 bt/btc/btr/bts + init
;

define i1 @test_ne_i64(ptr %word, i32 %position) nounwind {
; X86-LABEL: test_ne_i64:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl %ecx, %edx
; X86-NEXT:    andl $32, %edx
; X86-NEXT:    shrl $3, %edx
; X86-NEXT:    movl (%eax,%edx), %eax
; X86-NEXT:    btl %ecx, %eax
; X86-NEXT:    setb %al
; X86-NEXT:    retl
;
; X64-LABEL: test_ne_i64:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    movq (%rdi), %rax
; X64-NEXT:    btq %rsi, %rax
; X64-NEXT:    setb %al
; X64-NEXT:    retq
  %rem = and i32 %position, 63
  %ofs = zext nneg i32 %rem to i64
  %bit = shl nuw i64 1, %ofs
  %ld = load i64, ptr %word
  %test = and i64 %ld, %bit
  %cmp = icmp ne i64 %test, 0
  ret i1 %cmp
}

define i1 @complement_ne_i64(ptr %word, i32 %position) nounwind {
; X86-LABEL: complement_ne_i64:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    andl $32, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setb %al
; X86-NEXT:    btcl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: complement_ne_i64:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    movq (%rdi), %rax
; X64-NEXT:    movq %rax, %rcx
; X64-NEXT:    btcq %rsi, %rcx
; X64-NEXT:    btq %rsi, %rax
; X64-NEXT:    setb %al
; X64-NEXT:    movq %rcx, (%rdi)
; X64-NEXT:    retq
  %rem = and i32 %position, 63
  %ofs = zext nneg i32 %rem to i64
  %bit = shl nuw i64 1, %ofs
  %ld = load i64, ptr %word
  %test = and i64 %ld, %bit
  %res = xor i64 %ld, %bit
  %cmp = icmp ne i64 %test, 0
  store i64 %res, ptr %word
  ret i1 %cmp
}

define i1 @reset_eq_i64(ptr %word, i32 %position) nounwind {
; X86-LABEL: reset_eq_i64:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    andl $32, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setae %al
; X86-NEXT:    btrl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: reset_eq_i64:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    movq (%rdi), %rax
; X64-NEXT:    movq %rax, %rcx
; X64-NEXT:    btrq %rsi, %rcx
; X64-NEXT:    btq %rsi, %rax
; X64-NEXT:    setae %al
; X64-NEXT:    movq %rcx, (%rdi)
; X64-NEXT:    retq
  %rem = and i32 %position, 63
  %ofs = zext nneg i32 %rem to i64
  %bit = shl nuw i64 1, %ofs
  %mask = xor i64 %bit, -1
  %ld = load i64, ptr %word
  %test = and i64 %ld, %bit
  %res = and i64 %ld, %mask
  %cmp = icmp eq i64 %test, 0
  store i64 %res, ptr %word
  ret i1 %cmp
}

define i1 @set_ne_i64(ptr %word, i32 %position) nounwind {
; X86-LABEL: set_ne_i64:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    andl $32, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setb %al
; X86-NEXT:    btsl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: set_ne_i64:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    movq (%rdi), %rax
; X64-NEXT:    movq %rax, %rcx
; X64-NEXT:    btsq %rsi, %rcx
; X64-NEXT:    btq %rsi, %rax
; X64-NEXT:    setb %al
; X64-NEXT:    movq %rcx, (%rdi)
; X64-NEXT:    retq
  %rem = and i32 %position, 63
  %ofs = zext nneg i32 %rem to i64
  %bit = shl nuw i64 1, %ofs
  %ld = load i64, ptr %word
  %test = and i64 %ld, %bit
  %res = or i64 %ld, %bit
  %cmp = icmp ne i64 %test, 0
  store i64 %res, ptr %word
  ret i1 %cmp
}

define i1 @init_eq_i64(ptr %word, i32 %position, i1 zeroext %value) nounwind {
; X86-LABEL: init_eq_i64:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl %ecx, %esi
; X86-NEXT:    andl $32, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%edx,%esi), %edi
; X86-NEXT:    btl %ecx, %edi
; X86-NEXT:    setae %al
; X86-NEXT:    btrl %ecx, %edi
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %ebx
; X86-NEXT:    # kill: def $cl killed $cl killed $ecx
; X86-NEXT:    shll %cl, %ebx
; X86-NEXT:    orl %edi, %ebx
; X86-NEXT:    movl %ebx, (%edx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    retl
;
; SSE-LABEL: init_eq_i64:
; SSE:       # %bb.0:
; SSE-NEXT:    movl %esi, %ecx
; SSE-NEXT:    movl %edx, %eax
; SSE-NEXT:    shlq %cl, %rax
; SSE-NEXT:    movq (%rdi), %rdx
; SSE-NEXT:    movq %rdx, %rsi
; SSE-NEXT:    btrq %rcx, %rsi
; SSE-NEXT:    orq %rax, %rsi
; SSE-NEXT:    btq %rcx, %rdx
; SSE-NEXT:    setae %al
; SSE-NEXT:    movq %rsi, (%rdi)
; SSE-NEXT:    retq
;
; AVX-LABEL: init_eq_i64:
; AVX:       # %bb.0:
; AVX-NEXT:    # kill: def $esi killed $esi def $rsi
; AVX-NEXT:    movl %edx, %eax
; AVX-NEXT:    shlxq %rsi, %rax, %rax
; AVX-NEXT:    movq (%rdi), %rcx
; AVX-NEXT:    movq %rcx, %rdx
; AVX-NEXT:    btrq %rsi, %rdx
; AVX-NEXT:    orq %rax, %rdx
; AVX-NEXT:    btq %rsi, %rcx
; AVX-NEXT:    setae %al
; AVX-NEXT:    movq %rdx, (%rdi)
; AVX-NEXT:    retq
  %rem = and i32 %position, 63
  %ofs = zext nneg i32 %rem to i64
  %bit = shl nuw i64 1, %ofs
  %mask = xor i64 %bit, -1
  %val0 = zext i1 %value to i64
  %val = shl nuw i64 %val0, %ofs
  %ld = load i64, ptr %word
  %test = and i64 %ld, %bit
  %res0 = and i64 %ld, %mask
  %res = or i64 %res0, %val
  %cmp = icmp eq i64 %test, 0
  store i64 %res, ptr %word
  ret i1 %cmp
}

;
; i128
;

define i1 @test_ne_i128(ptr %word, i32 %position) nounwind {
; X86-LABEL: test_ne_i128:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl %ecx, %edx
; X86-NEXT:    andl $96, %edx
; X86-NEXT:    shrl $3, %edx
; X86-NEXT:    movl (%eax,%edx), %eax
; X86-NEXT:    btl %ecx, %eax
; X86-NEXT:    setb %al
; X86-NEXT:    retl
;
; X64-LABEL: test_ne_i128:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %eax
; X64-NEXT:    andl $96, %eax
; X64-NEXT:    shrl $3, %eax
; X64-NEXT:    movl (%rdi,%rax), %eax
; X64-NEXT:    btl %esi, %eax
; X64-NEXT:    setb %al
; X64-NEXT:    retq
  %rem = and i32 %position, 127
  %ofs = zext nneg i32 %rem to i128
  %bit = shl nuw i128 1, %ofs
  %ld = load i128, ptr %word
  %test = and i128 %ld, %bit
  %cmp = icmp ne i128 %test, 0
  ret i1 %cmp
}

define i1 @complement_ne_i128(ptr %word, i32 %position) nounwind {
; X86-LABEL: complement_ne_i128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    andl $96, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setb %al
; X86-NEXT:    btcl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: complement_ne_i128:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    andl $96, %ecx
; X64-NEXT:    shrl $3, %ecx
; X64-NEXT:    movl (%rdi,%rcx), %edx
; X64-NEXT:    btl %esi, %edx
; X64-NEXT:    setb %al
; X64-NEXT:    btcl %esi, %edx
; X64-NEXT:    movl %edx, (%rdi,%rcx)
; X64-NEXT:    retq
  %rem = and i32 %position, 127
  %ofs = zext nneg i32 %rem to i128
  %bit = shl nuw i128 1, %ofs
  %ld = load i128, ptr %word
  %test = and i128 %ld, %bit
  %res = xor i128 %ld, %bit
  %cmp = icmp ne i128 %test, 0
  store i128 %res, ptr %word
  ret i1 %cmp
}

define i1 @reset_eq_i128(ptr %word, i32 %position) nounwind {
; X86-LABEL: reset_eq_i128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    andl $96, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setae %al
; X86-NEXT:    btrl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: reset_eq_i128:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    andl $96, %ecx
; X64-NEXT:    shrl $3, %ecx
; X64-NEXT:    movl (%rdi,%rcx), %edx
; X64-NEXT:    btl %esi, %edx
; X64-NEXT:    setae %al
; X64-NEXT:    btrl %esi, %edx
; X64-NEXT:    movl %edx, (%rdi,%rcx)
; X64-NEXT:    retq
  %rem = and i32 %position, 127
  %ofs = zext nneg i32 %rem to i128
  %bit = shl nuw i128 1, %ofs
  %mask = xor i128 %bit, -1
  %ld = load i128, ptr %word
  %test = and i128 %ld, %bit
  %res = and i128 %ld, %mask
  %cmp = icmp eq i128 %test, 0
  store i128 %res, ptr %word
  ret i1 %cmp
}

define i1 @set_ne_i128(ptr %word, i32 %position) nounwind {
; X86-LABEL: set_ne_i128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    andl $96, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setb %al
; X86-NEXT:    btsl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: set_ne_i128:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    andl $96, %ecx
; X64-NEXT:    shrl $3, %ecx
; X64-NEXT:    movl (%rdi,%rcx), %edx
; X64-NEXT:    btl %esi, %edx
; X64-NEXT:    setb %al
; X64-NEXT:    btsl %esi, %edx
; X64-NEXT:    movl %edx, (%rdi,%rcx)
; X64-NEXT:    retq
  %rem = and i32 %position, 127
  %ofs = zext nneg i32 %rem to i128
  %bit = shl nuw i128 1, %ofs
  %ld = load i128, ptr %word
  %test = and i128 %ld, %bit
  %res = or i128 %ld, %bit
  %cmp = icmp ne i128 %test, 0
  store i128 %res, ptr %word
  ret i1 %cmp
}

define i1 @init_eq_i128(ptr %word, i32 %position, i1 zeroext %value) nounwind {
; X86-LABEL: init_eq_i128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl %ecx, %esi
; X86-NEXT:    andl $96, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    movl (%edx,%esi), %edi
; X86-NEXT:    btl %ecx, %edi
; X86-NEXT:    setae %al
; X86-NEXT:    btrl %ecx, %edi
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %ebx
; X86-NEXT:    # kill: def $cl killed $cl killed $ecx
; X86-NEXT:    shll %cl, %ebx
; X86-NEXT:    orl %edi, %ebx
; X86-NEXT:    movl %ebx, (%edx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    retl
;
; SSE-LABEL: init_eq_i128:
; SSE:       # %bb.0:
; SSE-NEXT:    movl %esi, %ecx
; SSE-NEXT:    andl $96, %esi
; SSE-NEXT:    shrl $3, %esi
; SSE-NEXT:    movl (%rdi,%rsi), %r8d
; SSE-NEXT:    btl %ecx, %r8d
; SSE-NEXT:    setae %al
; SSE-NEXT:    shll %cl, %edx
; SSE-NEXT:    btrl %ecx, %r8d
; SSE-NEXT:    orl %r8d, %edx
; SSE-NEXT:    movl %edx, (%rdi,%rsi)
; SSE-NEXT:    retq
;
; AVX-LABEL: init_eq_i128:
; AVX:       # %bb.0:
; AVX-NEXT:    movl %esi, %ecx
; AVX-NEXT:    andl $96, %ecx
; AVX-NEXT:    shrl $3, %ecx
; AVX-NEXT:    movl (%rdi,%rcx), %r8d
; AVX-NEXT:    btl %esi, %r8d
; AVX-NEXT:    setae %al
; AVX-NEXT:    btrl %esi, %r8d
; AVX-NEXT:    shlxl %esi, %edx, %edx
; AVX-NEXT:    orl %r8d, %edx
; AVX-NEXT:    movl %edx, (%rdi,%rcx)
; AVX-NEXT:    retq
  %rem = and i32 %position, 127
  %ofs = zext nneg i32 %rem to i128
  %bit = shl nuw i128 1, %ofs
  %mask = xor i128 %bit, -1
  %val0 = zext i1 %value to i128
  %val = shl nuw i128 %val0, %ofs
  %ld = load i128, ptr %word
  %test = and i128 %ld, %bit
  %res0 = and i128 %ld, %mask
  %res = or i128 %res0, %val
  %cmp = icmp eq i128 %test, 0
  store i128 %res, ptr %word
  ret i1 %cmp
}

; i512

define i1 @test_ne_i512(ptr %word, i32 %position) nounwind {
; X86-LABEL: test_ne_i512:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl %ecx, %edx
; X86-NEXT:    shrl $3, %edx
; X86-NEXT:    andl $60, %edx
; X86-NEXT:    movl (%eax,%edx), %eax
; X86-NEXT:    btl %ecx, %eax
; X86-NEXT:    setb %al
; X86-NEXT:    retl
;
; X64-LABEL: test_ne_i512:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %eax
; X64-NEXT:    shrl $3, %eax
; X64-NEXT:    andl $60, %eax
; X64-NEXT:    movl (%rdi,%rax), %eax
; X64-NEXT:    btl %esi, %eax
; X64-NEXT:    setb %al
; X64-NEXT:    retq
  %rem = and i32 %position, 511
  %ofs = zext nneg i32 %rem to i512
  %bit = shl nuw i512 1, %ofs
  %ld = load i512, ptr %word
  %test = and i512 %ld, %bit
  %cmp = icmp ne i512 %test, 0
  ret i1 %cmp
}

define i1 @complement_ne_i512(ptr %word, i32 %position) nounwind {
; X86-LABEL: complement_ne_i512:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    andl $60, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setb %al
; X86-NEXT:    btcl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: complement_ne_i512:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    shrl $3, %ecx
; X64-NEXT:    andl $60, %ecx
; X64-NEXT:    movl (%rdi,%rcx), %edx
; X64-NEXT:    btl %esi, %edx
; X64-NEXT:    setb %al
; X64-NEXT:    btcl %esi, %edx
; X64-NEXT:    movl %edx, (%rdi,%rcx)
; X64-NEXT:    retq
  %rem = and i32 %position, 511
  %ofs = zext nneg i32 %rem to i512
  %bit = shl nuw i512 1, %ofs
  %ld = load i512, ptr %word
  %test = and i512 %ld, %bit
  %res = xor i512 %ld, %bit
  %cmp = icmp ne i512 %test, 0
  store i512 %res, ptr %word
  ret i1 %cmp
}

define i1 @reset_eq_i512(ptr %word, i32 %position) nounwind {
; X86-LABEL: reset_eq_i512:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    andl $60, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setae %al
; X86-NEXT:    btrl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: reset_eq_i512:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    shrl $3, %ecx
; X64-NEXT:    andl $60, %ecx
; X64-NEXT:    movl (%rdi,%rcx), %edx
; X64-NEXT:    btl %esi, %edx
; X64-NEXT:    setae %al
; X64-NEXT:    btrl %esi, %edx
; X64-NEXT:    movl %edx, (%rdi,%rcx)
; X64-NEXT:    retq
  %rem = and i32 %position, 511
  %ofs = zext nneg i32 %rem to i512
  %bit = shl nuw i512 1, %ofs
  %mask = xor i512 %bit, -1
  %ld = load i512, ptr %word
  %test = and i512 %ld, %bit
  %res = and i512 %ld, %mask
  %cmp = icmp eq i512 %test, 0
  store i512 %res, ptr %word
  ret i1 %cmp
}

define i1 @set_ne_i512(ptr %word, i32 %position) nounwind {
; X86-LABEL: set_ne_i512:
; X86:       # %bb.0:
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %edx, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    andl $60, %esi
; X86-NEXT:    movl (%ecx,%esi), %edi
; X86-NEXT:    btl %edx, %edi
; X86-NEXT:    setb %al
; X86-NEXT:    btsl %edx, %edi
; X86-NEXT:    movl %edi, (%ecx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    retl
;
; X64-LABEL: set_ne_i512:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    shrl $3, %ecx
; X64-NEXT:    andl $60, %ecx
; X64-NEXT:    movl (%rdi,%rcx), %edx
; X64-NEXT:    btl %esi, %edx
; X64-NEXT:    setb %al
; X64-NEXT:    btsl %esi, %edx
; X64-NEXT:    movl %edx, (%rdi,%rcx)
; X64-NEXT:    retq
  %rem = and i32 %position, 511
  %ofs = zext nneg i32 %rem to i512
  %bit = shl nuw i512 1, %ofs
  %ld = load i512, ptr %word
  %test = and i512 %ld, %bit
  %res = or i512 %ld, %bit
  %cmp = icmp ne i512 %test, 0
  store i512 %res, ptr %word
  ret i1 %cmp
}

define i1 @init_eq_i512(ptr %word, i32 %position, i1 zeroext %value) nounwind {
; X86-LABEL: init_eq_i512:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl %ecx, %esi
; X86-NEXT:    shrl $3, %esi
; X86-NEXT:    andl $60, %esi
; X86-NEXT:    movl (%edx,%esi), %edi
; X86-NEXT:    btl %ecx, %edi
; X86-NEXT:    setae %al
; X86-NEXT:    btrl %ecx, %edi
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %ebx
; X86-NEXT:    # kill: def $cl killed $cl killed $ecx
; X86-NEXT:    shll %cl, %ebx
; X86-NEXT:    orl %edi, %ebx
; X86-NEXT:    movl %ebx, (%edx,%esi)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    retl
;
; SSE-LABEL: init_eq_i512:
; SSE:       # %bb.0:
; SSE-NEXT:    movl %esi, %ecx
; SSE-NEXT:    shrl $3, %esi
; SSE-NEXT:    andl $60, %esi
; SSE-NEXT:    movl (%rdi,%rsi), %r8d
; SSE-NEXT:    btl %ecx, %r8d
; SSE-NEXT:    setae %al
; SSE-NEXT:    shll %cl, %edx
; SSE-NEXT:    btrl %ecx, %r8d
; SSE-NEXT:    orl %r8d, %edx
; SSE-NEXT:    movl %edx, (%rdi,%rsi)
; SSE-NEXT:    retq
;
; AVX-LABEL: init_eq_i512:
; AVX:       # %bb.0:
; AVX-NEXT:    movl %esi, %ecx
; AVX-NEXT:    shrl $3, %ecx
; AVX-NEXT:    andl $60, %ecx
; AVX-NEXT:    movl (%rdi,%rcx), %r8d
; AVX-NEXT:    btl %esi, %r8d
; AVX-NEXT:    setae %al
; AVX-NEXT:    btrl %esi, %r8d
; AVX-NEXT:    shlxl %esi, %edx, %edx
; AVX-NEXT:    orl %r8d, %edx
; AVX-NEXT:    movl %edx, (%rdi,%rcx)
; AVX-NEXT:    retq
  %rem = and i32 %position, 511
  %ofs = zext nneg i32 %rem to i512
  %bit = shl nuw i512 1, %ofs
  %mask = xor i512 %bit, -1
  %val0 = zext i1 %value to i512
  %val = shl nuw i512 %val0, %ofs
  %ld = load i512, ptr %word
  %test = and i512 %ld, %bit
  %res0 = and i512 %ld, %mask
  %res = or i512 %res0, %val
  %cmp = icmp eq i512 %test, 0
  store i512 %res, ptr %word
  ret i1 %cmp
}

; i4096

define i1 @test_ne_i4096(ptr %word, i32 %position) nounwind {
; X86-LABEL: test_ne_i4096:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl %ecx, %edx
; X86-NEXT:    andl $4064, %edx # imm = 0xFE0
; X86-NEXT:    shrl $3, %edx
; X86-NEXT:    movl (%eax,%edx), %eax
; X86-NEXT:    btl %ecx, %eax
; X86-NEXT:    setb %al
; X86-NEXT:    retl
;
; X64-LABEL: test_ne_i4096:
; X64:       # %bb.0:
; X64-NEXT:    movl %esi, %eax
; X64-NEXT:    andl $4064, %eax # imm = 0xFE0
; X64-NEXT:    shrl $3, %eax
; X64-NEXT:    movl (%rdi,%rax), %eax
; X64-NEXT:    btl %esi, %eax
; X64-NEXT:    setb %al
; X64-NEXT:    retq
  %rem = and i32 %position, 4095
  %ofs = zext nneg i32 %rem to i4096
  %bit = shl nuw i4096 1, %ofs
  %ld = load i4096, ptr %word
  %test = and i4096 %ld, %bit
  %cmp = icmp ne i4096 %test, 0
  ret i1 %cmp
}

; Special Cases

; Multiple uses of the stored value
define i1 @complement_cmpz_i128(ptr %word, i32 %position) nounwind {
; X86-LABEL: complement_cmpz_i128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebp
; X86-NEXT:    movl %esp, %ebp
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    andl $-16, %esp
; X86-NEXT:    subl $64, %esp
; X86-NEXT:    movzbl 12(%ebp), %ecx
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $1, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl %ecx, %eax
; X86-NEXT:    shrb $3, %al
; X86-NEXT:    andb $12, %al
; X86-NEXT:    negb %al
; X86-NEXT:    movsbl %al, %esi
; X86-NEXT:    movl 36(%esp,%esi), %eax
; X86-NEXT:    movl 40(%esp,%esi), %edi
; X86-NEXT:    movl %edi, %edx
; X86-NEXT:    shldl %cl, %eax, %edx
; X86-NEXT:    movl 32(%esp,%esi), %ebx
; X86-NEXT:    movl %ebx, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; X86-NEXT:    movl 44(%esp,%esi), %esi
; X86-NEXT:    shldl %cl, %edi, %esi
; X86-NEXT:    movl %ebx, %edi
; X86-NEXT:    shll %cl, %edi
; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %ebx # 4-byte Reload
; X86-NEXT:    shldl %cl, %ebx, %eax
; X86-NEXT:    movl 8(%ebp), %ecx
; X86-NEXT:    xorl 12(%ecx), %esi
; X86-NEXT:    xorl 8(%ecx), %edx
; X86-NEXT:    xorl 4(%ecx), %eax
; X86-NEXT:    xorl (%ecx), %edi
; X86-NEXT:    movl %edx, 8(%ecx)
; X86-NEXT:    movl %esi, 12(%ecx)
; X86-NEXT:    movl %edi, (%ecx)
; X86-NEXT:    movl %eax, 4(%ecx)
; X86-NEXT:    orl %esi, %eax
; X86-NEXT:    orl %edx, %edi
; X86-NEXT:    orl %eax, %edi
; X86-NEXT:    setne %al
; X86-NEXT:    leal -12(%ebp), %esp
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    popl %ebp
; X86-NEXT:    retl
;
; SSE-LABEL: complement_cmpz_i128:
; SSE:       # %bb.0:
; SSE-NEXT:    movl %esi, %ecx
; SSE-NEXT:    movl $1, %eax
; SSE-NEXT:    xorl %edx, %edx
; SSE-NEXT:    shldq %cl, %rax, %rdx
; SSE-NEXT:    shlq %cl, %rax
; SSE-NEXT:    xorl %esi, %esi
; SSE-NEXT:    testb $64, %cl
; SSE-NEXT:    cmovneq %rax, %rdx
; SSE-NEXT:    cmovneq %rsi, %rax
; SSE-NEXT:    xorq 8(%rdi), %rdx
; SSE-NEXT:    xorq (%rdi), %rax
; SSE-NEXT:    movq %rax, (%rdi)
; SSE-NEXT:    movq %rdx, 8(%rdi)
; SSE-NEXT:    orq %rdx, %rax
; SSE-NEXT:    setne %al
; SSE-NEXT:    retq
;
; AVX2-LABEL: complement_cmpz_i128:
; AVX2:       # %bb.0:
; AVX2-NEXT:    movl %esi, %ecx
; AVX2-NEXT:    movl $1, %eax
; AVX2-NEXT:    xorl %edx, %edx
; AVX2-NEXT:    shldq %cl, %rax, %rdx
; AVX2-NEXT:    xorl %esi, %esi
; AVX2-NEXT:    shlxq %rcx, %rax, %rax
; AVX2-NEXT:    testb $64, %cl
; AVX2-NEXT:    cmovneq %rax, %rdx
; AVX2-NEXT:    cmovneq %rsi, %rax
; AVX2-NEXT:    xorq 8(%rdi), %rdx
; AVX2-NEXT:    xorq (%rdi), %rax
; AVX2-NEXT:    movq %rax, (%rdi)
; AVX2-NEXT:    movq %rdx, 8(%rdi)
; AVX2-NEXT:    orq %rdx, %rax
; AVX2-NEXT:    setne %al
; AVX2-NEXT:    retq
;
; AVX512-LABEL: complement_cmpz_i128:
; AVX512:       # %bb.0:
; AVX512-NEXT:    movl %esi, %ecx
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    movl $1, %edx
; AVX512-NEXT:    xorl %esi, %esi
; AVX512-NEXT:    shldq %cl, %rdx, %rsi
; AVX512-NEXT:    shlxq %rcx, %rdx, %rdx
; AVX512-NEXT:    testb $64, %cl
; AVX512-NEXT:    cmovneq %rdx, %rsi
; AVX512-NEXT:    cmovneq %rax, %rdx
; AVX512-NEXT:    xorq 8(%rdi), %rsi
; AVX512-NEXT:    xorq (%rdi), %rdx
; AVX512-NEXT:    movq %rdx, (%rdi)
; AVX512-NEXT:    movq %rsi, 8(%rdi)
; AVX512-NEXT:    orq %rsi, %rdx
; AVX512-NEXT:    setne %al
; AVX512-NEXT:    retq
  %rem = and i32 %position, 127
  %ofs = zext nneg i32 %rem to i128
  %bit = shl nuw i128 1, %ofs
  %ld = load i128, ptr %word
  %res = xor i128 %ld, %bit
  store i128 %res, ptr %word
  %cmp = icmp ne i128 %res, 0
  ret i1 %cmp
}

; Multiple loads in store chain
define i32 @reset_multiload_i128(ptr %word, i32 %position, ptr %p) nounwind {
; X86-LABEL: reset_multiload_i128:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebp
; X86-NEXT:    movl %esp, %ebp
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    andl $-16, %esp
; X86-NEXT:    subl $64, %esp
; X86-NEXT:    movl 12(%ebp), %ecx
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $1, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl $0, {{[0-9]+}}(%esp)
; X86-NEXT:    movl %ecx, %eax
; X86-NEXT:    shrb $3, %al
; X86-NEXT:    andb $12, %al
; X86-NEXT:    negb %al
; X86-NEXT:    movsbl %al, %edi
; X86-NEXT:    movl 36(%esp,%edi), %edx
; X86-NEXT:    movl 40(%esp,%edi), %ebx
; X86-NEXT:    movl %ebx, %esi
; X86-NEXT:    shldl %cl, %edx, %esi
; X86-NEXT:    movl 32(%esp,%edi), %eax
; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; X86-NEXT:    movl 44(%esp,%edi), %edi
; X86-NEXT:    shldl %cl, %ebx, %edi
; X86-NEXT:    movl %eax, %ebx
; X86-NEXT:    # kill: def $cl killed $cl killed $ecx
; X86-NEXT:    shll %cl, %ebx
; X86-NEXT:    notl %ebx
; X86-NEXT:    movl 16(%ebp), %eax
; X86-NEXT:    movl (%eax), %eax
; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; X86-NEXT:    movl 12(%ebp), %eax
; X86-NEXT:    andl $96, %eax
; X86-NEXT:    shrl $3, %eax
; X86-NEXT:    movl 8(%ebp), %ecx
; X86-NEXT:    movl (%ecx,%eax), %eax
; X86-NEXT:    andl %ebx, (%ecx)
; X86-NEXT:    movl 12(%ebp), %ecx
; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %ebx # 4-byte Reload
; X86-NEXT:    shldl %cl, %ebx, %edx
; X86-NEXT:    notl %edx
; X86-NEXT:    movl 8(%ebp), %ebx
; X86-NEXT:    andl %edx, 4(%ebx)
; X86-NEXT:    notl %esi
; X86-NEXT:    andl %esi, 8(%ebx)
; X86-NEXT:    notl %edi
; X86-NEXT:    andl %edi, 12(%ebx)
; X86-NEXT:    btl %ecx, %eax
; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Reload
; X86-NEXT:    jae .LBB22_2
; X86-NEXT:  # %bb.1:
; X86-NEXT:    xorl %eax, %eax
; X86-NEXT:  .LBB22_2:
; X86-NEXT:    leal -12(%ebp), %esp
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    popl %ebp
; X86-NEXT:    retl
;
; SSE-LABEL: reset_multiload_i128:
; SSE:       # %bb.0:
; SSE-NEXT:    movl %esi, %ecx
; SSE-NEXT:    movl $1, %esi
; SSE-NEXT:    xorl %r8d, %r8d
; SSE-NEXT:    shldq %cl, %rsi, %r8
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    shlq %cl, %rsi
; SSE-NEXT:    testb $64, %cl
; SSE-NEXT:    cmovneq %rsi, %r8
; SSE-NEXT:    cmovneq %rax, %rsi
; SSE-NEXT:    notq %r8
; SSE-NEXT:    notq %rsi
; SSE-NEXT:    movl %ecx, %r9d
; SSE-NEXT:    andl $96, %r9d
; SSE-NEXT:    shrl $3, %r9d
; SSE-NEXT:    movl (%rdi,%r9), %r9d
; SSE-NEXT:    btl %ecx, %r9d
; SSE-NEXT:    jb .LBB22_2
; SSE-NEXT:  # %bb.1:
; SSE-NEXT:    movl (%rdx), %eax
; SSE-NEXT:  .LBB22_2:
; SSE-NEXT:    andq %r8, 8(%rdi)
; SSE-NEXT:    andq %rsi, (%rdi)
; SSE-NEXT:    # kill: def $eax killed $eax killed $rax
; SSE-NEXT:    retq
;
; AVX2-LABEL: reset_multiload_i128:
; AVX2:       # %bb.0:
; AVX2-NEXT:    movl %esi, %ecx
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    movl $1, %r8d
; AVX2-NEXT:    xorl %esi, %esi
; AVX2-NEXT:    shldq %cl, %r8, %rsi
; AVX2-NEXT:    shlxq %rcx, %r8, %r8
; AVX2-NEXT:    testb $64, %cl
; AVX2-NEXT:    cmovneq %r8, %rsi
; AVX2-NEXT:    cmovneq %rax, %r8
; AVX2-NEXT:    notq %rsi
; AVX2-NEXT:    notq %r8
; AVX2-NEXT:    movl %ecx, %r9d
; AVX2-NEXT:    andl $96, %r9d
; AVX2-NEXT:    shrl $3, %r9d
; AVX2-NEXT:    movl (%rdi,%r9), %r9d
; AVX2-NEXT:    btl %ecx, %r9d
; AVX2-NEXT:    jb .LBB22_2
; AVX2-NEXT:  # %bb.1:
; AVX2-NEXT:    movl (%rdx), %eax
; AVX2-NEXT:  .LBB22_2:
; AVX2-NEXT:    andq %rsi, 8(%rdi)
; AVX2-NEXT:    andq %r8, (%rdi)
; AVX2-NEXT:    # kill: def $eax killed $eax killed $rax
; AVX2-NEXT:    retq
;
; AVX512-LABEL: reset_multiload_i128:
; AVX512:       # %bb.0:
; AVX512-NEXT:    movl %esi, %ecx
; AVX512-NEXT:    movl $1, %r8d
; AVX512-NEXT:    xorl %esi, %esi
; AVX512-NEXT:    shldq %cl, %r8, %rsi
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    shlxq %rcx, %r8, %r8
; AVX512-NEXT:    testb $64, %cl
; AVX512-NEXT:    cmovneq %r8, %rsi
; AVX512-NEXT:    cmovneq %rax, %r8
; AVX512-NEXT:    notq %rsi
; AVX512-NEXT:    notq %r8
; AVX512-NEXT:    movl %ecx, %r9d
; AVX512-NEXT:    andl $96, %r9d
; AVX512-NEXT:    shrl $3, %r9d
; AVX512-NEXT:    movl (%rdi,%r9), %r9d
; AVX512-NEXT:    btl %ecx, %r9d
; AVX512-NEXT:    jb .LBB22_2
; AVX512-NEXT:  # %bb.1:
; AVX512-NEXT:    movl (%rdx), %eax
; AVX512-NEXT:  .LBB22_2:
; AVX512-NEXT:    andq %rsi, 8(%rdi)
; AVX512-NEXT:    andq %r8, (%rdi)
; AVX512-NEXT:    # kill: def $eax killed $eax killed $rax
; AVX512-NEXT:    retq
  %rem = and i32 %position, 127
  %ofs = zext nneg i32 %rem to i128
  %bit = shl nuw i128 1, %ofs
  %mask = xor i128 %bit, -1
  %ld = load i128, ptr %word
  %sel = load i32, ptr %p
  %test = and i128 %ld, %bit
  %res = and i128 %ld, %mask
  %cmp = icmp eq i128 %test, 0
  store i128 %res, ptr %word
  %ret = select i1 %cmp, i32 %sel, i32 0
  ret i32 %ret
}
