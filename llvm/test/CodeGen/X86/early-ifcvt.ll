; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -x86-early-ifcvt -stress-early-ifcvt | FileCheck %s
target triple = "x86_64-apple-macosx10.8.0"

define i32 @mm2(ptr nocapture %p, i32 %n) nounwind uwtable readonly ssp {
; CHECK-LABEL: mm2:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  LBB0_1: ## %do.body
; CHECK-NEXT:    ## =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %esi, %r8d
; CHECK-NEXT:    movl (%rdi,%rdx,4), %r9d
; CHECK-NEXT:    cmpl %esi, %r9d
; CHECK-NEXT:    cmovll %r9d, %esi
; CHECK-NEXT:    cmpl %eax, %r9d
; CHECK-NEXT:    cmovgl %r9d, %eax
; CHECK-NEXT:    cmovgl %r8d, %esi
; CHECK-NEXT:    incq %rdx
; CHECK-NEXT:    cmpl %edx, %ecx
; CHECK-NEXT:    jne LBB0_1
; CHECK-NEXT:  ## %bb.2: ## %do.end
; CHECK-NEXT:    subl %esi, %eax
; CHECK-NEXT:    retq
entry:
  br label %do.body

; Loop body has no branches before the backedge.
do.body:
  %max.0 = phi i32 [ 0, %entry ], [ %max.1, %do.cond ]
  %min.0 = phi i32 [ 0, %entry ], [ %min.1, %do.cond ]
  %n.addr.0 = phi i32 [ %n, %entry ], [ %dec, %do.cond ]
  %p.addr.0 = phi ptr [ %p, %entry ], [ %incdec.ptr, %do.cond ]
  %incdec.ptr = getelementptr inbounds i32, ptr %p.addr.0, i64 1
  %0 = load i32, ptr %p.addr.0, align 4
  %cmp = icmp sgt i32 %0, %max.0
  br i1 %cmp, label %do.cond, label %if.else

if.else:
  %cmp1 = icmp slt i32 %0, %min.0
  %.min.0 = select i1 %cmp1, i32 %0, i32 %min.0
  br label %do.cond

do.cond:
  %max.1 = phi i32 [ %0, %do.body ], [ %max.0, %if.else ]
  %min.1 = phi i32 [ %min.0, %do.body ], [ %.min.0, %if.else ]
  %dec = add i32 %n.addr.0, -1
  %tobool = icmp eq i32 %dec, 0
  br i1 %tobool, label %do.end, label %do.body

do.end:
  %sub = sub nsw i32 %max.1, %min.1
  ret i32 %sub
}

; Deal with alternative tail predecessors
define void @multipreds(i32 %sw) nounwind uwtable ssp {
; CHECK-LABEL: multipreds:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movl $66, %ecx
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    cmpl $127, %edi
; CHECK-NEXT:    movl $2, %eax
; CHECK-NEXT:    cmovel %ecx, %eax
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    cmovel %edx, %eax
; CHECK-NEXT:    movl %eax, %edi
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    callq _fprintf
; CHECK-NEXT:    ud2
entry:
  switch i32 %sw, label %if.then29 [
    i32 0, label %if.then37
    i32 127, label %if.end41
  ]

if.then29:
  br label %if.end41

if.then37:
  br label %if.end41

if.end41:
  %exit_status.0 = phi i32 [ 2, %if.then29 ], [ 0, %if.then37 ], [ 66, %entry ]
  call void (...) @fprintf(i32 %exit_status.0) nounwind
  unreachable
}

declare void @fprintf(...) nounwind

; This test case contains irreducible control flow, so MachineLoopInfo doesn't
; recognize the cycle in the CFG. This would confuse MachineTraceMetrics.
define void @BZ2_decompress(ptr %s) nounwind ssp {
; CHECK-LABEL: BZ2_decompress:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    xorl %ebx, %ebx
; CHECK-NEXT:    testb %bl, %bl
; CHECK-NEXT:    jne LBB2_8
; CHECK-NEXT:  ## %bb.1: ## %entry
; CHECK-NEXT:    movabsq $18897856102400, %rax ## imm = 0x113000000000
; CHECK-NEXT:    btq %rbx, %rax
; CHECK-NEXT:    jae LBB2_2
; CHECK-NEXT:  LBB2_9: ## %save_state_and_return
; CHECK-NEXT:    movl %ebx, (%rax)
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    retq
; CHECK-NEXT:  LBB2_2: ## %entry
; CHECK-NEXT:    cmpq $38, %rbx
; CHECK-NEXT:    je LBB2_5
; CHECK-NEXT:  ## %bb.3: ## %entry
; CHECK-NEXT:    cmpq $39, %rbx
; CHECK-NEXT:    jne LBB2_8
; CHECK-NEXT:  ## %bb.4: ## %if.end.sw.bb2050_crit_edge
; CHECK-NEXT:    xorl %ebx, %ebx
; CHECK-NEXT:    jmp LBB2_6
; CHECK-NEXT:  LBB2_8: ## %sw.default
; CHECK-NEXT:    callq _BZ2_bz__AssertH__fail
; CHECK-NEXT:    jmp LBB2_9
; CHECK-NEXT:  LBB2_5: ## %sw.bb1983
; CHECK-NEXT:    xorl %ebx, %ebx
; CHECK-NEXT:    testb %bl, %bl
; CHECK-NEXT:    jne LBB2_9
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  LBB2_6: ## %while.body2038
; CHECK-NEXT:    ## =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    jne LBB2_9
; CHECK-NEXT:  ## %bb.7: ## %if.end2042
; CHECK-NEXT:    ## in Loop: Header=BB2_6 Depth=1
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    je LBB2_6
; CHECK-NEXT:    jmp LBB2_9
entry:
  switch i32 undef, label %sw.default [
    i32 39, label %if.end.sw.bb2050_crit_edge
    i32 36, label %sw.bb1788
    i32 37, label %if.end.sw.bb1855_crit_edge
    i32 40, label %sw.bb2409
    i32 38, label %sw.bb1983
    i32 44, label %if.end.sw.bb3058_crit_edge
  ]

if.end.sw.bb3058_crit_edge:                       ; preds = %entry
  br label %save_state_and_return

if.end.sw.bb1855_crit_edge:                       ; preds = %entry
  br label %save_state_and_return

if.end.sw.bb2050_crit_edge:                       ; preds = %entry
  br label %sw.bb2050

sw.bb1788:                                        ; preds = %entry
  br label %save_state_and_return

sw.bb1983:                                        ; preds = %entry
  br i1 undef, label %save_state_and_return, label %if.then1990

if.then1990:                                      ; preds = %sw.bb1983
  br label %while.body2038

while.body2038:                                   ; preds = %sw.bb2050, %if.then1990
  %groupPos.8 = phi i32 [ 0, %if.then1990 ], [ %groupPos.9, %sw.bb2050 ]
  br i1 undef, label %save_state_and_return, label %if.end2042

if.end2042:                                       ; preds = %while.body2038
  br i1 undef, label %if.end2048, label %while.end2104

if.end2048:                                       ; preds = %if.end2042
  %bsLive2054.pre = getelementptr inbounds i8, ptr %s, i32 8
  br label %sw.bb2050

sw.bb2050:                                        ; preds = %if.end2048, %if.end.sw.bb2050_crit_edge
  %groupPos.9 = phi i32 [ 0, %if.end.sw.bb2050_crit_edge ], [ %groupPos.8, %if.end2048 ]
  %and2064 = and i32 undef, 1
  br label %while.body2038

while.end2104:                                    ; preds = %if.end2042
  br i1 undef, label %save_state_and_return, label %if.end2117

if.end2117:                                       ; preds = %while.end2104
  br i1 undef, label %while.body2161.lr.ph, label %while.body2145.lr.ph

while.body2145.lr.ph:                             ; preds = %if.end2117
  br label %save_state_and_return

while.body2161.lr.ph:                             ; preds = %if.end2117
  br label %save_state_and_return

sw.bb2409:                                        ; preds = %entry
  br label %save_state_and_return

sw.default:                                       ; preds = %entry
  call void @BZ2_bz__AssertH__fail() nounwind
  br label %save_state_and_return

save_state_and_return:
  %groupPos.14 = phi i32 [ 0, %sw.default ], [ %groupPos.8, %while.body2038 ], [ %groupPos.8, %while.end2104 ], [ 0, %if.end.sw.bb3058_crit_edge ], [ 0, %if.end.sw.bb1855_crit_edge ], [ %groupPos.8, %while.body2161.lr.ph ], [ %groupPos.8, %while.body2145.lr.ph ], [ 0, %sw.bb2409 ], [ 0, %sw.bb1788 ], [ 0, %sw.bb1983 ]
  store i32 %groupPos.14, ptr undef, align 4
  ret void
}

declare void @BZ2_bz__AssertH__fail()

; Make sure we don't speculate on div/idiv instructions
; CHECK: test_idiv
; CHECK-NOT: cmov
define i32 @test_idiv(i32 %a, i32 %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: test_idiv:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    testl %esi, %esi
; CHECK-NEXT:    je LBB3_2
; CHECK-NEXT:  ## %bb.1:
; CHECK-NEXT:    cltd
; CHECK-NEXT:    idivl %esi
; CHECK-NEXT:  LBB3_2:
; CHECK-NEXT:    retq
  %1 = icmp eq i32 %b, 0
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = sdiv i32 %a, %b
  br label %4

; <label>:4                                       ; preds = %0, %2
  %5 = phi i32 [ %3, %2 ], [ %a, %0 ]
  ret i32 %5
}

; CHECK: test_div
; CHECK-NOT: cmov
define i32 @test_div(i32 %a, i32 %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: test_div:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    testl %esi, %esi
; CHECK-NEXT:    je LBB4_2
; CHECK-NEXT:  ## %bb.1:
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %esi
; CHECK-NEXT:  LBB4_2:
; CHECK-NEXT:    retq
  %1 = icmp eq i32 %b, 0
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = udiv i32 %a, %b
  br label %4

; <label>:4                                       ; preds = %0, %2
  %5 = phi i32 [ %3, %2 ], [ %a, %0 ]
  ret i32 %5
}
