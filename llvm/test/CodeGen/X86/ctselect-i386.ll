; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=-cmov | FileCheck %s --check-prefix=I386-NOCMOV
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=+cmov | FileCheck %s --check-prefix=I386-CMOV
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=-cmov -verify-machineinstrs | FileCheck %s --check-prefix=I386-NOCMOV

; Comprehensive CTSELECT tests for i386 targets with scalar integer types
; - Without CMOV: constant-time implementation using post-RA expansion with bundled instructions
; - With CMOV: CMOV-based implementation
; - Verifies security properties: no conditional branches, constant execution time
; All expansion happens post-RA for better optimization control and constant-time guarantees

; Test basic i32 functionality
define i32 @test_ctselect_i32_basic(i1 %cond, i32 %a, i32 %b) nounwind {
; I386-NOCMOV-LABEL: test_ctselect_i32_basic:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    sete %bl
; I386-NOCMOV-NEXT:    movb %bl, %bh
; I386-NOCMOV-NEXT:    movzbl %bh, %esi
; I386-NOCMOV-NEXT:    negl %esi
; I386-NOCMOV-NEXT:    movl %edx, %eax
; I386-NOCMOV-NEXT:    andl %esi, %eax
; I386-NOCMOV-NEXT:    notl %esi
; I386-NOCMOV-NEXT:    andl %ecx, %esi
; I386-NOCMOV-NEXT:    orl %esi, %eax
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_ctselect_i32_basic:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    retl
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %a, i32 %b)
  ret i32 %result
}

; Test i16 functionality
define i16 @test_ctselect_i16_basic(i1 %cond, i16 %a, i16 %b) nounwind {
; I386-NOCMOV-LABEL: test_ctselect_i16_basic:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    movzwl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movzwl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    sete %bl
; I386-NOCMOV-NEXT:    movb %bl, %bh
; I386-NOCMOV-NEXT:    movzbw %bh, %si
; I386-NOCMOV-NEXT:    negw %si
; I386-NOCMOV-NEXT:    movw %dx, %ax
; I386-NOCMOV-NEXT:    andw %si, %ax
; I386-NOCMOV-NEXT:    notw %si
; I386-NOCMOV-NEXT:    andw %cx, %si
; I386-NOCMOV-NEXT:    orw %si, %ax
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_ctselect_i16_basic:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    movzwl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnew {{[0-9]+}}(%esp), %ax
; I386-CMOV-NEXT:    retl
  %result = call i16 @llvm.ct.select.i16(i1 %cond, i16 %a, i16 %b)
  ret i16 %result
}

; Test i8 functionality
define i8 @test_ctselect_i8_basic(i1 %cond, i8 %a, i8 %b) nounwind {
; I386-NOCMOV-LABEL: test_ctselect_i8_basic:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    movzbl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movzbl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    sete %ah
; I386-NOCMOV-NEXT:    movb %ah, %ch
; I386-NOCMOV-NEXT:    negb %ch
; I386-NOCMOV-NEXT:    movb %dl, %al
; I386-NOCMOV-NEXT:    andb %ch, %al
; I386-NOCMOV-NEXT:    notb %ch
; I386-NOCMOV-NEXT:    andb %cl, %ch
; I386-NOCMOV-NEXT:    orb %ch, %al
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_ctselect_i8_basic:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    # kill: def $al killed $al killed $eax
; I386-CMOV-NEXT:    retl
  %result = call i8 @llvm.ct.select.i8(i1 %cond, i8 %a, i8 %b)
  ret i8 %result
}

; Test security property: constant-time execution for cryptographic use case
define i32 @test_crypto_key_select(i32 %secret_bit, i32 %key1, i32 %key2) nounwind {
; I386-NOCMOV-LABEL: test_crypto_key_select:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    setne %al
; I386-NOCMOV-NEXT:    testb %al, %al
; I386-NOCMOV-NEXT:    sete %bl
; I386-NOCMOV-NEXT:    movb %bl, %bh
; I386-NOCMOV-NEXT:    movzbl %bh, %esi
; I386-NOCMOV-NEXT:    negl %esi
; I386-NOCMOV-NEXT:    movl %edx, %eax
; I386-NOCMOV-NEXT:    andl %esi, %eax
; I386-NOCMOV-NEXT:    notl %esi
; I386-NOCMOV-NEXT:    andl %ecx, %esi
; I386-NOCMOV-NEXT:    orl %esi, %eax
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_crypto_key_select:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    setne %cl
; I386-CMOV-NEXT:    testb %cl, %cl
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    retl
  %cond = icmp ne i32 %secret_bit, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %key1, i32 %key2)
  ret i32 %result
}

; Test that no conditional branches appear in constant-time path
define i32 @test_no_conditional_branches(i32 %secret, i32 %val1, i32 %val2) nounwind {
; I386-NOCMOV-LABEL: test_no_conditional_branches:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    setne %al
; I386-NOCMOV-NEXT:    testb %al, %al
; I386-NOCMOV-NEXT:    sete %bl
; I386-NOCMOV-NEXT:    movb %bl, %bh
; I386-NOCMOV-NEXT:    movzbl %bh, %esi
; I386-NOCMOV-NEXT:    negl %esi
; I386-NOCMOV-NEXT:    movl %edx, %eax
; I386-NOCMOV-NEXT:    andl %esi, %eax
; I386-NOCMOV-NEXT:    notl %esi
; I386-NOCMOV-NEXT:    andl %ecx, %esi
; I386-NOCMOV-NEXT:    orl %esi, %eax
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_no_conditional_branches:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    setne %cl
; I386-CMOV-NEXT:    testb %cl, %cl
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    retl
  %cond = icmp ne i32 %secret, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %val1, i32 %val2)
  ret i32 %result
}

; Test with comparison condition
define i32 @test_ctselect_i32_cmp(i32 %a, i32 %b, i32 %c) nounwind {
; I386-NOCMOV-LABEL: test_ctselect_i32_cmp:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    cmpl %edx, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    sete %al
; I386-NOCMOV-NEXT:    testb %al, %al
; I386-NOCMOV-NEXT:    sete %bl
; I386-NOCMOV-NEXT:    movb %bl, %bh
; I386-NOCMOV-NEXT:    movzbl %bh, %esi
; I386-NOCMOV-NEXT:    negl %esi
; I386-NOCMOV-NEXT:    movl %edx, %eax
; I386-NOCMOV-NEXT:    andl %esi, %eax
; I386-NOCMOV-NEXT:    notl %esi
; I386-NOCMOV-NEXT:    andl %ecx, %esi
; I386-NOCMOV-NEXT:    orl %esi, %eax
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_ctselect_i32_cmp:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    cmpl %eax, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    sete %cl
; I386-CMOV-NEXT:    testb %cl, %cl
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    retl
  %cond = icmp eq i32 %a, %c
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %b, i32 %c)
  ret i32 %result
}

; Test nested selects
define i32 @test_ctselect_nested(i1 %cond1, i1 %cond2, i32 %a, i32 %b, i32 %c) nounwind {
; I386-NOCMOV-LABEL: test_ctselect_nested:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    pushl %edi
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    sete %bl
; I386-NOCMOV-NEXT:    movb %bl, %bh
; I386-NOCMOV-NEXT:    movzbl %bh, %edi
; I386-NOCMOV-NEXT:    negl %edi
; I386-NOCMOV-NEXT:    movl %edx, %esi
; I386-NOCMOV-NEXT:    andl %edi, %esi
; I386-NOCMOV-NEXT:    notl %edi
; I386-NOCMOV-NEXT:    andl %eax, %edi
; I386-NOCMOV-NEXT:    orl %edi, %esi
; I386-NOCMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    sete %dl
; I386-NOCMOV-NEXT:    movb %dl, %dh
; I386-NOCMOV-NEXT:    movzbl %dh, %edi
; I386-NOCMOV-NEXT:    negl %edi
; I386-NOCMOV-NEXT:    movl %ecx, %eax
; I386-NOCMOV-NEXT:    andl %edi, %eax
; I386-NOCMOV-NEXT:    notl %edi
; I386-NOCMOV-NEXT:    andl %esi, %edi
; I386-NOCMOV-NEXT:    orl %edi, %eax
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    popl %edi
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_ctselect_nested:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    testb $1, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel %ecx, %eax
; I386-CMOV-NEXT:    retl
  %sel1 = call i32 @llvm.ct.select.i32(i1 %cond2, i32 %a, i32 %b)
  %sel2 = call i32 @llvm.ct.select.i32(i1 %cond1, i32 %sel1, i32 %c)
  ret i32 %sel2
}

; Declare ct.select intrinsics
declare i8 @llvm.ct.select.i8(i1, i8, i8)
declare i16 @llvm.ct.select.i16(i1, i16, i16)
declare i32 @llvm.ct.select.i32(i1, i32, i32)
