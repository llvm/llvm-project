; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=x86_64-unknown-unknown -mcpu=x86-64 -stop-after=x86-optimize-LEAs -experimental-debug-variable-locations=false < %s \
; RUN:   | FileCheck %s --check-prefix=NORMAL
; RUN: llc -mtriple=x86_64-unknown-unknown -mcpu=x86-64 -stop-after=x86-optimize-LEAs -experimental-debug-variable-locations < %s \
; RUN:   | FileCheck %s --check-prefix=INSTRREF

; The LEA optimization pass used to crash on this testcase.

; This test case used to trigger:
;
;   assert(MRI->use_empty(LastVReg) &&
;          "The LEA's def register must have no uses");

target triple = "x86_64-unknown-linux-gnu"

%t10 = type { ptr, [32 x i8] }

define void @foo() {
  ; NORMAL-LABEL: name: foo
  ; NORMAL: bb.0.bb_entry:
  ; NORMAL-NEXT:   successors: %bb.1(0x80000000)
  ; NORMAL-NEXT: {{  $}}
  ; NORMAL-NEXT:   [[MOV32r0_:%[0-9]+]]:gr32 = MOV32r0 implicit-def dead $eflags
  ; NORMAL-NEXT:   [[COPY:%[0-9]+]]:gr8 = COPY [[MOV32r0_]].sub_8bit
  ; NORMAL-NEXT:   [[LEA64r:%[0-9]+]]:gr64 = LEA64r %stack.1.i, 1, $noreg, 0, $noreg
  ; NORMAL-NEXT:   [[DEF:%[0-9]+]]:gr64 = IMPLICIT_DEF
  ; NORMAL-NEXT: {{  $}}
  ; NORMAL-NEXT: bb.1.bb_8:
  ; NORMAL-NEXT:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; NORMAL-NEXT: {{  $}}
  ; NORMAL-NEXT:   TEST8rr [[COPY]], [[COPY]], implicit-def $eflags
  ; NORMAL-NEXT:   JCC_1 %bb.3, 5, implicit $eflags
  ; NORMAL-NEXT:   JMP_1 %bb.2
  ; NORMAL-NEXT: {{  $}}
  ; NORMAL-NEXT: bb.2.bb_mid:
  ; NORMAL-NEXT:   successors: %bb.3(0x80000000)
  ; NORMAL-NEXT: {{  $}}
  ; NORMAL-NEXT:   [[MOVUPSrm:%[0-9]+]]:vr128 = MOVUPSrm %stack.1.i, 1, $noreg, 40, $noreg :: (load (s128) from %ir.i4, align 8)
  ; NORMAL-NEXT:   MOVUPSmr $noreg, 1, $noreg, 0, $noreg, killed [[MOVUPSrm]] :: (store (s128) into `ptr null`, align 8)
  ; NORMAL-NEXT:   DBG_VALUE_LIST !3, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_plus_uconst, 40, DW_OP_stack_value), %stack.1.i, %stack.1.i, debug-location !8
  ; NORMAL-NEXT:   [[MOVUPSrm1:%[0-9]+]]:vr128 = MOVUPSrm %stack.1.i, 1, $noreg, 40, $noreg :: (load (s128) from %ir.i6, align 8)
  ; NORMAL-NEXT:   MOVUPSmr $noreg, 1, $noreg, 0, $noreg, killed [[MOVUPSrm1]] :: (store (s128) into `ptr null`, align 8)
  ; NORMAL-NEXT: {{  $}}
  ; NORMAL-NEXT: bb.3.bb_last:
  ; NORMAL-NEXT:   successors: %bb.1(0x80000000)
  ; NORMAL-NEXT: {{  $}}
  ; NORMAL-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; NORMAL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gr64 = SUBREG_TO_REG 0, [[MOV32r0_]], %subreg.sub_32bit
  ; NORMAL-NEXT:   $rdi = COPY [[SUBREG_TO_REG]]
  ; NORMAL-NEXT:   $rsi = COPY [[SUBREG_TO_REG]]
  ; NORMAL-NEXT:   $rdx = COPY [[SUBREG_TO_REG]]
  ; NORMAL-NEXT:   $ecx = COPY [[MOV32r0_]]
  ; NORMAL-NEXT:   $r8 = COPY [[LEA64r]]
  ; NORMAL-NEXT:   CALL64r [[DEF]], csr_64, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit $ecx, implicit $r8, implicit-def $rsp, implicit-def $ssp
  ; NORMAL-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; NORMAL-NEXT:   JMP_1 %bb.1
  ;
  ; INSTRREF-LABEL: name: foo
  ; INSTRREF: bb.0.bb_entry:
  ; INSTRREF-NEXT:   successors: %bb.1(0x80000000)
  ; INSTRREF-NEXT: {{  $}}
  ; INSTRREF-NEXT:   [[MOV32r0_:%[0-9]+]]:gr32 = MOV32r0 implicit-def dead $eflags
  ; INSTRREF-NEXT:   [[COPY:%[0-9]+]]:gr8 = COPY [[MOV32r0_]].sub_8bit
  ; INSTRREF-NEXT:   [[LEA64r:%[0-9]+]]:gr64 = LEA64r %stack.1.i, 1, $noreg, 0, $noreg
  ; INSTRREF-NEXT:   [[DEF:%[0-9]+]]:gr64 = IMPLICIT_DEF
  ; INSTRREF-NEXT: {{  $}}
  ; INSTRREF-NEXT: bb.1.bb_8:
  ; INSTRREF-NEXT:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; INSTRREF-NEXT: {{  $}}
  ; INSTRREF-NEXT:   TEST8rr [[COPY]], [[COPY]], implicit-def $eflags
  ; INSTRREF-NEXT:   JCC_1 %bb.3, 5, implicit $eflags
  ; INSTRREF-NEXT:   JMP_1 %bb.2
  ; INSTRREF-NEXT: {{  $}}
  ; INSTRREF-NEXT: bb.2.bb_mid:
  ; INSTRREF-NEXT:   successors: %bb.3(0x80000000)
  ; INSTRREF-NEXT: {{  $}}
  ; INSTRREF-NEXT:   [[MOVUPSrm:%[0-9]+]]:vr128 = MOVUPSrm %stack.1.i, 1, $noreg, 40, $noreg :: (load (s128) from %ir.i4, align 8)
  ; INSTRREF-NEXT:   MOVUPSmr $noreg, 1, $noreg, 0, $noreg, killed [[MOVUPSrm]] :: (store (s128) into `ptr null`, align 8)
  ; INSTRREF-NEXT:   DBG_VALUE_LIST !3, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_plus_uconst, 40, DW_OP_stack_value), %stack.1.i, %stack.1.i, debug-location !8
  ; INSTRREF-NEXT:   [[MOVUPSrm1:%[0-9]+]]:vr128 = MOVUPSrm %stack.1.i, 1, $noreg, 40, $noreg :: (load (s128) from %ir.i6, align 8)
  ; INSTRREF-NEXT:   MOVUPSmr $noreg, 1, $noreg, 0, $noreg, killed [[MOVUPSrm1]] :: (store (s128) into `ptr null`, align 8)
  ; INSTRREF-NEXT: {{  $}}
  ; INSTRREF-NEXT: bb.3.bb_last:
  ; INSTRREF-NEXT:   successors: %bb.1(0x80000000)
  ; INSTRREF-NEXT: {{  $}}
  ; INSTRREF-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; INSTRREF-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gr64 = SUBREG_TO_REG 0, [[MOV32r0_]], %subreg.sub_32bit
  ; INSTRREF-NEXT:   $rdi = COPY [[SUBREG_TO_REG]]
  ; INSTRREF-NEXT:   $rsi = COPY [[SUBREG_TO_REG]]
  ; INSTRREF-NEXT:   $rdx = COPY [[SUBREG_TO_REG]]
  ; INSTRREF-NEXT:   $ecx = COPY [[MOV32r0_]]
  ; INSTRREF-NEXT:   $r8 = COPY [[LEA64r]]
  ; INSTRREF-NEXT:   CALL64r [[DEF]], csr_64, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit $ecx, implicit $r8, implicit-def $rsp, implicit-def $ssp
  ; INSTRREF-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; INSTRREF-NEXT:   JMP_1 %bb.1
bb_entry:
  %tmp11 = alloca [0 x [0 x i32]], i32 0, align 4
  %i = alloca %t10, align 8
  %i1 = alloca %t10, align 8
  br label %bb_8

bb_8:                                             ; preds = %bb_last, %bb_entry
  br i1 undef, label %bb_last, label %bb_mid

bb_mid:                                           ; preds = %bb_8
  %i4 = getelementptr inbounds %t10, ptr %i1, i64 0, i32 1, i64 32
  %i6 = getelementptr inbounds %t10, ptr %i, i64 0, i32 1, i64 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %i1)
  %v21 = call i64 @llvm.ctlz.i64(i64 undef, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull dereferenceable(16) null, ptr noundef nonnull align 8 dereferenceable(16) %i4, i64 16, i1 false)
  call void @llvm.dbg.value(metadata !DIArgList(ptr %i4, ptr %i4), metadata !4, metadata !DIExpression(DW_OP_LLVM_arg, 0)), !dbg !9
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %i1)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %i)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull dereferenceable(16) null, ptr noundef nonnull align 8 dereferenceable(16) %i6, i64 16, i1 false)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %i)
  br label %bb_last

bb_last:                                          ; preds = %bb_mid, %bb_8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %tmp11)
  call void undef(ptr null, ptr null, ptr null, i32 0, ptr nonnull %tmp11)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %tmp11)
  br label %bb_8
}

declare i64 @llvm.ctlz.i64(i64, i1 immarg)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)
declare void @llvm.dbg.value(metadata, metadata, metadata)

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!2}

!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug)
!1 = !DIFile(filename: "n", directory: "/proc/self/cwd", checksumkind: CSK_MD5, checksum: "e588179fedd8fcdfada963f2434cb950")
!2 = !{i32 2, !"Debug Info Version", i32 3}
!3 = !{!"function_entry_count", i64 2423}
!4 = !DILocalVariable(name: "r", scope: !5, file: !6, line: 93)
!5 = distinct !DISubprogram(name: "c", scope: !7, file: !6, line: 92, spFlags: DISPFlagDefinition, unit: !0)
!6 = !DIFile(filename: "a", directory: "/proc/self/cwd")
!7 = !DINamespace(name: "u", scope: !8)
!8 = !DINamespace(name: "s", scope: null)
!9 = !DILocation(line: 0, scope: !5)
