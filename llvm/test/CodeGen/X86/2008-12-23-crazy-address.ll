; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i686-- -relocation-model=static | FileCheck %s

@X = external dso_local global [0 x i32]

define void @foo() nounwind {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll frob@PLT
; CHECK-NEXT:    addl $4, %esp
; CHECK-NEXT:    leal X(%esp), %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll borf@PLT
; CHECK-NEXT:    addl $4, %esp
; CHECK-NEXT:    popl %eax
; CHECK-NEXT:    retl
entry:
	%Y = alloca i32
	call void @frob(ptr %Y) nounwind
	%ctg2 = getelementptr i8, ptr %Y, i32 ptrtoint (ptr @X to i32)
	%0 = ptrtoint ptr %ctg2 to i32
	call void @borf(i32 %0) nounwind
	ret void
}

define void @bar(i32 %i) nounwind {
; CHECK-LABEL: bar:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    subl $40, %esp
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CHECK-NEXT:    movl %esp, %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll frob@PLT
; CHECK-NEXT:    addl $4, %esp
; CHECK-NEXT:    leal X(%esp,%esi,4), %eax
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    calll borf@PLT
; CHECK-NEXT:    addl $44, %esp
; CHECK-NEXT:    popl %esi
; CHECK-NEXT:    retl
entry:
	%Y = alloca [10 x i32]
	call void @frob(ptr %Y) nounwind
	%0 = getelementptr [0 x i32], ptr @X, i32 0, i32 %i
	%1 = ptrtoint ptr %Y to i32
	%ctg2 = getelementptr i8, ptr %0, i32 %1
	%2 = ptrtoint ptr %ctg2 to i32
	call void @borf(i32 %2) nounwind
	ret void
}

declare void @frob(ptr)

declare void @borf(i32)
