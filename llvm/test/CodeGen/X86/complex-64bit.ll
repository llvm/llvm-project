; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown | FileCheck %s

; Check that we handle the ABI of the complex functions correctly for 32-bit.

declare <2 x half> @llvm.experimental.complex.fmul.v2f16(<2 x half>, <2 x half>)
declare <2 x float> @llvm.experimental.complex.fmul.v2f32(<2 x float>, <2 x float>)
declare <2 x double> @llvm.experimental.complex.fmul.v2f64(<2 x double>, <2 x double>)
declare <2 x x86_fp80> @llvm.experimental.complex.fmul.v2f80(<2 x x86_fp80>, <2 x x86_fp80>)
declare <2 x fp128> @llvm.experimental.complex.fmul.v2f128(<2 x fp128>, <2 x fp128>)

define <2 x half> @intrinsic_f16(<2 x half> %z, <2 x half> %w) {
; CHECK-LABEL: intrinsic_f16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movdqa %xmm1, %xmm2
; CHECK-NEXT:    movdqa %xmm0, %xmm1
; CHECK-NEXT:    psrld $16, %xmm1
; CHECK-NEXT:    movdqa %xmm2, %xmm3
; CHECK-NEXT:    psrld $16, %xmm3
; CHECK-NEXT:    callq __mulhc3@PLT
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
  %mul = call <2 x half> @llvm.experimental.complex.fmul.v2f16(<2 x half> %z, <2 x half> %w)
  ret <2 x half> %mul
}

define <2 x float> @intrinsic_f32(<2 x float> %z, <2 x float> %w) {
; CHECK-LABEL: intrinsic_f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movaps %xmm1, %xmm2
; CHECK-NEXT:    movaps %xmm0, %xmm1
; CHECK-NEXT:    shufps {{.*#+}} xmm1 = xmm1[1,1],xmm0[1,1]
; CHECK-NEXT:    movaps %xmm2, %xmm3
; CHECK-NEXT:    shufps {{.*#+}} xmm3 = xmm3[1,1],xmm2[1,1]
; CHECK-NEXT:    callq __mulsc3@PLT
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
  %mul = call <2 x float> @llvm.experimental.complex.fmul.v2f32(<2 x float> %z, <2 x float> %w)
  ret <2 x float> %mul
}

define <2 x double> @intrinsic_f64(<2 x double> %z, <2 x double> %w) {
; CHECK-LABEL: intrinsic_f64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movaps %xmm1, %xmm2
; CHECK-NEXT:    movaps %xmm0, %xmm1
; CHECK-NEXT:    unpckhpd {{.*#+}} xmm1 = xmm1[1],xmm0[1]
; CHECK-NEXT:    movaps %xmm2, %xmm3
; CHECK-NEXT:    unpckhpd {{.*#+}} xmm3 = xmm3[1],xmm2[1]
; CHECK-NEXT:    callq __muldc3@PLT
; CHECK-NEXT:    movlhps {{.*#+}} xmm0 = xmm0[0],xmm1[0]
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
  %mul = call <2 x double> @llvm.experimental.complex.fmul.v2f64(<2 x double> %z, <2 x double> %w)
  ret <2 x double> %mul
}

define <2 x x86_fp80> @intrinsic_f80(<2 x x86_fp80> %z, <2 x x86_fp80> %w) {
; CHECK-LABEL: intrinsic_f80:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subq $72, %rsp
; CHECK-NEXT:    .cfi_def_cfa_offset 80
; CHECK-NEXT:    fldt {{[0-9]+}}(%rsp)
; CHECK-NEXT:    fldt {{[0-9]+}}(%rsp)
; CHECK-NEXT:    fldt {{[0-9]+}}(%rsp)
; CHECK-NEXT:    fldt {{[0-9]+}}(%rsp)
; CHECK-NEXT:    fstpt {{[0-9]+}}(%rsp)
; CHECK-NEXT:    fstpt {{[0-9]+}}(%rsp)
; CHECK-NEXT:    fstpt {{[0-9]+}}(%rsp)
; CHECK-NEXT:    fstpt (%rsp)
; CHECK-NEXT:    callq __mulxc3@PLT
; CHECK-NEXT:    addq $72, %rsp
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
  %mul = call <2 x x86_fp80> @llvm.experimental.complex.fmul.v2f80(<2 x x86_fp80> %z, <2 x x86_fp80> %w)
  ret <2 x x86_fp80> %mul
}

define <2 x fp128> @intrinsic_f128(<2 x fp128> %z, <2 x fp128> %w) {
; CHECK-LABEL: intrinsic_f128:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subq $40, %rsp
; CHECK-NEXT:    .cfi_def_cfa_offset 48
; CHECK-NEXT:    movq %rsp, %rdi
; CHECK-NEXT:    callq __multc3@PLT
; CHECK-NEXT:    movaps (%rsp), %xmm0
; CHECK-NEXT:    movaps {{[0-9]+}}(%rsp), %xmm1
; CHECK-NEXT:    addq $40, %rsp
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
  %mul = call <2 x fp128> @llvm.experimental.complex.fmul.v2f128(<2 x fp128> %z, <2 x fp128> %w)
  ret <2 x fp128> %mul
}

