; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=i686-- | FileCheck -check-prefix=X86 %s
; RUN: llc < %s -mtriple=x86_64-- | FileCheck -check-prefix=X64 %s

; X86-NOT: and

; X64-NOT: and
; X64-NOT: movzbq
; X64-NOT: movzwq
; X64-NOT: movzlq

; These should use movzbl instead of 'and 255'.
; This related to not having a ZERO_EXTEND_REG opcode.

define i32 @a(i32 %d) nounwind  {
; X86-LABEL: a:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    movzbl %al, %eax
; X86-NEXT:    retl
;
; X64-LABEL: a:
; X64:       # %bb.0:
; X64-NEXT:    incl %edi
; X64-NEXT:    movzbl %dil, %eax
; X64-NEXT:    retq
        %e = add i32 %d, 1
        %retval = and i32 %e, 255
        ret i32 %retval
}
define i32 @b(float %d) nounwind  {
; X86-LABEL: b:
; X86:       # %bb.0:
; X86-NEXT:    subl $8, %esp
; X86-NEXT:    flds {{[0-9]+}}(%esp)
; X86-NEXT:    fnstcw {{[0-9]+}}(%esp)
; X86-NEXT:    movzwl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    orl $3072, %eax # imm = 0xC00
; X86-NEXT:    movw %ax, {{[0-9]+}}(%esp)
; X86-NEXT:    fldcw {{[0-9]+}}(%esp)
; X86-NEXT:    fistps {{[0-9]+}}(%esp)
; X86-NEXT:    fldcw {{[0-9]+}}(%esp)
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl $8, %esp
; X86-NEXT:    retl
;
; X64-LABEL: b:
; X64:       # %bb.0:
; X64-NEXT:    cvttss2si %xmm0, %eax
; X64-NEXT:    movzbl %al, %eax
; X64-NEXT:    retq
        %tmp12 = fptoui float %d to i8
        %retval = zext i8 %tmp12 to i32
        ret i32 %retval
}
define i32 @c(i32 %d) nounwind  {
; X86-LABEL: c:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    movzwl %ax, %eax
; X86-NEXT:    retl
;
; X64-LABEL: c:
; X64:       # %bb.0:
; X64-NEXT:    incl %edi
; X64-NEXT:    movzwl %di, %eax
; X64-NEXT:    retq
        %e = add i32 %d, 1
        %retval = and i32 %e, 65535
        ret i32 %retval
}
define i64 @d(i64 %d) nounwind  {
; X86-LABEL: d:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    movzbl %al, %eax
; X86-NEXT:    xorl %edx, %edx
; X86-NEXT:    retl
;
; X64-LABEL: d:
; X64:       # %bb.0:
; X64-NEXT:    incl %edi
; X64-NEXT:    movzbl %dil, %eax
; X64-NEXT:    retq
        %e = add i64 %d, 1
        %retval = and i64 %e, 255
        ret i64 %retval
}
define i64 @e(i64 %d) nounwind  {
; X86-LABEL: e:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    movzwl %ax, %eax
; X86-NEXT:    xorl %edx, %edx
; X86-NEXT:    retl
;
; X64-LABEL: e:
; X64:       # %bb.0:
; X64-NEXT:    incl %edi
; X64-NEXT:    movzwl %di, %eax
; X64-NEXT:    retq
        %e = add i64 %d, 1
        %retval = and i64 %e, 65535
        ret i64 %retval
}
define i64 @f(i64 %d) nounwind  {
; X86-LABEL: f:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    xorl %edx, %edx
; X86-NEXT:    retl
;
; X64-LABEL: f:
; X64:       # %bb.0:
; X64-NEXT:    leal 1(%rdi), %eax
; X64-NEXT:    retq
        %e = add i64 %d, 1
        %retval = and i64 %e, 4294967295
        ret i64 %retval
}

define i32 @g(i8 %d) nounwind  {
; X86-LABEL: g:
; X86:       # %bb.0:
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incb %al
; X86-NEXT:    movzbl %al, %eax
; X86-NEXT:    retl
;
; X64-LABEL: g:
; X64:       # %bb.0:
; X64-NEXT:    incb %dil
; X64-NEXT:    movzbl %dil, %eax
; X64-NEXT:    retq
        %e = add i8 %d, 1
        %retval = zext i8 %e to i32
        ret i32 %retval
}
define i32 @h(i16 %d) nounwind  {
; X86-LABEL: h:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    movzwl %ax, %eax
; X86-NEXT:    retl
;
; X64-LABEL: h:
; X64:       # %bb.0:
; X64-NEXT:    incl %edi
; X64-NEXT:    movzwl %di, %eax
; X64-NEXT:    retq
        %e = add i16 %d, 1
        %retval = zext i16 %e to i32
        ret i32 %retval
}
define i64 @i(i8 %d) nounwind  {
; X86-LABEL: i:
; X86:       # %bb.0:
; X86-NEXT:    movzbl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incb %al
; X86-NEXT:    movzbl %al, %eax
; X86-NEXT:    xorl %edx, %edx
; X86-NEXT:    retl
;
; X64-LABEL: i:
; X64:       # %bb.0:
; X64-NEXT:    incb %dil
; X64-NEXT:    movzbl %dil, %eax
; X64-NEXT:    retq
        %e = add i8 %d, 1
        %retval = zext i8 %e to i64
        ret i64 %retval
}
define i64 @j(i16 %d) nounwind  {
; X86-LABEL: j:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    movzwl %ax, %eax
; X86-NEXT:    xorl %edx, %edx
; X86-NEXT:    retl
;
; X64-LABEL: j:
; X64:       # %bb.0:
; X64-NEXT:    incl %edi
; X64-NEXT:    movzwl %di, %eax
; X64-NEXT:    retq
        %e = add i16 %d, 1
        %retval = zext i16 %e to i64
        ret i64 %retval
}
define i64 @k(i32 %d) nounwind  {
; X86-LABEL: k:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    incl %eax
; X86-NEXT:    xorl %edx, %edx
; X86-NEXT:    retl
;
; X64-LABEL: k:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal 1(%rdi), %eax
; X64-NEXT:    retq
        %e = add i32 %d, 1
        %retval = zext i32 %e to i64
        ret i64 %retval
}
