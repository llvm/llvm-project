; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc < %s -mtriple=x86_64-- | FileCheck %s

@a = dso_local local_unnamed_addr global i16 0, align 2
@c = internal unnamed_addr global i1 false, align 1
@b = dso_local local_unnamed_addr global i8 0, align 1
@d = dso_local local_unnamed_addr global i32 0, align 4
@e = dso_local local_unnamed_addr global i64 0, align 8

define i32 @PR65895() {
; CHECK-LABEL: PR65895:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movb $2, %al
; CHECK-NEXT:    subb c(%rip), %al
; CHECK-NEXT:    cmpw $0, a(%rip)
; CHECK-NEXT:    je .LBB0_3
; CHECK-NEXT:  # %bb.1: # %for.body.lr.ph
; CHECK-NEXT:    movb %al, b(%rip)
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    jmp .LBB0_2
; CHECK-NEXT:  .LBB0_3: # %for.end
; CHECK-NEXT:    addb $-3, %al
; CHECK-NEXT:    movsbl %al, %eax
; CHECK-NEXT:    movl %eax, d(%rip)
; CHECK-NEXT:    leal 247(%rax,%rax,2), %eax
; CHECK-NEXT:    movb $1, c(%rip)
; CHECK-NEXT:    movsbq %al, %rax
; CHECK-NEXT:    movq %rax, e(%rip)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
entry:
  %.pr = load i16, ptr @a, align 2
  %tobool.not = icmp eq i16 %.pr, 0
  %.b = load i1, ptr @c, align 1
  %0 = select i1 %.b, i8 1, i8 2
  br i1 %tobool.not, label %for.end, label %for.body.lr.ph

for.body.lr.ph:
  store i8 %0, ptr @b, align 1
  br label %for.body

for.body:
  br label %for.body

for.end:
  %sub = add nsw i8 %0, -3
  %conv2 = sext i8 %sub to i32
  store i32 %conv2, ptr @d, align 4
  %add = shl nsw i32 %conv2, 1
  %sub7 = add nsw i32 %conv2, 247
  %add8 = add nsw i32 %sub7, %add
  %conv9 = zext i32 %add8 to i64
  store i1 true, ptr @c, align 1
  %sext = shl i64 %conv9, 56
  %conv11 = ashr exact i64 %sext, 56
  store i64 %conv11, ptr @e, align 8
  ret i32 0
}

declare void @bar(i32)
define void @foo(i8 %arg) nounwind {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    addb $-109, %dil
; CHECK-NEXT:    movsbl %dil, %eax
; CHECK-NEXT:    leal 1(%rax,%rax,2), %edi
; CHECK-NEXT:    callq bar@PLT
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
entry:
  %0 = add nsw i8 %arg, -109
  %1 = sext i8 %0 to i32
  %reassoc = shl i32 %1, 1
  %2 = add i32 %1, 1
  %3 = add i32 %2, %reassoc
  call void @bar(i32 %3)
  ret void
}
