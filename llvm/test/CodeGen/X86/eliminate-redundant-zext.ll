; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -O2 | FileCheck %s

; Test that redundant MOVZX instructions are eliminated when the source
; register is a sub-register of the destination and the destination's upper
; bits are already known to be zero.

; This is the original countholes test case from GitHub issue #160710 that demonstrates
; the redundant movzbl %cl, %ecx in the loop
define i32 @countholes(ptr %s) {
; CHECK-LABEL: countholes:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movzbl (%rdi), %ecx
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpb $48, %cl
; CHECK-NEXT:    jb .LBB0_3
; CHECK-NEXT:  # %bb.1: # %while.body.preheader
; CHECK-NEXT:    incq %rdi
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_2: # %while.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    addl pre_table-192(,%rcx,4), %eax
; CHECK-NEXT:    movzbl (%rdi), %ecx
; CHECK-NEXT:    incq %rdi
; CHECK-NEXT:    cmpb $47, %cl
; CHECK-NEXT:    ja .LBB0_2
; CHECK-NEXT:  .LBB0_3: # %cleanup
; CHECK-NEXT:    retq
entry:
  %c.0 = load i8, ptr %s, align 1
  %conv = zext i8 %c.0 to i32
  %cmp = icmp ult i8 %c.0, 48
  br i1 %cmp, label %cleanup, label %while.body.preheader

while.body.preheader:
  br label %while.body

while.body:
  %s.addr.011 = phi ptr [ %incdec.ptr, %while.body ], [ %s, %while.body.preheader ]
  %c.010 = phi i8 [ %c.1, %while.body ], [ %c.0, %while.body.preheader ]
  %tot.09 = phi i32 [ %add, %while.body ], [ 0, %while.body.preheader ]
  %conv3 = zext i8 %c.010 to i64
  %sub = add nsw i64 %conv3, -48
  %arrayidx = getelementptr inbounds [10 x i32], ptr @pre_table, i64 0, i64 %sub
  %0 = load i32, ptr %arrayidx, align 4
  %add = add i32 %0, %tot.09
  %incdec.ptr = getelementptr inbounds i8, ptr %s.addr.011, i64 1
  %c.1 = load i8, ptr %incdec.ptr, align 1
  %cmp1 = icmp ult i8 %c.1, 48
  br i1 %cmp1, label %cleanup.loopexit, label %while.body

cleanup.loopexit:
  br label %cleanup

cleanup:
  %retval.0 = phi i32 [ 0, %entry ], [ %add, %cleanup.loopexit ]
  ret i32 %retval.0
}

@pre_table = internal constant [10 x i32] [i32 1, i32 0, i32 0, i32 0, i32 1, i32 0, i32 1, i32 0, i32 2, i32 1], align 4
