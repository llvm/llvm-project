; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc %s -o - -enable-shrink-wrap=true | FileCheck --check-prefix=SHRINK-WRAP %s
; RUN: llc %s -o - -enable-shrink-wrap=false | FileCheck --check-prefix=NO-SHRINK-WRAP %s
target datalayout = "e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32"
target triple = "i686-pc-windows-msvc18.0.0"

%struct.S = type { i32 }

; Check that we do not use a basic block that has EFLAGS as live-in
; if we need to realign the stack.
define x86_thiscallcc void @stackRealignment(ptr %this) {
; SHRINK-WRAP-LABEL: stackRealignment:
; SHRINK-WRAP:       # %bb.0: # %entry
; SHRINK-WRAP-NEXT:    movl (%ecx), %eax
; SHRINK-WRAP-NEXT:    cmpl $33, %eax
; SHRINK-WRAP-NEXT:    movl $42, %edx
; SHRINK-WRAP-NEXT:    jge LBB0_2
; SHRINK-WRAP-NEXT:  # %bb.1: # %entry
; SHRINK-WRAP-NEXT:    movl $128, %edx
; SHRINK-WRAP-NEXT:  LBB0_2: # %entry
; SHRINK-WRAP-NEXT:    pushl %ebp
; SHRINK-WRAP-NEXT:    movl %esp, %ebp
; SHRINK-WRAP-NEXT:    andl $-8, %esp
; SHRINK-WRAP-NEXT:    subl $16, %esp
; SHRINK-WRAP-NEXT:    movl %edx, {{[0-9]+}}(%esp)
; SHRINK-WRAP-NEXT:    cmpl $32, %eax
; SHRINK-WRAP-NEXT:    jl LBB0_4
; SHRINK-WRAP-NEXT:  # %bb.3: # %if.end
; SHRINK-WRAP-NEXT:    leal {{[0-9]+}}(%esp), %eax
; SHRINK-WRAP-NEXT:    leal {{[0-9]+}}(%esp), %edx
; SHRINK-WRAP-NEXT:    pushl %eax
; SHRINK-WRAP-NEXT:    pushl %edx
; SHRINK-WRAP-NEXT:    calll _bar
; SHRINK-WRAP-NEXT:  LBB0_4: # %cleanup
; SHRINK-WRAP-NEXT:    movl %ebp, %esp
; SHRINK-WRAP-NEXT:    popl %ebp
; SHRINK-WRAP-NEXT:    retl
;
; NO-SHRINK-WRAP-LABEL: stackRealignment:
; NO-SHRINK-WRAP:       # %bb.0: # %entry
; NO-SHRINK-WRAP-NEXT:    pushl %ebp
; NO-SHRINK-WRAP-NEXT:    movl %esp, %ebp
; NO-SHRINK-WRAP-NEXT:    andl $-8, %esp
; NO-SHRINK-WRAP-NEXT:    subl $16, %esp
; NO-SHRINK-WRAP-NEXT:    movl (%ecx), %eax
; NO-SHRINK-WRAP-NEXT:    cmpl $33, %eax
; NO-SHRINK-WRAP-NEXT:    movl $42, %edx
; NO-SHRINK-WRAP-NEXT:    jge LBB0_2
; NO-SHRINK-WRAP-NEXT:  # %bb.1: # %entry
; NO-SHRINK-WRAP-NEXT:    movl $128, %edx
; NO-SHRINK-WRAP-NEXT:  LBB0_2: # %entry
; NO-SHRINK-WRAP-NEXT:    movl %edx, {{[0-9]+}}(%esp)
; NO-SHRINK-WRAP-NEXT:    cmpl $32, %eax
; NO-SHRINK-WRAP-NEXT:    jl LBB0_4
; NO-SHRINK-WRAP-NEXT:  # %bb.3: # %if.end
; NO-SHRINK-WRAP-NEXT:    leal {{[0-9]+}}(%esp), %eax
; NO-SHRINK-WRAP-NEXT:    leal {{[0-9]+}}(%esp), %edx
; NO-SHRINK-WRAP-NEXT:    pushl %eax
; NO-SHRINK-WRAP-NEXT:    pushl %edx
; NO-SHRINK-WRAP-NEXT:    calll _bar
; NO-SHRINK-WRAP-NEXT:  LBB0_4: # %cleanup
; NO-SHRINK-WRAP-NEXT:    movl %ebp, %esp
; NO-SHRINK-WRAP-NEXT:    popl %ebp
; NO-SHRINK-WRAP-NEXT:    retl
entry:
  %data = alloca [1 x i32], align 4
  %d = alloca double, align 8
  %tmp = bitcast [1 x i32]* %data to i8*
  %arrayinit.begin = getelementptr inbounds [1 x i32], [1 x i32]* %data, i32 0, i32 0
  %x_ = getelementptr inbounds %struct.S, %struct.S* %this, i32 0, i32 0
  %tmp1 = load i32, i32* %x_, align 4
  %cmp = icmp sgt i32 %tmp1, 32
  %cond = select i1 %cmp, i32 42, i32 128
  store i32 %cond, i32* %arrayinit.begin, align 4
  %cmp3 = icmp slt i32 %tmp1, 32
  br i1 %cmp3, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tmp2 = bitcast double* %d to i8*
  call x86_thiscallcc void @bar(%struct.S* nonnull %this, i32* %arrayinit.begin, double* nonnull %d)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: optsize
declare x86_thiscallcc void @bar(%struct.S*, i32*, double*)
