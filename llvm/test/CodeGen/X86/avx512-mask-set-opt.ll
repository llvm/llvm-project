; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx512f | FileCheck %s --check-prefixes=AVX512F
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx512f,+avx512dq | FileCheck %s --check-prefixes=AVX512DQ
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx512f,+avx512bw | FileCheck %s --check-prefixes=AVX512BW
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx512f,+avx512dq,+avx512bw | FileCheck %s --check-prefixes=AVX512DQBW

declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr>, i32, <16 x i1>, <16 x float>)

; Test case 1: v16i1 with all bits set (should use kxnorw on all targets)
define <16 x float> @gather_all(ptr %base, <16 x i32> %ind, i16 %mask) {
; AVX512F-LABEL: gather_all:
; AVX512F:       # %bb.0:
; AVX512F-NEXT:    kxnorw %k0, %k0, %k1
; AVX512F-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512F-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512F-NEXT:    vmovaps %zmm1, %zmm0
; AVX512F-NEXT:    retq
;
; AVX512DQ-LABEL: gather_all:
; AVX512DQ:       # %bb.0:
; AVX512DQ-NEXT:    kxnorw %k0, %k0, %k1
; AVX512DQ-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512DQ-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512DQ-NEXT:    vmovaps %zmm1, %zmm0
; AVX512DQ-NEXT:    retq
;
; AVX512BW-LABEL: gather_all:
; AVX512BW:       # %bb.0:
; AVX512BW-NEXT:    kxnorw %k0, %k0, %k1
; AVX512BW-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512BW-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512BW-NEXT:    vmovaps %zmm1, %zmm0
; AVX512BW-NEXT:    retq
;
; AVX512DQBW-LABEL: gather_all:
; AVX512DQBW:       # %bb.0:
; AVX512DQBW-NEXT:    kxnorw %k0, %k0, %k1
; AVX512DQBW-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512DQBW-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512DQBW-NEXT:    vmovaps %zmm1, %zmm0
; AVX512DQBW-NEXT:    retq
  %broadcast.splatinsert = insertelement <16 x ptr> undef, ptr %base, i32 0
  %broadcast.splat = shufflevector <16 x ptr> %broadcast.splatinsert, <16 x ptr> undef, <16 x i32> zeroinitializer
  %sext_ind = sext <16 x i32> %ind to <16 x i64>
  %gep.random = getelementptr float, <16 x ptr> %broadcast.splat, <16 x i64> %sext_ind
  %res = call <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> %gep.random, i32 4, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <16 x float>undef)
  ret <16 x float> %res
}

; Test case 2: v8i1 with lower 8 bits set (should use kxnorb on AVX512DQ targets)
define <16 x float> @gather_lower(ptr %base, <16 x i32> %ind, i16 %mask) {
; AVX512F-LABEL: gather_lower:
; AVX512F:       # %bb.0:
; AVX512F-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512F-NEXT:    movw $255, %ax
; AVX512F-NEXT:    kmovw %eax, %k1
; AVX512F-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512F-NEXT:    vmovaps %zmm1, %zmm0
; AVX512F-NEXT:    retq
;
; AVX512DQ-LABEL: gather_lower:
; AVX512DQ:       # %bb.0:
; AVX512DQ-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512DQ-NEXT:    kxnorb %k0, %k0, %k1
; AVX512DQ-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512DQ-NEXT:    vmovaps %zmm1, %zmm0
; AVX512DQ-NEXT:    retq
;
; AVX512BW-LABEL: gather_lower:
; AVX512BW:       # %bb.0:
; AVX512BW-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512BW-NEXT:    movw $255, %ax
; AVX512BW-NEXT:    kmovd %eax, %k1
; AVX512BW-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512BW-NEXT:    vmovaps %zmm1, %zmm0
; AVX512BW-NEXT:    retq
;
; AVX512DQBW-LABEL: gather_lower:
; AVX512DQBW:       # %bb.0:
; AVX512DQBW-NEXT:    vxorps %xmm1, %xmm1, %xmm1
; AVX512DQBW-NEXT:    kxnorb %k0, %k0, %k1
; AVX512DQBW-NEXT:    vgatherdps (%rdi,%zmm0,4), %zmm1 {%k1}
; AVX512DQBW-NEXT:    vmovaps %zmm1, %zmm0
; AVX512DQBW-NEXT:    retq
  %broadcast.splatinsert = insertelement <16 x ptr> undef, ptr %base, i32 0
  %broadcast.splat = shufflevector <16 x ptr> %broadcast.splatinsert, <16 x ptr> undef, <16 x i32> zeroinitializer
  %sext_ind = sext <16 x i32> %ind to <16 x i64>
  %gep.random = getelementptr float, <16 x ptr> %broadcast.splat, <16 x i64> %sext_ind
  %res = call <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> %gep.random, i32 4, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <16 x float>undef)
  ret <16 x float> %res
}


