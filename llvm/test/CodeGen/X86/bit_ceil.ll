; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+bmi2,+lzcnt | FileCheck %s

; Check the assembly sequence generated for std::bit_ceil.

define i32 @bit_ceil_i32(i32 %x) {
; CHECK-LABEL: bit_ceil_i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $edi killed $edi def $rdi
; CHECK-NEXT:    leal -1(%rdi), %eax
; CHECK-NEXT:    lzcntl %eax, %eax
; CHECK-NEXT:    negb %al
; CHECK-NEXT:    movl $1, %ecx
; CHECK-NEXT:    shlxl %eax, %ecx, %eax
; CHECK-NEXT:    cmpl $2, %edi
; CHECK-NEXT:    cmovbl %ecx, %eax
; CHECK-NEXT:    retq
  %dec = add i32 %x, -1
  %lz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false)
  %cnt = sub i32 32, %lz
  %res = shl i32 1, %cnt
  %ugt = icmp ugt i32 %x, 1
  %sel = select i1 %ugt, i32 %res, i32 1
  ret i32 %sel
}

define i64 @bit_ceil_i64(i64 %x) {
; CHECK-LABEL: bit_ceil_i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    leaq -1(%rdi), %rax
; CHECK-NEXT:    lzcntq %rax, %rax
; CHECK-NEXT:    negb %al
; CHECK-NEXT:    movl $1, %ecx
; CHECK-NEXT:    shlxq %rax, %rcx, %rax
; CHECK-NEXT:    cmpq $2, %rdi
; CHECK-NEXT:    cmovbq %rcx, %rax
; CHECK-NEXT:    retq
  %dec = add i64 %x, -1
  %lz = tail call i64 @llvm.ctlz.i64(i64 %dec, i1 false)
  %cnt = sub i64 64, %lz
  %res = shl i64 1, %cnt
  %ugt = icmp ugt i64 %x, 1
  %sel = select i1 %ugt, i64 %res, i64 1
  ret i64 %sel
}

declare i32 @llvm.ctlz.i32(i32, i1 immarg)
declare i64 @llvm.ctlz.i64(i64, i1 immarg)
