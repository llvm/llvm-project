; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=i386-unknown-linux-gnu -mattr=-cmov,+mmx < %s | FileCheck %s --check-prefix=I386-NOCMOV
; RUN: llc -mtriple=i386-unknown-linux-gnu -mattr=+cmov,+mmx < %s | FileCheck %s --check-prefix=I386-CMOV
; RUN: llc -mtriple=i386-unknown-linux-gnu -mattr=-cmov,+mmx -verify-machineinstrs < %s | FileCheck %s --check-prefix=I386-NOCMOV

; Test constant-time selection with MMX intrinsics to exercise VR64 CTSELECT
; These tests use MMX intrinsics to create <1 x i64> values that get allocated to VR64 registers

; Test MMX ct.select using paddd intrinsic to force VR64 allocation
define <1 x i64> @test_mmx_ctselect_with_paddd(i32 %cond, i64 %a, i64 %b) {
; I386-NOCMOV-LABEL: test_mmx_ctselect_with_paddd:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    pushl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    subl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 40
; I386-NOCMOV-NEXT:    .cfi_offset %esi, -20
; I386-NOCMOV-NEXT:    .cfi_offset %edi, -16
; I386-NOCMOV-NEXT:    .cfi_offset %ebx, -12
; I386-NOCMOV-NEXT:    .cfi_offset %ebp, -8
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %esi
; I386-NOCMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    setne %bl
; I386-NOCMOV-NEXT:    testb %bl, %bl
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %edi, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-NOCMOV-NEXT:    paddd %mm0, %mm0
; I386-NOCMOV-NEXT:    movq %mm0, (%esp)
; I386-NOCMOV-NEXT:    movl (%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    addl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    popl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    popl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_mmx_ctselect_with_paddd:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    subl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 24
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    setne %dl
; I386-CMOV-NEXT:    testb %dl, %dl
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-CMOV-NEXT:    paddd %mm0, %mm0
; I386-CMOV-NEXT:    movq %mm0, (%esp)
; I386-CMOV-NEXT:    movl (%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-CMOV-NEXT:    addl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-CMOV-NEXT:    retl
  %mmx_a = bitcast i64 %a to <1 x i64>
  %mmx_b = bitcast i64 %b to <1 x i64>
  %cmp = icmp ne i32 %cond, 0
  %sel = call <1 x i64> @llvm.ct.select.v1i64(i1 %cmp, <1 x i64> %mmx_a, <1 x i64> %mmx_b)
  %result = call <1 x i64> @llvm.x86.mmx.padd.d(<1 x i64> %sel, <1 x i64> %sel)
  ret <1 x i64> %result
}

; Test MMX ct.select using psllw intrinsic
define <1 x i64> @test_mmx_ctselect_with_psllw(i32 %cond, i64 %a, i64 %b) {
; I386-NOCMOV-LABEL: test_mmx_ctselect_with_psllw:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    pushl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    subl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 40
; I386-NOCMOV-NEXT:    .cfi_offset %esi, -20
; I386-NOCMOV-NEXT:    .cfi_offset %edi, -16
; I386-NOCMOV-NEXT:    .cfi_offset %ebx, -12
; I386-NOCMOV-NEXT:    .cfi_offset %ebp, -8
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %esi
; I386-NOCMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    setne %bl
; I386-NOCMOV-NEXT:    testb %bl, %bl
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %edi, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-NOCMOV-NEXT:    psllw %mm0, %mm0
; I386-NOCMOV-NEXT:    movq %mm0, (%esp)
; I386-NOCMOV-NEXT:    movl (%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    addl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    popl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    popl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_mmx_ctselect_with_psllw:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    subl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 24
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    setne %dl
; I386-CMOV-NEXT:    testb %dl, %dl
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-CMOV-NEXT:    psllw %mm0, %mm0
; I386-CMOV-NEXT:    movq %mm0, (%esp)
; I386-CMOV-NEXT:    movl (%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-CMOV-NEXT:    addl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-CMOV-NEXT:    retl
  %mmx_a = bitcast i64 %a to <1 x i64>
  %mmx_b = bitcast i64 %b to <1 x i64>
  %cmp = icmp ne i32 %cond, 0
  %sel = call <1 x i64> @llvm.ct.select.v1i64(i1 %cmp, <1 x i64> %mmx_a, <1 x i64> %mmx_b)
  %result = call <1 x i64> @llvm.x86.mmx.psll.w(<1 x i64> %sel, <1 x i64> %sel)
  ret <1 x i64> %result
}

; Test nested MMX ct.selects with pand intrinsic
define <1 x i64> @test_mmx_nested_ctselect_with_pand(i32 %cond1, i32 %cond2, i64 %a, i64 %b, i64 %c) {
; I386-NOCMOV-LABEL: test_mmx_nested_ctselect_with_pand:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    pushl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    subl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 40
; I386-NOCMOV-NEXT:    .cfi_offset %esi, -20
; I386-NOCMOV-NEXT:    .cfi_offset %edi, -16
; I386-NOCMOV-NEXT:    .cfi_offset %ebx, -12
; I386-NOCMOV-NEXT:    .cfi_offset %ebp, -8
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %esi
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edi
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ebx
; I386-NOCMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    setne %cl
; I386-NOCMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    setne %ah
; I386-NOCMOV-NEXT:    testb %ah, %ah
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    testb %cl, %cl
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edi
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edi
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-NOCMOV-NEXT:    pand %mm0, %mm0
; I386-NOCMOV-NEXT:    movq %mm0, (%esp)
; I386-NOCMOV-NEXT:    movl (%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    addl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    popl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    popl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_mmx_nested_ctselect_with_pand:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    pushl %ebx
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-CMOV-NEXT:    pushl %esi
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-CMOV-NEXT:    subl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 32
; I386-CMOV-NEXT:    .cfi_offset %esi, -12
; I386-CMOV-NEXT:    .cfi_offset %ebx, -8
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %esi
; I386-CMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    setne %bl
; I386-CMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    setne %bh
; I386-CMOV-NEXT:    testb %bh, %bh
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %esi
; I386-CMOV-NEXT:    testb %bl, %bl
; I386-CMOV-NEXT:    cmovnel %esi, %edx
; I386-CMOV-NEXT:    movl %edx, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel %ecx, %eax
; I386-CMOV-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-CMOV-NEXT:    pand %mm0, %mm0
; I386-CMOV-NEXT:    movq %mm0, (%esp)
; I386-CMOV-NEXT:    movl (%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-CMOV-NEXT:    addl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-CMOV-NEXT:    popl %esi
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-CMOV-NEXT:    popl %ebx
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-CMOV-NEXT:    retl
  %mmx_a = bitcast i64 %a to <1 x i64>
  %mmx_b = bitcast i64 %b to <1 x i64>
  %mmx_c = bitcast i64 %c to <1 x i64>
  %cmp1 = icmp ne i32 %cond1, 0
  %cmp2 = icmp ne i32 %cond2, 0
  %sel1 = call <1 x i64> @llvm.ct.select.v1i64(i1 %cmp2, <1 x i64> %mmx_a, <1 x i64> %mmx_b)
  %sel2 = call <1 x i64> @llvm.ct.select.v1i64(i1 %cmp1, <1 x i64> %sel1, <1 x i64> %mmx_c)
  %result = call <1 x i64> @llvm.x86.mmx.pand(<1 x i64> %sel2, <1 x i64> %sel2)
  ret <1 x i64> %result
}

; Test MMX ct.select with por intrinsic
define <1 x i64> @test_mmx_ctselect_with_por(i32 %cond, i64 %a, i64 %b) {
; I386-NOCMOV-LABEL: test_mmx_ctselect_with_por:
; I386-NOCMOV:       # %bb.0:
; I386-NOCMOV-NEXT:    pushl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    pushl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    pushl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    pushl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    subl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 40
; I386-NOCMOV-NEXT:    .cfi_offset %esi, -20
; I386-NOCMOV-NEXT:    .cfi_offset %edi, -16
; I386-NOCMOV-NEXT:    .cfi_offset %ebx, -12
; I386-NOCMOV-NEXT:    .cfi_offset %ebp, -8
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %esi
; I386-NOCMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    setne %bl
; I386-NOCMOV-NEXT:    testb %bl, %bl
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %edi, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    BUNDLE
; I386-NOCMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-NOCMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-NOCMOV-NEXT:    por %mm0, %mm0
; I386-NOCMOV-NEXT:    movq %mm0, (%esp)
; I386-NOCMOV-NEXT:    movl (%esp), %eax
; I386-NOCMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-NOCMOV-NEXT:    addl $20, %esp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 20
; I386-NOCMOV-NEXT:    popl %esi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 16
; I386-NOCMOV-NEXT:    popl %edi
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 12
; I386-NOCMOV-NEXT:    popl %ebx
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 8
; I386-NOCMOV-NEXT:    popl %ebp
; I386-NOCMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-NOCMOV-NEXT:    retl
;
; I386-CMOV-LABEL: test_mmx_ctselect_with_por:
; I386-CMOV:       # %bb.0:
; I386-CMOV-NEXT:    subl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 24
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    setne %dl
; I386-CMOV-NEXT:    testb %dl, %dl
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %ecx
; I386-CMOV-NEXT:    movl %ecx, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    cmovnel {{[0-9]+}}(%esp), %eax
; I386-CMOV-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; I386-CMOV-NEXT:    movq {{[0-9]+}}(%esp), %mm0
; I386-CMOV-NEXT:    por %mm0, %mm0
; I386-CMOV-NEXT:    movq %mm0, (%esp)
; I386-CMOV-NEXT:    movl (%esp), %eax
; I386-CMOV-NEXT:    movl {{[0-9]+}}(%esp), %edx
; I386-CMOV-NEXT:    addl $20, %esp
; I386-CMOV-NEXT:    .cfi_def_cfa_offset 4
; I386-CMOV-NEXT:    retl
  %mmx_a = bitcast i64 %a to <1 x i64>
  %mmx_b = bitcast i64 %b to <1 x i64>
  %cmp = icmp ne i32 %cond, 0
  %sel = call <1 x i64> @llvm.ct.select.v1i64(i1 %cmp, <1 x i64> %mmx_a, <1 x i64> %mmx_b)
  %result = call <1 x i64> @llvm.x86.mmx.por(<1 x i64> %sel, <1 x i64> %sel)
  ret <1 x i64> %result
}

; Declare MMX intrinsics
declare <1 x i64> @llvm.x86.mmx.padd.d(<1 x i64>, <1 x i64>)
declare <1 x i64> @llvm.x86.mmx.psll.w(<1 x i64>, <1 x i64>)
declare <1 x i64> @llvm.x86.mmx.pand(<1 x i64>, <1 x i64>)
declare <1 x i64> @llvm.x86.mmx.por(<1 x i64>, <1 x i64>)

; Declare constant-time selection intrinsic
declare <1 x i64> @llvm.ct.select.v1i64(i1, <1 x i64>, <1 x i64>)
