; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+sse2     | FileCheck %s --check-prefixes=X64,SSE,SSE2
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+sse4.2   | FileCheck %s --check-prefixes=X64,SSE,SSE42
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+avx      | FileCheck %s --check-prefixes=X64,AVX
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+avx2     | FileCheck %s --check-prefixes=X64,AVX
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+avx512vl,+avx512bw,+avx512dq | FileCheck %s --check-prefixes=X64,AVX512
; RUN: llc < %s -mtriple=i686-unknown   -mattr=+avx2     | FileCheck %s --check-prefixes=X86

declare i1 @llvm.vector.reduce.and.v2i1(<2 x i1>)
declare i1 @llvm.vector.reduce.and.v4i1(<4 x i1>)
declare i1 @llvm.vector.reduce.and.v8i1(<8 x i1>)

; FIXME: All four versions are semantically equivalent and should produce same asm as scalar version.

define i1 @intrinsic_v2i8(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: intrinsic_v2i8:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movzwl (%rdi), %eax
; X64-NEXT:    cmpw %ax, (%rsi)
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: intrinsic_v2i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movzwl (%eax), %eax
; X86-NEXT:    cmpw %ax, (%ecx)
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <2 x i8>, ptr %arg1, align 1
  %rhs = load <2 x i8>, ptr %arg, align 1
  %cmp = icmp eq <2 x i8> %lhs, %rhs
  %all_eq = call i1 @llvm.vector.reduce.and.v2i1(<2 x i1> %cmp)
  ret i1 %all_eq
}

define i1 @intrinsic_v4i8(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: intrinsic_v4i8:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movl (%rdi), %eax
; X64-NEXT:    cmpl %eax, (%rsi)
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: intrinsic_v4i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%eax), %eax
; X86-NEXT:    cmpl %eax, (%ecx)
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <4 x i8>, ptr %arg1, align 1
  %rhs = load <4 x i8>, ptr %arg, align 1
  %cmp = icmp eq <4 x i8> %lhs, %rhs
  %all_eq = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> %cmp)
  ret i1 %all_eq
}

define i1 @intrinsic_v8i8(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: intrinsic_v8i8:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movq (%rdi), %rax
; X64-NEXT:    cmpq %rax, (%rsi)
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: intrinsic_v8i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    vmovq {{.*#+}} xmm0 = mem[0],zero
; X86-NEXT:    vmovq {{.*#+}} xmm1 = mem[0],zero
; X86-NEXT:    vpcmpeqb %xmm1, %xmm0, %xmm0
; X86-NEXT:    vpmovmskb %xmm0, %eax
; X86-NEXT:    cmpb $-1, %al
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <8 x i8>, ptr %arg1, align 1
  %rhs = load <8 x i8>, ptr %arg, align 1
  %cmp = icmp eq <8 x i8> %lhs, %rhs
  %all_eq = call i1 @llvm.vector.reduce.and.v8i1(<8 x i1> %cmp)
  ret i1 %all_eq
}

define i1 @vector_version_v2i8(ptr align 1 %arg, ptr align 1 %arg1) {
; SSE2-LABEL: vector_version_v2i8:
; SSE2:       # %bb.0: # %bb
; SSE2-NEXT:    movzwl (%rsi), %eax
; SSE2-NEXT:    movd %eax, %xmm0
; SSE2-NEXT:    movzwl (%rdi), %eax
; SSE2-NEXT:    movd %eax, %xmm1
; SSE2-NEXT:    pcmpeqb %xmm0, %xmm1
; SSE2-NEXT:    pcmpeqd %xmm0, %xmm0
; SSE2-NEXT:    pxor %xmm1, %xmm0
; SSE2-NEXT:    punpcklbw {{.*#+}} xmm0 = xmm0[0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]
; SSE2-NEXT:    pshuflw {{.*#+}} xmm0 = xmm0[0,0,2,1,4,5,6,7]
; SSE2-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,0,1,1]
; SSE2-NEXT:    movmskpd %xmm0, %eax
; SSE2-NEXT:    testl %eax, %eax
; SSE2-NEXT:    sete %al
; SSE2-NEXT:    retq
;
; SSE42-LABEL: vector_version_v2i8:
; SSE42:       # %bb.0: # %bb
; SSE42-NEXT:    pmovzxbq {{.*#+}} xmm0 = mem[0],zero,zero,zero,zero,zero,zero,zero,mem[1],zero,zero,zero,zero,zero,zero,zero
; SSE42-NEXT:    pmovzxbq {{.*#+}} xmm1 = mem[0],zero,zero,zero,zero,zero,zero,zero,mem[1],zero,zero,zero,zero,zero,zero,zero
; SSE42-NEXT:    psubq %xmm1, %xmm0
; SSE42-NEXT:    ptest %xmm0, %xmm0
; SSE42-NEXT:    sete %al
; SSE42-NEXT:    retq
;
; AVX-LABEL: vector_version_v2i8:
; AVX:       # %bb.0: # %bb
; AVX-NEXT:    vpmovzxbq {{.*#+}} xmm0 = mem[0],zero,zero,zero,zero,zero,zero,zero,mem[1],zero,zero,zero,zero,zero,zero,zero
; AVX-NEXT:    vpmovzxbq {{.*#+}} xmm1 = mem[0],zero,zero,zero,zero,zero,zero,zero,mem[1],zero,zero,zero,zero,zero,zero,zero
; AVX-NEXT:    vpsubq %xmm1, %xmm0, %xmm0
; AVX-NEXT:    vptest %xmm0, %xmm0
; AVX-NEXT:    sete %al
; AVX-NEXT:    retq
;
; AVX512-LABEL: vector_version_v2i8:
; AVX512:       # %bb.0: # %bb
; AVX512-NEXT:    movzwl (%rsi), %eax
; AVX512-NEXT:    vmovd %eax, %xmm0
; AVX512-NEXT:    movzwl (%rdi), %eax
; AVX512-NEXT:    vmovd %eax, %xmm1
; AVX512-NEXT:    vpcmpneqb %xmm1, %xmm0, %k0
; AVX512-NEXT:    kmovd %k0, %eax
; AVX512-NEXT:    testb $3, %al
; AVX512-NEXT:    sete %al
; AVX512-NEXT:    retq
;
; X86-LABEL: vector_version_v2i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    vpmovzxbq {{.*#+}} xmm0 = mem[0],zero,zero,zero,zero,zero,zero,zero,mem[1],zero,zero,zero,zero,zero,zero,zero
; X86-NEXT:    vpmovzxbq {{.*#+}} xmm1 = mem[0],zero,zero,zero,zero,zero,zero,zero,mem[1],zero,zero,zero,zero,zero,zero,zero
; X86-NEXT:    vpsubq %xmm1, %xmm0, %xmm0
; X86-NEXT:    vptest %xmm0, %xmm0
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <2 x i8>, ptr %arg1, align 1
  %rhs = load <2 x i8>, ptr %arg, align 1
  %any_ne = icmp ne <2 x i8> %lhs, %rhs
  %any_ne_scalar = bitcast <2 x i1> %any_ne to i2
  %all_eq = icmp eq i2 %any_ne_scalar, 0
  ret i1 %all_eq
}

define i1 @vector_version_v4i8(ptr align 1 %arg, ptr align 1 %arg1) {
; SSE2-LABEL: vector_version_v4i8:
; SSE2:       # %bb.0: # %bb
; SSE2-NEXT:    movd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; SSE2-NEXT:    movd {{.*#+}} xmm1 = mem[0],zero,zero,zero
; SSE2-NEXT:    pcmpeqb %xmm0, %xmm1
; SSE2-NEXT:    pcmpeqd %xmm0, %xmm0
; SSE2-NEXT:    pxor %xmm1, %xmm0
; SSE2-NEXT:    punpcklbw {{.*#+}} xmm0 = xmm0[0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]
; SSE2-NEXT:    punpcklwd {{.*#+}} xmm0 = xmm0[0,0,1,1,2,2,3,3]
; SSE2-NEXT:    movmskps %xmm0, %eax
; SSE2-NEXT:    testl %eax, %eax
; SSE2-NEXT:    sete %al
; SSE2-NEXT:    retq
;
; SSE42-LABEL: vector_version_v4i8:
; SSE42:       # %bb.0: # %bb
; SSE42-NEXT:    pmovzxbd {{.*#+}} xmm0 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; SSE42-NEXT:    pmovzxbd {{.*#+}} xmm1 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; SSE42-NEXT:    psubd %xmm1, %xmm0
; SSE42-NEXT:    ptest %xmm0, %xmm0
; SSE42-NEXT:    sete %al
; SSE42-NEXT:    retq
;
; AVX-LABEL: vector_version_v4i8:
; AVX:       # %bb.0: # %bb
; AVX-NEXT:    vpmovzxbd {{.*#+}} xmm0 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; AVX-NEXT:    vpmovzxbd {{.*#+}} xmm1 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; AVX-NEXT:    vpsubd %xmm1, %xmm0, %xmm0
; AVX-NEXT:    vptest %xmm0, %xmm0
; AVX-NEXT:    sete %al
; AVX-NEXT:    retq
;
; AVX512-LABEL: vector_version_v4i8:
; AVX512:       # %bb.0: # %bb
; AVX512-NEXT:    vmovd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX512-NEXT:    vmovd {{.*#+}} xmm1 = mem[0],zero,zero,zero
; AVX512-NEXT:    vpcmpneqb %xmm1, %xmm0, %k0
; AVX512-NEXT:    kmovd %k0, %eax
; AVX512-NEXT:    testb $15, %al
; AVX512-NEXT:    sete %al
; AVX512-NEXT:    retq
;
; X86-LABEL: vector_version_v4i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    vpmovzxbd {{.*#+}} xmm0 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; X86-NEXT:    vpmovzxbd {{.*#+}} xmm1 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; X86-NEXT:    vpsubd %xmm1, %xmm0, %xmm0
; X86-NEXT:    vptest %xmm0, %xmm0
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <4 x i8>, ptr %arg1, align 1
  %rhs = load <4 x i8>, ptr %arg, align 1
  %any_ne = icmp ne <4 x i8> %lhs, %rhs
  %any_ne_scalar = bitcast <4 x i1> %any_ne to i4
  %all_eq = icmp eq i4 %any_ne_scalar, 0
  ret i1 %all_eq
}

define i1 @vector_version_v8i8(ptr align 1 %arg, ptr align 1 %arg1) {
; SSE-LABEL: vector_version_v8i8:
; SSE:       # %bb.0: # %bb
; SSE-NEXT:    movq {{.*#+}} xmm0 = mem[0],zero
; SSE-NEXT:    movq {{.*#+}} xmm1 = mem[0],zero
; SSE-NEXT:    pcmpeqb %xmm0, %xmm1
; SSE-NEXT:    pmovmskb %xmm1, %eax
; SSE-NEXT:    xorb $-1, %al
; SSE-NEXT:    sete %al
; SSE-NEXT:    retq
;
; AVX-LABEL: vector_version_v8i8:
; AVX:       # %bb.0: # %bb
; AVX-NEXT:    vmovq {{.*#+}} xmm0 = mem[0],zero
; AVX-NEXT:    vmovq {{.*#+}} xmm1 = mem[0],zero
; AVX-NEXT:    vpcmpeqb %xmm1, %xmm0, %xmm0
; AVX-NEXT:    vpmovmskb %xmm0, %eax
; AVX-NEXT:    xorb $-1, %al
; AVX-NEXT:    sete %al
; AVX-NEXT:    retq
;
; AVX512-LABEL: vector_version_v8i8:
; AVX512:       # %bb.0: # %bb
; AVX512-NEXT:    vmovq {{.*#+}} xmm0 = mem[0],zero
; AVX512-NEXT:    vmovq {{.*#+}} xmm1 = mem[0],zero
; AVX512-NEXT:    vpcmpneqb %xmm1, %xmm0, %k0
; AVX512-NEXT:    kortestb %k0, %k0
; AVX512-NEXT:    sete %al
; AVX512-NEXT:    retq
;
; X86-LABEL: vector_version_v8i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    vmovq {{.*#+}} xmm0 = mem[0],zero
; X86-NEXT:    vmovq {{.*#+}} xmm1 = mem[0],zero
; X86-NEXT:    vpcmpeqb %xmm1, %xmm0, %xmm0
; X86-NEXT:    vpmovmskb %xmm0, %eax
; X86-NEXT:    xorb $-1, %al
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <8 x i8>, ptr %arg1, align 1
  %rhs = load <8 x i8>, ptr %arg, align 1
  %any_ne = icmp ne <8 x i8> %lhs, %rhs
  %any_ne_scalar = bitcast <8 x i1> %any_ne to i8
  %all_eq = icmp eq i8 %any_ne_scalar, 0
  ret i1 %all_eq
}

define i1 @mixed_version_v2i8(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: mixed_version_v2i8:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movzwl (%rsi), %eax
; X64-NEXT:    cmpw (%rdi), %ax
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: mixed_version_v2i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movzwl (%ecx), %ecx
; X86-NEXT:    cmpw (%eax), %cx
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <2 x i8>, ptr %arg1, align 1
  %rhs = load <2 x i8>, ptr %arg, align 1
  %lhs_s = bitcast <2 x i8> %lhs to i16
  %rhs_s = bitcast <2 x i8> %rhs to i16
  %all_eq = icmp eq i16 %lhs_s, %rhs_s
  ret i1 %all_eq
}

define i1 @mixed_version_v4i8(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: mixed_version_v4i8:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movl (%rsi), %eax
; X64-NEXT:    cmpl (%rdi), %eax
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: mixed_version_v4i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%ecx), %ecx
; X86-NEXT:    cmpl (%eax), %ecx
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <4 x i8>, ptr %arg1, align 1
  %rhs = load <4 x i8>, ptr %arg, align 1
  %lhs_s = bitcast <4 x i8> %lhs to i32
  %rhs_s = bitcast <4 x i8> %rhs to i32
  %all_eq = icmp eq i32 %lhs_s, %rhs_s
  ret i1 %all_eq
}

define i1 @mixed_version_v8i8(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: mixed_version_v8i8:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movq (%rsi), %rax
; X64-NEXT:    cmpq (%rdi), %rax
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: mixed_version_v8i8:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%ecx), %edx
; X86-NEXT:    movl 4(%ecx), %ecx
; X86-NEXT:    xorl 4(%eax), %ecx
; X86-NEXT:    xorl (%eax), %edx
; X86-NEXT:    orl %ecx, %edx
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load <8 x i8>, ptr %arg1, align 1
  %rhs = load <8 x i8>, ptr %arg, align 1
  %lhs_s = bitcast <8 x i8> %lhs to i64
  %rhs_s = bitcast <8 x i8> %rhs to i64
  %all_eq = icmp eq i64 %lhs_s, %rhs_s
  ret i1 %all_eq
}

define i1 @scalar_version_i16(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: scalar_version_i16:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movzwl (%rsi), %eax
; X64-NEXT:    cmpw (%rdi), %ax
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: scalar_version_i16:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movzwl (%ecx), %ecx
; X86-NEXT:    cmpw (%eax), %cx
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load i16, ptr %arg1, align 1
  %rhs = load i16, ptr %arg, align 1
  %all_eq = icmp eq i16 %lhs, %rhs
  ret i1 %all_eq
}

define i1 @scalar_version_i32(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: scalar_version_i32:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movl (%rsi), %eax
; X64-NEXT:    cmpl (%rdi), %eax
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: scalar_version_i32:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%ecx), %ecx
; X86-NEXT:    cmpl (%eax), %ecx
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load i32, ptr %arg1, align 1
  %rhs = load i32, ptr %arg, align 1
  %all_eq = icmp eq i32 %lhs, %rhs
  ret i1 %all_eq
}

define i1 @scalar_version_i64(ptr align 1 %arg, ptr align 1 %arg1) {
; X64-LABEL: scalar_version_i64:
; X64:       # %bb.0: # %bb
; X64-NEXT:    movq (%rsi), %rax
; X64-NEXT:    cmpq (%rdi), %rax
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-LABEL: scalar_version_i64:
; X86:       # %bb.0: # %bb
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl (%ecx), %edx
; X86-NEXT:    movl 4(%ecx), %ecx
; X86-NEXT:    xorl 4(%eax), %ecx
; X86-NEXT:    xorl (%eax), %edx
; X86-NEXT:    orl %ecx, %edx
; X86-NEXT:    sete %al
; X86-NEXT:    retl
bb:
  %lhs = load i64, ptr %arg1, align 1
  %rhs = load i64, ptr %arg, align 1
  %all_eq = icmp eq i64 %lhs, %rhs
  ret i1 %all_eq
}
