; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+avx2 | FileCheck %s --check-prefixes=AVX

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare i1 @llvm.vector.reduce.and.v4i1(<4 x i1>)

; FIXME: All four versions are semantically equivalent and should produce same asm as scalar version.
define i1 @intrinsic_version(i8* align 1 %arg, i8* align 1 %arg1, i32 %arg2) {
; AVX-LABEL: intrinsic_version:
; AVX:       # %bb.0: # %bb
; AVX-NEXT:    vpmovzxbd {{.*#+}} xmm0 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; AVX-NEXT:    vpmovzxbd {{.*#+}} xmm1 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; AVX-NEXT:    vpsubd %xmm1, %xmm0, %xmm0
; AVX-NEXT:    vptest %xmm0, %xmm0
; AVX-NEXT:    sete %al
; AVX-NEXT:    retq
bb:
  %ptr1 = bitcast i8* %arg1 to <4 x i8>*
  %ptr2 = bitcast i8* %arg to <4 x i8>*
  %lhs = load <4 x i8>, <4 x i8>* %ptr1, align 1
  %rhs = load <4 x i8>, <4 x i8>* %ptr2, align 1
  %cmp = icmp eq <4 x i8> %lhs, %rhs
  %all_eq = call i1 @llvm.vector.reduce.and.v4i1(<4 x i1> %cmp)
  ret i1 %all_eq
}

define i1 @vector_version(i8* align 1 %arg, i8* align 1 %arg1) {
; AVX-LABEL: vector_version:
; AVX:       # %bb.0: # %bb
; AVX-NEXT:    vpmovzxbd {{.*#+}} xmm0 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; AVX-NEXT:    vpmovzxbd {{.*#+}} xmm1 = mem[0],zero,zero,zero,mem[1],zero,zero,zero,mem[2],zero,zero,zero,mem[3],zero,zero,zero
; AVX-NEXT:    vpsubd %xmm1, %xmm0, %xmm0
; AVX-NEXT:    vptest %xmm0, %xmm0
; AVX-NEXT:    sete %al
; AVX-NEXT:    retq
bb:
  %ptr1 = bitcast i8* %arg1 to <4 x i8>*
  %ptr2 = bitcast i8* %arg to <4 x i8>*
  %lhs = load <4 x i8>, <4 x i8>* %ptr1, align 1
  %rhs = load <4 x i8>, <4 x i8>* %ptr2, align 1
  %any_ne = icmp ne <4 x i8> %lhs, %rhs
  %any_ne_scalar = bitcast <4 x i1> %any_ne to i4
  %all_eq = icmp eq i4 %any_ne_scalar, 0
  ret i1 %all_eq
}

define i1 @mixed_version(i8* align 1 %arg, i8* align 1 %arg1) {
; AVX-LABEL: mixed_version:
; AVX:       # %bb.0: # %bb
; AVX-NEXT:    movl (%rsi), %eax
; AVX-NEXT:    cmpl (%rdi), %eax
; AVX-NEXT:    sete %al
; AVX-NEXT:    retq
bb:
  %ptr1 = bitcast i8* %arg1 to <4 x i8>*
  %ptr2 = bitcast i8* %arg to <4 x i8>*
  %lhs = load <4 x i8>, <4 x i8>* %ptr1, align 1
  %rhs = load <4 x i8>, <4 x i8>* %ptr2, align 1
  %lhs_s = bitcast <4 x i8> %lhs to i32
  %rhs_s = bitcast <4 x i8> %rhs to i32
  %all_eq = icmp eq i32 %lhs_s, %rhs_s
  ret i1 %all_eq
}

define i1 @scalar_version(i8* align 1 %arg, i8* align 1 %arg1) {
; AVX-LABEL: scalar_version:
; AVX:       # %bb.0: # %bb
; AVX-NEXT:    movl (%rsi), %eax
; AVX-NEXT:    cmpl (%rdi), %eax
; AVX-NEXT:    sete %al
; AVX-NEXT:    retq
bb:
  %ptr1 = bitcast i8* %arg1 to i32*
  %ptr2 = bitcast i8* %arg to i32*
  %lhs = load i32, i32* %ptr1, align 1
  %rhs = load i32, i32* %ptr2, align 1
  %all_eq = icmp eq i32 %lhs, %rhs
  ret i1 %all_eq
}
