; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; test for more complicated forms of lea operands which can be generated
; in loop optimized cases.
; See also http://llvm.org/bugs/show_bug.cgi?id=20016

; RUN: llc < %s -mtriple=x86_64-linux -O2        | FileCheck %s
; RUN: llc < %s -mtriple=x86_64-linux-gnux32 -O2 | FileCheck %s -check-prefix=X32
; RUN: llc < %s -mtriple=x86_64-nacl -O2 | FileCheck %s -check-prefix=X32

; Function Attrs: nounwind readnone uwtable
define void @foo(i32 %x, i32 %d) #0 {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movslq %esi, %rax
; CHECK-NEXT:    leaq (%rsp,%rax,4), %rax
; CHECK-NEXT:    addq $-40, %rax
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_1: # %while.cond
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmpl $0, (%rax)
; CHECK-NEXT:    leaq 4(%rax), %rax
; CHECK-NEXT:    jne .LBB0_1
; CHECK-NEXT:  # %bb.2: # %while.end
; CHECK-NEXT:    retq
;
; X32-LABEL: foo:
; X32:       # %bb.0: # %entry
; X32-NEXT:    # kill: def $esi killed $esi def $rsi
; X32-NEXT:    leal (%rsp,%rsi,4), %eax
; X32-NEXT:    addl $-40, %eax
; X32-NEXT:    .p2align 4
; X32-NEXT:  .LBB0_1: # %while.cond
; X32-NEXT:    # =>This Inner Loop Header: Depth=1
; X32-NEXT:    cmpl $0, (%eax)
; X32-NEXT:    leal 4(%rax), %eax
; X32-NEXT:    # kill: def $eax killed $eax def $rax
; X32-NEXT:    jne .LBB0_1
; X32-NEXT:  # %bb.2: # %while.end
; X32-NEXT:    retq
entry:
  %a = alloca [8 x i32], align 16
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %d.addr.0 = phi i32 [ %d, %entry ], [ %inc, %while.cond ]
  %arrayidx = getelementptr inbounds [8 x i32], ptr %a, i32 0, i32 %d.addr.0

  %0 = load i32, ptr %arrayidx, align 4
  %cmp1 = icmp eq i32 %0, 0
  %inc = add nsw i32 %d.addr.0, 1

  br i1 %cmp1, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; The same test as above but with enforsed stack realignment (%a aligned by 64)
; to check one more case of correct lea generation.

; Function Attrs: nounwind readnone uwtable
define void @bar(i32 %x, i32 %d) #0 {
; CHECK-LABEL: bar:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset %rbp, -16
; CHECK-NEXT:    movq %rsp, %rbp
; CHECK-NEXT:    .cfi_def_cfa_register %rbp
; CHECK-NEXT:    andq $-64, %rsp
; CHECK-NEXT:    subq $64, %rsp
; CHECK-NEXT:    movslq %esi, %rax
; CHECK-NEXT:    leaq (%rsp,%rax,4), %rax
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB1_1: # %while.cond
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmpl $0, (%rax)
; CHECK-NEXT:    leaq 4(%rax), %rax
; CHECK-NEXT:    jne .LBB1_1
; CHECK-NEXT:  # %bb.2: # %while.end
; CHECK-NEXT:    movq %rbp, %rsp
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:    .cfi_def_cfa %rsp, 8
; CHECK-NEXT:    retq
entry:
  %a = alloca [8 x i32], align 64
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %d.addr.0 = phi i32 [ %d, %entry ], [ %inc, %while.cond ]
  %arrayidx = getelementptr inbounds [8 x i32], ptr %a, i32 0, i32 %d.addr.0

  %0 = load i32, ptr %arrayidx, align 4
  %cmp1 = icmp eq i32 %0, 0
  %inc = add nsw i32 %d.addr.0, 1

  br i1 %cmp1, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

