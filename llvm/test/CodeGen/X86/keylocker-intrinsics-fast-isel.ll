; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -fast-isel -mtriple=x86_64-unknown-unknown -mattr=+kl,+widekl | FileCheck %s

; NOTE: This should use IR equivalent to what is generated by clang/test/CodeGen/X86/keylocker-builtins.c

define void @test_loadiwkey(i32 %ctl, <2 x i64> %intkey, <2 x i64> %enkey_lo, <2 x i64> %enkey_hi) {
; CHECK-LABEL: test_loadiwkey:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    loadiwkey %xmm2, %xmm1
; CHECK-NEXT:    retq
entry:
  tail call void @llvm.x86.loadiwkey(<2 x i64> %intkey, <2 x i64> %enkey_lo, <2 x i64> %enkey_hi, i32 %ctl)
  ret void
}

define i32 @test_encodekey128_u32(i32 %htype, <2 x i64> %key, i8* nocapture %h) {
; CHECK-LABEL: test_encodekey128_u32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    encodekey128 %edi, %eax
; CHECK-NEXT:    movups %xmm0, (%rsi)
; CHECK-NEXT:    movups %xmm1, 16(%rsi)
; CHECK-NEXT:    movups %xmm2, 32(%rsi)
; CHECK-NEXT:    movups %xmm4, 48(%rsi)
; CHECK-NEXT:    movups %xmm5, 64(%rsi)
; CHECK-NEXT:    movups %xmm6, 80(%rsi)
; CHECK-NEXT:    retq
entry:
  %0 = tail call { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } @llvm.x86.encodekey128(i32 %htype, <2 x i64> %key)
  %1 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 1
  %2 = bitcast i8* %h to <2 x i64>*
  store <2 x i64> %1, <2 x i64>* %2, align 1
  %3 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 2
  %4 = getelementptr i8, i8* %h, i64 16
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64> %3, <2 x i64>* %5, align 1
  %6 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 3
  %7 = getelementptr i8, i8* %h, i64 32
  %8 = bitcast i8* %7 to <2 x i64>*
  store <2 x i64> %6, <2 x i64>* %8, align 1
  %9 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 4
  %10 = getelementptr i8, i8* %h, i64 48
  %11 = bitcast i8* %10 to <2 x i64>*
  store <2 x i64> %9, <2 x i64>* %11, align 1
  %12 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 5
  %13 = getelementptr i8, i8* %h, i64 64
  %14 = bitcast i8* %13 to <2 x i64>*
  store <2 x i64> %12, <2 x i64>* %14, align 1
  %15 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 6
  %16 = getelementptr i8, i8* %h, i64 80
  %17 = bitcast i8* %16 to <2 x i64>*
  store <2 x i64> %15, <2 x i64>* %17, align 1
  %18 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 0
  ret i32 %18
}

define i32 @test_encodekey256_u32(i32 %htype, <2 x i64> %key_lo, <2 x i64> %key_hi, i8* nocapture %h) {
; CHECK-LABEL: test_encodekey256_u32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    encodekey256 %edi, %eax
; CHECK-NEXT:    movups %xmm0, (%rsi)
; CHECK-NEXT:    movups %xmm1, 16(%rsi)
; CHECK-NEXT:    movups %xmm2, 32(%rsi)
; CHECK-NEXT:    movups %xmm3, 48(%rsi)
; CHECK-NEXT:    movups %xmm4, 64(%rsi)
; CHECK-NEXT:    movups %xmm5, 80(%rsi)
; CHECK-NEXT:    movups %xmm6, 96(%rsi)
; CHECK-NEXT:    retq
entry:
  %0 = tail call { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } @llvm.x86.encodekey256(i32 %htype, <2 x i64> %key_lo, <2 x i64> %key_hi)
  %1 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 1
  %2 = bitcast i8* %h to <2 x i64>*
  store <2 x i64> %1, <2 x i64>* %2, align 1
  %3 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 2
  %4 = getelementptr i8, i8* %h, i64 16
  %5 = bitcast i8* %4 to <2 x i64>*
  store <2 x i64> %3, <2 x i64>* %5, align 1
  %6 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 3
  %7 = getelementptr i8, i8* %h, i64 32
  %8 = bitcast i8* %7 to <2 x i64>*
  store <2 x i64> %6, <2 x i64>* %8, align 1
  %9 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 4
  %10 = getelementptr i8, i8* %h, i64 48
  %11 = bitcast i8* %10 to <2 x i64>*
  store <2 x i64> %9, <2 x i64>* %11, align 1
  %12 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 5
  %13 = getelementptr i8, i8* %h, i64 64
  %14 = bitcast i8* %13 to <2 x i64>*
  store <2 x i64> %12, <2 x i64>* %14, align 1
  %15 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 6
  %16 = getelementptr i8, i8* %h, i64 80
  %17 = bitcast i8* %16 to <2 x i64>*
  store <2 x i64> %15, <2 x i64>* %17, align 1
  %18 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 7
  %19 = getelementptr i8, i8* %h, i64 96
  %20 = bitcast i8* %19 to <2 x i64>*
  store <2 x i64> %18, <2 x i64>* %20, align 1
  %21 = extractvalue { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } %0, 0
  ret i32 %21
}

declare void @llvm.x86.loadiwkey(<2 x i64>, <2 x i64>, <2 x i64>, i32)
declare { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } @llvm.x86.encodekey128(i32, <2 x i64>)
declare { i32, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> } @llvm.x86.encodekey256(i32, <2 x i64>, <2 x i64>)
