; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-linux -branch-hint -branch-hint-probability-threshold=60 -show-mc-encoding | FileCheck %s

; Design: Insert "ds # encoding: [0x3e]" for condition branches who has high probability to take.
; Source code:
; int XX = 0;
; int bar(int x);
; void foo(int a, int b, char* c) {
;   if (a == 0) {
;     XX += 1;
;   } else {
;     if (c == 0)
;       XX += 2;
;   }
;   for(int i=0; i<b; i++)
;     bar(XX);
; }

@XX = dso_local local_unnamed_addr global i32 0, align 4

; Function Attrs: nounwind
define dso_local void @foo(i32 noundef %a, i32 noundef %b, i8* noundef readnone %c) local_unnamed_addr #0 {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbx # encoding: [0x53]
; CHECK-NEXT:    movl %esi, %ebx # encoding: [0x89,0xf3]
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    je .LBB0_1 # encoding: [0x74,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB0_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.else
; CHECK-NEXT:    testq %rdx, %rdx # encoding: [0x48,0x85,0xd2]
; CHECK-NEXT:    ds # encoding: [0x3e]
; CHECK-NEXT:    jne .LBB0_5 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB0_5-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    movl $2, %eax # encoding: [0xb8,0x02,0x00,0x00,0x00]
; CHECK-NEXT:    jmp .LBB0_4 # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB0_4-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB0_1:
; CHECK-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; CHECK-NEXT:  .LBB0_4: # %if.end4.sink.split
; CHECK-NEXT:    addl %eax, XX(%rip) # encoding: [0x01,0x05,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 2, value: XX-4, kind: reloc_riprel_4byte
; CHECK-NEXT:  .LBB0_5: # %if.end4
; CHECK-NEXT:    testl %ebx, %ebx # encoding: [0x85,0xdb]
; CHECK-NEXT:    jle .LBB0_7 # encoding: [0x7e,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB0_7-1, kind: FK_PCRel_1
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_6: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl XX(%rip), %edi # encoding: [0x8b,0x3d,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 2, value: XX-4, kind: reloc_riprel_4byte_relax
; CHECK-NEXT:    callq bar # encoding: [0xe8,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: bar-4, kind: reloc_branch_4byte_pcrel
; CHECK-NEXT:    decl %ebx # encoding: [0xff,0xcb]
; CHECK-NEXT:    ds # encoding: [0x3e]
; CHECK-NEXT:    jne .LBB0_6 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB0_6-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB0_7: # %for.cond.cleanup
; CHECK-NEXT:    popq %rbx # encoding: [0x5b]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp eq i32 %a, 0
  br i1 %cmp, label %if.end4.sink.split, label %if.else

if.else:                                          ; preds = %entry
  %cmp1 = icmp eq i8* %c, null
  br i1 %cmp1, label %if.end4.sink.split, label %if.end4

if.end4.sink.split:                               ; preds = %if.else, %entry
  %.sink10 = phi i32 [ 1, %entry ], [ 2, %if.else ]
  %0 = load i32, i32* @XX, align 4
  %add3 = add nsw i32 %0, %.sink10
  store i32 %add3, i32* @XX, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.end4.sink.split, %if.else
  %cmp58 = icmp sgt i32 %b, 0
  br i1 %cmp58, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.body, %if.end4
  ret void

for.body:                                         ; preds = %if.end4, %for.body
  %i.09 = phi i32 [ %inc, %for.body ], [ 0, %if.end4 ]
  %1 = load i32, i32* @XX, align 4
  %call = tail call i32 @bar(i32 noundef %1) #0
  %inc = add nuw nsw i32 %i.09, 1
  %exitcond.not = icmp eq i32 %inc, %b
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

declare dso_local i32 @bar(i32 noundef) local_unnamed_addr #0

attributes #0 = { nounwind "target-features"="+branch-hint" }
