; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=x86_64-pc-linux-gnu -verify-coalescing < %s | FileCheck %s

%"class.llvm::APInt." = type <{ %union.anon., i32, [4 x i8] }>
%union.anon. = type { i64 }

define void @_ZNK4llvm5APInt21multiplicativeInverseERKS0_(ptr %r) {
; CHECK-LABEL: _ZNK4llvm5APInt21multiplicativeInverseERKS0_:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    jmp .LBB0_1
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_4: # %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    movl %edx, %edx
; CHECK-NEXT:    shlq $4, %rdx
; CHECK-NEXT:    movl $0, (%rdi,%rdx)
; CHECK-NEXT:    movl %ecx, %edx
; CHECK-NEXT:  .LBB0_1: # %bb
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB0_3 Depth 2
; CHECK-NEXT:    xorl $1, %ecx
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:    movq %rcx, %r8
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    jne .LBB0_4
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_3: # %for.body.i.i.i.i.i.3
; CHECK-NEXT:    # Parent Loop BB0_1 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    orq $1, %r8
; CHECK-NEXT:    orq $1, %rsi
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    je .LBB0_3
; CHECK-NEXT:    jmp .LBB0_4
entry:
  br label %bb

bb:                                               ; preds = %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %xor, %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i ]
  %xor = xor i32 %i.0, 1
  %idxprom = zext nneg i32 %xor to i64
  br label %for.body.i.i.i.i.i

for.body.i.i.i.i.i:                               ; preds = %for.body.i.i.i.i.i.3, %bb
  %lsr.iv37 = phi i64 [ %lsr.iv.next38, %for.body.i.i.i.i.i.3 ], [ 0, %bb ]
  %lsr.iv = phi i64 [ %lsr.iv.next, %for.body.i.i.i.i.i.3 ], [ %idxprom, %bb ]
  %exitcond.not.i.i.i.i.i.2 = icmp eq i64 0, 1
  br i1 %exitcond.not.i.i.i.i.i.2, label %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i, label %for.body.i.i.i.i.i.3

for.body.i.i.i.i.i.3:                             ; preds = %for.body.i.i.i.i.i
  %sunkaddr55 = mul i64 %lsr.iv37, 0
  %i = xor i64 %lsr.iv, 0
  %lsr.iv.next = or i64 %lsr.iv, 1
  %lsr.iv.next38 = or i64 %lsr.iv37, 1
  br label %for.body.i.i.i.i.i

_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i:        ; preds = %for.body.i.i.i.i.i
  %idxprom12 = zext nneg i32 %i.0 to i64
  %arrayidx13 = getelementptr [2 x %"class.llvm::APInt."], ptr %r, i64 0, i64 %idxprom12
  store i32 0, ptr %arrayidx13, align 4
  br label %bb
}

; This variant hit an assert and never reached the verifier error
define void @_ZNK4llvm5APInt21multiplicativeInverseERKS0__assert(ptr %r) {
; CHECK-LABEL: _ZNK4llvm5APInt21multiplicativeInverseERKS0__assert:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    jmp .LBB1_1
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB1_4: # %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i
; CHECK-NEXT:    # in Loop: Header=BB1_1 Depth=1
; CHECK-NEXT:    movl %edx, %edx
; CHECK-NEXT:    shlq $4, %rdx
; CHECK-NEXT:    movl $0, (%rdi,%rdx)
; CHECK-NEXT:    movl %ecx, %edx
; CHECK-NEXT:  .LBB1_1: # %bb
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB1_3 Depth 2
; CHECK-NEXT:    xorl $1, %ecx
; CHECK-NEXT:    movq %rcx, %rsi
; CHECK-NEXT:    shlq $4, %rsi
; CHECK-NEXT:    movq (%rsi), %rsi
; CHECK-NEXT:    xorl %r8d, %r8d
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    jne .LBB1_4
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB1_3: # %for.body.i.i.i.i.i.3
; CHECK-NEXT:    # Parent Loop BB1_1 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    orq $1, %rsi
; CHECK-NEXT:    orq $1, %r8
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    je .LBB1_3
; CHECK-NEXT:    jmp .LBB1_4
entry:
  br label %bb

bb:                                               ; preds = %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %xor, %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i ]
  %xor = xor i32 %i.0, 1
  %idxprom = zext nneg i32 %xor to i64
  %arrayidx = getelementptr [2 x %"class.llvm::APInt."], ptr null, i64 0, i64 %idxprom
  %i.i.i.i.i.i = load ptr, ptr %arrayidx, align 16
  %i.i.i.i.i.i36 = ptrtoint ptr %i.i.i.i.i.i to i64
  br label %for.body.i.i.i.i.i

for.body.i.i.i.i.i:                               ; preds = %for.body.i.i.i.i.i.3, %bb
  %lsr.iv37 = phi i64 [ %lsr.iv.next38, %for.body.i.i.i.i.i.3 ], [ 0, %bb ]
  %lsr.iv = phi i64 [ %lsr.iv.next, %for.body.i.i.i.i.i.3 ], [ %i.i.i.i.i.i36, %bb ]
  %exitcond.not.i.i.i.i.i.2 = icmp eq i64 0, 1
  br i1 %exitcond.not.i.i.i.i.i.2, label %_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i, label %for.body.i.i.i.i.i.3

for.body.i.i.i.i.i.3:                             ; preds = %for.body.i.i.i.i.i
  %sunkaddr55 = mul i64 %lsr.iv37, 0
  %i = xor i64 %lsr.iv, 0
  %lsr.iv.next = or i64 %lsr.iv, 1
  %lsr.iv.next38 = or i64 %lsr.iv37, 1
  br label %for.body.i.i.i.i.i

_ZNK4llvm5APInt13getActiveBitsEv.exit.i.i:        ; preds = %for.body.i.i.i.i.i
  %idxprom12 = zext nneg i32 %i.0 to i64
  %arrayidx13 = getelementptr [2 x %"class.llvm::APInt."], ptr %r, i64 0, i64 %idxprom12
  store i32 0, ptr %arrayidx13, align 4
  br label %bb
}
