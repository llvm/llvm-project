; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-pc-windows-msvc | FileCheck %s -check-prefix=X64
; RUN: llc < %s -mtriple=x86_64-w64-windows-gnu | FileCheck %s -check-prefix=X64
; Control Flow Guard is currently only available on Windows


; Test that Control Flow Guard checks are correctly added for x86_64 vector calls.
define void @func_cf_vector_x64(ptr %0, ptr %1) #0 {
; X64-LABEL: func_cf_vector_x64:
; X64:       # %bb.0: # %entry
; X64-NEXT:    subq $72, %rsp
; X64-NEXT:    .seh_stackalloc 72
; X64-NEXT:    .seh_endprologue
; X64-NEXT:    movq %rcx, %rax
; X64-NEXT:    movups (%rdx), %xmm0
; X64-NEXT:    movups 16(%rdx), %xmm1
; X64-NEXT:    movaps %xmm0, {{[0-9]+}}(%rsp)
; X64-NEXT:    movaps %xmm1, {{[0-9]+}}(%rsp)
; X64-NEXT:    movsd {{.*#+}} xmm0 = mem[0],zero
; X64-NEXT:    movsd {{.*#+}} xmm1 = mem[0],zero
; X64-NEXT:    movsd {{.*#+}} xmm2 = mem[0],zero
; X64-NEXT:    movsd {{.*#+}} xmm3 = mem[0],zero
; X64-NEXT:    callq *__guard_dispatch_icall_fptr(%rip)
; X64-NEXT:    nop
; X64-NEXT:    addq $72, %rsp
; X64-NEXT:    retq
; X64-NEXT:    .seh_endproc
entry:
  %2 = alloca %struct.HVA, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %2, ptr align 8 %1, i64 32, i1 false)
  %3 = load %struct.HVA, ptr %2, align 8
  call x86_vectorcallcc void %0(%struct.HVA inreg %3)
  ret void

}
attributes #0 = { "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" }

%struct.HVA = type { double, double, double, double }

declare void @llvm.memcpy.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #1
attributes #1 = { argmemonly nounwind willreturn }


!llvm.module.flags = !{!0}
!0 = !{i32 2, !"cfguard", i32 2}
