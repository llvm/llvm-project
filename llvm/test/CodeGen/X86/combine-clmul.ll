; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-- -mattr=+sse2    | FileCheck %s --check-prefixes=CHECK,SCALAR
; RUN: llc < %s -mtriple=x86_64-- -mattr=+sse2,+pclmul | FileCheck %s --check-prefixes=CHECK,SSE-PCLMUL
; RUN: llc < %s -mtriple=x86_64-- -mattr=+sse4.2,+pclmul | FileCheck %s --check-prefixes=CHECK,SSE-PCLMUL
; RUN: llc < %s -mtriple=x86_64-- -mattr=+avx2,+pclmul | FileCheck %s --check-prefixes=CHECK,AVX
; RUN: llc < %s -mtriple=x86_64-- -mattr=+avx2,+vpclmulqdq  | FileCheck %s --check-prefixes=CHECK,AVX
; RUN: llc < %s -mtriple=x86_64-- -mattr=+avx512vl,+vpclmulqdq | FileCheck %s --check-prefixes=CHECK,AVX

; Test with constant 0 - should optimize to just returning 0
define i32 @clmul_i32_zero(i32 %a) {
; CHECK-LABEL: clmul_i32_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
  %res = call i32 @llvm.clmul.i32(i32 %a, i32 0)
  ret i32 %res
}

; Test with constant 1 - should optimize to just returning %a
define i32 @clmul_i32_one(i32 %a) {
; SCALAR-LABEL: clmul_i32_one:
; SCALAR:       # %bb.0:
; SCALAR-NEXT:    movl %edi, %eax
; SCALAR-NEXT:    retq
;
; SSE-PCLMUL-LABEL: clmul_i32_one:
; SSE-PCLMUL:       # %bb.0:
; SSE-PCLMUL-NEXT:    movl $1, %eax
; SSE-PCLMUL-NEXT:    movq %rax, %xmm0
; SSE-PCLMUL-NEXT:    movd %edi, %xmm1
; SSE-PCLMUL-NEXT:    pclmulqdq $0, %xmm0, %xmm1
; SSE-PCLMUL-NEXT:    movq %xmm1, %rax
; SSE-PCLMUL-NEXT:    # kill: def $eax killed $eax killed $rax
; SSE-PCLMUL-NEXT:    retq
;
; AVX-LABEL: clmul_i32_one:
; AVX:       # %bb.0:
; AVX-NEXT:    movl $1, %eax
; AVX-NEXT:    vmovq %rax, %xmm0
; AVX-NEXT:    vmovd %edi, %xmm1
; AVX-NEXT:    vpclmulqdq $0, %xmm0, %xmm1, %xmm0
; AVX-NEXT:    vmovq %xmm0, %rax
; AVX-NEXT:    # kill: def $eax killed $eax killed $rax
; AVX-NEXT:    retq
  %res = call i32 @llvm.clmul.i32(i32 %a, i32 1)
  ret i32 %res
}

; Test with power of 2 - should become a shift
define i32 @clmul_i32_pow2(i32 %a) {
; SCALAR-LABEL: clmul_i32_pow2:
; SCALAR:       # %bb.0:
; SCALAR-NEXT:    movl %edi, %eax
; SCALAR-NEXT:    shll $4, %eax
; SCALAR-NEXT:    retq
;
; SSE-PCLMUL-LABEL: clmul_i32_pow2:
; SSE-PCLMUL:       # %bb.0:
; SSE-PCLMUL-NEXT:    movl $16, %eax
; SSE-PCLMUL-NEXT:    movq %rax, %xmm0
; SSE-PCLMUL-NEXT:    movd %edi, %xmm1
; SSE-PCLMUL-NEXT:    pclmulqdq $0, %xmm0, %xmm1
; SSE-PCLMUL-NEXT:    movq %xmm1, %rax
; SSE-PCLMUL-NEXT:    # kill: def $eax killed $eax killed $rax
; SSE-PCLMUL-NEXT:    retq
;
; AVX-LABEL: clmul_i32_pow2:
; AVX:       # %bb.0:
; AVX-NEXT:    movl $16, %eax
; AVX-NEXT:    vmovq %rax, %xmm0
; AVX-NEXT:    vmovd %edi, %xmm1
; AVX-NEXT:    vpclmulqdq $0, %xmm0, %xmm1, %xmm0
; AVX-NEXT:    vmovq %xmm0, %rax
; AVX-NEXT:    # kill: def $eax killed $eax killed $rax
; AVX-NEXT:    retq
  %res = call i32 @llvm.clmul.i32(i32 %a, i32 16)  ; 0x10 = 1 << 4
  ret i32 %res
}
