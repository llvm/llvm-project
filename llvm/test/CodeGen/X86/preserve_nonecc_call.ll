; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=x86_64-unknown-unknown -mcpu=corei7 < %s | FileCheck %s --check-prefix=X64
; RUN: llc -mtriple=i386-unknown-unknown -mcpu=pentium4 < %s | FileCheck %s --check-prefix=X32

; This test checks various function call behaviors between preserve_none and
; normal calling conventions.

declare preserve_nonecc void @callee(ptr)

; Normal caller calls preserve_none callee. Will not generated tail call because
; of incompatible calling convention. Callee saved registers are saved/restored
; around the call.
define void @caller1(ptr %a) {
; X64-LABEL: caller1:
; X64:       # %bb.0:
; X64-NEXT:    pushq %r15
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    pushq %r14
; X64-NEXT:    .cfi_def_cfa_offset 24
; X64-NEXT:    pushq %r13
; X64-NEXT:    .cfi_def_cfa_offset 32
; X64-NEXT:    pushq %r12
; X64-NEXT:    .cfi_def_cfa_offset 40
; X64-NEXT:    pushq %rbx
; X64-NEXT:    .cfi_def_cfa_offset 48
; X64-NEXT:    .cfi_offset %rbx, -48
; X64-NEXT:    .cfi_offset %r12, -40
; X64-NEXT:    .cfi_offset %r13, -32
; X64-NEXT:    .cfi_offset %r14, -24
; X64-NEXT:    .cfi_offset %r15, -16
; X64-NEXT:    movq %rdi, %r12
; X64-NEXT:    callq callee@PLT
; X64-NEXT:    popq %rbx
; X64-NEXT:    .cfi_def_cfa_offset 40
; X64-NEXT:    popq %r12
; X64-NEXT:    .cfi_def_cfa_offset 32
; X64-NEXT:    popq %r13
; X64-NEXT:    .cfi_def_cfa_offset 24
; X64-NEXT:    popq %r14
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    popq %r15
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq
;
; X32-LABEL: caller1:
; X32:       # %bb.0:
; X32-NEXT:    pushl %ebx
; X32-NEXT:    .cfi_def_cfa_offset 8
; X32-NEXT:    pushl %edi
; X32-NEXT:    .cfi_def_cfa_offset 12
; X32-NEXT:    pushl %esi
; X32-NEXT:    .cfi_def_cfa_offset 16
; X32-NEXT:    .cfi_offset %esi, -16
; X32-NEXT:    .cfi_offset %edi, -12
; X32-NEXT:    .cfi_offset %ebx, -8
; X32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X32-NEXT:    calll callee@PLT
; X32-NEXT:    popl %esi
; X32-NEXT:    .cfi_def_cfa_offset 12
; X32-NEXT:    popl %edi
; X32-NEXT:    .cfi_def_cfa_offset 8
; X32-NEXT:    popl %ebx
; X32-NEXT:    .cfi_def_cfa_offset 4
; X32-NEXT:    retl
  tail call preserve_nonecc void @callee(ptr %a)
  ret void
}

; Preserve_none caller calls preserve_none callee. Same function body.
; The tail call is preserved. No registers are saved/restored around the call.
; Actually a simple jmp instruction is generated.
define preserve_nonecc void @caller2(ptr %a) {
; CHECK-LABEL: caller2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jmp callee@PLT # TAILCALL
; X64-LABEL: caller2:
; X64:       # %bb.0:
; X64-NEXT:    jmp callee@PLT # TAILCALL
;
; X32-LABEL: caller2:
; X32:       # %bb.0:
; X32-NEXT:    jmp callee@PLT # TAILCALL
  tail call preserve_nonecc void @callee(ptr %a)
  ret void
}

; Preserve_none function can use more registers to pass parameters.
declare preserve_nonecc i64 @callee_with_many_param2(i64 %a1, i64 %a2, i64 %a3, i64 %a4, i64 %a5, i64 %a6, i64 %a7, i64 %a8, i64 %a9, i64 %a10, i64 %a11)
define preserve_nonecc i64 @callee_with_many_param(i64 %a1, i64 %a2, i64 %a3, i64 %a4, i64 %a5, i64 %a6, i64 %a7, i64 %a8, i64 %a9, i64 %a10, i64 %a11, i64 %a12) {
; X64-LABEL: callee_with_many_param:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    movq %r13, %r12
; X64-NEXT:    movq %r14, %r13
; X64-NEXT:    movq %r15, %r14
; X64-NEXT:    movq %rdi, %r15
; X64-NEXT:    movq %rsi, %rdi
; X64-NEXT:    movq %rdx, %rsi
; X64-NEXT:    movq %rcx, %rdx
; X64-NEXT:    movq %r8, %rcx
; X64-NEXT:    movq %r9, %r8
; X64-NEXT:    movq %r11, %r9
; X64-NEXT:    movq %rax, %r11
; X64-NEXT:    callq callee_with_many_param2@PLT
; X64-NEXT:    popq %rcx
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq
;
; X32-LABEL: callee_with_many_param:
; X32:       # %bb.0:
; X32-NEXT:    pushl %ebp
; X32-NEXT:    .cfi_def_cfa_offset 8
; X32-NEXT:    .cfi_offset %ebp, -8
; X32-NEXT:    movl {{[0-9]+}}(%esp), %ebx
; X32-NEXT:    movl %esi, %ebp
; X32-NEXT:    movl {{[0-9]+}}(%esp), %esi
; X32-NEXT:    movl %ecx, %eax
; X32-NEXT:    movl %edi, %edx
; X32-NEXT:    movl %ebp, %ecx
; X32-NEXT:    movl %ebx, %edi
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl {{[0-9]+}}(%esp)
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    calll callee_with_many_param2@PLT
; X32-NEXT:    addl $68, %esp
; X32-NEXT:    .cfi_adjust_cfa_offset -68
; X32-NEXT:    popl %ebp
; X32-NEXT:    .cfi_def_cfa_offset 4
; X32-NEXT:    retl
  %ret = call preserve_nonecc i64 @callee_with_many_param2(i64 %a2, i64 %a3, i64 %a4, i64 %a5, i64 %a6, i64 %a7, i64 %a8, i64 %a9, i64 %a10, i64 %a11, i64 %a12)
  ret i64 %ret
}

define i64 @caller3() {
; X64-LABEL: caller3:
; X64:       # %bb.0:
; X64-NEXT:    pushq %r15
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    pushq %r14
; X64-NEXT:    .cfi_def_cfa_offset 24
; X64-NEXT:    pushq %r13
; X64-NEXT:    .cfi_def_cfa_offset 32
; X64-NEXT:    pushq %r12
; X64-NEXT:    .cfi_def_cfa_offset 40
; X64-NEXT:    pushq %rbx
; X64-NEXT:    .cfi_def_cfa_offset 48
; X64-NEXT:    .cfi_offset %rbx, -48
; X64-NEXT:    .cfi_offset %r12, -40
; X64-NEXT:    .cfi_offset %r13, -32
; X64-NEXT:    .cfi_offset %r14, -24
; X64-NEXT:    .cfi_offset %r15, -16
; X64-NEXT:    movl $1, %r12d
; X64-NEXT:    movl $2, %r13d
; X64-NEXT:    movl $3, %r14d
; X64-NEXT:    movl $4, %r15d
; X64-NEXT:    movl $5, %edi
; X64-NEXT:    movl $6, %esi
; X64-NEXT:    movl $7, %edx
; X64-NEXT:    movl $8, %ecx
; X64-NEXT:    movl $9, %r8d
; X64-NEXT:    movl $10, %r9d
; X64-NEXT:    movl $11, %r11d
; X64-NEXT:    movl $12, %eax
; X64-NEXT:    callq callee_with_many_param@PLT
; X64-NEXT:    popq %rbx
; X64-NEXT:    .cfi_def_cfa_offset 40
; X64-NEXT:    popq %r12
; X64-NEXT:    .cfi_def_cfa_offset 32
; X64-NEXT:    popq %r13
; X64-NEXT:    .cfi_def_cfa_offset 24
; X64-NEXT:    popq %r14
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    popq %r15
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    retq
;
; X32-LABEL: caller3:
; X32:       # %bb.0:
; X32-NEXT:    pushl %ebx
; X32-NEXT:    .cfi_def_cfa_offset 8
; X32-NEXT:    pushl %edi
; X32-NEXT:    .cfi_def_cfa_offset 12
; X32-NEXT:    pushl %esi
; X32-NEXT:    .cfi_def_cfa_offset 16
; X32-NEXT:    .cfi_offset %esi, -16
; X32-NEXT:    .cfi_offset %edi, -12
; X32-NEXT:    .cfi_offset %ebx, -8
; X32-NEXT:    movl $1, %eax
; X32-NEXT:    xorl %edx, %edx
; X32-NEXT:    movl $2, %ecx
; X32-NEXT:    xorl %edi, %edi
; X32-NEXT:    movl $3, %esi
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $12
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $11
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $10
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $9
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $8
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $7
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $6
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $5
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $4
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    pushl $0
; X32-NEXT:    .cfi_adjust_cfa_offset 4
; X32-NEXT:    calll callee_with_many_param@PLT
; X32-NEXT:    addl $76, %esp
; X32-NEXT:    .cfi_adjust_cfa_offset -76
; X32-NEXT:    popl %esi
; X32-NEXT:    .cfi_def_cfa_offset 12
; X32-NEXT:    popl %edi
; X32-NEXT:    .cfi_def_cfa_offset 8
; X32-NEXT:    popl %ebx
; X32-NEXT:    .cfi_def_cfa_offset 4
; X32-NEXT:    retl
  %ret = call preserve_nonecc i64 @callee_with_many_param(i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12)
  ret i64 %ret
}

; Non-volatile registers are used to pass the first few parameters.
declare void @boring()
declare preserve_nonecc void @continuation(ptr, ptr, ptr, ptr)
define preserve_nonecc void @entry(ptr %r12, ptr %r13, ptr %r14, ptr %r15) {
; X64-LABEL: entry:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rax
; X64-NEXT:    .cfi_def_cfa_offset 16
; X64-NEXT:    callq boring@PLT
; X64-NEXT:    popq %rax
; X64-NEXT:    .cfi_def_cfa_offset 8
; X64-NEXT:    jmp continuation@PLT # TAILCALL
;
; X32-LABEL: entry:
; X32:       # %bb.0:
; X32-NEXT:    pushl %ebp
; X32-NEXT:    .cfi_def_cfa_offset 8
; X32-NEXT:    .cfi_offset %ebp, -8
; X32-NEXT:    movl %ecx, %esi
; X32-NEXT:    movl %edx, %ebx
; X32-NEXT:    movl %eax, %ebp
; X32-NEXT:    calll boring@PLT
; X32-NEXT:    movl %ebp, %eax
; X32-NEXT:    movl %ebx, %edx
; X32-NEXT:    movl %esi, %ecx
; X32-NEXT:    popl %ebp
; X32-NEXT:    .cfi_def_cfa_offset 4
; X32-NEXT:    jmp continuation@PLT # TAILCALL
  call void @boring()
  musttail call preserve_nonecc void @continuation(ptr %r12, ptr %r13, ptr %r14, ptr %r15)
  ret void
}
