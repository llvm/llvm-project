; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=i686-linux | FileCheck %s -check-prefixes=X86
; RUN: llc < %s -mtriple=x86_64-linux | FileCheck %s -check-prefixes=X64
; RUN: llc < %s -mtriple=i686-linux -global-isel | FileCheck %s -check-prefixes=X86,X86-GISEL
; RUN: llc < %s -mtriple=x86_64-linux -global-isel | FileCheck %s -check-prefixes=X64,X64-GISEL

; FIXME: We can reuse llvm/test/CodeGen/X86/is_fpclass.ll when all patches are included.

define i1 @is_fcNone_f32(float %x) nounwind {
; X86-LABEL: is_fcNone_f32:
; X86:       # %bb.0: # %entry
; X86-NEXT:    xorl %eax, %eax
; X86-NEXT:    retl
;
; X64-LABEL: is_fcNone_f32:
; X64:       # %bb.0: # %entry
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 0)
    ret i1 %0
}

define i1 @is_fcAllFlags_f32(float %x) nounwind {
; X86-LABEL: is_fcAllFlags_f32:
; X86:       # %bb.0: # %entry
; X86-NEXT:    movb $1, %al
; X86-NEXT:    retl
;
; X64-LABEL: is_fcAllFlags_f32:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movb $1, %al
; X64-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 1023)
    ret i1 %0
}

define i1 @issignaling_f(float %x) {
; X64-LABEL: issignaling_f:
; X64:       # %bb.0:
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X64-NEXT:    cmpl $2143289344, %eax # imm = 0x7FC00000
; X64-NEXT:    setl %cl
; X64-NEXT:    cmpl $2139095041, %eax # imm = 0x7F800001
; X64-NEXT:    setge %al
; X64-NEXT:    andb %cl, %al
; X64-NEXT:    retq
;
; X86-GISEL-LABEL: issignaling_f:
; X86-GISEL:       # %bb.0:
; X86-GISEL-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-GISEL-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X86-GISEL-NEXT:    cmpl $2143289344, %eax # imm = 0x7FC00000
; X86-GISEL-NEXT:    setl %cl
; X86-GISEL-NEXT:    cmpl $2139095041, %eax # imm = 0x7F800001
; X86-GISEL-NEXT:    setge %al
; X86-GISEL-NEXT:    andb %cl, %al
; X86-GISEL-NEXT:    retl
   %a0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 1)  ; "snan"
   ret i1 %a0
}

 define i1 @isquiet_f(float %x) {
; X64-LABEL: isquiet_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X64-NEXT:    cmpl $2143289344, %eax # imm = 0x7FC00000
; X64-NEXT:    setge %al
; X64-NEXT:    retq
;
; X86-GISEL-LABEL: isquiet_f:
; X86-GISEL:       # %bb.0: # %entry
; X86-GISEL-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-GISEL-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X86-GISEL-NEXT:    cmpl $2143289344, %eax # imm = 0x7FC00000
; X86-GISEL-NEXT:    setge %al
; X86-GISEL-NEXT:    retl
 entry:
   %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 2)  ; "qnan"
   ret i1 %0
}

define i1 @not_isquiet_f(float %x) {
; X64-LABEL: not_isquiet_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X64-NEXT:    cmpl $2143289344, %eax # imm = 0x7FC00000
; X64-NEXT:    setl %al
; X64-NEXT:    retq
;
; X86-GISEL-LABEL: not_isquiet_f:
; X86-GISEL:       # %bb.0: # %entry
; X86-GISEL-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-GISEL-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X86-GISEL-NEXT:    cmpl $2143289344, %eax # imm = 0x7FC00000
; X86-GISEL-NEXT:    setl %al
; X86-GISEL-NEXT:    retl
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 1021)  ; ~"qnan"
  ret i1 %0
}

define i1 @isinf_f(float %x) {
; X64-LABEL: isinf_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X64-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X64-NEXT:    sete %al
; X64-NEXT:    retq
;
; X86-GISEL-LABEL: isinf_f:
; X86-GISEL:       # %bb.0: # %entry
; X86-GISEL-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-GISEL-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X86-GISEL-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X86-GISEL-NEXT:    sete %al
; X86-GISEL-NEXT:    retl
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 516)  ; 0x204 = "inf"
  ret i1 %0
}

define i1 @not_isinf_f(float %x) {
; X64-LABEL: not_isinf_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X64-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X64-NEXT:    setne %al
; X64-NEXT:    retq
;
; X86-GISEL-LABEL: not_isinf_f:
; X86-GISEL:       # %bb.0: # %entry
; X86-GISEL-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-GISEL-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X86-GISEL-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X86-GISEL-NEXT:    setne %al
; X86-GISEL-NEXT:    retl
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 507)  ; ~0x204 = "~inf"
  ret i1 %0
}

define i1 @is_plus_inf_f(float %x) {
; X86-LABEL: is_plus_inf_f:
; X86:       # %bb.0: # %entry
; X86-NEXT:    cmpl $2139095040, {{[0-9]+}}(%esp) # imm = 0x7F800000
; X86-NEXT:    sete %al
; X86-NEXT:    retl
;
; X64-LABEL: is_plus_inf_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X64-NEXT:    sete %al
; X64-NEXT:    retq
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 512)  ; 0x200 = "+inf"
  ret i1 %0
}

define i1 @is_minus_inf_f(float %x) {
; X86-LABEL: is_minus_inf_f:
; X86:       # %bb.0: # %entry
; X86-NEXT:    cmpl $-8388608, {{[0-9]+}}(%esp) # imm = 0xFF800000
; X86-NEXT:    sete %al
; X86-NEXT:    retl
;
; X64-LABEL: is_minus_inf_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    cmpl $-8388608, %eax # imm = 0xFF800000
; X64-NEXT:    sete %al
; X64-NEXT:    retq
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 4)  ; "-inf"
  ret i1 %0
}

define i1 @not_is_minus_inf_f(float %x) {
; X86-LABEL: not_is_minus_inf_f:
; X86:       # %bb.0: # %entry
; X86-NEXT:    cmpl $-8388608, {{[0-9]+}}(%esp) # imm = 0xFF800000
; X86-NEXT:    setne %al
; X86-NEXT:    retl
;
; X64-LABEL: not_is_minus_inf_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    cmpl $-8388608, %eax # imm = 0xFF800000
; X64-NEXT:    setne %al
; X64-NEXT:    retq
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 1019)  ; ~"-inf"
  ret i1 %0
}

define i1 @isfinite_f(float %x) {
; X64-LABEL: isfinite_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X64-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X64-NEXT:    setl %al
; X64-NEXT:    retq
;
; X86-GISEL-LABEL: isfinite_f:
; X86-GISEL:       # %bb.0: # %entry
; X86-GISEL-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-GISEL-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X86-GISEL-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X86-GISEL-NEXT:    setl %al
; X86-GISEL-NEXT:    retl
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 504)  ; 0x1f8 = "finite"
  ret i1 %0
}

define i1 @not_isfinite_f(float %x) {
; X64-LABEL: not_isfinite_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X64-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X64-NEXT:    setge %al
; X64-NEXT:    retq
;
; X86-GISEL-LABEL: not_isfinite_f:
; X86-GISEL:       # %bb.0: # %entry
; X86-GISEL-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-GISEL-NEXT:    andl $2147483647, %eax # imm = 0x7FFFFFFF
; X86-GISEL-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X86-GISEL-NEXT:    setge %al
; X86-GISEL-NEXT:    retl
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 519)  ; ~0x1f8 = "~finite"
  ret i1 %0
}

define i1 @is_plus_finite_f(float %x) {
; X86-LABEL: is_plus_finite_f:
; X86:       # %bb.0: # %entry
; X86-NEXT:    cmpl $2139095040, {{[0-9]+}}(%esp) # imm = 0x7F800000
; X86-NEXT:    setb %al
; X86-NEXT:    retl
;
; X64-LABEL: is_plus_finite_f:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movd %xmm0, %eax
; X64-NEXT:    cmpl $2139095040, %eax # imm = 0x7F800000
; X64-NEXT:    setb %al
; X64-NEXT:    retq
entry:
  %0 = tail call i1 @llvm.is.fpclass.f32(float %x, i32 448)  ; 0x1c0 = "+finite"
  ret i1 %0
}

define i1 @is_fcNone_f64(double %x) nounwind {
; X86-LABEL: is_fcNone_f64:
; X86:       # %bb.0: # %entry
; X86-NEXT:    xorl %eax, %eax
; X86-NEXT:    retl
;
; X64-LABEL: is_fcNone_f64:
; X64:       # %bb.0: # %entry
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f64(double %x, i32 0)
    ret i1 %0
}

define i1 @is_fcAllFlags_f64(double %x) nounwind {
; X86-LABEL: is_fcAllFlags_f64:
; X86:       # %bb.0: # %entry
; X86-NEXT:    movb $1, %al
; X86-NEXT:    retl
;
; X64-LABEL: is_fcAllFlags_f64:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movb $1, %al
; X64-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f64(double %x, i32 1023)
    ret i1 %0
}

define i1 @is_fcNone_f80(x86_fp80 %x) nounwind {
; X86-LABEL: is_fcNone_f80:
; X86:       # %bb.0: # %entry
; X86-NEXT:    xorl %eax, %eax
; X86-NEXT:    retl
;
; X64-LABEL: is_fcNone_f80:
; X64:       # %bb.0: # %entry
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
entry:
%0 = tail call i1 @llvm.is.fpclass.f80(x86_fp80 %x, i32 0)
ret i1 %0
}

define i1 @is_fcAllFlags_f80(x86_fp80 %x) nounwind {
; X86-LABEL: is_fcAllFlags_f80:
; X86:       # %bb.0: # %entry
; X86-NEXT:    movb $1, %al
; X86-NEXT:    retl
;
; X64-LABEL: is_fcAllFlags_f80:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movb $1, %al
; X64-NEXT:    retq
entry:
    %0 = tail call i1 @llvm.is.fpclass.f80(x86_fp80 %x, i32 1023)
    ret i1 %0
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; X64-GISEL: {{.*}}
