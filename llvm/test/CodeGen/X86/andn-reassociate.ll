; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-unknown-unknown -mattr=-bmi < %s | FileCheck %s --check-prefixes=CHECK,NOBMI
; RUN: llc -mtriple=x86_64-unknown-unknown -mattr=+bmi < %s | FileCheck %s --check-prefixes=CHECK,BMI

; Test the optimization: X & b & ~c -> X & (b & ~c)
; This reassociation allows ANDN to execute in parallel with computing X

define i64 @test_constant_xor_and_andnot(i64 %a, i64 %b, i64 %c) {
; NOBMI-LABEL: test_constant_xor_and_andnot:
; NOBMI:       # %bb.0:
; NOBMI-NEXT:    movq %rdx, %rax
; NOBMI-NEXT:    xorq $1234, %rdi # imm = 0x4D2
; NOBMI-NEXT:    andq %rsi, %rdi
; NOBMI-NEXT:    notq %rax
; NOBMI-NEXT:    andq %rdi, %rax
; NOBMI-NEXT:    retq
;
; BMI-LABEL: test_constant_xor_and_andnot:
; BMI:       # %bb.0:
; BMI-NEXT:    xorq $1234, %rdi # imm = 0x4D2
; BMI-NEXT:    andnq %rsi, %rdx, %rax
; BMI-NEXT:    andq %rdi, %rax
; BMI-NEXT:    retq
  %xor = xor i64 %a, 1234
  %and1 = and i64 %xor, %b
  %not_c = xor i64 %c, -1
  %result = and i64 %and1, %not_c
  ret i64 %result
}

define i32 @test_constant_xor_and_andnot_32(i32 %a, i32 %b, i32 %c) {
; NOBMI-LABEL: test_constant_xor_and_andnot_32:
; NOBMI:       # %bb.0:
; NOBMI-NEXT:    movl %edx, %eax
; NOBMI-NEXT:    xorl $5678, %edi # imm = 0x162E
; NOBMI-NEXT:    andl %esi, %edi
; NOBMI-NEXT:    notl %eax
; NOBMI-NEXT:    andl %edi, %eax
; NOBMI-NEXT:    retq
;
; BMI-LABEL: test_constant_xor_and_andnot_32:
; BMI:       # %bb.0:
; BMI-NEXT:    xorl $5678, %edi # imm = 0x162E
; BMI-NEXT:    andnl %esi, %edx, %eax
; BMI-NEXT:    andl %edi, %eax
; BMI-NEXT:    retq
  %xor = xor i32 %a, 5678
  %and1 = and i32 %xor, %b
  %not_c = xor i32 %c, -1
  %result = and i32 %and1, %not_c
  ret i32 %result
}

; Test with different operand order
define i64 @test_constant_xor_and_andnot_swapped(i64 %a, i64 %b, i64 %c) {
; NOBMI-LABEL: test_constant_xor_and_andnot_swapped:
; NOBMI:       # %bb.0:
; NOBMI-NEXT:    movq %rdx, %rax
; NOBMI-NEXT:    xorq $1234, %rdi # imm = 0x4D2
; NOBMI-NEXT:    andq %rsi, %rdi
; NOBMI-NEXT:    notq %rax
; NOBMI-NEXT:    andq %rdi, %rax
; NOBMI-NEXT:    retq
;
; BMI-LABEL: test_constant_xor_and_andnot_swapped:
; BMI:       # %bb.0:
; BMI-NEXT:    xorq $1234, %rdi # imm = 0x4D2
; BMI-NEXT:    andnq %rsi, %rdx, %rax
; BMI-NEXT:    andq %rdi, %rax
; BMI-NEXT:    retq
  %xor = xor i64 %a, 1234
  %and1 = and i64 %b, %xor
  %not_c = xor i64 %c, -1
  %result = and i64 %and1, %not_c
  ret i64 %result
}

; Test with different operand order for the final AND
define i64 @test_constant_xor_and_andnot_final_swapped(i64 %a, i64 %b, i64 %c) {
; NOBMI-LABEL: test_constant_xor_and_andnot_final_swapped:
; NOBMI:       # %bb.0:
; NOBMI-NEXT:    movq %rdx, %rax
; NOBMI-NEXT:    xorq $1234, %rdi # imm = 0x4D2
; NOBMI-NEXT:    andq %rsi, %rdi
; NOBMI-NEXT:    notq %rax
; NOBMI-NEXT:    andq %rdi, %rax
; NOBMI-NEXT:    retq
;
; BMI-LABEL: test_constant_xor_and_andnot_final_swapped:
; BMI:       # %bb.0:
; BMI-NEXT:    xorq $1234, %rdi # imm = 0x4D2
; BMI-NEXT:    andnq %rsi, %rdx, %rax
; BMI-NEXT:    andq %rdi, %rax
; BMI-NEXT:    retq
  %xor = xor i64 %a, 1234
  %and1 = and i64 %xor, %b
  %not_c = xor i64 %c, -1
  %result = and i64 %not_c, %and1
  ret i64 %result
}

define i64 @test_add_and_andnot(i64 %a, i64 %b, i64 %c) {
; NOBMI-LABEL: test_add_and_andnot:
; NOBMI:       # %bb.0:
; NOBMI-NEXT:    leaq 5678(%rdi), %rax
; NOBMI-NEXT:    andq %rsi, %rax
; NOBMI-NEXT:    notq %rdx
; NOBMI-NEXT:    andq %rdx, %rax
; NOBMI-NEXT:    retq
;
; BMI-LABEL: test_add_and_andnot:
; BMI:       # %bb.0:
; BMI-NEXT:    leaq 5678(%rdi), %rcx
; BMI-NEXT:    andnq %rsi, %rdx, %rax
; BMI-NEXT:    andq %rcx, %rax
; BMI-NEXT:    retq
  %add = add i64 %a, 5678
  %and1 = and i64 %add, %b
  %not_c = xor i64 %c, -1
  %result = and i64 %and1, %not_c
  ret i64 %result
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
