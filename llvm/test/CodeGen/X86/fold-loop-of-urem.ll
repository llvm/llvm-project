; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown | FileCheck %s

declare void @use.i32(i32)
declare void @use.2xi64(<2 x i64>)
declare void @do_stuff0()
declare void @do_stuff1()
declare i1 @get.i1()
declare i32 @get.i32()

define void @simple_urem_to_sel(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_to_sel:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB0_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    xorl %r15d, %r15d
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    xorl %r12d, %r12d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %ebx, %r14d
; CHECK-NEXT:    cmovel %r15d, %r14d
; CHECK-NEXT:    incl %r12d
; CHECK-NEXT:    cmpl %r12d, %ebp
; CHECK-NEXT:    jne .LBB0_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r12
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB0_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_nested2(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_to_sel_nested2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB1_8
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    xorl %r15d, %r15d
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    xorl %r12d, %r12d
; CHECK-NEXT:    jmp .LBB1_2
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB1_5: # %for.body1
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    movl %r14d, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:  .LBB1_6: # %for.body.tail
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %ebx, %r14d
; CHECK-NEXT:    cmovel %r15d, %r14d
; CHECK-NEXT:    incl %r12d
; CHECK-NEXT:    cmpl %r12d, %ebp
; CHECK-NEXT:    je .LBB1_7
; CHECK-NEXT:  .LBB1_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    je .LBB1_6
; CHECK-NEXT:  # %bb.3: # %for.body0
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    jne .LBB1_5
; CHECK-NEXT:  # %bb.4: # %for.body2
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    jne .LBB1_5
; CHECK-NEXT:    jmp .LBB1_6
; CHECK-NEXT:  .LBB1_7:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r12
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB1_8: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body.tail ], [ 0, %entry ]
  %cond0 = call i1 @get.i1()
  br i1 %cond0, label %for.body0, label %for.body.tail
for.body0:
  %cond1 = call i1 @get.i1()
  br i1 %cond1, label %for.body1, label %for.body2
for.body2:
  %cond2 = call i1 @get.i1()
  br i1 %cond2, label %for.body1, label %for.body.tail
for.body1:
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  br label %for.body.tail
for.body.tail:
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_fail_bad_incr3(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_bad_incr3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB2_9
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    jmp .LBB2_2
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB2_6: # %for.body1
; CHECK-NEXT:    # in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    movl %ebp, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:  .LBB2_7: # %for.body.tail
; CHECK-NEXT:    # in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    jne .LBB2_8
; CHECK-NEXT:  .LBB2_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    je .LBB2_5
; CHECK-NEXT:  # %bb.3: # %for.body0
; CHECK-NEXT:    # in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    movl %eax, %r14d
; CHECK-NEXT:    callq get.i32@PLT
; CHECK-NEXT:    testb $1, %r14b
; CHECK-NEXT:    je .LBB2_7
; CHECK-NEXT:  # %bb.4: # in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    movl %eax, %ebp
; CHECK-NEXT:    incl %ebp
; CHECK-NEXT:    jmp .LBB2_6
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB2_5: # %for.body2
; CHECK-NEXT:    # in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    xorl %ebp, %ebp
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    jne .LBB2_6
; CHECK-NEXT:    jmp .LBB2_7
; CHECK-NEXT:  .LBB2_8:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB2_9: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %cond0 = call i1 @get.i1()
  br i1 %cond0, label %for.body0, label %for.body2
for.body0:
  %cond1 = call i1 @get.i1()
  %val = call i32 @get.i32()
  %inc = add nuw i32 %val, 1
  br i1 %cond1, label %for.body1, label %for.body.tail
for.body2:
  %cond2 = call i1 @get.i1()
  br i1 %cond2, label %for.body1, label %for.body.tail
for.body1:
  %i.04 = phi i32 [ %inc, %for.body0], [ 0, %for.body2 ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  br label %for.body.tail
for.body.tail:
  %exitcond.not = call i1 @get.i1()
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_vec(<2 x i64> %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_to_sel_vec:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    subq $56, %rsp
; CHECK-NEXT:    movdqa %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK-NEXT:    pxor %xmm1, %xmm1
; CHECK-NEXT:    pxor %xmm0, %xmm0
; CHECK-NEXT:    movdqa %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB3_1: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movdqa %xmm1, (%rsp) # 16-byte Spill
; CHECK-NEXT:    movdqa %xmm1, %xmm0
; CHECK-NEXT:    callq use.2xi64@PLT
; CHECK-NEXT:    pcmpeqd %xmm1, %xmm1
; CHECK-NEXT:    movdqa (%rsp), %xmm2 # 16-byte Reload
; CHECK-NEXT:    psubq %xmm1, %xmm2
; CHECK-NEXT:    movdqa %xmm2, %xmm0
; CHECK-NEXT:    movdqa %xmm2, %xmm3
; CHECK-NEXT:    pcmpeqd {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Folded Reload
; CHECK-NEXT:    pshufd {{.*#+}} xmm2 = xmm0[1,0,3,2]
; CHECK-NEXT:    pand %xmm0, %xmm2
; CHECK-NEXT:    pandn %xmm3, %xmm2
; CHECK-NEXT:    movdqa %xmm2, (%rsp) # 16-byte Spill
; CHECK-NEXT:    movdqa {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK-NEXT:    psubq %xmm1, %xmm0
; CHECK-NEXT:    movdqa %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    movdqa (%rsp), %xmm1 # 16-byte Reload
; CHECK-NEXT:    je .LBB3_1
; CHECK-NEXT:  # %bb.2: # %for.cond.cleanup
; CHECK-NEXT:    addq $56, %rsp
; CHECK-NEXT:    retq
entry:
  br label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi <2 x i64> [ %inc, %for.body ], [ zeroinitializer, %entry ]
  %rem = urem <2 x i64> %i.04, %rem_amt
  tail call void @use.2xi64(<2 x i64> %rem)
  %inc = add nuw <2 x i64> %i.04, <i64 1, i64 1>
  %exitcond.not = call i1 @get.i1()
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_fail_bad_incr(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_bad_incr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB4_6
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    jmp .LBB4_2
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB4_4: # %for.body.tail
; CHECK-NEXT:    # in Loop: Header=BB4_2 Depth=1
; CHECK-NEXT:    movl %r14d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %ebp, %r14d
; CHECK-NEXT:    je .LBB4_5
; CHECK-NEXT:  .LBB4_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    je .LBB4_4
; CHECK-NEXT:  # %bb.3: # %for.body0
; CHECK-NEXT:    # in Loop: Header=BB4_2 Depth=1
; CHECK-NEXT:    callq get.i32@PLT
; CHECK-NEXT:    movl %eax, %r14d
; CHECK-NEXT:    jmp .LBB4_4
; CHECK-NEXT:  .LBB4_5:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB4_6: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.03 = phi i32 [ %inc, %for.body.tail ], [ 0, %entry ]
  %cond0 = call i1 @get.i1()
  br i1 %cond0, label %for.body0, label %for.body.tail
for.body0:
  %some_val = call i32 @get.i32()
  br label %for.body.tail

for.body.tail:
  %i.04 = phi i32 [ %i.03, %for.body ], [ %some_val, %for.body0 ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_second_acc(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_to_sel_second_acc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $2, %edi
; CHECK-NEXT:    jb .LBB5_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r13
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    movl $1, %r15d
; CHECK-NEXT:    xorl %r12d, %r12d
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    xorl %r13d, %r13d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB5_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %ebx, %r14d
; CHECK-NEXT:    cmovel %r12d, %r14d
; CHECK-NEXT:    incl %r13d
; CHECK-NEXT:    addl $2, %r15d
; CHECK-NEXT:    cmpl %ebp, %r15d
; CHECK-NEXT:    jbe .LBB5_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    addq $8, %rsp
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r12
; CHECK-NEXT:    popq %r13
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB5_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp ult i32 %N, 2
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %i.05 = phi i32 [ %inc2, %for.body ], [ 1, %entry ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %inc2 = add nuw i32 %i.05, 2
  %exitcond.not = icmp ugt i32 %inc2, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_fail_srem(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_srem:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB6_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB6_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %eax
; CHECK-NEXT:    cltd
; CHECK-NEXT:    idivl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %r14d, %ebp
; CHECK-NEXT:    jne .LBB6_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB6_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %rem = srem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_fail_missing_nuw(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_missing_nuw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB7_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB7_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %r14d, %ebp
; CHECK-NEXT:    jne .LBB7_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB7_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nsw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_fail_bad_incr2(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_bad_incr2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB8_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB8_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    addl $2, %r14d
; CHECK-NEXT:    cmpl %r14d, %ebp
; CHECK-NEXT:    jne .LBB8_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB8_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 2
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_non_zero_entry4(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_non_zero_entry4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB9_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    movl $4, %r14d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB9_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %r14d, %ebp
; CHECK-NEXT:    jne .LBB9_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB9_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 4, %entry ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_skip_const_rem_amt(i32 %N) nounwind {
; CHECK-LABEL: simple_urem_skip_const_rem_amt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB10_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %edi, %ebx
; CHECK-NEXT:    addl $-4, %ebx
; CHECK-NEXT:    movl $4, %ebp
; CHECK-NEXT:    movl $2938661835, %r14d # imm = 0xAF286BCB
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB10_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %ebp, %eax
; CHECK-NEXT:    imulq %r14, %rax
; CHECK-NEXT:    shrq $32, %rax
; CHECK-NEXT:    movl %ebp, %ecx
; CHECK-NEXT:    subl %eax, %ecx
; CHECK-NEXT:    shrl %ecx
; CHECK-NEXT:    addl %eax, %ecx
; CHECK-NEXT:    shrl $4, %ecx
; CHECK-NEXT:    leal (%rcx,%rcx,8), %eax
; CHECK-NEXT:    leal (%rcx,%rax,2), %eax
; CHECK-NEXT:    movl %ebp, %edi
; CHECK-NEXT:    subl %eax, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %ebp
; CHECK-NEXT:    decl %ebx
; CHECK-NEXT:    jne .LBB10_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB10_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 4, %entry ]
  %rem = urem i32 %i.04, 19
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_fail_no_preheader_non_canonical(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_no_preheader_non_canonical:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB11_1
; CHECK-NEXT:  # %bb.2: # %for.body1
; CHECK-NEXT:    movl $1, %r14d
; CHECK-NEXT:    jmp .LBB11_3
; CHECK-NEXT:  .LBB11_1:
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB11_3: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %r14d, %ebp
; CHECK-NEXT:    jne .LBB11_3
; CHECK-NEXT:  # %bb.4: # %for.cond.cleanup
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.body0, label %for.body1

for.cond.cleanup:
  ret void

for.body0:
  br label %for.body

for.body1:
  br label %for.body

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %for.body0 ], [ 1, %for.body1 ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_multi_latch_non_canonical(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_multi_latch_non_canonical:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB12_6
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r13
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    decl %ebp
; CHECK-NEXT:    xorl %r12d, %r12d
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    xorl %r13d, %r13d
; CHECK-NEXT:    jmp .LBB12_2
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB12_3: # %for.body.backedge
; CHECK-NEXT:    # in Loop: Header=BB12_2 Depth=1
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %ebx, %r14d
; CHECK-NEXT:    cmovel %r12d, %r14d
; CHECK-NEXT:    incl %r13d
; CHECK-NEXT:  .LBB12_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    callq get.i1@PLT
; CHECK-NEXT:    movl %eax, %r15d
; CHECK-NEXT:    callq do_stuff0@PLT
; CHECK-NEXT:    testb $1, %r15b
; CHECK-NEXT:    je .LBB12_3
; CHECK-NEXT:  # %bb.4: # %for.body0
; CHECK-NEXT:    # in Loop: Header=BB12_2 Depth=1
; CHECK-NEXT:    callq do_stuff1@PLT
; CHECK-NEXT:    cmpl %r13d, %ebp
; CHECK-NEXT:    jne .LBB12_3
; CHECK-NEXT:  # %bb.5:
; CHECK-NEXT:    addq $8, %rsp
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r12
; CHECK-NEXT:    popq %r13
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB12_6: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ %inc, %for.body0 ], [ 0, %entry ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %cond = call i1 @get.i1()
  call void @do_stuff0()
  br i1 %cond, label %for.body0, label %for.body
for.body0:
  call void @do_stuff1()
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_fail_bad_loop(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_bad_loop:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    callq get.i32@PLT
; CHECK-NEXT:    testl %eax, %eax
; CHECK-NEXT:    # implicit-def: $r14d
; CHECK-NEXT:    jne .LBB13_4
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:  .LBB13_2: # %for.cond
; CHECK-NEXT:    cmpl %ebp, %r14d
; CHECK-NEXT:    jae .LBB13_5
; CHECK-NEXT:  # %bb.3: # %for.body
; CHECK-NEXT:    movl %r14d, %edi
; CHECK-NEXT:    xorl $1, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:  .LBB13_4: # %halfway
; CHECK-NEXT:    movl %r14d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    jmp .LBB13_2
; CHECK-NEXT:  .LBB13_5: # %for.end
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:    retq
entry:
  %call = call i32 @get.i32()
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %for.cond, label %halfway

for.cond:
  %i.0 = phi i32 [ %inc, %halfway ], [ 0, %entry ]
  %cmp = icmp ult i32 %i.0, %N
  br i1 %cmp, label %for.body, label %for.end

for.body:
  %xor = xor i32 %i.0, 1
  call void @use.i32(i32 %xor)
  br label %halfway

halfway:
  %i.1 = phi i32 [ poison, %entry ], [ %i.0, %for.body ]
  %rem = urem i32 %i.1, %rem_amt
  call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.1, 1
  br label %for.cond

for.end:
  ret void
}

define void @simple_urem_fail_intermediate_inc(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_fail_intermediate_inc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    je .LBB14_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %r14d
; CHECK-NEXT:    negl %r14d
; CHECK-NEXT:    movl $1, %r15d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB14_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r15d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    leal 1(%r14,%r15), %eax
; CHECK-NEXT:    movl %r15d, %ecx
; CHECK-NEXT:    incl %ecx
; CHECK-NEXT:    cmpl $1, %eax
; CHECK-NEXT:    movl %ecx, %r15d
; CHECK-NEXT:    jne .LBB14_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:  .LBB14_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp eq i32 %N, 0
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %inc2 = add nuw i32 %i.04, 1
  %rem = urem i32 %inc2, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @weird_loop(i64 %sub.ptr.div.i56) personality ptr null {
; CHECK-LABEL: weird_loop:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB15_1: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    jmp .LBB15_1
entry:
  br label %for.preheader

for.preheader:
  %i57.0540.us = phi i64 [ 0, %entry ], [ %add74.us, %for.body ]
  %add74.us = add nuw i64 %i57.0540.us, 1
  br label %for.body

for.body:
  %rem.us = urem i64 %i57.0540.us, %sub.ptr.div.i56
  br i1 false, label %for.preheader, label %for.body
}

define void @simple_urem_to_sel_non_zero_start(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_to_sel_non_zero_start:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $3, %edi
; CHECK-NEXT:    jb .LBB16_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    movl $2, %r14d
; CHECK-NEXT:    xorl %r15d, %r15d
; CHECK-NEXT:    movl $2, %r12d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB16_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %ebx, %r14d
; CHECK-NEXT:    cmovel %r15d, %r14d
; CHECK-NEXT:    incl %r12d
; CHECK-NEXT:    cmpl %r12d, %ebp
; CHECK-NEXT:    jne .LBB16_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r12
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:  .LBB16_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp ult i32 %N, 3
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 2, %entry ]
  %rem = urem i32 %i.04, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_non_zero_start_through_add(i32 %N, i32 %rem_amt_in) nounwind {
; CHECK-LABEL: simple_urem_to_sel_non_zero_start_through_add:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $3, %edi
; CHECK-NEXT:    jb .LBB17_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %r14d
; CHECK-NEXT:    orl $16, %ebx
; CHECK-NEXT:    negl %r14d
; CHECK-NEXT:    movl $7, %r15d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB17_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r15d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    leal 1(%r14,%r15), %eax
; CHECK-NEXT:    movl %r15d, %ecx
; CHECK-NEXT:    incl %ecx
; CHECK-NEXT:    cmpl $5, %eax
; CHECK-NEXT:    movl %ecx, %r15d
; CHECK-NEXT:    jne .LBB17_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:  .LBB17_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %rem_amt = or i32 %rem_amt_in, 16
  %cmp3.not = icmp ult i32 %N, 3
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 2, %entry ]
  %i_with_off = add nuw i32 %i.04, 5
  %rem = urem i32 %i_with_off, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_non_zero_start_through_add_fail_missing_nuw(i32 %N, i32 %rem_amt_in) nounwind {
; CHECK-LABEL: simple_urem_to_sel_non_zero_start_through_add_fail_missing_nuw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $3, %edi
; CHECK-NEXT:    jb .LBB18_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %r14d
; CHECK-NEXT:    orl $16, %ebx
; CHECK-NEXT:    negl %r14d
; CHECK-NEXT:    movl $7, %r15d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB18_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r15d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    leal 1(%r14,%r15), %eax
; CHECK-NEXT:    movl %r15d, %ecx
; CHECK-NEXT:    incl %ecx
; CHECK-NEXT:    cmpl $5, %eax
; CHECK-NEXT:    movl %ecx, %r15d
; CHECK-NEXT:    jne .LBB18_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:  .LBB18_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %rem_amt = or i32 %rem_amt_in, 16
  %cmp3.not = icmp ult i32 %N, 3
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 2, %entry ]
  %i_with_off = add i32 %i.04, 5
  %rem = urem i32 %i_with_off, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_non_zero_start_through_add_fail_no_simplify_rem(i32 %N, i32 %rem_amt) nounwind {
; CHECK-LABEL: simple_urem_to_sel_non_zero_start_through_add_fail_no_simplify_rem:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $3, %edi
; CHECK-NEXT:    jb .LBB19_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %r14d
; CHECK-NEXT:    negl %r14d
; CHECK-NEXT:    movl $7, %r15d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB19_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r15d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    leal 1(%r14,%r15), %eax
; CHECK-NEXT:    movl %r15d, %ecx
; CHECK-NEXT:    incl %ecx
; CHECK-NEXT:    cmpl $5, %eax
; CHECK-NEXT:    movl %ecx, %r15d
; CHECK-NEXT:    jne .LBB19_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:  .LBB19_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp ult i32 %N, 3
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ 2, %entry ]
  %i_with_off = add nuw i32 %i.04, 5
  %rem = urem i32 %i_with_off, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_non_zero_start_through_sub(i32 %N, i32 %rem_amt, i32 %start) nounwind {
; CHECK-LABEL: simple_urem_to_sel_non_zero_start_through_sub:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    subl %edx, %ebp
; CHECK-NEXT:    jbe .LBB20_3
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    xorl %r15d, %r15d
; CHECK-NEXT:    xorl %r14d, %r14d
; CHECK-NEXT:    xorl %r12d, %r12d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB20_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r14d, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    incl %r14d
; CHECK-NEXT:    cmpl %ebx, %r14d
; CHECK-NEXT:    cmovel %r15d, %r14d
; CHECK-NEXT:    incl %r12d
; CHECK-NEXT:    cmpl %r12d, %ebp
; CHECK-NEXT:    jne .LBB20_2
; CHECK-NEXT:  .LBB20_3: # %for.cond.cleanup
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r12
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp ule i32 %N, %start
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ %start, %entry ]
  %i_with_off = sub nuw i32 %i.04, %start
  %rem = urem i32 %i_with_off, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

define void @simple_urem_to_sel_non_zero_start_through_sub_no_simplfy(i32 %N, i32 %rem_amt, i32 %start) nounwind {
; CHECK-LABEL: simple_urem_to_sel_non_zero_start_through_sub_no_simplfy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi
; CHECK-NEXT:    jbe .LBB21_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    movl %edx, %r15d
; CHECK-NEXT:    movl %esi, %ebx
; CHECK-NEXT:    movl %edi, %r14d
; CHECK-NEXT:    negl %r14d
; CHECK-NEXT:    addl $-2, %r15d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB21_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl %r15d, %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ebx
; CHECK-NEXT:    movl %edx, %edi
; CHECK-NEXT:    callq use.i32@PLT
; CHECK-NEXT:    leal 1(%r14,%r15), %eax
; CHECK-NEXT:    movl %r15d, %ecx
; CHECK-NEXT:    incl %ecx
; CHECK-NEXT:    cmpl $-2, %eax
; CHECK-NEXT:    movl %ecx, %r15d
; CHECK-NEXT:    jne .LBB21_2
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:  .LBB21_4: # %for.cond.cleanup
; CHECK-NEXT:    retq
entry:
  %cmp3.not = icmp ule i32 %N, %start
  br i1 %cmp3.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.04 = phi i32 [ %inc, %for.body ], [ %start, %entry ]
  %i_with_off = sub nuw i32 %i.04, 2
  %rem = urem i32 %i_with_off, %rem_amt
  tail call void @use.i32(i32 %rem)
  %inc = add nuw i32 %i.04, 1
  %exitcond.not = icmp eq i32 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}
