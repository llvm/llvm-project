; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -x86-asm-syntax=intel | FileCheck %s
; ; RUN: llc < %s -mtriple=i686-unknown-unknown | FileCheck %s

; Test correct handling of a musttail call with a byval struct argument.

%struct.1xi32 = type { [1 x i32] }
%struct.3xi32 = type { [3 x i32] }
%struct.5xi32 = type { [5 x i32] }

declare dso_local i32 @Func1(ptr byval(%struct.1xi32) %0)
declare dso_local i32 @Func3(ptr byval(%struct.3xi32) %0)
declare dso_local i32 @Func5(ptr byval(%struct.5xi32) %0)
declare dso_local i32 @FuncManyArgs(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i8 %6, ptr byval(%struct.5xi32) %7)

define dso_local i32 @test1(ptr byval(%struct.1xi32) %0) {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jmp Func1 # TAILCALL
  %r = musttail call i32 @Func1(ptr byval(%struct.1xi32) %0)
  ret i32 %r
}

define dso_local i32 @test3(ptr byval(%struct.3xi32) %0) {
; CHECK-LABEL: test3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jmp Func3 # TAILCALL
  %r = musttail call i32 @Func3(ptr byval(%struct.3xi32) %0)
  ret i32 %r
}

; sizeof(%struct.5xi32) > 16, in x64 this is passed on stack.
define dso_local i32 @test5(ptr byval(%struct.5xi32) %0) {
; CHECK-LABEL: test5:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jmp Func5 # TAILCALL
  %r = musttail call i32 @Func5(ptr byval(%struct.5xi32) %0)
  ret i32 %r
}

; Test passing multiple arguments with different sizes on stack. In x64 Linux
; the first 6 are passed by register.
define dso_local i32 @testManyArgs(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i8 %6, ptr byval(%struct.5xi32) %7) {
; CHECK-LABEL: testManyArgs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jmp FuncManyArgs # TAILCALL
  %r = musttail call i32 @FuncManyArgs(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i8 %6, ptr byval(%struct.5xi32) %7)
  ret i32 %r
}

define dso_local i32 @testRecursion(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i8 %6, ptr byval(%struct.5xi32) %7) {
; CHECK-LABEL: testRecursion:
; CHECK:       # %bb.0:
; CHECK-NEXT:    jmp testRecursion # TAILCALL
  %r = musttail call i32 @testRecursion(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i8 %6, ptr byval(%struct.5xi32) %7)
  ret i32 %r
}

define dso_local i32 @swap(ptr byval(%struct.1xi32) %0, ptr byval(%struct.1xi32) %1) noinline {
; CHECK-LABEL: swap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mov eax, dword ptr [rsp + 8]
; CHECK-NEXT:    add eax, dword ptr [rsp + 16]
; CHECK-NEXT:    ret
entry:
  %a.ptr = getelementptr inbounds %struct.1xi32, ptr %0, i32 0, i32 0, i32 0
  %a     = load i32, ptr %a.ptr, align 4
  %b.ptr = getelementptr inbounds %struct.1xi32, ptr %1, i32 0, i32 0, i32 0
  %b     = load i32, ptr %b.ptr, align 4
  %sum   = add i32 %a, %b
  ret i32 %sum
}

define dso_local i32 @swapByValArguments(ptr byval(%struct.1xi32) %0, ptr byval(%struct.1xi32) %1) {
; CHECK-LABEL: swapArguments:
; CHECK:       # %bb.0:

; CHECK-NEXT:    mov eax, dword ptr [rsp + 8]
; CHECK-NEXT:    mov dword ptr [rsp - 16], eax
; CHECK-NEXT:    mov ecx, dword ptr [rsp + 16]
; CHECK-NEXT:    mov dword ptr [rsp - 8], ecx

; CHECK-NEXT:    mov dword ptr [rsp + 8], ecx
; CHECK-NEXT:    mov dword ptr [rsp + 16], eax
; CHECK-NEXT:    jmp swap # TAILCALL
  %r = musttail call i32 @swap(ptr byval(%struct.1xi32) %1, ptr byval(%struct.1xi32) %0)
  ret i32 %r
}
