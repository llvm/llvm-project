; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx | FileCheck %s --check-prefixes=CHECK,VTEST,VTEST-AVX1
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx2 | FileCheck %s --check-prefixes=CHECK,VTEST,VTEST-AVX2
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx,+prefer-movmsk-over-vtest | FileCheck %s --check-prefixes=CHECK,MOVMSK,MOVMSK-AVX1
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx2,+prefer-movmsk-over-vtest | FileCheck %s --check-prefixes=CHECK,MOVMSK,MOVMSK-AVX2

declare i32 @llvm.x86.avx.movmsk.pd.256(<4 x double>)
declare i32 @llvm.x86.avx.movmsk.ps.256(<8 x float>)

; Use widest possible vector for movmsk comparisons (PR37087)

define i1 @movmskps_noneof_bitcast_v4f64(<4 x double> %a0) {
; VTEST-LABEL: movmskps_noneof_bitcast_v4f64:
; VTEST:       # %bb.0:
; VTEST-NEXT:    vxorpd %xmm1, %xmm1, %xmm1
; VTEST-NEXT:    vcmpeqpd %ymm1, %ymm0, %ymm0
; VTEST-NEXT:    vtestpd %ymm0, %ymm0
; VTEST-NEXT:    sete %al
; VTEST-NEXT:    vzeroupper
; VTEST-NEXT:    retq
;
; MOVMSK-LABEL: movmskps_noneof_bitcast_v4f64:
; MOVMSK:       # %bb.0:
; MOVMSK-NEXT:    vxorpd %xmm1, %xmm1, %xmm1
; MOVMSK-NEXT:    vcmpeqpd %ymm1, %ymm0, %ymm0
; MOVMSK-NEXT:    vmovmskpd %ymm0, %eax
; MOVMSK-NEXT:    testl %eax, %eax
; MOVMSK-NEXT:    sete %al
; MOVMSK-NEXT:    vzeroupper
; MOVMSK-NEXT:    retq
  %1 = fcmp oeq <4 x double> %a0, zeroinitializer
  %2 = sext <4 x i1> %1 to <4 x i64>
  %3 = bitcast <4 x i64> %2 to <8 x float>
  %4 = tail call i32 @llvm.x86.avx.movmsk.ps.256(<8 x float> %3)
  %5 = icmp eq i32 %4, 0
  ret i1 %5
}

define i1 @movmskps_allof_bitcast_v4f64(<4 x double> %a0) {
; VTEST-AVX1-LABEL: movmskps_allof_bitcast_v4f64:
; VTEST-AVX1:       # %bb.0:
; VTEST-AVX1-NEXT:    vxorpd %xmm1, %xmm1, %xmm1
; VTEST-AVX1-NEXT:    vcmpeqpd %ymm1, %ymm0, %ymm0
; VTEST-AVX1-NEXT:    vcmptrueps %ymm1, %ymm1, %ymm1
; VTEST-AVX1-NEXT:    vtestpd %ymm1, %ymm0
; VTEST-AVX1-NEXT:    setb %al
; VTEST-AVX1-NEXT:    vzeroupper
; VTEST-AVX1-NEXT:    retq
;
; VTEST-AVX2-LABEL: movmskps_allof_bitcast_v4f64:
; VTEST-AVX2:       # %bb.0:
; VTEST-AVX2-NEXT:    vxorpd %xmm1, %xmm1, %xmm1
; VTEST-AVX2-NEXT:    vcmpeqpd %ymm1, %ymm0, %ymm0
; VTEST-AVX2-NEXT:    vpcmpeqd %ymm1, %ymm1, %ymm1
; VTEST-AVX2-NEXT:    vtestpd %ymm1, %ymm0
; VTEST-AVX2-NEXT:    setb %al
; VTEST-AVX2-NEXT:    vzeroupper
; VTEST-AVX2-NEXT:    retq
;
; MOVMSK-LABEL: movmskps_allof_bitcast_v4f64:
; MOVMSK:       # %bb.0:
; MOVMSK-NEXT:    vxorpd %xmm1, %xmm1, %xmm1
; MOVMSK-NEXT:    vcmpeqpd %ymm1, %ymm0, %ymm0
; MOVMSK-NEXT:    vmovmskpd %ymm0, %eax
; MOVMSK-NEXT:    cmpl $15, %eax
; MOVMSK-NEXT:    sete %al
; MOVMSK-NEXT:    vzeroupper
; MOVMSK-NEXT:    retq
  %1 = fcmp oeq <4 x double> %a0, zeroinitializer
  %2 = sext <4 x i1> %1 to <4 x i64>
  %3 = bitcast <4 x i64> %2 to <8 x float>
  %4 = tail call i32 @llvm.x86.avx.movmsk.ps.256(<8 x float> %3)
  %5 = icmp eq i32 %4, 255
  ret i1 %5
}

;
; TODO - Avoid sign extension ops when just extracting the sign bits.
;

define i32 @movmskpd_cmpgt_v4i64(<4 x i64> %a0) {
; VTEST-AVX1-LABEL: movmskpd_cmpgt_v4i64:
; VTEST-AVX1:       # %bb.0:
; VTEST-AVX1-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; VTEST-AVX1-NEXT:    vpcmpgtq %xmm0, %xmm1, %xmm1
; VTEST-AVX1-NEXT:    vblendpd {{.*#+}} ymm0 = ymm1[0,1],ymm0[2,3]
; VTEST-AVX1-NEXT:    vmovmskpd %ymm0, %eax
; VTEST-AVX1-NEXT:    vzeroupper
; VTEST-AVX1-NEXT:    retq
;
; VTEST-AVX2-LABEL: movmskpd_cmpgt_v4i64:
; VTEST-AVX2:       # %bb.0:
; VTEST-AVX2-NEXT:    vmovmskpd %ymm0, %eax
; VTEST-AVX2-NEXT:    vzeroupper
; VTEST-AVX2-NEXT:    retq
;
; MOVMSK-AVX1-LABEL: movmskpd_cmpgt_v4i64:
; MOVMSK-AVX1:       # %bb.0:
; MOVMSK-AVX1-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; MOVMSK-AVX1-NEXT:    vpcmpgtq %xmm0, %xmm1, %xmm1
; MOVMSK-AVX1-NEXT:    vblendpd {{.*#+}} ymm0 = ymm1[0,1],ymm0[2,3]
; MOVMSK-AVX1-NEXT:    vmovmskpd %ymm0, %eax
; MOVMSK-AVX1-NEXT:    vzeroupper
; MOVMSK-AVX1-NEXT:    retq
;
; MOVMSK-AVX2-LABEL: movmskpd_cmpgt_v4i64:
; MOVMSK-AVX2:       # %bb.0:
; MOVMSK-AVX2-NEXT:    vmovmskpd %ymm0, %eax
; MOVMSK-AVX2-NEXT:    vzeroupper
; MOVMSK-AVX2-NEXT:    retq
  %1 = icmp sgt <4 x i64> zeroinitializer, %a0
  %2 = sext <4 x i1> %1 to <4 x i64>
  %3 = bitcast <4 x i64> %2 to <4 x double>
  %4 = tail call i32 @llvm.x86.avx.movmsk.pd.256(<4 x double> %3)
  ret i32 %4
}

define i32 @movmskps_ashr_v8i32(<8 x i32> %a0)  {
; VTEST-AVX1-LABEL: movmskps_ashr_v8i32:
; VTEST-AVX1:       # %bb.0:
; VTEST-AVX1-NEXT:    vpsrad $31, %xmm0, %xmm1
; VTEST-AVX1-NEXT:    vblendps {{.*#+}} ymm0 = ymm1[0,1,2,3],ymm0[4,5,6,7]
; VTEST-AVX1-NEXT:    vmovmskps %ymm0, %eax
; VTEST-AVX1-NEXT:    vzeroupper
; VTEST-AVX1-NEXT:    retq
;
; VTEST-AVX2-LABEL: movmskps_ashr_v8i32:
; VTEST-AVX2:       # %bb.0:
; VTEST-AVX2-NEXT:    vmovmskps %ymm0, %eax
; VTEST-AVX2-NEXT:    vzeroupper
; VTEST-AVX2-NEXT:    retq
;
; MOVMSK-AVX1-LABEL: movmskps_ashr_v8i32:
; MOVMSK-AVX1:       # %bb.0:
; MOVMSK-AVX1-NEXT:    vpsrad $31, %xmm0, %xmm1
; MOVMSK-AVX1-NEXT:    vblendps {{.*#+}} ymm0 = ymm1[0,1,2,3],ymm0[4,5,6,7]
; MOVMSK-AVX1-NEXT:    vmovmskps %ymm0, %eax
; MOVMSK-AVX1-NEXT:    vzeroupper
; MOVMSK-AVX1-NEXT:    retq
;
; MOVMSK-AVX2-LABEL: movmskps_ashr_v8i32:
; MOVMSK-AVX2:       # %bb.0:
; MOVMSK-AVX2-NEXT:    vmovmskps %ymm0, %eax
; MOVMSK-AVX2-NEXT:    vzeroupper
; MOVMSK-AVX2-NEXT:    retq
  %1 = ashr <8 x i32> %a0, <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
  %2 = bitcast <8 x i32> %1 to <8 x float>
  %3 = tail call i32 @llvm.x86.avx.movmsk.ps.256(<8 x float> %2)
  ret i32 %3
}

define i32 @movmskps_sext_v4i64(<4 x i32> %a0)  {
; VTEST-AVX1-LABEL: movmskps_sext_v4i64:
; VTEST-AVX1:       # %bb.0:
; VTEST-AVX1-NEXT:    vpmovsxdq %xmm0, %xmm1
; VTEST-AVX1-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[2,3,2,3]
; VTEST-AVX1-NEXT:    vpmovsxdq %xmm0, %xmm0
; VTEST-AVX1-NEXT:    vinsertf128 $1, %xmm0, %ymm1, %ymm0
; VTEST-AVX1-NEXT:    vmovmskpd %ymm0, %eax
; VTEST-AVX1-NEXT:    vzeroupper
; VTEST-AVX1-NEXT:    retq
;
; VTEST-AVX2-LABEL: movmskps_sext_v4i64:
; VTEST-AVX2:       # %bb.0:
; VTEST-AVX2-NEXT:    vpmovsxdq %xmm0, %ymm0
; VTEST-AVX2-NEXT:    vmovmskpd %ymm0, %eax
; VTEST-AVX2-NEXT:    vzeroupper
; VTEST-AVX2-NEXT:    retq
;
; MOVMSK-AVX1-LABEL: movmskps_sext_v4i64:
; MOVMSK-AVX1:       # %bb.0:
; MOVMSK-AVX1-NEXT:    vpmovsxdq %xmm0, %xmm1
; MOVMSK-AVX1-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[2,3,2,3]
; MOVMSK-AVX1-NEXT:    vpmovsxdq %xmm0, %xmm0
; MOVMSK-AVX1-NEXT:    vinsertf128 $1, %xmm0, %ymm1, %ymm0
; MOVMSK-AVX1-NEXT:    vmovmskpd %ymm0, %eax
; MOVMSK-AVX1-NEXT:    vzeroupper
; MOVMSK-AVX1-NEXT:    retq
;
; MOVMSK-AVX2-LABEL: movmskps_sext_v4i64:
; MOVMSK-AVX2:       # %bb.0:
; MOVMSK-AVX2-NEXT:    vpmovsxdq %xmm0, %ymm0
; MOVMSK-AVX2-NEXT:    vmovmskpd %ymm0, %eax
; MOVMSK-AVX2-NEXT:    vzeroupper
; MOVMSK-AVX2-NEXT:    retq
  %1 = sext <4 x i32> %a0 to <4 x i64>
  %2 = bitcast <4 x i64> %1 to <4 x double>
  %3 = tail call i32 @llvm.x86.avx.movmsk.pd.256(<4 x double> %2)
  ret i32 %3
}

define i32 @movmskps_sext_v8i32(<8 x i16> %a0)  {
; VTEST-AVX1-LABEL: movmskps_sext_v8i32:
; VTEST-AVX1:       # %bb.0:
; VTEST-AVX1-NEXT:    vpmovsxwd %xmm0, %xmm1
; VTEST-AVX1-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[2,3,2,3]
; VTEST-AVX1-NEXT:    vpmovsxwd %xmm0, %xmm0
; VTEST-AVX1-NEXT:    vinsertf128 $1, %xmm0, %ymm1, %ymm0
; VTEST-AVX1-NEXT:    vmovmskps %ymm0, %eax
; VTEST-AVX1-NEXT:    vzeroupper
; VTEST-AVX1-NEXT:    retq
;
; VTEST-AVX2-LABEL: movmskps_sext_v8i32:
; VTEST-AVX2:       # %bb.0:
; VTEST-AVX2-NEXT:    vpmovsxwd %xmm0, %ymm0
; VTEST-AVX2-NEXT:    vmovmskps %ymm0, %eax
; VTEST-AVX2-NEXT:    vzeroupper
; VTEST-AVX2-NEXT:    retq
;
; MOVMSK-AVX1-LABEL: movmskps_sext_v8i32:
; MOVMSK-AVX1:       # %bb.0:
; MOVMSK-AVX1-NEXT:    vpmovsxwd %xmm0, %xmm1
; MOVMSK-AVX1-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[2,3,2,3]
; MOVMSK-AVX1-NEXT:    vpmovsxwd %xmm0, %xmm0
; MOVMSK-AVX1-NEXT:    vinsertf128 $1, %xmm0, %ymm1, %ymm0
; MOVMSK-AVX1-NEXT:    vmovmskps %ymm0, %eax
; MOVMSK-AVX1-NEXT:    vzeroupper
; MOVMSK-AVX1-NEXT:    retq
;
; MOVMSK-AVX2-LABEL: movmskps_sext_v8i32:
; MOVMSK-AVX2:       # %bb.0:
; MOVMSK-AVX2-NEXT:    vpmovsxwd %xmm0, %ymm0
; MOVMSK-AVX2-NEXT:    vmovmskps %ymm0, %eax
; MOVMSK-AVX2-NEXT:    vzeroupper
; MOVMSK-AVX2-NEXT:    retq
  %1 = sext <8 x i16> %a0 to <8 x i32>
  %2 = bitcast <8 x i32> %1 to <8 x float>
  %3 = tail call i32 @llvm.x86.avx.movmsk.ps.256(<8 x float> %2)
  ret i32 %3
}

define i32 @movmskps_concat_v4f32(<4 x float> %a0, <4 x float> %a1)  {
; VTEST-LABEL: movmskps_concat_v4f32:
; VTEST:       # %bb.0:
; VTEST-NEXT:    vorps %xmm1, %xmm0, %xmm0
; VTEST-NEXT:    xorl %eax, %eax
; VTEST-NEXT:    vtestps %xmm0, %xmm0
; VTEST-NEXT:    setne %al
; VTEST-NEXT:    negl %eax
; VTEST-NEXT:    retq
;
; MOVMSK-LABEL: movmskps_concat_v4f32:
; MOVMSK:       # %bb.0:
; MOVMSK-NEXT:    vorps %xmm1, %xmm0, %xmm0
; MOVMSK-NEXT:    vmovmskps %xmm0, %ecx
; MOVMSK-NEXT:    xorl %eax, %eax
; MOVMSK-NEXT:    negl %ecx
; MOVMSK-NEXT:    sbbl %eax, %eax
; MOVMSK-NEXT:    retq
  %1 = shufflevector <4 x float> %a0, <4 x float> %a1, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  %2 = tail call i32 @llvm.x86.avx.movmsk.ps.256(<8 x float> %1)
  %3 = icmp ne i32 %2, 0
  %4 = sext i1 %3 to i32
  ret i32 %4
}

define i32 @movmskps_demanded_concat_v4f32(<4 x float> %a0, <4 x float> %a1)  {
; CHECK-LABEL: movmskps_demanded_concat_v4f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmovmskps %xmm0, %ecx
; CHECK-NEXT:    andl $3, %ecx
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    negl %ecx
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    retq
  %1 = shufflevector <4 x float> %a0, <4 x float> %a1, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  %2 = tail call i32 @llvm.x86.avx.movmsk.ps.256(<8 x float> %1)
  %3 = and i32 %2, 3
  %4 = icmp ne i32 %3, 0
  %5 = sext i1 %4 to i32
  ret i32 %5
}
