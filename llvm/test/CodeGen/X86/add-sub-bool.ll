; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i686-unknown | FileCheck %s --check-prefixes=X86
; RUN: llc < %s -mtriple=x86_64-unknown | FileCheck %s --check-prefixes=X64,NOTBM
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+tbm | FileCheck %s --check-prefixes=X64,TBM

; PR35908 - Fold ADD/SUB and bit tests into ADC/SBB+BT
;
; int test_add(int x, int y, int z) { return (bool(z & (1 << 30)) + x + y); }
; int test_sub(int x, int y, int z) { return (bool(z & (1 << 30)) - x - y); }

;
; Constant Bit Indices
;

define i32 @test_i32_add_add_idx(i32 %x, i32 %y, i32 %z) {
; X86-LABEL: test_i32_add_add_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    addl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    shrl $30, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %ecx, %eax
; X86-NEXT:    retl
;
; NOTBM-LABEL: test_i32_add_add_idx:
; NOTBM:       # %bb.0:
; NOTBM-NEXT:    # kill: def $esi killed $esi def $rsi
; NOTBM-NEXT:    # kill: def $edi killed $edi def $rdi
; NOTBM-NEXT:    leal (%rdi,%rsi), %eax
; NOTBM-NEXT:    shrl $30, %edx
; NOTBM-NEXT:    andl $1, %edx
; NOTBM-NEXT:    addl %edx, %eax
; NOTBM-NEXT:    retq
;
; TBM-LABEL: test_i32_add_add_idx:
; TBM:       # %bb.0:
; TBM-NEXT:    # kill: def $esi killed $esi def $rsi
; TBM-NEXT:    # kill: def $edi killed $edi def $rdi
; TBM-NEXT:    bextrl $286, %edx, %eax # imm = 0x11E
; TBM-NEXT:    addl %edi, %eax
; TBM-NEXT:    addl %esi, %eax
; TBM-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, 30
  %mask = and i32 %shift, 1
  %add1 = add i32 %add, %mask
  ret i32 %add1
}

define i32 @test_i32_add_add_commute_idx(i32 %x, i32 %y, i32 %z) {
; X86-LABEL: test_i32_add_add_commute_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    addl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    shrl $2, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %ecx, %eax
; X86-NEXT:    retl
;
; NOTBM-LABEL: test_i32_add_add_commute_idx:
; NOTBM:       # %bb.0:
; NOTBM-NEXT:    # kill: def $esi killed $esi def $rsi
; NOTBM-NEXT:    # kill: def $edi killed $edi def $rdi
; NOTBM-NEXT:    leal (%rdi,%rsi), %eax
; NOTBM-NEXT:    shrl $2, %edx
; NOTBM-NEXT:    andl $1, %edx
; NOTBM-NEXT:    addl %edx, %eax
; NOTBM-NEXT:    retq
;
; TBM-LABEL: test_i32_add_add_commute_idx:
; TBM:       # %bb.0:
; TBM-NEXT:    # kill: def $esi killed $esi def $rsi
; TBM-NEXT:    # kill: def $edi killed $edi def $rdi
; TBM-NEXT:    bextrl $258, %edx, %eax # imm = 0x102
; TBM-NEXT:    addl %edi, %eax
; TBM-NEXT:    addl %esi, %eax
; TBM-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, 2
  %mask = and i32 %shift, 1
  %add1 = add i32 %mask, %add
  ret i32 %add1
}

define i32 @test_i32_add_sub_idx(i32 %x, i32 %y, i32 %z) {
; X86-LABEL: test_i32_add_sub_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    subl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    shrl $31, %eax
; X86-NEXT:    addl %ecx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_sub_idx:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $edx killed $edx def $rdx
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    subl %esi, %edi
; X64-NEXT:    shrl $31, %edx
; X64-NEXT:    leal (%rdx,%rdi), %eax
; X64-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, 31
  %mask = and i32 %shift, 1
  %add = add i32 %sub, %mask
  ret i32 %add
}

define i32 @test_i32_add_sub_commute_idx(i32 %x, i32 %y, i32 %z) {
; X86-LABEL: test_i32_add_sub_commute_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    subl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    shrl $8, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %ecx, %eax
; X86-NEXT:    retl
;
; NOTBM-LABEL: test_i32_add_sub_commute_idx:
; NOTBM:       # %bb.0:
; NOTBM-NEXT:    # kill: def $edx killed $edx def $rdx
; NOTBM-NEXT:    # kill: def $edi killed $edi def $rdi
; NOTBM-NEXT:    subl %esi, %edi
; NOTBM-NEXT:    shrl $8, %edx
; NOTBM-NEXT:    andl $1, %edx
; NOTBM-NEXT:    leal (%rdx,%rdi), %eax
; NOTBM-NEXT:    retq
;
; TBM-LABEL: test_i32_add_sub_commute_idx:
; TBM:       # %bb.0:
; TBM-NEXT:    subl %esi, %edi
; TBM-NEXT:    bextrl $264, %edx, %eax # imm = 0x108
; TBM-NEXT:    addl %edi, %eax
; TBM-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, 8
  %mask = and i32 %shift, 1
  %add = add i32 %mask, %sub
  ret i32 %add
}

define i32 @test_i32_sub_add_idx(i32 %x, i32 %y, i32 %z) {
; X86-LABEL: test_i32_sub_add_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    shrl %ecx
; X86-NEXT:    andl $1, %ecx
; X86-NEXT:    subl %ecx, %eax
; X86-NEXT:    retl
;
; NOTBM-LABEL: test_i32_sub_add_idx:
; NOTBM:       # %bb.0:
; NOTBM-NEXT:    # kill: def $esi killed $esi def $rsi
; NOTBM-NEXT:    # kill: def $edi killed $edi def $rdi
; NOTBM-NEXT:    leal (%rdi,%rsi), %eax
; NOTBM-NEXT:    shrl %edx
; NOTBM-NEXT:    andl $1, %edx
; NOTBM-NEXT:    subl %edx, %eax
; NOTBM-NEXT:    retq
;
; TBM-LABEL: test_i32_sub_add_idx:
; TBM:       # %bb.0:
; TBM-NEXT:    # kill: def $esi killed $esi def $rsi
; TBM-NEXT:    # kill: def $edi killed $edi def $rdi
; TBM-NEXT:    leal (%rdi,%rsi), %eax
; TBM-NEXT:    bextrl $257, %edx, %ecx # imm = 0x101
; TBM-NEXT:    subl %ecx, %eax
; TBM-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, 1
  %mask = and i32 %shift, 1
  %sub = sub i32 %add, %mask
  ret i32 %sub
}

define i32 @test_i32_sub_sub_idx(i32 %x, i32 %y, i32 %z) {
; X86-LABEL: test_i32_sub_sub_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    shrl $16, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    subl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; NOTBM-LABEL: test_i32_sub_sub_idx:
; NOTBM:       # %bb.0:
; NOTBM-NEXT:    # kill: def $edx killed $edx def $rdx
; NOTBM-NEXT:    # kill: def $edi killed $edi def $rdi
; NOTBM-NEXT:    shrl $16, %edx
; NOTBM-NEXT:    andl $1, %edx
; NOTBM-NEXT:    subl %esi, %edx
; NOTBM-NEXT:    leal (%rdx,%rdi), %eax
; NOTBM-NEXT:    retq
;
; TBM-LABEL: test_i32_sub_sub_idx:
; TBM:       # %bb.0:
; TBM-NEXT:    bextrl $272, %edx, %eax # imm = 0x110
; TBM-NEXT:    subl %esi, %eax
; TBM-NEXT:    addl %edi, %eax
; TBM-NEXT:    retq
  %shift = lshr i32 %z, 16
  %mask = and i32 %shift, 1
  %sub0 = sub i32 %y, %mask
  %sub1 = sub i32 %x, %sub0
  ret i32 %sub1
}

;
; Variable Bit Indices
;

define i32 @test_i32_add_add_var(i32 %x, i32 %y, i32 %z, i32 %w) {
; X86-LABEL: test_i32_add_add_var:
; X86:       # %bb.0:
; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    addl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    shrl %cl, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %edx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_add_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    # kill: def $cl killed $cl killed $ecx
; X64-NEXT:    shrl %cl, %edx
; X64-NEXT:    andl $1, %edx
; X64-NEXT:    addl %edx, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add1 = add i32 %add, %mask
  ret i32 %add1
}

define i32 @test_i32_add_add_commute_var(i32 %x, i32 %y, i32 %z, i32 %w) {
; X86-LABEL: test_i32_add_add_commute_var:
; X86:       # %bb.0:
; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    addl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    shrl %cl, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %edx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_add_commute_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    # kill: def $cl killed $cl killed $ecx
; X64-NEXT:    shrl %cl, %edx
; X64-NEXT:    andl $1, %edx
; X64-NEXT:    addl %edx, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add1 = add i32 %mask, %add
  ret i32 %add1
}

define i32 @test_i32_add_sub_var(i32 %x, i32 %y, i32 %z, i32 %w) {
; X86-LABEL: test_i32_add_sub_var:
; X86:       # %bb.0:
; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    subl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    shrl %cl, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %edx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_sub_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $edx killed $edx def $rdx
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    subl %esi, %edi
; X64-NEXT:    # kill: def $cl killed $cl killed $ecx
; X64-NEXT:    shrl %cl, %edx
; X64-NEXT:    andl $1, %edx
; X64-NEXT:    leal (%rdx,%rdi), %eax
; X64-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add = add i32 %sub, %mask
  ret i32 %add
}

define i32 @test_i32_add_sub_commute_var(i32 %x, i32 %y, i32 %z, i32 %w) {
; X86-LABEL: test_i32_add_sub_commute_var:
; X86:       # %bb.0:
; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    subl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    shrl %cl, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %edx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_sub_commute_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $edx killed $edx def $rdx
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    subl %esi, %edi
; X64-NEXT:    # kill: def $cl killed $cl killed $ecx
; X64-NEXT:    shrl %cl, %edx
; X64-NEXT:    andl $1, %edx
; X64-NEXT:    leal (%rdx,%rdi), %eax
; X64-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add = add i32 %mask, %sub
  ret i32 %add
}

define i32 @test_i32_sub_add_var(i32 %x, i32 %y, i32 %z, i32 %w) {
; X86-LABEL: test_i32_sub_add_var:
; X86:       # %bb.0:
; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    shrl %cl, %edx
; X86-NEXT:    andl $1, %edx
; X86-NEXT:    subl %edx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_add_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    # kill: def $cl killed $cl killed $ecx
; X64-NEXT:    shrl %cl, %edx
; X64-NEXT:    andl $1, %edx
; X64-NEXT:    subl %edx, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %sub = sub i32 %add, %mask
  ret i32 %sub
}

define i32 @test_i32_sub_sub_var(i32 %x, i32 %y, i32 %z, i32 %w) {
; X86-LABEL: test_i32_sub_sub_var:
; X86:       # %bb.0:
; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    shrl %cl, %eax
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    subl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_sub_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $edx killed $edx def $rdx
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    # kill: def $cl killed $cl killed $ecx
; X64-NEXT:    shrl %cl, %edx
; X64-NEXT:    andl $1, %edx
; X64-NEXT:    subl %esi, %edx
; X64-NEXT:    leal (%rdx,%rdi), %eax
; X64-NEXT:    retq
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %sub0 = sub i32 %y, %mask
  %sub1 = sub i32 %x, %sub0
  ret i32 %sub1
}
