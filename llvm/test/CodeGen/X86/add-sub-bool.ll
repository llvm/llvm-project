; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i686-unknown | FileCheck %s --check-prefixes=X86
; RUN: llc < %s -mtriple=x86_64-unknown | FileCheck %s --check-prefixes=X64,NOTBM
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+tbm | FileCheck %s --check-prefixes=X64,TBM

; PR35908 - Fold ADD/SUB and bit extracts into ADC/SBB+BT
;
; int test_add_add(int x, int y, int z) { return ((x + y) + bool(z & (1 << 30))); }
; int test_add_sub(int x, int y, int z) { return ((x - y) + bool(z & (1 << 30))); }
; int test_sub_add(int x, int y, int z) { return ((x + y) - bool(z & (1 << 30))); }
; int test_sub_sub(int x, int y, int z) { return (x - (y - bool(z & (1 << 30)))); }

;
; Constant Bit Indices
;

define i32 @test_i32_add_add_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_add_add_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $30, {{[0-9]+}}(%esp)
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_add_idx:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl $30, %edx
; X64-NEXT:    adcl %esi, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, 30
  %mask = and i32 %shift, 1
  %add1 = add i32 %add, %mask
  ret i32 %add1
}

define i32 @test_i32_add_add_commute_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_add_add_commute_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $2, {{[0-9]+}}(%esp)
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_add_commute_idx:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl $2, %edx
; X64-NEXT:    adcl %esi, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, 2
  %mask = and i32 %shift, 1
  %add1 = add i32 %mask, %add
  ret i32 %add1
}

define i32 @test_i32_add_add_idx0(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_add_add_idx0:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    addl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    andl $1, %eax
; X86-NEXT:    addl %ecx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_add_idx0:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    andl $1, %edx
; X64-NEXT:    addl %edx, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %mask = and i32 %z, 1
  %add1 = add i32 %mask, %add
  ret i32 %add1
}

define i24 @test_i24_add_add_idx(i24 %x, i24 %y, i24 %z) nounwind {
; X86-LABEL: test_i24_add_add_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $15, {{[0-9]+}}(%esp)
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i24_add_add_idx:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl $15, %edx
; X64-NEXT:    adcl %esi, %eax
; X64-NEXT:    retq
  %add = add i24 %y, %x
  %shift = lshr i24 %z, 15
  %mask = and i24 %shift, 1
  %add1 = add i24 %add, %mask
  ret i24 %add1
}

define i128 @test_i128_add_add_idx(i128 %x, i128 %y, i128 %z) nounwind {
; X86-LABEL: test_i128_add_add_idx:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ebx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edi
; X86-NEXT:    addl {{[0-9]+}}(%esp), %ebx
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %edi
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %esi
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    shrl $5, %edx
; X86-NEXT:    andl $1, %edx
; X86-NEXT:    addl %ebx, %edx
; X86-NEXT:    adcl $0, %edi
; X86-NEXT:    adcl $0, %esi
; X86-NEXT:    adcl $0, %ecx
; X86-NEXT:    movl %edx, (%eax)
; X86-NEXT:    movl %edi, 4(%eax)
; X86-NEXT:    movl %esi, 8(%eax)
; X86-NEXT:    movl %ecx, 12(%eax)
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    retl $4
;
; NOTBM-LABEL: test_i128_add_add_idx:
; NOTBM:       # %bb.0:
; NOTBM-NEXT:    movq %r9, %rax
; NOTBM-NEXT:    addq %rdx, %rdi
; NOTBM-NEXT:    adcq %rcx, %rsi
; NOTBM-NEXT:    shrl $5, %eax
; NOTBM-NEXT:    andl $1, %eax
; NOTBM-NEXT:    addq %rdi, %rax
; NOTBM-NEXT:    adcq $0, %rsi
; NOTBM-NEXT:    movq %rsi, %rdx
; NOTBM-NEXT:    retq
;
; TBM-LABEL: test_i128_add_add_idx:
; TBM:       # %bb.0:
; TBM-NEXT:    addq %rdx, %rdi
; TBM-NEXT:    adcq %rcx, %rsi
; TBM-NEXT:    bextrl $261, %r9d, %eax # imm = 0x105
; TBM-NEXT:    addq %rdi, %rax
; TBM-NEXT:    adcq $0, %rsi
; TBM-NEXT:    movq %rsi, %rdx
; TBM-NEXT:    retq
  %add = add i128 %y, %x
  %shift = lshr i128 %z, 69
  %mask = and i128 %shift, 1
  %add1 = add i128 %add, %mask
  ret i128 %add1
}

define i32 @test_i32_add_sub_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_add_sub_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    subl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    shrl $31, %eax
; X86-NEXT:    addl %ecx, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_sub_idx:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $edx killed $edx def $rdx
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    subl %esi, %edi
; X64-NEXT:    shrl $31, %edx
; X64-NEXT:    leal (%rdx,%rdi), %eax
; X64-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, 31
  %mask = and i32 %shift, 1
  %add = add i32 %sub, %mask
  ret i32 %add
}

define i32 @test_i32_add_sub_commute_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_add_sub_commute_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    subl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $8, {{[0-9]+}}(%esp)
; X86-NEXT:    adcl $0, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_sub_commute_idx:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    subl %esi, %eax
; X64-NEXT:    btl $8, %edx
; X64-NEXT:    adcl $0, %eax
; X64-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, 8
  %mask = and i32 %shift, 1
  %add = add i32 %mask, %sub
  ret i32 %add
}

define i32 @test_i32_sub_add_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_sub_add_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $1, {{[0-9]+}}(%esp)
; X86-NEXT:    sbbl $0, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_add_idx:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    btl $1, %edx
; X64-NEXT:    sbbl $0, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, 1
  %mask = and i32 %shift, 1
  %sub = sub i32 %add, %mask
  ret i32 %sub
}

define i32 @test_i32_sub_sub_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_sub_sub_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $16, {{[0-9]+}}(%esp)
; X86-NEXT:    adcl $0, %eax
; X86-NEXT:    subl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_sub_idx:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl $16, %edx
; X64-NEXT:    adcl $0, %eax
; X64-NEXT:    subl %esi, %eax
; X64-NEXT:    retq
  %shift = lshr i32 %z, 16
  %mask = and i32 %shift, 1
  %sub0 = sub i32 %y, %mask
  %sub1 = sub i32 %x, %sub0
  ret i32 %sub1
}

define i32 @test_i32_sub_sub_commute_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_sub_sub_commute_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $15, {{[0-9]+}}(%esp)
; X86-NEXT:    sbbl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_sub_commute_idx:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl $15, %edx
; X64-NEXT:    sbbl %esi, %eax
; X64-NEXT:    retq
  %shift = lshr i32 %z, 15
  %mask = and i32 %shift, 1
  %sub0 = sub i32 %x, %y
  %sub1 = sub i32 %sub0, %mask
  ret i32 %sub1
}

define i32 @test_i32_sub_sum_idx(i32 %x, i32 %y, i32 %z) nounwind {
; X86-LABEL: test_i32_sub_sum_idx:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl $30, {{[0-9]+}}(%esp)
; X86-NEXT:    sbbl $0, %eax
; X86-NEXT:    negl %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_sum_idx:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    btl $30, %edx
; X64-NEXT:    sbbl $0, %eax
; X64-NEXT:    negl %eax
; X64-NEXT:    retq
  %shift = lshr i32 %z, 30
  %mask = and i32 %shift, 1
  %add = add i32 %y, %x
  %sub = sub i32 %mask, %add
  ret i32 %sub
}

;
; Variable Bit Indices
;

define i32 @test_i32_add_add_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_add_add_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_add_var:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    adcl %esi, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add1 = add i32 %add, %mask
  ret i32 %add1
}

define i32 @test_i32_add_add_commute_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_add_add_commute_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_add_commute_var:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    adcl %esi, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add1 = add i32 %mask, %add
  ret i32 %add1
}

define i64 @test_i64_add_add_var(i64 %x, i64 %y, i64 %z, i64 %w) nounwind {
; X86-LABEL: test_i64_add_add_var:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl
; X86-NEXT:    movl {{[0-9]+}}(%esp), %esi
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ebx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    adcl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl %ebx, %edi
; X86-NEXT:    shrl %cl, %edi
; X86-NEXT:    shrdl %cl, %ebx, %esi
; X86-NEXT:    testb $32, %cl
; X86-NEXT:    jne .LBB13_2
; X86-NEXT:  # %bb.1:
; X86-NEXT:    movl %esi, %edi
; X86-NEXT:  .LBB13_2:
; X86-NEXT:    andl $1, %edi
; X86-NEXT:    addl %edi, %eax
; X86-NEXT:    adcl $0, %edx
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    retl
;
; X64-LABEL: test_i64_add_add_var:
; X64:       # %bb.0:
; X64-NEXT:    movq %rdi, %rax
; X64-NEXT:    btq %rcx, %rdx
; X64-NEXT:    adcq %rsi, %rax
; X64-NEXT:    retq
  %add = add i64 %y, %x
  %shift = lshr i64 %z, %w
  %mask = and i64 %shift, 1
  %add1 = add i64 %add, %mask
  ret i64 %add1
}

define i32 @test_i32_add_sub_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_add_sub_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    subl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    adcl $0, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_sub_var:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    subl %esi, %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    adcl $0, %eax
; X64-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add = add i32 %sub, %mask
  ret i32 %add
}

define i32 @test_i32_add_sub_commute_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_add_sub_commute_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    subl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    adcl $0, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_add_sub_commute_var:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    subl %esi, %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    adcl $0, %eax
; X64-NEXT:    retq
  %sub = sub i32 %x, %y
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add = add i32 %mask, %sub
  ret i32 %add
}

define i32 @test_i32_sub_add_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_sub_add_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    sbbl $0, %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_add_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    sbbl $0, %eax
; X64-NEXT:    retq
  %add = add i32 %y, %x
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %sub = sub i32 %add, %mask
  ret i32 %sub
}

define i32 @test_i32_sub_sub_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_sub_sub_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    adcl $0, %eax
; X86-NEXT:    subl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_sub_var:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    adcl $0, %eax
; X64-NEXT:    subl %esi, %eax
; X64-NEXT:    retq
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %sub0 = sub i32 %y, %mask
  %sub1 = sub i32 %x, %sub0
  ret i32 %sub1
}

define i32 @test_i32_sub_sub_commute_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_sub_sub_commute_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    sbbl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_sub_commute_var:
; X64:       # %bb.0:
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    sbbl %esi, %eax
; X64-NEXT:    retq
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %sub0 = sub i32 %x, %y
  %sub1 = sub i32 %sub0, %mask
  ret i32 %sub1
}

define i32 @test_i32_sub_sum_var(i32 %x, i32 %y, i32 %z, i32 %w) nounwind {
; X86-LABEL: test_i32_sub_sum_var:
; X86:       # %bb.0:
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    addl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    btl %ecx, %edx
; X86-NEXT:    sbbl $0, %eax
; X86-NEXT:    negl %eax
; X86-NEXT:    retl
;
; X64-LABEL: test_i32_sub_sum_var:
; X64:       # %bb.0:
; X64-NEXT:    # kill: def $esi killed $esi def $rsi
; X64-NEXT:    # kill: def $edi killed $edi def $rdi
; X64-NEXT:    leal (%rdi,%rsi), %eax
; X64-NEXT:    btl %ecx, %edx
; X64-NEXT:    sbbl $0, %eax
; X64-NEXT:    negl %eax
; X64-NEXT:    retq
  %shift = lshr i32 %z, %w
  %mask = and i32 %shift, 1
  %add = add i32 %y, %x
  %sub = sub i32 %mask, %add
  ret i32 %sub
}
