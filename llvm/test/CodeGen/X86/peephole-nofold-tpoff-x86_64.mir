# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -run-pass=peephole-opt -mtriple=x86_64-- %s -o - | FileCheck %s

# Linkers may change `addq xx@GOTTPOFF, %reg` to `leaq OFFSET(%reg), %reg`,
# so we must not depend upon the EFLAGS output. Verify that the TEST
# instruction won't be folded into the ADD.

# NOTE: the IR will no longer actually produce the input MIR after
# llvm.threadlocal.address intrinsic is annotated as having a nonnull
# result.

--- |
  target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-unknown-linux-gnu"

  @x = external thread_local(initialexec) global i32, align 4

  define i32 @foo() {
    %1 = tail call ptr @llvm.threadlocal.address.p0(ptr nonnull @x)
    %cmp = icmp eq ptr %1, null
    %zext = zext i1 %cmp to i32
    ret i32 %zext
  }

  ; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
  declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull) #0

  attributes #0 = { nocallback nofree nosync nounwind readnone speculatable willreturn }

...
---
name:            foo
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: gr64 }
  - { id: 1, class: gr64 }
  - { id: 2, class: gr8 }
  - { id: 3, class: gr32 }
frameInfo:
  maxAlignment:    1
machineFunctionInfo: {}
body:             |
  bb.0 (%ir-block.0):
    ; CHECK-LABEL: name: foo
    ; CHECK: [[MOV64rm:%[0-9]+]]:gr64 = MOV64rm $noreg, 1, $noreg, 0, $fs :: (load (s64) from `ptr addrspace(257) null`, addrspace 257)
    ; CHECK-NEXT: [[ADD64rm:%[0-9]+]]:gr64 = ADD64rm [[MOV64rm]], $rip, 1, $noreg, target-flags(x86-gottpoff) @x, $noreg, implicit-def dead $eflags :: (load (s64) from got)
    ; CHECK-NEXT: TEST64rr [[ADD64rm]], [[ADD64rm]], implicit-def $eflags
    ; CHECK-NEXT: [[SETCCr:%[0-9]+]]:gr8 = SETCCr 4, implicit $eflags
    ; CHECK-NEXT: [[MOVZX32rr8_:%[0-9]+]]:gr32 = MOVZX32rr8 killed [[SETCCr]]
    ; CHECK-NEXT: $eax = COPY [[MOVZX32rr8_]]
    ; CHECK-NEXT: RET 0, $eax
    %0:gr64 = MOV64rm $noreg, 1, $noreg, 0, $fs :: (load (s64) from `ptr addrspace(257) null`, addrspace 257)
    %1:gr64 = ADD64rm %0, $rip, 1, $noreg, target-flags(x86-gottpoff) @x, $noreg, implicit-def dead $eflags :: (load (s64) from got)
    TEST64rr %1, %1, implicit-def $eflags
    %2:gr8 = SETCCr 4, implicit $eflags
    %3:gr32 = MOVZX32rr8 killed %2
    $eax = COPY %3
    RET 0, $eax

...
