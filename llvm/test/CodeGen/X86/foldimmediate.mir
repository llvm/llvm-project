# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 3
# RUN: llc -mtriple=x86_64-- -run-pass=peephole-opt %s -o - | FileCheck %s
--- |
  define void @foldImmediate() { ret void }
...
---
# Check that immediates can be folded into ALU instructions.
name: foldImmediate
registers:
  - { id: 0, class: gr32 }
  - { id: 1, class: gr32 }
  - { id: 2, class: gr32 }
  - { id: 3, class: gr32 }
  - { id: 4, class: gr32 }
  - { id: 5, class: gr32 }
  - { id: 6, class: gr32 }
  - { id: 7, class: gr64 }
  - { id: 8, class: gr64 }
  - { id: 9, class: gr64 }
  - { id: 10, class: gr64 }
  - { id: 11, class: gr64 }
  - { id: 12, class: gr64 }
  - { id: 13, class: gr64 }
  - { id: 14, class: gr64 }
  - { id: 15, class: gr64 }
  - { id: 16, class: gr32 }
  - { id: 17, class: gr64 }
  - { id: 18, class: gr32 }

body: |
  bb.0:
    liveins: $rdi, $rsi

    ; CHECK-LABEL: name: foldImmediate
    ; CHECK: liveins: $rdi, $rsi
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[MOV32ri:%[0-9]+]]:gr32 = MOV32ri 81
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gr32 = COPY $edi
    ; CHECK-NEXT: [[ADD32ri:%[0-9]+]]:gr32 = ADD32ri [[COPY]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[ADD32ri]]
    ; CHECK-NEXT: [[SUB32ri:%[0-9]+]]:gr32 = SUB32ri [[COPY]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[SUB32ri]]
    ; CHECK-NEXT: [[AND32ri:%[0-9]+]]:gr32 = AND32ri [[COPY]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[AND32ri]]
    ; CHECK-NEXT: [[OR32ri:%[0-9]+]]:gr32 = OR32ri [[COPY]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[OR32ri]]
    ; CHECK-NEXT: [[XOR32ri:%[0-9]+]]:gr32 = XOR32ri [[COPY]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[XOR32ri]]
    ; CHECK-NEXT: TEST32ri [[COPY]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit $eflags
    ; CHECK-NEXT: CMP32ri [[COPY]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit $eflags
    ; CHECK-NEXT: [[ADC32ri:%[0-9]+]]:gr32 = ADC32ri [[COPY]], 81, implicit-def $eflags, implicit $eflags
    ; CHECK-NEXT: NOOP implicit [[ADC32ri]]
    ; CHECK-NEXT: [[SBB32ri:%[0-9]+]]:gr32 = SBB32ri [[COPY]], 81, implicit-def $eflags, implicit $eflags
    ; CHECK-NEXT: NOOP implicit [[SBB32ri]]
    ; CHECK-NEXT: [[SUBREG_TO_REG:%[0-9]+]]:gr64 = SUBREG_TO_REG 0, killed [[MOV32ri]], %subreg.sub_32bit
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:gr64 = COPY $rsi
    ; CHECK-NEXT: [[ADD64ri32_:%[0-9]+]]:gr64 = ADD64ri32 [[COPY1]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[ADD64ri32_]]
    ; CHECK-NEXT: [[SUB64ri32_:%[0-9]+]]:gr64 = SUB64ri32 [[COPY1]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[SUB64ri32_]]
    ; CHECK-NEXT: [[AND64ri32_:%[0-9]+]]:gr64 = AND64ri32 [[COPY1]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[AND64ri32_]]
    ; CHECK-NEXT: [[OR64ri32_:%[0-9]+]]:gr64 = OR64ri32 [[COPY1]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[OR64ri32_]]
    ; CHECK-NEXT: [[XOR64ri32_:%[0-9]+]]:gr64 = XOR64ri32 [[COPY1]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit [[XOR64ri32_]]
    ; CHECK-NEXT: [[MOV32ri64_:%[0-9]+]]:gr64 = MOV32ri64 81
    ; CHECK-NEXT: NOOP implicit [[MOV32ri64_]]
    ; CHECK-NEXT: TEST64ri32 [[COPY1]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit $eflags
    ; CHECK-NEXT: [[ADC64ri32_:%[0-9]+]]:gr64 = ADC64ri32 [[COPY1]], 81, implicit-def $eflags, implicit $eflags
    ; CHECK-NEXT: NOOP implicit [[ADC64ri32_]]
    ; CHECK-NEXT: [[SBB64ri32_:%[0-9]+]]:gr64 = SBB64ri32 [[COPY1]], 81, implicit-def $eflags, implicit $eflags
    ; CHECK-NEXT: NOOP implicit [[SBB64ri32_]]
    ; CHECK-NEXT: CMP64ri32 [[COPY1]], 81, implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit $eflags
    ; CHECK-NEXT: CMP64rr [[SUBREG_TO_REG]], [[COPY1]], implicit-def $eflags
    ; CHECK-NEXT: NOOP implicit $eflags
    %0 = MOV32ri 81
    %1 = COPY $edi
    %2 = ADD32rr %0, %1, implicit-def $eflags
    NOOP implicit %2

    %3 = SUB32rr %1, %0, implicit-def $eflags
    NOOP implicit %3

    %4 = AND32rr %0, %1, implicit-def $eflags
    NOOP implicit %4

    %5 = OR32rr %0, %1, implicit-def $eflags
    NOOP implicit %5

    %6 = XOR32rr %0, %1, implicit-def $eflags
    NOOP implicit %6

    TEST32rr %0, %1, implicit-def $eflags
    NOOP implicit $eflags

    CMP32rr %1, %0, implicit-def $eflags
    NOOP implicit $eflags

    %16 = ADC32rr %0, %1, implicit-def $eflags, implicit $eflags
    NOOP implicit %16

    %18 = SBB32rr %1, %0, implicit-def $eflags, implicit $eflags
    NOOP implicit %18

    %7 = SUBREG_TO_REG 0, killed %0:gr32, %subreg.sub_32bit
    %8 = COPY $rsi
    %9 = ADD64rr %7, %8, implicit-def $eflags
    NOOP implicit %9

    %10 = SUB64rr %8, %7, implicit-def $eflags
    NOOP implicit %10

    %11 = AND64rr %8, %7, implicit-def $eflags
    NOOP implicit %11

    %12 = OR64rr %8, %7, implicit-def $eflags
    NOOP implicit %12

    %13 = XOR64rr %8, %7, implicit-def $eflags
    NOOP implicit %13

    %14 = COPY %7
    NOOP implicit %14

    TEST64rr %8, %7, implicit-def $eflags
    NOOP implicit $eflags

    %15 = ADC64rr %8, %7, implicit-def $eflags, implicit $eflags
    NOOP implicit %15

    %17 = SBB64rr %8, %7, implicit-def $eflags, implicit $eflags
    NOOP implicit %17

    CMP64rr %8, %7, implicit-def $eflags
    NOOP implicit $eflags
    CMP64rr %7, %8, implicit-def $eflags
    NOOP implicit $eflags
...
