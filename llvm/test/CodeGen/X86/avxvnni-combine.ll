; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mcpu=alderlake | FileCheck %s

; __m256i foo(int cnt, __m256i c, __m256i b, __m256i *p) {
;     for (int i = 0; i < cnt; ++i) {
;         __m256i a = p[i];
;         __m256i m = _mm256_madd_epi16 (b, a);
;         c = _mm256_add_epi32(m, c);
;     }
;     return c;
; }

define dso_local <4 x i64> @foo(i32 %0, <4 x i64> %1, <4 x i64> %2, ptr %3) {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    jle .LBB0_6
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    movl %edi, %edx
; CHECK-NEXT:    movl %edx, %eax
; CHECK-NEXT:    andl $3, %eax
; CHECK-NEXT:    cmpl $4, %edi
; CHECK-NEXT:    jae .LBB0_7
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    jmp .LBB0_3
; CHECK-NEXT:  .LBB0_7:
; CHECK-NEXT:    andl $-4, %edx
; CHECK-NEXT:    leaq 96(%rsi), %rdi
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_8: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    {vex} vpdpwssd -96(%rdi), %ymm1, %ymm0
; CHECK-NEXT:    {vex} vpdpwssd -64(%rdi), %ymm1, %ymm0
; CHECK-NEXT:    {vex} vpdpwssd -32(%rdi), %ymm1, %ymm0
; CHECK-NEXT:    {vex} vpdpwssd (%rdi), %ymm1, %ymm0
; CHECK-NEXT:    addq $4, %rcx
; CHECK-NEXT:    subq $-128, %rdi
; CHECK-NEXT:    cmpq %rcx, %rdx
; CHECK-NEXT:    jne .LBB0_8
; CHECK-NEXT:  .LBB0_3:
; CHECK-NEXT:    testq %rax, %rax
; CHECK-NEXT:    je .LBB0_6
; CHECK-NEXT:  # %bb.4: # %.preheader
; CHECK-NEXT:    shlq $5, %rcx
; CHECK-NEXT:    addq %rcx, %rsi
; CHECK-NEXT:    shlq $5, %rax
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_5: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    {vex} vpdpwssd (%rsi,%rcx), %ymm1, %ymm0
; CHECK-NEXT:    addq $32, %rcx
; CHECK-NEXT:    cmpq %rcx, %rax
; CHECK-NEXT:    jne .LBB0_5
; CHECK-NEXT:  .LBB0_6:
; CHECK-NEXT:    retq
  %5 = icmp sgt i32 %0, 0
  br i1 %5, label %6, label %33

6:                                                ; preds = %4
  %7 = bitcast <4 x i64> %2 to <16 x i16>
  %8 = bitcast <4 x i64> %1 to <8 x i32>
  %9 = zext i32 %0 to i64
  %10 = and i64 %9, 3
  %11 = icmp ult i32 %0, 4
  br i1 %11, label %14, label %12

12:                                               ; preds = %6
  %13 = and i64 %9, 4294967292
  br label %35

14:                                               ; preds = %35, %6
  %15 = phi <8 x i32> [ undef, %6 ], [ %57, %35 ]
  %16 = phi i64 [ 0, %6 ], [ %58, %35 ]
  %17 = phi <8 x i32> [ %8, %6 ], [ %57, %35 ]
  %18 = icmp eq i64 %10, 0
  br i1 %18, label %30, label %19

19:                                               ; preds = %14, %19
  %20 = phi i64 [ %27, %19 ], [ %16, %14 ]
  %21 = phi <8 x i32> [ %26, %19 ], [ %17, %14 ]
  %22 = phi i64 [ %28, %19 ], [ 0, %14 ]
  %23 = getelementptr inbounds <4 x i64>, ptr %3, i64 %20
  %24 = load <16 x i16>, ptr %23, align 32
  %25 = tail call <8 x i32> @llvm.x86.avx2.pmadd.wd(<16 x i16> %7, <16 x i16> %24)
  %26 = add <8 x i32> %25, %21
  %27 = add nuw nsw i64 %20, 1
  %28 = add i64 %22, 1
  %29 = icmp eq i64 %28, %10
  br i1 %29, label %30, label %19

30:                                               ; preds = %19, %14
  %31 = phi <8 x i32> [ %15, %14 ], [ %26, %19 ]
  %32 = bitcast <8 x i32> %31 to <4 x i64>
  br label %33

33:                                               ; preds = %30, %4
  %34 = phi <4 x i64> [ %32, %30 ], [ %1, %4 ]
  ret <4 x i64> %34

35:                                               ; preds = %35, %12
  %36 = phi i64 [ 0, %12 ], [ %58, %35 ]
  %37 = phi <8 x i32> [ %8, %12 ], [ %57, %35 ]
  %38 = phi i64 [ 0, %12 ], [ %59, %35 ]
  %39 = getelementptr inbounds <4 x i64>, ptr %3, i64 %36
  %40 = load <16 x i16>, ptr %39, align 32
  %41 = tail call <8 x i32> @llvm.x86.avx2.pmadd.wd(<16 x i16> %7, <16 x i16> %40)
  %42 = add <8 x i32> %41, %37
  %43 = or i64 %36, 1
  %44 = getelementptr inbounds <4 x i64>, ptr %3, i64 %43
  %45 = load <16 x i16>, ptr %44, align 32
  %46 = tail call <8 x i32> @llvm.x86.avx2.pmadd.wd(<16 x i16> %7, <16 x i16> %45)
  %47 = add <8 x i32> %46, %42
  %48 = or i64 %36, 2
  %49 = getelementptr inbounds <4 x i64>, ptr %3, i64 %48
  %50 = load <16 x i16>, ptr %49, align 32
  %51 = tail call <8 x i32> @llvm.x86.avx2.pmadd.wd(<16 x i16> %7, <16 x i16> %50)
  %52 = add <8 x i32> %51, %47
  %53 = or i64 %36, 3
  %54 = getelementptr inbounds <4 x i64>, ptr %3, i64 %53
  %55 = load <16 x i16>, ptr %54, align 32
  %56 = tail call <8 x i32> @llvm.x86.avx2.pmadd.wd(<16 x i16> %7, <16 x i16> %55)
  %57 = add <8 x i32> %56, %52
  %58 = add nuw nsw i64 %36, 4
  %59 = add i64 %38, 4
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %14, label %35
}
declare <8 x i32> @llvm.x86.avx2.pmadd.wd(<16 x i16>, <16 x i16>)

; void bar(int cnt, __m256i *c, __m256i b, __m256i *p) {
;     for (int i = 0; i < cnt; ++i) {
;         __m256i a = p[i];
;         c[i] = _mm256_dpwssd_epi32(c[i], b, a);
;     }
; }
define void @bar(i32 %0, ptr %1, <4 x i64> %2, ptr %3) {
; CHECK-LABEL: bar:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    jle .LBB1_5
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    jne .LBB1_6
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    jmp .LBB1_3
; CHECK-NEXT:  .LBB1_6:
; CHECK-NEXT:    movl %eax, %edi
; CHECK-NEXT:    andl $-2, %edi
; CHECK-NEXT:    movl $32, %r8d
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB1_7: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    vmovdqa -32(%rsi,%r8), %ymm1
; CHECK-NEXT:    vmovdqa (%rsi,%r8), %ymm2
; CHECK-NEXT:    {vex} vpdpwssd -32(%rdx,%r8), %ymm0, %ymm1
; CHECK-NEXT:    vmovdqa %ymm1, -32(%rsi,%r8)
; CHECK-NEXT:    {vex} vpdpwssd (%rdx,%r8), %ymm0, %ymm2
; CHECK-NEXT:    vmovdqa %ymm2, (%rsi,%r8)
; CHECK-NEXT:    addq $2, %rcx
; CHECK-NEXT:    addq $64, %r8
; CHECK-NEXT:    cmpq %rcx, %rdi
; CHECK-NEXT:    jne .LBB1_7
; CHECK-NEXT:  .LBB1_3:
; CHECK-NEXT:    testb $1, %al
; CHECK-NEXT:    je .LBB1_5
; CHECK-NEXT:  # %bb.4:
; CHECK-NEXT:    shlq $5, %rcx
; CHECK-NEXT:    vmovdqa (%rsi,%rcx), %ymm1
; CHECK-NEXT:    {vex} vpdpwssd (%rdx,%rcx), %ymm0, %ymm1
; CHECK-NEXT:    vmovdqa %ymm1, (%rsi,%rcx)
; CHECK-NEXT:  .LBB1_5:
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %5 = icmp sgt i32 %0, 0
  br i1 %5, label %6, label %22

6:                                                ; preds = %4
  %7 = bitcast <4 x i64> %2 to <8 x i32>
  %8 = zext i32 %0 to i64
  %9 = and i64 %8, 1
  %10 = icmp eq i32 %0, 1
  br i1 %10, label %13, label %11

11:                                               ; preds = %6
  %12 = and i64 %8, 4294967294
  br label %23

13:                                               ; preds = %23, %6
  %14 = phi i64 [ 0, %6 ], [ %37, %23 ]
  %15 = icmp eq i64 %9, 0
  br i1 %15, label %22, label %16

16:                                               ; preds = %13
  %17 = getelementptr inbounds <4 x i64>, ptr %3, i64 %14
  %18 = load <8 x i32>, ptr %17, align 32
  %19 = getelementptr inbounds <4 x i64>, ptr %1, i64 %14
  %20 = load <8 x i32>, ptr %19, align 32
  %21 = tail call <8 x i32> @llvm.x86.avx512.vpdpwssd.256(<8 x i32> %20, <8 x i32> %7, <8 x i32> %18)
  store <8 x i32> %21, ptr %19, align 32
  br label %22

22:                                               ; preds = %16, %13, %4
  ret void

23:                                               ; preds = %23, %11
  %24 = phi i64 [ 0, %11 ], [ %37, %23 ]
  %25 = phi i64 [ 0, %11 ], [ %38, %23 ]
  %26 = getelementptr inbounds <4 x i64>, ptr %3, i64 %24
  %27 = load <8 x i32>, ptr %26, align 32
  %28 = getelementptr inbounds <4 x i64>, ptr %1, i64 %24
  %29 = load <8 x i32>, ptr %28, align 32
  %30 = tail call <8 x i32> @llvm.x86.avx512.vpdpwssd.256(<8 x i32> %29, <8 x i32> %7, <8 x i32> %27)
  store <8 x i32> %30, ptr %28, align 32
  %31 = or i64 %24, 1
  %32 = getelementptr inbounds <4 x i64>, ptr %3, i64 %31
  %33 = load <8 x i32>, ptr %32, align 32
  %34 = getelementptr inbounds <4 x i64>, ptr %1, i64 %31
  %35 = load <8 x i32>, ptr %34, align 32
  %36 = tail call <8 x i32> @llvm.x86.avx512.vpdpwssd.256(<8 x i32> %35, <8 x i32> %7, <8 x i32> %33)
  store <8 x i32> %36, ptr %34, align 32
  %37 = add nuw nsw i64 %24, 2
  %38 = add i64 %25, 2
  %39 = icmp eq i64 %38, %12
  br i1 %39, label %13, label %23
}
declare <8 x i32> @llvm.x86.avx512.vpdpwssd.256(<8 x i32>, <8 x i32>, <8 x i32>)
