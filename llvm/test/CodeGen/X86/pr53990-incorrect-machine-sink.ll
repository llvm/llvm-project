; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-- < %s | FileCheck %s

declare void @clobber()

define void @test(i1 %c, ptr %p, ptr noalias %p2) nounwind {
; CHECK-LABEL: test:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    movq %rdx, %rbx
; CHECK-NEXT:    movl %edi, %ebp
; CHECK-NEXT:    movq (%rsi), %r14
; CHECK-NEXT:    movb $1, %r15b
; CHECK-NEXT:    jmp .LBB0_1
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_4: # %sink
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    movq %r14, (%rbx)
; CHECK-NEXT:  .LBB0_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    testb %r15b, %r15b
; CHECK-NEXT:    jne .LBB0_1
; CHECK-NEXT:  # %bb.2: # %split.3
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    testb $1, %bpl
; CHECK-NEXT:    je .LBB0_4
; CHECK-NEXT:  # %bb.3: # %clobber
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    callq clobber@PLT
; CHECK-NEXT:    jmp .LBB0_4
entry:
  %val = load i64, ptr %p, align 8
  br label %loop

loop:
  switch i8 undef, label %unreachable [
    i8 0, label %latch
    i8 1, label %split.1
    i8 2, label %split.2
    i8 3, label %split.3
  ]

unreachable:
  unreachable

split.3:
  br i1 %c, label %clobber, label %sink

split.1:
  br label %latch

split.2:
  br label %latch

clobber:
  call void @clobber()
  br label %sink

sink:
  store i64 %val, ptr %p2, align 8
  br label %latch

latch:
  %phi = phi i64 [ 0, %sink ], [ 0, %split.2 ], [ 1, %split.1 ], [ 0, %loop ]
  %phi.live = add i64 %phi, 0
  br label %loop
}
