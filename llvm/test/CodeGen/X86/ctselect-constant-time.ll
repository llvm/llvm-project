; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=-cmov | FileCheck %s --check-prefix=CONSTANT-TIME
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=-cmov -verify-machineinstrs | FileCheck %s --check-prefix=CONSTANT-TIME

; Test constant-time properties of CTSELECT implementation on i386
; This test verifies that:
; 1. No conditional branches are generated
; 2. Both true and false values are always loaded/computed
; 3. No conditional memory loads are performed

define i32 @crypto_key_select(i32 %secret_bit, i32 %key1, i32 %key2) nounwind {
; CONSTANT-TIME-LABEL: crypto_key_select:
; CONSTANT-TIME:       # %bb.0:
; CONSTANT-TIME-NEXT:    pushl %ebx
; CONSTANT-TIME-NEXT:    pushl %edi
; CONSTANT-TIME-NEXT:    pushl %esi
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %edx
; CONSTANT-TIME-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; CONSTANT-TIME-NEXT:    setne %al
; CONSTANT-TIME-NEXT:    testb %al, %al
; CONSTANT-TIME-NEXT:    BUNDLE
; CONSTANT-TIME-NEXT:    popl %esi
; CONSTANT-TIME-NEXT:    popl %edi
; CONSTANT-TIME-NEXT:    popl %ebx
; CONSTANT-TIME-NEXT:    retl
  %cond = icmp ne i32 %secret_bit, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %key1, i32 %key2)
  ret i32 %result
}

define i32 @constant_memory_access(i32 %secret, i32* %data1, i32* %data2) nounwind {
; CONSTANT-TIME-LABEL: constant_memory_access:
; CONSTANT-TIME:       # %bb.0:
; CONSTANT-TIME-NEXT:    pushl %ebx
; CONSTANT-TIME-NEXT:    pushl %edi
; CONSTANT-TIME-NEXT:    pushl %esi
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CONSTANT-TIME-NEXT:    movl (%ecx), %ecx
; CONSTANT-TIME-NEXT:    movl (%eax), %edx
; CONSTANT-TIME-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; CONSTANT-TIME-NEXT:    setne %al
; CONSTANT-TIME-NEXT:    testb %al, %al
; CONSTANT-TIME-NEXT:    BUNDLE
; CONSTANT-TIME-NEXT:    popl %esi
; CONSTANT-TIME-NEXT:    popl %edi
; CONSTANT-TIME-NEXT:    popl %ebx
; CONSTANT-TIME-NEXT:    retl
  %val1 = load i32, i32* %data1
  %val2 = load i32, i32* %data2
  %cond = icmp ne i32 %secret, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %val1, i32 %val2)
  ret i32 %result
}

define i64 @crypto_key_select_64bit(i32 %secret_bit, i64 %key1, i64 %key2) nounwind {
; CONSTANT-TIME-LABEL: crypto_key_select_64bit:
; CONSTANT-TIME:       # %bb.0:
; CONSTANT-TIME-NEXT:    pushl %ebp
; CONSTANT-TIME-NEXT:    pushl %ebx
; CONSTANT-TIME-NEXT:    pushl %edi
; CONSTANT-TIME-NEXT:    pushl %esi
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %edx
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %edi
; CONSTANT-TIME-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; CONSTANT-TIME-NEXT:    setne %al
; CONSTANT-TIME-NEXT:    testb %al, %al
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CONSTANT-TIME-NEXT:    BUNDLE
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CONSTANT-TIME-NEXT:    BUNDLE
; CONSTANT-TIME-NEXT:    popl %esi
; CONSTANT-TIME-NEXT:    popl %edi
; CONSTANT-TIME-NEXT:    popl %ebx
; CONSTANT-TIME-NEXT:    popl %ebp
; CONSTANT-TIME-NEXT:    retl
  %cond = icmp ne i32 %secret_bit, 0
  %result = call i64 @llvm.ct.select.i64(i1 %cond, i64 %key1, i64 %key2)
  ret i64 %result
}

define i32 @array_index_protection(i32 %secret_index, i32* %array) nounwind {
; CONSTANT-TIME-LABEL: array_index_protection:
; CONSTANT-TIME:       # %bb.0:
; CONSTANT-TIME-NEXT:    pushl %ebx
; CONSTANT-TIME-NEXT:    pushl %edi
; CONSTANT-TIME-NEXT:    pushl %esi
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CONSTANT-TIME-NEXT:    movl (%eax), %ecx
; CONSTANT-TIME-NEXT:    movl 4(%eax), %edx
; CONSTANT-TIME-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; CONSTANT-TIME-NEXT:    setne %al
; CONSTANT-TIME-NEXT:    testb %al, %al
; CONSTANT-TIME-NEXT:    BUNDLE
; CONSTANT-TIME-NEXT:    popl %esi
; CONSTANT-TIME-NEXT:    popl %edi
; CONSTANT-TIME-NEXT:    popl %ebx
; CONSTANT-TIME-NEXT:    retl
  %val0 = load i32, i32* %array
  %ptr1 = getelementptr i32, i32* %array, i32 1
  %val1 = load i32, i32* %ptr1
  %cond = icmp ne i32 %secret_index, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %val1, i32 %val0)
  ret i32 %result
}

; Test that complex expressions also work in constant-time
define i32 @complex_crypto_operation(i32 %secret, i32 %a, i32 %b) nounwind {
; CONSTANT-TIME-LABEL: complex_crypto_operation:
; CONSTANT-TIME:       # %bb.0:
; CONSTANT-TIME-NEXT:    pushl %ebx
; CONSTANT-TIME-NEXT:    pushl %edi
; CONSTANT-TIME-NEXT:    pushl %esi
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %edx
; CONSTANT-TIME-NEXT:    addl %ecx, %edx
; CONSTANT-TIME-NEXT:    imull %ecx, %ecx
; CONSTANT-TIME-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; CONSTANT-TIME-NEXT:    setne %al
; CONSTANT-TIME-NEXT:    testb %al, %al
; CONSTANT-TIME-NEXT:    BUNDLE
; CONSTANT-TIME-NEXT:    popl %esi
; CONSTANT-TIME-NEXT:    popl %edi
; CONSTANT-TIME-NEXT:    popl %ebx
; CONSTANT-TIME-NEXT:    retl
  %expr1 = add i32 %a, %b
  %expr2 = mul i32 %b, %b
  %cond = icmp ne i32 %secret, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %expr1, i32 %expr2)
  ret i32 %result
}

; Verify that bundling prevents instruction reordering
; This is harder to test directly, but we can check that instructions appear
; in the expected sequence and no optimization has moved them around
define i32 @verify_bundling(i32 %secret, i32 %val1, i32 %val2) nounwind {
; CONSTANT-TIME-LABEL: verify_bundling:
; CONSTANT-TIME:       # %bb.0:
; CONSTANT-TIME-NEXT:    pushl %ebx
; CONSTANT-TIME-NEXT:    pushl %edi
; CONSTANT-TIME-NEXT:    pushl %esi
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CONSTANT-TIME-NEXT:    movl {{[0-9]+}}(%esp), %edx
; CONSTANT-TIME-NEXT:    cmpl $0, {{[0-9]+}}(%esp)
; CONSTANT-TIME-NEXT:    setne %al
; CONSTANT-TIME-NEXT:    testb %al, %al
; CONSTANT-TIME-NEXT:    BUNDLE
; CONSTANT-TIME-NEXT:    popl %esi
; CONSTANT-TIME-NEXT:    popl %edi
; CONSTANT-TIME-NEXT:    popl %ebx
; CONSTANT-TIME-NEXT:    retl
  %cond = icmp ne i32 %secret, 0
  %result = call i32 @llvm.ct.select.i32(i1 %cond, i32 %val1, i32 %val2)
  ret i32 %result
}

declare i32 @llvm.ct.select.i32(i1, i32, i32)
declare i64 @llvm.ct.select.i64(i1, i64, i64)
