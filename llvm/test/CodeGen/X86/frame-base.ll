; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=x86_64-apple-macosx -o - %s | FileCheck %s

; The issue here was a conflict between forming a %rip-relative lea and a
; FrameIndex lea. The %rip sanity-checks didn't consider that a base register
; had been set if we'd already matched a FrameIndex, when it has in reality.

@var = global i32 0

define void @test_frame_rip_conflict() {
; CHECK-LABEL: test_frame_rip_conflict:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    leaq _var(%rip), %rax
; CHECK-NEXT:    leaq (%rsp,%rax), %rdi
; CHECK-NEXT:    addq $4, %rdi
; CHECK-NEXT:    callq _eat_i64
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
  %stackvar = alloca i32

  %stackint = ptrtoint ptr %stackvar to i64
  %addr = add i64 ptrtoint(ptr @var to i64), %stackint

  call void @eat_i64(i64 %addr)
  ret void
}

declare void @eat_i64(i64)
