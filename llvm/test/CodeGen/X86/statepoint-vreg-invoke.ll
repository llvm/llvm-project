; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -max-registers-for-gc-values=4 -stop-after virtregrewriter < %s | FileCheck %s

target datalayout = "e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

declare dso_local void @"some_call"(ptr addrspace(1))
declare dso_local i32 @foo(i32, ptr addrspace(1), i32, i32, i32)
declare dso_local ptr @personality_function()

define ptr addrspace(1) @test_basic_invoke(ptr addrspace(1) %obj, ptr addrspace(1) %obj1)
  ; CHECK-LABEL: name: test_basic_invoke
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x7ffff800), %bb.3(0x00000800)
  ; CHECK-NEXT:   liveins: $rdi, $rsi
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   MOV64mr %stack.1, 1, $noreg, 0, $noreg, renamable $rdi :: (store (s64) into %stack.1)
  ; CHECK-NEXT:   MOV64mr %stack.0, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store (s64) into %stack.0)
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   STATEPOINT 0, 0, 1, @some_call, $rdi, 2, 0, 2, 0, 2, 5, 2, 0, 2, -1, 2, 0, 2, 0, 2, 0, 2, 2, 1, 8, %stack.0, 0, 1, 8, %stack.1, 0, 2, 0, 2, 2, 0, 0, 1, 1, csr_64, implicit-def $rsp, implicit-def $ssp :: (volatile load store (s64) on %stack.0), (volatile load store (s64) on %stack.1)
  ; CHECK-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   JMP_1 %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.safepoint_normal_dest:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $rax = MOV64rm %stack.1, 1, $noreg, 0, $noreg :: (load (s64) from %stack.1)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.normal_return:
  ; CHECK-NEXT:   liveins: $rax
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   RET 0, $rax
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.exceptional_return (landing-pad):
  ; CHECK-NEXT:   liveins: $rax, $rdx
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   renamable $rax = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
  ; CHECK-NEXT:   RET 0, $rax
  gc "statepoint-example" personality ptr @"personality_function" {
entry:
  %0 = invoke token (i64, i32, ptr, i32, i32, ...) @llvm.experimental.gc.statepoint.p0(i64 0, i32 0, ptr elementtype(void (ptr addrspace(1))) @some_call, i32 1, i32 0, ptr addrspace(1) %obj, i32 0, i32 0) ["gc-live" (ptr addrspace(1) %obj, ptr addrspace(1) %obj1), "deopt" (i32 0, i32 -1, i32 0, i32 0, i32 0)]
          to label %safepoint_normal_dest unwind label %exceptional_return

safepoint_normal_dest:
  %obj.relocated = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %0, i32 0, i32 0)
  %obj1.relocated = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %0, i32 1, i32 1)
  br label %normal_return

normal_return:
  ret ptr addrspace(1) %obj.relocated

exceptional_return:
  %landing_pad = landingpad token
          cleanup
  %obj.relocated1 = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %landing_pad, i32 0, i32 0)
  %obj1.relocated1 = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %landing_pad, i32 1, i32 1)
  ret ptr addrspace(1) %obj1.relocated1
}

define ptr addrspace(1) @test_invoke_same_val(i1 %cond, ptr addrspace(1) %val1, ptr addrspace(1) %val2, ptr addrspace(1) %val3)
  ; CHECK-LABEL: name: test_invoke_same_val
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.3(0x40000000)
  ; CHECK-NEXT:   liveins: $edi, $rcx, $rdx, $rsi
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $rbx = COPY $rcx
  ; CHECK-NEXT:   renamable $rbp = COPY $rdx
  ; CHECK-NEXT:   renamable $r14d = COPY $edi
  ; CHECK-NEXT:   TEST8ri renamable $r14b, 1, implicit-def $eflags
  ; CHECK-NEXT:   JCC_1 %bb.3, 4, implicit killed $eflags
  ; CHECK-NEXT:   JMP_1 %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.left:
  ; CHECK-NEXT:   successors: %bb.2(0x7ffff800), %bb.6(0x00000800)
  ; CHECK-NEXT:   liveins: $rbp, $rsi, $r14d
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   MOV64mr %stack.0, 1, $noreg, 0, $noreg, renamable $rsi :: (store (s64) into %stack.0)
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   $rdi = COPY killed renamable $rsi
  ; CHECK-NEXT:   renamable $rbp = STATEPOINT 0, 0, 1, @some_call, $rdi, 2, 0, 2, 0, 2, 0, 2, 2, killed renamable $rbp(tied-def 0), 1, 8, %stack.0, 0, 2, 0, 2, 2, 0, 0, 1, 1, csr_64, implicit-def $rsp, implicit-def $ssp :: (volatile load store (s64) on %stack.0)
  ; CHECK-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   JMP_1 %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.left.relocs:
  ; CHECK-NEXT:   successors: %bb.5(0x80000000)
  ; CHECK-NEXT:   liveins: $rbp, $r14d
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $rbx = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
  ; CHECK-NEXT:   JMP_1 %bb.5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.right:
  ; CHECK-NEXT:   successors: %bb.4(0x7ffff800), %bb.7(0x00000800)
  ; CHECK-NEXT:   liveins: $rbp, $rbx, $rsi, $r14d
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   MOV64mr %stack.0, 1, $noreg, 0, $noreg, killed renamable $rbp :: (store (s64) into %stack.0)
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   $rdi = COPY killed renamable $rsi
  ; CHECK-NEXT:   renamable $rbx = STATEPOINT 0, 0, 1, @some_call, $rdi, 2, 0, 2, 0, 2, 0, 2, 2, killed renamable $rbx(tied-def 0), 1, 8, %stack.0, 0, 2, 0, 2, 2, 0, 0, 1, 1, csr_64, implicit-def $rsp, implicit-def $ssp :: (volatile load store (s64) on %stack.0)
  ; CHECK-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   JMP_1 %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.right.relocs:
  ; CHECK-NEXT:   successors: %bb.5(0x80000000)
  ; CHECK-NEXT:   liveins: $rbx, $r14d
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $rbp = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.5.normal_return:
  ; CHECK-NEXT:   liveins: $rbp, $rbx, $r14d
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   TEST8ri renamable $r14b, 1, implicit-def $eflags, implicit killed $r14d
  ; CHECK-NEXT:   renamable $rbx = CMOV64rr killed renamable $rbx, killed renamable $rbp, 4, implicit killed $eflags
  ; CHECK-NEXT:   $rax = COPY killed renamable $rbx
  ; CHECK-NEXT:   RET 0, $rax
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.6.exceptional_return.left (landing-pad):
  ; CHECK-NEXT:   liveins: $rax, $rdx
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   renamable $rax = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
  ; CHECK-NEXT:   RET 0, $rax
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.7.exceptional_return.right (landing-pad):
  ; CHECK-NEXT:   liveins: $rax, $rdx
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   renamable $rax = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
  ; CHECK-NEXT:   RET 0, $rax
  gc "statepoint-example" personality ptr @"personality_function" {
entry:
  br i1 %cond, label %left, label %right

left:
  %sp1 = invoke token (i64, i32, ptr, i32, i32, ...) @llvm.experimental.gc.statepoint.p0(i64 0, i32 0, ptr elementtype(void (ptr addrspace(1))) @some_call, i32 1, i32 0, ptr addrspace(1) %val1, i32 0, i32 0) ["gc-live"(ptr addrspace(1) %val1, ptr addrspace(1) %val2)]
           to label %left.relocs unwind label %exceptional_return.left

left.relocs:
  %val1.relocated = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %sp1, i32 0, i32 0)
  %val2.relocated_left = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %sp1, i32 1, i32 1)
  br label %normal_return

right:
  %sp2 = invoke token (i64, i32, ptr, i32, i32, ...) @llvm.experimental.gc.statepoint.p0(i64 0, i32 0, ptr elementtype(void (ptr addrspace(1))) @some_call, i32 1, i32 0, ptr addrspace(1) %val1, i32 0, i32 0) ["gc-live"(ptr addrspace(1) %val2, ptr addrspace(1) %val3)]
           to label %right.relocs unwind label %exceptional_return.right

right.relocs:
  %val2.relocated_right = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %sp2, i32 0, i32 0)
  %val3.relocated = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %sp2, i32 1, i32 1)
  br label %normal_return

normal_return:
  %a1 = phi ptr addrspace(1) [%val1.relocated, %left.relocs], [%val3.relocated, %right.relocs]
  %a2 = phi ptr addrspace(1) [%val2.relocated_left, %left.relocs], [%val2.relocated_right, %right.relocs]
  %ret = select i1 %cond, ptr addrspace(1) %a1, ptr addrspace(1) %a2
  ret ptr addrspace(1) %ret

exceptional_return.left:
  %landing_pad = landingpad token
          cleanup
  %val1.relocated2 = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %landing_pad, i32 0, i32 0)
  ret ptr addrspace(1) %val1.relocated2

exceptional_return.right:
  %landing_pad1 = landingpad token
          cleanup
  %val2.relocated3 = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %landing_pad1, i32 0, i32 0)
  ret ptr addrspace(1) %val2.relocated3
}

define void @test_duplicate_ir_values() gc "statepoint-example" personality ptr @personality_function {
  ; CHECK-LABEL: name: test_duplicate_ir_values
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $rax = MOV64rm undef renamable $rax, 1, $noreg, 0, $noreg :: (load (s64) from `ptr addrspace(1) undef`, addrspace 1)
  ; CHECK-NEXT:   MOV64mr %stack.0, 1, $noreg, 0, $noreg, killed renamable $rax :: (store (s64) into %stack.0)
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   STATEPOINT 1, 16, 5, undef renamable $rax, undef $edi, undef $rsi, undef $edx, undef $ecx, undef $r8d, 2, 0, 2, 0, 2, 0, 2, 1, 1, 8, %stack.0, 0, 2, 0, 2, 1, 0, 0, csr_64, implicit-def $rsp, implicit-def $ssp, implicit-def dead $eax :: (volatile load store (s64) on %stack.0)
  ; CHECK-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   JMP_1 %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.normal_continue:
  ; CHECK-NEXT:   successors: {{$}}
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $rbx = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   $edi = MOV32ri 10
  ; CHECK-NEXT:   dead renamable $rbx = STATEPOINT 2882400000, 0, 1, target-flags(x86-plt) @__llvm_deoptimize, killed $edi, 2, 0, 2, 2, 2, 2, killed renamable $rbx, renamable $rbx, 2, 1, renamable $rbx(tied-def 0), 2, 0, 2, 1, 0, 0, csr_64, implicit-def $rsp, implicit-def $ssp
  ; CHECK-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.exceptional_return (landing-pad):
  ; CHECK-NEXT:   liveins: $rax, $rdx
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   EH_LABEL <mcsymbol >
  ; CHECK-NEXT:   renamable $rbx = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
  ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  ; CHECK-NEXT:   $edi = MOV32ri -271
  ; CHECK-NEXT:   dead renamable $rbx = STATEPOINT 2882400000, 0, 1, target-flags(x86-plt) @__llvm_deoptimize, killed $edi, 2, 0, 2, 0, 2, 1, killed renamable $rbx, 2, 1, renamable $rbx(tied-def 0), 2, 0, 2, 1, 0, 0, csr_64, implicit-def $rsp, implicit-def $ssp
  ; CHECK-NEXT:   ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
entry:
  %val1 = load ptr addrspace(1), ptr addrspace(1) undef, align 8
  %val2 = load ptr addrspace(1), ptr addrspace(1) undef, align 8
  %statepoint_token1 = invoke token (i64, i32, ptr, i32, i32, ...) @llvm.experimental.gc.statepoint.p0(i64 1, i32 16, ptr nonnull elementtype(i32 (i32, ptr addrspace(1), i32, i32, i32)) @foo, i32 5, i32 0, i32 undef, ptr addrspace(1) undef, i32 undef, i32 undef, i32 undef, i32 0, i32 0) [ "deopt"(), "gc-live"(ptr addrspace(1) %val1, ptr addrspace(1) %val2) ]
          to label %normal_continue unwind label %exceptional_return

normal_continue: ; preds = %entry
  %val1.relocated1 = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %statepoint_token1, i32 0, i32 0) ; (%val1, %val1)
  %val2.relocated1 = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %statepoint_token1, i32 1, i32 1) ; (%val2, %val2)
  %safepoint_token2 = call token (i64, i32, ptr, i32, i32, ...) @llvm.experimental.gc.statepoint.p0(i64 2882400000, i32 0, ptr nonnull elementtype(void (i32)) @__llvm_deoptimize, i32 1, i32 2, i32 10, i32 0, i32 0) [ "deopt"(ptr addrspace(1) %val1.relocated1, ptr addrspace(1) %val2.relocated1), "gc-live"() ]
  unreachable

exceptional_return:                         ; preds = %entry
  %lpad_token11090 = landingpad token
          cleanup
  %val2.relocated2 = call coldcc ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token %lpad_token11090, i32 1, i32 1) ; (%val2, %val2)
  %safepoint_token3 = call token (i64, i32, ptr, i32, i32, ...) @llvm.experimental.gc.statepoint.p0(i64 2882400000, i32 0, ptr nonnull elementtype(void (i32)) @__llvm_deoptimize, i32 1, i32 0, i32 -271, i32 0, i32 0) [ "deopt"(ptr addrspace(1) %val2.relocated2), "gc-live"() ]
  unreachable
}

declare void @__llvm_deoptimize(i32)
declare token @llvm.experimental.gc.statepoint.p0(i64 immarg, i32 immarg, ptr, i32 immarg, i32 immarg, ...)
declare ptr addrspace(1) @llvm.experimental.gc.relocate.p1(token, i32, i32)
