; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -show-mc-encoding | FileCheck %s --check-prefixes=CHECK,NO-NDD
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+ndd -show-mc-encoding | FileCheck --check-prefixes=CHECK,NDD %s
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+zu -show-mc-encoding | FileCheck --check-prefixes=CHECK,ZU %s
; RUN: llc -O0 < %s -mtriple=x86_64-unknown-unknown -mattr=+zu -show-mc-encoding | FileCheck --check-prefix=O0-ZU %s

@d = dso_local global i8 0, align 1
@d64 = dso_local global i64 0

define i32 @test1(i32 %X, ptr %y) nounwind {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $0, (%rsi) # encoding: [0x83,0x3e,0x00]
; CHECK-NEXT:    je .LBB0_2 # encoding: [0x74,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB0_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %cond_true
; CHECK-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
; CHECK-NEXT:  .LBB0_2: # %ReturnBlock
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test1:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    cmpl $0, (%rsi) # encoding: [0x83,0x3e,0x00]
; O0-ZU-NEXT:    je .LBB0_2 # encoding: [0x74,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB0_2-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  # %bb.1: # %cond_true
; O0-ZU-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
; O0-ZU-NEXT:  .LBB0_2: # %ReturnBlock
; O0-ZU-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %tmp = load i32, ptr %y
  %tmp.upgrd.1 = icmp eq i32 %tmp, 0
  br i1 %tmp.upgrd.1, label %ReturnBlock, label %cond_true

cond_true:
  ret i32 1

ReturnBlock:
  ret i32 0
}

define i32 @test2(i32 %X, ptr %y) nounwind {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl $536870911, (%rsi) # encoding: [0xf7,0x06,0xff,0xff,0xff,0x1f]
; CHECK-NEXT:    # imm = 0x1FFFFFFF
; CHECK-NEXT:    je .LBB1_2 # encoding: [0x74,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB1_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %cond_true
; CHECK-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
; CHECK-NEXT:  .LBB1_2: # %ReturnBlock
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test2:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    movl (%rsi), %eax # encoding: [0x8b,0x06]
; O0-ZU-NEXT:    shll $3, %eax # encoding: [0xc1,0xe0,0x03]
; O0-ZU-NEXT:    cmpl $0, %eax # encoding: [0x83,0xf8,0x00]
; O0-ZU-NEXT:    je .LBB1_2 # encoding: [0x74,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB1_2-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  # %bb.1: # %cond_true
; O0-ZU-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
; O0-ZU-NEXT:  .LBB1_2: # %ReturnBlock
; O0-ZU-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %tmp = load i32, ptr %y
  %tmp1 = shl i32 %tmp, 3
  %tmp1.upgrd.2 = icmp eq i32 %tmp1, 0
  br i1 %tmp1.upgrd.2, label %ReturnBlock, label %cond_true

cond_true:
  ret i32 1

ReturnBlock:
  ret i32 0
}

define i8 @test2b(i8 %X, ptr %y) nounwind {
; CHECK-LABEL: test2b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testb $31, (%rsi) # encoding: [0xf6,0x06,0x1f]
; CHECK-NEXT:    je .LBB2_2 # encoding: [0x74,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB2_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %cond_true
; CHECK-NEXT:    movb $1, %al # encoding: [0xb0,0x01]
; CHECK-NEXT:    retq # encoding: [0xc3]
; CHECK-NEXT:  .LBB2_2: # %ReturnBlock
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test2b:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    movb (%rsi), %al # encoding: [0x8a,0x06]
; O0-ZU-NEXT:    shlb $3, %al # encoding: [0xc0,0xe0,0x03]
; O0-ZU-NEXT:    cmpb $0, %al # encoding: [0x3c,0x00]
; O0-ZU-NEXT:    je .LBB2_2 # encoding: [0x74,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB2_2-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  # %bb.1: # %cond_true
; O0-ZU-NEXT:    movb $1, %al # encoding: [0xb0,0x01]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
; O0-ZU-NEXT:  .LBB2_2: # %ReturnBlock
; O0-ZU-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; O0-ZU-NEXT:    # kill: def $al killed $al killed $eax
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %tmp = load i8, ptr %y
  %tmp1 = shl i8 %tmp, 3
  %tmp1.upgrd.2 = icmp eq i8 %tmp1, 0
  br i1 %tmp1.upgrd.2, label %ReturnBlock, label %cond_true

cond_true:
  ret i8 1

ReturnBlock:
  ret i8 0
}

define i64 @test3(i64 %x) nounwind {
; NO-NDD-LABEL: test3:
; NO-NDD:       # %bb.0: # %entry
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test3:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test3:
; ZU:       # %bb.0: # %entry
; ZU-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test3:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    # kill: def $rax killed $eax
; O0-ZU-NEXT:    retq # encoding: [0xc3]
; NDD-ZU-LABEL: test3:
; NDD-ZU:       # %bb.0: # %entry
; NDD-ZU-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NDD-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; NDD-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %t = icmp eq i64 %x, 0
  %r = zext i1 %t to i64
  ret i64 %r
}

define i64 @test4(i64 %x) nounwind {
; NO-NDD-LABEL: test4:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NO-NDD-NEXT:    setle %al # encoding: [0x0f,0x9e,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test4:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NDD-NEXT:    setle %al # encoding: [0x0f,0x9e,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test4:
; ZU:       # %bb.0:
; ZU-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; ZU-NEXT:    setzule %al # encoding: [0x62,0xf4,0x7f,0x18,0x4e,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test4:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    cmpq $1, %rdi # encoding: [0x48,0x83,0xff,0x01]
; O0-ZU-NEXT:    setzul %al # encoding: [0x62,0xf4,0x7f,0x18,0x4c,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    # kill: def $rax killed $eax
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %t = icmp slt i64 %x, 1
  %r = zext i1 %t to i64
  ret i64 %r
}

define i32 @test5(double %A) nounwind {
; CHECK-LABEL: test5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ucomisd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0 # encoding: [0x66,0x0f,0x2e,0x05,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    ja .LBB5_3 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB5_3-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    ucomisd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0 # encoding: [0x66,0x0f,0x2e,0x05,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    jb .LBB5_3 # encoding: [0x72,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB5_3-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %bb12
; CHECK-NEXT:    movl $32, %eax # encoding: [0xb8,0x20,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
; CHECK-NEXT:  .LBB5_3: # %bb8
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo@PLT # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo@PLT-1, kind: FK_PCRel_1
;
; O0-ZU-LABEL: test5:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    movsd {{.*#+}} xmm1 = [1.5E+2,0.0E+0]
; O0-ZU-NEXT:    # encoding: [0xf2,0x0f,0x10,0x0d,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; O0-ZU-NEXT:    ucomisd %xmm1, %xmm0 # encoding: [0x66,0x0f,0x2e,0xc1]
; O0-ZU-NEXT:    setzua %al # encoding: [0x62,0xf4,0x7f,0x18,0x47,0xc0]
; O0-ZU-NEXT:    movsd {{.*#+}} xmm1 = [7.5E+1,0.0E+0]
; O0-ZU-NEXT:    # encoding: [0xf2,0x0f,0x10,0x0d,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; O0-ZU-NEXT:    ucomisd %xmm1, %xmm0 # encoding: [0x66,0x0f,0x2e,0xc1]
; O0-ZU-NEXT:    setzub %cl # encoding: [0x62,0xf4,0x7f,0x18,0x42,0xc1]
; O0-ZU-NEXT:    orb %cl, %al # encoding: [0x08,0xc8]
; O0-ZU-NEXT:    testb $1, %al # encoding: [0xa8,0x01]
; O0-ZU-NEXT:    jne .LBB5_1 # encoding: [0x75,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB5_1-1, kind: FK_PCRel_1
; O0-ZU-NEXT:    jmp .LBB5_2 # encoding: [0xeb,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB5_2-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  .LBB5_1: # %bb8
; O0-ZU-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; O0-ZU-NEXT:    # kill: def $al killed $al killed $eax
; O0-ZU-NEXT:    jmp foo@PLT # TAILCALL
; O0-ZU-NEXT:    # encoding: [0xeb,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: foo@PLT-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  .LBB5_2: # %bb12
; O0-ZU-NEXT:    movl $32, %eax # encoding: [0xb8,0x20,0x00,0x00,0x00]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %tmp2 = fcmp ogt double %A, 1.500000e+02
  %tmp5 = fcmp ult double %A, 7.500000e+01
  %bothcond = or i1 %tmp2, %tmp5
  br i1 %bothcond, label %bb8, label %bb12

bb8:
  %tmp9 = tail call i32 (...) @foo() nounwind
  ret i32 %tmp9

bb12:
  ret i32 32
}

declare i32 @foo(...)

define i32 @test6() nounwind align 2 {
; CHECK-LABEL: test6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq $0, -{{[0-9]+}}(%rsp) # encoding: [0x48,0x83,0x7c,0x24,0xf8,0x00]
; CHECK-NEXT:    je .LBB6_1 # encoding: [0x74,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB6_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %F
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
; CHECK-NEXT:  .LBB6_1: # %T
; CHECK-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test6:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    cmpq $0, -{{[0-9]+}}(%rsp) # encoding: [0x48,0x83,0x7c,0x24,0xf8,0x00]
; O0-ZU-NEXT:    jne .LBB6_2 # encoding: [0x75,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB6_2-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  # %bb.1: # %T
; O0-ZU-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
; O0-ZU-NEXT:  .LBB6_2: # %F
; O0-ZU-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %A = alloca { i64, i64 }, align 8
  %B = getelementptr inbounds { i64, i64 }, ptr %A, i64 0, i32 1
  %C = load i64, ptr %B
  %D = icmp eq i64 %C, 0
  br i1 %D, label %T, label %F

T:
  ret i32 1

F:
  ret i32 0
}

define i32 @test7(i64 %res) nounwind {
; NO-NDD-LABEL: test7:
; NO-NDD:       # %bb.0: # %entry
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    shrq $32, %rdi # encoding: [0x48,0xc1,0xef,0x20]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test7:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shrq $32, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x20]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test7:
; ZU:       # %bb.0: # %entry
; ZU-NEXT:    shrq $32, %rdi # encoding: [0x48,0xc1,0xef,0x20]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test7:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    movabsq $4294967296, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00]
; O0-ZU-NEXT:    # imm = 0x100000000
; O0-ZU-NEXT:    cmpq %rax, %rdi # encoding: [0x48,0x39,0xc7]
; O0-ZU-NEXT:    setzub %al # encoding: [0x62,0xf4,0x7f,0x18,0x42,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %lnot = icmp ult i64 %res, 4294967296
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test8(i64 %res) nounwind {
; NO-NDD-LABEL: test8:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    shrq $32, %rdi # encoding: [0x48,0xc1,0xef,0x20]
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    cmpl $3, %edi # encoding: [0x83,0xff,0x03]
; NO-NDD-NEXT:    setb %al # encoding: [0x0f,0x92,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test8:
; NDD:       # %bb.0:
; NDD-NEXT:    shrq $32, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x20]
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    cmpl $3, %edi # encoding: [0x83,0xff,0x03]
; NDD-NEXT:    setb %al # encoding: [0x0f,0x92,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test8:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $32, %rdi # encoding: [0x48,0xc1,0xef,0x20]
; ZU-NEXT:    cmpl $3, %edi # encoding: [0x83,0xff,0x03]
; ZU-NEXT:    setzub %al # encoding: [0x62,0xf4,0x7f,0x18,0x42,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test8:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $12884901888, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00]
; O0-ZU-NEXT:    # imm = 0x300000000
; O0-ZU-NEXT:    cmpq %rax, %rdi # encoding: [0x48,0x39,0xc7]
; O0-ZU-NEXT:    setzub %al # encoding: [0x62,0xf4,0x7f,0x18,0x42,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %lnot = icmp ult i64 %res, 12884901888
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test9(i64 %res) nounwind {
; NO-NDD-LABEL: test9:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    shrq $33, %rdi # encoding: [0x48,0xc1,0xef,0x21]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test9:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shrq $33, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x21]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test9:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $33, %rdi # encoding: [0x48,0xc1,0xef,0x21]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test9:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $8589934592, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00]
; O0-ZU-NEXT:    # imm = 0x200000000
; O0-ZU-NEXT:    cmpq %rax, %rdi # encoding: [0x48,0x39,0xc7]
; O0-ZU-NEXT:    setzub %al # encoding: [0x62,0xf4,0x7f,0x18,0x42,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %lnot = icmp ult i64 %res, 8589934592
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test10(i64 %res) nounwind {
; NO-NDD-LABEL: test10:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    shrq $32, %rdi # encoding: [0x48,0xc1,0xef,0x20]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test10:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shrq $32, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x20]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test10:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $32, %rdi # encoding: [0x48,0xc1,0xef,0x20]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test10:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $4294967296, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00]
; O0-ZU-NEXT:    # imm = 0x100000000
; O0-ZU-NEXT:    cmpq %rax, %rdi # encoding: [0x48,0x39,0xc7]
; O0-ZU-NEXT:    setzuae %al # encoding: [0x62,0xf4,0x7f,0x18,0x43,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %lnot = icmp uge i64 %res, 4294967296
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test11(i64 %l) nounwind {
; NO-NDD-LABEL: test11:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    shrq $47, %rdi # encoding: [0x48,0xc1,0xef,0x2f]
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    cmpl $1, %edi # encoding: [0x83,0xff,0x01]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test11:
; NDD:       # %bb.0:
; NDD-NEXT:    shrq $47, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x2f]
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    cmpl $1, %edi # encoding: [0x83,0xff,0x01]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test11:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $47, %rdi # encoding: [0x48,0xc1,0xef,0x2f]
; ZU-NEXT:    cmpl $1, %edi # encoding: [0x83,0xff,0x01]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test11:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $-140737488355328, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x00,0x80,0xff,0xff]
; O0-ZU-NEXT:    # imm = 0xFFFF800000000000
; O0-ZU-NEXT:    andq %rax, %rdi # encoding: [0x48,0x21,0xc7]
; O0-ZU-NEXT:    movabsq $140737488355328, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00]
; O0-ZU-NEXT:    # imm = 0x800000000000
; O0-ZU-NEXT:    cmpq %rax, %rdi # encoding: [0x48,0x39,0xc7]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %shr.mask = and i64 %l, -140737488355328
  %cmp = icmp eq i64 %shr.mask, 140737488355328
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @test12() ssp uwtable {
; CHECK-LABEL: test12:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax # encoding: [0x50]
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    callq test12b@PLT # encoding: [0xe8,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: test12b@PLT-4, kind: FK_PCRel_4
; CHECK-NEXT:    testb %al, %al # encoding: [0x84,0xc0]
; CHECK-NEXT:    je .LBB12_2 # encoding: [0x74,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB12_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %T
; CHECK-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; CHECK-NEXT:    popq %rcx # encoding: [0x59]
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq # encoding: [0xc3]
; CHECK-NEXT:  .LBB12_2: # %F
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movl $2, %eax # encoding: [0xb8,0x02,0x00,0x00,0x00]
; CHECK-NEXT:    popq %rcx # encoding: [0x59]
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test12:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    pushq %rax # encoding: [0x50]
; O0-ZU-NEXT:    .cfi_def_cfa_offset 16
; O0-ZU-NEXT:    callq test12b@PLT # encoding: [0xe8,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: test12b@PLT-4, kind: FK_PCRel_4
; O0-ZU-NEXT:    testb $1, %al # encoding: [0xa8,0x01]
; O0-ZU-NEXT:    jne .LBB12_1 # encoding: [0x75,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB12_1-1, kind: FK_PCRel_1
; O0-ZU-NEXT:    jmp .LBB12_2 # encoding: [0xeb,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB12_2-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  .LBB12_1: # %T
; O0-ZU-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; O0-ZU-NEXT:    popq %rcx # encoding: [0x59]
; O0-ZU-NEXT:    .cfi_def_cfa_offset 8
; O0-ZU-NEXT:    retq # encoding: [0xc3]
; O0-ZU-NEXT:  .LBB12_2: # %F
; O0-ZU-NEXT:    .cfi_def_cfa_offset 16
; O0-ZU-NEXT:    movl $2, %eax # encoding: [0xb8,0x02,0x00,0x00,0x00]
; O0-ZU-NEXT:    popq %rcx # encoding: [0x59]
; O0-ZU-NEXT:    .cfi_def_cfa_offset 8
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %tmp1 = call zeroext i1 @test12b()
  br i1 %tmp1, label %T, label %F

T:
  ret i32 1

F:
  ret i32 2
}

declare zeroext i1 @test12b()

define i32 @test13(i32 %mask, i32 %base, i32 %intra) {
; NO-NDD-LABEL: test13:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    movl %esi, %eax # encoding: [0x89,0xf0]
; NO-NDD-NEXT:    testb $8, %dil # encoding: [0x40,0xf6,0xc7,0x08]
; NO-NDD-NEXT:    cmovnel %edx, %eax # encoding: [0x0f,0x45,0xc2]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test13:
; NDD:       # %bb.0:
; NDD-NEXT:    testb $8, %dil # encoding: [0x40,0xf6,0xc7,0x08]
; NDD-NEXT:    cmovnel %edx, %esi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x45,0xf2]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test13:
; ZU:       # %bb.0:
; ZU-NEXT:    movl %esi, %eax # encoding: [0x89,0xf0]
; ZU-NEXT:    testb $8, %dil # encoding: [0x40,0xf6,0xc7,0x08]
; ZU-NEXT:    cmovnel %edx, %eax # encoding: [0x0f,0x45,0xc2]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test13:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movl %esi, %eax # encoding: [0x89,0xf0]
; O0-ZU-NEXT:    andl $8, %edi # encoding: [0x83,0xe7,0x08]
; O0-ZU-NEXT:    cmpl $0, %edi # encoding: [0x83,0xff,0x00]
; O0-ZU-NEXT:    cmovnel %edx, %eax # encoding: [0x0f,0x45,0xc2]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i32 %mask, 8
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 %intra, i32 %base
  ret i32 %cond
}

define i32 @test14(i32 %mask, i32 %base, i32 %intra) {
; NO-NDD-LABEL: test14:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    movl %esi, %eax # encoding: [0x89,0xf0]
; NO-NDD-NEXT:    shrl $7, %edi # encoding: [0xc1,0xef,0x07]
; NO-NDD-NEXT:    cmovnsl %edx, %eax # encoding: [0x0f,0x49,0xc2]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test14:
; NDD:       # %bb.0:
; NDD-NEXT:    shrl $7, %edi # EVEX TO LEGACY Compression encoding: [0xc1,0xef,0x07]
; NDD-NEXT:    cmovnsl %edx, %esi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x49,0xf2]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test14:
; ZU:       # %bb.0:
; ZU-NEXT:    movl %esi, %eax # encoding: [0x89,0xf0]
; ZU-NEXT:    shrl $7, %edi # encoding: [0xc1,0xef,0x07]
; ZU-NEXT:    cmovnsl %edx, %eax # encoding: [0x0f,0x49,0xc2]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test14:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movl %esi, %eax # encoding: [0x89,0xf0]
; O0-ZU-NEXT:    shrl $7, %edi # encoding: [0xc1,0xef,0x07]
; O0-ZU-NEXT:    cmpl $-1, %edi # encoding: [0x83,0xff,0xff]
; O0-ZU-NEXT:    cmovgl %edx, %eax # encoding: [0x0f,0x4f,0xc2]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %s = lshr i32 %mask, 7
  %tobool = icmp sgt i32 %s, -1
  %cond = select i1 %tobool, i32 %intra, i32 %base
  ret i32 %cond
}

; PR19964
define zeroext i1 @test15(i32 %bf.load, i32 %n) {
; NO-NDD-LABEL: test15:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    shrl $16, %edi # encoding: [0xc1,0xef,0x10]
; NO-NDD-NEXT:    sete %cl # encoding: [0x0f,0x94,0xc1]
; NO-NDD-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; NO-NDD-NEXT:    setae %al # encoding: [0x0f,0x93,0xc0]
; NO-NDD-NEXT:    orb %cl, %al # encoding: [0x08,0xc8]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test15:
; NDD:       # %bb.0:
; NDD-NEXT:    shrl $16, %edi # EVEX TO LEGACY Compression encoding: [0xc1,0xef,0x10]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; NDD-NEXT:    setae %cl # encoding: [0x0f,0x93,0xc1]
; NDD-NEXT:    orb %cl, %al # EVEX TO LEGACY Compression encoding: [0x08,0xc8]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test15:
; ZU:       # %bb.0:
; ZU-NEXT:    shrl $16, %edi # encoding: [0xc1,0xef,0x10]
; ZU-NEXT:    setzue %cl # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc1]
; ZU-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; ZU-NEXT:    setzuae %al # encoding: [0x62,0xf4,0x7f,0x18,0x43,0xc0]
; ZU-NEXT:    orb %cl, %al # encoding: [0x08,0xc8]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test15:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    shrl $16, %edi # encoding: [0xc1,0xef,0x10]
; O0-ZU-NEXT:    cmpl $0, %edi # encoding: [0x83,0xff,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; O0-ZU-NEXT:    setzuae %cl # encoding: [0x62,0xf4,0x7f,0x18,0x43,0xc1]
; O0-ZU-NEXT:    orb %cl, %al # encoding: [0x08,0xc8]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %bf.lshr = lshr i32 %bf.load, 16
  %cmp2 = icmp eq i32 %bf.lshr, 0
  %cmp5 = icmp uge i32 %bf.lshr, %n
  %.cmp5 = or i1 %cmp2, %cmp5
  ret i1 %.cmp5
}

define i8 @signbit_i16(i16 signext %L) {
; NO-NDD-LABEL: signbit_i16:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; NO-NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: signbit_i16:
; NDD:       # %bb.0:
; NDD-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: signbit_i16:
; ZU:       # %bb.0:
; ZU-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; ZU-NEXT:    setzuns %al # encoding: [0x62,0xf4,0x7f,0x18,0x49,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: signbit_i16:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movw %di, %ax # encoding: [0x66,0x89,0xf8]
; O0-ZU-NEXT:    shrw $15, %ax # encoding: [0x66,0xc1,0xe8,0x0f]
; O0-ZU-NEXT:    # kill: def $al killed $al killed $ax
; O0-ZU-NEXT:    xorb $1, %al # encoding: [0x34,0x01]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %lshr = lshr i16 %L, 15
  %trunc = trunc i16 %lshr to i8
  %not = xor i8 %trunc, 1
  ret i8 %not
}

define i8 @signbit_i32(i32 %L) {
; NO-NDD-LABEL: signbit_i32:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NO-NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: signbit_i32:
; NDD:       # %bb.0:
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: signbit_i32:
; ZU:       # %bb.0:
; ZU-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; ZU-NEXT:    setzuns %al # encoding: [0x62,0xf4,0x7f,0x18,0x49,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: signbit_i32:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    shrl $31, %edi # encoding: [0xc1,0xef,0x1f]
; O0-ZU-NEXT:    movb %dil, %al # encoding: [0x40,0x88,0xf8]
; O0-ZU-NEXT:    xorb $1, %al # encoding: [0x34,0x01]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %lshr = lshr i32 %L, 31
  %trunc = trunc i32 %lshr to i8
  %not = xor i8 %trunc, 1
  ret i8 %not
}

define i8 @signbit_i64(i64 %L) {
; NO-NDD-LABEL: signbit_i64:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NO-NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: signbit_i64:
; NDD:       # %bb.0:
; NDD-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: signbit_i64:
; ZU:       # %bb.0:
; ZU-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; ZU-NEXT:    setzuns %al # encoding: [0x62,0xf4,0x7f,0x18,0x49,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: signbit_i64:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    shrq $63, %rdi # encoding: [0x48,0xc1,0xef,0x3f]
; O0-ZU-NEXT:    movb %dil, %al # encoding: [0x40,0x88,0xf8]
; O0-ZU-NEXT:    xorb $1, %al # encoding: [0x34,0x01]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %lshr = lshr i64 %L, 63
  %trunc = trunc i64 %lshr to i8
  %not = xor i8 %trunc, 1
  ret i8 %not
}

define zeroext i1 @signbit_i32_i1(i32 %L) {
; NO-NDD-LABEL: signbit_i32_i1:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NO-NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: signbit_i32_i1:
; NDD:       # %bb.0:
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: signbit_i32_i1:
; ZU:       # %bb.0:
; ZU-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; ZU-NEXT:    setzuns %al # encoding: [0x62,0xf4,0x7f,0x18,0x49,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: signbit_i32_i1:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    shrl $31, %edi # encoding: [0xc1,0xef,0x1f]
; O0-ZU-NEXT:    movb %dil, %al # encoding: [0x40,0x88,0xf8]
; O0-ZU-NEXT:    xorb $-1, %al # encoding: [0x34,0xff]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %lshr = lshr i32 %L, 31
  %trunc = trunc i32 %lshr to i1
  %not = xor i1 %trunc, true
  ret i1 %not
}

; This test failed due to incorrect handling of "shift + icmp" sequence
define void @test20(i32 %bf.load, i8 %x1, ptr %b_addr) {
; NO-NDD-LABEL: test20:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testl $16777215, %edi # encoding: [0xf7,0xc7,0xff,0xff,0xff,0x00]
; NO-NDD-NEXT:    # imm = 0xFFFFFF
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    movzbl %sil, %ecx # encoding: [0x40,0x0f,0xb6,0xce]
; NO-NDD-NEXT:    addl %eax, %ecx # encoding: [0x01,0xc1]
; NO-NDD-NEXT:    setne (%rdx) # encoding: [0x0f,0x95,0x02]
; NO-NDD-NEXT:    testl $16777215, %edi # encoding: [0xf7,0xc7,0xff,0xff,0xff,0x00]
; NO-NDD-NEXT:    # imm = 0xFFFFFF
; NO-NDD-NEXT:    setne d(%rip) # encoding: [0x0f,0x95,0x05,A,A,A,A]
; NO-NDD-NEXT:    # fixup A - offset: 3, value: d-4, kind: reloc_riprel_4byte
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: test20:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testl $16777215, %edi # encoding: [0xf7,0xc7,0xff,0xff,0xff,0x00]
; NDD-NEXT:    # imm = 0xFFFFFF
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    movzbl %sil, %ecx # encoding: [0x40,0x0f,0xb6,0xce]
; NDD-NEXT:    addl %ecx, %eax # EVEX TO LEGACY Compression encoding: [0x01,0xc8]
; NDD-NEXT:    setne (%rdx) # encoding: [0x0f,0x95,0x02]
; NDD-NEXT:    testl $16777215, %edi # encoding: [0xf7,0xc7,0xff,0xff,0xff,0x00]
; NDD-NEXT:    # imm = 0xFFFFFF
; NDD-NEXT:    setne d(%rip) # encoding: [0x0f,0x95,0x05,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: d-4, kind: reloc_riprel_4byte
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: test20:
; ZU:       # %bb.0:
; ZU-NEXT:    testl $16777215, %edi # encoding: [0xf7,0xc7,0xff,0xff,0xff,0x00]
; ZU-NEXT:    # imm = 0xFFFFFF
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    movzbl %sil, %ecx # encoding: [0x40,0x0f,0xb6,0xce]
; ZU-NEXT:    addl %eax, %ecx # encoding: [0x01,0xc1]
; ZU-NEXT:    setne (%rdx) # encoding: [0x0f,0x95,0x02]
; ZU-NEXT:    testl $16777215, %edi # encoding: [0xf7,0xc7,0xff,0xff,0xff,0x00]
; ZU-NEXT:    # imm = 0xFFFFFF
; ZU-NEXT:    setne d(%rip) # encoding: [0x0f,0x95,0x05,A,A,A,A]
; ZU-NEXT:    # fixup A - offset: 3, value: d-4, kind: reloc_riprel_4byte
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: test20:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movb %sil, %cl # encoding: [0x40,0x88,0xf1]
; O0-ZU-NEXT:    shll $8, %edi # encoding: [0xc1,0xe7,0x08]
; O0-ZU-NEXT:    movl %edi, %eax # encoding: [0x89,0xf8]
; O0-ZU-NEXT:    sarl $8, %eax # encoding: [0xc1,0xf8,0x08]
; O0-ZU-NEXT:    cmpl $0, %eax # encoding: [0x83,0xf8,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    movzbl %cl, %ecx # encoding: [0x0f,0xb6,0xc9]
; O0-ZU-NEXT:    addl %ecx, %eax # encoding: [0x01,0xc8]
; O0-ZU-NEXT:    cmpl $0, %eax # encoding: [0x83,0xf8,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movb %al, (%rdx) # encoding: [0x88,0x02]
; O0-ZU-NEXT:    cmpl $0, %edi # encoding: [0x83,0xff,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movb %al, d # encoding: [0x88,0x04,0x25,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 3, value: d, kind: reloc_signed_4byte
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %bf.shl = shl i32 %bf.load, 8
  %bf.ashr = ashr exact i32 %bf.shl, 8
  %tobool4 = icmp ne i32 %bf.ashr, 0
  %conv = zext i1 %tobool4 to i32
  %conv6 = zext i8 %x1 to i32
  %add = add nuw nsw i32 %conv, %conv6
  %tobool7 = icmp ne i32 %add, 0
  %frombool = zext i1 %tobool7 to i8
  store i8 %frombool, ptr %b_addr, align 1
  %tobool14 = icmp ne i32 %bf.shl, 0
  %frombool15 = zext i1 %tobool14 to i8
  store i8 %frombool15, ptr @d, align 1
  ret void
}

define i32 @highmask_i64_simplify(i64 %val) {
; CHECK-LABEL: highmask_i64_simplify:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i64_simplify:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $-2199023255552, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x00,0xfe,0xff,0xff]
; O0-ZU-NEXT:    # imm = 0xFFFFFE0000000000
; O0-ZU-NEXT:    andq %rax, %rdi # encoding: [0x48,0x21,0xc7]
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzub %al # encoding: [0x62,0xf4,0x7f,0x18,0x42,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -2199023255552
  %cmp = icmp ult i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i32 @highmask_i64_mask64(i64 %val) {
; NO-NDD-LABEL: highmask_i64_mask64:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    shrq $41, %rdi # encoding: [0x48,0xc1,0xef,0x29]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: highmask_i64_mask64:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shrq $41, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x29]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: highmask_i64_mask64:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $41, %rdi # encoding: [0x48,0xc1,0xef,0x29]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i64_mask64:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $-2199023255552, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x00,0xfe,0xff,0xff]
; O0-ZU-NEXT:    # imm = 0xFFFFFE0000000000
; O0-ZU-NEXT:    andq %rax, %rdi # encoding: [0x48,0x21,0xc7]
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -2199023255552
  %cmp = icmp ne i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i64 @highmask_i64_mask64_extra_use(i64 %val) nounwind {
; NO-NDD-LABEL: highmask_i64_mask64_extra_use:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    movq %rdi, %rcx # encoding: [0x48,0x89,0xf9]
; NO-NDD-NEXT:    shrq $41, %rcx # encoding: [0x48,0xc1,0xe9,0x29]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: highmask_i64_mask64_extra_use:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shrq $41, %rdi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0xc1,0xef,0x29]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    imulq %rdi, %rax # EVEX TO LEGACY Compression encoding: [0x48,0x0f,0xaf,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: highmask_i64_mask64_extra_use:
; ZU:       # %bb.0:
; ZU-NEXT:    movq %rdi, %rax # encoding: [0x48,0x89,0xf8]
; ZU-NEXT:    shrq $41, %rax # encoding: [0x48,0xc1,0xe8,0x29]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i64_mask64_extra_use:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $-2199023255552, %rcx # encoding: [0x48,0xb9,0x00,0x00,0x00,0x00,0x00,0xfe,0xff,0xff]
; O0-ZU-NEXT:    # imm = 0xFFFFFE0000000000
; O0-ZU-NEXT:    movq %rdi, %rax # encoding: [0x48,0x89,0xf8]
; O0-ZU-NEXT:    andq %rcx, %rax # encoding: [0x48,0x21,0xc8]
; O0-ZU-NEXT:    cmpq $0, %rax # encoding: [0x48,0x83,0xf8,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    # kill: def $rax killed $eax
; O0-ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -2199023255552
  %cmp = icmp ne i64 %and, 0
  %z = zext i1 %cmp to i64
  %ret = mul i64 %z, %val
  ret i64 %ret
}

define i32 @highmask_i64_mask32(i64 %val) {
; NO-NDD-LABEL: highmask_i64_mask32:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    shrq $20, %rdi # encoding: [0x48,0xc1,0xef,0x14]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: highmask_i64_mask32:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shrq $20, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x14]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: highmask_i64_mask32:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $20, %rdi # encoding: [0x48,0xc1,0xef,0x14]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i64_mask32:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andq $-1048576, %rdi # encoding: [0x48,0x81,0xe7,0x00,0x00,0xf0,0xff]
; O0-ZU-NEXT:    # imm = 0xFFF00000
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -1048576
  %cmp = icmp eq i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i64 @highmask_i64_mask32_extra_use(i64 %val) nounwind {
; NO-NDD-LABEL: highmask_i64_mask32_extra_use:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testq $-1048576, %rdi # encoding: [0x48,0xf7,0xc7,0x00,0x00,0xf0,0xff]
; NO-NDD-NEXT:    # imm = 0xFFF00000
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: highmask_i64_mask32_extra_use:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testq $-1048576, %rdi # encoding: [0x48,0xf7,0xc7,0x00,0x00,0xf0,0xff]
; NDD-NEXT:    # imm = 0xFFF00000
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    imulq %rdi, %rax # EVEX TO LEGACY Compression encoding: [0x48,0x0f,0xaf,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: highmask_i64_mask32_extra_use:
; ZU:       # %bb.0:
; ZU-NEXT:    testq $-1048576, %rdi # encoding: [0x48,0xf7,0xc7,0x00,0x00,0xf0,0xff]
; ZU-NEXT:    # imm = 0xFFF00000
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i64_mask32_extra_use:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movq %rdi, %rax # encoding: [0x48,0x89,0xf8]
; O0-ZU-NEXT:    andq $-1048576, %rax # encoding: [0x48,0x25,0x00,0x00,0xf0,0xff]
; O0-ZU-NEXT:    # imm = 0xFFF00000
; O0-ZU-NEXT:    cmpq $0, %rax # encoding: [0x48,0x83,0xf8,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    # kill: def $rax killed $eax
; O0-ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -1048576
  %cmp = icmp eq i64 %and, 0
  %z = zext i1 %cmp to i64
  %ret = mul i64 %z, %val
  ret i64 %ret
}

define i32 @highmask_i64_mask8(i64 %val) {
; NO-NDD-LABEL: highmask_i64_mask8:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testq $-16, %rdi # encoding: [0x48,0xf7,0xc7,0xf0,0xff,0xff,0xff]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: highmask_i64_mask8:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testq $-16, %rdi # encoding: [0x48,0xf7,0xc7,0xf0,0xff,0xff,0xff]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: highmask_i64_mask8:
; ZU:       # %bb.0:
; ZU-NEXT:    testq $-16, %rdi # encoding: [0x48,0xf7,0xc7,0xf0,0xff,0xff,0xff]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i64_mask8:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andq $-16, %rdi # encoding: [0x48,0x83,0xe7,0xf0]
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -16
  %cmp = icmp ne i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i32 @lowmask_i64_mask64(i64 %val) {
; NO-NDD-LABEL: lowmask_i64_mask64:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    shlq $16, %rdi # encoding: [0x48,0xc1,0xe7,0x10]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: lowmask_i64_mask64:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shlq $16, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xe7,0x10]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: lowmask_i64_mask64:
; ZU:       # %bb.0:
; ZU-NEXT:    shlq $16, %rdi # encoding: [0x48,0xc1,0xe7,0x10]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: lowmask_i64_mask64:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $281474976710655, %rax # encoding: [0x48,0xb8,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00]
; O0-ZU-NEXT:    # imm = 0xFFFFFFFFFFFF
; O0-ZU-NEXT:    andq %rax, %rdi # encoding: [0x48,0x21,0xc7]
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 281474976710655
  %cmp = icmp eq i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i64 @lowmask_i64_mask64_extra_use(i64 %val) nounwind {
; NO-NDD-LABEL: lowmask_i64_mask64_extra_use:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    movq %rdi, %rcx # encoding: [0x48,0x89,0xf9]
; NO-NDD-NEXT:    shlq $16, %rcx # encoding: [0x48,0xc1,0xe1,0x10]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: lowmask_i64_mask64_extra_use:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shlq $16, %rdi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0xc1,0xe7,0x10]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    imulq %rdi, %rax # EVEX TO LEGACY Compression encoding: [0x48,0x0f,0xaf,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: lowmask_i64_mask64_extra_use:
; ZU:       # %bb.0:
; ZU-NEXT:    movq %rdi, %rax # encoding: [0x48,0x89,0xf8]
; ZU-NEXT:    shlq $16, %rax # encoding: [0x48,0xc1,0xe0,0x10]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: lowmask_i64_mask64_extra_use:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $281474976710655, %rcx # encoding: [0x48,0xb9,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00]
; O0-ZU-NEXT:    # imm = 0xFFFFFFFFFFFF
; O0-ZU-NEXT:    movq %rdi, %rax # encoding: [0x48,0x89,0xf8]
; O0-ZU-NEXT:    andq %rcx, %rax # encoding: [0x48,0x21,0xc8]
; O0-ZU-NEXT:    cmpq $0, %rax # encoding: [0x48,0x83,0xf8,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    # kill: def $rax killed $eax
; O0-ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 281474976710655
  %cmp = icmp eq i64 %and, 0
  %z = zext i1 %cmp to i64
  %ret = mul i64 %z, %val
  ret i64 %ret
}

define i32 @lowmask_i64_mask32(i64 %val) {
; NO-NDD-LABEL: lowmask_i64_mask32:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    shlq $44, %rdi # encoding: [0x48,0xc1,0xe7,0x2c]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: lowmask_i64_mask32:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    shlq $44, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xe7,0x2c]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: lowmask_i64_mask32:
; ZU:       # %bb.0:
; ZU-NEXT:    shlq $44, %rdi # encoding: [0x48,0xc1,0xe7,0x2c]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: lowmask_i64_mask32:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andq $1048575, %rdi # encoding: [0x48,0x81,0xe7,0xff,0xff,0x0f,0x00]
; O0-ZU-NEXT:    # imm = 0xFFFFF
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 1048575
  %cmp = icmp ne i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i64 @lowmask_i64_mask32_extra_use(i64 %val) nounwind {
; NO-NDD-LABEL: lowmask_i64_mask32_extra_use:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testl $1048575, %edi # encoding: [0xf7,0xc7,0xff,0xff,0x0f,0x00]
; NO-NDD-NEXT:    # imm = 0xFFFFF
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: lowmask_i64_mask32_extra_use:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testl $1048575, %edi # encoding: [0xf7,0xc7,0xff,0xff,0x0f,0x00]
; NDD-NEXT:    # imm = 0xFFFFF
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    imulq %rdi, %rax # EVEX TO LEGACY Compression encoding: [0x48,0x0f,0xaf,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: lowmask_i64_mask32_extra_use:
; ZU:       # %bb.0:
; ZU-NEXT:    testl $1048575, %edi # encoding: [0xf7,0xc7,0xff,0xff,0x0f,0x00]
; ZU-NEXT:    # imm = 0xFFFFF
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: lowmask_i64_mask32_extra_use:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movq %rdi, %rax # encoding: [0x48,0x89,0xf8]
; O0-ZU-NEXT:    andq $1048575, %rax # encoding: [0x48,0x25,0xff,0xff,0x0f,0x00]
; O0-ZU-NEXT:    # imm = 0xFFFFF
; O0-ZU-NEXT:    cmpq $0, %rax # encoding: [0x48,0x83,0xf8,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    # kill: def $rax killed $eax
; O0-ZU-NEXT:    imulq %rdi, %rax # encoding: [0x48,0x0f,0xaf,0xc7]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 1048575
  %cmp = icmp ne i64 %and, 0
  %z = zext i1 %cmp to i64
  %ret = mul i64 %z, %val
  ret i64 %ret
}

define i32 @lowmask_i64_mask8(i64 %val) {
; NO-NDD-LABEL: lowmask_i64_mask8:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testb $31, %dil # encoding: [0x40,0xf6,0xc7,0x1f]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: lowmask_i64_mask8:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testb $31, %dil # encoding: [0x40,0xf6,0xc7,0x1f]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: lowmask_i64_mask8:
; ZU:       # %bb.0:
; ZU-NEXT:    testb $31, %dil # encoding: [0x40,0xf6,0xc7,0x1f]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: lowmask_i64_mask8:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andq $31, %rdi # encoding: [0x48,0x83,0xe7,0x1f]
; O0-ZU-NEXT:    cmpq $0, %rdi # encoding: [0x48,0x83,0xff,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 31
  %cmp = icmp eq i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i32 @highmask_i32_mask32(i32 %val) {
; NO-NDD-LABEL: highmask_i32_mask32:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testl $-1048576, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xf0,0xff]
; NO-NDD-NEXT:    # imm = 0xFFF00000
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: highmask_i32_mask32:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testl $-1048576, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xf0,0xff]
; NDD-NEXT:    # imm = 0xFFF00000
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: highmask_i32_mask32:
; ZU:       # %bb.0:
; ZU-NEXT:    testl $-1048576, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xf0,0xff]
; ZU-NEXT:    # imm = 0xFFF00000
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i32_mask32:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andl $-1048576, %edi # encoding: [0x81,0xe7,0x00,0x00,0xf0,0xff]
; O0-ZU-NEXT:    # imm = 0xFFF00000
; O0-ZU-NEXT:    cmpl $0, %edi # encoding: [0x83,0xff,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i32 %val, -1048576
  %cmp = icmp ne i32 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i32 @highmask_i32_mask8(i32 %val) {
; NO-NDD-LABEL: highmask_i32_mask8:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testl $-16, %edi # encoding: [0xf7,0xc7,0xf0,0xff,0xff,0xff]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: highmask_i32_mask8:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testl $-16, %edi # encoding: [0xf7,0xc7,0xf0,0xff,0xff,0xff]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: highmask_i32_mask8:
; ZU:       # %bb.0:
; ZU-NEXT:    testl $-16, %edi # encoding: [0xf7,0xc7,0xf0,0xff,0xff,0xff]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: highmask_i32_mask8:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andl $-16, %edi # encoding: [0x83,0xe7,0xf0]
; O0-ZU-NEXT:    cmpl $0, %edi # encoding: [0x83,0xff,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i32 %val, -16
  %cmp = icmp eq i32 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i32 @lowmask_i32_mask32(i32 %val) {
; NO-NDD-LABEL: lowmask_i32_mask32:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testl $1048575, %edi # encoding: [0xf7,0xc7,0xff,0xff,0x0f,0x00]
; NO-NDD-NEXT:    # imm = 0xFFFFF
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: lowmask_i32_mask32:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testl $1048575, %edi # encoding: [0xf7,0xc7,0xff,0xff,0x0f,0x00]
; NDD-NEXT:    # imm = 0xFFFFF
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: lowmask_i32_mask32:
; ZU:       # %bb.0:
; ZU-NEXT:    testl $1048575, %edi # encoding: [0xf7,0xc7,0xff,0xff,0x0f,0x00]
; ZU-NEXT:    # imm = 0xFFFFF
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: lowmask_i32_mask32:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andl $1048575, %edi # encoding: [0x81,0xe7,0xff,0xff,0x0f,0x00]
; O0-ZU-NEXT:    # imm = 0xFFFFF
; O0-ZU-NEXT:    cmpl $0, %edi # encoding: [0x83,0xff,0x00]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i32 %val, 1048575
  %cmp = icmp eq i32 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i32 @lowmask_i32_mask8(i32 %val) {
; NO-NDD-LABEL: lowmask_i32_mask8:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testb $31, %dil # encoding: [0x40,0xf6,0xc7,0x1f]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: lowmask_i32_mask8:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testb $31, %dil # encoding: [0x40,0xf6,0xc7,0x1f]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: lowmask_i32_mask8:
; ZU:       # %bb.0:
; ZU-NEXT:    testb $31, %dil # encoding: [0x40,0xf6,0xc7,0x1f]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: lowmask_i32_mask8:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andl $31, %edi # encoding: [0x83,0xe7,0x1f]
; O0-ZU-NEXT:    cmpl $0, %edi # encoding: [0x83,0xff,0x00]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    andb $1, %al # encoding: [0x24,0x01]
; O0-ZU-NEXT:    movzbl %al, %eax # encoding: [0x0f,0xb6,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %and = and i32 %val, 31
  %cmp = icmp ne i32 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i1 @shifted_mask64_testb(i64 %a) {
; NO-NDD-LABEL: shifted_mask64_testb:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    shrq $50, %rdi # encoding: [0x48,0xc1,0xef,0x32]
; NO-NDD-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask64_testb:
; NDD:       # %bb.0:
; NDD-NEXT:    shrq $50, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x32]
; NDD-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask64_testb:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $50, %rdi # encoding: [0x48,0xc1,0xef,0x32]
; ZU-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask64_testb:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    shrq $50, %rdi # encoding: [0x48,0xc1,0xef,0x32]
; O0-ZU-NEXT:    movb %dil, %al # encoding: [0x40,0x88,0xf8]
; O0-ZU-NEXT:    testb %al, %al # encoding: [0x84,0xc0]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 287104476244869120  ; 0xff << 50
  %v1 = icmp ne i64 %v0, 0
  ret i1 %v1
}

define i1 @shifted_mask64_testw(i64 %a) {
; NO-NDD-LABEL: shifted_mask64_testw:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    shrq $33, %rdi # encoding: [0x48,0xc1,0xef,0x21]
; NO-NDD-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask64_testw:
; NDD:       # %bb.0:
; NDD-NEXT:    shrq $33, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x21]
; NDD-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask64_testw:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $33, %rdi # encoding: [0x48,0xc1,0xef,0x21]
; ZU-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask64_testw:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    shrq $33, %rdi # encoding: [0x48,0xc1,0xef,0x21]
; O0-ZU-NEXT:    movw %di, %ax # encoding: [0x66,0x89,0xf8]
; O0-ZU-NEXT:    testw %ax, %ax # encoding: [0x66,0x85,0xc0]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 562941363486720  ; 0xffff << 33
  %v1 = icmp ne i64 %v0, 0
  ret i1 %v1
}

define i1 @shifted_mask64_testl(i64 %a) {
; NO-NDD-LABEL: shifted_mask64_testl:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    shrq $7, %rdi # encoding: [0x48,0xc1,0xef,0x07]
; NO-NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask64_testl:
; NDD:       # %bb.0:
; NDD-NEXT:    shrq $7, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0xc1,0xef,0x07]
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask64_testl:
; ZU:       # %bb.0:
; ZU-NEXT:    shrq $7, %rdi # encoding: [0x48,0xc1,0xef,0x07]
; ZU-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask64_testl:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    shrq $7, %rdi # encoding: [0x48,0xc1,0xef,0x07]
; O0-ZU-NEXT:    movl %edi, %eax # encoding: [0x89,0xf8]
; O0-ZU-NEXT:    testl %eax, %eax # encoding: [0x85,0xc0]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 549755813760  ; 0xffffffff << 7
  %v1 = icmp eq i64 %v0, 0
  ret i1 %v1
}

define i1 @shifted_mask64_extra_use_const(i64 %a) {
; NO-NDD-LABEL: shifted_mask64_extra_use_const:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    movabsq $287104476244869120, %rcx # encoding: [0x48,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; NO-NDD-NEXT:    # imm = 0x3FC000000000000
; NO-NDD-NEXT:    testq %rcx, %rdi # encoding: [0x48,0x85,0xcf]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    movq %rcx, d64(%rip) # encoding: [0x48,0x89,0x0d,A,A,A,A]
; NO-NDD-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask64_extra_use_const:
; NDD:       # %bb.0:
; NDD-NEXT:    movabsq $287104476244869120, %rcx # encoding: [0x48,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; NDD-NEXT:    # imm = 0x3FC000000000000
; NDD-NEXT:    testq %rcx, %rdi # encoding: [0x48,0x85,0xcf]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    movq %rcx, d64(%rip) # encoding: [0x48,0x89,0x0d,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask64_extra_use_const:
; ZU:       # %bb.0:
; ZU-NEXT:    movabsq $287104476244869120, %rcx # encoding: [0x48,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; ZU-NEXT:    # imm = 0x3FC000000000000
; ZU-NEXT:    testq %rcx, %rdi # encoding: [0x48,0x85,0xcf]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    movq %rcx, d64(%rip) # encoding: [0x48,0x89,0x0d,A,A,A,A]
; ZU-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask64_extra_use_const:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $287104476244869120, %rcx # encoding: [0x48,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; O0-ZU-NEXT:    # imm = 0x3FC000000000000
; O0-ZU-NEXT:    andq %rcx, %rdi # encoding: [0x48,0x21,0xcf]
; O0-ZU-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    movq %rcx, d64(%rip) # encoding: [0x48,0x89,0x0d,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 287104476244869120  ; 0xff << 50
  %v1 = icmp ne i64 %v0, 0
  store i64 287104476244869120, ptr @d64
  ret i1 %v1
}

define i1 @shifted_mask64_extra_use_and(i64 %a) {
; NO-NDD-LABEL: shifted_mask64_extra_use_and:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    movabsq $287104476244869120, %rcx # encoding: [0x48,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; NO-NDD-NEXT:    # imm = 0x3FC000000000000
; NO-NDD-NEXT:    andq %rdi, %rcx # encoding: [0x48,0x21,0xf9]
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    movq %rcx, d64(%rip) # encoding: [0x48,0x89,0x0d,A,A,A,A]
; NO-NDD-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask64_extra_use_and:
; NDD:       # %bb.0:
; NDD-NEXT:    movabsq $287104476244869120, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; NDD-NEXT:    # imm = 0x3FC000000000000
; NDD-NEXT:    andq %rax, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0x21,0xc7]
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    movq %rdi, d64(%rip) # encoding: [0x48,0x89,0x3d,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask64_extra_use_and:
; ZU:       # %bb.0:
; ZU-NEXT:    movabsq $287104476244869120, %rcx # encoding: [0x48,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; ZU-NEXT:    # imm = 0x3FC000000000000
; ZU-NEXT:    andq %rdi, %rcx # encoding: [0x48,0x21,0xf9]
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    movq %rcx, d64(%rip) # encoding: [0x48,0x89,0x0d,A,A,A,A]
; ZU-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask64_extra_use_and:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movabsq $287104476244869120, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03]
; O0-ZU-NEXT:    # imm = 0x3FC000000000000
; O0-ZU-NEXT:    andq %rax, %rdi # encoding: [0x48,0x21,0xc7]
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    movq %rdi, d64(%rip) # encoding: [0x48,0x89,0x3d,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 287104476244869120  ; 0xff << 50
  %v1 = icmp ne i64 %v0, 0
  store i64 %v0, ptr @d64
  ret i1 %v1
}

define i1 @shifted_mask32_testl_immediate(i64 %a) {
; NO-NDD-LABEL: shifted_mask32_testl_immediate:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    testl $66846720, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xfc,0x03]
; NO-NDD-NEXT:    # imm = 0x3FC0000
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask32_testl_immediate:
; NDD:       # %bb.0:
; NDD-NEXT:    testl $66846720, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xfc,0x03]
; NDD-NEXT:    # imm = 0x3FC0000
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask32_testl_immediate:
; ZU:       # %bb.0:
; ZU-NEXT:    testl $66846720, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xfc,0x03]
; ZU-NEXT:    # imm = 0x3FC0000
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask32_testl_immediate:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movl %edi, %eax # encoding: [0x89,0xf8]
; O0-ZU-NEXT:    testl $66846720, %eax # encoding: [0xa9,0x00,0x00,0xfc,0x03]
; O0-ZU-NEXT:    # imm = 0x3FC0000
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 66846720  ; 0xff << 18
  %v1 = icmp ne i64 %v0, 0
  ret i1 %v1
}

define i1 @shifted_mask32_extra_use_const(i64 %a) {
; NO-NDD-LABEL: shifted_mask32_extra_use_const:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    testl $66846720, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xfc,0x03]
; NO-NDD-NEXT:    # imm = 0x3FC0000
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    movq $66846720, d64(%rip) # encoding: [0x48,0xc7,0x05,A,A,A,A,0x00,0x00,0xfc,0x03]
; NO-NDD-NEXT:    # fixup A - offset: 3, value: d64-8, kind: reloc_riprel_4byte
; NO-NDD-NEXT:    # imm = 0x3FC0000
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask32_extra_use_const:
; NDD:       # %bb.0:
; NDD-NEXT:    testl $66846720, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xfc,0x03]
; NDD-NEXT:    # imm = 0x3FC0000
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    movq $66846720, d64(%rip) # encoding: [0x48,0xc7,0x05,A,A,A,A,0x00,0x00,0xfc,0x03]
; NDD-NEXT:    # fixup A - offset: 3, value: d64-8, kind: reloc_riprel_4byte
; NDD-NEXT:    # imm = 0x3FC0000
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask32_extra_use_const:
; ZU:       # %bb.0:
; ZU-NEXT:    testl $66846720, %edi # encoding: [0xf7,0xc7,0x00,0x00,0xfc,0x03]
; ZU-NEXT:    # imm = 0x3FC0000
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    movq $66846720, d64(%rip) # encoding: [0x48,0xc7,0x05,A,A,A,A,0x00,0x00,0xfc,0x03]
; ZU-NEXT:    # fixup A - offset: 3, value: d64-8, kind: reloc_riprel_4byte
; ZU-NEXT:    # imm = 0x3FC0000
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask32_extra_use_const:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movl %edi, %eax # encoding: [0x89,0xf8]
; O0-ZU-NEXT:    testl $66846720, %eax # encoding: [0xa9,0x00,0x00,0xfc,0x03]
; O0-ZU-NEXT:    # imm = 0x3FC0000
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    movq $66846720, d64(%rip) # encoding: [0x48,0xc7,0x05,A,A,A,A,0x00,0x00,0xfc,0x03]
; O0-ZU-NEXT:    # fixup A - offset: 3, value: d64-8, kind: reloc_riprel_4byte
; O0-ZU-NEXT:    # imm = 0x3FC0000
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 66846720  ; 0xff << 18
  %v1 = icmp ne i64 %v0, 0
  store i64 66846720, ptr @d64
  ret i1 %v1
}

define i1 @shifted_mask32_extra_use_and(i64 %a) {
; NO-NDD-LABEL: shifted_mask32_extra_use_and:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    andq $66846720, %rdi # encoding: [0x48,0x81,0xe7,0x00,0x00,0xfc,0x03]
; NO-NDD-NEXT:    # imm = 0x3FC0000
; NO-NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NO-NDD-NEXT:    movq %rdi, d64(%rip) # encoding: [0x48,0x89,0x3d,A,A,A,A]
; NO-NDD-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: shifted_mask32_extra_use_and:
; NDD:       # %bb.0:
; NDD-NEXT:    andq $66846720, %rdi # EVEX TO LEGACY Compression encoding: [0x48,0x81,0xe7,0x00,0x00,0xfc,0x03]
; NDD-NEXT:    # imm = 0x3FC0000
; NDD-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; NDD-NEXT:    movq %rdi, d64(%rip) # encoding: [0x48,0x89,0x3d,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: shifted_mask32_extra_use_and:
; ZU:       # %bb.0:
; ZU-NEXT:    andq $66846720, %rdi # encoding: [0x48,0x81,0xe7,0x00,0x00,0xfc,0x03]
; ZU-NEXT:    # imm = 0x3FC0000
; ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; ZU-NEXT:    movq %rdi, d64(%rip) # encoding: [0x48,0x89,0x3d,A,A,A,A]
; ZU-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: shifted_mask32_extra_use_and:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    andq $66846720, %rdi # encoding: [0x48,0x81,0xe7,0x00,0x00,0xfc,0x03]
; O0-ZU-NEXT:    # imm = 0x3FC0000
; O0-ZU-NEXT:    setzune %al # encoding: [0x62,0xf4,0x7f,0x18,0x45,0xc0]
; O0-ZU-NEXT:    movq %rdi, d64(%rip) # encoding: [0x48,0x89,0x3d,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 3, value: d64-4, kind: reloc_riprel_4byte
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %v0 = and i64 %a, 66846720  ; 0xff << 50
  %v1 = icmp ne i64 %v0, 0
  store i64 %v0, ptr @d64
  ret i1 %v1
}

define { i64, i64 } @pr39968(i64, i64, i32) {
; NO-NDD-LABEL: pr39968:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NO-NDD-NEXT:    testb $64, %dl # encoding: [0xf6,0xc2,0x40]
; NO-NDD-NEXT:    cmovneq %rdi, %rsi # encoding: [0x48,0x0f,0x45,0xf7]
; NO-NDD-NEXT:    cmovneq %rdi, %rax # encoding: [0x48,0x0f,0x45,0xc7]
; NO-NDD-NEXT:    movq %rsi, %rdx # encoding: [0x48,0x89,0xf2]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: pr39968:
; NDD:       # %bb.0:
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    testb $64, %dl # encoding: [0xf6,0xc2,0x40]
; NDD-NEXT:    cmovneq %rdi, %rsi, %rdx # encoding: [0x62,0xf4,0xec,0x18,0x45,0xf7]
; NDD-NEXT:    cmovneq %rdi, %rax # EVEX TO LEGACY Compression encoding: [0x48,0x0f,0x45,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: pr39968:
; ZU:       # %bb.0:
; ZU-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; ZU-NEXT:    testb $64, %dl # encoding: [0xf6,0xc2,0x40]
; ZU-NEXT:    cmovneq %rdi, %rsi # encoding: [0x48,0x0f,0x45,0xf7]
; ZU-NEXT:    cmovneq %rdi, %rax # encoding: [0x48,0x0f,0x45,0xc7]
; ZU-NEXT:    movq %rsi, %rdx # encoding: [0x48,0x89,0xf2]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: pr39968:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movl %edx, %eax # encoding: [0x89,0xd0]
; O0-ZU-NEXT:    movq %rsi, %rdx # encoding: [0x48,0x89,0xf2]
; O0-ZU-NEXT:    movb %al, %cl # encoding: [0x88,0xc1]
; O0-ZU-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; O0-ZU-NEXT:    testb $64, %cl # encoding: [0xf6,0xc1,0x40]
; O0-ZU-NEXT:    cmovneq %rdi, %rdx # encoding: [0x48,0x0f,0x45,0xd7]
; O0-ZU-NEXT:    # kill: def $rax killed $eax
; O0-ZU-NEXT:    cmovneq %rdi, %rax # encoding: [0x48,0x0f,0x45,0xc7]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %4 = and i32 %2, 64
  %5 = icmp ne i32 %4, 0
  %6 = select i1 %5, i64 %0, i64 %1
  %7 = select i1 %5, i64 %0, i64 0
  %8 = insertvalue { i64, i64 } undef, i64 %7, 0
  %9 = insertvalue { i64, i64 } %8, i64 %6, 1
  ret { i64, i64 } %9
}

; Make sure we use a 32-bit comparison without an extend based on the input
; being pre-sign extended by caller.
define i32 @pr42189(i16 signext %c) {
; CHECK-LABEL: pr42189:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl $32767, %edi # encoding: [0x81,0xff,0xff,0x7f,0x00,0x00]
; CHECK-NEXT:    # imm = 0x7FFF
; CHECK-NEXT:    jne f@PLT # TAILCALL
; CHECK-NEXT:    # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: f@PLT-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    jmp g@PLT # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: g@PLT-1, kind: FK_PCRel_1
;
; O0-ZU-LABEL: pr42189:
; O0-ZU:       # %bb.0: # %entry
; O0-ZU-NEXT:    pushq %rax # encoding: [0x50]
; O0-ZU-NEXT:    .cfi_def_cfa_offset 16
; O0-ZU-NEXT:    movw %di, %ax # encoding: [0x66,0x89,0xf8]
; O0-ZU-NEXT:    cmpw $32767, %ax # encoding: [0x66,0x3d,0xff,0x7f]
; O0-ZU-NEXT:    # imm = 0x7FFF
; O0-ZU-NEXT:    jne .LBB45_2 # encoding: [0x75,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB45_2-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  # %bb.1: # %if.then
; O0-ZU-NEXT:    callq g@PLT # encoding: [0xe8,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: g@PLT-4, kind: FK_PCRel_4
; O0-ZU-NEXT:    movl %eax, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill
; O0-ZU-NEXT:    # encoding: [0x89,0x44,0x24,0x04]
; O0-ZU-NEXT:    jmp .LBB45_3 # encoding: [0xeb,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: .LBB45_3-1, kind: FK_PCRel_1
; O0-ZU-NEXT:  .LBB45_2: # %if.end
; O0-ZU-NEXT:    callq f@PLT # encoding: [0xe8,A,A,A,A]
; O0-ZU-NEXT:    # fixup A - offset: 1, value: f@PLT-4, kind: FK_PCRel_4
; O0-ZU-NEXT:    movl %eax, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill
; O0-ZU-NEXT:    # encoding: [0x89,0x44,0x24,0x04]
; O0-ZU-NEXT:  .LBB45_3: # %return
; O0-ZU-NEXT:    movl {{[-0-9]+}}(%r{{[sb]}}p), %eax # 4-byte Reload
; O0-ZU-NEXT:    # encoding: [0x8b,0x44,0x24,0x04]
; O0-ZU-NEXT:    popq %rcx # encoding: [0x59]
; O0-ZU-NEXT:    .cfi_def_cfa_offset 8
; O0-ZU-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp eq i16 %c, 32767
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call i32 @g()
  br label %return

if.end:                                           ; preds = %entry
  %call2 = tail call i32 @f()
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call2, %if.end ]
  ret i32 %retval.0
}

declare i32 @g()
declare i32 @f()

; Make sure we fold the load+and into a test from memory.
; The store makes sure the chain result of the load is used which used to
; prevent the post isel peephole from catching this.
define i1 @fold_test_and_with_chain(ptr %x, ptr %y, i32 %z) {
; NO-NDD-LABEL: fold_test_and_with_chain:
; NO-NDD:       # %bb.0:
; NO-NDD-NEXT:    testl %edx, (%rdi) # encoding: [0x85,0x17]
; NO-NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NO-NDD-NEXT:    movl %edx, (%rsi) # encoding: [0x89,0x16]
; NO-NDD-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: fold_test_and_with_chain:
; NDD:       # %bb.0:
; NDD-NEXT:    testl %edx, (%rdi) # encoding: [0x85,0x17]
; NDD-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; NDD-NEXT:    movl %edx, (%rsi) # encoding: [0x89,0x16]
; NDD-NEXT:    retq # encoding: [0xc3]
;
; ZU-LABEL: fold_test_and_with_chain:
; ZU:       # %bb.0:
; ZU-NEXT:    testl %edx, (%rdi) # encoding: [0x85,0x17]
; ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; ZU-NEXT:    movl %edx, (%rsi) # encoding: [0x89,0x16]
; ZU-NEXT:    retq # encoding: [0xc3]
;
; O0-ZU-LABEL: fold_test_and_with_chain:
; O0-ZU:       # %bb.0:
; O0-ZU-NEXT:    movl (%rdi), %ecx # encoding: [0x8b,0x0f]
; O0-ZU-NEXT:    movl %edx, %eax # encoding: [0x89,0xd0]
; O0-ZU-NEXT:    andl %ecx, %eax # encoding: [0x21,0xc8]
; O0-ZU-NEXT:    testl %eax, %eax # encoding: [0x85,0xc0]
; O0-ZU-NEXT:    setzue %al # encoding: [0x62,0xf4,0x7f,0x18,0x44,0xc0]
; O0-ZU-NEXT:    movl %edx, (%rsi) # encoding: [0x89,0x16]
; O0-ZU-NEXT:    retq # encoding: [0xc3]
  %a = load i32, ptr %x
  %b = and i32 %z, %a
  %c = icmp eq i32 %b, 0
  store i32 %z, ptr %y
  ret i1 %c
}
