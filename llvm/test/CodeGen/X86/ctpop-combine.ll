; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+popcnt | FileCheck %s -check-prefixes=CHECK,POPCOUNT
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=-popcnt | FileCheck %s -check-prefixes=CHECK,NO-POPCOUNT

declare i8 @llvm.ctpop.i8(i8) nounwind readnone
declare i64 @llvm.ctpop.i64(i64) nounwind readnone

define i32 @test1(i64 %x) nounwind readnone {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    leaq -1(%rdi), %rcx
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    testq %rcx, %rdi
; CHECK-NEXT:    setne %al
; CHECK-NEXT:    retq
  %count = tail call i64 @llvm.ctpop.i64(i64 %x)
  %cast = trunc i64 %count to i32
  %cmp = icmp ugt i32 %cast, 1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}


define i32 @test2(i64 %x) nounwind readnone {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    leaq -1(%rdi), %rcx
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    testq %rcx, %rdi
; CHECK-NEXT:    sete %al
; CHECK-NEXT:    retq
  %count = tail call i64 @llvm.ctpop.i64(i64 %x)
  %cmp = icmp ult i64 %count, 2
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @test3(i64 %x) nounwind readnone {
; POPCOUNT-LABEL: test3:
; POPCOUNT:       # %bb.0:
; POPCOUNT-NEXT:    popcntq %rdi, %rcx
; POPCOUNT-NEXT:    andb $63, %cl
; POPCOUNT-NEXT:    xorl %eax, %eax
; POPCOUNT-NEXT:    cmpb $2, %cl
; POPCOUNT-NEXT:    setb %al
; POPCOUNT-NEXT:    retq
;
; NO-POPCOUNT-LABEL: test3:
; NO-POPCOUNT:       # %bb.0:
; NO-POPCOUNT-NEXT:    movq %rdi, %rax
; NO-POPCOUNT-NEXT:    shrq %rax
; NO-POPCOUNT-NEXT:    movabsq $6148914691236517205, %rcx # imm = 0x5555555555555555
; NO-POPCOUNT-NEXT:    andq %rax, %rcx
; NO-POPCOUNT-NEXT:    subq %rcx, %rdi
; NO-POPCOUNT-NEXT:    movabsq $3689348814741910323, %rax # imm = 0x3333333333333333
; NO-POPCOUNT-NEXT:    movq %rdi, %rcx
; NO-POPCOUNT-NEXT:    andq %rax, %rcx
; NO-POPCOUNT-NEXT:    shrq $2, %rdi
; NO-POPCOUNT-NEXT:    andq %rax, %rdi
; NO-POPCOUNT-NEXT:    addq %rcx, %rdi
; NO-POPCOUNT-NEXT:    movq %rdi, %rax
; NO-POPCOUNT-NEXT:    shrq $4, %rax
; NO-POPCOUNT-NEXT:    addq %rdi, %rax
; NO-POPCOUNT-NEXT:    movabsq $1085102592571150095, %rcx # imm = 0xF0F0F0F0F0F0F0F
; NO-POPCOUNT-NEXT:    andq %rax, %rcx
; NO-POPCOUNT-NEXT:    movabsq $72340172838076673, %rdx # imm = 0x101010101010101
; NO-POPCOUNT-NEXT:    imulq %rcx, %rdx
; NO-POPCOUNT-NEXT:    shrq $56, %rdx
; NO-POPCOUNT-NEXT:    andb $63, %dl
; NO-POPCOUNT-NEXT:    xorl %eax, %eax
; NO-POPCOUNT-NEXT:    cmpb $2, %dl
; NO-POPCOUNT-NEXT:    setb %al
; NO-POPCOUNT-NEXT:    retq
  %count = tail call i64 @llvm.ctpop.i64(i64 %x)
  %cast = trunc i64 %count to i6 ; Too small for 0-64
  %cmp = icmp ult i6 %cast, 2
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i8 @test4(i8 %x) nounwind readnone {
; POPCOUNT-LABEL: test4:
; POPCOUNT:       # %bb.0:
; POPCOUNT-NEXT:    andl $127, %edi
; POPCOUNT-NEXT:    popcntl %edi, %eax
; POPCOUNT-NEXT:    # kill: def $al killed $al killed $eax
; POPCOUNT-NEXT:    retq
;
; NO-POPCOUNT-LABEL: test4:
; NO-POPCOUNT:       # %bb.0:
; NO-POPCOUNT-NEXT:    andl $127, %edi
; NO-POPCOUNT-NEXT:    imull $134480385, %edi, %eax # imm = 0x8040201
; NO-POPCOUNT-NEXT:    shrl $3, %eax
; NO-POPCOUNT-NEXT:    andl $286331153, %eax # imm = 0x11111111
; NO-POPCOUNT-NEXT:    imull $286331153, %eax, %eax # imm = 0x11111111
; NO-POPCOUNT-NEXT:    shrl $28, %eax
; NO-POPCOUNT-NEXT:    # kill: def $al killed $al killed $eax
; NO-POPCOUNT-NEXT:    retq
  %x2 = and i8 %x, 127
  %count = tail call i8 @llvm.ctpop.i8(i8 %x2)
  %and = and i8 %count, 7
  ret i8 %and
}

define i32 @ctpop_eq_one(i64 %x) nounwind readnone {
; POPCOUNT-LABEL: ctpop_eq_one:
; POPCOUNT:       # %bb.0:
; POPCOUNT-NEXT:    popcntq %rdi, %rcx
; POPCOUNT-NEXT:    xorl %eax, %eax
; POPCOUNT-NEXT:    cmpl $1, %ecx
; POPCOUNT-NEXT:    sete %al
; POPCOUNT-NEXT:    retq
;
; NO-POPCOUNT-LABEL: ctpop_eq_one:
; NO-POPCOUNT:       # %bb.0:
; NO-POPCOUNT-NEXT:    leaq -1(%rdi), %rcx
; NO-POPCOUNT-NEXT:    xorq %rcx, %rdi
; NO-POPCOUNT-NEXT:    xorl %eax, %eax
; NO-POPCOUNT-NEXT:    cmpq %rcx, %rdi
; NO-POPCOUNT-NEXT:    seta %al
; NO-POPCOUNT-NEXT:    retq
  %count = tail call i64 @llvm.ctpop.i64(i64 %x)
  %cmp = icmp eq i64 %count, 1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @ctpop_ne_one(i64 %x) nounwind readnone {
; POPCOUNT-LABEL: ctpop_ne_one:
; POPCOUNT:       # %bb.0:
; POPCOUNT-NEXT:    popcntq %rdi, %rcx
; POPCOUNT-NEXT:    xorl %eax, %eax
; POPCOUNT-NEXT:    cmpl $1, %ecx
; POPCOUNT-NEXT:    setne %al
; POPCOUNT-NEXT:    retq
;
; NO-POPCOUNT-LABEL: ctpop_ne_one:
; NO-POPCOUNT:       # %bb.0:
; NO-POPCOUNT-NEXT:    leaq -1(%rdi), %rcx
; NO-POPCOUNT-NEXT:    xorq %rcx, %rdi
; NO-POPCOUNT-NEXT:    xorl %eax, %eax
; NO-POPCOUNT-NEXT:    cmpq %rcx, %rdi
; NO-POPCOUNT-NEXT:    setbe %al
; NO-POPCOUNT-NEXT:    retq
  %count = tail call i64 @llvm.ctpop.i64(i64 %x)
  %cmp = icmp ne i64 %count, 1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i1 @ctpop_trunc_non_power2(i255 %x) nounwind {
; CHECK-LABEL: ctpop_trunc_non_power2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    addq $-1, %rax
; CHECK-NEXT:    movq %rsi, %r8
; CHECK-NEXT:    adcq $-1, %r8
; CHECK-NEXT:    movq %rdx, %r9
; CHECK-NEXT:    adcq $-1, %r9
; CHECK-NEXT:    movabsq $9223372036854775807, %r10 # imm = 0x7FFFFFFFFFFFFFFF
; CHECK-NEXT:    movq %rcx, %r11
; CHECK-NEXT:    adcq %r10, %r11
; CHECK-NEXT:    xorq %r11, %rcx
; CHECK-NEXT:    andq %r10, %r11
; CHECK-NEXT:    andq %r10, %rcx
; CHECK-NEXT:    xorq %r9, %rdx
; CHECK-NEXT:    xorq %r8, %rsi
; CHECK-NEXT:    xorq %rax, %rdi
; CHECK-NEXT:    cmpq %rdi, %rax
; CHECK-NEXT:    sbbq %rsi, %r8
; CHECK-NEXT:    sbbq %rdx, %r9
; CHECK-NEXT:    sbbq %rcx, %r11
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    retq
  %a = call i255 @llvm.ctpop.i255(i255 %x)
  %b = trunc i255 %a to i8 ; largest value from ctpop is 255, fits in 8 bits.
  %c = icmp eq i8 %b, 1
  ret i1 %c
}
declare i255 @llvm.ctpop.i255(i255)
