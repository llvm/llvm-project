; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -verify-machineinstrs -mtriple=x86_64-unknown-unknown -disable-cgp-select2branch -x86-cmov-converter=false | FileCheck %s
; RUN: llc < %s -verify-machineinstrs -mtriple=x86_64-unknown-unknown -disable-cgp-select2branch -x86-cmov-converter=false -mattr=+ndd --show-mc-encoding | FileCheck %s --check-prefix=NDD
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128"

define i32 @test1(i32 %x, i32 %n, i32 %w, ptr %vp) nounwind readnone {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    btl %esi, %edi
; CHECK-NEXT:    movl $12, %eax
; CHECK-NEXT:    cmovael (%rcx), %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: test1:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    btl %esi, %edi # encoding: [0x0f,0xa3,0xf7]
; NDD-NEXT:    movl $12, %eax # encoding: [0xb8,0x0c,0x00,0x00,0x00]
; NDD-NEXT:    cmovael (%rcx), %eax # EVEX TO LEGACY Compression encoding: [0x0f,0x43,0x01]
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
	%0 = lshr i32 %x, %n
	%1 = and i32 %0, 1
	%toBool = icmp eq i32 %1, 0
        %v = load i32, ptr %vp
	%.0 = select i1 %toBool, i32 %v, i32 12
	ret i32 %.0
}

define i32 @test2(i32 %x, i32 %n, i32 %w, ptr %vp) nounwind readnone {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    btl %esi, %edi
; CHECK-NEXT:    movl $12, %eax
; CHECK-NEXT:    cmovbl (%rcx), %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: test2:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    btl %esi, %edi # encoding: [0x0f,0xa3,0xf7]
; NDD-NEXT:    movl $12, %eax # encoding: [0xb8,0x0c,0x00,0x00,0x00]
; NDD-NEXT:    cmovbl (%rcx), %eax # EVEX TO LEGACY Compression encoding: [0x0f,0x42,0x01]
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
	%0 = lshr i32 %x, %n
	%1 = and i32 %0, 1
	%toBool = icmp eq i32 %1, 0
        %v = load i32, ptr %vp
	%.0 = select i1 %toBool, i32 12, i32 %v
	ret i32 %.0
}


; x86's 32-bit cmov zeroes the high 32 bits of the destination. Make
; sure CodeGen takes advantage of that to avoid an unnecessary
; zero-extend (movl) after the cmov.

declare void @bar(i64) nounwind

define void @test3(i64 %a, i64 %b, i1 %p) nounwind {
; CHECK-LABEL: test3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    testb $1, %dl
; CHECK-NEXT:    cmovel %esi, %edi
; CHECK-NEXT:    callq bar@PLT
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    retq
;
; NDD-LABEL: test3:
; NDD:       # %bb.0:
; NDD-NEXT:    pushq %rax # encoding: [0x50]
; NDD-NEXT:    testb $1, %dl # encoding: [0xf6,0xc2,0x01]
; NDD-NEXT:    cmovel %esi, %edi # EVEX TO LEGACY Compression encoding: [0x0f,0x44,0xfe]
; NDD-NEXT:    callq bar@PLT # encoding: [0xe8,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 1, value: bar@PLT-4, kind: FK_PCRel_4
; NDD-NEXT:    popq %rax # encoding: [0x58]
; NDD-NEXT:    retq # encoding: [0xc3]
  %c = trunc i64 %a to i32
  %d = trunc i64 %b to i32
  %e = select i1 %p, i32 %c, i32 %d
  %f = zext i32 %e to i64
  call void @bar(i64 %f)
  ret void
}



; CodeGen shouldn't try to do a setne after an expanded 8-bit conditional
; move without recomputing EFLAGS, because the expansion of the conditional
; move with control flow may clobber EFLAGS (e.g., with xor, to set the
; register to zero).

; The test is a little awkward; the important part is that there's a test before the
; setne.
; PR4814


@g_3 = external dso_local global i8
@g_96 = external dso_local global i8
@g_100 = external dso_local global i8
@_2E_str = external dso_local constant [15 x i8], align 1

define i1 @test4() nounwind {
; CHECK-LABEL: test4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movsbl g_3(%rip), %edx
; CHECK-NEXT:    movzbl %dl, %ecx
; CHECK-NEXT:    shrl $7, %ecx
; CHECK-NEXT:    xorb $1, %cl
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    sarl %cl, %edx
; CHECK-NEXT:    movzbl g_96(%rip), %eax
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    je .LBB3_2
; CHECK-NEXT:  # %bb.1: # %bb.i.i.i
; CHECK-NEXT:    movzbl g_100(%rip), %ecx
; CHECK-NEXT:  .LBB3_2: # %func_4.exit.i
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:    testb %dl, %dl
; CHECK-NEXT:    setne %bl
; CHECK-NEXT:    movzbl %al, %ecx
; CHECK-NEXT:    cmovnel %esi, %ecx
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    je .LBB3_5
; CHECK-NEXT:  # %bb.3: # %func_4.exit.i
; CHECK-NEXT:    testb %bl, %bl
; CHECK-NEXT:    jne .LBB3_5
; CHECK-NEXT:  # %bb.4: # %bb.i.i
; CHECK-NEXT:    movzbl g_100(%rip), %ecx
; CHECK-NEXT:    xorl %ebx, %ebx
; CHECK-NEXT:    movl %eax, %ecx
; CHECK-NEXT:  .LBB3_5: # %func_1.exit
; CHECK-NEXT:    movb %cl, g_96(%rip)
; CHECK-NEXT:    movzbl %cl, %esi
; CHECK-NEXT:    movl $_2E_str, %edi
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    callq printf@PLT
; CHECK-NEXT:    movl %ebx, %eax
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    retq
;
; NDD-LABEL: test4:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    movsbl g_3(%rip), %eax # encoding: [0x0f,0xbe,0x05,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: g_3-4, kind: reloc_riprel_4byte
; NDD-NEXT:    movzbl %al, %ecx # encoding: [0x0f,0xb6,0xc8]
; NDD-NEXT:    shrl $7, %ecx # EVEX TO LEGACY Compression encoding: [0xc1,0xe9,0x07]
; NDD-NEXT:    xorb $1, %cl # EVEX TO LEGACY Compression encoding: [0x80,0xf1,0x01]
; NDD-NEXT:    sarl %cl, %eax, %ecx # encoding: [0x62,0xf4,0x74,0x18,0xd3,0xf8]
; NDD-NEXT:    movzbl g_96(%rip), %eax # encoding: [0x0f,0xb6,0x05,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: g_96-4, kind: reloc_riprel_4byte
; NDD-NEXT:    testb %al, %al # encoding: [0x84,0xc0]
; NDD-NEXT:    je .LBB3_2 # encoding: [0x74,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB3_2-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.1: # %bb.i.i.i
; NDD-NEXT:    movzbl g_100(%rip), %edx # encoding: [0x0f,0xb6,0x15,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: g_100-4, kind: reloc_riprel_4byte
; NDD-NEXT:  .LBB3_2: # %func_4.exit.i
; NDD-NEXT:    pushq %rbx # encoding: [0x53]
; NDD-NEXT:    xorl %edx, %edx # encoding: [0x31,0xd2]
; NDD-NEXT:    testb %cl, %cl # encoding: [0x84,0xc9]
; NDD-NEXT:    setne %bl # encoding: [0x0f,0x95,0xc3]
; NDD-NEXT:    movzbl %al, %ecx # encoding: [0x0f,0xb6,0xc8]
; NDD-NEXT:    cmovnel %edx, %ecx # EVEX TO LEGACY Compression encoding: [0x0f,0x45,0xca]
; NDD-NEXT:    testb %al, %al # encoding: [0x84,0xc0]
; NDD-NEXT:    je .LBB3_5 # encoding: [0x74,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB3_5-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.3: # %func_4.exit.i
; NDD-NEXT:    testb %bl, %bl # encoding: [0x84,0xdb]
; NDD-NEXT:    jne .LBB3_5 # encoding: [0x75,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB3_5-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.4: # %bb.i.i
; NDD-NEXT:    movzbl g_100(%rip), %ecx # encoding: [0x0f,0xb6,0x0d,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 3, value: g_100-4, kind: reloc_riprel_4byte
; NDD-NEXT:    xorl %ebx, %ebx # encoding: [0x31,0xdb]
; NDD-NEXT:    movl %eax, %ecx # encoding: [0x89,0xc1]
; NDD-NEXT:  .LBB3_5: # %func_1.exit
; NDD-NEXT:    movb %cl, g_96(%rip) # encoding: [0x88,0x0d,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 2, value: g_96-4, kind: reloc_riprel_4byte
; NDD-NEXT:    movzbl %cl, %esi # encoding: [0x0f,0xb6,0xf1]
; NDD-NEXT:    movl $_2E_str, %edi # encoding: [0xbf,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 1, value: _2E_str, kind: FK_Data_4
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    callq printf@PLT # encoding: [0xe8,A,A,A,A]
; NDD-NEXT:    # fixup A - offset: 1, value: printf@PLT-4, kind: FK_PCRel_4
; NDD-NEXT:    movl %ebx, %eax # encoding: [0x89,0xd8]
; NDD-NEXT:    popq %rbx # encoding: [0x5b]
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %0 = load i8, ptr @g_3, align 1
  %1 = sext i8 %0 to i32
  %.lobit.i = lshr i8 %0, 7
  %tmp.i = zext i8 %.lobit.i to i32
  %tmp.not.i = xor i32 %tmp.i, 1
  %iftmp.17.0.i.i = ashr i32 %1, %tmp.not.i
  %retval56.i.i = trunc i32 %iftmp.17.0.i.i to i8
  %2 = icmp eq i8 %retval56.i.i, 0
  %g_96.promoted.i = load i8, ptr @g_96
  %3 = icmp eq i8 %g_96.promoted.i, 0
  br i1 %3, label %func_4.exit.i, label %bb.i.i.i

bb.i.i.i:
  %4 = load volatile i8, ptr @g_100, align 1
  br label %func_4.exit.i

func_4.exit.i:
  %.not.i = xor i1 %2, true
  %brmerge.i = or i1 %3, %.not.i
  %.mux.i = select i1 %2, i8 %g_96.promoted.i, i8 0
  br i1 %brmerge.i, label %func_1.exit, label %bb.i.i

bb.i.i:
  %5 = load volatile i8, ptr @g_100, align 1
  br label %func_1.exit

func_1.exit:
  %g_96.tmp.0.i = phi i8 [ %g_96.promoted.i, %bb.i.i ], [ %.mux.i, %func_4.exit.i ]
  %ret = phi i1 [ 0, %bb.i.i ], [ %.not.i, %func_4.exit.i ]
  store i8 %g_96.tmp.0.i, ptr @g_96
  %6 = zext i8 %g_96.tmp.0.i to i32
  %7 = tail call i32 (ptr, ...) @printf(ptr noalias @_2E_str, i32 %6) nounwind
  ret i1 %ret
}

declare i32 @printf(ptr nocapture, ...) nounwind


; Should compile to setcc | -2.
; rdar://6668608
define i32 @test5(ptr nocapture %P) nounwind readonly {
; CHECK-LABEL: test5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $42, (%rdi)
; CHECK-NEXT:    setge %al
; CHECK-NEXT:    orl $-2, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: test5:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    cmpl $42, (%rdi) # encoding: [0x83,0x3f,0x2a]
; NDD-NEXT:    setge %al # encoding: [0x0f,0x9d,0xc0]
; NDD-NEXT:    orl $-2, %eax # EVEX TO LEGACY Compression encoding: [0x83,0xc8,0xfe]
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
	%0 = load i32, ptr %P, align 4
	%1 = icmp sgt i32 %0, 41
	%iftmp.0.0 = select i1 %1, i32 -1, i32 -2
	ret i32 %iftmp.0.0
}

define i32 @test6(ptr nocapture %P) nounwind readonly {
; CHECK-LABEL: test6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $42, (%rdi)
; CHECK-NEXT:    setl %al
; CHECK-NEXT:    leal 4(%rax,%rax,8), %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: test6:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    cmpl $42, (%rdi) # encoding: [0x83,0x3f,0x2a]
; NDD-NEXT:    setl %al # encoding: [0x0f,0x9c,0xc0]
; NDD-NEXT:    leal 4(%rax,%rax,8), %eax # encoding: [0x8d,0x44,0xc0,0x04]
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
	%0 = load i32, ptr %P, align 4
	%1 = icmp sgt i32 %0, 41
	%iftmp.0.0 = select i1 %1, i32 4, i32 13
	ret i32 %iftmp.0.0
}


define i8 @test7(i1 inreg %c, i8 inreg %a, i8 inreg %b) nounwind {
; CHECK-LABEL: test7:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl %esi, %eax
; CHECK-NEXT:    testb $1, %dil
; CHECK-NEXT:    cmovel %edx, %eax
; CHECK-NEXT:    # kill: def $al killed $al killed $eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: test7:
; NDD:       # %bb.0:
; NDD-NEXT:    testb $1, %dil # encoding: [0x40,0xf6,0xc7,0x01]
; NDD-NEXT:    cmovnel %esi, %edx, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x45,0xd6]
; NDD-NEXT:    # kill: def $al killed $al killed $eax
; NDD-NEXT:    retq # encoding: [0xc3]
  %d = select i1 %c, i8 %a, i8 %b
  ret i8 %d
}

define i64 @test8(i64 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq %rsi, %rax
; CHECK-NEXT:    cmpq $-2147483648, %rdi # imm = 0x80000000
; CHECK-NEXT:    cmovlq %rdx, %rax
; CHECK-NEXT:    retq
;
; NDD-LABEL: test8:
; NDD:       # %bb.0:
; NDD-NEXT:    cmpq $-2147483648, %rdi # encoding: [0x48,0x81,0xff,0x00,0x00,0x00,0x80]
; NDD-NEXT:    # imm = 0x80000000
; NDD-NEXT:    cmovgeq %rsi, %rdx, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x4d,0xd6]
; NDD-NEXT:    retq # encoding: [0xc3]
  %4 = icmp sgt i64 %0, -2147483649
  %5 = select i1 %4, i64 %1, i64 %2
  ret i64 %5
}

define i32 @smin(i32 %x) {
; CHECK-LABEL: smin:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    notl %edi
; CHECK-NEXT:    movl $-1, %eax
; CHECK-NEXT:    cmovnsl %edi, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: smin:
; NDD:       # %bb.0:
; NDD-NEXT:    notl %edi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0xf7,0xd7]
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    movl $-1, %ecx # encoding: [0xb9,0xff,0xff,0xff,0xff]
; NDD-NEXT:    cmovsl %ecx, %eax # EVEX TO LEGACY Compression encoding: [0x0f,0x48,0xc1]
; NDD-NEXT:    retq # encoding: [0xc3]
  %not_x = xor i32 %x, -1
  %1 = icmp slt i32 %not_x, -1
  %sel = select i1 %1, i32 %not_x, i32 -1
  ret i32 %sel
}

define i32 @pr47049_1(i32 %0) {
; CHECK-LABEL: pr47049_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    cmovlel %edi, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: pr47049_1:
; NDD:       # %bb.0:
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; NDD-NEXT:    cmovlel %edi, %eax # EVEX TO LEGACY Compression encoding: [0x0f,0x4e,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
  %2 = icmp slt i32 %0, 1
  %3 = select i1 %2, i32 %0, i32 1
  ret i32 %3
}

define i32 @pr47049_2(i32 %0) {
; CHECK-LABEL: pr47049_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    movl $-1, %eax
; CHECK-NEXT:    cmovnsl %edi, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: pr47049_2:
; NDD:       # %bb.0:
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    movl $-1, %eax # encoding: [0xb8,0xff,0xff,0xff,0xff]
; NDD-NEXT:    cmovnsl %edi, %eax # EVEX TO LEGACY Compression encoding: [0x0f,0x49,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
  %2 = icmp sgt i32 %0, -1
  %3 = select i1 %2, i32 %0, i32 -1
  ret i32 %3
}

define i32 @pr47049_3(i32 %0) {
; CHECK-LABEL: pr47049_3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    cmovgl %edi, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: pr47049_3:
; NDD:       # %bb.0:
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; NDD-NEXT:    cmovgl %edi, %eax # EVEX TO LEGACY Compression encoding: [0x0f,0x4f,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
  %2 = icmp sgt i32 %0, 1
  %3 = select i1 %2, i32 %0, i32 1
  ret i32 %3
}

define i32 @pr47049_4(i32 %0) {
; CHECK-LABEL: pr47049_4:
; CHECK:       # %bb.0:
; CHECK-NEXT:    testl %edi, %edi
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    cmovnel %edi, %eax
; CHECK-NEXT:    retq
;
; NDD-LABEL: pr47049_4:
; NDD:       # %bb.0:
; NDD-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; NDD-NEXT:    movl $1, %eax # encoding: [0xb8,0x01,0x00,0x00,0x00]
; NDD-NEXT:    cmovnel %edi, %eax # EVEX TO LEGACY Compression encoding: [0x0f,0x45,0xc7]
; NDD-NEXT:    retq # encoding: [0xc3]
  %2 = icmp ugt i32 %0, 1
  %3 = select i1 %2, i32 %0, i32 1
  ret i32 %3
}
