; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple=x86_64-unknown-linux | FileCheck %s

; This test verifies that the experimental.vector.extract.last.active intrinsic
; doesn't cause an infinite loop during legalization when the step vector type
; needs widening (e.g., v4i8 -> v16i8 on X86).

define i32 @extract_last_active_v4i32(<4 x i32> %a, <4 x i1> %c) {
; CHECK-LABEL: extract_last_active_v4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movd %xmm1, %eax
; CHECK-NEXT:    pshufd {{.*#+}} xmm2 = xmm1[2,3,2,3]
; CHECK-NEXT:    movd %xmm2, %ecx
; CHECK-NEXT:    pshufd {{.*#+}} xmm2 = xmm1[1,1,1,1]
; CHECK-NEXT:    movd %xmm2, %edx
; CHECK-NEXT:    pshufd {{.*#+}} xmm1 = xmm1[3,3,3,3]
; CHECK-NEXT:    movd %xmm1, %esi
; CHECK-NEXT:    movaps %xmm0, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    xorl %edi, %edi
; CHECK-NEXT:    testl %esi, %esi
; CHECK-NEXT:    setne %dil
; CHECK-NEXT:    leal (%rdi,%rdi,2), %r8d
; CHECK-NEXT:    xorl %r9d, %r9d
; CHECK-NEXT:    testl %edx, %edx
; CHECK-NEXT:    setne %r9b
; CHECK-NEXT:    xorl %edi, %edi
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    setne %dil
; CHECK-NEXT:    addl %edi, %edi
; CHECK-NEXT:    cmpb %dil, %r9b
; CHECK-NEXT:    cmoval %r9d, %edi
; CHECK-NEXT:    cmpb %r8b, %dil
; CHECK-NEXT:    cmovbel %r8d, %edi
; CHECK-NEXT:    orl %edx, %eax
; CHECK-NEXT:    orl %esi, %ecx
; CHECK-NEXT:    orl %eax, %ecx
; CHECK-NEXT:    andb $1, %cl
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpb $1, %cl
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    orl -24(%rsp,%rdi,4), %eax
; CHECK-NEXT:    retq
  %res = call i32 @llvm.experimental.vector.extract.last.active.v4i32(<4 x i32> %a, <4 x i1> %c, i32 -1)
  ret i32 %res
}

define i32 @extract_last_active_v4i32_no_default(<4 x i32> %a, <4 x i1> %c) {
; CHECK-LABEL: extract_last_active_v4i32_no_default:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movaps %xmm0, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    pshufd {{.*#+}} xmm0 = xmm1[3,3,3,3]
; CHECK-NEXT:    movd %xmm0, %eax
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    testl %eax, %eax
; CHECK-NEXT:    setne %cl
; CHECK-NEXT:    leal (%rcx,%rcx,2), %eax
; CHECK-NEXT:    pshufd {{.*#+}} xmm0 = xmm1[1,1,1,1]
; CHECK-NEXT:    movd %xmm0, %ecx
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    setne %dl
; CHECK-NEXT:    pshufd {{.*#+}} xmm0 = xmm1[2,3,2,3]
; CHECK-NEXT:    movd %xmm0, %ecx
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    setne %sil
; CHECK-NEXT:    addl %esi, %esi
; CHECK-NEXT:    cmpb %sil, %dl
; CHECK-NEXT:    cmoval %edx, %esi
; CHECK-NEXT:    cmpb %al, %sil
; CHECK-NEXT:    cmovbel %eax, %esi
; CHECK-NEXT:    movl -24(%rsp,%rsi,4), %eax
; CHECK-NEXT:    retq
  %res = call i32 @llvm.experimental.vector.extract.last.active.v4i32(<4 x i32> %a, <4 x i1> %c, i32 poison)
  ret i32 %res
}
