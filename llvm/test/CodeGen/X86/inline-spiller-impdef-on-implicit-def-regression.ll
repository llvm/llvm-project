; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc -mtriple=x86_64-unknown-linux-gnu < %s | FileCheck %s

; Make sure there's no assert on an implicit-def with implicit operands
; during register allocation.

%struct.BlockContext = type { [32 x i8], [32 x i8], [2 x [32 x i8]], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [2 x [32 x i8]], [2 x [32 x i8]], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [16 x i8], [32 x i8], [32 x i8] }
%struct.CdfModeContext = type { [4 x [16 x i16]], [2 x [13 x [16 x i16]]], [9 x [16 x i16]], [5 x [4 x [16 x i16]]], [6 x [16 x i16]], [2 x [16 x i16]], [16 x i16], [2 x [13 x [8 x i16]]], [3 x [13 x [8 x i16]]], [8 x i16], [8 x [8 x i16]], [8 x i16], [8 x [8 x i16]], [3 x [8 x i16]], [2 x [7 x [8 x i16]]], [2 x [7 x [5 x [8 x i16]]]], [2 x [8 x [4 x i16]]], [4 x [3 x [4 x i16]]], [22 x [4 x i16]], [4 x i16], [5 x [4 x i16]], [4 x [4 x i16]], [4 x i16], [2 x i16], [2 x i16], [7 x [2 x i16]], [7 x [2 x i16]], [4 x [2 x i16]], [22 x [2 x i16]], [6 x [2 x i16]], [2 x [2 x i16]], [6 x [2 x i16]], [3 x [2 x i16]], [4 x [2 x i16]], [5 x [2 x i16]], [5 x [2 x i16]], [6 x [2 x i16]], [6 x [2 x i16]], [9 x [2 x i16]], [6 x [3 x [2 x i16]]], [3 x [3 x [2 x i16]]], [2 x [3 x [2 x i16]]], [3 x [3 x [2 x i16]]], [7 x [3 x [2 x i16]]], [3 x [2 x i16]], [3 x [2 x i16]], [3 x [2 x i16]], [22 x [2 x i16]], [7 x [3 x [2 x i16]]], [2 x [2 x i16]], [2 x i16], [8 x i8] }

define i32 @decode_sb(ptr %t, i32 %bl, i32 %_msprop1966, i32 %sub.i, i64 %idxprom, i1 %cmp54) #0 {
; CHECK-LABEL: decode_sb:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rbp
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset %rbp, -16
; CHECK-NEXT:    movq %rsp, %rbp
; CHECK-NEXT:    .cfi_def_cfa_register %rbp
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %r13
; CHECK-NEXT:    pushq %r12
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    subq $24, %rsp
; CHECK-NEXT:    .cfi_offset %rbx, -56
; CHECK-NEXT:    .cfi_offset %r12, -48
; CHECK-NEXT:    .cfi_offset %r13, -40
; CHECK-NEXT:    .cfi_offset %r14, -32
; CHECK-NEXT:    .cfi_offset %r15, -24
; CHECK-NEXT:    movl %r9d, %ebx
; CHECK-NEXT:    movabsq $87960930222080, %r15 # imm = 0x500000000000
; CHECK-NEXT:    movl 0, %r13d
; CHECK-NEXT:    movl %esi, %r12d
; CHECK-NEXT:    # implicit-def: $eax
; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
; CHECK-NEXT:    testb $1, %bl
; CHECK-NEXT:    jne .LBB0_7
; CHECK-NEXT:  # %bb.1: # %if.else
; CHECK-NEXT:    movq %r8, %r14
; CHECK-NEXT:    movl %ecx, %eax
; CHECK-NEXT:    andl $1, %eax
; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
; CHECK-NEXT:    movzbl 544(%rax), %eax
; CHECK-NEXT:    andl $1, %eax
; CHECK-NEXT:    movl %r15d, %r9d
; CHECK-NEXT:    andl $1, %r9d
; CHECK-NEXT:    movl %r14d, %r10d
; CHECK-NEXT:    andl $1, %r10d
; CHECK-NEXT:    movl %esi, %r11d
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    shrl %cl, %r11d
; CHECK-NEXT:    movabsq $17592186044416, %r8 # imm = 0x100000000000
; CHECK-NEXT:    orq %r10, %r8
; CHECK-NEXT:    andl $2, %r11d
; CHECK-NEXT:    testb $1, %bl
; CHECK-NEXT:    cmoveq %r9, %r8
; CHECK-NEXT:    movl %edx, %ecx
; CHECK-NEXT:    orq %rax, %rcx
; CHECK-NEXT:    movq %r13, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
; CHECK-NEXT:    orq $1, %r13
; CHECK-NEXT:    orl %esi, %r11d
; CHECK-NEXT:    movl $1, %edx
; CHECK-NEXT:    je .LBB0_3
; CHECK-NEXT:  # %bb.2: # %if.else
; CHECK-NEXT:    movl (%r8), %edx
; CHECK-NEXT:  .LBB0_3: # %if.else
; CHECK-NEXT:    shlq $5, %rcx
; CHECK-NEXT:    movq %r12, %rsi
; CHECK-NEXT:    shlq $7, %rsi
; CHECK-NEXT:    addq %rcx, %rsi
; CHECK-NEXT:    addq $1248, %rsi # imm = 0x4E0
; CHECK-NEXT:    movq %r13, 0
; CHECK-NEXT:    movq %rdi, %r15
; CHECK-NEXT:    movl %edx, (%rdi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    xorl %edi, %edi
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    callq *%rax
; CHECK-NEXT:    xorq $1, %r14
; CHECK-NEXT:    cmpl $0, (%r14)
; CHECK-NEXT:    je .LBB0_6
; CHECK-NEXT:  # %bb.4: # %if.else
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    je .LBB0_5
; CHECK-NEXT:  .LBB0_6: # %bb19
; CHECK-NEXT:    testb $1, %bl
; CHECK-NEXT:    movq %r15, %rdi
; CHECK-NEXT:    movabsq $87960930222080, %r15 # imm = 0x500000000000
; CHECK-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %r13 # 8-byte Reload
; CHECK-NEXT:    jne .LBB0_8
; CHECK-NEXT:  .LBB0_7: # %if.end69
; CHECK-NEXT:    movl %r13d, 0
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:    xorl %r8d, %r8d
; CHECK-NEXT:    callq *%rax
; CHECK-NEXT:    xorq %r15, %r12
; CHECK-NEXT:    movslq {{[-0-9]+}}(%r{{[sb]}}p), %rax # 4-byte Folded Reload
; CHECK-NEXT:    movzbl (%r12), %ecx
; CHECK-NEXT:    movb %cl, 544(%rax)
; CHECK-NEXT:  .LBB0_8: # %land.lhs.true56
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    addq $24, %rsp
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r12
; CHECK-NEXT:    popq %r13
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    popq %rbp
; CHECK-NEXT:    .cfi_def_cfa %rsp, 8
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB0_5: # %bb
entry:
  %i = load i32, ptr null, align 8
  br i1 %cmp54, label %if.end69, label %if.else

if.else:                                          ; preds = %entry
  %shr18 = and i32 %sub.i, 1
  %idxprom.i = zext i32 %shr18 to i64
  %arrayidx.i = getelementptr %struct.BlockContext, ptr null, i64 0, i32 14, i64 %idxprom.i
  %i1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %i1 to i32
  %and.i = and i32 %conv.i, 1
  %i2 = and i64 87960930222080, 1
  %i3 = inttoptr i64 %i2 to ptr
  %i4 = load i32, ptr %i3, align 4
  %i5 = and i64 %idxprom, 1
  %i6 = or i64 %i5, 17592186044416
  %i7 = inttoptr i64 %i6 to ptr
  %i8 = load i32, ptr %i7, align 4
  %i9 = lshr i32 %bl, %sub.i
  %i10 = and i32 %i9, 2
  %i11 = or i32 %bl, %i10
  %i12 = select i1 %cmp54, i32 %i8, i32 %i4
  %add.i = or i32 %_msprop1966, %and.i
  %idxprom4 = zext i32 %bl to i64
  %idxprom24 = zext i32 %add.i to i64
  %i13 = or i32 %i, 1
  %i14 = zext i32 %i13 to i64
  %.not2329 = icmp eq i32 %i11, 0
  %i15 = select i1 %.not2329, i32 1, i32 %i12
  %arrayidx25 = getelementptr %struct.CdfModeContext, ptr null, i64 0, i32 3, i64 %idxprom4, i64 %idxprom24
  store i64 %i14, ptr null, align 8
  store i32 %i15, ptr %t, align 4
  %call53 = tail call i32 null(ptr null, ptr %arrayidx25, i64 0)
  %i16 = xor i64 %idxprom, 1
  %i17 = inttoptr i64 %i16 to ptr
  %_msld1992 = load i32, ptr %i17, align 8
  %i18 = icmp ne i32 %_msld1992, 0
  %_msprop_icmp1993 = and i1 %i18, false
  br i1 %_msprop_icmp1993, label %bb, label %bb19

bb:                                               ; preds = %if.else
  unreachable

bb19:                                             ; preds = %if.else
  br i1 %cmp54, label %land.lhs.true56, label %if.end69

land.lhs.true56:                                  ; preds = %bb19
  ret i32 0

if.end69:                                         ; preds = %bb19, %entry
  %bx8.011941201 = phi i32 [ %shr18, %bb19 ], [ undef, %entry ]
  store i32 %i, ptr null, align 8
  %call79 = tail call fastcc i32 null(ptr %t, i32 0, i32 0, i32 0, i32 0)
  %idxprom666 = zext i32 %bl to i64
  %i20 = xor i64 %idxprom666, 87960930222080
  %idxprom675 = sext i32 %bx8.011941201 to i64
  %arrayidx676 = getelementptr %struct.BlockContext, ptr null, i64 0, i32 14, i64 %idxprom675
  %i21 = inttoptr i64 %i20 to ptr
  %_msld1414 = load i8, ptr %i21, align 1
  store i8 %_msld1414, ptr %arrayidx676, align 1
  ret i32 0
}

attributes #0 = { "frame-pointer"="all" "target-cpu"="x86-64" }
