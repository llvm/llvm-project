; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=avx | FileCheck %s
define i8 @test_offset(ptr %base) {
; CHECK-LABEL: test_offset:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movb $0, 7(%rdi)
; CHECK-NEXT:    movw $0, 5(%rdi)
; CHECK-NEXT:    movl $0, 1(%rdi)
; CHECK-NEXT:    movl -4(%rdi), %eax
; CHECK-NEXT:    movl %eax, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    movzbl (%rdi), %eax
; CHECK-NEXT:    movb %al, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    movl 1(%rdi), %eax
; CHECK-NEXT:    movl %eax, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    movzwl 5(%rdi), %eax
; CHECK-NEXT:    movw %ax, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    movzbl 7(%rdi), %eax
; CHECK-NEXT:    movb %al, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    movl 8(%rdi), %eax
; CHECK-NEXT:    movl %eax, -{{[0-9]+}}(%rsp)
; CHECK-NEXT:    movzbl -{{[0-9]+}}(%rsp), %eax
; CHECK-NEXT:    popq %rcx
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
entry:
  %z = alloca [128 x i8], align 16
  %gep0 = getelementptr inbounds i8, ptr %base, i64 7
  store volatile i8 0, ptr %gep0
  %gep1 = getelementptr inbounds i8, ptr %base, i64 5
  store volatile i16 0, ptr %gep1
  %gep2 = getelementptr inbounds i8, ptr %base, i64 1
  store volatile i32 0, ptr %gep2

  %y1 = getelementptr inbounds i8, ptr %base, i64 -4
  call void @llvm.memcpy.p0.p0.i64(ptr %z, ptr %y1, i64 16, i1 false)

  %gep4 = getelementptr inbounds [128 x i8], ptr %z, i64 0, i64 4
  %ret = load i8, ptr %gep4
  ret i8 %ret
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1)
