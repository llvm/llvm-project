; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --no_x86_scrub_sp
; RUN: llc < %s -mtriple=x86_64-unknown-unknown | FileCheck %s
@0 = internal unnamed_addr constant [4 x i5] [i5 2, i5 0, i5 2, i5 -1], align 1

; Function Attrs: nobuiltin nounwind
define void @_start() {
; CHECK-LABEL: _start:
; CHECK:       # %bb.0: # %Entry
; CHECK-NEXT:    movl __unnamed_1(%rip), %eax
; CHECK-NEXT:    movl %eax, -12(%rsp)
; CHECK-NEXT:    movzbl -9(%rsp), %ecx
; CHECK-NEXT:    movzbl -10(%rsp), %edx
; CHECK-NEXT:    movzbl -11(%rsp), %esi
; CHECK-NEXT:    movzbl %cl, %edi
; CHECK-NEXT:    shrb %cl
; CHECK-NEXT:    movb %cl, -2(%rsp)
; CHECK-NEXT:    andl $31, %eax
; CHECK-NEXT:    andl $31, %esi
; CHECK-NEXT:    shll $5, %esi
; CHECK-NEXT:    orl %eax, %esi
; CHECK-NEXT:    andl $31, %edx
; CHECK-NEXT:    shll $10, %edx
; CHECK-NEXT:    orl %esi, %edx
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    shll $15, %eax
; CHECK-NEXT:    orl %edx, %eax
; CHECK-NEXT:    movw %ax, -4(%rsp)
; CHECK-NEXT:    movb %dil, -5(%rsp)
; CHECK-NEXT:    cmpb $31, %dil
; CHECK-NEXT:    je .LBB0_2
; CHECK-NEXT:  # %bb.1: # %Then
; CHECK-NEXT:    int3
; CHECK-NEXT:  .LBB0_2: # %EndIf
; CHECK-NEXT:    retq
Entry:
  %x = alloca [4 x i5], align 1
  %y = alloca <4 x i5>, align 4
  %z = alloca i5, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %x, ptr align 1 @0, i64 4, i1 false)
  %0 = load i5, ptr %x
  %1 = insertelement <4 x i5> undef, i5 %0, i32 0
  %2 = getelementptr inbounds [4 x i5], ptr %x, i64 0, i64 1
  %3 = load i5, ptr %2
  %4 = insertelement <4 x i5> %1, i5 %3, i32 1
  %5 = getelementptr inbounds [4 x i5], ptr %x, i64 0, i64 2
  %6 = load i5, ptr %5
  %7 = insertelement <4 x i5> %4, i5 %6, i32 2
  %8 = getelementptr inbounds [4 x i5], ptr %x, i64 0, i64 3
  %9 = load i5, ptr %8
  %10 = insertelement <4 x i5> %7, i5 %9, i32 3
  store <4 x i5> %10, ptr %y, align 4
  %11 = load <4 x i5>, ptr %y
  %12 = extractelement <4 x i5> %11, i32 3
  store i5 %12, ptr %z, align 1
  %13 = load i5, ptr %z, align 1
  %14 = icmp ne i5 %13, -1
  br i1 %14, label %Then, label %Else

Then:                                             ; preds = %Entry
  call void @llvm.debugtrap()
  br label %EndIf

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  ret void
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg)

; Function Attrs: nounwind
declare void @llvm.debugtrap()
