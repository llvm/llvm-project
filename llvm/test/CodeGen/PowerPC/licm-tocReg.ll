; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -verify-machineinstrs -mtriple=powerpc64le-unknown-linux-gnu < %s | FileCheck -check-prefixes=CHECKLX %s
; RUN: llc -verify-machineinstrs -mtriple=powerpc64-ibm-aix-xcoff < %s | FileCheck -check-prefixes=CHECKAIX %s
; RUN: llc -verify-machineinstrs -mtriple=powerpc-ibm-aix-xcoff < %s | FileCheck -check-prefixes=CHECKAIX32 %s

; The instructions ADDIStocHA8/LDtocL are used to calculate the address of
; globals. The ones that are in bb.3.if.end could not be hoisted by Machine
; LICM due to BCTRL_LDinto_toc in bb2.if.then.  This call causes the compiler
; to insert a save TOC to stack before the call and load into X2 to restore TOC
; after. By communicating to Machine LICM that X2 is guaranteed to have the
; same value before and after BCTRL_LDinto_toc, these instructions can be
; hoisted out of bb.3.if.end to outside of the loop.

; Pre Machine LICM MIR
;
;body:
;  bb.0.entry:
;    successors: %bb.2.if.then(0x40000000), %bb.3.if.end(0x40000000)
;    liveins: %x3
;
;    %4 = COPY %x3
;    %5 = ADDIStocHA8 %x2, @ga
;    %6 = LDtocL @ga, killed %5 :: (load (s64) from got)
;    %7 = LWZ 0, %6 :: (volatile dereferenceable load (s32) from @ga)
;    %8 = ADDIStocHA8 %x2, @gb
;    %9 = LDtocL @gb, killed %8 :: (load (s64) from got)
;    %10 = LWZ 0, killed %9 :: (volatile dereferenceable load (s32) from @gb)
;    %0 = LWZ 0, %6 :: (volatile dereferenceable load (s32) from @ga)
;    %11 = CMPW killed %7, killed %10
;    BCC 44, killed %11, %bb.2.if.then
;    B %bb.3.if.end
;
;  bb.2.if.then:
;    %1 = PHI %0, %bb.0.entry, %3, %bb.3.if.end
;    ADJCALLSTACKDOWN 32, 0, implicit-def dead %r1, implicit %r1
;    %20 = COPY %x2
;    STD %20, 24, %x1 :: (store (s64) into stack + 24)
;    %21 = EXTSW_32_64 %1
;    %x3 = COPY %21
;    %x12 = COPY %4
;    MTCTR8 %4, implicit-def %ctr8
;    BCTRL8_LDinto_toc 24, %x1, csr_ppc64_altivec, implicit-def dead %lr8, implicit-def dead %x2, implicit %ctr8, implicit %rm, implicit %x3, implicit %x12, implicit %x2, implicit-def %r1, implicit-def %x3
;    ADJCALLSTACKUP 32, 0, implicit-def dead %r1, implicit %r1
;    %22 = COPY %x3
;    %x3 = COPY %22
;    BLR8 implicit %lr8, implicit %rm, implicit %x3
;
;  bb.3.if.end:
;    successors: %bb.2.if.then(0x04000000), %bb.3.if.end(0x7c000000)
;
;    %2 = PHI %0, %bb.0.entry, %3, %bb.3.if.end
;    %12 = ADDI %2, 1
;    %13 = ADDIStocHA8 %x2, @ga
;    %14 = LDtocL @ga, killed %13 :: (load (s64) from got)
;    STW killed %12, 0, %14 :: (volatile store (s32) into @ga)
;    %15 = LWZ 0, %14 :: (volatile dereferenceable load (s32) from @ga)
;    %16 = ADDIStocHA8 %x2, @gb
;    %17 = LDtocL @gb, killed %16 :: (load (s64) from got)
;    %18 = LWZ 0, killed %17 :: (volatile dereferenceable load (s32) from @gb)
;    %3 = LWZ 0, %14 :: (volatile dereferenceable load (s32) from @ga)
;    %19 = CMPW killed %15, killed %18
;    BCC 44, killed %19, %bb.2.if.then
;    B %bb.3.if.end

@ga = external global i32, align 4
@gb = external global i32, align 4
define signext i32 @test(ptr nocapture %FP) local_unnamed_addr #0 {
; CHECKLX-LABEL: test:
; CHECKLX:       # %bb.0: # %entry
; CHECKLX-NEXT:    mr 12, 3
; CHECKLX-NEXT:    addis 3, 2, .LC0@toc@ha
; CHECKLX-NEXT:    addis 4, 2, .LC1@toc@ha
; CHECKLX-NEXT:    ld 3, .LC0@toc@l(3)
; CHECKLX-NEXT:    ld 4, .LC1@toc@l(4)
; CHECKLX-NEXT:    lwz 6, 0(3)
; CHECKLX-NEXT:    .p2align 5
; CHECKLX-NEXT:  .LBB0_1: # %if.end
; CHECKLX-NEXT:    #
; CHECKLX-NEXT:    lwz 7, 0(4)
; CHECKLX-NEXT:    lwz 5, 0(3)
; CHECKLX-NEXT:    cmpw 6, 7
; CHECKLX-NEXT:    bgt 0, .LBB0_3
; CHECKLX-NEXT:  # %bb.2: # %if.end
; CHECKLX-NEXT:    #
; CHECKLX-NEXT:    addi 5, 5, 1
; CHECKLX-NEXT:    stw 5, 0(3)
; CHECKLX-NEXT:    lwz 6, 0(3)
; CHECKLX-NEXT:    b .LBB0_1
; CHECKLX-NEXT:  .LBB0_3: # %if.then
; CHECKLX-NEXT:    mflr 0
; CHECKLX-NEXT:    stdu 1, -32(1)
; CHECKLX-NEXT:    std 2, 24(1)
; CHECKLX-NEXT:    std 0, 48(1)
; CHECKLX-NEXT:    .cfi_def_cfa_offset 32
; CHECKLX-NEXT:    .cfi_offset lr, 16
; CHECKLX-NEXT:    mtctr 12
; CHECKLX-NEXT:    extsw 3, 5
; CHECKLX-NEXT:    bctrl
; CHECKLX-NEXT:    ld 2, 24(1)
; CHECKLX-NEXT:    addi 1, 1, 32
; CHECKLX-NEXT:    ld 0, 16(1)
; CHECKLX-NEXT:    mtlr 0
; CHECKLX-NEXT:    blr
;
; CHECKAIX-LABEL: test:
; CHECKAIX:       # %bb.0: # %entry
; CHECKAIX-NEXT:    ld 4, L..C0(2) # @ga
; CHECKAIX-NEXT:    ld 5, L..C1(2) # @gb
; CHECKAIX-NEXT:  L..BB0_1: # %if.end
; CHECKAIX-NEXT:    #
; CHECKAIX-NEXT:    lwz 6, 0(4)
; CHECKAIX-NEXT:    lwz 7, 0(5)
; CHECKAIX-NEXT:    cmpw 6, 7
; CHECKAIX-NEXT:    lwz 6, 0(4)
; CHECKAIX-NEXT:    bgt 0, L..BB0_3
; CHECKAIX-NEXT:  # %bb.2: # %if.end
; CHECKAIX-NEXT:    #
; CHECKAIX-NEXT:    addi 6, 6, 1
; CHECKAIX-NEXT:    stw 6, 0(4)
; CHECKAIX-NEXT:    b L..BB0_1
; CHECKAIX-NEXT:  L..BB0_3: # %if.then
; CHECKAIX-NEXT:    mflr 0
; CHECKAIX-NEXT:    stdu 1, -112(1)
; CHECKAIX-NEXT:    ld 4, 0(3)
; CHECKAIX-NEXT:    std 0, 128(1)
; CHECKAIX-NEXT:    ld 11, 16(3)
; CHECKAIX-NEXT:    std 2, 40(1)
; CHECKAIX-NEXT:    ld 2, 8(3)
; CHECKAIX-NEXT:    extsw 3, 6
; CHECKAIX-NEXT:    mtctr 4
; CHECKAIX-NEXT:    bctrl
; CHECKAIX-NEXT:    ld 2, 40(1)
; CHECKAIX-NEXT:    addi 1, 1, 112
; CHECKAIX-NEXT:    ld 0, 16(1)
; CHECKAIX-NEXT:    mtlr 0
; CHECKAIX-NEXT:    blr
;
; CHECKAIX32-LABEL: test:
; CHECKAIX32:       # %bb.0: # %entry
; CHECKAIX32-NEXT:    lwz 5, L..C0(2) # @ga
; CHECKAIX32-NEXT:    lwz 6, L..C1(2) # @gb
; CHECKAIX32-NEXT:  L..BB0_1: # %if.end
; CHECKAIX32-NEXT:    #
; CHECKAIX32-NEXT:    lwz 4, 0(5)
; CHECKAIX32-NEXT:    lwz 7, 0(6)
; CHECKAIX32-NEXT:    cmpw 4, 7
; CHECKAIX32-NEXT:    lwz 4, 0(5)
; CHECKAIX32-NEXT:    bgt 0, L..BB0_3
; CHECKAIX32-NEXT:  # %bb.2: # %if.end
; CHECKAIX32-NEXT:    #
; CHECKAIX32-NEXT:    addi 4, 4, 1
; CHECKAIX32-NEXT:    stw 4, 0(5)
; CHECKAIX32-NEXT:    b L..BB0_1
; CHECKAIX32-NEXT:  L..BB0_3: # %if.then
; CHECKAIX32-NEXT:    mflr 0
; CHECKAIX32-NEXT:    stwu 1, -64(1)
; CHECKAIX32-NEXT:    lwz 5, 0(3)
; CHECKAIX32-NEXT:    stw 0, 72(1)
; CHECKAIX32-NEXT:    stw 2, 20(1)
; CHECKAIX32-NEXT:    mtctr 5
; CHECKAIX32-NEXT:    lwz 11, 8(3)
; CHECKAIX32-NEXT:    lwz 2, 4(3)
; CHECKAIX32-NEXT:    mr 3, 4
; CHECKAIX32-NEXT:    bctrl
; CHECKAIX32-NEXT:    lwz 2, 20(1)
; CHECKAIX32-NEXT:    addi 1, 1, 64
; CHECKAIX32-NEXT:    lwz 0, 8(1)
; CHECKAIX32-NEXT:    mtlr 0
; CHECKAIX32-NEXT:    blr
entry:
  %0 = load volatile i32, ptr @ga, align 4
  %1 = load volatile i32, ptr @gb, align 4
  %cmp1 = icmp sgt i32 %0, %1
  %2 = load volatile i32, ptr @ga, align 4
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %if.end, %entry
  %.lcssa = phi i32 [ %2, %entry ], [ %6, %if.end ]
  %call = tail call signext i32 %FP(i32 signext %.lcssa) #1
  ret i32 %call

if.end:                                           ; preds = %entry, %if.end
  %3 = phi i32 [ %6, %if.end ], [ %2, %entry ]
  %inc = add nsw i32 %3, 1
  store volatile i32 %inc, ptr @ga, align 4
  %4 = load volatile i32, ptr @ga, align 4
  %5 = load volatile i32, ptr @gb, align 4
  %cmp = icmp sgt i32 %4, %5
  %6 = load volatile i32, ptr @ga, align 4
  br i1 %cmp, label %if.then, label %if.end
}
