; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc -verify-machineinstrs -mcpu=pwr7 < %s | FileCheck %s
; RUN: llc -verify-machineinstrs -O1 -mcpu=pwr7 < %s | FileCheck %s
; RUN: llc -verify-machineinstrs -mcpu=pwr7 -ppc-gen-isel=false  < %s | FileCheck --check-prefix=CHECK-NO-ISEL %s
; RUN: llc -verify-machineinstrs -O1 -mcpu=pwr7 -ppc-gen-isel=false < %s | FileCheck --check-prefix=CHECK-NO-ISEL %s

target datalayout = "E-m:e-i64:64-n32:64"
target triple = "powerpc64-unknown-linux-gnu"

define zeroext i1 @testi1(i1 zeroext %b1, i1 zeroext %b2) #0 {
; CHECK-LABEL: testi1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi. 3, 3, 1
; CHECK-NEXT:    crmove 20, 1
; CHECK-NEXT:    andi. 3, 4, 1
; CHECK-NEXT:    li 3, 0
; CHECK-NEXT:    li 4, 1
; CHECK-NEXT:    #APP
; CHECK-NEXT:    crand 20, 20, 1
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    isel 3, 4, 3, 20
; CHECK-NEXT:    blr
;
; CHECK-NO-ISEL-LABEL: testi1:
; CHECK-NO-ISEL:       # %bb.0: # %entry
; CHECK-NO-ISEL-NEXT:    andi. 3, 3, 1
; CHECK-NO-ISEL-NEXT:    crmove 20, 1
; CHECK-NO-ISEL-NEXT:    andi. 3, 4, 1
; CHECK-NO-ISEL-NEXT:    li 3, 0
; CHECK-NO-ISEL-NEXT:    li 4, 1
; CHECK-NO-ISEL-NEXT:    #APP
; CHECK-NO-ISEL-NEXT:    crand 20, 20, 1
; CHECK-NO-ISEL-NEXT:    #NO_APP
; CHECK-NO-ISEL-NEXT:    bc 12, 20, .LBB0_1
; CHECK-NO-ISEL-NEXT:    blr
; CHECK-NO-ISEL-NEXT:  .LBB0_1: # %entry
; CHECK-NO-ISEL-NEXT:    addi 3, 4, 0
; CHECK-NO-ISEL-NEXT:    blr
entry:
  %0 = tail call i8 asm "crand $0, $1, $2", "=^wc,^wc,^wc"(i1 %b1, i1 %b2) #0
  %1 = and i8 %0, 1
  %tobool3 = icmp ne i8 %1, 0
  ret i1 %tobool3

}

define signext i32 @testi32(i32 signext %b1, i32 signext %b2) #0 {
; CHECK-LABEL: testi32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi. 3, 3, 1
; CHECK-NEXT:    crmove 20, 1
; CHECK-NEXT:    andi. 3, 4, 1
; CHECK-NEXT:    li 3, 0
; CHECK-NEXT:    li 4, -1
; CHECK-NEXT:    #APP
; CHECK-NEXT:    crand 20, 20, 1
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    isel 3, 4, 3, 20
; CHECK-NEXT:    blr
;
; CHECK-NO-ISEL-LABEL: testi32:
; CHECK-NO-ISEL:       # %bb.0: # %entry
; CHECK-NO-ISEL-NEXT:    andi. 3, 3, 1
; CHECK-NO-ISEL-NEXT:    crmove 20, 1
; CHECK-NO-ISEL-NEXT:    andi. 3, 4, 1
; CHECK-NO-ISEL-NEXT:    li 3, 0
; CHECK-NO-ISEL-NEXT:    li 4, -1
; CHECK-NO-ISEL-NEXT:    #APP
; CHECK-NO-ISEL-NEXT:    crand 20, 20, 1
; CHECK-NO-ISEL-NEXT:    #NO_APP
; CHECK-NO-ISEL-NEXT:    bc 12, 20, .LBB1_1
; CHECK-NO-ISEL-NEXT:    blr
; CHECK-NO-ISEL-NEXT:  .LBB1_1: # %entry
; CHECK-NO-ISEL-NEXT:    addi 3, 4, 0
; CHECK-NO-ISEL-NEXT:    blr
entry:
  %0 = tail call i32 asm "crand $0, $1, $2", "=^wc,^wc,^wc"(i32 %b1, i32 %b2) #0
  ret i32 %0

; The ABI sign_extend should combine with the any_extend from the asm result,
; and the result will be 0 or -1. This highlights the fact that only the first
; bit is meaningful.
}

define zeroext i8 @testi8(i8 zeroext %b1, i8 zeroext %b2) #0 {
; CHECK-LABEL: testi8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andi. 3, 3, 1
; CHECK-NEXT:    crmove 20, 1
; CHECK-NEXT:    andi. 3, 4, 1
; CHECK-NEXT:    li 3, 0
; CHECK-NEXT:    li 4, 1
; CHECK-NEXT:    #APP
; CHECK-NEXT:    crand 20, 20, 1
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    isel 3, 4, 3, 20
; CHECK-NEXT:    blr
;
; CHECK-NO-ISEL-LABEL: testi8:
; CHECK-NO-ISEL:       # %bb.0: # %entry
; CHECK-NO-ISEL-NEXT:    andi. 3, 3, 1
; CHECK-NO-ISEL-NEXT:    crmove 20, 1
; CHECK-NO-ISEL-NEXT:    andi. 3, 4, 1
; CHECK-NO-ISEL-NEXT:    li 3, 0
; CHECK-NO-ISEL-NEXT:    li 4, 1
; CHECK-NO-ISEL-NEXT:    #APP
; CHECK-NO-ISEL-NEXT:    crand 20, 20, 1
; CHECK-NO-ISEL-NEXT:    #NO_APP
; CHECK-NO-ISEL-NEXT:    bc 12, 20, .LBB2_1
; CHECK-NO-ISEL-NEXT:    blr
; CHECK-NO-ISEL-NEXT:  .LBB2_1: # %entry
; CHECK-NO-ISEL-NEXT:    addi 3, 4, 0
; CHECK-NO-ISEL-NEXT:    blr
entry:
  %0 = tail call i8 asm "crand $0, $1, $2", "=^wc,^wc,^wc"(i8 %b1, i8 %b2) #0
  ret i8 %0

}

attributes #0 = { nounwind "target-features"="+crbits" }

