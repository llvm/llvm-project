; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc   -mtriple=powerpc-ibm-aix-xcoff -mcpu=pwr9 -ppc-asm-full-reg-names < %s | FileCheck --check-prefix=PWR9 %s
; RUN: llc   -mtriple=powerpc-ibm-aixi-xcoff -mcpu=pwr10 -ppc-asm-full-reg-names < %s | FileCheck --check-prefix=PWR10 %s
; RUN: llc   -mtriple=powerpc64-ibm-aix-xcoff -mcpu=pwr9 -ppc-asm-full-reg-names < %s | FileCheck --check-prefix=BIT64-PWR9 %s
; RUN: llc   -mtriple=powerpc64-ibm-aix-xcoff -mcpu=pwr10 -ppc-asm-full-reg-names < %s | FileCheck --check-prefix=PWR10 %s
; RUN: llc   -mtriple=powerpc64le-unknown-linux-gnu -mcpu=pwr9 -ppc-asm-full-reg-names < %s | FileCheck --check-prefix=BIT64-PWR9 %s
; RUN: llc   -mtriple=powerpc64le-unknown-linux-gnu -mcpu=pwr10 -ppc-asm-full-reg-names < %s | FileCheck --check-prefix=PWR10 %s

define noundef zeroext i1 @_Z16ossIsValidDoubled(double noundef %in) local_unnamed_addr  {
; PWR9-LABEL: _Z16ossIsValidDoubled:
; PWR9:       # %bb.0: # %entry
; PWR9-NEXT:    xststdcdp cr0, f1, 115
; PWR9-NEXT:    li r3, 0
; PWR9-NEXT:    li r4, 1
; PWR9-NEXT:    iseleq r3, r4, r3
; PWR9-NEXT:    cntlzw r3, r3
; PWR9-NEXT:    rlwinm r3, r3, 27, 31, 31
; PWR9-NEXT:    blr
;
; PWR10-LABEL: _Z16ossIsValidDoubled:
; PWR10:       # %bb.0: # %entry
; PWR10-NEXT:    xststdcdp cr0, f1, 115
; PWR10-NEXT:    li r3, 0
; PWR10-NEXT:    li r4, 1
; PWR10-NEXT:    iseleq r3, r4, r3
; PWR10-NEXT:    cntlzw r3, r3
; PWR10-NEXT:    rlwinm r3, r3, 27, 31, 31
; PWR10-NEXT:    blr
;
; BIT64-PWR9-LABEL: _Z16ossIsValidDoubled:
; BIT64-PWR9:       # %bb.0: # %entry
; BIT64-PWR9-NEXT:    xststdcdp cr0, f1, 115
; BIT64-PWR9-NEXT:    li r3, 0
; BIT64-PWR9-NEXT:    li r4, 1
; BIT64-PWR9-NEXT:    iseleq r3, r4, r3
; BIT64-PWR9-NEXT:    cntlzw r3, r3
; BIT64-PWR9-NEXT:    srwi r3, r3, 5
; BIT64-PWR9-NEXT:    blr

entry:
  %test_data_class = tail call i32 @llvm.ppc.test.data.class.f64(double %in, i32 115)
  %tobool.not = icmp eq i32 %test_data_class, 0
  ret i1 %tobool.not
}

declare i32 @llvm.ppc.test.data.class.f64(double, i32 immarg)
