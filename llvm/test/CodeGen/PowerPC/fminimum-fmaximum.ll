; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -mtriple=powerpc64le-unknown-linux-gnu -mcpu=pwr8 -mattr=-vsx < %s | FileCheck %s --check-prefix=NOVSX
; RUN: llc -mtriple=powerpc64le-unknown-linux-gnu -mcpu=pwr8 < %s | FileCheck %s --check-prefix=VSX
; RUN: llc -mtriple=powerpc64-ibm-aix -mcpu=pwr8 < %s | FileCheck %s --check-prefix=AIX

define float @f32_minimum(float %a, float %b) {
; NOVSX-LABEL: f32_minimum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    fcmpu 0, 2, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    fmr 1, 2
; NOVSX-NEXT:    bc 12, 3, .LBB0_2
; NOVSX-NEXT:  # %bb.1: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:  .LBB0_2: # %entry
; NOVSX-NEXT:    fcmpu 0, 1, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    stfs 1, -4(1)
; NOVSX-NEXT:    cror 20, 0, 3
; NOVSX-NEXT:    bc 12, 20, .LBB0_4
; NOVSX-NEXT:  # %bb.3: # %entry
; NOVSX-NEXT:    fmr 0, 2
; NOVSX-NEXT:  .LBB0_4: # %entry
; NOVSX-NEXT:    addis 3, 2, .LCPI0_0@toc@ha
; NOVSX-NEXT:    lfs 2, .LCPI0_0@toc@l(3)
; NOVSX-NEXT:    lwz 3, -4(1)
; NOVSX-NEXT:    fcmpu 0, 0, 2
; NOVSX-NEXT:    bc 4, 2, .LBB0_6
; NOVSX-NEXT:  # %bb.5: # %entry
; NOVSX-NEXT:    cmpwi 3, 0
; NOVSX-NEXT:    bclr 12, 0, 0
; NOVSX-NEXT:  .LBB0_6: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:    blr
;
; VSX-LABEL: f32_minimum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    fcmpu 0, 1, 2
; VSX-NEXT:    bc 12, 3, .LBB0_2
; VSX-NEXT:  # %bb.1: # %entry
; VSX-NEXT:    xsmindp 1, 1, 2
; VSX-NEXT:    blr
; VSX-NEXT:  .LBB0_2:
; VSX-NEXT:    addis 3, 2, .LCPI0_0@toc@ha
; VSX-NEXT:    lfs 1, .LCPI0_0@toc@l(3)
; VSX-NEXT:    blr
;
; AIX-LABEL: f32_minimum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    fcmpu 0, 1, 2
; AIX-NEXT:    bc 12, 3, L..BB0_2
; AIX-NEXT:  # %bb.1: # %entry
; AIX-NEXT:    xsmindp 1, 1, 2
; AIX-NEXT:    blr
; AIX-NEXT:  L..BB0_2:
; AIX-NEXT:    ld 3, L..C0(2) # %const.0
; AIX-NEXT:    lfs 1, 0(3)
; AIX-NEXT:    blr
entry:
  %m = call float @llvm.minimum.f32(float %a, float %b)
  ret float %m
}

define float @f32_maximum(float %a, float %b) {
; NOVSX-LABEL: f32_maximum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    fcmpu 0, 2, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    fmr 1, 2
; NOVSX-NEXT:    bc 12, 3, .LBB1_2
; NOVSX-NEXT:  # %bb.1: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:  .LBB1_2: # %entry
; NOVSX-NEXT:    fcmpu 0, 1, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    stfs 1, -4(1)
; NOVSX-NEXT:    cror 20, 1, 3
; NOVSX-NEXT:    bc 12, 20, .LBB1_4
; NOVSX-NEXT:  # %bb.3: # %entry
; NOVSX-NEXT:    fmr 0, 2
; NOVSX-NEXT:  .LBB1_4: # %entry
; NOVSX-NEXT:    addis 3, 2, .LCPI1_0@toc@ha
; NOVSX-NEXT:    lfs 2, .LCPI1_0@toc@l(3)
; NOVSX-NEXT:    lwz 3, -4(1)
; NOVSX-NEXT:    fcmpu 0, 0, 2
; NOVSX-NEXT:    bc 4, 2, .LBB1_6
; NOVSX-NEXT:  # %bb.5: # %entry
; NOVSX-NEXT:    cmpwi 3, -1
; NOVSX-NEXT:    bclr 12, 1, 0
; NOVSX-NEXT:  .LBB1_6: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:    blr
;
; VSX-LABEL: f32_maximum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    fcmpu 0, 1, 2
; VSX-NEXT:    bc 12, 3, .LBB1_2
; VSX-NEXT:  # %bb.1: # %entry
; VSX-NEXT:    xsmaxdp 1, 1, 2
; VSX-NEXT:    blr
; VSX-NEXT:  .LBB1_2:
; VSX-NEXT:    addis 3, 2, .LCPI1_0@toc@ha
; VSX-NEXT:    lfs 1, .LCPI1_0@toc@l(3)
; VSX-NEXT:    blr
;
; AIX-LABEL: f32_maximum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    fcmpu 0, 1, 2
; AIX-NEXT:    bc 12, 3, L..BB1_2
; AIX-NEXT:  # %bb.1: # %entry
; AIX-NEXT:    xsmaxdp 1, 1, 2
; AIX-NEXT:    blr
; AIX-NEXT:  L..BB1_2:
; AIX-NEXT:    ld 3, L..C1(2) # %const.0
; AIX-NEXT:    lfs 1, 0(3)
; AIX-NEXT:    blr
entry:
  %m = call float @llvm.maximum.f32(float %a, float %b)
  ret float %m
}

define double @f64_minimum(double %a, double %b) {
; NOVSX-LABEL: f64_minimum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    fcmpu 0, 2, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    fmr 1, 2
; NOVSX-NEXT:    bc 12, 3, .LBB2_2
; NOVSX-NEXT:  # %bb.1: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:  .LBB2_2: # %entry
; NOVSX-NEXT:    fcmpu 0, 1, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    stfd 1, -8(1)
; NOVSX-NEXT:    cror 20, 0, 3
; NOVSX-NEXT:    bc 12, 20, .LBB2_4
; NOVSX-NEXT:  # %bb.3: # %entry
; NOVSX-NEXT:    fmr 0, 2
; NOVSX-NEXT:  .LBB2_4: # %entry
; NOVSX-NEXT:    addis 3, 2, .LCPI2_0@toc@ha
; NOVSX-NEXT:    lfs 2, .LCPI2_0@toc@l(3)
; NOVSX-NEXT:    ld 3, -8(1)
; NOVSX-NEXT:    fcmpu 0, 0, 2
; NOVSX-NEXT:    bc 4, 2, .LBB2_6
; NOVSX-NEXT:  # %bb.5: # %entry
; NOVSX-NEXT:    cmpdi 3, 0
; NOVSX-NEXT:    bclr 12, 0, 0
; NOVSX-NEXT:  .LBB2_6: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:    blr
;
; VSX-LABEL: f64_minimum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    fcmpu 0, 1, 2
; VSX-NEXT:    bc 12, 3, .LBB2_2
; VSX-NEXT:  # %bb.1: # %entry
; VSX-NEXT:    xsmindp 1, 1, 2
; VSX-NEXT:    blr
; VSX-NEXT:  .LBB2_2:
; VSX-NEXT:    addis 3, 2, .LCPI2_0@toc@ha
; VSX-NEXT:    lfs 1, .LCPI2_0@toc@l(3)
; VSX-NEXT:    blr
;
; AIX-LABEL: f64_minimum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    fcmpu 0, 1, 2
; AIX-NEXT:    bc 12, 3, L..BB2_2
; AIX-NEXT:  # %bb.1: # %entry
; AIX-NEXT:    xsmindp 1, 1, 2
; AIX-NEXT:    blr
; AIX-NEXT:  L..BB2_2:
; AIX-NEXT:    ld 3, L..C2(2) # %const.0
; AIX-NEXT:    lfs 1, 0(3)
; AIX-NEXT:    blr
entry:
  %m = call double @llvm.minimum.f64(double %a, double %b)
  ret double %m
}

define double @f64_maximum(double %a, double %b) {
; NOVSX-LABEL: f64_maximum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    fcmpu 0, 2, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    fmr 1, 2
; NOVSX-NEXT:    bc 12, 3, .LBB3_2
; NOVSX-NEXT:  # %bb.1: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:  .LBB3_2: # %entry
; NOVSX-NEXT:    fcmpu 0, 1, 2
; NOVSX-NEXT:    fmr 0, 1
; NOVSX-NEXT:    stfd 1, -8(1)
; NOVSX-NEXT:    cror 20, 1, 3
; NOVSX-NEXT:    bc 12, 20, .LBB3_4
; NOVSX-NEXT:  # %bb.3: # %entry
; NOVSX-NEXT:    fmr 0, 2
; NOVSX-NEXT:  .LBB3_4: # %entry
; NOVSX-NEXT:    addis 3, 2, .LCPI3_0@toc@ha
; NOVSX-NEXT:    lfs 2, .LCPI3_0@toc@l(3)
; NOVSX-NEXT:    ld 3, -8(1)
; NOVSX-NEXT:    fcmpu 0, 0, 2
; NOVSX-NEXT:    bc 4, 2, .LBB3_6
; NOVSX-NEXT:  # %bb.5: # %entry
; NOVSX-NEXT:    cmpdi 3, -1
; NOVSX-NEXT:    bclr 12, 1, 0
; NOVSX-NEXT:  .LBB3_6: # %entry
; NOVSX-NEXT:    fmr 1, 0
; NOVSX-NEXT:    blr
;
; VSX-LABEL: f64_maximum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    fcmpu 0, 1, 2
; VSX-NEXT:    bc 12, 3, .LBB3_2
; VSX-NEXT:  # %bb.1: # %entry
; VSX-NEXT:    xsmaxdp 1, 1, 2
; VSX-NEXT:    blr
; VSX-NEXT:  .LBB3_2:
; VSX-NEXT:    addis 3, 2, .LCPI3_0@toc@ha
; VSX-NEXT:    lfs 1, .LCPI3_0@toc@l(3)
; VSX-NEXT:    blr
;
; AIX-LABEL: f64_maximum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    fcmpu 0, 1, 2
; AIX-NEXT:    bc 12, 3, L..BB3_2
; AIX-NEXT:  # %bb.1: # %entry
; AIX-NEXT:    xsmaxdp 1, 1, 2
; AIX-NEXT:    blr
; AIX-NEXT:  L..BB3_2:
; AIX-NEXT:    ld 3, L..C3(2) # %const.0
; AIX-NEXT:    lfs 1, 0(3)
; AIX-NEXT:    blr
entry:
  %m = call double @llvm.maximum.f64(double %a, double %b)
  ret double %m
}

define <4 x float> @v4f32_minimum(<4 x float> %a, <4 x float> %b) {
; NOVSX-LABEL: v4f32_minimum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    vcmpeqfp 4, 3, 3
; NOVSX-NEXT:    addi 3, 1, -48
; NOVSX-NEXT:    vnot 4, 4
; NOVSX-NEXT:    stvx 3, 0, 3
; NOVSX-NEXT:    addi 3, 1, -32
; NOVSX-NEXT:    vsel 2, 2, 3, 4
; NOVSX-NEXT:    vxor 3, 3, 3
; NOVSX-NEXT:    stvx 2, 0, 3
; NOVSX-NEXT:    vcmpgtsw 4, 3, 2
; NOVSX-NEXT:    lwz 3, -36(1)
; NOVSX-NEXT:    lwz 4, -20(1)
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    isellt 3, 4, 3
; NOVSX-NEXT:    lwz 4, -24(1)
; NOVSX-NEXT:    stw 3, -4(1)
; NOVSX-NEXT:    lwz 3, -40(1)
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    isellt 3, 4, 3
; NOVSX-NEXT:    lwz 4, -28(1)
; NOVSX-NEXT:    stw 3, -8(1)
; NOVSX-NEXT:    lwz 3, -44(1)
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    isellt 3, 4, 3
; NOVSX-NEXT:    lwz 4, -32(1)
; NOVSX-NEXT:    stw 3, -12(1)
; NOVSX-NEXT:    lwz 3, -48(1)
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    isellt 3, 4, 3
; NOVSX-NEXT:    stw 3, -16(1)
; NOVSX-NEXT:    addi 3, 1, -16
; NOVSX-NEXT:    lvx 5, 0, 3
; NOVSX-NEXT:    vcmpeqfp 3, 5, 3
; NOVSX-NEXT:    vsel 2, 5, 2, 4
; NOVSX-NEXT:    vsel 2, 5, 2, 3
; NOVSX-NEXT:    blr
;
; VSX-LABEL: v4f32_minimum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    xvcmpeqsp 1, 35, 35
; VSX-NEXT:    xvcmpeqsp 2, 34, 34
; VSX-NEXT:    addis 3, 2, .LCPI4_0@toc@ha
; VSX-NEXT:    addi 3, 3, .LCPI4_0@toc@l
; VSX-NEXT:    xxlnor 1, 1, 1
; VSX-NEXT:    xxlnor 2, 2, 2
; VSX-NEXT:    xvminsp 0, 34, 35
; VSX-NEXT:    xxlor 1, 2, 1
; VSX-NEXT:    lxvd2x 2, 0, 3
; VSX-NEXT:    xxsel 34, 0, 2, 1
; VSX-NEXT:    blr
;
; AIX-LABEL: v4f32_minimum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    xvcmpeqsp 1, 35, 35
; AIX-NEXT:    xvcmpeqsp 2, 34, 34
; AIX-NEXT:    ld 3, L..C4(2) # %const.0
; AIX-NEXT:    xvminsp 0, 34, 35
; AIX-NEXT:    xxlnor 1, 1, 1
; AIX-NEXT:    xxlnor 2, 2, 2
; AIX-NEXT:    xxlor 1, 2, 1
; AIX-NEXT:    lxvw4x 2, 0, 3
; AIX-NEXT:    xxsel 34, 0, 2, 1
; AIX-NEXT:    blr
entry:
  %m = call <4 x float> @llvm.minimum.v4f32(<4 x float> %a, <4 x float> %b)
  ret <4 x float> %m
}

define <4 x float> @v4f32_maximum(<4 x float> %a, <4 x float> %b) {
; NOVSX-LABEL: v4f32_maximum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    vcmpeqfp 4, 3, 3
; NOVSX-NEXT:    addi 3, 1, -48
; NOVSX-NEXT:    vnot 4, 4
; NOVSX-NEXT:    stvx 3, 0, 3
; NOVSX-NEXT:    addi 3, 1, -32
; NOVSX-NEXT:    vsel 2, 2, 3, 4
; NOVSX-NEXT:    vxor 3, 3, 3
; NOVSX-NEXT:    stvx 2, 0, 3
; NOVSX-NEXT:    vcmpgtsw 4, 3, 2
; NOVSX-NEXT:    lwz 3, -36(1)
; NOVSX-NEXT:    lwz 4, -20(1)
; NOVSX-NEXT:    vnot 4, 4
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    iselgt 3, 4, 3
; NOVSX-NEXT:    lwz 4, -24(1)
; NOVSX-NEXT:    stw 3, -4(1)
; NOVSX-NEXT:    lwz 3, -40(1)
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    iselgt 3, 4, 3
; NOVSX-NEXT:    lwz 4, -28(1)
; NOVSX-NEXT:    stw 3, -8(1)
; NOVSX-NEXT:    lwz 3, -44(1)
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    iselgt 3, 4, 3
; NOVSX-NEXT:    lwz 4, -32(1)
; NOVSX-NEXT:    stw 3, -12(1)
; NOVSX-NEXT:    lwz 3, -48(1)
; NOVSX-NEXT:    cmplw 4, 3
; NOVSX-NEXT:    iselgt 3, 4, 3
; NOVSX-NEXT:    stw 3, -16(1)
; NOVSX-NEXT:    addi 3, 1, -16
; NOVSX-NEXT:    lvx 5, 0, 3
; NOVSX-NEXT:    vcmpeqfp 3, 5, 3
; NOVSX-NEXT:    vsel 2, 5, 2, 4
; NOVSX-NEXT:    vsel 2, 5, 2, 3
; NOVSX-NEXT:    blr
;
; VSX-LABEL: v4f32_maximum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    xvcmpeqsp 1, 35, 35
; VSX-NEXT:    xvcmpeqsp 2, 34, 34
; VSX-NEXT:    addis 3, 2, .LCPI5_0@toc@ha
; VSX-NEXT:    addi 3, 3, .LCPI5_0@toc@l
; VSX-NEXT:    xxlnor 1, 1, 1
; VSX-NEXT:    xxlnor 2, 2, 2
; VSX-NEXT:    xvmaxsp 0, 34, 35
; VSX-NEXT:    xxlor 1, 2, 1
; VSX-NEXT:    lxvd2x 2, 0, 3
; VSX-NEXT:    xxsel 34, 0, 2, 1
; VSX-NEXT:    blr
;
; AIX-LABEL: v4f32_maximum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    xvcmpeqsp 1, 35, 35
; AIX-NEXT:    xvcmpeqsp 2, 34, 34
; AIX-NEXT:    ld 3, L..C5(2) # %const.0
; AIX-NEXT:    xvmaxsp 0, 34, 35
; AIX-NEXT:    xxlnor 1, 1, 1
; AIX-NEXT:    xxlnor 2, 2, 2
; AIX-NEXT:    xxlor 1, 2, 1
; AIX-NEXT:    lxvw4x 2, 0, 3
; AIX-NEXT:    xxsel 34, 0, 2, 1
; AIX-NEXT:    blr
entry:
  %m = call <4 x float> @llvm.maximum.v4f32(<4 x float> %a, <4 x float> %b)
  ret <4 x float> %m
}

define <2 x double> @v2f64_minimum(<2 x double> %a, <2 x double> %b) {
; NOVSX-LABEL: v2f64_minimum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    fcmpu 0, 3, 3
; NOVSX-NEXT:    fmr 0, 2
; NOVSX-NEXT:    fmr 2, 1
; NOVSX-NEXT:    fmr 1, 3
; NOVSX-NEXT:    bc 12, 3, .LBB6_2
; NOVSX-NEXT:  # %bb.1: # %entry
; NOVSX-NEXT:    fmr 1, 2
; NOVSX-NEXT:  .LBB6_2: # %entry
; NOVSX-NEXT:    fcmpu 0, 4, 4
; NOVSX-NEXT:    fmr 2, 4
; NOVSX-NEXT:    stfd 1, -8(1)
; NOVSX-NEXT:    bc 12, 3, .LBB6_4
; NOVSX-NEXT:  # %bb.3: # %entry
; NOVSX-NEXT:    fmr 2, 0
; NOVSX-NEXT:  .LBB6_4: # %entry
; NOVSX-NEXT:    fcmpu 0, 1, 3
; NOVSX-NEXT:    fmr 5, 1
; NOVSX-NEXT:    stfd 2, -16(1)
; NOVSX-NEXT:    cror 20, 0, 3
; NOVSX-NEXT:    bc 12, 20, .LBB6_6
; NOVSX-NEXT:  # %bb.5: # %entry
; NOVSX-NEXT:    fmr 5, 3
; NOVSX-NEXT:  .LBB6_6: # %entry
; NOVSX-NEXT:    addis 3, 2, .LCPI6_0@toc@ha
; NOVSX-NEXT:    lfs 0, .LCPI6_0@toc@l(3)
; NOVSX-NEXT:    ld 3, -8(1)
; NOVSX-NEXT:    fcmpu 0, 5, 0
; NOVSX-NEXT:    bc 4, 2, .LBB6_8
; NOVSX-NEXT:  # %bb.7: # %entry
; NOVSX-NEXT:    cmpdi 3, 0
; NOVSX-NEXT:    bc 12, 0, .LBB6_9
; NOVSX-NEXT:  .LBB6_8: # %entry
; NOVSX-NEXT:    fmr 1, 5
; NOVSX-NEXT:  .LBB6_9: # %entry
; NOVSX-NEXT:    fcmpu 0, 2, 4
; NOVSX-NEXT:    fmr 3, 2
; NOVSX-NEXT:    cror 20, 0, 3
; NOVSX-NEXT:    bc 12, 20, .LBB6_11
; NOVSX-NEXT:  # %bb.10: # %entry
; NOVSX-NEXT:    fmr 3, 4
; NOVSX-NEXT:  .LBB6_11: # %entry
; NOVSX-NEXT:    fcmpu 0, 3, 0
; NOVSX-NEXT:    ld 3, -16(1)
; NOVSX-NEXT:    bc 4, 2, .LBB6_13
; NOVSX-NEXT:  # %bb.12: # %entry
; NOVSX-NEXT:    cmpdi 3, 0
; NOVSX-NEXT:    bclr 12, 0, 0
; NOVSX-NEXT:  .LBB6_13: # %entry
; NOVSX-NEXT:    fmr 2, 3
; NOVSX-NEXT:    blr
;
; VSX-LABEL: v2f64_minimum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    addis 3, 2, .LCPI6_0@toc@ha
; VSX-NEXT:    xvmindp 0, 34, 35
; VSX-NEXT:    xvcmpeqdp 35, 35, 35
; VSX-NEXT:    addi 3, 3, .LCPI6_0@toc@l
; VSX-NEXT:    xvcmpeqdp 34, 34, 34
; VSX-NEXT:    xxlnor 35, 35, 35
; VSX-NEXT:    xxlnor 34, 34, 34
; VSX-NEXT:    lxvd2x 2, 0, 3
; VSX-NEXT:    xxlor 1, 34, 35
; VSX-NEXT:    xxsel 34, 0, 2, 1
; VSX-NEXT:    blr
;
; AIX-LABEL: v2f64_minimum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    ld 3, L..C6(2) # %const.0
; AIX-NEXT:    xvmindp 0, 34, 35
; AIX-NEXT:    xvcmpeqdp 35, 35, 35
; AIX-NEXT:    lxvd2x 2, 0, 3
; AIX-NEXT:    xvcmpeqdp 34, 34, 34
; AIX-NEXT:    xxlnor 35, 35, 35
; AIX-NEXT:    xxlnor 34, 34, 34
; AIX-NEXT:    xxlor 1, 34, 35
; AIX-NEXT:    xxsel 34, 0, 2, 1
; AIX-NEXT:    blr
entry:
  %m = call <2 x double> @llvm.minimum.v2f64(<2 x double> %a, <2 x double> %b)
  ret <2 x double> %m
}

define <2 x double> @v2f64_maximum(<2 x double> %a, <2 x double> %b) {
; NOVSX-LABEL: v2f64_maximum:
; NOVSX:       # %bb.0: # %entry
; NOVSX-NEXT:    fcmpu 0, 3, 3
; NOVSX-NEXT:    fmr 0, 2
; NOVSX-NEXT:    fmr 2, 1
; NOVSX-NEXT:    fmr 1, 3
; NOVSX-NEXT:    bc 12, 3, .LBB7_2
; NOVSX-NEXT:  # %bb.1: # %entry
; NOVSX-NEXT:    fmr 1, 2
; NOVSX-NEXT:  .LBB7_2: # %entry
; NOVSX-NEXT:    fcmpu 0, 4, 4
; NOVSX-NEXT:    fmr 2, 4
; NOVSX-NEXT:    stfd 1, -8(1)
; NOVSX-NEXT:    bc 12, 3, .LBB7_4
; NOVSX-NEXT:  # %bb.3: # %entry
; NOVSX-NEXT:    fmr 2, 0
; NOVSX-NEXT:  .LBB7_4: # %entry
; NOVSX-NEXT:    fcmpu 0, 1, 3
; NOVSX-NEXT:    fmr 5, 1
; NOVSX-NEXT:    stfd 2, -16(1)
; NOVSX-NEXT:    cror 20, 1, 3
; NOVSX-NEXT:    bc 12, 20, .LBB7_6
; NOVSX-NEXT:  # %bb.5: # %entry
; NOVSX-NEXT:    fmr 5, 3
; NOVSX-NEXT:  .LBB7_6: # %entry
; NOVSX-NEXT:    addis 3, 2, .LCPI7_0@toc@ha
; NOVSX-NEXT:    lfs 0, .LCPI7_0@toc@l(3)
; NOVSX-NEXT:    ld 3, -8(1)
; NOVSX-NEXT:    fcmpu 0, 5, 0
; NOVSX-NEXT:    bc 4, 2, .LBB7_8
; NOVSX-NEXT:  # %bb.7: # %entry
; NOVSX-NEXT:    cmpdi 3, -1
; NOVSX-NEXT:    bc 12, 1, .LBB7_9
; NOVSX-NEXT:  .LBB7_8: # %entry
; NOVSX-NEXT:    fmr 1, 5
; NOVSX-NEXT:  .LBB7_9: # %entry
; NOVSX-NEXT:    fcmpu 0, 2, 4
; NOVSX-NEXT:    fmr 3, 2
; NOVSX-NEXT:    cror 20, 1, 3
; NOVSX-NEXT:    bc 12, 20, .LBB7_11
; NOVSX-NEXT:  # %bb.10: # %entry
; NOVSX-NEXT:    fmr 3, 4
; NOVSX-NEXT:  .LBB7_11: # %entry
; NOVSX-NEXT:    fcmpu 0, 3, 0
; NOVSX-NEXT:    ld 3, -16(1)
; NOVSX-NEXT:    bc 4, 2, .LBB7_13
; NOVSX-NEXT:  # %bb.12: # %entry
; NOVSX-NEXT:    cmpdi 3, -1
; NOVSX-NEXT:    bclr 12, 1, 0
; NOVSX-NEXT:  .LBB7_13: # %entry
; NOVSX-NEXT:    fmr 2, 3
; NOVSX-NEXT:    blr
;
; VSX-LABEL: v2f64_maximum:
; VSX:       # %bb.0: # %entry
; VSX-NEXT:    addis 3, 2, .LCPI7_0@toc@ha
; VSX-NEXT:    xvmaxdp 0, 34, 35
; VSX-NEXT:    xvcmpeqdp 35, 35, 35
; VSX-NEXT:    addi 3, 3, .LCPI7_0@toc@l
; VSX-NEXT:    xvcmpeqdp 34, 34, 34
; VSX-NEXT:    xxlnor 35, 35, 35
; VSX-NEXT:    xxlnor 34, 34, 34
; VSX-NEXT:    lxvd2x 2, 0, 3
; VSX-NEXT:    xxlor 1, 34, 35
; VSX-NEXT:    xxsel 34, 0, 2, 1
; VSX-NEXT:    blr
;
; AIX-LABEL: v2f64_maximum:
; AIX:       # %bb.0: # %entry
; AIX-NEXT:    ld 3, L..C7(2) # %const.0
; AIX-NEXT:    xvmaxdp 0, 34, 35
; AIX-NEXT:    xvcmpeqdp 35, 35, 35
; AIX-NEXT:    lxvd2x 2, 0, 3
; AIX-NEXT:    xvcmpeqdp 34, 34, 34
; AIX-NEXT:    xxlnor 35, 35, 35
; AIX-NEXT:    xxlnor 34, 34, 34
; AIX-NEXT:    xxlor 1, 34, 35
; AIX-NEXT:    xxsel 34, 0, 2, 1
; AIX-NEXT:    blr
entry:
  %m = call <2 x double> @llvm.maximum.v2f64(<2 x double> %a, <2 x double> %b)
  ret <2 x double> %m
}

declare float @llvm.maximum.f32(float, float)
declare double @llvm.maximum.f64(double, double)
declare <4 x float> @llvm.maximum.v4f32(<4 x float>, <4 x float>)
declare <2 x double> @llvm.maximum.v2f64(<2 x double>, <2 x double>)

declare float @llvm.minimum.f32(float, float)
declare double @llvm.minimum.f64(double, double)
declare <4 x float> @llvm.minimum.v4f32(<4 x float>, <4 x float>)
declare <2 x double> @llvm.minimum.v2f64(<2 x double>, <2 x double>)
