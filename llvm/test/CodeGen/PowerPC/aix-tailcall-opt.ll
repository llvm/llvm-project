; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc -verify-machineinstrs -mtriple=powerpc-ibm-aix -ppc-asm-full-reg-names < %s | FileCheck --check-prefixes=AIX32,COMM %s
; RUN: llc -verify-machineinstrs -mtriple=powerpc64-ibm-aix -ppc-asm-full-reg-names < %s | FileCheck --check-prefixes=AIX64,COMM %s

; RUN: llc -verify-machineinstrs -mtriple=powerpc-ibm-aix -tailcallopt -ppc-asm-full-reg-names < %s | FileCheck --check-prefixes=AIX32-OPT,COMM-OPT %s
; RUN: llc -verify-machineinstrs -mtriple=powerpc64-ibm-aix -tailcallopt -ppc-asm-full-reg-names < %s | FileCheck --check-prefixes=AIX64-OPT,COMM-OPT %s

define hidden fastcc i32 @k(i32 %a, i32 %b) {
; COMM-LABEL: k:
; COMM:       # %bb.0: # %entry
; COMM-NEXT:    add r3, r3, r4
; COMM-NEXT:    blr

; COMM-OPT-LABEL: k:
; COMM-OPT:       # %bb.0: # %entry
; COMM-OPT-NEXT:    add r3, r3, r4
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX64-OPT-NEXT:    addi r1, r1, 112
; COMM-OPT-NEXT:    blr

entry:
  %c = add i32 %a, %b
  ret i32 %c
}

define hidden fastcc i32 @ff(i32 %a) {

; COMM-LABEL: ff:
; COMM:       # %bb.0: # %entry
; COMM-NEXT:    blr
;
; COMM-OPT-LABEL: ff:
; COMM-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX64-OPT-NEXT:    addi r1, r1, 112
; COMM-OPT-NEXT:    blr

entry:
  ret i32 %a
}

define fastcc i32 @f(i32 %a, i32 %b) {
; AIX32-LABEL: f:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    b .ff
; AIX32-NEXT:    #TC_RETURNd .ff 0
;
; AIX64-LABEL: f:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    clrldi r3, r3, 32
; AIX64-NEXT:    b .ff
; AIX64-NEXT:    #TC_RETURNd8 .ff 0
;
; AIX32-OPT-LABEL: f:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    b .ff
; AIX32-OPT-NEXT:    #TC_RETURNd .ff 0
;
; AIX64-OPT-LABEL: f:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    clrldi r3, r3, 32
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    b .ff
; AIX64-OPT-NEXT:    #TC_RETURNd8 .ff 0
entry:
  %r = tail call fastcc i32 @ff(i32 %a)
  ret i32 %r
}

define fastcc i32 @kk(i32 %a) {
; AIX32-LABEL: kk:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    li r4, 1024
; AIX32-NEXT:    b .k
; AIX32-NEXT:    #TC_RETURNd .k 0
;
; AIX64-LABEL: kk:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    clrldi r3, r3, 32
; AIX64-NEXT:    li r4, 1024
; AIX64-NEXT:    b .k
; AIX64-NEXT:    #TC_RETURNd8 .k 0
;
; AIX32-OPT-LABEL: kk:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    li r4, 1024
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    b .k
; AIX32-OPT-NEXT:    #TC_RETURNd .k 0
;
; AIX64-OPT-LABEL: kk:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    clrldi r3, r3, 32
; AIX64-OPT-NEXT:    li r4, 1024
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    b .k
; AIX64-OPT-NEXT:    #TC_RETURNd8 .k 0
entry:
  %r = tail call fastcc i32 @k(i32 %a, i32 1024)
  ret i32 %r
}

define fastcc i32 @g(i32 %a) {
; AIX32-LABEL: g:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    b .ff
; AIX32-NEXT:    #TC_RETURNd .ff 0
;
; AIX64-LABEL: g:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    clrldi r3, r3, 32
; AIX64-NEXT:    b .ff
; AIX64-NEXT:    #TC_RETURNd8 .ff 0
;
; AIX32-OPT-LABEL: g:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    b .ff
; AIX32-OPT-NEXT:    #TC_RETURNd .ff 0
;
; AIX64-OPT-LABEL: g:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    clrldi r3, r3, 32
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    b .ff
; AIX64-OPT-NEXT:    #TC_RETURNd8 .ff 0
entry:
  %r = tail call fastcc i32 @ff(i32 %a)
  ret i32 %r
}

define fastcc i32 @gg(i32 %a) {
; AIX32-LABEL: gg:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    mflr r0
; AIX32-NEXT:    stwu r1, -64(r1)
; AIX32-NEXT:    stw r0, 72(r1)
; AIX32-NEXT:    bl .ff
; AIX32-NEXT:    addi r3, r3, 1
; AIX32-NEXT:    addi r1, r1, 64
; AIX32-NEXT:    lwz r0, 8(r1)
; AIX32-NEXT:    mtlr r0
; AIX32-NEXT:    blr
;
; AIX64-LABEL: gg:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    mflr r0
; AIX64-NEXT:    stdu r1, -112(r1)
; AIX64-NEXT:    clrldi r3, r3, 32
; AIX64-NEXT:    std r0, 128(r1)
; AIX64-NEXT:    bl .ff
; AIX64-NEXT:    addi r3, r3, 1
; AIX64-NEXT:    addi r1, r1, 112
; AIX64-NEXT:    ld r0, 16(r1)
; AIX64-NEXT:    mtlr r0
; AIX64-NEXT:    blr
;
; AIX32-OPT-LABEL: gg:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    mflr r0
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    stw r0, 72(r1)
; AIX32-OPT-NEXT:    bl .ff
; AIX32-OPT-NEXT:    addi r1, r1, -56
; AIX32-OPT-NEXT:    addi r3, r3, 1
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    lwz r0, 8(r1)
; AIX32-OPT-NEXT:    mtlr r0
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    blr
;
; AIX64-OPT-LABEL: gg:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    mflr r0
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    clrldi r3, r3, 32
; AIX64-OPT-NEXT:    std r0, 128(r1)
; AIX64-OPT-NEXT:    bl .ff
; AIX64-OPT-NEXT:    addi r1, r1, -112
; AIX64-OPT-NEXT:    addi r3, r3, 1
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    ld r0, 16(r1)
; AIX64-OPT-NEXT:    mtlr r0
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    blr
entry:
  %r = tail call fastcc i32 @ff(i32 %a)
  %r.0 = add i32 %r, 1
  ret i32 %r.0
}


;; The following IRs are generated from source code with commmand:
;; clang -O1 -target powerpc-unknown-aix -emit-llvm

; // The argument size in stack is 4(int) +8(double) +4(float) + 16(vector)  = 32 bytes  in 32-bit mode.
; // The argument size in stack is 8(int) +8(double) +8(float) + 16(vector)  = 40 bytes  in 64-bit mode. 
; __attribute__((noinline, visibility("hidden")))
; double c1(int a1, double a2, float a3 ,vector unsigned int v1) {
;     return a1 + a2  ;
; }
;
; double b1(int x, double y, float z) {
;     vector unsigned int v = { 0x0000FFFF, 0,0xFF,0 };
;     return c1(x, y, z, v);
; }
;
; // The argument size in stack is 4(int) +8(double) +4(float) + 16(vector) + 16(vector) = 48 bytes  in 32-bit mode.
; // The argument size in stack is 8(int) +8(double) +8(float) + 16(vector) + 16(vector) = 56 bytes  in 64-bit mode.
; __attribute__((noinline, visibility("hidden")))
; double c2(int a1, double a2, float a3 ,vector unsigned int v1 , vector unsigned int v2 ) {
;     return a1 + a2  ;
; }
;
; double b2(int x, double y, float z) {
;     vector unsigned int v = { 0x0000FFFF, 0,0xFF,0 };
;     return c2(x, y, z, v, v);
; }
;
; // The argument size in stack is 4(int) +8(double) +4(float) + 16(vector) + 16(vector) + 16(vector) = 60 bytes  in 32-bit mode.
; // The argument size in stack is 8(int) +8(double) +8(float) + 16(vector) + 16(vector) + 16(vector) = 72 bytes  in 64-bit mode.
; __attribute__((noinline, visibility("hidden")))
; double c3(int a1, double a2, float a3 ,vector unsigned int v1 , vector unsigned int v2 , vector unsigned int v3 ) {
;     return a1 + a2  ;
; }
;
; double b3(int x, double y, float z) {
;     vector unsigned int v = { 0x0000FFFF, 0,0xFF,0 };
;     return c3(x, y, z, v, v, v);
; }
;
; struct ST {
;   int a1;
;   double b1;
; };
;

; // The argument size in stack is 12(ST) +8(double) +4(float) + 16(vector) = 40 bytes  in 32-bit mode.
; // The argument size in stack is 12(ST) +8(double) +8(float) + 16(vector) = 48 bytes  in 64-bit mode.
; __attribute__((noinline, visibility("hidden")))
; double c4(struct ST s, double a3 ,vector unsigned int v1 ) {
;    return s.a1 +s.b1;
; }
;
; double b4(int x, double y, float z) {
;   struct ST s = { 1, 1.0};
;   vector unsigned int v = { 0x0000FFFF, 0,0xFF,0 };
;   return  c4( s, y, v);
; }

%struct.ST = type <{ i32, double }>

@__const.b4.s = private unnamed_addr constant %struct.ST <{ i32 1, double 1.000000e+00 }>, align 4

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none)
define hidden noundef double @c1(i32 noundef %a1, double noundef %a2, float %a3, <4 x i32> %v1)  {
; COMM-LABEL: c1:
; COMM:       # %bb.0: # %entry
; COMM-NEXT:    stw r3, -4(r1)
; COMM-NEXT:    addi r3, r1, -4
; COMM-NEXT:    lfiwax f0, 0, r3
; COMM-NEXT:    xscvsxddp f0, f0
; COMM-NEXT:    xsadddp f1, f1, f0
; COMM-NEXT:    blr

; COMM-OPT-LABEL: c1:
; COMM-OPT:       # %bb.0: # %entry
; COMM-OPT-NEXT:    stw r3, -4(r1)
; COMM-OPT-NEXT:    addi r3, r1, -4
; COMM-OPT-NEXT:    lfiwax f0, 0, r3
; COMM-OPT-NEXT:    xscvsxddp f0, f0
; COMM-OPT-NEXT:    xsadddp f1, f1, f0
; COMM-OPT-NEXT:    blr

entry:
  %conv = sitofp i32 %a1 to double
  %add = fadd double %a2, %conv
  ret double %add
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef double @b1(i32 noundef %x, double noundef %y, float noundef %z)  {
; AIX32-LABEL: b1:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    b .c1
; AIX32-NEXT:    #TC_RETURNd .c1 0
;
; AIX64-LABEL: b1:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    clrldi r3, r3, 32
; AIX64-NEXT:    b .c1
; AIX64-NEXT:    #TC_RETURNd8 .c1 0
;
; AIX32-OPT-LABEL: b1:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    b .c1
; AIX32-OPT-NEXT:    #TC_RETURNd .c1 0
;
; AIX64-OPT-LABEL: b1:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    clrldi r3, r3, 32
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    b .c1
; AIX64-OPT-NEXT:    #TC_RETURNd8 .c1 0
entry:
  %call = tail call double @c1(i32 noundef %x, double noundef %y, float poison, <4 x i32> poison)
  ret double %call
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none)
define hidden noundef double @c2(i32 noundef %a1, double noundef %a2, float %a3, <4 x i32> %v1, <4 x i32> %v2)  {
; COMM-LABEL: c2:
; COMM:       # %bb.0: # %entry
; COMM-NEXT:    stw r3, -4(r1)
; COMM-NEXT:    addi r3, r1, -4
; COMM-NEXT:    lfiwax f0, 0, r3
; COMM-NEXT:    xscvsxddp f0, f0
; COMM-NEXT:    xsadddp f1, f1, f0
; COMM-NEXT:    blr

; COMM-OPT-LABEL: c2:
; COMM-OPT:       # %bb.0: # %entry
; COMM-OPT-NEXT:    stw r3, -4(r1)
; COMM-OPT-NEXT:    addi r3, r1, -4
; COMM-OPT-NEXT:    lfiwax f0, 0, r3
; COMM-OPT-NEXT:    xscvsxddp f0, f0
; COMM-OPT-NEXT:    xsadddp f1, f1, f0
; COMM-OPT-NEXT:    blr

entry:
  %conv = sitofp i32 %a1 to double
  %add = fadd double %a2, %conv
  ret double %add
}

define noundef double @b2(i32 noundef %x, double noundef %y, float noundef %z)  {
; AIX32-LABEL: b2:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    mflr r0
; AIX32-NEXT:    stwu r1, -64(r1)
; AIX32-NEXT:    stw r0, 72(r1)
; AIX32-NEXT:    bl .c2
; AIX32-NEXT:    addi r1, r1, 64
; AIX32-NEXT:    lwz r0, 8(r1)
; AIX32-NEXT:    mtlr r0
; AIX32-NEXT:    blr
;
; AIX64-LABEL: b2:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    clrldi r3, r3, 32
; AIX64-NEXT:    b .c2
; AIX64-NEXT:    #TC_RETURNd8 .c2 0
;
; AIX32-OPT-LABEL: b2:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    mflr r0
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    stw r0, 72(r1)
; AIX32-OPT-NEXT:    bl .c2
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    lwz r0, 8(r1)
; AIX32-OPT-NEXT:    mtlr r0
; AIX32-OPT-NEXT:    blr
;
; AIX64-OPT-LABEL: b2:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    clrldi r3, r3, 32
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    b .c2
; AIX64-OPT-NEXT:    #TC_RETURNd8 .c2 0
entry:
  %call = tail call double @c2(i32 noundef %x, double noundef %y, float poison, <4 x i32> poison, <4 x i32> poison)
  ret double %call
}

define hidden noundef double @c3(i32 noundef %a1, double noundef %a2, float %a3, <4 x i32> %v1, <4 x i32> %v2, <4 x i32> %v3)  {
; COMM-LABEL: c3:
; COMM:       # %bb.0: # %entry
; COMM-NEXT:    stw r3, -4(r1)
; COMM-NEXT:    addi r3, r1, -4
; COMM-NEXT:    lfiwax f0, 0, r3
; COMM-NEXT:    xscvsxddp f0, f0
; COMM-NEXT:    xsadddp f1, f1, f0
; COMM-NEXT:    blr

; COMM-OPT-LABEL: c3:
; COMM-OPT:       # %bb.0: # %entry
; COMM-OPT-NEXT:    stw r3, -4(r1)
; COMM-OPT-NEXT:    addi r3, r1, -4
; COMM-OPT-NEXT:    lfiwax f0, 0, r3
; COMM-OPT-NEXT:    xscvsxddp f0, f0
; COMM-OPT-NEXT:    xsadddp f1, f1, f0
; COMM-OPT-NEXT:    blr
entry:
  %conv = sitofp i32 %a1 to double
  %add = fadd double %a2, %conv
  ret double %add
}

define noundef double @b3(i32 noundef %x, double noundef %y, float noundef %z)   {
; AIX32-LABEL: b3:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    mflr r0
; AIX32-NEXT:    stwu r1, -64(r1)
; AIX32-NEXT:    stw r0, 72(r1)
; AIX32-NEXT:    bl .c3
; AIX32-NEXT:    addi r1, r1, 64
; AIX32-NEXT:    lwz r0, 8(r1)
; AIX32-NEXT:    mtlr r0
; AIX32-NEXT:    blr
;
; AIX64-LABEL: b3:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    mflr r0
; AIX64-NEXT:    stdu r1, -112(r1)
; AIX64-NEXT:    clrldi r3, r3, 32
; AIX64-NEXT:    std r0, 128(r1)
; AIX64-NEXT:    bl .c3
; AIX64-NEXT:    addi r1, r1, 112
; AIX64-NEXT:    ld r0, 16(r1)
; AIX64-NEXT:    mtlr r0
; AIX64-NEXT:    blr
;
; AIX32-OPT-LABEL: b3:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    mflr r0
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    stw r0, 72(r1)
; AIX32-OPT-NEXT:    bl .c3
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    lwz r0, 8(r1)
; AIX32-OPT-NEXT:    mtlr r0
; AIX32-OPT-NEXT:    blr
;
; AIX64-OPT-LABEL: b3:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    mflr r0
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    clrldi r3, r3, 32
; AIX64-OPT-NEXT:    std r0, 128(r1)
; AIX64-OPT-NEXT:    bl .c3
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    ld r0, 16(r1)
; AIX64-OPT-NEXT:    mtlr r0
; AIX64-OPT-NEXT:    blr
entry:
  %call = tail call double @c3(i32 noundef %x, double noundef %y, float poison, <4 x i32> poison, <4 x i32> poison, <4 x i32> poison)
  ret double %call
}

define hidden double @c4(ptr noundef readonly byval(%struct.ST) align 4 captures(none) %s, double %a3, <4 x i32> %v1)  {
; AIX32-LABEL: c4:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    stw r3, 24(r1)
; AIX32-NEXT:    stw r3, -4(r1)
; AIX32-NEXT:    addi r3, r1, -4
; AIX32-NEXT:    stw r5, 32(r1)
; AIX32-NEXT:    stw r4, 28(r1)
; AIX32-NEXT:    lfiwax f0, 0, r3
; AIX32-NEXT:    lfd f1, 28(r1)
; AIX32-NEXT:    xscvsxddp f0, f0
; AIX32-NEXT:    xsadddp f1, f1, f0
; AIX32-NEXT:    blr
;
; AIX64-LABEL: c4:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    std r3, 48(r1)
; AIX64-NEXT:    rldicl r3, r3, 32, 32
; AIX64-NEXT:    std r4, 56(r1)
; AIX64-NEXT:    lfd f1, 52(r1)
; AIX64-NEXT:    stw r3, -4(r1)
; AIX64-NEXT:    addi r3, r1, -4
; AIX64-NEXT:    lfiwax f0, 0, r3
; AIX64-NEXT:    xscvsxddp f0, f0
; AIX64-NEXT:    xsadddp f1, f1, f0
; AIX64-NEXT:    blr
;
; AIX32-OPT-LABEL: c4:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    stw r3, 24(r1)
; AIX32-OPT-NEXT:    stw r3, -4(r1)
; AIX32-OPT-NEXT:    addi r3, r1, -4
; AIX32-OPT-NEXT:    stw r5, 32(r1)
; AIX32-OPT-NEXT:    stw r4, 28(r1)
; AIX32-OPT-NEXT:    lfiwax f0, 0, r3
; AIX32-OPT-NEXT:    lfd f1, 28(r1)
; AIX32-OPT-NEXT:    xscvsxddp f0, f0
; AIX32-OPT-NEXT:    xsadddp f1, f1, f0
; AIX32-OPT-NEXT:    blr
;
; AIX64-OPT-LABEL: c4:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    std r3, 48(r1)
; AIX64-OPT-NEXT:    rldicl r3, r3, 32, 32
; AIX64-OPT-NEXT:    std r4, 56(r1)
; AIX64-OPT-NEXT:    lfd f1, 52(r1)
; AIX64-OPT-NEXT:    stw r3, -4(r1)
; AIX64-OPT-NEXT:    addi r3, r1, -4
; AIX64-OPT-NEXT:    lfiwax f0, 0, r3
; AIX64-OPT-NEXT:    xscvsxddp f0, f0
; AIX64-OPT-NEXT:    xsadddp f1, f1, f0
; AIX64-OPT-NEXT:    blr
entry:
  %0 = load i32, ptr %s, align 4
  %conv = sitofp i32 %0 to double
  %b1 = getelementptr inbounds nuw i8, ptr %s, i32 4
  %1 = load double, ptr %b1, align 4
  %add = fadd double %1, %conv
  ret double %add
}

define double @b4(i32 noundef %x, double noundef %y, float noundef %z)  {
; AIX32-LABEL: b4:
; AIX32:       # %bb.0: # %entry
; AIX32-NEXT:    mflr r0
; AIX32-NEXT:    stwu r1, -64(r1)
; AIX32-NEXT:    lwz r3, L..C0(r2) # @__const.b4.s
; AIX32-NEXT:    stw r0, 72(r1)
; AIX32-NEXT:    lwz r5, 8(r3)
; AIX32-NEXT:    lwz r4, 4(r3)
; AIX32-NEXT:    lwz r3, 0(r3)
; AIX32-NEXT:    bl .c4
; AIX32-NEXT:    addi r1, r1, 64
; AIX32-NEXT:    lwz r0, 8(r1)
; AIX32-NEXT:    mtlr r0
; AIX32-NEXT:    blr
;
; AIX64-LABEL: b4:
; AIX64:       # %bb.0: # %entry
; AIX64-NEXT:    ld r4, L..C0(r2) # @__const.b4.s
; AIX64-NEXT:    ld r3, 0(r4)
; AIX64-NEXT:    lwz r4, 8(r4)
; AIX64-NEXT:    sldi r4, r4, 32
; AIX64-NEXT:    b .c4
; AIX64-NEXT:    #TC_RETURNd8 .c4 0
;
; AIX32-OPT-LABEL: b4:
; AIX32-OPT:       # %bb.0: # %entry
; AIX32-OPT-NEXT:    mflr r0
; AIX32-OPT-NEXT:    stwu r1, -64(r1)
; AIX32-OPT-NEXT:    lwz r3, L..C0(r2) # @__const.b4.s
; AIX32-OPT-NEXT:    stw r0, 72(r1)
; AIX32-OPT-NEXT:    lwz r5, 8(r3)
; AIX32-OPT-NEXT:    lwz r4, 4(r3)
; AIX32-OPT-NEXT:    lwz r3, 0(r3)
; AIX32-OPT-NEXT:    bl .c4
; AIX32-OPT-NEXT:    addi r1, r1, 64
; AIX32-OPT-NEXT:    lwz r0, 8(r1)
; AIX32-OPT-NEXT:    mtlr r0
; AIX32-OPT-NEXT:    blr
;
; AIX64-OPT-LABEL: b4:
; AIX64-OPT:       # %bb.0: # %entry
; AIX64-OPT-NEXT:    stdu r1, -112(r1)
; AIX64-OPT-NEXT:    ld r4, L..C0(r2) # @__const.b4.s
; AIX64-OPT-NEXT:    ld r3, 0(r4)
; AIX64-OPT-NEXT:    lwz r4, 8(r4)
; AIX64-OPT-NEXT:    sldi r4, r4, 32
; AIX64-OPT-NEXT:    addi r1, r1, 112
; AIX64-OPT-NEXT:    b .c4
; AIX64-OPT-NEXT:    #TC_RETURNd8 .c4 0
entry:
  %call = tail call double @c4(ptr noundef nonnull byval(%struct.ST) align 4 @__const.b4.s, double poison, <4 x i32> poison)
  ret double %call
}

