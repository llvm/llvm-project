; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; Test file to verify the emission of Vector Evaluate instructions when ternary operators are used.

; RUN: llc -verify-machineinstrs -mcpu=pwr10 -mtriple=powerpc64le-unknown-unknown \
; RUN:   -ppc-asm-full-reg-names --ppc-vsr-nums-as-vr < %s | FileCheck %s

; RUN: llc -verify-machineinstrs -mcpu=pwr10 -mtriple=powerpc-ibm-aix-xcoff \
; RUN:   -ppc-asm-full-reg-names --ppc-vsr-nums-as-vr < %s | FileCheck %s

; RUN: llc -verify-machineinstrs -mcpu=pwr10 -mtriple=powerpc64-ibm-aix-xcoff \
; RUN:   -ppc-asm-full-reg-names --ppc-vsr-nums-as-vr < %s | FileCheck %s

; Function to test ternary(A, or(B, C), eqv(B, C)) for <4 x i32>
define <4 x i32> @ternary_A_or_BC_eqv_BC_4x32(<4 x i1> %A, <4 x i32> %B, <4 x i32> %C) {
; CHECK-LABEL: ternary_A_or_BC_eqv_BC_4x32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxleqv v5, v5, v5
; CHECK-NEXT:    xxlor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslw v2, v2, v5
; CHECK-NEXT:    vsraw v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <4 x i32> %B, %C
  %xor = xor <4 x i32> %B, %C
  %eqv = xor <4 x i32> %xor, <i32 -1, i32 -1, i32 -1, i32 -1>  ; Vector eqv operation
  %res = select <4 x i1> %A, <4 x i32> %or, <4 x i32> %eqv
  ret <4 x i32> %res
}

; Function to test ternary(A, or(B, C), eqv(B, C)) for <2 x i64>
define <2 x i64> @ternary_A_or_BC_eqv_BC_2x64(<2 x i1> %A, <2 x i64> %B, <2 x i64> %C) {
; CHECK-LABEL: ternary_A_or_BC_eqv_BC_2x64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxlxor v5, v5, v5
; CHECK-NEXT:    xxlor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    xxsplti32dx v5, 1, 63
; CHECK-NEXT:    vsld v2, v2, v5
; CHECK-NEXT:    vsrad v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <2 x i64> %B, %C
  %xor = xor <2 x i64> %B, %C
  %eqv = xor <2 x i64> %xor, <i64 -1, i64 -1>  ; Vector eqv operation
  %res = select <2 x i1> %A, <2 x i64> %or, <2 x i64> %eqv
  ret <2 x i64> %res
}

; Function to test ternary(A, or(B, C), eqv(B, C)) for <16 x i8>
define <16 x i8> @ternary_A_or_BC_eqv_BC_16x8(<16 x i1> %A, <16 x i8> %B, <16 x i8> %C) {
; CHECK-LABEL: ternary_A_or_BC_eqv_BC_16x8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltib v5, 7
; CHECK-NEXT:    xxlor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslb v2, v2, v5
; CHECK-NEXT:    vsrab v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <16 x i8> %B, %C
  %xor = xor <16 x i8> %B, %C
  %eqv = xor <16 x i8> %xor, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>  ; Vector eqv operation
  %res = select <16 x i1> %A, <16 x i8> %or, <16 x i8> %eqv
  ret <16 x i8> %res
}

; Function to test ternary(A, or(B, C), eqv(B, C)) for <8 x i16>
define <8 x i16> @ternary_A_or_BC_eqv_BC_8x16(<8 x i1> %A, <8 x i16> %B, <8 x i16> %C) {
; CHECK-LABEL: ternary_A_or_BC_eqv_BC_8x16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltiw v5, 983055
; CHECK-NEXT:    xxlor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslh v2, v2, v5
; CHECK-NEXT:    vsrah v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <8 x i16> %B, %C
  %xor = xor <8 x i16> %B, %C
  %eqv = xor <8 x i16> %xor, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>  ; Vector eqv operation
  %res = select <8 x i1> %A, <8 x i16> %or, <8 x i16> %eqv
  ret <8 x i16> %res
}

; Function to test ternary(A, nor(B, C), eqv(B, C)) for <4 x i32>
define <4 x i32> @ternary_A_nor_BC_eqv_BC_4x32(<4 x i1> %A, <4 x i32> %B, <4 x i32> %C) {
; CHECK-LABEL: ternary_A_nor_BC_eqv_BC_4x32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxleqv v5, v5, v5
; CHECK-NEXT:    xxlnor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslw v2, v2, v5
; CHECK-NEXT:    vsraw v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <4 x i32> %B, %C
  %nor = xor <4 x i32> %or, <i32 -1, i32 -1, i32 -1, i32 -1>  ; Vector NOR operation
  %xor = xor <4 x i32> %B, %C
  %eqv = xor <4 x i32> %xor, <i32 -1, i32 -1, i32 -1, i32 -1>  ; Vector eqv operation
  %res = select <4 x i1> %A, <4 x i32> %nor, <4 x i32> %eqv
  ret <4 x i32> %res
}

; Function to test ternary(A, nor(B, C), eqv(B, C)) for <2 x i64>
define <2 x i64> @ternary_A_nor_BC_eqv_BC_2x64(<2 x i1> %A, <2 x i64> %B, <2 x i64> %C) {
; CHECK-LABEL: ternary_A_nor_BC_eqv_BC_2x64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxlxor v5, v5, v5
; CHECK-NEXT:    xxlnor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    xxsplti32dx v5, 1, 63
; CHECK-NEXT:    vsld v2, v2, v5
; CHECK-NEXT:    vsrad v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <2 x i64> %B, %C
  %nor = xor <2 x i64> %or, <i64 -1, i64 -1>  ; Vector NOR operation
  %xor = xor <2 x i64> %B, %C
  %eqv = xor <2 x i64> %xor, <i64 -1, i64 -1>  ; Vector eqv operation
  %res = select <2 x i1> %A, <2 x i64> %nor, <2 x i64> %eqv
  ret <2 x i64> %res
}

; Function to test ternary(A, nor(B, C), eqv(B, C)) for <16 x i8>
define <16 x i8> @ternary_A_nor_BC_eqv_BC_16x8(<16 x i1> %A, <16 x i8> %B, <16 x i8> %C) {
; CHECK-LABEL: ternary_A_nor_BC_eqv_BC_16x8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltib v5, 7
; CHECK-NEXT:    xxlnor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslb v2, v2, v5
; CHECK-NEXT:    vsrab v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <16 x i8> %B, %C
  %nor = xor <16 x i8> %or, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>  ; Vector NOR operation
  %xor = xor <16 x i8> %B, %C
  %eqv = xor <16 x i8> %xor, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>  ; Vector eqv operation
  %res = select <16 x i1> %A, <16 x i8> %nor, <16 x i8> %eqv
  ret <16 x i8> %res
}

; Function to test ternary(A, nor(B, C), eqv(B, C)) for <8 x i16>
define <8 x i16> @ternary_A_nor_BC_eqv_BC_8x16(<8 x i1> %A, <8 x i16> %B, <8 x i16> %C) {
; CHECK-LABEL: ternary_A_nor_BC_eqv_BC_8x16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltiw v5, 983055
; CHECK-NEXT:    xxlnor vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslh v2, v2, v5
; CHECK-NEXT:    vsrah v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %or = or <8 x i16> %B, %C
  %nor = xor <8 x i16> %or, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>  ; Vector NOR operation
  %xor = xor <8 x i16> %B, %C
  %eqv = xor <8 x i16> %xor, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>  ; Vector eqv operation
  %res = select <8 x i1> %A, <8 x i16> %nor, <8 x i16> %eqv
  ret <8 x i16> %res
}

; Function to test ternary(A, not(C), eqv(B, C)) for <4 x i32>
define <4 x i32> @ternary_A_not_C_eqv_BC_4x32(<4 x i1> %A, <4 x i32> %B, <4 x i32> %C) {
; CHECK-LABEL: ternary_A_not_C_eqv_BC_4x32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxleqv v5, v5, v5
; CHECK-NEXT:    xxlnor vs0, v4, v4
; CHECK-NEXT:    xxleqv vs1, v4, v3
; CHECK-NEXT:    vslw v2, v2, v5
; CHECK-NEXT:    vsraw v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %not = xor <4 x i32> %C, <i32 -1, i32 -1, i32 -1, i32 -1>  ; Vector not operation
  %xor = xor <4 x i32> %B, %C
  %eqv = xor <4 x i32> %xor, <i32 -1, i32 -1, i32 -1, i32 -1>  ; Vector eqv operation
  %res = select <4 x i1> %A, <4 x i32> %not, <4 x i32> %eqv
  ret <4 x i32> %res
}

; Function to test ternary(A, not(C), eqv(B, C)) for <2 x i64>
define <2 x i64> @ternary_A_not_C_eqv_BC_2x64(<2 x i1> %A, <2 x i64> %B, <2 x i64> %C) {
; CHECK-LABEL: ternary_A_not_C_eqv_BC_2x64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxlxor v5, v5, v5
; CHECK-NEXT:    xxlnor vs0, v4, v4
; CHECK-NEXT:    xxleqv vs1, v4, v3
; CHECK-NEXT:    xxsplti32dx v5, 1, 63
; CHECK-NEXT:    vsld v2, v2, v5
; CHECK-NEXT:    vsrad v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %not = xor <2 x i64> %C, <i64 -1, i64 -1>  ; Vector not operation
  %xor = xor <2 x i64> %B, %C
  %eqv = xor <2 x i64> %xor, <i64 -1, i64 -1>  ; Vector eqv operation
  %res = select <2 x i1> %A, <2 x i64> %not, <2 x i64> %eqv
  ret <2 x i64> %res
}

; Function to test ternary(A, not(C), eqv(B, C)) for <16 x i8>
define <16 x i8> @ternary_A_not_C_eqv_BC_16x8(<16 x i1> %A, <16 x i8> %B, <16 x i8> %C) {
; CHECK-LABEL: ternary_A_not_C_eqv_BC_16x8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltib v5, 7
; CHECK-NEXT:    xxlnor vs0, v4, v4
; CHECK-NEXT:    xxleqv vs1, v4, v3
; CHECK-NEXT:    vslb v2, v2, v5
; CHECK-NEXT:    vsrab v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %not = xor <16 x i8> %C, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>  ; Vector not operation
  %xor = xor <16 x i8> %B, %C
  %eqv = xor <16 x i8> %xor, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>  ; Vector eqv operation
  %res = select <16 x i1> %A, <16 x i8> %not, <16 x i8> %eqv
  ret <16 x i8> %res
}

; Function to test ternary(A, not(C), eqv(B, C)) for <8 x i16>
define <8 x i16> @ternary_A_not_C_eqv_BC_8x16(<8 x i1> %A, <8 x i16> %B, <8 x i16> %C) {
; CHECK-LABEL: ternary_A_not_C_eqv_BC_8x16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltiw v5, 983055
; CHECK-NEXT:    xxlnor vs0, v4, v4
; CHECK-NEXT:    xxleqv vs1, v4, v3
; CHECK-NEXT:    vslh v2, v2, v5
; CHECK-NEXT:    vsrah v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %not = xor <8 x i16> %C, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>  ; Vector not operation
  %xor = xor <8 x i16> %B, %C
  %eqv = xor <8 x i16> %xor, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>  ; Vector eqv operation
  %res = select <8 x i1> %A, <8 x i16> %not, <8 x i16> %eqv
  ret <8 x i16> %res
}

; Function to test ternary(A, nand(B, C), eqv(B, C)) for <4 x i32>
define <4 x i32> @ternary_A_nand_BC_eqv_BC_4x32(<4 x i1> %A, <4 x i32> %B, <4 x i32> %C) {
; CHECK-LABEL: ternary_A_nand_BC_eqv_BC_4x32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxleqv v5, v5, v5
; CHECK-NEXT:    xxlnand vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslw v2, v2, v5
; CHECK-NEXT:    vsraw v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %and = and <4 x i32> %B, %C
  %nand = xor <4 x i32> %and, <i32 -1, i32 -1, i32 -1, i32 -1>  ; Vector nand operation
  %xor = xor <4 x i32> %B, %C
  %eqv = xor <4 x i32> %xor, <i32 -1, i32 -1, i32 -1, i32 -1>  ; Vector eqv operation
  %res = select <4 x i1> %A, <4 x i32> %nand, <4 x i32> %eqv
  ret <4 x i32> %res
}

; Function to test ternary(A, nand(B, C), eqv(B, C)) for <2 x i64>
define <2 x i64> @ternary_A_nand_BC_eqv_BC_2x64(<2 x i1> %A, <2 x i64> %B, <2 x i64> %C) {
; CHECK-LABEL: ternary_A_nand_BC_eqv_BC_2x64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxlxor v5, v5, v5
; CHECK-NEXT:    xxlnand vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    xxsplti32dx v5, 1, 63
; CHECK-NEXT:    vsld v2, v2, v5
; CHECK-NEXT:    vsrad v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %and = and <2 x i64> %B, %C
  %nand = xor <2 x i64> %and, <i64 -1, i64 -1>  ; Vector nand operation
  %xor = xor <2 x i64> %B, %C
  %eqv = xor <2 x i64> %xor, <i64 -1, i64 -1>  ; Vector eqv operation
  %res = select <2 x i1> %A, <2 x i64> %nand, <2 x i64> %eqv
  ret <2 x i64> %res
}

; Function to test ternary(A, nand(B, C), eqv(B, C)) for <16 x i8>
define <16 x i8> @ternary_A_nand_BC_eqv_BC_16x8(<16 x i1> %A, <16 x i8> %B, <16 x i8> %C) {
; CHECK-LABEL: ternary_A_nand_BC_eqv_BC_16x8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltib v5, 7
; CHECK-NEXT:    xxlnand vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslb v2, v2, v5
; CHECK-NEXT:    vsrab v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %and = and <16 x i8> %B, %C
  %nand = xor <16 x i8> %and, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>  ; Vector nand operation
  %xor = xor <16 x i8> %B, %C
  %eqv = xor <16 x i8> %xor, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>  ; Vector eqv operation
  %res = select <16 x i1> %A, <16 x i8> %nand, <16 x i8> %eqv
  ret <16 x i8> %res
}

; Function to test ternary(A, nand(B, C), eqv(B, C)) for <8 x i16>
define <8 x i16> @ternary_A_nand_BC_eqv_BC_8x16(<8 x i1> %A, <8 x i16> %B, <8 x i16> %C) {
; CHECK-LABEL: ternary_A_nand_BC_eqv_BC_8x16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xxspltiw v5, 983055
; CHECK-NEXT:    xxlnand vs0, v3, v4
; CHECK-NEXT:    xxleqv vs1, v3, v4
; CHECK-NEXT:    vslh v2, v2, v5
; CHECK-NEXT:    vsrah v2, v2, v5
; CHECK-NEXT:    xxsel v2, vs1, vs0, v2
; CHECK-NEXT:    blr
entry:
  %and = and <8 x i16> %B, %C
  %nand = xor <8 x i16> %and, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>  ; Vector nand operation
  %xor = xor <8 x i16> %B, %C
  %eqv = xor <8 x i16> %xor, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>  ; Vector eqv operation
  %res = select <8 x i1> %A, <8 x i16> %nand, <8 x i16> %eqv
  ret <8 x i16> %res
}
