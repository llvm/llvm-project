; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mcpu=ppc -mtriple=powerpc64 -verify-machineinstrs < %s \
; RUN:     | FileCheck %s --check-prefixes=BE64
; RUN: llc -mtriple=powerpc64le -verify-machineinstrs < %s \
; RUN:     | FileCheck %s --check-prefixes=LE64
; RUN: llc -mtriple=ppc32 -verify-machineinstrs < %s \
; RUN:     | FileCheck %s --check-prefixes=LE32

define void @foo(i64 %t) sspstrong nounwind {
; BE64-LABEL: foo:
; BE64:       # %bb.0:
; BE64-NEXT:    mflr 0
; BE64-NEXT:    std 31, -8(1)
; BE64-NEXT:    stdu 1, -144(1)
; BE64-NEXT:    ld 4, 500(13)
; BE64-NEXT:    sldi 3, 3, 2
; BE64-NEXT:    mr 31, 1
; BE64-NEXT:    addi 3, 3, 15
; BE64-NEXT:    rldicr 3, 3, 0, 59
; BE64-NEXT:    std 0, 160(1)
; BE64-NEXT:    neg 3, 3
; BE64-NEXT:    std 4, 128(31)
; BE64-NEXT:    addi 4, 31, 144
; BE64-NEXT:    stdux 4, 1, 3
; BE64-NEXT:    addi 3, 1, 112
; BE64-NEXT:    bl baz
; BE64-NEXT:    nop
; BE64-NEXT:    ld 3, 128(31)
; BE64-NEXT:    ld 4, 500(13)
; BE64-NEXT:    cmpld 4, 3
; BE64-NEXT:    bne 0, .LBB0_2
; BE64-NEXT:  # %bb.1:
; BE64-NEXT:    ld 1, 0(1)
; BE64-NEXT:    ld 0, 16(1)
; BE64-NEXT:    ld 31, -8(1)
; BE64-NEXT:    mtlr 0
; BE64-NEXT:    blr
; BE64-NEXT:  .LBB0_2:
; BE64-NEXT:    bl __stack_chk_fail
; BE64-NEXT:    nop
;
; LE64-LABEL: foo:
; LE64:       # %bb.0:
; LE64-NEXT:    mflr 0
; LE64-NEXT:    std 31, -8(1)
; LE64-NEXT:    stdu 1, -64(1)
; LE64-NEXT:    sldi 3, 3, 2
; LE64-NEXT:    ld 4, 500(13)
; LE64-NEXT:    std 0, 80(1)
; LE64-NEXT:    addi 3, 3, 15
; LE64-NEXT:    mr 31, 1
; LE64-NEXT:    std 4, 48(31)
; LE64-NEXT:    addi 4, 31, 64
; LE64-NEXT:    rldicr 3, 3, 0, 59
; LE64-NEXT:    neg 3, 3
; LE64-NEXT:    stdux 4, 1, 3
; LE64-NEXT:    addi 3, 1, 32
; LE64-NEXT:    bl baz
; LE64-NEXT:    nop
; LE64-NEXT:    ld 3, 48(31)
; LE64-NEXT:    ld 4, 500(13)
; LE64-NEXT:    cmpld 4, 3
; LE64-NEXT:    bne 0, .LBB0_2
; LE64-NEXT:  # %bb.1:
; LE64-NEXT:    ld 1, 0(1)
; LE64-NEXT:    ld 0, 16(1)
; LE64-NEXT:    ld 31, -8(1)
; LE64-NEXT:    mtlr 0
; LE64-NEXT:    blr
; LE64-NEXT:  .LBB0_2:
; LE64-NEXT:    bl __stack_chk_fail
; LE64-NEXT:    nop
;
; LE32-LABEL: foo:
; LE32:       # %bb.0:
; LE32-NEXT:    mflr 0
; LE32-NEXT:    stwu 1, -32(1)
; LE32-NEXT:    lwz 3, 500(2)
; LE32-NEXT:    slwi 4, 4, 2
; LE32-NEXT:    addi 4, 4, 15
; LE32-NEXT:    stw 31, 28(1)
; LE32-NEXT:    mr 31, 1
; LE32-NEXT:    rlwinm 4, 4, 0, 0, 27
; LE32-NEXT:    stw 0, 36(1)
; LE32-NEXT:    neg 4, 4
; LE32-NEXT:    stw 3, 24(31)
; LE32-NEXT:    addi 3, 31, 32
; LE32-NEXT:    stwux 3, 1, 4
; LE32-NEXT:    addi 3, 1, 16
; LE32-NEXT:    bl baz
; LE32-NEXT:    lwz 3, 24(31)
; LE32-NEXT:    lwz 4, 500(2)
; LE32-NEXT:    cmplw 4, 3
; LE32-NEXT:    bne 0, .LBB0_2
; LE32-NEXT:  # %bb.1:
; LE32-NEXT:    lwz 31, 0(1)
; LE32-NEXT:    lwz 0, -4(31)
; LE32-NEXT:    mr 1, 31
; LE32-NEXT:    mr 31, 0
; LE32-NEXT:    lwz 0, 4(1)
; LE32-NEXT:    mtlr 0
; LE32-NEXT:    blr
; LE32-NEXT:  .LBB0_2:
; LE32-NEXT:    bl __stack_chk_fail
  %vla = alloca i32, i64 %t, align 4
  call void @baz(ptr %vla)
  ret void
}

declare void @baz(ptr)

!llvm.module.flags = !{!1, !2}
!1 = !{i32 2, !"stack-protector-guard", !"tls"}
!2 = !{i32 2, !"stack-protector-guard-offset", i32 500}
