;; Test ppc-vsx-fma-mutate pass with -schedule-ppc-vsx-fma-mutation-early do not hosit some xxspltiw instruction.
; RUN: llc -verify-machineinstrs -mcpu=pwr10 -disable-ppc-vsx-fma-mutation=false \
; RUN:   -ppc-asm-full-reg-names -schedule-ppc-vsx-fma-mutation-early \
; RUN:    -mtriple powerpc64-ibm-aix < %s | FileCheck --check-prefix=CHECK64-M %s

; RUN: llc -verify-machineinstrs -mcpu=pwr10 -disable-ppc-vsx-fma-mutation=false \
; RUN:   -ppc-asm-full-reg-names -schedule-ppc-vsx-fma-mutation-early \
; RUN:   -mtriple=powerpc64le-unknown-linux-gnu < %s | FileCheck --check-prefix=CHECK64-M %s

; RUN: llc -verify-machineinstrs -mcpu=pwr10 -disable-ppc-vsx-fma-mutation=false \
; RUN:   -ppc-asm-full-reg-names -schedule-ppc-vsx-fma-mutation-early \
; RUN:    -mtriple powerpc-ibm-aix < %s | FileCheck --check-prefix=CHECK32-M %s

define void @vsexp(ptr noalias nocapture noundef writeonly %__output_a, ptr noalias nocapture noundef readonly %var1321In_a, ptr noalias nocapture noundef readonly %n) {
entry:
  %0 = load i32, ptr %n, align 4
  %cmp11 = icmp sgt i32 %0, 0
  br i1 %cmp11, label %for.body.preheader, label %for.end

for.body.preheader:
  %wide.trip.count = zext i32 %0 to i64
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %1 = shl nsw i64 %indvars.iv, 2
  %add.ptr = getelementptr inbounds float, ptr %var1321In_a, i64 %1
  %add.ptr.val = load <4 x float>, ptr %add.ptr, align 1
  %2 = tail call contract <4 x float> @llvm.fma.v4f32(<4 x float> %add.ptr.val, <4 x float> <float 0x3FF7154760000000, float 0x3FF7154760000000, float 0x3FF7154760000000, float 0x3FF7154760000000>, <4 x float> <float 6.270500e+03, float 6.270500e+03, float 6.270500e+03, float 6.270500e+03>)
  %add.ptr6 = getelementptr inbounds float, ptr %__output_a, i64 %1
  store <4 x float> %2, ptr %add.ptr6, align 1 
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare <4 x float> @llvm.fma.v4f32(<4 x float>, <4 x float>, <4 x float>) 

; CHECK64-M:      # %bb.0:                                # %entry
; CHECK64-M-NEXT:         lwz r5, 0(r5)
; CHECK64-M-NEXT:         cmpwi   r5, 1
; CHECK64-M-NEXT:         bltlr   cr0
; CHECK64-M-NEXT: # %bb.1:                                # %for.body.preheader
; CHECK64-M-NEXT:         xxspltiw vs0, 1069066811
; CHECK64-M-NEXT:         mtctr r5
; CHECK64-M-NEXT:         li r5, 0
; CHECK64-M-NEXT:         {{.*}}align  5
; CHECK64-M-NEXT: [[L2:.*]]:                               # %for.body
; CHECK64-M-NEXT:                                         # =>This Inner Loop Header: Depth=1
; CHECK64-M-NEXT:         lxvx vs1, r4, r5
; CHECK64-M-NEXT:         xxspltiw vs2, 1170469888
; CHECK64-M-NEXT:         xvmaddasp vs2, vs1, vs0
; CHECK64-M-NEXT:         stxvx vs2, r3, r5
; CHECK64-M-NEXT:         addi r5, r5, 16
; CHECK64-M-NEXT:         bdnz [[L2]]
; CHECK64-M-NEXT: # %bb.3:                                # %for.end
; CHECK64-M-NEXT:         blr

; CHECK32-M:        .vsexp:
; CHECK32-M-NEXT: # %bb.0:                                # %entry
; CHECK32-M-NEXT:       lwz r5, 0(r5)
; CHECK32-M-NEXT:       cmpwi   r5, 0
; CHECK32-M-NEXT:       blelr cr0
; CHECK32-M-NEXT: # %bb.1:                                # %for.body.preheader
; CHECK32-M-NEXT:       xxspltiw vs0, 1069066811
; CHECK32-M-NEXT:       li r6, 0
; CHECK32-M-NEXT:       li r7, 0
; CHECK32-M-NEXT:       .align  4
; CHECK32-M-NEXT: L..BB0_2:                               # %for.body
; CHECK32-M-NEXT:                                         # =>This Inner Loop Header: Depth=1
; CHECK32-M-NEXT:       slwi r8, r7, 4
; CHECK32-M-NEXT:       xxspltiw vs2, 1170469888
; CHECK32-M-NEXT:       addic r7, r7, 1
; CHECK32-M-NEXT:       addze r6, r6
; CHECK32-M-NEXT:       lxvx vs1, r4, r8
; CHECK32-M-NEXT:       xvmaddasp vs2, vs1, vs0
; CHECK32-M-NEXT:       stxvx vs2, r3, r8
; CHECK32-M-NEXT:       xor r8, r7, r5
; CHECK32-M-NEXT:       or. r8, r8, r6
; CHECK32-M-NEXT:       bne     cr0, L..BB0_2
