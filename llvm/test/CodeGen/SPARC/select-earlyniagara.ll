; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O3 < %s -relocation-model=pic -mtriple=sparc -mcpu=v9 | FileCheck --check-prefix=SPARC %s
; RUN: llc -O3 < %s -relocation-model=pic -mtriple=sparcv9 -mcpu=v9 | FileCheck --check-prefix=SPARC64 %s

;; Early Niagara processors should prefer conditional moves over branches
;; even when it's predictable.

define i32 @cinc(i32 %cond, i32 %num) #0 {
; SPARC-LABEL: cinc:
; SPARC:       ! %bb.0: ! %entry
; SPARC-NEXT:    cmp %o0, 0
; SPARC-NEXT:    bne %icc, .LBB0_2
; SPARC-NEXT:    mov %o1, %o0
; SPARC-NEXT:  ! %bb.1: ! %inc
; SPARC-NEXT:    add %o0, 1, %o0
; SPARC-NEXT:  .LBB0_2: ! %cont
; SPARC-NEXT:    retl
; SPARC-NEXT:    nop
;
; SPARC64-LABEL: cinc:
; SPARC64:       ! %bb.0: ! %entry
; SPARC64-NEXT:    cmp %o0, 0
; SPARC64-NEXT:    bne %icc, .LBB0_2
; SPARC64-NEXT:    mov %o1, %o0
; SPARC64-NEXT:  ! %bb.1: ! %inc
; SPARC64-NEXT:    add %o0, 1, %o0
; SPARC64-NEXT:  .LBB0_2: ! %cont
; SPARC64-NEXT:    retl
; SPARC64-NEXT:    nop
entry:
  %cmp = icmp eq i32 %cond, 0
  %exp = call i1 @llvm.expect.i1(i1 %cmp, i1 0)
  br i1 %exp, label %inc, label %cont
inc:
  %add = add nsw i32 %num, 1
  br label %cont
cont:
  %phi = phi i32 [ %add, %inc ], [ %num, %entry ]
  ret i32 %phi
}
declare i1 @llvm.expect.i1(i1, i1)

attributes #0 = { nounwind "tune-cpu"="niagara" }
