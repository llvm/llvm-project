; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=avr -mattr=movw -verify-machineinstrs | FileCheck %s

define i32 @shl_i32_1(i32 %a) {
; CHECK-LABEL: shl_i32_1:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    lsl r22
; CHECK-NEXT:    rol r23
; CHECK-NEXT:    rol r24
; CHECK-NEXT:    rol r25
; CHECK-NEXT:    ret
  %res = shl i32 %a, 1
  ret i32 %res
}

define i32 @shl_i32_2(i32 %a) {
; CHECK-LABEL: shl_i32_2:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    lsl r22
; CHECK-NEXT:    rol r23
; CHECK-NEXT:    rol r24
; CHECK-NEXT:    rol r25
; CHECK-NEXT:    lsl r22
; CHECK-NEXT:    rol r23
; CHECK-NEXT:    rol r24
; CHECK-NEXT:    rol r25
; CHECK-NEXT:    ret
  %res = shl i32 %a, 2
  ret i32 %res
}

; This is a special case: this shift is performed directly inside SelectionDAG
; instead of as a custom lowering like the other shift operations.
define i32 @shl_i32_16(i32 %a) {
; CHECK-LABEL: shl_i32_16:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    movw r24, r22
; CHECK-NEXT:    ldi r22, 0
; CHECK-NEXT:    ldi r23, 0
; CHECK-NEXT:    ret
  %res = shl i32 %a, 16
  ret i32 %res
}

; Combined with the register allocator, shift instructions can sometimes be
; optimized away entirely. The least significant registers are simply stored
; directly instead of moving them first.
define void @shl_i32_16_ptr(i32 %a, ptr %ptr) {
; CHECK-LABEL: shl_i32_16_ptr:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    movw r30, r20
; CHECK-NEXT:    std Z+2, r22
; CHECK-NEXT:    std Z+3, r23
; CHECK-NEXT:    ldi r24, 0
; CHECK-NEXT:    ldi r25, 0
; CHECK-NEXT:    st Z, r24
; CHECK-NEXT:    std Z+1, r25
; CHECK-NEXT:    ret
  %res = shl i32 %a, 16
  store i32 %res, ptr %ptr
  ret void
}

define i32 @lshr_i32_1(i32 %a) {
; CHECK-LABEL: lshr_i32_1:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    lsr r25
; CHECK-NEXT:    ror r24
; CHECK-NEXT:    ror r23
; CHECK-NEXT:    ror r22
; CHECK-NEXT:    ret
  %res = lshr i32 %a, 1
  ret i32 %res
}

define i32 @lshr_i32_2(i32 %a) {
; CHECK-LABEL: lshr_i32_2:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    lsr r25
; CHECK-NEXT:    ror r24
; CHECK-NEXT:    ror r23
; CHECK-NEXT:    ror r22
; CHECK-NEXT:    lsr r25
; CHECK-NEXT:    ror r24
; CHECK-NEXT:    ror r23
; CHECK-NEXT:    ror r22
; CHECK-NEXT:    ret
  %res = lshr i32 %a, 2
  ret i32 %res
}

define i32 @lshr_i32_16(i32 %a) {
; CHECK-LABEL: lshr_i32_16:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    movw r22, r24
; CHECK-NEXT:    ldi r24, 0
; CHECK-NEXT:    ldi r25, 0
; CHECK-NEXT:    ret
  %res = lshr i32 %a, 16
  ret i32 %res
}

define i32 @ashr_i32_1(i32 %a) {
; CHECK-LABEL: ashr_i32_1:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    asr r25
; CHECK-NEXT:    ror r24
; CHECK-NEXT:    ror r23
; CHECK-NEXT:    ror r22
; CHECK-NEXT:    ret
  %res = ashr i32 %a, 1
  ret i32 %res
}

define i32 @ashr_i32_2(i32 %a) {
; CHECK-LABEL: ashr_i32_2:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    asr r25
; CHECK-NEXT:    ror r24
; CHECK-NEXT:    ror r23
; CHECK-NEXT:    ror r22
; CHECK-NEXT:    asr r25
; CHECK-NEXT:    ror r24
; CHECK-NEXT:    ror r23
; CHECK-NEXT:    ror r22
; CHECK-NEXT:    ret
  %res = ashr i32 %a, 2
  ret i32 %res
}
