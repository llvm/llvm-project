; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=riscv32 -mattr=-zbc,-zbkc -verify-machineinstrs | FileCheck %s --check-prefix=RV32-EXPAND
; RUN: llc < %s -mtriple=riscv64 -mattr=-zbc,-zbkc -verify-machineinstrs | FileCheck %s --check-prefix=RV64-EXPAND
; RUN: llc < %s -mtriple=x86_64 -verify-machineinstrs | FileCheck %s --check-prefix=X64-EXPAND

; Test CLMUL expansion when the instruction is not natively supported

declare i8 @llvm.clmul.i8(i8 %a, i8 %b)
declare i16 @llvm.clmul.i16(i16 %a, i16 %b)
declare i32 @llvm.clmul.i32(i32 %a, i32 %b)
declare i64 @llvm.clmul.i64(i64 %a, i64 %b)
declare i128 @llvm.clmul.i128(i128 %a, i128 %b)

define i8 @clmul_expand_i8(i8 %a, i8 %b) nounwind {
; RV32-EXPAND-LABEL: clmul_expand_i8:
; RV32-EXPAND:       # %bb.0:
; RV32-EXPAND-NEXT:    andi a2, a0, 1
; RV32-EXPAND-NEXT:    beqz a2, .LBB0_2
; RV32-EXPAND-NEXT:  # %bb.1:
; RV32-EXPAND-NEXT:    mv a2, a1
; RV32-EXPAND-NEXT:    j .LBB0_3
; RV32-EXPAND-NEXT:  .LBB0_2:
; RV32-EXPAND-NEXT:    li a2, 0
; RV32-EXPAND-NEXT:  .LBB0_3:
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
; RV32-EXPAND-NEXT:    andi a3, a0, 1
; RV32-EXPAND-NEXT:    beqz a3, .LBB0_5
; RV32-EXPAND-NEXT:  # %bb.4:
; RV32-EXPAND-NEXT:    xor a2, a2, a1
; RV32-EXPAND-NEXT:  .LBB0_5:
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
; RV32-EXPAND-NEXT:    andi a3, a0, 1
; RV32-EXPAND-NEXT:    beqz a3, .LBB0_7
; RV32-EXPAND-NEXT:  # %bb.6:
; RV32-EXPAND-NEXT:    xor a2, a2, a1
; RV32-EXPAND-NEXT:  .LBB0_7:
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
; RV32-EXPAND-NEXT:    andi a3, a0, 1
; RV32-EXPAND-NEXT:    beqz a3, .LBB0_9
; RV32-EXPAND-NEXT:  # %bb.8:
; RV32-EXPAND-NEXT:    xor a2, a2, a1
; RV32-EXPAND-NEXT:  .LBB0_9:
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
; RV32-EXPAND-NEXT:    andi a3, a0, 1
; RV32-EXPAND-NEXT:    beqz a3, .LBB0_11
; RV32-EXPAND-NEXT:  # %bb.10:
; RV32-EXPAND-NEXT:    xor a2, a2, a1
; RV32-EXPAND-NEXT:  .LBB0_11:
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
; RV32-EXPAND-NEXT:    andi a3, a0, 1
; RV32-EXPAND-NEXT:    beqz a3, .LBB0_13
; RV32-EXPAND-NEXT:  # %bb.12:
; RV32-EXPAND-NEXT:    xor a2, a2, a1
; RV32-EXPAND-NEXT:  .LBB0_13:
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
; RV32-EXPAND-NEXT:    andi a3, a0, 1
; RV32-EXPAND-NEXT:    beqz a3, .LBB0_15
; RV32-EXPAND-NEXT:  # %bb.14:
; RV32-EXPAND-NEXT:    xor a2, a2, a1
; RV32-EXPAND-NEXT:  .LBB0_15:
; RV32-EXPAND-NEXT:    andi a0, a0, 2
; RV32-EXPAND-NEXT:    beqz a0, .LBB0_17
; RV32-EXPAND-NEXT:  # %bb.16:
; RV32-EXPAND-NEXT:    slli a0, a1, 1
; RV32-EXPAND-NEXT:    xor a2, a2, a0
; RV32-EXPAND-NEXT:  .LBB0_17:
; RV32-EXPAND-NEXT:    mv a0, a2
; RV32-EXPAND-NEXT:    ret
  %result = call i8 @llvm.clmul.i8(i8 %a, i8 %b)
  ret i8 %result
}

define i16 @clmul_expand_i16(i16 %a, i16 %b) nounwind {
; RV32-EXPAND-LABEL: clmul_expand_i16:
; RV32-EXPAND:       # %bb.0:
; RV32-EXPAND-NEXT:    andi a2, a0, 1
; RV32-EXPAND-NEXT:    beqz a2, .LBB1_2
; RV32-EXPAND-NEXT:  # %bb.1:
; RV32-EXPAND-NEXT:    mv a2, a1
; RV32-EXPAND-NEXT:    j .LBB1_3
; RV32-EXPAND-NEXT:  .LBB1_2:
; RV32-EXPAND-NEXT:    li a2, 0
; RV32-EXPAND-NEXT:  .LBB1_3:  
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
  %result = call i16 @llvm.clmul.i16(i16 %a, i16 %b)
  ret i16 %result
}

define i32 @clmul_expand_i32(i32 %a, i32 %b) nounwind {
; RV32-EXPAND-LABEL: clmul_expand_i32:
; RV32-EXPAND:       # %bb.0:
; RV32-EXPAND-NEXT:    andi a2, a0, 1
; RV32-EXPAND-NEXT:    beqz a2, .LBB2_2
; RV32-EXPAND-NEXT:  # %bb.1:
; RV32-EXPAND-NEXT:    mv a2, a1
; RV32-EXPAND-NEXT:    j .LBB2_3
; RV32-EXPAND-NEXT:  .LBB2_2:
; RV32-EXPAND-NEXT:    li a2, 0
; RV32-EXPAND-NEXT:  .LBB2_3:
; RV32-EXPAND-NEXT:    srli a0, a0, 1
; RV32-EXPAND-NEXT:    slli a1, a1, 1
  %result = call i32 @llvm.clmul.i32(i32 %a, i32 %b)
  ret i32 %result
}

define i64 @clmul_expand_i64(i64 %a, i64 %b) nounwind {
; RV32-EXPAND-LABEL: clmul_expand_i64:
; RV32-EXPAND:       # %bb.0:
; RV32-EXPAND-NEXT:    addi sp, sp, -16
; RV32-EXPAND-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32-EXPAND-NEXT:    call __clmuldi3
; RV32-EXPAND-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32-EXPAND-NEXT:    addi sp, sp, 16
; RV32-EXPAND-NEXT:    ret
;
; RV64-EXPAND-LABEL: clmul_expand_i64:
; RV64-EXPAND:       # %bb.0:
; RV64-EXPAND-NEXT:    andi a2, a0, 1
; RV64-EXPAND-NEXT:    beqz a2, .LBB3_2
; RV64-EXPAND-NEXT:  # %bb.1:
; RV64-EXPAND-NEXT:    mv a2, a1
; RV64-EXPAND-NEXT:    j .LBB3_3
; RV64-EXPAND-NEXT:  .LBB3_2:
; RV64-EXPAND-NEXT:    li a2, 0
; RV64-EXPAND-NEXT:  .LBB3_3:
; RV64-EXPAND-NEXT:    srli a0, a0, 1
; RV64-EXPAND-NEXT:    slli a1, a1, 1
  %result = call i64 @llvm.clmul.i64(i64 %a, i64 %b)
  ret i64 %result
}

define i128 @clmul_expand_i128(i128 %a, i128 %b) nounwind {
; RV32-EXPAND-LABEL: clmul_expand_i128:
; RV32-EXPAND:       # %bb.0:
; RV32-EXPAND-NEXT:    addi sp, sp, -16
; RV32-EXPAND-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; RV32-EXPAND-NEXT:    call __clmulti3
; RV32-EXPAND-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; RV32-EXPAND-NEXT:    addi sp, sp, 16
; RV32-EXPAND-NEXT:    ret
;
; RV64-EXPAND-LABEL: clmul_expand_i128:
; RV64-EXPAND:       # %bb.0:
; RV64-EXPAND-NEXT:    addi sp, sp, -16
; RV64-EXPAND-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; RV64-EXPAND-NEXT:    call __clmulti3
; RV64-EXPAND-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; RV64-EXPAND-NEXT:    addi sp, sp, 16
; RV64-EXPAND-NEXT:    ret
  %result = call i128 @llvm.clmul.i128(i128 %a, i128 %b)
  ret i128 %result
}

; Test with known constants to verify correctness
define i8 @clmul_expand_i8_known() nounwind {
; RV32-EXPAND-LABEL: clmul_expand_i8_known:
; RV32-EXPAND:       # %bb.0:
; RV32-EXPAND-NEXT:    li a0, 14
; RV32-EXPAND-NEXT:    ret
;
; RV64-EXPAND-LABEL: clmul_expand_i8_known:
; RV64-EXPAND:       # %bb.0:
; RV64-EXPAND-NEXT:    li a0, 14
; RV64-EXPAND-NEXT:    ret
  ; clmul(5, 6) = clmul(0b101, 0b110) = 0b1110 = 14
  %result = call i8 @llvm.clmul.i8(i8 5, i8 6)
  ret i8 %result
}

define i16 @clmul_expand_i16_known() nounwind {
; RV32-EXPAND-LABEL: clmul_expand_i16_known:
; RV32-EXPAND:       # %bb.0:
; RV32-EXPAND-NEXT:    li a0, 158
; RV32-EXPAND-NEXT:    ret
;
; RV64-EXPAND-LABEL: clmul_expand_i16_known:
; RV64-EXPAND:       # %bb.0:
; RV64-EXPAND-NEXT:    li a0, 158
; RV64-EXPAND-NEXT:    ret
  ; clmul(15, 13) = clmul(0b1111, 0b1101) = 0b10011110 = 158
  %result = call i16 @llvm.clmul.i16(i16 15, i16 13)
  ret i16 %result
}