; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=riscv32 -mattr=-zbc,-zbkc -verify-machineinstrs | FileCheck %s --check-prefix=RV32
; RUN: llc < %s -mtriple=riscv64 -mattr=-zbc,-zbkc -verify-machineinstrs | FileCheck %s --check-prefix=RV64
; RUN: llc < %s -mtriple=x86_64 -verify-machineinstrs | FileCheck %s --check-prefix=X64

; Test CLMUL with vector types

declare <2 x i32> @llvm.clmul.v2i32(<2 x i32> %a, <2 x i32> %b)
declare <4 x i32> @llvm.clmul.v4i32(<4 x i32> %a, <4 x i32> %b)
declare <2 x i64> @llvm.clmul.v2i64(<2 x i64> %a, <2 x i64> %b)
declare <8 x i16> @llvm.clmul.v8i16(<8 x i16> %a, <8 x i16> %b)
declare <16 x i8> @llvm.clmul.v16i8(<16 x i8> %a, <16 x i8> %b)

define <2 x i32> @clmul_v2i32(<2 x i32> %a, <2 x i32> %b) nounwind {
; RV32-LABEL: clmul_v2i32:
; RV32:       # %bb.0:
; RV32-NEXT:    addi sp, sp, -32
; RV32-NEXT:    sw s0, 28(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s1, 24(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s2, 20(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s3, 16(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s4, 12(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s5, 8(sp) # 4-byte Folded Spill
; RV32-NEXT:    mv s0, a3
; RV32-NEXT:    mv s1, a2
; RV32-NEXT:    mv s2, a1
; RV32-NEXT:    mv s3, a0
; RV32-NEXT:    andi a0, a3, 1
; RV32-NEXT:    beqz a0, .LBB0_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    mv s4, s1
; RV32-NEXT:    j .LBB0_3
; RV32-NEXT:  .LBB0_2:
; RV32-NEXT:    li s4, 0
; RV32-NEXT:  .LBB0_3:
; RV32-NEXT:    srli s0, s0, 1
; RV32-NEXT:    slli s1, s1, 1
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> %a, <2 x i32> %b)
  ret <2 x i32> %result
}

define <4 x i32> @clmul_v4i32(<4 x i32> %a, <4 x i32> %b) nounwind {
; RV32-LABEL: clmul_v4i32:
; RV32:       # %bb.0:
; RV32-NEXT:    addi sp, sp, -80
; RV32-NEXT:    sw ra, 76(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s0, 72(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s1, 68(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s2, 64(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s3, 60(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s4, 56(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s5, 52(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s6, 48(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s7, 44(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s8, 40(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s9, 36(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s10, 32(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s11, 28(sp) # 4-byte Folded Spill
  %result = call <4 x i32> @llvm.clmul.v4i32(<4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %result
}

define <2 x i64> @clmul_v2i64(<2 x i64> %a, <2 x i64> %b) nounwind {
; RV32-LABEL: clmul_v2i64:
; RV32:       # %bb.0:
; RV32-NEXT:    addi sp, sp, -48
; RV32-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s1, 36(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s2, 32(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s3, 28(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s4, 24(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s5, 20(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s6, 16(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s7, 12(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s8, 8(sp) # 4-byte Folded Spill
; RV32-NEXT:    lw s0, 64(sp)
; RV32-NEXT:    lw s1, 68(sp)
; RV32-NEXT:    lw s2, 72(sp)
; RV32-NEXT:    lw s3, 76(sp)
; RV32-NEXT:    mv s4, a0
; RV32-NEXT:    mv s5, a1
; RV32-NEXT:    mv s6, a2
; RV32-NEXT:    mv s7, a3
; RV32-NEXT:    mv a0, s6
; RV32-NEXT:    mv a1, s7
; RV32-NEXT:    mv a2, s2
; RV32-NEXT:    mv a3, s3
; RV32-NEXT:    call __clmuldi3
; RV32-NEXT:    mv s8, a0
; RV32-NEXT:    mv s2, a1
; RV32-NEXT:    mv a0, s4
; RV32-NEXT:    mv a1, s5
; RV32-NEXT:    mv a2, s0
; RV32-NEXT:    mv a3, s1
; RV32-NEXT:    call __clmuldi3
; RV32-NEXT:    mv a2, a0
; RV32-NEXT:    mv a3, a1
; RV32-NEXT:    mv a0, a2
; RV32-NEXT:    mv a1, a3
; RV32-NEXT:    mv a2, s8
; RV32-NEXT:    mv a3, s2
; RV32-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s1, 36(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s2, 32(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s3, 28(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s4, 24(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s5, 20(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s6, 16(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s7, 12(sp) # 4-byte Folded Reload
; RV32-NEXT:    lw s8, 8(sp) # 4-byte Folded Reload
; RV32-NEXT:    addi sp, sp, 48
; RV32-NEXT:    ret
  %result = call <2 x i64> @llvm.clmul.v2i64(<2 x i64> %a, <2 x i64> %b)
  ret <2 x i64> %result
}

define <8 x i16> @clmul_v8i16(<8 x i16> %a, <8 x i16> %b) nounwind {
; RV32-LABEL: clmul_v8i16:
; RV32:       # %bb.0:
; RV32-NEXT:    addi sp, sp, -144
; RV32-NEXT:    sw ra, 140(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s0, 136(sp) # 4-byte Folded Spill
  %result = call <8 x i16> @llvm.clmul.v8i16(<8 x i16> %a, <8 x i16> %b)
  ret <8 x i16> %result
}

define <16 x i8> @clmul_v16i8(<16 x i8> %a, <16 x i8> %b) nounwind {
; RV32-LABEL: clmul_v16i8:
; RV32:       # %bb.0:
; RV32-NEXT:    addi sp, sp, -272
; RV32-NEXT:    sw ra, 268(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s0, 264(sp) # 4-byte Folded Spill
  %result = call <16 x i8> @llvm.clmul.v16i8(<16 x i8> %a, <16 x i8> %b)
  ret <16 x i8> %result
}

; Test with splat vectors  
define <2 x i32> @clmul_v2i32_splat(<2 x i32> %a) nounwind {
; RV32-LABEL: clmul_v2i32_splat:
; RV32:       # %bb.0:
; RV32-NEXT:    addi sp, sp, -32
; RV32-NEXT:    sw s0, 28(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s1, 24(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s2, 20(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s3, 16(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s4, 12(sp) # 4-byte Folded Spill
; RV32-NEXT:    sw s5, 8(sp) # 4-byte Folded Spill
; RV32-NEXT:    mv s0, a1
; RV32-NEXT:    mv s1, a0
; RV32-NEXT:    andi a0, a1, 1
; RV32-NEXT:    li s2, 3
; RV32-NEXT:    beqz a0, .LBB5_2
; RV32-NEXT:  # %bb.1:
; RV32-NEXT:    mv s3, s2
; RV32-NEXT:    j .LBB5_3
; RV32-NEXT:  .LBB5_2:
; RV32-NEXT:    li s3, 0
; RV32-NEXT:  .LBB5_3:
; RV32-NEXT:    srli s0, s0, 1
; RV32-NEXT:    slli s2, s2, 1
  %splat = insertelement <2 x i32> poison, i32 3, i32 0
  %splat_vec = shufflevector <2 x i32> %splat, <2 x i32> poison, <2 x i32> zeroinitializer
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> %a, <2 x i32> %splat_vec)
  ret <2 x i32> %result
}

; Test with constant vectors
define <2 x i32> @clmul_v2i32_const() nounwind {
; RV32-LABEL: clmul_v2i32_const:
; RV32:       # %bb.0:
; RV32-NEXT:    li a0, 14
; RV32-NEXT:    li a1, 6
; RV32-NEXT:    ret
  %result = call <2 x i32> @llvm.clmul.v2i32(<2 x i32> <i32 5, i32 2>, <2 x i32> <i32 6, i32 3>)
  ret <2 x i32> %result
}