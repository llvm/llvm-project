; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=arm64-eabi -mattr=crypto -aarch64-neon-syntax=apple -o - %s | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -mtriple=arm64-eabi -mattr=crypto -aarch64-neon-syntax=apple -global-isel -o - %s | FileCheck %s --check-prefixes=CHECK,CHECK-GI


declare <16 x i8> @llvm.aarch64.crypto.aese(<16 x i8> %data, <16 x i8> %key)
declare <16 x i8> @llvm.aarch64.crypto.aesd(<16 x i8> %data, <16 x i8> %key)
declare <16 x i8> @llvm.aarch64.crypto.aesmc(<16 x i8> %data)
declare <16 x i8> @llvm.aarch64.crypto.aesimc(<16 x i8> %data)

define <16 x i8> @test_aese(<16 x i8> %data, <16 x i8> %key) {
; CHECK-LABEL: test_aese:
; CHECK:       // %bb.0:
; CHECK-NEXT:    aese.16b v0, v1
; CHECK-NEXT:    ret
  %res = call <16 x i8> @llvm.aarch64.crypto.aese(<16 x i8> %data, <16 x i8> %key)
  ret <16 x i8> %res
}

define <16 x i8> @test_aesd(<16 x i8> %data, <16 x i8> %key) {
; CHECK-LABEL: test_aesd:
; CHECK:       // %bb.0:
; CHECK-NEXT:    aesd.16b v0, v1
; CHECK-NEXT:    ret
  %res = call <16 x i8> @llvm.aarch64.crypto.aesd(<16 x i8> %data, <16 x i8> %key)
  ret <16 x i8> %res
}

define <16 x i8> @test_aesmc(<16 x i8> %data) {
; CHECK-LABEL: test_aesmc:
; CHECK:       // %bb.0:
; CHECK-NEXT:    aesmc.16b v0, v0
; CHECK-NEXT:    ret
 %res = call <16 x i8> @llvm.aarch64.crypto.aesmc(<16 x i8> %data)
  ret <16 x i8> %res
}

define <16 x i8> @test_aesimc(<16 x i8> %data) {
; CHECK-LABEL: test_aesimc:
; CHECK:       // %bb.0:
; CHECK-NEXT:    aesimc.16b v0, v0
; CHECK-NEXT:    ret
 %res = call <16 x i8> @llvm.aarch64.crypto.aesimc(<16 x i8> %data)
  ret <16 x i8> %res
}

declare <4 x i32> @llvm.aarch64.crypto.sha1c(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk)
declare <4 x i32> @llvm.aarch64.crypto.sha1p(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk)
declare <4 x i32> @llvm.aarch64.crypto.sha1m(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk)
declare i32 @llvm.aarch64.crypto.sha1h(i32 %hash_e)
declare <4 x i32> @llvm.aarch64.crypto.sha1su0(<4 x i32> %wk0_3, <4 x i32> %wk4_7, <4 x i32> %wk8_11)
declare <4 x i32> @llvm.aarch64.crypto.sha1su1(<4 x i32> %wk0_3, <4 x i32> %wk12_15)

define <4 x i32> @test_sha1c(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk) {
; CHECK-LABEL: test_sha1c:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov s2, w0
; CHECK-NEXT:    sha1c.4s q0, s2, v1
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha1c(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk)
  ret <4 x i32> %res
}

; <rdar://problem/14742333> Incomplete removal of unnecessary FMOV instructions in intrinsic SHA1
define <4 x i32> @test_sha1c_in_a_row(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk) {
; CHECK-LABEL: test_sha1c_in_a_row:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov s2, w0
; CHECK-NEXT:    mov.16b v3, v0
; CHECK-NEXT:    sha1c.4s q3, s2, v1
; CHECK-NEXT:    sha1c.4s q0, s3, v1
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha1c(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk)
  %extract = extractelement <4 x i32> %res, i32 0
  %res2 = call <4 x i32> @llvm.aarch64.crypto.sha1c(<4 x i32> %hash_abcd, i32 %extract, <4 x i32> %wk)
  ret <4 x i32> %res2
}

define <4 x i32> @test_sha1p(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk) {
; CHECK-LABEL: test_sha1p:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov s2, w0
; CHECK-NEXT:    sha1p.4s q0, s2, v1
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha1p(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk)
  ret <4 x i32> %res
}

define <4 x i32> @test_sha1m(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk) {
; CHECK-LABEL: test_sha1m:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov s2, w0
; CHECK-NEXT:    sha1m.4s q0, s2, v1
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha1m(<4 x i32> %hash_abcd, i32 %hash_e, <4 x i32> %wk)
  ret <4 x i32> %res
}

define i32 @test_sha1h(i32 %hash_e) {
; CHECK-LABEL: test_sha1h:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov s0, w0
; CHECK-NEXT:    sha1h s0, s0
; CHECK-NEXT:    fmov w0, s0
; CHECK-NEXT:    ret
  %res = call i32 @llvm.aarch64.crypto.sha1h(i32 %hash_e)
  ret i32 %res
}

define <4 x i32> @test_sha1su0(<4 x i32> %wk0_3, <4 x i32> %wk4_7, <4 x i32> %wk8_11) {
; CHECK-LABEL: test_sha1su0:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sha1su0.4s v0, v1, v2
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha1su0(<4 x i32> %wk0_3, <4 x i32> %wk4_7, <4 x i32> %wk8_11)
  ret <4 x i32> %res
}

define <4 x i32> @test_sha1su1(<4 x i32> %wk0_3, <4 x i32> %wk12_15) {
; CHECK-LABEL: test_sha1su1:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sha1su1.4s v0, v1
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha1su1(<4 x i32> %wk0_3, <4 x i32> %wk12_15)
  ret <4 x i32> %res
}

declare <4 x i32> @llvm.aarch64.crypto.sha256h(<4 x i32> %hash_abcd, <4 x i32> %hash_efgh, <4 x i32> %wk)
declare <4 x i32> @llvm.aarch64.crypto.sha256h2(<4 x i32> %hash_efgh, <4 x i32> %hash_abcd, <4 x i32> %wk)
declare <4 x i32> @llvm.aarch64.crypto.sha256su0(<4 x i32> %w0_3, <4 x i32> %w4_7)
declare <4 x i32> @llvm.aarch64.crypto.sha256su1(<4 x i32> %w0_3, <4 x i32> %w8_11, <4 x i32> %w12_15)

define <4 x i32> @test_sha256h(<4 x i32> %hash_abcd, <4 x i32> %hash_efgh, <4 x i32> %wk) {
; CHECK-LABEL: test_sha256h:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sha256h.4s q0, q1, v2
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha256h(<4 x i32> %hash_abcd, <4 x i32> %hash_efgh, <4 x i32> %wk)
  ret <4 x i32> %res
}

define <4 x i32> @test_sha256h2(<4 x i32> %hash_efgh, <4 x i32> %hash_abcd, <4 x i32> %wk) {
; CHECK-LABEL: test_sha256h2:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sha256h2.4s q0, q1, v2
; CHECK-NEXT:    ret

  %res = call <4 x i32> @llvm.aarch64.crypto.sha256h2(<4 x i32> %hash_efgh, <4 x i32> %hash_abcd, <4 x i32> %wk)
  ret <4 x i32> %res
}

define <4 x i32> @test_sha256su0(<4 x i32> %w0_3, <4 x i32> %w4_7) {
; CHECK-LABEL: test_sha256su0:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sha256su0.4s v0, v1
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha256su0(<4 x i32> %w0_3, <4 x i32> %w4_7)
  ret <4 x i32> %res
}

define <4 x i32> @test_sha256su1(<4 x i32> %w0_3, <4 x i32> %w8_11, <4 x i32> %w12_15) {
; CHECK-LABEL: test_sha256su1:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sha256su1.4s v0, v1, v2
; CHECK-NEXT:    ret
  %res = call <4 x i32> @llvm.aarch64.crypto.sha256su1(<4 x i32> %w0_3, <4 x i32> %w8_11, <4 x i32> %w12_15)
  ret <4 x i32> %res
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK-GI: {{.*}}
; CHECK-SD: {{.*}}
