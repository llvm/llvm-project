; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -mtriple=aarch64 -mattr=+sve < %s | FileCheck %s

; Test that we do not end in an infinite loop (https://github.com/llvm/llvm-project/issues/63322)

declare void @llvm.masked.scatter.nxv16i8.nxv16p0(<vscale x 16 x i8>, <vscale x 16 x ptr>, i32 immarg, <vscale x 16 x i1>)

define fastcc i8 @allocno_reload_assign(ptr %p) {
; CHECK-LABEL: allocno_reload_assign:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov d0, xzr
; CHECK-NEXT:    ptrue p0.d
; CHECK-NEXT:    mov z16.d, #0 // =0x0
; CHECK-NEXT:    cmpeq p0.d, p0/z, z0.d, #0
; CHECK-NEXT:    uzp1 p0.s, p0.s, p0.s
; CHECK-NEXT:    uzp1 p0.h, p0.h, p0.h
; CHECK-NEXT:    uzp1 p8.b, p0.b, p0.b
; CHECK-NEXT:    mov z0.b, p8/z, #1 // =0x1
; CHECK-NEXT:    fmov w8, s0
; CHECK-NEXT:    mov z0.b, #0 // =0x0
; CHECK-NEXT:    uunpklo z1.h, z0.b
; CHECK-NEXT:    uunpkhi z0.h, z0.b
; CHECK-NEXT:    mvn w8, w8
; CHECK-NEXT:    sbfx x8, x8, #0, #1
; CHECK-NEXT:    whilelo p0.b, xzr, x8
; CHECK-NEXT:    uunpklo z2.s, z1.h
; CHECK-NEXT:    uunpkhi z3.s, z1.h
; CHECK-NEXT:    uunpklo z5.s, z0.h
; CHECK-NEXT:    uunpkhi z7.s, z0.h
; CHECK-NEXT:    punpklo p1.h, p0.b
; CHECK-NEXT:    punpkhi p0.h, p0.b
; CHECK-NEXT:    punpklo p2.h, p1.b
; CHECK-NEXT:    punpkhi p4.h, p1.b
; CHECK-NEXT:    uunpklo z0.d, z2.s
; CHECK-NEXT:    uunpkhi z1.d, z2.s
; CHECK-NEXT:    punpklo p6.h, p0.b
; CHECK-NEXT:    uunpklo z2.d, z3.s
; CHECK-NEXT:    uunpkhi z3.d, z3.s
; CHECK-NEXT:    punpkhi p0.h, p0.b
; CHECK-NEXT:    uunpklo z4.d, z5.s
; CHECK-NEXT:    uunpkhi z5.d, z5.s
; CHECK-NEXT:    uunpklo z6.d, z7.s
; CHECK-NEXT:    uunpkhi z7.d, z7.s
; CHECK-NEXT:    punpklo p1.h, p2.b
; CHECK-NEXT:    punpkhi p2.h, p2.b
; CHECK-NEXT:    punpklo p3.h, p4.b
; CHECK-NEXT:    punpkhi p4.h, p4.b
; CHECK-NEXT:    punpklo p5.h, p6.b
; CHECK-NEXT:    punpkhi p6.h, p6.b
; CHECK-NEXT:    punpklo p7.h, p0.b
; CHECK-NEXT:    punpkhi p0.h, p0.b
; CHECK-NEXT:  .LBB0_1: // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    st1b { z0.d }, p1, [z16.d]
; CHECK-NEXT:    st1b { z1.d }, p2, [z16.d]
; CHECK-NEXT:    st1b { z2.d }, p3, [z16.d]
; CHECK-NEXT:    st1b { z3.d }, p4, [z16.d]
; CHECK-NEXT:    st1b { z4.d }, p5, [z16.d]
; CHECK-NEXT:    st1b { z5.d }, p6, [z16.d]
; CHECK-NEXT:    st1b { z6.d }, p7, [z16.d]
; CHECK-NEXT:    st1b { z7.d }, p0, [z16.d]
; CHECK-NEXT:    str p8, [x0]
; CHECK-NEXT:    b .LBB0_1
  br label %1

1:                                                ; preds = %1, %0
  %constexpr = icmp eq <vscale x 16 x ptr> insertelement (<vscale x 16 x ptr> poison, ptr null, i64 0), zeroinitializer
  %constexpr1 = shufflevector <vscale x 16 x i1> %constexpr, <vscale x 16 x i1> poison, <vscale x 16 x i32> zeroinitializer
  %constexpr2 = xor <vscale x 16 x i1> %constexpr1, shufflevector (<vscale x 16 x i1> insertelement (<vscale x 16 x i1> poison, i1 true, i64 0), <vscale x 16 x i1> poison, <vscale x 16 x i32> zeroinitializer)
  call void @llvm.masked.scatter.nxv16i8.nxv16p0(<vscale x 16 x i8> zeroinitializer, <vscale x 16 x ptr> zeroinitializer, i32 0, <vscale x 16 x i1> %constexpr2)
  store <vscale x 16 x i1> %constexpr, ptr %p, align 16
  br label %1
}

uselistorder <vscale x 16 x i1> poison, { 1, 2, 0 }
