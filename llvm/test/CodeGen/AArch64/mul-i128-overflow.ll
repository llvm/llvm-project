; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64 -o - %s | FileCheck %s


declare i32 @error()

define i128 @test1(i128 noundef %x, i128 noundef %y) {
; CHECK-LABEL: test1:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    eor x8, x3, x2, asr #63
; CHECK-NEXT:    eor x9, x1, x0, asr #63
; CHECK-NEXT:    orr x8, x9, x8
; CHECK-NEXT:    cbz x8, .LBB0_4
; CHECK-NEXT:  // %bb.1: // %overflow
; CHECK-NEXT:    asr x9, x1, #63
; CHECK-NEXT:    umulh x10, x0, x2
; CHECK-NEXT:    asr x13, x3, #63
; CHECK-NEXT:    mul x11, x1, x2
; CHECK-NEXT:    umulh x8, x1, x2
; CHECK-NEXT:    mul x9, x9, x2
; CHECK-NEXT:    adds x10, x11, x10
; CHECK-NEXT:    mul x14, x0, x3
; CHECK-NEXT:    umulh x12, x0, x3
; CHECK-NEXT:    adc x8, x8, x9
; CHECK-NEXT:    mov x9, x1
; CHECK-NEXT:    mul x13, x0, x13
; CHECK-NEXT:    asr x11, x8, #63
; CHECK-NEXT:    mul x15, x1, x3
; CHECK-NEXT:    adds x1, x14, x10
; CHECK-NEXT:    smulh x9, x9, x3
; CHECK-NEXT:    adc x10, x12, x13
; CHECK-NEXT:    asr x12, x10, #63
; CHECK-NEXT:    adds x8, x8, x10
; CHECK-NEXT:    asr x10, x1, #63
; CHECK-NEXT:    mul x0, x0, x2
; CHECK-NEXT:    adc x11, x11, x12
; CHECK-NEXT:    adds x8, x15, x8
; CHECK-NEXT:    adc x9, x9, x11
; CHECK-NEXT:    cmp x8, x10
; CHECK-NEXT:    ccmp x9, x10, #0, eq
; CHECK-NEXT:    cset w8, ne
; CHECK-NEXT:    cbz w8, .LBB0_3
; CHECK-NEXT:  .LBB0_2: // %if.then
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    bl error
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    sxtw x0, w0
; CHECK-NEXT:    asr x1, x0, #63
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:  .LBB0_3: // %cleanup
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_4: // %overflow.no
; CHECK-NEXT:    smulh x1, x0, x2
; CHECK-NEXT:    mul x0, x0, x2
; CHECK-NEXT:    cbnz w8, .LBB0_2
; CHECK-NEXT:    b .LBB0_3
entry:
  %0 = tail call { i128, i1 } @llvm.smul.with.overflow.i128(i128 %x, i128 %y)
  %1 = extractvalue { i128, i1 } %0, 1
  br i1 %1, label %if.then, label %if.end

if.then:
  %call = tail call i32 @error()
  %conv1 = sext i32 %call to i128
  br label %cleanup

if.end:
  %2 = extractvalue { i128, i1 } %0, 0
  br label %cleanup

cleanup:
  %retval.0 = phi i128 [ %conv1, %if.then ], [ %2, %if.end ]
  ret i128 %retval.0
}

define i128 @test2(i128 noundef %x, i128 noundef %y, ptr %out) {
; CHECK-LABEL: test2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    eor x8, x3, x2, asr #63
; CHECK-NEXT:    eor x9, x1, x0, asr #63
; CHECK-NEXT:    orr x8, x9, x8
; CHECK-NEXT:    cbz x8, .LBB1_4
; CHECK-NEXT:  // %bb.1: // %overflow
; CHECK-NEXT:    asr x9, x1, #63
; CHECK-NEXT:    umulh x10, x0, x2
; CHECK-NEXT:    asr x13, x3, #63
; CHECK-NEXT:    mul x11, x1, x2
; CHECK-NEXT:    umulh x8, x1, x2
; CHECK-NEXT:    mul x9, x9, x2
; CHECK-NEXT:    adds x10, x11, x10
; CHECK-NEXT:    mul x14, x0, x3
; CHECK-NEXT:    umulh x12, x0, x3
; CHECK-NEXT:    adc x8, x8, x9
; CHECK-NEXT:    mov x9, x1
; CHECK-NEXT:    mul x13, x0, x13
; CHECK-NEXT:    asr x11, x8, #63
; CHECK-NEXT:    mul x15, x1, x3
; CHECK-NEXT:    adds x1, x14, x10
; CHECK-NEXT:    smulh x9, x9, x3
; CHECK-NEXT:    adc x10, x12, x13
; CHECK-NEXT:    asr x12, x10, #63
; CHECK-NEXT:    adds x8, x8, x10
; CHECK-NEXT:    asr x10, x1, #63
; CHECK-NEXT:    mul x0, x0, x2
; CHECK-NEXT:    adc x11, x11, x12
; CHECK-NEXT:    adds x8, x15, x8
; CHECK-NEXT:    adc x9, x9, x11
; CHECK-NEXT:    cmp x8, x10
; CHECK-NEXT:    ccmp x9, x10, #0, eq
; CHECK-NEXT:    cset w8, ne
; CHECK-NEXT:    stp x0, x1, [x4]
; CHECK-NEXT:    cbz w8, .LBB1_3
; CHECK-NEXT:  .LBB1_2: // %if.then
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    bl error
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    sxtw x0, w0
; CHECK-NEXT:    asr x1, x0, #63
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:  .LBB1_3: // %cleanup
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB1_4: // %overflow.no
; CHECK-NEXT:    smulh x1, x0, x2
; CHECK-NEXT:    mul x0, x0, x2
; CHECK-NEXT:    stp x0, x1, [x4]
; CHECK-NEXT:    cbnz w8, .LBB1_2
; CHECK-NEXT:    b .LBB1_3
entry:
  %0 = tail call { i128, i1 } @llvm.smul.with.overflow.i128(i128 %x, i128 %y)
  %1 = extractvalue { i128, i1 } %0, 0
  store i128 %1, ptr %out
  %2 = extractvalue { i128, i1 } %0, 1
  br i1 %2, label %if.then, label %cleanup

if.then:
  %call = tail call i32 @error()
  %conv1 = sext i32 %call to i128
  br label %cleanup

cleanup:
  %retval.0 = phi i128 [ %conv1, %if.then ], [ %1, %entry ]
  ret i128 %retval.0
}

define i128 @test3(i128 noundef %x, i128 noundef %y, ptr %out) {
; CHECK-LABEL: test3:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    orr x8, x1, x3
; CHECK-NEXT:    cbz x8, .LBB2_3
; CHECK-NEXT:  // %bb.1: // %overflow
; CHECK-NEXT:    mul x8, x3, x0
; CHECK-NEXT:    cmp x1, #0
; CHECK-NEXT:    ccmp x3, #0, #4, ne
; CHECK-NEXT:    umulh x10, x1, x2
; CHECK-NEXT:    umulh x9, x3, x0
; CHECK-NEXT:    madd x11, x1, x2, x8
; CHECK-NEXT:    ccmp xzr, x10, #0, eq
; CHECK-NEXT:    umulh x12, x0, x2
; CHECK-NEXT:    ccmp xzr, x9, #0, eq
; CHECK-NEXT:    mul x8, x0, x2
; CHECK-NEXT:    cset w10, ne
; CHECK-NEXT:    adds x9, x12, x11
; CHECK-NEXT:    csinc w10, w10, wzr, lo
; CHECK-NEXT:    stp x8, x9, [x4]
; CHECK-NEXT:    cbnz w10, .LBB2_4
; CHECK-NEXT:  .LBB2_2:
; CHECK-NEXT:    mov x1, xzr
; CHECK-NEXT:    mov w0, #1 // =0x1
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB2_3: // %overflow.no
; CHECK-NEXT:    umulh x9, x0, x2
; CHECK-NEXT:    mov w10, wzr
; CHECK-NEXT:    mul x8, x0, x2
; CHECK-NEXT:    stp x8, x9, [x4]
; CHECK-NEXT:    cbz w10, .LBB2_2
; CHECK-NEXT:  .LBB2_4: // %if.then
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    bl error
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    sxtw x0, w0
; CHECK-NEXT:    asr x1, x0, #63
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
entry:
  %0 = tail call { i128, i1 } @llvm.umul.with.overflow.i128(i128 %x, i128 %y)
  %1 = extractvalue { i128, i1 } %0, 0
  store i128 %1, ptr %out
  %2 = extractvalue { i128, i1 } %0, 1
  br i1 %2, label %if.then, label %cleanup

if.then:
  %call = tail call i32 @error()
  %conv1 = sext i32 %call to i128
  br label %cleanup

cleanup:
  %retval.0 = phi i128 [ %conv1, %if.then ], [ 1, %entry ]
  ret i128 %retval.0
}

define i128 @test4(i128 noundef %x, i128 noundef %y, i128 %out) {
; CHECK-LABEL: test4:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    orr x8, x1, x3
; CHECK-NEXT:    cbz x8, .LBB3_2
; CHECK-NEXT:  // %bb.1: // %overflow
; CHECK-NEXT:    mul x8, x3, x0
; CHECK-NEXT:    cmp x1, #0
; CHECK-NEXT:    ccmp x3, #0, #4, ne
; CHECK-NEXT:    umulh x10, x1, x2
; CHECK-NEXT:    umulh x9, x3, x0
; CHECK-NEXT:    madd x11, x1, x2, x8
; CHECK-NEXT:    ccmp xzr, x10, #0, eq
; CHECK-NEXT:    umulh x12, x0, x2
; CHECK-NEXT:    ccmp xzr, x9, #0, eq
; CHECK-NEXT:    mul x8, x0, x2
; CHECK-NEXT:    cset w10, ne
; CHECK-NEXT:    adds x9, x12, x11
; CHECK-NEXT:    csinc w10, w10, wzr, lo
; CHECK-NEXT:    b .LBB3_3
; CHECK-NEXT:  .LBB3_2: // %overflow.no
; CHECK-NEXT:    umulh x9, x0, x2
; CHECK-NEXT:    mov w10, wzr
; CHECK-NEXT:    mul x8, x0, x2
; CHECK-NEXT:  .LBB3_3: // %overflow.res
; CHECK-NEXT:    adds x0, x8, x4
; CHECK-NEXT:    adc x1, x9, x5
; CHECK-NEXT:    cbz w10, .LBB3_5
; CHECK-NEXT:  // %bb.4: // %if.then
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    bl error
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    sxtw x0, w0
; CHECK-NEXT:    asr x1, x0, #63
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:  .LBB3_5: // %cleanup
; CHECK-NEXT:    ret
entry:
  %0 = tail call { i128, i1 } @llvm.umul.with.overflow.i128(i128 %x, i128 %y)
  %1 = extractvalue { i128, i1 } %0, 0
  %res = add i128 %1, %out
  %2 = extractvalue { i128, i1 } %0, 1
  br i1 %2, label %if.then, label %cleanup

if.then:
  %call = tail call i32 @error()
  %conv1 = sext i32 %call to i128
  br label %cleanup

cleanup:
  %retval.0 = phi i128 [ %conv1, %if.then ], [ %res, %entry ]
  ret i128 %retval.0
}
