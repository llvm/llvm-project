; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -O0 -fast-isel -fast-isel-abort=1 -verify-machineinstrs -mtriple=arm64-apple-darwin < %s | FileCheck %s

define void @t0(i32 %a) nounwind {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr
  %tmp = load i32, ptr %a.addr
  store i32 %tmp, ptr %a.addr
  ret void
}

define void @t1(i64 %a) nounwind {
  %a.addr = alloca i64, align 4
  store i64 %a, ptr %a.addr
  %tmp = load i64, ptr %a.addr
  store i64 %tmp, ptr %a.addr
  ret void
}

define zeroext i1 @i1(i1 %a) nounwind {
entry:
  %a.addr = alloca i1, align 1
  store i1 %a, ptr %a.addr, align 1
  %0 = load i1, ptr %a.addr, align 1
  ret i1 %0
}

define i32 @t2(ptr %ptr) nounwind {
entry:
  %0 = getelementptr i32, ptr %ptr, i32 -1
  %1 = load i32, ptr %0, align 4
  ret i32 %1
}

define i32 @t3(ptr %ptr) nounwind {
entry:
  %0 = getelementptr i32, ptr %ptr, i32 -64
  %1 = load i32, ptr %0, align 4
  ret i32 %1
}

define void @t4(ptr %ptr) nounwind {
entry:
  %0 = getelementptr i32, ptr %ptr, i32 -1
  store i32 0, ptr %0, align 4
  ret void
}

define void @t5(ptr %ptr) nounwind {
entry:
  %0 = getelementptr i32, ptr %ptr, i32 -64
  store i32 0, ptr %0, align 4
  ret void
}

define void @t6() nounwind {
  tail call void @llvm.trap()
  ret void
}

declare void @llvm.trap() nounwind

define void @ands(ptr %addr) {
; FIXME: 'select i1 undef' makes this unreliable (ub?).
; COM: CHECK-LABEL: ands:
; COM: CHECK: tst [[COND:w[0-9]+]], #0x1
; COM: CHECK-NEXT: mov w{{[0-9]+}}, #2
; COM: CHECK-NEXT: mov w{{[0-9]+}}, #1
; COM: CHECK-NEXT: csel [[COND]],
entry:
  %cond91 = select i1 undef, i32 1, i32 2
  store i32 %cond91, ptr %addr, align 4
  ret void
}

define i64 @mul_umul(i64 %arg) {
entry:
  %sub.ptr.div = sdiv exact i64 %arg, 8
  %tmp = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %sub.ptr.div, i64 8)
  %tmp1 = extractvalue { i64, i1 } %tmp, 0
  ret i64 %tmp1
}

declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64)

define void @logicalReg(i1 %arg) {
; Make sure we generate a logical reg = reg, reg instruction without any
; machine verifier errors.
entry:
  br i1 %arg, label %cond.end, label %cond.false

cond.false:
  %cond = select i1 undef, i1 true, i1 false
  br label %cond.end

cond.end:
  %cond13 = phi i1 [ %cond, %cond.false ], [ true, %entry ]
  ret void
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
