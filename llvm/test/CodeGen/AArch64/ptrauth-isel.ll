; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple arm64e-apple-darwin             -verify-machineinstrs -stop-after=finalize-isel -global-isel=0 \
; RUN:     | FileCheck %s --check-prefixes=DAGISEL,DAGISEL-DARWIN
; RUN: llc < %s -mtriple arm64e-apple-darwin             -verify-machineinstrs -stop-after=finalize-isel -global-isel=1 -global-isel-abort=1 \
; RUN:     | FileCheck %s --check-prefixes=GISEL,GISEL-DARWIN
; RUN: llc < %s -mtriple aarch64-linux-gnu -mattr=+pauth -verify-machineinstrs -stop-after=finalize-isel -global-isel=0 \
; RUN:     | FileCheck %s --check-prefixes=DAGISEL,DAGISEL-ELF
; RUN: llc < %s -mtriple aarch64-linux-gnu -mattr=+pauth -verify-machineinstrs -stop-after=finalize-isel -global-isel=1 -global-isel-abort=1 \
; RUN:     | FileCheck %s --check-prefixes=GISEL,GISEL-ELF

; Check MIR produced by the instruction selector to validate properties that
; cannot be reliably tested by only inspecting the final asm output.

@discvar = dso_local global i64 0

; Make sure the components of blend(addr, imm) and integer constants are
; recognized and passed to AUT / PAC / AUTPAC pseudo via separate operands
; prevent substitution of the immediate modifier.
;
; MIR output of the instruction selector is inspected, as it is hard to reliably
; distinguish MOVKXi immediately followed by a pseudo from a standalone pseudo
; instruction carrying address and immediate modifiers in its separate operands
; by only observing the final asm output.

define i64 @small_imm_disc_optimized(i64 %addr) {
  ; DAGISEL-LABEL: name: small_imm_disc_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 42
  ; DAGISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, killed [[MOVi32imm]], %subreg.sub_32
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, killed $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: small_imm_disc_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 42
  ; GISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, [[MOVi32imm]], %subreg.sub_32
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 42)
  ret i64 %signed
}

; Without optimization, MOVi64imm may be used for small i64 constants as well.
define i64 @small_imm_disc_non_optimized(i64 %addr) noinline optnone {
  ; DAGISEL-LABEL: name: small_imm_disc_non_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY killed [[COPY]]
  ; DAGISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 42
  ; DAGISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, killed [[MOVi32imm]], %subreg.sub_32
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY1]], 2, 42, killed $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64all = COPY [[PAC]]
  ; DAGISEL-NEXT:   $x0 = COPY [[COPY2]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: small_imm_disc_non_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi64imm:%[0-9]+]]:gpr64noip = MOVi64imm 42
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 42)
  ret i64 %signed
}

define i64 @large_imm_disc_wreg(i64 %addr) {
  ; DAGISEL-LABEL: name: large_imm_disc_wreg
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 12345678
  ; DAGISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, killed [[MOVi32imm]], %subreg.sub_32
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, killed [[SUBREG_TO_REG]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: large_imm_disc_wreg
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 12345678
  ; GISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, [[MOVi32imm]], %subreg.sub_32
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, [[SUBREG_TO_REG]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 12345678)
  ret i64 %signed
}

define i64 @large_imm_disc_xreg(i64 %addr) {
  ; DAGISEL-LABEL: name: large_imm_disc_xreg
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[MOVi64imm:%[0-9]+]]:gpr64noip = MOVi64imm 123456789012345
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, killed [[MOVi64imm]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: large_imm_disc_xreg
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi64imm:%[0-9]+]]:gpr64noip = MOVi64imm 123456789012345
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, [[MOVi64imm]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 123456789012345)
  ret i64 %signed
}

; Make sure blend() is lowered as expected when optimization is disabled.
define i64 @blended_disc_non_optimized(i64 %addr, i64 %addrdisc) noinline optnone {
  ; DAGISEL-LABEL: name: blended_disc_non_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0, $x1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64 = COPY killed [[COPY1]]
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64 = COPY killed [[COPY]]
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[COPY3]], 42, 48
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   [[COPY5:%[0-9]+]]:gpr64noip = COPY [[COPY3]]
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY2]], 2, 42, [[COPY5]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   [[COPY6:%[0-9]+]]:gpr64all = COPY [[PAC]]
  ; DAGISEL-NEXT:   $x0 = COPY [[COPY6]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blended_disc_non_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0, $x1
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[COPY1]], 42, 48
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[COPY1]]
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, [[COPY2]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 %disc)
  ret i64 %signed
}

define i64 @blend_and_auth_same_bb(i64 %addr) {
  ; DAGISEL-DARWIN-LABEL: name: blend_and_auth_same_bb
  ; DAGISEL-DARWIN: bb.0.entry:
  ; DAGISEL-DARWIN-NEXT:   liveins: $x0
  ; DAGISEL-DARWIN-NEXT: {{  $}}
  ; DAGISEL-DARWIN-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-DARWIN-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-DARWIN-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-DARWIN-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-DARWIN-NEXT:   $x16 = COPY [[COPY]]
  ; DAGISEL-DARWIN-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-DARWIN-NEXT:   AUTx16x17 2, 42, killed [[COPY1]], implicit-def $x16, implicit-def dead $x17, implicit-def dead $nzcv, implicit $x16
  ; DAGISEL-DARWIN-NEXT:   [[COPY2:%[0-9]+]]:gpr64all = COPY $x16
  ; DAGISEL-DARWIN-NEXT:   $x0 = COPY [[COPY2]]
  ; DAGISEL-DARWIN-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-DARWIN-LABEL: name: blend_and_auth_same_bb
  ; GISEL-DARWIN: bb.1.entry:
  ; GISEL-DARWIN-NEXT:   liveins: $x0
  ; GISEL-DARWIN-NEXT: {{  $}}
  ; GISEL-DARWIN-NEXT:   [[COPY:%[0-9]+]]:gpr64all = COPY $x0
  ; GISEL-DARWIN-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-DARWIN-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-DARWIN-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-DARWIN-NEXT:   $x16 = COPY [[COPY]]
  ; GISEL-DARWIN-NEXT:   $x17 = IMPLICIT_DEF
  ; GISEL-DARWIN-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-DARWIN-NEXT:   AUTx16x17 2, 42, [[COPY1]], implicit-def $x16, implicit-def $x17, implicit-def dead $nzcv, implicit $x16
  ; GISEL-DARWIN-NEXT:   [[COPY2:%[0-9]+]]:gpr64 = COPY $x16
  ; GISEL-DARWIN-NEXT:   $x0 = COPY [[COPY2]]
  ; GISEL-DARWIN-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; DAGISEL-ELF-LABEL: name: blend_and_auth_same_bb
  ; DAGISEL-ELF: bb.0.entry:
  ; DAGISEL-ELF-NEXT:   liveins: $x0
  ; DAGISEL-ELF-NEXT: {{  $}}
  ; DAGISEL-ELF-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-ELF-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-ELF-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-ELF-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-ELF-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-ELF-NEXT:   [[AUTxMxN:%[0-9]+]]:gpr64, [[AUTxMxN1:%[0-9]+]]:gpr64common = AUTxMxN [[COPY]], 2, 42, killed [[COPY1]], implicit-def dead $nzcv
  ; DAGISEL-ELF-NEXT:   $x0 = COPY [[AUTxMxN]]
  ; DAGISEL-ELF-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-ELF-LABEL: name: blend_and_auth_same_bb
  ; GISEL-ELF: bb.1.entry:
  ; GISEL-ELF-NEXT:   liveins: $x0
  ; GISEL-ELF-NEXT: {{  $}}
  ; GISEL-ELF-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-ELF-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-ELF-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-ELF-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-ELF-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-ELF-NEXT:   [[AUTxMxN:%[0-9]+]]:gpr64, [[AUTxMxN1:%[0-9]+]]:gpr64common = AUTxMxN [[COPY]], 2, 42, [[COPY1]], implicit-def dead $nzcv
  ; GISEL-ELF-NEXT:   $x0 = COPY [[AUTxMxN]]
  ; GISEL-ELF-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %authed = call i64 @llvm.ptrauth.auth(i64 %addr, i32 2, i64 %disc)
  ret i64 %authed
}

define i64 @blend_and_sign_same_bb(i64 %addr) {
  ; DAGISEL-LABEL: name: blend_and_sign_same_bb
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, killed [[COPY1]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blend_and_sign_same_bb
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, [[COPY1]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 %disc)
  ret i64 %signed
}

define i64 @blend_and_resign_same_bb(i64 %addr) {
  ; DAGISEL-LABEL: name: blend_and_resign_same_bb
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[MOVKXi1:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 123, 48
  ; DAGISEL-NEXT:   $x16 = COPY [[COPY]]
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   AUTPAC 2, 42, killed [[COPY1]], 3, 123, killed [[COPY2]], implicit-def $x16, implicit-def dead $x17, implicit-def dead $nzcv, implicit $x16
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64all = COPY $x16
  ; DAGISEL-NEXT:   $x0 = COPY [[COPY3]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blend_and_resign_same_bb
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64all = COPY $x0
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   [[MOVKXi1:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 123, 48
  ; GISEL-NEXT:   $x16 = COPY [[COPY]]
  ; GISEL-NEXT:   $x17 = IMPLICIT_DEF
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   AUTPAC 2, 42, [[COPY1]], 3, 123, [[COPY2]], implicit-def $x16, implicit-def $x17, implicit-def dead $nzcv, implicit $x16
  ; GISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64 = COPY $x16
  ; GISEL-NEXT:   $x0 = COPY [[COPY3]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %auth.disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %sign.disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 123)
  %resigned = call i64 @llvm.ptrauth.resign(i64 %addr, i32 2, i64 %auth.disc, i32 3, i64 %sign.disc)
  ret i64 %resigned
}

; In the below test cases both %addrdisc and %disc are computed (i.e. they are
; neither global addresses, nor function arguments) in a different basic block,
; making them harder to express via ISD::PtrAuthGlobalAddress.

define i64 @blend_and_auth_different_bbs(i64 %addr, i64 %cond) {
  ; DAGISEL-DARWIN-LABEL: name: blend_and_auth_different_bbs
  ; DAGISEL-DARWIN: bb.0.entry:
  ; DAGISEL-DARWIN-NEXT:   successors: %bb.1(0x50000000), %bb.2(0x30000000)
  ; DAGISEL-DARWIN-NEXT:   liveins: $x0, $x1
  ; DAGISEL-DARWIN-NEXT: {{  $}}
  ; DAGISEL-DARWIN-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; DAGISEL-DARWIN-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-DARWIN-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-DARWIN-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-DARWIN-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-DARWIN-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[MOVKXi]]
  ; DAGISEL-DARWIN-NEXT:   CBZX [[COPY]], %bb.2
  ; DAGISEL-DARWIN-NEXT:   B %bb.1
  ; DAGISEL-DARWIN-NEXT: {{  $}}
  ; DAGISEL-DARWIN-NEXT: bb.1.next:
  ; DAGISEL-DARWIN-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-DARWIN-NEXT: {{  $}}
  ; DAGISEL-DARWIN-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-DARWIN-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; DAGISEL-DARWIN-NEXT: {{  $}}
  ; DAGISEL-DARWIN-NEXT: bb.2.exit:
  ; DAGISEL-DARWIN-NEXT:   $x16 = COPY [[COPY1]]
  ; DAGISEL-DARWIN-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-DARWIN-NEXT:   AUTx16x17 2, 42, [[COPY4]], implicit-def $x16, implicit-def dead $x17, implicit-def dead $nzcv, implicit $x16
  ; DAGISEL-DARWIN-NEXT:   [[COPY5:%[0-9]+]]:gpr64all = COPY $x16
  ; DAGISEL-DARWIN-NEXT:   $x0 = COPY [[COPY5]]
  ; DAGISEL-DARWIN-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-DARWIN-LABEL: name: blend_and_auth_different_bbs
  ; GISEL-DARWIN: bb.1.entry:
  ; GISEL-DARWIN-NEXT:   successors: %bb.2(0x50000000), %bb.3(0x30000000)
  ; GISEL-DARWIN-NEXT:   liveins: $x0, $x1
  ; GISEL-DARWIN-NEXT: {{  $}}
  ; GISEL-DARWIN-NEXT:   [[COPY:%[0-9]+]]:gpr64all = COPY $x0
  ; GISEL-DARWIN-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
  ; GISEL-DARWIN-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-DARWIN-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-DARWIN-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-DARWIN-NEXT:   CBZX [[COPY1]], %bb.3
  ; GISEL-DARWIN-NEXT:   B %bb.2
  ; GISEL-DARWIN-NEXT: {{  $}}
  ; GISEL-DARWIN-NEXT: bb.2.next:
  ; GISEL-DARWIN-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-DARWIN-NEXT: {{  $}}
  ; GISEL-DARWIN-NEXT:   [[COPY2:%[0-9]+]]:gpr64common = COPY [[MOVKXi]]
  ; GISEL-DARWIN-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY2]]
  ; GISEL-DARWIN-NEXT: {{  $}}
  ; GISEL-DARWIN-NEXT: bb.3.exit:
  ; GISEL-DARWIN-NEXT:   $x16 = COPY [[COPY]]
  ; GISEL-DARWIN-NEXT:   $x17 = IMPLICIT_DEF
  ; GISEL-DARWIN-NEXT:   [[COPY3:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-DARWIN-NEXT:   AUTx16x17 2, 42, [[COPY3]], implicit-def $x16, implicit-def $x17, implicit-def dead $nzcv, implicit $x16
  ; GISEL-DARWIN-NEXT:   [[COPY4:%[0-9]+]]:gpr64 = COPY $x16
  ; GISEL-DARWIN-NEXT:   $x0 = COPY [[COPY4]]
  ; GISEL-DARWIN-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; DAGISEL-ELF-LABEL: name: blend_and_auth_different_bbs
  ; DAGISEL-ELF: bb.0.entry:
  ; DAGISEL-ELF-NEXT:   successors: %bb.1(0x50000000), %bb.2(0x30000000)
  ; DAGISEL-ELF-NEXT:   liveins: $x0, $x1
  ; DAGISEL-ELF-NEXT: {{  $}}
  ; DAGISEL-ELF-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; DAGISEL-ELF-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-ELF-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-ELF-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-ELF-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-ELF-NEXT:   [[COPY2:%[0-9]+]]:gpr64 = COPY [[MOVKXi]]
  ; DAGISEL-ELF-NEXT:   CBZX [[COPY]], %bb.2
  ; DAGISEL-ELF-NEXT:   B %bb.1
  ; DAGISEL-ELF-NEXT: {{  $}}
  ; DAGISEL-ELF-NEXT: bb.1.next:
  ; DAGISEL-ELF-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-ELF-NEXT: {{  $}}
  ; DAGISEL-ELF-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-ELF-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; DAGISEL-ELF-NEXT: {{  $}}
  ; DAGISEL-ELF-NEXT: bb.2.exit:
  ; DAGISEL-ELF-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-ELF-NEXT:   [[AUTxMxN:%[0-9]+]]:gpr64, [[AUTxMxN1:%[0-9]+]]:gpr64common = AUTxMxN [[COPY1]], 2, 42, [[COPY4]], implicit-def dead $nzcv
  ; DAGISEL-ELF-NEXT:   $x0 = COPY [[AUTxMxN]]
  ; DAGISEL-ELF-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-ELF-LABEL: name: blend_and_auth_different_bbs
  ; GISEL-ELF: bb.1.entry:
  ; GISEL-ELF-NEXT:   successors: %bb.2(0x50000000), %bb.3(0x30000000)
  ; GISEL-ELF-NEXT:   liveins: $x0, $x1
  ; GISEL-ELF-NEXT: {{  $}}
  ; GISEL-ELF-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-ELF-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
  ; GISEL-ELF-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-ELF-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-ELF-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-ELF-NEXT:   CBZX [[COPY1]], %bb.3
  ; GISEL-ELF-NEXT:   B %bb.2
  ; GISEL-ELF-NEXT: {{  $}}
  ; GISEL-ELF-NEXT: bb.2.next:
  ; GISEL-ELF-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-ELF-NEXT: {{  $}}
  ; GISEL-ELF-NEXT:   [[COPY2:%[0-9]+]]:gpr64common = COPY [[MOVKXi]]
  ; GISEL-ELF-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY2]]
  ; GISEL-ELF-NEXT: {{  $}}
  ; GISEL-ELF-NEXT: bb.3.exit:
  ; GISEL-ELF-NEXT:   [[COPY3:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-ELF-NEXT:   [[AUTxMxN:%[0-9]+]]:gpr64, [[AUTxMxN1:%[0-9]+]]:gpr64common = AUTxMxN [[COPY]], 2, 42, [[COPY3]], implicit-def dead $nzcv
  ; GISEL-ELF-NEXT:   $x0 = COPY [[AUTxMxN]]
  ; GISEL-ELF-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %cond.b = icmp ne i64 %cond, 0
  br i1 %cond.b, label %next, label %exit

next:
  call void asm sideeffect "nop", "r"(i64 %disc)
  br label %exit

exit:
  %authed = call i64 @llvm.ptrauth.auth(i64 %addr, i32 2, i64 %disc)
  ret i64 %authed
}

define i64 @blend_and_sign_different_bbs(i64 %addr, i64 %cond) {
  ; DAGISEL-LABEL: name: blend_and_sign_different_bbs
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   successors: %bb.1(0x50000000), %bb.2(0x30000000)
  ; DAGISEL-NEXT:   liveins: $x0, $x1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   CBZX [[COPY]], %bb.2
  ; DAGISEL-NEXT:   B %bb.1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.1.next:
  ; DAGISEL-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.2.exit:
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY1]], 2, 42, [[COPY4]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blend_and_sign_different_bbs
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   successors: %bb.2(0x50000000), %bb.3(0x30000000)
  ; GISEL-NEXT:   liveins: $x0, $x1
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   CBZX [[COPY1]], %bb.3
  ; GISEL-NEXT:   B %bb.2
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.2.next:
  ; GISEL-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64common = COPY [[MOVKXi]]
  ; GISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY2]]
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.3.exit:
  ; GISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, [[COPY3]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %cond.b = icmp ne i64 %cond, 0
  br i1 %cond.b, label %next, label %exit

next:
  call void asm sideeffect "nop", "r"(i64 %disc)
  br label %exit

exit:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 %disc)
  ret i64 %signed
}

define i64 @blend_and_resign_different_bbs(i64 %addr, i64 %cond) {
  ; DAGISEL-LABEL: name: blend_and_resign_different_bbs
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   successors: %bb.1(0x50000000), %bb.2(0x30000000)
  ; DAGISEL-NEXT:   liveins: $x0, $x1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   [[MOVKXi1:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 123, 48
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64noip = COPY [[MOVKXi1]]
  ; DAGISEL-NEXT:   CBZX [[COPY]], %bb.2
  ; DAGISEL-NEXT:   B %bb.1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.1.next:
  ; DAGISEL-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-NEXT:   [[COPY5:%[0-9]+]]:gpr64common = COPY [[COPY3]]
  ; DAGISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY4]], 3866633 /* reguse:GPR64common */, [[COPY5]]
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.2.exit:
  ; DAGISEL-NEXT:   $x16 = COPY [[COPY1]]
  ; DAGISEL-NEXT:   [[COPY6:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   [[COPY7:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   AUTPAC 2, 42, [[COPY6]], 3, 123, [[COPY7]], implicit-def $x16, implicit-def dead $x17, implicit-def dead $nzcv, implicit $x16
  ; DAGISEL-NEXT:   [[COPY8:%[0-9]+]]:gpr64all = COPY $x16
  ; DAGISEL-NEXT:   $x0 = COPY [[COPY8]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blend_and_resign_different_bbs
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   successors: %bb.2(0x50000000), %bb.3(0x30000000)
  ; GISEL-NEXT:   liveins: $x0, $x1
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64all = COPY $x0
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   [[MOVKXi1:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 123, 48
  ; GISEL-NEXT:   CBZX [[COPY1]], %bb.3
  ; GISEL-NEXT:   B %bb.2
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.2.next:
  ; GISEL-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64common = COPY [[MOVKXi]]
  ; GISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[MOVKXi1]]
  ; GISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY2]], 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.3.exit:
  ; GISEL-NEXT:   $x16 = COPY [[COPY]]
  ; GISEL-NEXT:   $x17 = IMPLICIT_DEF
  ; GISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   [[COPY5:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   AUTPAC 2, 42, [[COPY4]], 3, 123, [[COPY5]], implicit-def $x16, implicit-def $x17, implicit-def dead $nzcv, implicit $x16
  ; GISEL-NEXT:   [[COPY6:%[0-9]+]]:gpr64 = COPY $x16
  ; GISEL-NEXT:   $x0 = COPY [[COPY6]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %auth.disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %sign.disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 123)
  %cond.b = icmp ne i64 %cond, 0
  br i1 %cond.b, label %next, label %exit

next:
  call void asm sideeffect "nop", "r,r"(i64 %auth.disc, i64 %sign.disc)
  br label %exit

exit:
  %resigned = call i64 @llvm.ptrauth.resign(i64 %addr, i32 2, i64 %auth.disc, i32 3, i64 %sign.disc)
  ret i64 %resigned
}

; Test other pseudo instructions accepting discriminator components as separate
; operands: AUTH_TCRETURN, AUTH_TCRETURN_BTI and BLRA.
; FIXME: Test BLRA_RVMARKER.
;
; A few other PAuth-related pseudo instructions exist that accept address and
; integer discriminator components, but the way they are currently selected both
; by DAGISel and GlobalISel is not susceptible to this issue:
; * MOVaddrPAC and LOADgotPAC are only emitted when lowering `ptrauth` constants
;   in LLVM IR, so their discriminators are never expressed via blend.
; * BRA is only emitted for indirect branch, and its address discriminator is
;   always XZR.
;
; Furthermore, a few more pseudo instructions have HasPAuth in their predicates,
; but only have constant discriminator or no discriminator operands at all:
; LOADgotAUTH and LOADauthptrstatic.
;
; The below test cases specify non-default preserve_nonecc calling convention -
; this is to prevent meaningless divergence between Darwin and ELF targets due
; to difference in callee-saved register masks specified in call instructions.

define preserve_nonecc i64 @auth_tcreturn_blend_components(ptr %callee, i1 %cond.b) {
  ; DAGISEL-LABEL: name: auth_tcreturn_blend_components
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; DAGISEL-NEXT:   liveins: $x20, $w0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr32 = COPY $w0
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:tcgprnotx16x17 = COPY $x20
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:tcgpr64 = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   TBZW [[COPY]], 0, %bb.2
  ; DAGISEL-NEXT:   B %bb.1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.1.next:
  ; DAGISEL-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.2.exit:
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:tcgpr64 = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   AUTH_TCRETURN [[COPY1]], 0, 1, 42, [[COPY4]], csr_aarch64_noneregs, implicit-def dead $x16, implicit-def dead $x17, implicit $sp
  ;
  ; GISEL-LABEL: name: auth_tcreturn_blend_components
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   successors: %bb.2(0x40000000), %bb.3(0x40000000)
  ; GISEL-NEXT:   liveins: $w0, $x20
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:tcgprnotx16x17 = COPY $x20
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $w0
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:tcgpr64 = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   TBZW [[COPY1]], 0, %bb.3
  ; GISEL-NEXT:   B %bb.2
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.2.next:
  ; GISEL-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[MOVKXi]]
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.3.exit:
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:tcgpr64 = COPY [[LDRXui]]
  ; GISEL-NEXT:   AUTH_TCRETURN [[COPY]], 0, 1, 42, [[COPY2]], csr_aarch64_noneregs, implicit-def $x16, implicit-def $x17, implicit $sp
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  br i1 %cond.b, label %next, label %exit

next:
  call void asm sideeffect "nop", "r"(i64 %disc)
  br label %exit

exit:
  %result = tail call preserve_nonecc i64 %callee() [ "ptrauth"(i32 1, i64 %disc) ]
  ret i64 %result
}

define preserve_nonecc i64 @auth_tcreturn_bti_blend_components(ptr %callee, i1 %cond.b) "branch-target-enforcement"="true" {
  ; DAGISEL-LABEL: name: auth_tcreturn_bti_blend_components
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; DAGISEL-NEXT:   liveins: $x20, $w0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr32 = COPY $w0
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x20
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:tcgprnotx16x17 = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   TBZW [[COPY]], 0, %bb.2
  ; DAGISEL-NEXT:   B %bb.1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.1.next:
  ; DAGISEL-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.2.exit:
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:tcgprx16x17 = COPY [[COPY1]]
  ; DAGISEL-NEXT:   [[COPY5:%[0-9]+]]:tcgprnotx16x17 = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   AUTH_TCRETURN_BTI [[COPY4]], 0, 1, 42, [[COPY5]], csr_aarch64_noneregs, implicit-def dead $x16, implicit-def dead $x17, implicit $sp
  ;
  ; GISEL-LABEL: name: auth_tcreturn_bti_blend_components
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   successors: %bb.2(0x40000000), %bb.3(0x40000000)
  ; GISEL-NEXT:   liveins: $w0, $x20
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:tcgprx16x17 = COPY $x20
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $w0
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:tcgprnotx16x17 = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   TBZW [[COPY1]], 0, %bb.3
  ; GISEL-NEXT:   B %bb.2
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.2.next:
  ; GISEL-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[MOVKXi]]
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.3.exit:
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:tcgprnotx16x17 = COPY [[LDRXui]]
  ; GISEL-NEXT:   AUTH_TCRETURN_BTI [[COPY]], 0, 1, 42, [[COPY2]], csr_aarch64_noneregs, implicit-def $x16, implicit-def $x17, implicit $sp
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  br i1 %cond.b, label %next, label %exit

next:
  call void asm sideeffect "nop", "r"(i64 %disc)
  br label %exit

exit:
  %result = tail call preserve_nonecc i64 %callee() [ "ptrauth"(i32 1, i64 %disc) ]
  ret i64 %result
}

define preserve_nonecc i64 @blra_blend_components(ptr %callee, i1 %cond.b) {
  ; DAGISEL-LABEL: name: blra_blend_components
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; DAGISEL-NEXT:   liveins: $x20, $w0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr32 = COPY $w0
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY $x20
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64 = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   TBZW [[COPY]], 0, %bb.2
  ; DAGISEL-NEXT:   B %bb.1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.1.next:
  ; DAGISEL-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.2.exit:
  ; DAGISEL-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def dead $sp, implicit $sp
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   BLRA [[COPY1]], 1, 42, [[COPY4]], csr_aarch64_noneregs, implicit-def dead $x16, implicit-def dead $x17, implicit-def dead $lr, implicit $sp, implicit-def $sp, implicit-def $x0
  ; DAGISEL-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def dead $sp, implicit $sp
  ; DAGISEL-NEXT:   [[COPY5:%[0-9]+]]:gpr64sp = COPY $x0
  ; DAGISEL-NEXT:   [[ADDXri:%[0-9]+]]:gpr64sp = ADDXri [[COPY5]], 123, 0
  ; DAGISEL-NEXT:   $x0 = COPY [[ADDXri]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blra_blend_components
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   successors: %bb.2(0x40000000), %bb.3(0x40000000)
  ; GISEL-NEXT:   liveins: $w0, $x20
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64noip = COPY $x20
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr32 = COPY $w0
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   TBZW [[COPY1]], 0, %bb.3
  ; GISEL-NEXT:   B %bb.2
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.2.next:
  ; GISEL-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64common = COPY [[MOVKXi]]
  ; GISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY2]]
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.3.exit:
  ; GISEL-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; GISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   BLRA [[COPY]], 1, 42, [[COPY3]], csr_aarch64_noneregs, implicit-def $x16, implicit-def $x17, implicit-def $lr, implicit $sp, implicit-def $x0
  ; GISEL-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; GISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64sp = COPY $x0
  ; GISEL-NEXT:   [[ADDXri:%[0-9]+]]:gpr64sp = ADDXri [[COPY4]], 123, 0
  ; GISEL-NEXT:   $x0 = COPY [[ADDXri]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  br i1 %cond.b, label %next, label %exit

next:
  call void asm sideeffect "nop", "r"(i64 %disc)
  br label %exit

exit:
  %tmp = call preserve_nonecc i64 %callee() [ "ptrauth"(i32 1, i64 %disc) ]
  ; Prevent tail call.
  %result = add i64 %tmp, 123
  ret i64 %result
}
