; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple arm64e-apple-darwin             -verify-machineinstrs -stop-after=finalize-isel -global-isel=0 \
; RUN:     | FileCheck %s --check-prefixes=DAGISEL
; RUN: llc < %s -mtriple arm64e-apple-darwin             -verify-machineinstrs -stop-after=finalize-isel -global-isel=1 -global-isel-abort=1 \
; RUN:     | FileCheck %s --check-prefixes=GISEL
; RUN: llc < %s -mtriple aarch64-linux-gnu -mattr=+pauth -verify-machineinstrs -stop-after=finalize-isel -global-isel=0 \
; RUN:     | FileCheck %s --check-prefixes=DAGISEL
; RUN: llc < %s -mtriple aarch64-linux-gnu -mattr=+pauth -verify-machineinstrs -stop-after=finalize-isel -global-isel=1 -global-isel-abort=1 \
; RUN:     | FileCheck %s --check-prefixes=GISEL

; Check MIR produced by the instruction selector to validate properties that
; cannot be reliably tested by only inspecting the final asm output.

@discvar = dso_local global i64 0

; Make sure the components of blend(addr, imm) and integer constants are
; recognized and passed to PAC pseudo via separate operands to prevent
; substitution of the immediate modifier.
;
; MIR output of the instruction selector is inspected, as it is hard to reliably
; distinguish MOVKXi immediately followed by a pseudo from a standalone pseudo
; instruction carrying address and immediate modifiers in its separate operands
; by only observing the final asm output.

define i64 @small_imm_disc_optimized(i64 %addr) {
  ; DAGISEL-LABEL: name: small_imm_disc_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 42
  ; DAGISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, killed [[MOVi32imm]], %subreg.sub_32
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, killed $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: small_imm_disc_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 42
  ; GISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, [[MOVi32imm]], %subreg.sub_32
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 42)
  ret i64 %signed
}

; Without optimization, MOVi64imm may be used for small i64 constants as well.
define i64 @small_imm_disc_non_optimized(i64 %addr) noinline optnone {
  ; DAGISEL-LABEL: name: small_imm_disc_non_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY killed [[COPY]]
  ; DAGISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 42
  ; DAGISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, killed [[MOVi32imm]], %subreg.sub_32
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY1]], 2, 42, killed $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64all = COPY [[PAC]]
  ; DAGISEL-NEXT:   $x0 = COPY [[COPY2]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: small_imm_disc_non_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi64imm:%[0-9]+]]:gpr64noip = MOVi64imm 42
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, $noreg, implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 42)
  ret i64 %signed
}

define i64 @large_imm_disc_wreg(i64 %addr) {
  ; DAGISEL-LABEL: name: large_imm_disc_wreg
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 12345678
  ; DAGISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, killed [[MOVi32imm]], %subreg.sub_32
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, killed [[SUBREG_TO_REG]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: large_imm_disc_wreg
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi32imm:%[0-9]+]]:gpr32 = MOVi32imm 12345678
  ; GISEL-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gpr64noip = SUBREG_TO_REG 0, [[MOVi32imm]], %subreg.sub_32
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, [[SUBREG_TO_REG]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 12345678)
  ret i64 %signed
}

define i64 @large_imm_disc_xreg(i64 %addr) {
  ; DAGISEL-LABEL: name: large_imm_disc_xreg
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[MOVi64imm:%[0-9]+]]:gpr64noip = MOVi64imm 123456789012345
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, killed [[MOVi64imm]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: large_imm_disc_xreg
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[MOVi64imm:%[0-9]+]]:gpr64noip = MOVi64imm 123456789012345
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 0, [[MOVi64imm]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 123456789012345)
  ret i64 %signed
}

; Make sure blend() is lowered as expected when optimization is disabled.
define i64 @blended_disc_non_optimized(i64 %addr, i64 %addrdisc) noinline optnone {
  ; DAGISEL-LABEL: name: blended_disc_non_optimized
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0, $x1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64 = COPY killed [[COPY1]]
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64 = COPY killed [[COPY]]
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[COPY3]], 42, 48
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   [[COPY5:%[0-9]+]]:gpr64noip = COPY [[COPY3]]
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY2]], 2, 42, [[COPY5]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   [[COPY6:%[0-9]+]]:gpr64all = COPY [[PAC]]
  ; DAGISEL-NEXT:   $x0 = COPY [[COPY6]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blended_disc_non_optimized
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0, $x1
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[COPY1]], 42, 48
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[COPY1]]
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, [[COPY2]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 %disc)
  ret i64 %signed
}

define i64 @blend_and_sign_same_bb(i64 %addr) {
  ; DAGISEL-LABEL: name: blend_and_sign_same_bb
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   liveins: $x0
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, killed [[COPY1]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blend_and_sign_same_bb
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   liveins: $x0
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, [[COPY1]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 %disc)
  ret i64 %signed
}

; In the below test cases both %addrdisc and %disc are computed (i.e. they are
; neither global addresses, nor function arguments) in a different basic block,
; making them harder to express via ISD::PtrAuthGlobalAddress.

define i64 @blend_and_sign_different_bbs(i64 %addr, i64 %cond) {
  ; DAGISEL-LABEL: name: blend_and_sign_different_bbs
  ; DAGISEL: bb.0.entry:
  ; DAGISEL-NEXT:   successors: %bb.1(0x50000000), %bb.2(0x30000000)
  ; DAGISEL-NEXT:   liveins: $x0, $x1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; DAGISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; DAGISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; DAGISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui killed [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; DAGISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64 = MOVKXi [[LDRXui]], 42, 48
  ; DAGISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64noip = COPY [[MOVKXi]]
  ; DAGISEL-NEXT:   CBZX [[COPY]], %bb.2
  ; DAGISEL-NEXT:   B %bb.1
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.1.next:
  ; DAGISEL-NEXT:   successors: %bb.2(0x80000000)
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64common = COPY [[COPY2]]
  ; DAGISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY3]]
  ; DAGISEL-NEXT: {{  $}}
  ; DAGISEL-NEXT: bb.2.exit:
  ; DAGISEL-NEXT:   [[COPY4:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; DAGISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY1]], 2, 42, [[COPY4]], implicit-def dead $x16, implicit-def dead $x17
  ; DAGISEL-NEXT:   $x0 = COPY [[PAC]]
  ; DAGISEL-NEXT:   RET_ReallyLR implicit $x0
  ;
  ; GISEL-LABEL: name: blend_and_sign_different_bbs
  ; GISEL: bb.1.entry:
  ; GISEL-NEXT:   successors: %bb.2(0x50000000), %bb.3(0x30000000)
  ; GISEL-NEXT:   liveins: $x0, $x1
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x0
  ; GISEL-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x1
  ; GISEL-NEXT:   [[ADRP:%[0-9]+]]:gpr64common = ADRP target-flags(aarch64-page) @discvar
  ; GISEL-NEXT:   [[LDRXui:%[0-9]+]]:gpr64 = LDRXui [[ADRP]], target-flags(aarch64-pageoff, aarch64-nc) @discvar :: (dereferenceable load (s64) from @discvar)
  ; GISEL-NEXT:   [[MOVKXi:%[0-9]+]]:gpr64noip = MOVKXi [[LDRXui]], 42, 48
  ; GISEL-NEXT:   CBZX [[COPY1]], %bb.3
  ; GISEL-NEXT:   B %bb.2
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.2.next:
  ; GISEL-NEXT:   successors: %bb.3(0x80000000)
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT:   [[COPY2:%[0-9]+]]:gpr64common = COPY [[MOVKXi]]
  ; GISEL-NEXT:   INLINEASM &nop, 1 /* sideeffect attdialect */, 3866633 /* reguse:GPR64common */, [[COPY2]]
  ; GISEL-NEXT: {{  $}}
  ; GISEL-NEXT: bb.3.exit:
  ; GISEL-NEXT:   [[COPY3:%[0-9]+]]:gpr64noip = COPY [[LDRXui]]
  ; GISEL-NEXT:   [[PAC:%[0-9]+]]:gpr64 = PAC [[COPY]], 2, 42, [[COPY3]], implicit-def dead $x16, implicit-def dead $x17
  ; GISEL-NEXT:   $x0 = COPY [[PAC]]
  ; GISEL-NEXT:   RET_ReallyLR implicit $x0
entry:
  %addrdisc = load i64, ptr @discvar
  %disc = call i64 @llvm.ptrauth.blend(i64 %addrdisc, i64 42)
  %cond.b = icmp ne i64 %cond, 0
  br i1 %cond.b, label %next, label %exit

next:
  call void asm sideeffect "nop", "r"(i64 %disc)
  br label %exit

exit:
  %signed = call i64 @llvm.ptrauth.sign(i64 %addr, i32 2, i64 %disc)
  ret i64 %signed
}
