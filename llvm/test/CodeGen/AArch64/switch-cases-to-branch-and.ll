; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -O3 -mtriple=arm64-apple-macosx -o - %s | FileCheck %s

define i32 @switch_with_matching_dests_0_and_pow2_3_cases(i8 %v) {
; CHECK-LABEL: switch_with_matching_dests_0_and_pow2_3_cases:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov w9, #100 ; =0x64
; CHECK-NEXT:    mov w8, #20 ; =0x14
; CHECK-NEXT:  LBB0_1: ; %loop.header
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ands w10, w0, #0xff
; CHECK-NEXT:    b.eq LBB0_6
; CHECK-NEXT:  ; %bb.2: ; %loop.header
; CHECK-NEXT:    ; in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    cmp w10, #32
; CHECK-NEXT:    b.eq LBB0_6
; CHECK-NEXT:  ; %bb.3: ; %loop.header
; CHECK-NEXT:    ; in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    cmp w10, #124
; CHECK-NEXT:    b.eq LBB0_7
; CHECK-NEXT:  ; %bb.4: ; %loop.latch
; CHECK-NEXT:    ; in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    subs w9, w9, #1
; CHECK-NEXT:    b.ne LBB0_1
; CHECK-NEXT:  ; %bb.5:
; CHECK-NEXT:    mov w8, #20 ; =0x14
; CHECK-NEXT:  LBB0_6: ; %common.ret
; CHECK-NEXT:    mov w0, w8
; CHECK-NEXT:    ret
; CHECK-NEXT:  LBB0_7: ; %e2
; CHECK-NEXT:    mov w0, #30 ; =0x1e
; CHECK-NEXT:    ret
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]
  switch i8 %v, label %loop.latch [
  i8 32, label %e1
  i8 0, label %e1
  i8 124, label %e2
  ]

loop.latch:
  %iv.next = add i32 %iv, 1
  %c = icmp eq i32 %iv.next, 100
  br i1 %c, label %e1, label %loop.header

e1:
  ret i32 20

e2:
  ret i32 30
}

define i64 @consecutive_match_both(ptr %p, i32 %param) {
; CHECK-LABEL: consecutive_match_both:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov w8, #1 ; =0x1
; CHECK-NEXT:    mov w9, #100 ; =0x64
; CHECK-NEXT:    mov w10, #249 ; =0xf9
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    b LBB1_2
; CHECK-NEXT:  LBB1_1: ; %loop.latch
; CHECK-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    subs w9, w9, #1
; CHECK-NEXT:    b.eq LBB1_5
; CHECK-NEXT:  LBB1_2: ; %loop.header
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmp w1, #7
; CHECK-NEXT:    b.hi LBB1_1
; CHECK-NEXT:  ; %bb.3: ; %loop.header
; CHECK-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    tst w8, w10
; CHECK-NEXT:    b.eq LBB1_1
; CHECK-NEXT:  ; %bb.4: ; %e0
; CHECK-NEXT:    mov x0, xzr
; CHECK-NEXT:    ret
; CHECK-NEXT:  LBB1_5:
; CHECK-NEXT:    mov x0, #-42 ; =0xffffffffffffffd6
; CHECK-NEXT:    ret
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]
  switch i32 %param, label %loop.latch [
  i32 7, label %e0
  i32 6, label %e0
  i32 5, label %e0
  i32 4, label %e0
  i32 3, label %e0
  i32 0, label %e0
  ]

loop.latch:
  %iv.next = add i32 %iv, 1
  %ec = icmp eq i32 %iv.next, 100
  br i1 %ec, label %e1, label %loop.header

e0:
  %m = getelementptr i8, ptr %p, i64 20
  br label %e1

e1:
  %res = phi i64 [ 0, %e0 ], [ -42, %loop.latch ]
  ret i64 %res
}

define i64 @consecutive_match_before(ptr %p, i32 %param) {
; CHECK-LABEL: consecutive_match_before:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov w8, #1 ; =0x1
; CHECK-NEXT:    mov w9, #100 ; =0x64
; CHECK-NEXT:    mov w10, #25 ; =0x19
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    b LBB2_2
; CHECK-NEXT:  LBB2_1: ; %loop.latch
; CHECK-NEXT:    ; in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    subs w9, w9, #1
; CHECK-NEXT:    b.eq LBB2_5
; CHECK-NEXT:  LBB2_2: ; %loop.header
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmp w1, #4
; CHECK-NEXT:    b.hi LBB2_1
; CHECK-NEXT:  ; %bb.3: ; %loop.header
; CHECK-NEXT:    ; in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    tst w8, w10
; CHECK-NEXT:    b.eq LBB2_1
; CHECK-NEXT:  ; %bb.4: ; %e0
; CHECK-NEXT:    mov x0, xzr
; CHECK-NEXT:    ret
; CHECK-NEXT:  LBB2_5:
; CHECK-NEXT:    mov x0, #-42 ; =0xffffffffffffffd6
; CHECK-NEXT:    ret
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]
  switch i32 %param, label %loop.latch [
  i32 4, label %e0
  i32 3, label %e0
  i32 0, label %e0
  ]

loop.latch:
  %iv.next = add i32 %iv, 1
  %ec = icmp eq i32 %iv.next, 100
  br i1 %ec, label %e1, label %loop.header

e0:
  %m = getelementptr i8, ptr %p, i64 20
  br label %e1

e1:
  %res = phi i64 [ 0, %e0 ], [ -42, %loop.latch ]
  ret i64 %res
}

define i64 @consecutive_match_after(ptr %p, i32 %param) {
; CHECK-LABEL: consecutive_match_after:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov w8, #1 ; =0x1
; CHECK-NEXT:    mov w9, #100 ; =0x64
; CHECK-NEXT:    mov w10, #49 ; =0x31
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    b LBB3_2
; CHECK-NEXT:  LBB3_1: ; %loop.latch
; CHECK-NEXT:    ; in Loop: Header=BB3_2 Depth=1
; CHECK-NEXT:    subs w9, w9, #1
; CHECK-NEXT:    b.eq LBB3_5
; CHECK-NEXT:  LBB3_2: ; %loop.header
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmp w1, #5
; CHECK-NEXT:    b.hi LBB3_1
; CHECK-NEXT:  ; %bb.3: ; %loop.header
; CHECK-NEXT:    ; in Loop: Header=BB3_2 Depth=1
; CHECK-NEXT:    tst w8, w10
; CHECK-NEXT:    b.eq LBB3_1
; CHECK-NEXT:  ; %bb.4: ; %e0
; CHECK-NEXT:    mov x0, xzr
; CHECK-NEXT:    ret
; CHECK-NEXT:  LBB3_5:
; CHECK-NEXT:    mov x0, #-42 ; =0xffffffffffffffd6
; CHECK-NEXT:    ret
entry:
  br label %loop.header

loop.header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]
  switch i32 %param, label %loop.latch [
  i32 5, label %e0
  i32 4, label %e0
  i32 0, label %e0
  ]

loop.latch:
  %iv.next = add i32 %iv, 1
  %ec = icmp eq i32 %iv.next, 100
  br i1 %ec, label %e1, label %loop.header

e0:
  %m = getelementptr i8, ptr %p, i64 20
  br label %e1

e1:
  %res = phi i64 [ 0, %e0 ], [ -42, %loop.latch ]
  ret i64 %res
}
