; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64 -mattr=+sve2 -verify-machineinstrs -stop-after=finalize-isel %s -o - | FileCheck %s

; Regression test for a bug where getTargetConstant(0) was used instead of
; getConstant(0) in ScalarizeVecRes_LOOP_DEPENDENCE_MASK, causing instruction
; selection to incorrectly generate CCMPXr (register form) with an immediate
; operand instead of CCMPXi (immediate form).
;

define <1 x i1> @test_war_mask_ccmp(ptr %a, ptr %b) {
  ; CHECK-LABEL: name: test_war_mask_ccmp
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $x0, $x1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; CHECK-NEXT:   [[SUBSXrr:%[0-9]+]]:gpr64common = SUBSXrr [[COPY]], [[COPY1]], implicit-def dead $nzcv
  ; CHECK-NEXT:   [[ADDSXri:%[0-9]+]]:gpr64 = ADDSXri killed [[SUBSXrr]], 1, 0, implicit-def $nzcv
  ; CHECK-NEXT:   [[CSINCWr:%[0-9]+]]:gpr32 = CSINCWr $wzr, $wzr, 13, implicit $nzcv
  ; CHECK-NEXT:   $w0 = COPY [[CSINCWr]]
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
entry:
  %0 = call <1 x i1> @llvm.loop.dependence.war.mask.v1i1(ptr %a, ptr %b, i64 1)
  ret <1 x i1> %0
}

define <1 x i1> @test_raw_mask_ccmp(ptr %a, ptr %b) {
  ; CHECK-LABEL: name: test_raw_mask_ccmp
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $x0, $x1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $x1
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpr64 = COPY $x0
  ; CHECK-NEXT:   [[SUBSXrr:%[0-9]+]]:gpr64common = SUBSXrr [[COPY]], [[COPY1]], implicit-def dead $nzcv
  ; CHECK-NEXT:   [[ADDSXri:%[0-9]+]]:gpr64 = ADDSXri killed [[SUBSXrr]], 1, 0, implicit-def $nzcv
  ; CHECK-NEXT:   [[CSINCWr:%[0-9]+]]:gpr32 = CSINCWr $wzr, $wzr, 13, implicit $nzcv
  ; CHECK-NEXT:   $w0 = COPY [[CSINCWr]]
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
entry:
  %0 = call <1 x i1> @llvm.loop.dependence.raw.mask.v1i1(ptr %a, ptr %b, i64 1)
  ret <1 x i1> %0
}

declare <1 x i1> @llvm.loop.dependence.war.mask.v1i1(ptr, ptr, i64)
declare <1 x i1> @llvm.loop.dependence.raw.mask.v1i1(ptr, ptr, i64)
