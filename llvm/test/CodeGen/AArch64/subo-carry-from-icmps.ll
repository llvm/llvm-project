; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=aarch64 | FileCheck %s

define i1 @is_usub_overflow_i32_with_two_i16(i16 %a0, i16 %a1, i16 %b0, i16 %b1) {
; CHECK-LABEL: is_usub_overflow_i32_with_two_i16:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    and w8, w0, #0xffff
; CHECK-NEXT:    sxth w9, w2
; CHECK-NEXT:    sub w8, w8, w1, uxth
; CHECK-NEXT:    tst w8, #0xffff0000
; CHECK-NEXT:    sxth w8, w3
; CHECK-NEXT:    cset w10, ne
; CHECK-NEXT:    cmp wzr, w10
; CHECK-NEXT:    sbcs wzr, w9, w8
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
entry:
  %carry.A = icmp ult i16 %a0, %a1
  %carry.B = icmp ult i16 %b0, %b1
  %equal.B = icmp eq i16 %b0, %b1

  %is.carry.A.propagated = and i1 %carry.A, %equal.B
  %carry.B.with.borrow.A = or i1 %carry.B, %is.carry.A.propagated

  ret i1 %carry.B.with.borrow.A
}

define i1 @is_usub_overflow_i64_with_two_i32(i32 %a0, i32 %a1, i32 %b0, i32 %b1) {
; CHECK-LABEL: is_usub_overflow_i64_with_two_i32:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp w0, w1
; CHECK-NEXT:    sbcs wzr, w2, w3
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
entry:
  %carry.A = icmp ult i32 %a0, %a1
  %carry.B = icmp ult i32 %b0, %b1
  %equal.B = icmp eq i32 %b0, %b1

  %is.carry.A.propagated = and i1 %carry.A, %equal.B
  %carry.B.with.borrow.A = or i1 %carry.B, %is.carry.A.propagated

  ret i1 %carry.B.with.borrow.A
}

define i1 @is_usub_overflow_i128_with_two_i64(i64 %a0, i64 %a1, i64 %b0, i64 %b1) {
;
; CHECK-LABEL: is_usub_overflow_i128_with_two_i64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    sbcs xzr, x2, x3
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
entry:
  %carry.A = icmp ult i64 %a0, %a1
  %carry.B = icmp ult i64 %b0, %b1
  %equal.B = icmp eq i64 %b0, %b1

  %is.carry.A.propagated = and i1 %carry.A, %equal.B
  %carry.B.with.borrow.A = or i1 %carry.B, %is.carry.A.propagated

  ret i1 %carry.B.with.borrow.A
}

; check GE/UGE are supported too
define i1 @i128_with_gt(i64 %a0, i64 %a1, i64 %b0, i64 %b1) {
; CHECK-LABEL: i128_with_gt:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    sbcs xzr, x2, x3
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
entry:
  %carry.A = icmp ugt i64 %a1, %a0
  %carry.B = icmp ugt i64 %b1, %b0
  %equal.B = icmp eq i64 %b0, %b1

  ; propagate carry only if B0 == B1
  %is.carry.A.propagated = and i1 %carry.A, %equal.B
  %carry.B.with.borrow.A = or i1 %carry.B, %is.carry.A.propagated

  ret i1 %carry.B.with.borrow.A
}

; do not combine if the check for CarryA propagating is not EQ
define i1 @nothing_if_not_eq(i64 %a0, i64 %a1, i64 %b0, i64 %b1) {
; CHECK-LABEL: nothing_if_not_eq:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp x1, x0
; CHECK-NEXT:    ccmp x2, x3, #2, hs
; CHECK-NEXT:    ccmp x3, x2, #2, hi
; CHECK-NEXT:    cset w0, hs
; CHECK-NEXT:    ret
entry:
  %carry.A = icmp uge i64 %a1, %a0
  %carry.B = icmp uge i64 %b1, %b0
  %equal.B = icmp ule i64 %b0, %b1

  ; propagate carry only if B0 == B1
  %is.carry.A.propagated = and i1 %carry.A, %equal.B
  %carry.B.with.borrow.A = or i1 %carry.B, %is.carry.A.propagated

  ret i1 %carry.B.with.borrow.A
}

define i1 @is_ssub_overflow_i64_with_two_i32(i32 %a0, i32 %a1, i32 %b0, i32 %b1) {
; CHECK-LABEL: is_ssub_overflow_i64_with_two_i32:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp w0, w1
; CHECK-NEXT:    cset w8, vs
; CHECK-NEXT:    cmp wzr, w8
; CHECK-NEXT:    sbcs wzr, w2, w3
; CHECK-NEXT:    cset w0, vs
; CHECK-NEXT:    ret
entry:
  %carry.A = icmp slt i32 %a0, %a1
  %carry.B = icmp slt i32 %b0, %b1
  %equal.B = icmp eq i32 %b0, %b1

  %is.carry.A.propagated = and i1 %carry.A, %equal.B
  %carry.B.with.borrow.A = or i1 %carry.B, %is.carry.A.propagated

  ret i1 %carry.B.with.borrow.A
}
