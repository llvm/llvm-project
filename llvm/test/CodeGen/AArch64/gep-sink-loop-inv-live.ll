; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -codegenprepare < %s | FileCheck %s
target triple = "aarch64-linux"

declare void @use(...)
declare i64 @next(i64)

define void @f(ptr %a, i64 %k, i64 %n, ptr %q) {
; CHECK-LABEL: @f(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[COND:%.*]]
; CHECK:       cond:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[J:%.*]], [[IF_THEN:%.*]] ], [ [[I]], [[IF_ELSE:%.*]] ]
; CHECK-NEXT:    [[P:%.*]] = getelementptr i32, ptr [[A:%.*]], i64 [[I]]
; CHECK-NEXT:    [[C0:%.*]] = icmp ult i64 [[I]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[C0]], label [[LOOP:%.*]], label [[EXIT:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[J]] = call i64 @next(i64 [[I]])
; CHECK-NEXT:    [[SUNKADDR:%.*]] = mul i64 [[I]], 4
; CHECK-NEXT:    [[SUNKADDR1:%.*]] = getelementptr i8, ptr [[A]], i64 [[SUNKADDR]]
; CHECK-NEXT:    [[V:%.*]] = load i32, ptr [[SUNKADDR1]], align 4
; CHECK-NEXT:    [[C1:%.*]] = icmp slt i32 [[V]], 0
; CHECK-NEXT:    br i1 [[C1]], label [[IF_THEN]], label [[IF_ELSE]]
; CHECK:       if.then:
; CHECK-NEXT:    store ptr [[P]], ptr [[Q:%.*]], align 8
; CHECK-NEXT:    br label [[COND]]
; CHECK:       if.else:
; CHECK-NEXT:    call void @use(ptr [[A]])
; CHECK-NEXT:    br label [[COND]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  br label %cond

cond:
  %i = phi i64 [0, %entry], [%i.next, %next]
  %p = getelementptr i32, ptr %a, i64 %i
  %c0 = icmp ult i64 %i, %n
  br i1 %c0, label %loop, label %exit

loop:
  %j = call i64 @next(i64 %i)
  %v = load i32, ptr %p
  %c1 = icmp slt i32 %v, 0
  br i1 %c1, label %if.then, label %if.else

if.then:
  store ptr %p, ptr %q
  br label %next

if.else:
  call void @use(ptr %a)
  br label %next

next:
  %i.next = phi i64 [%j, %if.then], [%i, %if.else]
  br label %cond

exit:
  ret void
}
