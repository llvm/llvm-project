; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=aarch64 -mattr=+sve < %s | FileCheck %s --check-prefixes=CHECK,CHECK-BASE
; RUN: llc -mtriple=aarch64 -aarch64-sve-vector-bits-min=256 -mattr=+sve < %s | FileCheck %s --check-prefixes=CHECK,CHECK-VL256

;; Full SVE vectors (supported with +sve)

define void @test_compressstore_nxv4i32(ptr %p, <vscale x 4 x i32> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compressstore_nxv4i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    cntp x8, p1, p0.s
; CHECK-NEXT:    whilelo p0.s, xzr, x8
; CHECK-NEXT:    st1w { z0.s }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.nxv4i32(<vscale x 4 x i32> %vec, ptr align 4 %p, <vscale x 4 x i1> %mask)
  ret void
}

define void @test_compressstore_nxv2i64(ptr %p, <vscale x 2 x i64> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compressstore_nxv2i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    cntp x8, p1, p0.d
; CHECK-NEXT:    whilelo p0.d, xzr, x8
; CHECK-NEXT:    st1d { z0.d }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.nxv2i64(<vscale x 2 x i64> %vec, ptr align 8 %p, <vscale x 2 x i1> %mask)
  ret void
}

define void @test_compressstore_nxv4f32(ptr %p, <vscale x 4 x float> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compressstore_nxv4f32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    cntp x8, p1, p0.s
; CHECK-NEXT:    whilelo p0.s, xzr, x8
; CHECK-NEXT:    st1w { z0.s }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.nxv4f32(<vscale x 4 x float> %vec, ptr align 4 %p, <vscale x 4 x i1> %mask)
  ret void
}

define void @test_compressstore_nxv2f64(ptr %p, <vscale x 2 x double> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compressstore_nxv2f64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    cntp x8, p1, p0.d
; CHECK-NEXT:    whilelo p0.d, xzr, x8
; CHECK-NEXT:    st1d { z0.d }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.nxv2f64(<vscale x 2 x double> %vec, ptr align 8 %p, <vscale x 2 x i1> %mask)
  ret void
}

;; Unpacked SVE vector types

define void @test_compressstore_nxv2f32(ptr %p, <vscale x 2 x float> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compressstore_nxv2f32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    cntp x8, p1, p0.d
; CHECK-NEXT:    whilelo p0.d, xzr, x8
; CHECK-NEXT:    st1w { z0.d }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.nxv2f32(<vscale x 2 x float> %vec, ptr align 4 %p, <vscale x 2 x i1> %mask)
  ret void
}

;; SVE vector types promoted to 32/64-bit (non-exhaustive)

define void @test_compressstore_nxv2i8(ptr %p, <vscale x 2 x i8> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compressstore_nxv2i8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    cntp x8, p1, p0.d
; CHECK-NEXT:    whilelo p0.d, xzr, x8
; CHECK-NEXT:    st1b { z0.d }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.nxv2i8(<vscale x 2 x i8> %vec, ptr align 1 %p, <vscale x 2 x i1> %mask)
  ret void
}

define void @test_compressstore_nxv4i16(ptr %p, <vscale x 4 x i16> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compressstore_nxv4i16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    cntp x8, p1, p0.s
; CHECK-NEXT:    whilelo p0.s, xzr, x8
; CHECK-NEXT:    st1h { z0.s }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.nxv4i16(<vscale x 4 x i16> %vec, ptr align 2 %p, <vscale x 4 x i1> %mask)
  ret void
}

;; NEON vector types (promoted to SVE)

define void @test_compressstore_v2f64(ptr %p, <2 x double> %vec, <2 x i1> %mask) {
; CHECK-LABEL: test_compressstore_v2f64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ushll v1.2d, v1.2s, #0
; CHECK-NEXT:    ptrue p0.d, vl2
; CHECK-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    shl v1.2d, v1.2d, #63
; CHECK-NEXT:    cmpne p0.d, p0/z, z1.d, #0
; CHECK-NEXT:    cntp x8, p1, p0.d
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    whilelo p0.d, xzr, x8
; CHECK-NEXT:    st1d { z0.d }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.v2f64(<2 x double> %vec, ptr align 8 %p, <2 x i1> %mask)
  ret void
}

define void @test_compressstore_v4i32(ptr %p, <4 x i32> %vec, <4 x i1> %mask) {
; CHECK-LABEL: test_compressstore_v4i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ushll v1.4s, v1.4h, #0
; CHECK-NEXT:    ptrue p0.s, vl4
; CHECK-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    shl v1.4s, v1.4s, #31
; CHECK-NEXT:    cmpne p0.s, p0/z, z1.s, #0
; CHECK-NEXT:    cntp x8, p1, p0.s
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    whilelo p0.s, xzr, x8
; CHECK-NEXT:    st1w { z0.s }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.v4i32(<4 x i32> %vec, ptr align 4 %p, <4 x i1> %mask)
  ret void
}

define void @test_compressstore_v2i64(ptr %p, <2 x i64> %vec, <2 x i1> %mask) {
; CHECK-LABEL: test_compressstore_v2i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ushll v1.2d, v1.2s, #0
; CHECK-NEXT:    ptrue p0.d, vl2
; CHECK-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-NEXT:    ptrue p1.d
; CHECK-NEXT:    shl v1.2d, v1.2d, #63
; CHECK-NEXT:    cmpne p0.d, p0/z, z1.d, #0
; CHECK-NEXT:    cntp x8, p1, p0.d
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    whilelo p0.d, xzr, x8
; CHECK-NEXT:    st1d { z0.d }, p0, [x0]
; CHECK-NEXT:    ret
  tail call void @llvm.masked.compressstore.v2i64(<2 x i64> %vec, ptr align 8 %p, <2 x i1> %mask)
  ret void
}

define void @test_compressstore_v8i32(ptr %p, <8 x i32> %vec, <8 x i1> %mask) {
; CHECK-BASE-LABEL: test_compressstore_v8i32:
; CHECK-BASE:       // %bb.0:
; CHECK-BASE-NEXT:    shl v2.8b, v2.8b, #7
; CHECK-BASE-NEXT:    adrp x8, .LCPI10_0
; CHECK-BASE-NEXT:    ldr d3, [x8, :lo12:.LCPI10_0]
; CHECK-BASE-NEXT:    cmlt v2.8b, v2.8b, #0
; CHECK-BASE-NEXT:    and v2.8b, v2.8b, v3.8b
; CHECK-BASE-NEXT:    addv b2, v2.8b
; CHECK-BASE-NEXT:    fmov w8, s2
; CHECK-BASE-NEXT:    tbnz w8, #0, .LBB10_9
; CHECK-BASE-NEXT:  // %bb.1: // %else
; CHECK-BASE-NEXT:    tbnz w8, #1, .LBB10_10
; CHECK-BASE-NEXT:  .LBB10_2: // %else2
; CHECK-BASE-NEXT:    tbnz w8, #2, .LBB10_11
; CHECK-BASE-NEXT:  .LBB10_3: // %else5
; CHECK-BASE-NEXT:    tbnz w8, #3, .LBB10_12
; CHECK-BASE-NEXT:  .LBB10_4: // %else8
; CHECK-BASE-NEXT:    tbnz w8, #4, .LBB10_13
; CHECK-BASE-NEXT:  .LBB10_5: // %else11
; CHECK-BASE-NEXT:    tbnz w8, #5, .LBB10_14
; CHECK-BASE-NEXT:  .LBB10_6: // %else14
; CHECK-BASE-NEXT:    tbnz w8, #6, .LBB10_15
; CHECK-BASE-NEXT:  .LBB10_7: // %else17
; CHECK-BASE-NEXT:    tbnz w8, #7, .LBB10_16
; CHECK-BASE-NEXT:  .LBB10_8: // %else20
; CHECK-BASE-NEXT:    ret
; CHECK-BASE-NEXT:  .LBB10_9: // %cond.store
; CHECK-BASE-NEXT:    st1 { v0.s }[0], [x0], #4
; CHECK-BASE-NEXT:    tbz w8, #1, .LBB10_2
; CHECK-BASE-NEXT:  .LBB10_10: // %cond.store1
; CHECK-BASE-NEXT:    st1 { v0.s }[1], [x0], #4
; CHECK-BASE-NEXT:    tbz w8, #2, .LBB10_3
; CHECK-BASE-NEXT:  .LBB10_11: // %cond.store4
; CHECK-BASE-NEXT:    st1 { v0.s }[2], [x0], #4
; CHECK-BASE-NEXT:    tbz w8, #3, .LBB10_4
; CHECK-BASE-NEXT:  .LBB10_12: // %cond.store7
; CHECK-BASE-NEXT:    st1 { v0.s }[3], [x0], #4
; CHECK-BASE-NEXT:    tbz w8, #4, .LBB10_5
; CHECK-BASE-NEXT:  .LBB10_13: // %cond.store10
; CHECK-BASE-NEXT:    st1 { v1.s }[0], [x0], #4
; CHECK-BASE-NEXT:    tbz w8, #5, .LBB10_6
; CHECK-BASE-NEXT:  .LBB10_14: // %cond.store13
; CHECK-BASE-NEXT:    st1 { v1.s }[1], [x0], #4
; CHECK-BASE-NEXT:    tbz w8, #6, .LBB10_7
; CHECK-BASE-NEXT:  .LBB10_15: // %cond.store16
; CHECK-BASE-NEXT:    st1 { v1.s }[2], [x0], #4
; CHECK-BASE-NEXT:    tbz w8, #7, .LBB10_8
; CHECK-BASE-NEXT:  .LBB10_16: // %cond.store19
; CHECK-BASE-NEXT:    st1 { v1.s }[3], [x0]
; CHECK-BASE-NEXT:    ret
;
; CHECK-VL256-LABEL: test_compressstore_v8i32:
; CHECK-VL256:       // %bb.0:
; CHECK-VL256-NEXT:    // kill: def $d2 killed $d2 def $z2
; CHECK-VL256-NEXT:    ptrue p0.s, vl8
; CHECK-VL256-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-VL256-NEXT:    // kill: def $q1 killed $q1 def $z1
; CHECK-VL256-NEXT:    uunpklo z2.h, z2.b
; CHECK-VL256-NEXT:    ptrue p1.s, vl4
; CHECK-VL256-NEXT:    splice z0.s, p1, z0.s, z1.s
; CHECK-VL256-NEXT:    ptrue p1.s
; CHECK-VL256-NEXT:    uunpklo z2.s, z2.h
; CHECK-VL256-NEXT:    lsl z2.s, z2.s, #31
; CHECK-VL256-NEXT:    asr z2.s, z2.s, #31
; CHECK-VL256-NEXT:    cmpne p0.s, p0/z, z2.s, #0
; CHECK-VL256-NEXT:    cntp x8, p1, p0.s
; CHECK-VL256-NEXT:    compact z0.s, p0, z0.s
; CHECK-VL256-NEXT:    whilelo p0.s, xzr, x8
; CHECK-VL256-NEXT:    st1w { z0.s }, p0, [x0]
; CHECK-VL256-NEXT:    ret
  tail call void @llvm.masked.compressstore.v8i32(<8 x i32> %vec, ptr align 4 %p, <8 x i1> %mask)
  ret void
}

define void @test_compressstore_v4i64(ptr %p, <4 x i64> %vec, <4 x i1> %mask) {
; CHECK-BASE-LABEL: test_compressstore_v4i64:
; CHECK-BASE:       // %bb.0:
; CHECK-BASE-NEXT:    shl v2.4h, v2.4h, #15
; CHECK-BASE-NEXT:    adrp x8, .LCPI11_0
; CHECK-BASE-NEXT:    ldr d3, [x8, :lo12:.LCPI11_0]
; CHECK-BASE-NEXT:    cmlt v2.4h, v2.4h, #0
; CHECK-BASE-NEXT:    and v2.8b, v2.8b, v3.8b
; CHECK-BASE-NEXT:    addv h2, v2.4h
; CHECK-BASE-NEXT:    fmov w8, s2
; CHECK-BASE-NEXT:    tbnz w8, #0, .LBB11_5
; CHECK-BASE-NEXT:  // %bb.1: // %else
; CHECK-BASE-NEXT:    tbnz w8, #1, .LBB11_6
; CHECK-BASE-NEXT:  .LBB11_2: // %else2
; CHECK-BASE-NEXT:    tbnz w8, #2, .LBB11_7
; CHECK-BASE-NEXT:  .LBB11_3: // %else5
; CHECK-BASE-NEXT:    tbnz w8, #3, .LBB11_8
; CHECK-BASE-NEXT:  .LBB11_4: // %else8
; CHECK-BASE-NEXT:    ret
; CHECK-BASE-NEXT:  .LBB11_5: // %cond.store
; CHECK-BASE-NEXT:    st1 { v0.d }[0], [x0], #8
; CHECK-BASE-NEXT:    tbz w8, #1, .LBB11_2
; CHECK-BASE-NEXT:  .LBB11_6: // %cond.store1
; CHECK-BASE-NEXT:    st1 { v0.d }[1], [x0], #8
; CHECK-BASE-NEXT:    tbz w8, #2, .LBB11_3
; CHECK-BASE-NEXT:  .LBB11_7: // %cond.store4
; CHECK-BASE-NEXT:    st1 { v1.d }[0], [x0], #8
; CHECK-BASE-NEXT:    tbz w8, #3, .LBB11_4
; CHECK-BASE-NEXT:  .LBB11_8: // %cond.store7
; CHECK-BASE-NEXT:    st1 { v1.d }[1], [x0]
; CHECK-BASE-NEXT:    ret
;
; CHECK-VL256-LABEL: test_compressstore_v4i64:
; CHECK-VL256:       // %bb.0:
; CHECK-VL256-NEXT:    // kill: def $d2 killed $d2 def $z2
; CHECK-VL256-NEXT:    ptrue p0.d, vl4
; CHECK-VL256-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-VL256-NEXT:    // kill: def $q1 killed $q1 def $z1
; CHECK-VL256-NEXT:    uunpklo z2.s, z2.h
; CHECK-VL256-NEXT:    ptrue p1.d, vl2
; CHECK-VL256-NEXT:    splice z0.d, p1, z0.d, z1.d
; CHECK-VL256-NEXT:    ptrue p1.d
; CHECK-VL256-NEXT:    uunpklo z2.d, z2.s
; CHECK-VL256-NEXT:    lsl z2.d, z2.d, #63
; CHECK-VL256-NEXT:    asr z2.d, z2.d, #63
; CHECK-VL256-NEXT:    cmpne p0.d, p0/z, z2.d, #0
; CHECK-VL256-NEXT:    cntp x8, p1, p0.d
; CHECK-VL256-NEXT:    compact z0.d, p0, z0.d
; CHECK-VL256-NEXT:    whilelo p0.d, xzr, x8
; CHECK-VL256-NEXT:    st1d { z0.d }, p0, [x0]
; CHECK-VL256-NEXT:    ret
  tail call void @llvm.masked.compressstore.v4i64(<4 x i64> %vec, ptr align 8 %p, <4 x i1> %mask)
  ret void
}
