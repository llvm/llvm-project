; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -expand-reductions -S | FileCheck %s

target triple = "aarch64-unknown-linux-gnu"

; The reduction has the reassoc fast-math flag, so it can be done in log2(VF) iterations.
define float @test_reduce_fmul_tree_expansion(<vscale x 4 x float> %vec) #0 {
; CHECK-LABEL: define float @test_reduce_fmul_tree_expansion(
; CHECK-SAME: <vscale x 4 x float> [[VEC:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[TMP2:%.*]] = mul i64 [[TMP1]], 4
; CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cttz.i64(i64 [[TMP2]], i1 true)
; CHECK-NEXT:    br label %[[RDX_LOOP:.*]]
; CHECK:       [[RDX_LOOP]]:
; CHECK-NEXT:    [[ITER:%.*]] = phi i64 [ 0, [[TMP0:%.*]] ], [ [[ITER_NEXT:%.*]], %[[RDX_LOOP]] ]
; CHECK-NEXT:    [[RDX_PHI:%.*]] = phi fast <vscale x 4 x float> [ [[VEC]], [[TMP0]] ], [ [[RDX:%.*]], %[[RDX_LOOP]] ]
; CHECK-NEXT:    [[ITER_NEXT]] = add nuw nsw i64 [[ITER]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = call fast <vscale x 8 x float> @llvm.vector.insert.nxv8f32.nxv4f32(<vscale x 8 x float> poison, <vscale x 4 x float> [[RDX_PHI]], i64 0)
; CHECK-NEXT:    [[TMP5:%.*]] = call fast { <vscale x 4 x float>, <vscale x 4 x float> } @llvm.vector.deinterleave2.nxv8f32(<vscale x 8 x float> [[TMP4]])
; CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP5]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP5]], 1
; CHECK-NEXT:    [[RDX]] = fmul fast <vscale x 4 x float> [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[ITER_NEXT]], [[TMP3]]
; CHECK-NEXT:    br i1 [[EXITCOND]], [[DOTSPLIT:label %.*]], label %[[RDX_LOOP]]
; CHECK:       [[_SPLIT:.*:]]
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <vscale x 4 x float> [[RDX]], i64 0
; CHECK-NEXT:    [[RDX_FINAL:%.*]] = fmul fast float 3.000000e+00, [[TMP8]]
; CHECK-NEXT:    ret float [[RDX_FINAL]]
;
  %res = call fast float @llvm.vector.reduce.fmul.vnx4f32(float 3.0, <vscale x 4 x float> %vec)
  ret float %res
}

; The reduction does not have the reassoc fast-math flag, so a sequential traversal is needed.
define float @test_reduce_fmul_seq_expansion(<vscale x 4 x float> %vec) #0 {
; CHECK-LABEL: define float @test_reduce_fmul_seq_expansion(
; CHECK-SAME: <vscale x 4 x float> [[VEC:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[TMP2:%.*]] = mul i64 [[TMP1]], 4
; CHECK-NEXT:    br label %[[RDX_LOOP:.*]]
; CHECK:       [[RDX_LOOP]]:
; CHECK-NEXT:    [[ITER:%.*]] = phi i64 [ 0, [[TMP0:%.*]] ], [ [[ITER_NEXT:%.*]], %[[RDX_LOOP]] ]
; CHECK-NEXT:    [[RDX_PHI:%.*]] = phi float [ 3.000000e+00, [[TMP0]] ], [ [[RDX_FINAL:%.*]], %[[RDX_LOOP]] ]
; CHECK-NEXT:    [[ITER_NEXT]] = add nuw nsw i64 [[ITER]], 1
; CHECK-NEXT:    [[ELM:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i64 [[ITER]]
; CHECK-NEXT:    [[RDX_FINAL]] = fmul float [[RDX_PHI]], [[ELM]]
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[ITER_NEXT]], [[TMP2]]
; CHECK-NEXT:    br i1 [[EXITCOND]], [[DOTSPLIT:label %.*]], label %[[RDX_LOOP]]
; CHECK:       [[_SPLIT:.*:]]
; CHECK-NEXT:    ret float [[RDX_FINAL]]
;
  %res = call float @llvm.vector.reduce.fmul.vnx4f32(float 3.0, <vscale x 4 x float> %vec)
  ret float %res
}

; Similar to the first test, but for integers instead of floats,
; which makes a difference because there is no accumulator argument.
define i32 @test_reduce_int_mul_expansion(<vscale x 4 x i32> %vec) #0 {
; CHECK-LABEL: define i32 @test_reduce_int_mul_expansion(
; CHECK-SAME: <vscale x 4 x i32> [[VEC:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[TMP2:%.*]] = mul i64 [[TMP1]], 4
; CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cttz.i64(i64 [[TMP2]], i1 true)
; CHECK-NEXT:    br label %[[RDX_LOOP:.*]]
; CHECK:       [[RDX_LOOP]]:
; CHECK-NEXT:    [[ITER:%.*]] = phi i64 [ 0, [[TMP0:%.*]] ], [ [[ITER_NEXT:%.*]], %[[RDX_LOOP]] ]
; CHECK-NEXT:    [[RDX_PHI:%.*]] = phi <vscale x 4 x i32> [ [[VEC]], [[TMP0]] ], [ [[RDX:%.*]], %[[RDX_LOOP]] ]
; CHECK-NEXT:    [[ITER_NEXT]] = add nuw nsw i64 [[ITER]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = call <vscale x 8 x i32> @llvm.vector.insert.nxv8i32.nxv4i32(<vscale x 8 x i32> poison, <vscale x 4 x i32> [[RDX_PHI]], i64 0)
; CHECK-NEXT:    [[TMP5:%.*]] = call { <vscale x 4 x i32>, <vscale x 4 x i32> } @llvm.vector.deinterleave2.nxv8i32(<vscale x 8 x i32> [[TMP4]])
; CHECK-NEXT:    [[TMP6:%.*]] = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } [[TMP5]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { <vscale x 4 x i32>, <vscale x 4 x i32> } [[TMP5]], 1
; CHECK-NEXT:    [[RDX]] = mul <vscale x 4 x i32> [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[ITER_NEXT]], [[TMP3]]
; CHECK-NEXT:    br i1 [[EXITCOND]], [[DOTSPLIT:label %.*]], label %[[RDX_LOOP]]
; CHECK:       [[_SPLIT:.*:]]
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <vscale x 4 x i32> [[RDX]], i64 0
; CHECK-NEXT:    ret i32 [[TMP8]]
;
  %res = call i32 @llvm.vector.reduce.mul.vnx4i32(<vscale x 4 x i32> %vec)
  ret i32 %res
}

; This function has the attribute `vscale_range(2,2)`, which means that it can be
; expanded just like a reduction on a fixed-sized vector without any loop.
define float @test_fixed_vscale(<vscale x 4 x float> %vec) #1 {
; CHECK-LABEL: define float @test_fixed_vscale(
; CHECK-SAME: <vscale x 4 x float> [[VEC:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 0
; CHECK-NEXT:    [[BIN_RDX:%.*]] = fmul float 3.000000e+00, [[TMP1]]
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 1
; CHECK-NEXT:    [[BIN_RDX1:%.*]] = fmul float [[BIN_RDX]], [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 2
; CHECK-NEXT:    [[BIN_RDX2:%.*]] = fmul float [[BIN_RDX1]], [[TMP3]]
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 3
; CHECK-NEXT:    [[BIN_RDX3:%.*]] = fmul float [[BIN_RDX2]], [[TMP4]]
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 4
; CHECK-NEXT:    [[BIN_RDX4:%.*]] = fmul float [[BIN_RDX3]], [[TMP5]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 5
; CHECK-NEXT:    [[BIN_RDX5:%.*]] = fmul float [[BIN_RDX4]], [[TMP6]]
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 6
; CHECK-NEXT:    [[BIN_RDX6:%.*]] = fmul float [[BIN_RDX5]], [[TMP7]]
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <vscale x 4 x float> [[VEC]], i32 7
; CHECK-NEXT:    [[BIN_RDX15:%.*]] = fmul float [[BIN_RDX6]], [[TMP8]]
; CHECK-NEXT:    ret float [[BIN_RDX15]]
;
  %res = call float @llvm.vector.reduce.fmul.vnx4f32(float 3.0, <vscale x 4 x float> %vec)
  ret float %res
}

define float @test_fixed_vscale_log2_reduction(<vscale x 4 x float> %vec) #1 {
; CHECK-LABEL: define float @test_fixed_vscale_log2_reduction(
; CHECK-SAME: <vscale x 4 x float> [[VEC:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    [[TMP1:%.*]] = call fast <vscale x 8 x float> @llvm.vector.insert.nxv8f32.nxv4f32(<vscale x 8 x float> poison, <vscale x 4 x float> [[VEC]], i64 0)
; CHECK-NEXT:    [[TMP2:%.*]] = call fast { <vscale x 4 x float>, <vscale x 4 x float> } @llvm.vector.deinterleave2.nxv8f32(<vscale x 8 x float> [[TMP1]])
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP2]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP2]], 1
; CHECK-NEXT:    [[RDX:%.*]] = fmul fast <vscale x 4 x float> [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP5:%.*]] = call fast <vscale x 8 x float> @llvm.vector.insert.nxv8f32.nxv4f32(<vscale x 8 x float> poison, <vscale x 4 x float> [[RDX]], i64 0)
; CHECK-NEXT:    [[TMP6:%.*]] = call fast { <vscale x 4 x float>, <vscale x 4 x float> } @llvm.vector.deinterleave2.nxv8f32(<vscale x 8 x float> [[TMP5]])
; CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP6]], 0
; CHECK-NEXT:    [[TMP8:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP6]], 1
; CHECK-NEXT:    [[RDX1:%.*]] = fmul fast <vscale x 4 x float> [[TMP7]], [[TMP8]]
; CHECK-NEXT:    [[TMP9:%.*]] = call fast <vscale x 8 x float> @llvm.vector.insert.nxv8f32.nxv4f32(<vscale x 8 x float> poison, <vscale x 4 x float> [[RDX1]], i64 0)
; CHECK-NEXT:    [[TMP10:%.*]] = call fast { <vscale x 4 x float>, <vscale x 4 x float> } @llvm.vector.deinterleave2.nxv8f32(<vscale x 8 x float> [[TMP9]])
; CHECK-NEXT:    [[TMP11:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP10]], 0
; CHECK-NEXT:    [[TMP12:%.*]] = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } [[TMP10]], 1
; CHECK-NEXT:    [[RDX2:%.*]] = fmul fast <vscale x 4 x float> [[TMP11]], [[TMP12]]
; CHECK-NEXT:    [[TMP13:%.*]] = extractelement <vscale x 4 x float> [[RDX2]], i64 0
; CHECK-NEXT:    [[RDX_FINAL:%.*]] = fmul fast float 3.000000e+00, [[TMP13]]
; CHECK-NEXT:    ret float [[RDX_FINAL]]
;
  %res = call fast float @llvm.vector.reduce.fmul.vnx4f32(float 3.0, <vscale x 4 x float> %vec)
  ret float %res
}

attributes #0 = { vscale_range(1,16) "target-features"="+sve" }
attributes #1 = { vscale_range(2,2) "target-features"="+sve" }
