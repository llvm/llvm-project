; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=aarch64 -O0 -mattr=+sme < %s | FileCheck %s

target triple = "aarch64-linux-gnu"

; This test checks that with only +sme set with set up the base-pointer (x19) in
; functions with dynamic allocas and SVE stack objects.

define void @quux(i64 %n) "aarch64_new_za" "aarch64_pstate_sm_enabled" {
; CHECK-LABEL: quux:
; CHECK:       // %bb.0:
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    str x19, [sp, #16] // 8-byte Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    addvl sp, sp, #-1
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    .cfi_def_cfa w29, 32
; CHECK-NEXT:    .cfi_offset w19, -16
; CHECK-NEXT:    .cfi_offset w30, -24
; CHECK-NEXT:    .cfi_offset w29, -32
; CHECK-NEXT:    add x8, x0, #15
; CHECK-NEXT:    and x9, x8, #0xfffffffffffffff0
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    subs x8, x8, x9
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    // fake_use: $x8
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldr x19, [sp, #16] // 8-byte Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:    ret
  %zpr_local = alloca <vscale x 16 x i8>
  %dyn_alloc = alloca i8, i64 %n, align 1
  call void (...) @llvm.fake.use(ptr %dyn_alloc)
  call void (...) @llvm.fake.use(ptr %zpr_local)
  ret void
}
