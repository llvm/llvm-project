; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64-unknown-linux-gnu | FileCheck %s

; Test fp128 to bfloat16 conversion
; This test ensures that the compiler can handle fp128 to bf16 conversions
; without crashing (regression test for missing type legalization)

define void @fp128_to_bf16(ptr %src, ptr %dst) {
; CHECK-LABEL: fp128_to_bf16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    stp x30, x19, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    mov x19, x1
; CHECK-NEXT:    bl __trunctfsf2
; CHECK-NEXT:    fmov w9, s0
; CHECK-NEXT:    mov w8, #32767 // =0x7fff
; CHECK-NEXT:    ubfx w10, w9, #16, #1
; CHECK-NEXT:    add w8, w9, w8
; CHECK-NEXT:    add w8, w10, w8
; CHECK-NEXT:    lsr w8, w8, #16
; CHECK-NEXT:    fmov s0, w8
; CHECK-NEXT:    str h0, [x19]
; CHECK-NEXT:    ldp x30, x19, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    ret
  %val = load fp128, ptr %src, align 16
  %conv = fptrunc fp128 %val to bfloat
  store bfloat %conv, ptr %dst, align 2
  ret void
}

; Test with constant value
define bfloat @fp128_to_bf16_const() {
; CHECK-LABEL: fp128_to_bf16_const:
; CHECK:       // %bb.0:
; CHECK-NEXT:    adrp x8, .LCPI1_0
; CHECK-NEXT:    ldr h0, [x8, :lo12:.LCPI1_0]
; CHECK-NEXT:    ret
  %conv = fptrunc fp128 0xL00000000000000004000921FB54442D18 to bfloat ; 3.14159...
  ret bfloat %conv
}

; Test with vector (if supported)
define void @fp128_to_bf16_multiple(ptr %src1, ptr %src2, ptr %dst1, ptr %dst2) {
; CHECK-LABEL: fp128_to_bf16_multiple:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sub sp, sp, #64
; CHECK-NEXT:    str d8, [sp, #16] // 8-byte Spill
; CHECK-NEXT:    stp x30, x21, [sp, #32] // 16-byte Folded Spill
; CHECK-NEXT:    stp x20, x19, [sp, #48] // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 64
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w20, -16
; CHECK-NEXT:    .cfi_offset w21, -24
; CHECK-NEXT:    .cfi_offset w30, -32
; CHECK-NEXT:    .cfi_offset b8, -48
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ldr q1, [x1]
; CHECK-NEXT:    mov x19, x3
; CHECK-NEXT:    mov x20, x2
; CHECK-NEXT:    str q1, [sp] // 16-byte Spill
; CHECK-NEXT:    bl __trunctfsf2
; CHECK-NEXT:    fmov w8, s0
; CHECK-NEXT:    mov w21, #32767 // =0x7fff
; CHECK-NEXT:    ldr q0, [sp] // 16-byte Reload
; CHECK-NEXT:    ubfx w9, w8, #16, #1
; CHECK-NEXT:    add w8, w8, w21
; CHECK-NEXT:    add w8, w9, w8
; CHECK-NEXT:    lsr w8, w8, #16
; CHECK-NEXT:    fmov s8, w8
; CHECK-NEXT:    bl __trunctfsf2
; CHECK-NEXT:    fmov w8, s0
; CHECK-NEXT:    str h8, [x20]
; CHECK-NEXT:    ldr d8, [sp, #16] // 8-byte Reload
; CHECK-NEXT:    ubfx w9, w8, #16, #1
; CHECK-NEXT:    add w8, w8, w21
; CHECK-NEXT:    ldp x30, x21, [sp, #32] // 16-byte Folded Reload
; CHECK-NEXT:    add w8, w9, w8
; CHECK-NEXT:    lsr w8, w8, #16
; CHECK-NEXT:    fmov s0, w8
; CHECK-NEXT:    str h0, [x19]
; CHECK-NEXT:    ldp x20, x19, [sp, #48] // 16-byte Folded Reload
; CHECK-NEXT:    add sp, sp, #64
; CHECK-NEXT:    ret
  %val1 = load fp128, ptr %src1, align 16
  %val2 = load fp128, ptr %src2, align 16
  %conv1 = fptrunc fp128 %val1 to bfloat
  %conv2 = fptrunc fp128 %val2 to bfloat
  store bfloat %conv1, ptr %dst1, align 2
  store bfloat %conv2, ptr %dst2, align 2
  ret void
}
