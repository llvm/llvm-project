; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -callbrprepare -S -o - | FileCheck %s

define i32 @test0() {
; CHECK-LABEL: @test0(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OUT:%.*]] = callbr i32 asm "# $0", "=r,!i"()
; CHECK-NEXT:    to label [[DIRECT:%.*]] [label %entry.indirect_crit_edge]
; CHECK:       entry.indirect_crit_edge:
; CHECK-NEXT:    br label [[INDIRECT:%.*]]
; CHECK:       direct:
; CHECK-NEXT:    [[OUT2:%.*]] = callbr i32 asm "# $0", "=r,!i"()
; CHECK-NEXT:    to label [[DIRECT2:%.*]] [label %direct.indirect_crit_edge]
; CHECK:       direct.indirect_crit_edge:
; CHECK-NEXT:    br label [[INDIRECT]]
; CHECK:       direct2:
; CHECK-NEXT:    ret i32 0
; CHECK:       indirect:
; CHECK-NEXT:    [[OUT3:%.*]] = phi i32 [ [[OUT]], [[ENTRY_INDIRECT_CRIT_EDGE:%.*]] ], [ [[OUT2]], [[DIRECT_INDIRECT_CRIT_EDGE:%.*]] ]
; CHECK-NEXT:    ret i32 [[OUT3]]
;
entry:
  %out = callbr i32 asm "# $0", "=r,!i"()
  to label %direct [label %indirect]
direct:
  %out2 = callbr i32 asm "# $0", "=r,!i"()
  to label %direct2 [label %indirect]
direct2:
  ret i32 0
indirect:
  %out3 = phi i32 [%out, %entry], [%out2, %direct]
  ret i32 %out3
}

; Don't split edges unless they are critical, and callbr produces output, and
; that output is used.
; Here we have none of the above.
define i32 @dont_split0() {
; CHECK-LABEL: @dont_split0(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    callbr void asm "", "!i"()
; CHECK-NEXT:    to label [[X:%.*]] [label %y]
; CHECK:       x:
; CHECK-NEXT:    ret i32 42
; CHECK:       y:
; CHECK-NEXT:    ret i32 0
;
entry:
  callbr void asm "", "!i"()
  to label %x [label %y]

x:
  ret i32 42

y:
  ret i32 0
}

; Don't split edges unless they are critical, and callbr produces output, and
; that output is used.
; Here we have output, but no critical edge.
define i32 @dont_split1() {
; CHECK-LABEL: @dont_split1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = callbr i32 asm "", "=r,!i"()
; CHECK-NEXT:    to label [[X:%.*]] [label %y]
; CHECK:       x:
; CHECK-NEXT:    ret i32 42
; CHECK:       y:
; CHECK-NEXT:    ret i32 [[TMP0]]
;
entry:
  %0 = callbr i32 asm "", "=r,!i"()
  to label %x [label %y]

x:
  ret i32 42

y:
  ret i32 %0
}

; Don't split edges unless they are critical, and callbr produces output, and
; that output is used.
; Here we have a critical edge along an indirect branch, but no output.
define i32 @dont_split2() {
; CHECK-LABEL: @dont_split2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    callbr void asm "", "!i"()
; CHECK-NEXT:    to label [[X:%.*]] [label %y]
; CHECK:       x:
; CHECK-NEXT:    br label [[Y:%.*]]
; CHECK:       y:
; CHECK-NEXT:    [[TMP0:%.*]] = phi i32 [ 0, [[X]] ], [ 42, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[TMP0]]
;
entry:
  callbr void asm "", "!i"()
  to label %x [label %y]

x:
  br label %y

y:
  %0 = phi i32 [ 0, %x ], [ 42, %entry ]
  ret i32 %0
}

; Don't split edges unless they are critical, and callbr produces output, and
; that output is used.
; Here we're missing a use.
define i32 @dont_split3() {
; CHECK-LABEL: @dont_split3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = callbr i32 asm "", "=r,!i"()
; CHECK-NEXT:    to label [[X:%.*]] [label %v]
; CHECK:       x:
; CHECK-NEXT:    br label [[V:%.*]]
; CHECK:       v:
; CHECK-NEXT:    ret i32 42
;
entry:
  %0 = callbr i32 asm "", "=r,!i"() to label %x [label %v]

x:
  br label %v

v:
  ret i32 42
}

; Don't split edges unless they are critical, and callbr produces output, and
; that output is used.
; Here we have output and a critical edge along an indirect branch.
define i32 @split_me0() {
; CHECK-LABEL: @split_me0(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = callbr i32 asm "", "=r,!i"()
; CHECK-NEXT:    to label [[X:%.*]] [label %entry.y_crit_edge]
; CHECK:       entry.y_crit_edge:
; CHECK-NEXT:    br label [[Y:%.*]]
; CHECK:       x:
; CHECK-NEXT:    br label [[Y]]
; CHECK:       y:
; CHECK-NEXT:    [[TMP1:%.*]] = phi i32 [ [[TMP0]], [[ENTRY_Y_CRIT_EDGE:%.*]] ], [ 42, [[X]] ]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
entry:
  %0 = callbr i32 asm "", "=r,!i"()
  to label %x [label %y]

x:
  br label %y

y:
  %1 = phi i32 [ %0, %entry ], [ 42, %x ]
  ret i32 %1
}

; Here we have output and a critical edge along an indirect branch.
; Ensure that if we repeat the indirect destination, that we only split it
; once.
define i32 @split_me1(i1 %z) {
; CHECK-LABEL: @split_me1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[Z:%.*]], label [[W:%.*]], label [[V:%.*]]
; CHECK:       w:
; CHECK-NEXT:    [[TMP0:%.*]] = callbr i32 asm "", "=r,!i,!i"()
; CHECK-NEXT:    to label [[X:%.*]] [label [[W_V_CRIT_EDGE:%.*]], label %w.v_crit_edge]
; CHECK:       w.v_crit_edge:
; CHECK-NEXT:    br label [[V]]
; CHECK:       x:
; CHECK-NEXT:    ret i32 42
; CHECK:       v:
; CHECK-NEXT:    [[TMP1:%.*]] = phi i32 [ [[TMP0]], [[W_V_CRIT_EDGE]] ], [ undef, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
entry:
  br i1 %z, label %w, label %v

w:
  %0 = callbr i32 asm "", "=r,!i,!i"()
  to label %x [label %v, label %v]

x:
  ret i32 42

v:
  %1 = phi i32 [%0, %w], [%0, %w], [undef, %entry]
  ret i32 %1
}

; A more interessting case of @split_me1. Check that we still only split the
; critical edge from w to v once.
define i32 @split_me2(i1 %z) {
; CHECK-LABEL: @split_me2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[Z:%.*]], label [[W:%.*]], label [[V:%.*]]
; CHECK:       w:
; CHECK-NEXT:    [[TMP0:%.*]] = callbr i32 asm "", "=r,!i,!i"()
; CHECK-NEXT:    to label [[X:%.*]] [label [[W_V_CRIT_EDGE:%.*]], label %w.v_crit_edge]
; CHECK:       w.v_crit_edge:
; CHECK-NEXT:    br label [[V]]
; CHECK:       x:
; CHECK-NEXT:    ret i32 42
; CHECK:       v:
; CHECK-NEXT:    [[TMP1:%.*]] = phi i32 [ [[TMP0]], [[W_V_CRIT_EDGE]] ], [ 42, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[TMP1]]
;
entry:
  br i1 %z, label %w, label %v

w:
  %0 = callbr i32 asm "", "=r,!i,!i"()
  to label %x [label %v, label %v]

x:
  ret i32 42

v:
  %1 = phi i32 [ %0, %w ], [ 42, %entry ], [ %0, %w ]
  ret i32 %1
}
