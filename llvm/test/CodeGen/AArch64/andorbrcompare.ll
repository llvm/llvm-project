; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-none-elf -verify-machineinstrs %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -mtriple=aarch64-none-elf -global-isel -verify-machineinstrs %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-GI

declare void @dummy()

define i32 @and_eq_ne_ult(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_eq_ne_ult:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #0, ne
; CHECK-SD-NEXT:    b.eq .LBB0_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.lo .LBB0_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB0_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_eq_ne_ult:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, eq
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, ne
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB0_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.lo .LBB0_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB0_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp eq i32 %s0, %s1
  %c1 = icmp ne i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp ult i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}

define i32 @and_ne_ult_ule(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_ne_ult_ule:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #4, lo
; CHECK-SD-NEXT:    b.ne .LBB1_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.ls .LBB1_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB1_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_ne_ult_ule:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, ne
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, lo
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB1_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.ls .LBB1_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB1_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp ne i32 %s0, %s1
  %c1 = icmp ult i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp ule i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}

define i32 @and_ult_ule_ugt(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_ult_ule_ugt:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #2, ls
; CHECK-SD-NEXT:    b.lo .LBB2_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.hi .LBB2_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB2_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_ult_ule_ugt:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, lo
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, ls
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB2_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.hi .LBB2_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB2_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp ult i32 %s0, %s1
  %c1 = icmp ule i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp ugt i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}

define i32 @and_ule_ugt_uge(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_ule_ugt_uge:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #2, hi
; CHECK-SD-NEXT:    b.ls .LBB3_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.hs .LBB3_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB3_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_ule_ugt_uge:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, ls
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, hi
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB3_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.hs .LBB3_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB3_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp ule i32 %s0, %s1
  %c1 = icmp ugt i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp uge i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}

define i32 @and_ugt_uge_slt(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_ugt_uge_slt:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #0, hs
; CHECK-SD-NEXT:    b.hi .LBB4_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.lt .LBB4_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB4_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_ugt_uge_slt:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, hi
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, hs
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB4_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.lt .LBB4_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB4_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp ugt i32 %s0, %s1
  %c1 = icmp uge i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp slt i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}

define i32 @and_uge_slt_sle(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_uge_slt_sle:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #0, lt
; CHECK-SD-NEXT:    b.hs .LBB5_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.le .LBB5_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB5_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_uge_slt_sle:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, hs
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, lt
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB5_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.le .LBB5_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB5_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp uge i32 %s0, %s1
  %c1 = icmp slt i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp sle i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}

define i32 @and_slt_sle_sgt(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_slt_sle_sgt:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #0, le
; CHECK-SD-NEXT:    b.lt .LBB6_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.gt .LBB6_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB6_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_slt_sle_sgt:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, lt
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, le
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB6_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.gt .LBB6_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB6_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp slt i32 %s0, %s1
  %c1 = icmp sle i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp sgt i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}

define i32 @and_sle_sgt_sge(i32 %s0, i32 %s1, i32 %s2, i32 %s3, i32 %s4, i32 %s5, ptr %p) {
; CHECK-SD-LABEL: and_sle_sgt_sge:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w2, w3
; CHECK-SD-NEXT:    ccmp w0, w1, #0, gt
; CHECK-SD-NEXT:    b.le .LBB7_3
; CHECK-SD-NEXT:  // %bb.1: // %entry
; CHECK-SD-NEXT:    cmp w4, w5
; CHECK-SD-NEXT:    b.ge .LBB7_3
; CHECK-SD-NEXT:  // %bb.2:
; CHECK-SD-NEXT:    mov w0, wzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB7_3: // %if
; CHECK-SD-NEXT:    mov w0, #1 // =0x1
; CHECK-SD-NEXT:    str w0, [x6]
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: and_sle_sgt_sge:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, le
; CHECK-GI-NEXT:    cmp w2, w3
; CHECK-GI-NEXT:    cset w9, gt
; CHECK-GI-NEXT:    and w8, w8, w9
; CHECK-GI-NEXT:    tbnz w8, #0, .LBB7_3
; CHECK-GI-NEXT:  // %bb.1: // %entry
; CHECK-GI-NEXT:    cmp w4, w5
; CHECK-GI-NEXT:    mov w0, wzr
; CHECK-GI-NEXT:    b.ge .LBB7_3
; CHECK-GI-NEXT:  // %bb.2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB7_3: // %if
; CHECK-GI-NEXT:    mov w0, #1 // =0x1
; CHECK-GI-NEXT:    str w0, [x6]
; CHECK-GI-NEXT:    ret
entry:
  %c0 = icmp sle i32 %s0, %s1
  %c1 = icmp sgt i32 %s2, %s3
  %a = and i1 %c0, %c1
  %c2 = icmp sge i32 %s4, %s5
  %o = or i1 %a, %c2
  br i1 %o, label %if, label %else

if:
  store i32 1, ptr %p
  ret i32 1

else:
  ret i32 0
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
