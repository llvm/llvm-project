; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -mtriple=aarch64-gnu-linux < %s | FileCheck -check-prefixes=CHECK %s

define { <2 x half>, <2 x i32> } @test_frexp_v2f16_v2i32(<2 x half> %a) {
; CHECK-LABEL: test_frexp_v2f16_v2i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sub sp, sp, #64
; CHECK-NEXT:    stp x30, x19, [sp, #48] // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 64
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    // kill: def $d0 killed $d0 def $q0
; CHECK-NEXT:    mov h1, v0.h[1]
; CHECK-NEXT:    str q0, [sp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    add x0, sp, #36
; CHECK-NEXT:    add x19, sp, #36
; CHECK-NEXT:    fcvt s0, h1
; CHECK-NEXT:    bl frexpf
; CHECK-NEXT:    ldr q1, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    fcvt h0, s0
; CHECK-NEXT:    add x0, sp, #32
; CHECK-NEXT:    fcvt s1, h1
; CHECK-NEXT:    str q0, [sp] // 16-byte Folded Spill
; CHECK-NEXT:    fmov s0, s1
; CHECK-NEXT:    bl frexpf
; CHECK-NEXT:    ldr q1, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    fcvt h2, s0
; CHECK-NEXT:    add x0, sp, #40
; CHECK-NEXT:    mov h1, v1.h[2]
; CHECK-NEXT:    fcvt s0, h1
; CHECK-NEXT:    ldr q1, [sp] // 16-byte Folded Reload
; CHECK-NEXT:    mov v2.h[1], v1.h[0]
; CHECK-NEXT:    str q2, [sp] // 16-byte Folded Spill
; CHECK-NEXT:    bl frexpf
; CHECK-NEXT:    ldr q1, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    fcvt h2, s0
; CHECK-NEXT:    add x0, sp, #44
; CHECK-NEXT:    mov h1, v1.h[3]
; CHECK-NEXT:    fcvt s0, h1
; CHECK-NEXT:    ldr q1, [sp] // 16-byte Folded Reload
; CHECK-NEXT:    mov v1.h[2], v2.h[0]
; CHECK-NEXT:    str q1, [sp] // 16-byte Folded Spill
; CHECK-NEXT:    bl frexpf
; CHECK-NEXT:    fcvt h2, s0
; CHECK-NEXT:    ldr s1, [sp, #32]
; CHECK-NEXT:    ldr q0, [sp] // 16-byte Folded Reload
; CHECK-NEXT:    ld1 { v1.s }[1], [x19]
; CHECK-NEXT:    ldp x30, x19, [sp, #48] // 16-byte Folded Reload
; CHECK-NEXT:    // kill: def $d1 killed $d1 killed $q1
; CHECK-NEXT:    mov v0.h[3], v2.h[0]
; CHECK-NEXT:    // kill: def $d0 killed $d0 killed $q0
; CHECK-NEXT:    add sp, sp, #64
; CHECK-NEXT:    ret
  %result = call { <2 x half>, <2 x i32> } @llvm.frexp.v2f16.v2i32(<2 x half> %a)
  ret { <2 x half>, <2 x i32> } %result
}

define { <3 x float>, <3 x i32> } @test_frexp_v3f16_v3i32(<3 x float> %a) {
; CHECK-LABEL: test_frexp_v3f16_v3i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    sub sp, sp, #80
; CHECK-NEXT:    str x30, [sp, #48] // 8-byte Folded Spill
; CHECK-NEXT:    stp x20, x19, [sp, #64] // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 80
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w20, -16
; CHECK-NEXT:    .cfi_offset w30, -32
; CHECK-NEXT:    str q0, [sp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    mov s0, v0.s[1]
; CHECK-NEXT:    add x0, sp, #56
; CHECK-NEXT:    add x19, sp, #56
; CHECK-NEXT:    bl frexpf
; CHECK-NEXT:    // kill: def $s0 killed $s0 def $q0
; CHECK-NEXT:    str q0, [sp] // 16-byte Folded Spill
; CHECK-NEXT:    add x0, sp, #44
; CHECK-NEXT:    ldr q0, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    // kill: def $s0 killed $s0 killed $q0
; CHECK-NEXT:    bl frexpf
; CHECK-NEXT:    ldr q1, [sp] // 16-byte Folded Reload
; CHECK-NEXT:    // kill: def $s0 killed $s0 def $q0
; CHECK-NEXT:    add x0, sp, #60
; CHECK-NEXT:    add x20, sp, #60
; CHECK-NEXT:    mov v0.s[1], v1.s[0]
; CHECK-NEXT:    str q0, [sp] // 16-byte Folded Spill
; CHECK-NEXT:    ldr q0, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    mov s0, v0.s[2]
; CHECK-NEXT:    bl frexpf
; CHECK-NEXT:    ldr s1, [sp, #44]
; CHECK-NEXT:    ldr q2, [sp] // 16-byte Folded Reload
; CHECK-NEXT:    // kill: def $s0 killed $s0 def $q0
; CHECK-NEXT:    ldr x30, [sp, #48] // 8-byte Folded Reload
; CHECK-NEXT:    ld1 { v1.s }[1], [x19]
; CHECK-NEXT:    mov v2.s[2], v0.s[0]
; CHECK-NEXT:    ld1 { v1.s }[2], [x20]
; CHECK-NEXT:    ldp x20, x19, [sp, #64] // 16-byte Folded Reload
; CHECK-NEXT:    mov v0.16b, v2.16b
; CHECK-NEXT:    add sp, sp, #80
; CHECK-NEXT:    ret
  %result = call { <3 x float>, <3 x i32> } @llvm.frexp.v3float.v3i32(<3 x float> %a)
  ret { <3 x float>, <3 x i32> } %result
}
