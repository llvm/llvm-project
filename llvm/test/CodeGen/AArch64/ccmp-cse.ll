; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=aarch64-unknown-unknown | FileCheck %s

define i64 @test_single_or(i64 %unrelated, i64 %x, i64 %y) nounwind {
; CHECK-LABEL: test_single_or:
; CHECK:       // %bb.0:
; CHECK-NEXT:    subs x8, x2, x1
; CHECK-NEXT:    cset w9, lo
; CHECK-NEXT:    cmp x2, x0
; CHECK-NEXT:    csinc w9, w9, wzr, ls
; CHECK-NEXT:    cmp w9, #0
; CHECK-NEXT:    csel x0, xzr, x8, ne
; CHECK-NEXT:    ret
  %cmp.match = icmp ult i64 %y, %x
  %cmp.nomatch = icmp ugt i64 %y, %unrelated
  %or.cond = or i1 %cmp.match, %cmp.nomatch
  %sub.reuse = sub nuw i64 %y, %x
  %res = select i1 %or.cond, i64 0, i64 %sub.reuse
  ret i64 %res
}

define i64 @test_two_ors(i64 %unrelated, i64 %x, i64 %y) nounwind {
; CHECK-LABEL: test_two_ors:
; CHECK:       // %bb.0:
; CHECK-NEXT:    subs x8, x2, x1
; CHECK-NEXT:    cset w9, lo
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    ccmp x2, x0, #2, hs
; CHECK-NEXT:    csinc w9, w9, wzr, ls
; CHECK-NEXT:    cmp w9, #0
; CHECK-NEXT:    csel x0, xzr, x8, ne
; CHECK-NEXT:    ret
  %cmp.match = icmp ult i64 %y, %x
  %cmp.nomatch1 = icmp ult i64 %unrelated, %x
  %cmp.nomatch2 = icmp ugt i64 %y, %unrelated
  %or.nomatch = or i1 %cmp.nomatch1, %cmp.nomatch2
  %or.cond = or i1 %cmp.match, %or.nomatch
  %sub.reuse = sub nuw i64 %y, %x
  %res = select i1 %or.cond, i64 0, i64 %sub.reuse
  ret i64 %res
}

define i64 @test_two_ors_commuted(i64 %unrelated, i64 %x, i64 %y) nounwind {
; CHECK-LABEL: test_two_ors_commuted:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    ccmp x2, x0, #2, hs
; CHECK-NEXT:    cset w8, hi
; CHECK-NEXT:    subs x9, x2, x1
; CHECK-NEXT:    csinc w8, w8, wzr, hs
; CHECK-NEXT:    cmp w8, #0
; CHECK-NEXT:    csel x0, xzr, x9, ne
; CHECK-NEXT:    ret
  %cmp.match = icmp ult i64 %y, %x
  %cmp.nomatch1 = icmp ult i64 %unrelated, %x
  %cmp.nomatch2 = icmp ugt i64 %y, %unrelated
  %or.nomatch = or i1 %cmp.nomatch1, %cmp.nomatch2
  %or.cond = or i1 %or.nomatch, %cmp.match
  %sub.reuse = sub nuw i64 %y, %x
  %res = select i1 %or.cond, i64 0, i64 %sub.reuse
  ret i64 %res
}

define i64 @test_single_and(i64 %unrelated, i64 %x, i64 %y) nounwind {
; CHECK-LABEL: test_single_and:
; CHECK:       // %bb.0:
; CHECK-NEXT:    subs x8, x2, x1
; CHECK-NEXT:    cset w9, lo
; CHECK-NEXT:    cmp x2, x0
; CHECK-NEXT:    cset w10, hi
; CHECK-NEXT:    tst w9, w10
; CHECK-NEXT:    csel x0, xzr, x8, ne
; CHECK-NEXT:    ret
  %cmp.match = icmp ult i64 %y, %x
  %cmp.nomatch = icmp ugt i64 %y, %unrelated
  %and.cond = and i1 %cmp.match, %cmp.nomatch
  %sub.reuse = sub nuw i64 %y, %x
  %res = select i1 %and.cond, i64 0, i64 %sub.reuse
  ret i64 %res
}

define i64 @test_single_or_sub_commuted(i64 %unrelated, i64 %x, i64 %y) nounwind {
; CHECK-LABEL: test_single_or_sub_commuted:
; CHECK:       // %bb.0:
; CHECK-NEXT:    subs x8, x1, x2
; CHECK-NEXT:    ccmp x2, x0, #2, ls
; CHECK-NEXT:    csel x0, xzr, x8, hi
; CHECK-NEXT:    ret
  %cmp.match = icmp ult i64 %y, %x
  %cmp.nomatch = icmp ugt i64 %y, %unrelated
  %or.cond = or i1 %cmp.match, %cmp.nomatch
  %sub.reuse = sub nuw i64 %x, %y
  %res = select i1 %or.cond, i64 0, i64 %sub.reuse
  ret i64 %res
}

; Negative test: We must negate the or operation, hence this must come first.
define i64 @test_mustbefirst_overrides_preferfirst_negative(i64 %unrelated, i64 %x, i64 %y) nounwind {
; CHECK-LABEL: test_mustbefirst_overrides_preferfirst_negative:
; CHECK:       // %bb.0:
; CHECK-NEXT:    subs x8, x2, x1
; CHECK-NEXT:    cset w9, lo
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    ccmp x2, x0, #2, hs
; CHECK-NEXT:    cset w10, hi
; CHECK-NEXT:    tst w10, w9
; CHECK-NEXT:    csel x0, xzr, x8, ne
; CHECK-NEXT:    ret
  %cmp.match = icmp ult i64 %y, %x
  %cmp.nomatch1 = icmp ult i64 %unrelated, %x
  %cmp.nomatch2 = icmp ugt i64 %y, %unrelated
  %or.nomatch = or i1 %cmp.nomatch1, %cmp.nomatch2
  %and.cond = and i1 %or.nomatch, %cmp.match
  %sub.reuse = sub nuw i64 %y, %x
  %res = select i1 %and.cond, i64 0, i64 %sub.reuse
  ret i64 %res
}

; Negative test: There is no analogue of SUBS for floating point.
define float @test_negative_float(float %unrelated, float %x, float %y) nounwind {
; CHECK-LABEL: test_negative_float:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fcmp s2, s0
; CHECK-NEXT:    fsub s0, s2, s1
; CHECK-NEXT:    movi d3, #0000000000000000
; CHECK-NEXT:    fccmp s2, s1, #8, le
; CHECK-NEXT:    fcsel s0, s3, s0, mi
; CHECK-NEXT:    ret
  %cmp.nomatch1 = fcmp olt float %y, %x
  %cmp.nomatch2 = fcmp ogt float %y, %unrelated
  %or.cond = or i1 %cmp.nomatch1, %cmp.nomatch2
  %sub.noreuse = fsub float %y, %x
  %res = select i1 %or.cond, float 0.0, float %sub.noreuse
  ret float %res
}

; Negative test: If both operands match a sub, do not reorder them.
define i64 @test_prefer_right_negative(i64 %x, i64 %y, i64 %z) nounwind {
; CHECK-LABEL: test_prefer_right_negative:
; CHECK:       // %bb.0:
; CHECK-NEXT:    subs x8, x2, x1
; CHECK-NEXT:    cset w9, lo
; CHECK-NEXT:    subs x10, x2, x0
; CHECK-NEXT:    csinc w9, w9, wzr, ls
; CHECK-NEXT:    cmp w9, #0
; CHECK-NEXT:    csel x0, x10, x8, ne
; CHECK-NEXT:    ret
  %cmp.match1 = icmp ult i64 %z, %y
  %cmp.match2 = icmp ugt i64 %z, %x
  %or.cond = or i1 %cmp.match1, %cmp.match2
  %sub.reuse1 = sub nuw i64 %z, %y
  %sub.reuse2 = sub nuw i64 %z, %x
  %res = select i1 %or.cond, i64 %sub.reuse2, i64 %sub.reuse1
  ret i64 %res
}
