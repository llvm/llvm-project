; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --filter "(bl|ptrue)" --version 5
; RUN: llc -mtriple=aarch64-gnu-linux -mattr=+neon,+sve -vector-library=sleefgnuabi < %s | FileCheck %s -check-prefix=SLEEF
; RUN: llc -mtriple=aarch64-gnu-linux -mattr=+neon,+sve -vector-library=ArmPL < %s | FileCheck %s -check-prefix=ARMPL

define <4 x float> @test_modf_v4f32(<4 x float> %x, ptr %out_integral) {
; SLEEF-LABEL: test_modf_v4f32:
; SLEEF:    bl _ZGVnN4vl4_modff
;
; ARMPL-LABEL: test_modf_v4f32:
; ARMPL:    bl armpl_vmodfq_f32
  %result = call { <4 x float>, <4 x float> } @llvm.modf.v4f32(<4 x float> %x)
  %result.0 = extractvalue { <4 x float>, <4 x float> } %result, 0
  %result.1 = extractvalue { <4 x float>, <4 x float> } %result, 1
  store <4 x float> %result.1, ptr %out_integral, align 4
  ret <4 x float> %result.0
}

define <2 x double> @test_modf_v2f64(<2 x double> %x, ptr %out_integral) {
; SLEEF-LABEL: test_modf_v2f64:
; SLEEF:    bl _ZGVnN2vl8_modf
;
; ARMPL-LABEL: test_modf_v2f64:
; ARMPL:    bl armpl_vmodfq_f64
  %result = call { <2 x double>, <2 x double> } @llvm.modf.v2f64(<2 x double> %x)
  %result.0 = extractvalue { <2 x double>, <2 x double> } %result, 0
  %result.1 = extractvalue { <2 x double>, <2 x double> } %result, 1
  store <2 x double> %result.1, ptr %out_integral, align 8
  ret <2 x double> %result.0
}

define <vscale x 4 x float> @test_modf_nxv4f32(<vscale x 4 x float> %x, ptr %out_integral) {
; SLEEF-LABEL: test_modf_nxv4f32:
; SLEEF:    bl _ZGVsNxvl4_modff
;
; ARMPL-LABEL: test_modf_nxv4f32:
; ARMPL:    ptrue p0.s
; ARMPL:    bl armpl_svmodf_f32_x
  %result = call { <vscale x 4 x float>, <vscale x 4 x float> } @llvm.modf.nxv4f32(<vscale x 4 x float> %x)
  %result.0 = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } %result, 0
  %result.1 = extractvalue { <vscale x 4 x float>, <vscale x 4 x float> } %result, 1
  store <vscale x 4 x float> %result.1, ptr %out_integral, align 4
  ret <vscale x 4 x float> %result.0
}

define <vscale x 2 x double> @test_modf_nxv2f64(<vscale x 2 x double> %x, ptr %out_integral) {
; SLEEF-LABEL: test_modf_nxv2f64:
; SLEEF:    bl _ZGVsNxvl8_modf
;
; ARMPL-LABEL: test_modf_nxv2f64:
; ARMPL:    ptrue p0.d
; ARMPL:    bl armpl_svmodf_f64_x
  %result = call { <vscale x 2 x double>, <vscale x 2 x double> } @llvm.modf.nxv2f64(<vscale x 2 x double> %x)
  %result.0 = extractvalue { <vscale x 2 x double>, <vscale x 2 x double> } %result, 0
  %result.1 = extractvalue { <vscale x 2 x double>, <vscale x 2 x double> } %result, 1
  store <vscale x 2 x double> %result.1, ptr %out_integral, align 8
  ret <vscale x 2 x double> %result.0
}
