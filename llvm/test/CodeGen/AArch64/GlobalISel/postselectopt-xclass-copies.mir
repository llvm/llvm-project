# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple aarch64 -run-pass=aarch64-post-select-optimize -verify-machineinstrs %s -o - | FileCheck %s
--- |
  target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"

  @x = external hidden local_unnamed_addr global i32*, align 8
  define void @copy_from_larger_rc_def() { ret void }
  define void @copy_from_larger_rc_def_multi_use() { ret void }
  define void @copy_from_smaller_rc_def() { ret void }

...
---
name:            copy_from_larger_rc_def
alignment:       4
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
liveins:
  - { reg: '$x0' }
  - { reg: '$w1' }
  - { reg: '$x2' }
body:             |
  bb.1:
    liveins: $w1, $x0, $x2

    ; Show that if we're doing a copy from a large rc to a single user with a smaller rc
    ; then we just constrain the def instead.
    ; CHECK-LABEL: name: copy_from_larger_rc_def
    ; CHECK: liveins: $w1, $x0, $x2
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gpr64 = COPY $x0
    ; CHECK-NEXT: %large_rc_def:gpr64common = UBFMXri [[COPY]], 61, 60
    ; CHECK-NEXT: %add:gpr64sp = ADDXri %large_rc_def, 3, 0
    ; CHECK-NEXT: $x0 = COPY %add
    ; CHECK-NEXT: RET_ReallyLR
    %0:gpr64 = COPY $x0
    %large_rc_def:gpr64 = UBFMXri %0, 61, 60
    %constrain_copy:gpr64common = COPY %large_rc_def
    ; Even though ADDXri may not actually need to use gpr64common, just use it as an example.
    %add:gpr64sp = ADDXri %constrain_copy, 3, 0
    $x0 = COPY %add
    RET_ReallyLR

...
---
name:            copy_from_larger_rc_def_multi_use
alignment:       4
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
liveins:
  - { reg: '$x0' }
  - { reg: '$w1' }
  - { reg: '$x2' }
body:             |
  bb.1:
    liveins: $w1, $x0, $x2

    ; Don't constrain def if the original def has multiple users.
    ; CHECK-LABEL: name: copy_from_larger_rc_def_multi_use
    ; CHECK: liveins: $w1, $x0, $x2
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gpr64 = COPY $x0
    ; CHECK-NEXT: %large_rc_def:gpr64 = UBFMXri [[COPY]], 61, 60
    ; CHECK-NEXT: %constrain_copy:gpr64common = COPY %large_rc_def
    ; CHECK-NEXT: %add:gpr64sp = ADDXri %constrain_copy, 3, 0
    ; CHECK-NEXT: %add2:gpr64sp = ADDXri %constrain_copy, 3, 0
    ; CHECK-NEXT: $x0 = COPY %add
    ; CHECK-NEXT: $x1 = COPY %large_rc_def
    ; CHECK-NEXT: RET_ReallyLR
    %0:gpr64 = COPY $x0
    %large_rc_def:gpr64 = UBFMXri %0, 61, 60
    %constrain_copy:gpr64common = COPY %large_rc_def
    %add:gpr64sp = ADDXri %constrain_copy, 3, 0
    %add2:gpr64sp = ADDXri %constrain_copy, 3, 0
    $x0 = COPY %add
    $x1 = COPY %large_rc_def
    RET_ReallyLR

...
---
name:            copy_from_smaller_rc_def
alignment:       4
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
liveins:
  - { reg: '$x0' }
  - { reg: '$w1' }
  - { reg: '$x2' }
body:             |
  bb.1:
    liveins: $w1, $x0, $x2

    ; Show that if we're doing a copy from a small rc to a single user with a larger rc
    ; then we just use the smaller def instead of doing a copy.
    ; CHECK-LABEL: name: copy_from_smaller_rc_def
    ; CHECK: liveins: $w1, $x0, $x2
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:gpr64common = COPY $x0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:gpr64common = COPY $x1
    ; CHECK-NEXT: %add:gpr64common = ADDXri [[COPY1]], 3, 0
    ; CHECK-NEXT: STRXui [[COPY1]], %add, target-flags(aarch64-pageoff, aarch64-nc) @x :: (store (p0))
    ; CHECK-NEXT: RET_ReallyLR
    %0:gpr64common = COPY $x0
    %1:gpr64common = COPY $x1

    %add:gpr64common = ADDXri %1, 3, 0
    %copy:gpr64sp = COPY %add
    STRXui %1, %copy, target-flags(aarch64-pageoff, aarch64-nc) @x :: (store (p0))
    RET_ReallyLR

...
