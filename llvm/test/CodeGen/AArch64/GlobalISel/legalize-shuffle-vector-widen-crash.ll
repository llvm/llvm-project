; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -global-isel -o - %s | FileCheck %s
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "arm64-apple-macosx11.0.0"

declare i32 @llvm.aarch64.neon.uaddv.i32.v4i32(<4 x i32>) #0

define i32 @bar() {
; CHECK-LABEL: bar:
; CHECK:       ; %bb.0: ; %bb
; CHECK-NEXT:    movi.2d v0, #0000000000000000
; CHECK-NEXT:    mov b1, v0[1]
; CHECK-NEXT:    mov b2, v0[3]
; CHECK-NEXT:    mov b3, v0[2]
; CHECK-NEXT:    fmov w8, s1
; CHECK-NEXT:    fmov w9, s2
; CHECK-NEXT:    mov.h v0[1], w8
; CHECK-NEXT:    mov.h v3[1], w9
; CHECK-NEXT:    ushll.4s v0, v0, #0
; CHECK-NEXT:    ushll.4s v1, v3, #0
; CHECK-NEXT:    mov.d v0[1], v1[0]
; CHECK-NEXT:    movi.4s v1, #1
; CHECK-NEXT:    and.16b v0, v0, v1
; CHECK-NEXT:    addv.4s s0, v0
; CHECK-NEXT:    fmov w0, s0
; CHECK-NEXT:    ret
bb:
  %shufflevector = shufflevector <8 x i1> zeroinitializer, <8 x i1> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %zext = zext <4 x i1> %shufflevector to <4 x i32>
  %call = call i32 @llvm.aarch64.neon.uaddv.i32.v4i32(<4 x i32> %zext)
  %icmp = icmp eq i32 %call, 0
  br i1 %icmp, label %bb1, label %bb2

bb1:                                              ; preds = %bb2, %bb
  ret i32 %call

bb2:                                              ; preds = %bb
  %sext = sext i32 0 to i64
  br label %bb1
}

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(none) }
