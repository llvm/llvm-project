# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=arm64-unknown-unknown -global-isel -global-isel-abort=1 -O0 -run-pass=legalizer %s -o - | FileCheck %s
--- |
  target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
  target triple = "aarch64"

  define i8* @test_simple_alloca(i32 %numelts) {
    %addr = alloca i8, i32 %numelts
    ret i8* %addr
  }

  define i8* @test_aligned_alloca(i32 %numelts) {
    %addr = alloca i8, i32 %numelts, align 32
    ret i8* %addr
  }

  define i128* @test_natural_alloca(i32 %numelts) {
    %addr = alloca i128, i32 %numelts
    ret i128* %addr
  }

  define i8* @test_simple_alloca_stack_probing(i32 %numelts) "probe-stack"="inline-asm" {
    %addr = alloca i8, i32 %numelts
    ret i8* %addr
  }

  define i8* @test_aligned_alloca_stack_probing(i32 %numelts) "probe-stack"="inline-asm" {
    %addr = alloca i8, i32 %numelts, align 32
    ret i8* %addr
  }

  define i128* @test_natural_alloca_stack_probing(i32 %numelts) "probe-stack"="inline-asm" {
    %addr = alloca i128, i32 %numelts
    ret i128* %addr
  }

...
---
name:            test_simple_alloca
alignment:       4
tracksRegLiveness: true
liveins:
  - { reg: '$w0' }
frameInfo:
  maxAlignment:    1
stack:
  - { id: 0, name: addr, type: variable-sized, alignment: 1 }
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $w0

    ; CHECK-LABEL: name: test_simple_alloca
    ; CHECK: liveins: $w0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(s32) = COPY $w0
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 1
    ; CHECK-NEXT: [[ZEXT:%[0-9]+]]:_(s64) = G_ZEXT [[COPY]](s32)
    ; CHECK-NEXT: [[MUL:%[0-9]+]]:_(s64) = G_MUL [[ZEXT]], [[C]]
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 15
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s64) = nuw G_ADD [[MUL]], [[C1]]
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s64) = G_CONSTANT i64 -16
    ; CHECK-NEXT: [[AND:%[0-9]+]]:_(s64) = G_AND [[ADD]], [[C2]]
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
    ; CHECK-NEXT: [[PTRTOINT:%[0-9]+]]:_(s64) = G_PTRTOINT [[COPY1]](p0)
    ; CHECK-NEXT: [[SUB:%[0-9]+]]:_(s64) = G_SUB [[PTRTOINT]], [[AND]]
    ; CHECK-NEXT: [[INTTOPTR:%[0-9]+]]:_(p0) = G_INTTOPTR [[SUB]](s64)
    ; CHECK-NEXT: $sp = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(p0) = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: $x0 = COPY [[COPY2]](p0)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %0:_(s32) = COPY $w0
    %3:_(s64) = G_CONSTANT i64 1
    %1:_(s64) = G_ZEXT %0(s32)
    %2:_(s64) = G_MUL %1, %3
    %4:_(s64) = G_CONSTANT i64 15
    %5:_(s64) = nuw G_ADD %2, %4
    %6:_(s64) = G_CONSTANT i64 -16
    %7:_(s64) = G_AND %5, %6
    %8:_(p0) = G_DYN_STACKALLOC %7(s64), 0
    $x0 = COPY %8(p0)
    RET_ReallyLR implicit $x0

...
---
name:            test_aligned_alloca
alignment:       4
tracksRegLiveness: true
liveins:
  - { reg: '$w0' }
frameInfo:
  maxAlignment:    32
stack:
  - { id: 0, name: addr, type: variable-sized, alignment: 32 }
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $w0

    ; CHECK-LABEL: name: test_aligned_alloca
    ; CHECK: liveins: $w0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(s32) = COPY $w0
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 1
    ; CHECK-NEXT: [[ZEXT:%[0-9]+]]:_(s64) = G_ZEXT [[COPY]](s32)
    ; CHECK-NEXT: [[MUL:%[0-9]+]]:_(s64) = G_MUL [[ZEXT]], [[C]]
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 15
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s64) = nuw G_ADD [[MUL]], [[C1]]
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s64) = G_CONSTANT i64 -16
    ; CHECK-NEXT: [[AND:%[0-9]+]]:_(s64) = G_AND [[ADD]], [[C2]]
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
    ; CHECK-NEXT: [[PTRTOINT:%[0-9]+]]:_(s64) = G_PTRTOINT [[COPY1]](p0)
    ; CHECK-NEXT: [[SUB:%[0-9]+]]:_(s64) = G_SUB [[PTRTOINT]], [[AND]]
    ; CHECK-NEXT: [[C3:%[0-9]+]]:_(s64) = G_CONSTANT i64 -32
    ; CHECK-NEXT: [[AND1:%[0-9]+]]:_(s64) = G_AND [[SUB]], [[C3]]
    ; CHECK-NEXT: [[INTTOPTR:%[0-9]+]]:_(p0) = G_INTTOPTR [[AND1]](s64)
    ; CHECK-NEXT: $sp = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(p0) = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: $x0 = COPY [[COPY2]](p0)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %0:_(s32) = COPY $w0
    %3:_(s64) = G_CONSTANT i64 1
    %1:_(s64) = G_ZEXT %0(s32)
    %2:_(s64) = G_MUL %1, %3
    %4:_(s64) = G_CONSTANT i64 15
    %5:_(s64) = nuw G_ADD %2, %4
    %6:_(s64) = G_CONSTANT i64 -16
    %7:_(s64) = G_AND %5, %6
    %8:_(p0) = G_DYN_STACKALLOC %7(s64), 32
    $x0 = COPY %8(p0)
    RET_ReallyLR implicit $x0

...
---
name:            test_natural_alloca
alignment:       4
tracksRegLiveness: true
liveins:
  - { reg: '$w0' }
frameInfo:
  maxAlignment:    1
stack:
  - { id: 0, name: addr, type: variable-sized, alignment: 1 }
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $w0

    ; CHECK-LABEL: name: test_natural_alloca
    ; CHECK: liveins: $w0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(s32) = COPY $w0
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 16
    ; CHECK-NEXT: [[ZEXT:%[0-9]+]]:_(s64) = G_ZEXT [[COPY]](s32)
    ; CHECK-NEXT: [[MUL:%[0-9]+]]:_(s64) = G_MUL [[ZEXT]], [[C]]
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 15
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s64) = nuw G_ADD [[MUL]], [[C1]]
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s64) = G_CONSTANT i64 -16
    ; CHECK-NEXT: [[AND:%[0-9]+]]:_(s64) = G_AND [[ADD]], [[C2]]
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
    ; CHECK-NEXT: [[PTRTOINT:%[0-9]+]]:_(s64) = G_PTRTOINT [[COPY1]](p0)
    ; CHECK-NEXT: [[SUB:%[0-9]+]]:_(s64) = G_SUB [[PTRTOINT]], [[AND]]
    ; CHECK-NEXT: [[INTTOPTR:%[0-9]+]]:_(p0) = G_INTTOPTR [[SUB]](s64)
    ; CHECK-NEXT: $sp = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(p0) = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: $x0 = COPY [[COPY2]](p0)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %0:_(s32) = COPY $w0
    %3:_(s64) = G_CONSTANT i64 16
    %1:_(s64) = G_ZEXT %0(s32)
    %2:_(s64) = G_MUL %1, %3
    %4:_(s64) = G_CONSTANT i64 15
    %5:_(s64) = nuw G_ADD %2, %4
    %6:_(s64) = G_CONSTANT i64 -16
    %7:_(s64) = G_AND %5, %6
    %8:_(p0) = G_DYN_STACKALLOC %7(s64), 0
    $x0 = COPY %8(p0)
    RET_ReallyLR implicit $x0

...
---
name:            test_simple_alloca_stack_probing
alignment:       4
tracksRegLiveness: true
liveins:
  - { reg: '$w0' }
frameInfo:
  maxAlignment:    1
stack:
  - { id: 0, name: addr, type: variable-sized, alignment: 1 }
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $w0

    ; CHECK-LABEL: name: test_simple_alloca_stack_probing
    ; CHECK: liveins: $w0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(s32) = COPY $w0
    ; CHECK-NEXT: [[ZEXT:%[0-9]+]]:_(s64) = G_ZEXT [[COPY]](s32)
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
    ; CHECK-NEXT: [[SHL:%[0-9]+]]:_(s64) = G_SHL [[ZEXT]], [[C]](s64)
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 15
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s64) = nuw G_ADD [[SHL]], [[C1]]
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s64) = G_CONSTANT i64 -16
    ; CHECK-NEXT: [[AND:%[0-9]+]]:_(s64) = G_AND [[ADD]], [[C2]]
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
    ; CHECK-NEXT: [[PTRTOINT:%[0-9]+]]:_(s64) = G_PTRTOINT [[COPY1]](p0)
    ; CHECK-NEXT: [[SUB:%[0-9]+]]:_(s64) = G_SUB [[PTRTOINT]], [[AND]]
    ; CHECK-NEXT: [[INTTOPTR:%[0-9]+]]:gpr64common(p0) = G_INTTOPTR [[SUB]](s64)
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(p0) = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: PROBED_STACKALLOC_DYN [[INTTOPTR]](p0), implicit-def $sp, implicit-def $nzcv, implicit $sp
    ; CHECK-NEXT: $x0 = COPY [[COPY2]](p0)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %0:_(s32) = COPY $w0
    %1:_(s64) = G_ZEXT %0(s32)
    %9:_(s64) = G_CONSTANT i64 0
    %2:_(s64) = G_SHL %1, %9(s64)
    %4:_(s64) = G_CONSTANT i64 15
    %5:_(s64) = nuw G_ADD %2, %4
    %6:_(s64) = G_CONSTANT i64 -16
    %7:_(s64) = G_AND %5, %6
    %8:_(p0) = G_DYN_STACKALLOC %7(s64), 1
    $x0 = COPY %8(p0)
    RET_ReallyLR implicit $x0

...
---
name:            test_aligned_alloca_stack_probing
alignment:       4
tracksRegLiveness: true
liveins:
  - { reg: '$w0' }
frameInfo:
  maxAlignment:    32
stack:
  - { id: 0, name: addr, type: variable-sized, alignment: 32 }
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $w0

    ; CHECK-LABEL: name: test_aligned_alloca_stack_probing
    ; CHECK: liveins: $w0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(s32) = COPY $w0
    ; CHECK-NEXT: [[ZEXT:%[0-9]+]]:_(s64) = G_ZEXT [[COPY]](s32)
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 0
    ; CHECK-NEXT: [[SHL:%[0-9]+]]:_(s64) = G_SHL [[ZEXT]], [[C]](s64)
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 15
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s64) = nuw G_ADD [[SHL]], [[C1]]
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s64) = G_CONSTANT i64 -16
    ; CHECK-NEXT: [[AND:%[0-9]+]]:_(s64) = G_AND [[ADD]], [[C2]]
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
    ; CHECK-NEXT: [[PTRTOINT:%[0-9]+]]:_(s64) = G_PTRTOINT [[COPY1]](p0)
    ; CHECK-NEXT: [[SUB:%[0-9]+]]:_(s64) = G_SUB [[PTRTOINT]], [[AND]]
    ; CHECK-NEXT: [[C3:%[0-9]+]]:_(s64) = G_CONSTANT i64 -32
    ; CHECK-NEXT: [[AND1:%[0-9]+]]:_(s64) = G_AND [[SUB]], [[C3]]
    ; CHECK-NEXT: [[INTTOPTR:%[0-9]+]]:gpr64common(p0) = G_INTTOPTR [[AND1]](s64)
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(p0) = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: PROBED_STACKALLOC_DYN [[INTTOPTR]](p0), implicit-def $sp, implicit-def $nzcv, implicit $sp
    ; CHECK-NEXT: $x0 = COPY [[COPY2]](p0)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %0:_(s32) = COPY $w0
    %1:_(s64) = G_ZEXT %0(s32)
    %9:_(s64) = G_CONSTANT i64 0
    %2:_(s64) = G_SHL %1, %9(s64)
    %4:_(s64) = G_CONSTANT i64 15
    %5:_(s64) = nuw G_ADD %2, %4
    %6:_(s64) = G_CONSTANT i64 -16
    %7:_(s64) = G_AND %5, %6
    %8:_(p0) = G_DYN_STACKALLOC %7(s64), 32
    $x0 = COPY %8(p0)
    RET_ReallyLR implicit $x0

...
---
name:            test_natural_alloca_stack_probing
alignment:       4
tracksRegLiveness: true
liveins:
  - { reg: '$w0' }
frameInfo:
  maxAlignment:    1
stack:
  - { id: 0, name: addr, type: variable-sized, alignment: 1 }
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $w0

    ; CHECK-LABEL: name: test_natural_alloca_stack_probing
    ; CHECK: liveins: $w0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(s32) = COPY $w0
    ; CHECK-NEXT: [[ZEXT:%[0-9]+]]:_(s64) = G_ZEXT [[COPY]](s32)
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s64) = G_CONSTANT i64 4
    ; CHECK-NEXT: [[SHL:%[0-9]+]]:_(s64) = G_SHL [[ZEXT]], [[C]](s64)
    ; CHECK-NEXT: [[C1:%[0-9]+]]:_(s64) = G_CONSTANT i64 15
    ; CHECK-NEXT: [[ADD:%[0-9]+]]:_(s64) = nuw G_ADD [[SHL]], [[C1]]
    ; CHECK-NEXT: [[C2:%[0-9]+]]:_(s64) = G_CONSTANT i64 -16
    ; CHECK-NEXT: [[AND:%[0-9]+]]:_(s64) = G_AND [[ADD]], [[C2]]
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $sp
    ; CHECK-NEXT: [[PTRTOINT:%[0-9]+]]:_(s64) = G_PTRTOINT [[COPY1]](p0)
    ; CHECK-NEXT: [[SUB:%[0-9]+]]:_(s64) = G_SUB [[PTRTOINT]], [[AND]]
    ; CHECK-NEXT: [[INTTOPTR:%[0-9]+]]:gpr64common(p0) = G_INTTOPTR [[SUB]](s64)
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(p0) = COPY [[INTTOPTR]](p0)
    ; CHECK-NEXT: PROBED_STACKALLOC_DYN [[INTTOPTR]](p0), implicit-def $sp, implicit-def $nzcv, implicit $sp
    ; CHECK-NEXT: $x0 = COPY [[COPY2]](p0)
    ; CHECK-NEXT: RET_ReallyLR implicit $x0
    %0:_(s32) = COPY $w0
    %1:_(s64) = G_ZEXT %0(s32)
    %9:_(s64) = G_CONSTANT i64 4
    %2:_(s64) = G_SHL %1, %9(s64)
    %4:_(s64) = G_CONSTANT i64 15
    %5:_(s64) = nuw G_ADD %2, %4
    %6:_(s64) = G_CONSTANT i64 -16
    %7:_(s64) = G_AND %5, %6
    %8:_(p0) = G_DYN_STACKALLOC %7(s64), 1
    $x0 = COPY %8(p0)
    RET_ReallyLR implicit $x0

...
