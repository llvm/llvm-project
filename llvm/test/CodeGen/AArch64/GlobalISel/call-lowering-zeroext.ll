; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -mtriple=aarch64 -global-isel -stop-after=irtranslator -verify-machineinstrs -o - %s | FileCheck %s

; Verify that we generate G_ASSERT_ZEXT for zeroext parameters.

define i8 @zeroext_param_i8(i8 zeroext %x) {
  ; CHECK-LABEL: name: zeroext_param_i8
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $w0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i32) = COPY $w0
  ; CHECK-NEXT:   [[ASSERT_ZEXT:%[0-9]+]]:_(i32) = G_ASSERT_ZEXT [[COPY]], 8
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(i8) = G_TRUNC [[ASSERT_ZEXT]](i32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(i32) = G_ANYEXT [[TRUNC]](i8)
  ; CHECK-NEXT:   $w0 = COPY [[ANYEXT]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
  ret i8 %x
}

define i8 @no_zeroext_param(i8 %x) {
  ; CHECK-LABEL: name: no_zeroext_param
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $w0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i32) = COPY $w0
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(i8) = G_TRUNC [[COPY]](i32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(i32) = G_ANYEXT [[TRUNC]](i8)
  ; CHECK-NEXT:   $w0 = COPY [[ANYEXT]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
  ret i8 %x
}

; Don't need G_ASSERT_ZEXT here. The sizes match.
define i32 @zeroext_param_i32(i32 zeroext %x) {
  ; CHECK-LABEL: name: zeroext_param_i32
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $w0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i32) = COPY $w0
  ; CHECK-NEXT:   $w0 = COPY [[COPY]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
  ret i32 %x
}

; Zeroext param is passed on the stack. We should still get a G_ASSERT_ZEXT.
define i32 @zeroext_param_stack(i64 %a, i64 %b, i64 %c, i64 %d, i64 %e, i64 %f,
  ; CHECK-LABEL: name: zeroext_param_stack
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $x0, $x1, $x2, $x3, $x4, $x5, $x6, $x7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i64) = COPY $x0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(i64) = COPY $x1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(i64) = COPY $x2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(i64) = COPY $x3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(i64) = COPY $x4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(i64) = COPY $x5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(i64) = COPY $x6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(i64) = COPY $x7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(i64) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (i64) from %fixed-stack.1, align 16)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[ZEXTLOAD:%[0-9]+]]:_(i32) = G_ZEXTLOAD [[FRAME_INDEX1]](p0) :: (invariant load (i8) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   [[ASSERT_ZEXT:%[0-9]+]]:_(i32) = G_ASSERT_ZEXT [[ZEXTLOAD]], 1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(i1) = G_TRUNC [[ASSERT_ZEXT]](i32)
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(i32) = G_ZEXT [[TRUNC]](i1)
  ; CHECK-NEXT:   $w0 = COPY [[ZEXT]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
                                i64 %g, i64 %h, i64 %i, i1 zeroext %j) {
  %v = zext i1 %j to i32
  ret i32 %v
}

; The zeroext parameter is a s32, so there's no extension required.
define i32 @dont_need_assert_zext_stack(i64 %a, i64 %b, i64 %c, i64 %d, i64 %e,
  ; CHECK-LABEL: name: dont_need_assert_zext_stack
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $x0, $x1, $x2, $x3, $x4, $x5, $x6, $x7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i64) = COPY $x0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(i64) = COPY $x1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(i64) = COPY $x2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(i64) = COPY $x3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(i64) = COPY $x4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(i64) = COPY $x5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(i64) = COPY $x6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(i64) = COPY $x7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(i64) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (i64) from %fixed-stack.1, align 16)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[LOAD1:%[0-9]+]]:_(i32) = G_LOAD [[FRAME_INDEX1]](p0) :: (invariant load (i32) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   $w0 = COPY [[LOAD1]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
                                        i64 %f, i64 %g, i64 %h, i64 %i,
                                        i32 zeroext %j) {
  ret i32 %j
}

; s8 requires extension to s32, so we should get a G_ASSERT_ZEXT here.
define i8 @s8_assert_zext_stack(i64 %a, i64 %b, i64 %c, i64 %d, i64 %e,
  ; CHECK-LABEL: name: s8_assert_zext_stack
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $x0, $x1, $x2, $x3, $x4, $x5, $x6, $x7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i64) = COPY $x0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:_(i64) = COPY $x1
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:_(i64) = COPY $x2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:_(i64) = COPY $x3
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:_(i64) = COPY $x4
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:_(i64) = COPY $x5
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:_(i64) = COPY $x6
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:_(i64) = COPY $x7
  ; CHECK-NEXT:   [[FRAME_INDEX:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.1
  ; CHECK-NEXT:   [[LOAD:%[0-9]+]]:_(i64) = G_LOAD [[FRAME_INDEX]](p0) :: (invariant load (i64) from %fixed-stack.1, align 16)
  ; CHECK-NEXT:   [[FRAME_INDEX1:%[0-9]+]]:_(p0) = G_FRAME_INDEX %fixed-stack.0
  ; CHECK-NEXT:   [[ZEXTLOAD:%[0-9]+]]:_(i32) = G_ZEXTLOAD [[FRAME_INDEX1]](p0) :: (invariant load (i8) from %fixed-stack.0, align 8)
  ; CHECK-NEXT:   [[ASSERT_ZEXT:%[0-9]+]]:_(i32) = G_ASSERT_ZEXT [[ZEXTLOAD]], 8
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(i8) = G_TRUNC [[ASSERT_ZEXT]](i32)
  ; CHECK-NEXT:   [[ANYEXT:%[0-9]+]]:_(i32) = G_ANYEXT [[TRUNC]](i8)
  ; CHECK-NEXT:   $w0 = COPY [[ANYEXT]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
                                        i64 %f, i64 %g, i64 %h, i64 %i,
                                        i8 zeroext %j) {
  ret i8 %j
}

define i32 @callee_zeroext_i1(i1 zeroext %0) {
  ; CHECK-LABEL: name: callee_zeroext_i1
  ; CHECK: bb.1 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $w0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i32) = COPY $w0
  ; CHECK-NEXT:   [[ASSERT_ZEXT:%[0-9]+]]:_(i32) = G_ASSERT_ZEXT [[COPY]], 1
  ; CHECK-NEXT:   [[TRUNC:%[0-9]+]]:_(i1) = G_TRUNC [[ASSERT_ZEXT]](i32)
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(i32) = G_ZEXT [[TRUNC]](i1)
  ; CHECK-NEXT:   $w0 = COPY [[ZEXT]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
  %r = zext i1 %0 to i32
  ret i32 %r
}

define i32 @caller_zeroext_i1() {
  ; CHECK-LABEL: name: caller_zeroext_i1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(i1) = G_CONSTANT i1 true
  ; CHECK-NEXT:   ADJCALLSTACKDOWN 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(i8) = G_ZEXT [[C]](i1)
  ; CHECK-NEXT:   [[ZEXT1:%[0-9]+]]:_(i32) = G_ZEXT [[ZEXT]](i8)
  ; CHECK-NEXT:   $w0 = COPY [[ZEXT1]](i32)
  ; CHECK-NEXT:   BL @callee_zeroext_i1, csr_aarch64_aapcs, implicit-def $lr, implicit $sp, implicit $w0, implicit-def $w0
  ; CHECK-NEXT:   ADJCALLSTACKUP 0, 0, implicit-def $sp, implicit $sp
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:_(i32) = COPY $w0
  ; CHECK-NEXT:   $w0 = COPY [[COPY]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
  %r = call i32 @callee_zeroext_i1(i1 zeroext true)
  ret i32 %r
}

define zeroext i1 @ret_zeroext_i1() {
  ; CHECK-LABEL: name: ret_zeroext_i1
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK-NEXT:   [[C:%[0-9]+]]:_(i1) = G_CONSTANT i1 true
  ; CHECK-NEXT:   [[ZEXT:%[0-9]+]]:_(i32) = G_ZEXT [[C]](i1)
  ; CHECK-NEXT:   $w0 = COPY [[ZEXT]](i32)
  ; CHECK-NEXT:   RET_ReallyLR implicit $w0
  ret i1 true
}
