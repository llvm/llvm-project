; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -global-isel -o - %s | FileCheck %s

target triple = "aarch64-unknown-unknown"

; Check we don't crash here when computing known bits.

define <4 x i32> @test(<8 x i16> %in, i1 %continue) {
; CHECK-LABEL: test:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    mov w11, wzr
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    mov w9, #2 // =0x2
; CHECK-NEXT:  .LBB0_1: // %loop
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    mov w10, w11
; CHECK-NEXT:    mov w11, w11
; CHECK-NEXT:    str q0, [sp]
; CHECK-NEXT:    and x11, x11, #0x7
; CHECK-NEXT:    umull x11, w11, w9
; CHECK-NEXT:    ldrb w11, [x8, x11]
; CHECK-NEXT:    cmp w11, #0
; CHECK-NEXT:    cset w11, eq
; CHECK-NEXT:    fmov s1, w11
; CHECK-NEXT:    mov v1.b[1], wzr
; CHECK-NEXT:    mov v1.b[2], wzr
; CHECK-NEXT:    mov v1.b[3], wzr
; CHECK-NEXT:    fmov w11, s1
; CHECK-NEXT:    tbz w0, #0, .LBB0_1
; CHECK-NEXT:  // %bb.2: // %exit
; CHECK-NEXT:    fmov s0, w10
; CHECK-NEXT:    mov v0.s[1], wzr
; CHECK-NEXT:    mov v0.s[2], wzr
; CHECK-NEXT:    mov v0.s[3], wzr
; CHECK-NEXT:    add sp, sp, #16
; CHECK-NEXT:    ret
entry:
  br label %loop

exit:
  %result = insertelement <4 x i32> zeroinitializer, i32 %index, i64 0
  ret <4 x i32> %result

loop:
  %index = phi i32 [ 0, %entry ], [ %insert.bitcast, %loop ]
  %extracted = extractelement <8 x i16> %in, i32 %index
  %masked = and i16 %extracted, 255
  %maskedIsZero = icmp eq i16 %masked, 0
  %maskedIsZero.zext = zext i1 %maskedIsZero to i8
  %insert = insertelement <4 x i8> zeroinitializer, i8 %maskedIsZero.zext, i64 0
  %insert.bitcast = bitcast <4 x i8> %insert to i32
  br i1 %continue, label %exit, label %loop
}
