# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
#
# Check that we can recognize a shuffle mask for a zip instruction, and produce
# G_ZIP1 or G_ZIP2 where appropriate.
#
# RUN: llc -mtriple aarch64 -run-pass=aarch64-postlegalizer-lowering -verify-machineinstrs %s -o - | FileCheck %s

...
---
name:            zip1_v2s32
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $d0, $d1

    ; CHECK-LABEL: name: zip1_v2s32
    ; CHECK: liveins: $d0, $d1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<2 x s32>) = COPY $d0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<2 x s32>) = COPY $d1
    ; CHECK-NEXT: [[ZIP1_:%[0-9]+]]:_(<2 x s32>) = G_ZIP1 [[COPY]], [[COPY1]]
    ; CHECK-NEXT: $d0 = COPY [[ZIP1_]](<2 x s32>)
    ; CHECK-NEXT: RET_ReallyLR implicit $d0
    %0:_(<2 x s32>) = COPY $d0
    %1:_(<2 x s32>) = COPY $d1
    %2:_(<2 x s32>) = G_SHUFFLE_VECTOR %0(<2 x s32>), %1, shufflemask(0, 2)
    $d0 = COPY %2(<2 x s32>)
    RET_ReallyLR implicit $d0

...
---
name:            zip1_v2s64
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $q0, $q1

    ; CHECK-LABEL: name: zip1_v2s64
    ; CHECK: liveins: $q0, $q1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<2 x s64>) = COPY $q0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<2 x s64>) = COPY $q1
    ; CHECK-NEXT: [[ZIP1_:%[0-9]+]]:_(<2 x s64>) = G_ZIP1 [[COPY]], [[COPY1]]
    ; CHECK-NEXT: $q0 = COPY [[ZIP1_]](<2 x s64>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %0:_(<2 x s64>) = COPY $q0
    %1:_(<2 x s64>) = COPY $q1
    %2:_(<2 x s64>) = G_SHUFFLE_VECTOR %0(<2 x s64>), %1, shufflemask(0, 2)
    $q0 = COPY %2(<2 x s64>)
    RET_ReallyLR implicit $q0

...
---
name:            zip1_v4s32
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $q0, $q1

    ; CHECK-LABEL: name: zip1_v4s32
    ; CHECK: liveins: $q0, $q1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<4 x s32>) = COPY $q0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<4 x s32>) = COPY $q1
    ; CHECK-NEXT: [[ZIP1_:%[0-9]+]]:_(<4 x s32>) = G_ZIP1 [[COPY]], [[COPY1]]
    ; CHECK-NEXT: $q0 = COPY [[ZIP1_]](<4 x s32>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %0:_(<4 x s32>) = COPY $q0
    %1:_(<4 x s32>) = COPY $q1
    %2:_(<4 x s32>) = G_SHUFFLE_VECTOR %0(<4 x s32>), %1, shufflemask(0, 4, 1, 5)
    $q0 = COPY %2(<4 x s32>)
    RET_ReallyLR implicit $q0

...
---
name:            zip2_v2s32
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $d0, $d1

    ; CHECK-LABEL: name: zip2_v2s32
    ; CHECK: liveins: $d0, $d1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<2 x s32>) = COPY $d0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<2 x s32>) = COPY $d1
    ; CHECK-NEXT: [[ZIP2_:%[0-9]+]]:_(<2 x s32>) = G_ZIP2 [[COPY]], [[COPY1]]
    ; CHECK-NEXT: $d0 = COPY [[ZIP2_]](<2 x s32>)
    ; CHECK-NEXT: RET_ReallyLR implicit $d0
    %0:_(<2 x s32>) = COPY $d0
    %1:_(<2 x s32>) = COPY $d1
    %2:_(<2 x s32>) = G_SHUFFLE_VECTOR %0(<2 x s32>), %1, shufflemask(1, 3)
    $d0 = COPY %2(<2 x s32>)
    RET_ReallyLR implicit $d0

...
---
name:            zip2_v2s64
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $q0, $q1

    ; CHECK-LABEL: name: zip2_v2s64
    ; CHECK: liveins: $q0, $q1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<2 x s64>) = COPY $q0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<2 x s64>) = COPY $q1
    ; CHECK-NEXT: [[ZIP2_:%[0-9]+]]:_(<2 x s64>) = G_ZIP2 [[COPY]], [[COPY1]]
    ; CHECK-NEXT: $q0 = COPY [[ZIP2_]](<2 x s64>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %0:_(<2 x s64>) = COPY $q0
    %1:_(<2 x s64>) = COPY $q1
    %2:_(<2 x s64>) = G_SHUFFLE_VECTOR %0(<2 x s64>), %1, shufflemask(1, 3)
    $q0 = COPY %2(<2 x s64>)
    RET_ReallyLR implicit $q0

...
---
name:            zip2_v4s32
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $q0, $q1

    ; CHECK-LABEL: name: zip2_v4s32
    ; CHECK: liveins: $q0, $q1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<4 x s32>) = COPY $q0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<4 x s32>) = COPY $q1
    ; CHECK-NEXT: [[ZIP2_:%[0-9]+]]:_(<4 x s32>) = G_ZIP2 [[COPY]], [[COPY1]]
    ; CHECK-NEXT: $q0 = COPY [[ZIP2_]](<4 x s32>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %0:_(<4 x s32>) = COPY $q0
    %1:_(<4 x s32>) = COPY $q1
    %2:_(<4 x s32>) = G_SHUFFLE_VECTOR %0(<4 x s32>), %1, shufflemask(2, 6, 3, 7)
    $q0 = COPY %2(<4 x s32>)
    RET_ReallyLR implicit $q0

...
---
name:            zip2_no_combine_idx_mismatch
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $q0, $q1

    ; This will fail because it expects 3 to be the second element of the
    ; shuffle vector mask.
    ;
    ; CHECK-LABEL: name: zip2_no_combine_idx_mismatch
    ; CHECK: liveins: $q0, $q1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<2 x s64>) = COPY $q0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<2 x s64>) = COPY $q1
    ; CHECK-NEXT: [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 8
    ; CHECK-NEXT: [[EXT:%[0-9]+]]:_(<2 x s64>) = G_EXT [[COPY]], [[COPY1]], [[C]](s32)
    ; CHECK-NEXT: $q0 = COPY [[EXT]](<2 x s64>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %0:_(<2 x s64>) = COPY $q0
    %1:_(<2 x s64>) = COPY $q1
    %2:_(<2 x s64>) = G_SHUFFLE_VECTOR %0(<2 x s64>), %1, shufflemask(1, 2)
    $q0 = COPY %2(<2 x s64>)
    RET_ReallyLR implicit $q0

...
---
name:            zip1_no_combine_idx_mismatch
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $q0, $q1

    ; This will fail because it expects 2 to be the second element of the
    ; shuffle vector mask.
    ;
    ; CHECK-LABEL: name: zip1_no_combine_idx_mismatch
    ; CHECK: liveins: $q0, $q1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<2 x s64>) = COPY $q0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<2 x s64>) = COPY [[COPY]](<2 x s64>)
    ; CHECK-NEXT: $q0 = COPY [[COPY1]](<2 x s64>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %0:_(<2 x s64>) = COPY $q0
    %1:_(<2 x s64>) = COPY $q1
    %2:_(<2 x s64>) = G_SHUFFLE_VECTOR %0(<2 x s64>), %1, shufflemask(0, 1)
    $q0 = COPY %2(<2 x s64>)
    RET_ReallyLR implicit $q0

...
---
name:            no_combine_first_elt_of_mask_must_be_zero_or_one
alignment:       4
legalized:       true
tracksRegLiveness: true
body:             |
  bb.1.entry:
    liveins: $q0, $q1

    ; zip1/zip2 must have 0 or 1 as the first element in the shuffle mask.
    ;
    ; CHECK-LABEL: name: no_combine_first_elt_of_mask_must_be_zero_or_one
    ; CHECK: liveins: $q0, $q1
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(<4 x s32>) = COPY $q0
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(<4 x s32>) = COPY $q1
    ; CHECK-NEXT: [[SHUF:%[0-9]+]]:_(<4 x s32>) = G_SHUFFLE_VECTOR [[COPY]](<4 x s32>), [[COPY1]], shufflemask(3, 4, 1, 5)
    ; CHECK-NEXT: $q0 = COPY [[SHUF]](<4 x s32>)
    ; CHECK-NEXT: RET_ReallyLR implicit $q0
    %0:_(<4 x s32>) = COPY $q0
    %1:_(<4 x s32>) = COPY $q1
    %2:_(<4 x s32>) = G_SHUFFLE_VECTOR %0(<4 x s32>), %1, shufflemask(3, 4, 1, 5)
    $q0 = COPY %2(<4 x s32>)
    RET_ReallyLR implicit $q0
