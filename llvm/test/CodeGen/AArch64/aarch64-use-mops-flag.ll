; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5

; Test the -aarch64-use-mops flag that controls whether MOPS
; instructions are used in memset/memcpy/memmove intrinsics
; when the target supports them.

; RUN: llc %s -o - -mtriple=aarch64 -mattr=+mops | FileCheck %s --check-prefix=MOPS-ENABLED
; RUN: llc %s -o - -mtriple=aarch64 -mattr=+mops -aarch64-use-mops=false | FileCheck %s --check-prefix=MOPS-DISABLED
; RUN: llc %s -o - -mtriple=aarch64 -mattr=+mops -aarch64-use-mops=true  | FileCheck %s --check-prefix=MOPS-ENABLED

declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg)
declare void @llvm.memcpy.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg)

; Test memset at threshold (512 bytes) - should be inlined when MOPS disabled
define void @memset_threshold(ptr %dst) {
; MOPS-ENABLED-LABEL: memset_threshold:
; MOPS-ENABLED:       // %bb.0:
; MOPS-ENABLED-NEXT:    movi v0.2d, #0000000000000000
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #32]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #64]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #96]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #128]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #160]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #192]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #224]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #256]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #288]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #320]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #352]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #384]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #416]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #448]
; MOPS-ENABLED-NEXT:    stp q0, q0, [x0, #480]
; MOPS-ENABLED-NEXT:    ret
;
; MOPS-DISABLED-LABEL: memset_threshold:
; MOPS-DISABLED:       // %bb.0:
; MOPS-DISABLED-NEXT:    movi v0.2d, #0000000000000000
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #32]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #64]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #96]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #128]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #160]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #192]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #224]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #256]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #288]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #320]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #352]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #384]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #416]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #448]
; MOPS-DISABLED-NEXT:    stp q0, q0, [x0, #480]
; MOPS-DISABLED-NEXT:    ret
  call void @llvm.memset.p0.i64(ptr align 16 %dst, i8 0, i64 512, i1 false)
  ret void
}

; Test memset just over threshold (513 bytes) - should use MOPS when enabled, library call when disabled
define void @memset_over_threshold(ptr %dst) {
; MOPS-ENABLED-LABEL: memset_over_threshold:
; MOPS-ENABLED:       // %bb.0:
; MOPS-ENABLED-NEXT:    mov w8, #513 // =0x201
; MOPS-ENABLED-NEXT:    setp [x0]!, x8!, xzr
; MOPS-ENABLED-NEXT:    setm [x0]!, x8!, xzr
; MOPS-ENABLED-NEXT:    sete [x0]!, x8!, xzr
; MOPS-ENABLED-NEXT:    ret
;
; MOPS-DISABLED-LABEL: memset_over_threshold:
; MOPS-DISABLED:       // %bb.0:
; MOPS-DISABLED-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; MOPS-DISABLED-NEXT:    .cfi_def_cfa_offset 16
; MOPS-DISABLED-NEXT:    .cfi_offset w30, -16
; MOPS-DISABLED-NEXT:    mov w1, wzr
; MOPS-DISABLED-NEXT:    mov w2, #513 // =0x201
; MOPS-DISABLED-NEXT:    bl memset
; MOPS-DISABLED-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; MOPS-DISABLED-NEXT:    ret
  call void @llvm.memset.p0.i64(ptr align 16 %dst, i8 0, i64 513, i1 false)
  ret void
}

; Test memcpy (should use MOPS when enabled, library call when disabled)
define void @memcpy_large(ptr %dst, ptr %src) {
; MOPS-ENABLED-LABEL: memcpy_large:
; MOPS-ENABLED:       // %bb.0:
; MOPS-ENABLED-NEXT:    mov w8, #2048 // =0x800
; MOPS-ENABLED-NEXT:    cpyfp [x0]!, [x1]!, x8!
; MOPS-ENABLED-NEXT:    cpyfm [x0]!, [x1]!, x8!
; MOPS-ENABLED-NEXT:    cpyfe [x0]!, [x1]!, x8!
; MOPS-ENABLED-NEXT:    ret
;
; MOPS-DISABLED-LABEL: memcpy_large:
; MOPS-DISABLED:       // %bb.0:
; MOPS-DISABLED-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; MOPS-DISABLED-NEXT:    .cfi_def_cfa_offset 16
; MOPS-DISABLED-NEXT:    .cfi_offset w30, -16
; MOPS-DISABLED-NEXT:    mov w2, #2048 // =0x800
; MOPS-DISABLED-NEXT:    bl memcpy
; MOPS-DISABLED-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; MOPS-DISABLED-NEXT:    ret
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %dst, ptr align 1 %src, i64 2048, i1 false)
  ret void
}

; Test memmove (should use MOPS when enabled, library call when disabled)
define void @memmove_large(ptr %dst, ptr %src) {
; MOPS-ENABLED-LABEL: memmove_large:
; MOPS-ENABLED:       // %bb.0:
; MOPS-ENABLED-NEXT:    mov w8, #800 // =0x320
; MOPS-ENABLED-NEXT:    cpyp [x0]!, [x1]!, x8!
; MOPS-ENABLED-NEXT:    cpym [x0]!, [x1]!, x8!
; MOPS-ENABLED-NEXT:    cpye [x0]!, [x1]!, x8!
; MOPS-ENABLED-NEXT:    ret
;
; MOPS-DISABLED-LABEL: memmove_large:
; MOPS-DISABLED:       // %bb.0:
; MOPS-DISABLED-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; MOPS-DISABLED-NEXT:    .cfi_def_cfa_offset 16
; MOPS-DISABLED-NEXT:    .cfi_offset w30, -16
; MOPS-DISABLED-NEXT:    mov w2, #800 // =0x320
; MOPS-DISABLED-NEXT:    bl memmove
; MOPS-DISABLED-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; MOPS-DISABLED-NEXT:    ret
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %dst, ptr align 1 %src, i64 800, i1 false)
  ret void
}
