; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64-unknown-unknown | FileCheck %s

; Test for the optimization: (Cond0 s> -1) ? -1 : N2 --> ~(Cond0 s>> BW-1) | freeze(N2)
; This pattern should be optimized to use 'orn' instruction on AArch64

define <4 x i32> @vselect_signbit_orn_scalar(<4 x i32> %x, <4 x i32> %y) {
; CHECK-LABEL: vselect_signbit_orn_scalar:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmge v0.4s, v0.4s, #0
; CHECK-NEXT:    orr v0.16b, v0.16b, v1.16b
; CHECK-NEXT:    ret
  %cmp = icmp sgt <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %sel = select <4 x i1> %cmp, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, <4 x i32> %y
  ret <4 x i32> %sel
}

define <2 x i64> @vselect_signbit_orn_scalar64(<2 x i64> %x, <2 x i64> %y) {
; CHECK-LABEL: vselect_signbit_orn_scalar64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmge v0.2d, v0.2d, #0
; CHECK-NEXT:    orr v0.16b, v0.16b, v1.16b
; CHECK-NEXT:    ret
  %cmp = icmp sgt <2 x i64> %x, <i64 -1, i64 -1>
  %sel = select <2 x i1> %cmp, <2 x i64> <i64 -1, i64 -1>, <2 x i64> %y
  ret <2 x i64> %sel
}

define <4 x i32> @vselect_signbit_orn_vector(<4 x i32> %x, <4 x i32> %y) {
; CHECK-LABEL: vselect_signbit_orn_vector:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmge v0.4s, v0.4s, #0
; CHECK-NEXT:    orr v0.16b, v0.16b, v1.16b
; CHECK-NEXT:    ret
  %cmp = icmp sgt <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %sel = select <4 x i1> %cmp, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, <4 x i32> %y
  ret <4 x i32> %sel
}

define <2 x i64> @vselect_signbit_orn_vector64(<2 x i64> %x, <2 x i64> %y) {
; CHECK-LABEL: vselect_signbit_orn_vector64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmge v0.2d, v0.2d, #0
; CHECK-NEXT:    orr v0.16b, v0.16b, v1.16b
; CHECK-NEXT:    ret
  %cmp = icmp sgt <2 x i64> %x, <i64 -1, i64 -1>
  %sel = select <2 x i1> %cmp, <2 x i64> <i64 -1, i64 -1>, <2 x i64> %y
  ret <2 x i64> %sel
}

; Test with different constant values for N2
define <4 x i32> @vselect_signbit_orn_scalar_const(<4 x i32> %x) {
; CHECK-LABEL: vselect_signbit_orn_scalar_const:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmge v0.4s, v0.4s, #0
; CHECK-NEXT:    orr v0.4s, #42
; CHECK-NEXT:    ret
  %cmp = icmp sgt <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %sel = select <4 x i1> %cmp, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, <4 x i32> <i32 42, i32 42, i32 42, i32 42>
  ret <4 x i32> %sel
}

; Test the inverse pattern to ensure it doesn't get optimized (should use different instruction)
define <4 x i32> @vselect_signbit_not_orn(<4 x i32> %x, <4 x i32> %y) {
; CHECK-LABEL: vselect_signbit_not_orn:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmlt v0.4s, v0.4s, #0
; CHECK-NEXT:    and v0.16b, v0.16b, v1.16b
; CHECK-NEXT:    ret
  %cmp = icmp sgt <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %sel = select <4 x i1> %cmp, <4 x i32> <i32 0, i32 0, i32 0, i32 0>, <4 x i32> %y
  ret <4 x i32> %sel
}

define <4 x i32> @test_orn_instruction_direct(<4 x i32> %x, <4 x i32> %y) {
; CHECK-LABEL: test_orn_instruction_direct:
; CHECK:       // %bb.0:
; CHECK-NEXT:    orn v0.16b, v0.16b, v1.16b
; CHECK-NEXT:    ret
  %not_y = xor <4 x i32> %y, <i32 -1, i32 -1, i32 -1, i32 -1>
  %result = or <4 x i32> %x, %not_y
  ret <4 x i32> %result
}

; Scalar versions of the same tests
define i32 @vselect_signbit_orn_scalar_i32(i32 %x, i32 %y) {
; CHECK-LABEL: vselect_signbit_orn_scalar_i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmn w0, #1
; CHECK-NEXT:    csinv w0, w1, wzr, le
; CHECK-NEXT:    ret
  %cmp = icmp sgt i32 %x, -1
  %sel = select i1 %cmp, i32 -1, i32 %y
  ret i32 %sel
}

define i64 @vselect_signbit_orn_scalar_i64(i64 %x, i64 %y) {
; CHECK-LABEL: vselect_signbit_orn_scalar_i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmn x0, #1
; CHECK-NEXT:    csinv x0, x1, xzr, le
; CHECK-NEXT:    ret
  %cmp = icmp sgt i64 %x, -1
  %sel = select i1 %cmp, i64 -1, i64 %y
  ret i64 %sel
}

define i32 @test_orn_instruction_scalar_i32(i32 %x, i32 %y) {
; CHECK-LABEL: test_orn_instruction_scalar_i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    orn w0, w0, w1
; CHECK-NEXT:    ret
  %not_y = xor i32 %y, -1
  %result = or i32 %x, %not_y
  ret i32 %result
}

define i64 @test_orn_instruction_scalar_i64(i64 %x, i64 %y) {
; CHECK-LABEL: test_orn_instruction_scalar_i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    orn x0, x0, x1
; CHECK-NEXT:    ret
  %not_y = xor i64 %y, -1
  %result = or i64 %x, %not_y
  ret i64 %result
}

