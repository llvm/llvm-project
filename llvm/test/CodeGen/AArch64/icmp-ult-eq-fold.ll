; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=aarch64 | FileCheck %s


define i1 @lt8_u8(i8 %0) {
; CHECK-LABEL: lt8_u8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tst w0, #0xf8
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = icmp ult i8 %0, 8
  ret i1 %2
}

define i1 @lt32_u8(i8 %0) {
; CHECK-LABEL: lt32_u8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tst w0, #0xe0
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = icmp ult i8 %0, 32
  ret i1 %2
}

define i1 @lt64_u8(i8 %0) {
; CHECK-LABEL: lt64_u8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tst w0, #0xc0
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = icmp ult i8 %0, 64
  ret i1 %2
}

define i1 @lt8_u32(i32 %0) {
; CHECK-LABEL: lt8_u32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #8
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i32 %0, 8
  ret i1 %2
}

define i1 @lt32_u32(i32 %0) {
; CHECK-LABEL: lt32_u32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #32
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i32 %0, 32
  ret i1 %2
}

define i1 @lt64_u32(i32 %0) {
; CHECK-LABEL: lt64_u32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #64
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i32 %0, 64
  ret i1 %2
}

define i1 @lt8_u64(i64 %0) {
; CHECK-LABEL: lt8_u64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp x0, #8
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i64 %0, 8
  ret i1 %2
}

define i1 @lt32_u64(i64 %0) {
; CHECK-LABEL: lt32_u64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp x0, #32
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i64 %0, 32
  ret i1 %2
}

define i1 @lt64_u64(i64 %0) {
; CHECK-LABEL: lt64_u64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp x0, #64
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i64 %0, 64
  ret i1 %2
}

define i1 @lt8_u16_and_5(i8 %0) {
; CHECK-LABEL: lt8_u16_and_5:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, wzr
; CHECK-NEXT:    cmp w8, #0
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = and i8 %0, 5
  %3 = icmp ult i8 %2, 16
  ret i1 %3
}

define i1 @lt8_u16_and_19(i8 %0) {
; CHECK-LABEL: lt8_u16_and_19:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tst w0, #0x10
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = and i8 %0, 19
  %3 = icmp ult i8 %2, 16
  ret i1 %3
}

define i1 @lt32_u16_and_7(i32 %0) {
; CHECK-LABEL: lt32_u16_and_7:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, wzr
; CHECK-NEXT:    cmp w8, #0
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = and i32 %0, 7
  %3 = icmp ult i32 %2, 16
  ret i1 %3
}

define i1 @lt32_u16_and_21(i32 %0) {
; CHECK-LABEL: lt32_u16_and_21:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tst w0, #0x10
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = and i32 %0, 21
  %3 = icmp ult i32 %2, 16
  ret i1 %3
}

define i1 @lt64_u16_and_9(i64 %0) {
; CHECK-LABEL: lt64_u16_and_9:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:    cmp x8, #0
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = and i64 %0, 9
  %3 = icmp ult i64 %2, 16
  ret i1 %3
}

define i1 @lt64_u16_and_23(i64 %0) {
; CHECK-LABEL: lt64_u16_and_23:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tst x0, #0x10
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %2 = and i64 %0, 23
  %3 = icmp ult i64 %2, 16
  ret i1 %3
}

define i1 @test_disjoint(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    tst w9, w8
; CHECK-NEXT:    cset w8, eq
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %5 = and i32 %3, %4
  %6 = icmp eq i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint2(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    tst w9, w8
; CHECK-NEXT:    cset w8, gt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %5 = and i32 %3, %4
  %6 = icmp sgt i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint3(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint3:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    tst w9, w8
; CHECK-NEXT:    cset w8, mi
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %5 = and i32 %3, %4
  %6 = icmp slt i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint4(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint4:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    and w8, w9, w8
; CHECK-NEXT:    cmp w8, #1
; CHECK-NEXT:    cset w8, lt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %5 = and i32 %3, %4
  %6 = icmp sle i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint_inverse_4(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint_inverse_4:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    bic w8, w9, w8
; CHECK-NEXT:    cmp w8, #1
; CHECK-NEXT:    cset w8, lt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %not = xor i32 %4, -1
  %5 = and i32 %3, %not
  %6 = icmp sle i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint_inverse(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint_inverse:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    bics wzr, w9, w8
; CHECK-NEXT:    cset w8, eq
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %not = xor i32 %4, -1
  %5 = and i32 %3, %not
  %6 = icmp eq i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint2_inverse(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint2_inverse:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    bics wzr, w9, w8
; CHECK-NEXT:    cset w8, gt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %not = xor i32 %4, -1
  %5 = and i32 %3, %not
  %6 = icmp sgt i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint3_inverse(i1 %0, i32 %1, i32 %2) {
; CHECK-LABEL: test_disjoint3_inverse:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr w9, w2, #0x800000
; CHECK-NEXT:    lsl w8, w8, w1
; CHECK-NEXT:    bics wzr, w9, w8
; CHECK-NEXT:    cset w8, mi
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i32 %2, 8388608
  %4 = shl nuw i32 1, %1
  %not = xor i32 %4, -1
  %5 = and i32 %3, %not
  %6 = icmp slt i32 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    tst x9, x8
; CHECK-NEXT:    cset w8, eq
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %5 = and i64 %3, %4
  %6 = icmp eq i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint2_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint2_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    tst x9, x8
; CHECK-NEXT:    cset w8, gt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %5 = and i64 %3, %4
  %6 = icmp sgt i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint3_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint3_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    tst x9, x8
; CHECK-NEXT:    cset w8, mi
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %5 = and i64 %3, %4
  %6 = icmp slt i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint4_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint4_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    and x8, x9, x8
; CHECK-NEXT:    cmp x8, #1
; CHECK-NEXT:    cset w8, lt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %5 = and i64 %3, %4
  %6 = icmp sle i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint_inverse_4_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint_inverse_4_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    bic x8, x9, x8
; CHECK-NEXT:    cmp x8, #1
; CHECK-NEXT:    cset w8, lt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %not = xor i64 %4, -1
  %5 = and i64 %3, %not
  %6 = icmp sle i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint_inverse_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint_inverse_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    bics xzr, x9, x8
; CHECK-NEXT:    cset w8, eq
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %not = xor i64 %4, -1
  %5 = and i64 %3, %not
  %6 = icmp eq i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint2_inverse_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint2_inverse_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    bics xzr, x9, x8
; CHECK-NEXT:    cset w8, gt
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %not = xor i64 %4, -1
  %5 = and i64 %3, %not
  %6 = icmp sgt i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

define i1 @test_disjoint3_inverse_64(i1 %0, i64 %1, i64 %2) {
; CHECK-LABEL: test_disjoint3_inverse_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    orr x9, x2, #0x80000000000000
; CHECK-NEXT:    lsl x8, x8, x1
; CHECK-NEXT:    bics xzr, x9, x8
; CHECK-NEXT:    cset w8, mi
; CHECK-NEXT:    orr w8, w0, w8
; CHECK-NEXT:    and w0, w8, #0x1
; CHECK-NEXT:    ret
entry:
  %3 = or disjoint i64 %2, 36028797018963968
  %4 = shl nuw i64 1, %1
  %not = xor i64 %4, -1
  %5 = and i64 %3, %not
  %6 = icmp slt i64 %5, 0
  %7 = select i1 %0, i1 true, i1 %6
  ret i1 %7
}

; negative test
define i1 @lt3_u8(i8 %0) {
; CHECK-LABEL: lt3_u8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    and w8, w0, #0xff
; CHECK-NEXT:    cmp w8, #3
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i8 %0, 3
  ret i1 %2
}

; negative test
define i1 @lt3_u32(i32 %0) {
; CHECK-LABEL: lt3_u32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #3
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i32 %0, 3
  ret i1 %2
}

; negative test
define i1 @lt3_u64(i64 %0) {
; CHECK-LABEL: lt3_u64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp x0, #3
; CHECK-NEXT:    cset w0, lo
; CHECK-NEXT:    ret
  %2 = icmp ult i64 %0, 3
  ret i1 %2
}

; negative test
define i32 @lt32_u16_multiple_use(i32 %0) {
; CHECK-LABEL: lt32_u16_multiple_use:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #21 // =0x15
; CHECK-NEXT:    mov w9, #10 // =0xa
; CHECK-NEXT:    and w8, w0, w8
; CHECK-NEXT:    cmp w8, #16
; CHECK-NEXT:    orr w8, w8, w9
; CHECK-NEXT:    cset w10, lo
; CHECK-NEXT:    mul w0, w8, w10
; CHECK-NEXT:    ret
  %2 = and i32 %0, 21
  %3 = icmp ult i32 %2, 16
  %4 = add i32 %2, 10
  %5 = zext i1 %3 to i32
  %6 = mul i32 %4, %5
  ret i32 %6
}
