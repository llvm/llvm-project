; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64 -verify-machineinstrs < %s | FileCheck --check-prefix=CHECK --check-prefix=OPT %s
; RUN: llc -mtriple=aarch64 -verify-machineinstrs -O0 -fast-isel=0 -global-isel=false < %s | FileCheck --check-prefix=CHECK --check-prefix=NOOPT %s

declare void @foo()

; Check that the inverted or doesn't inhibit the splitting of the
; complex conditional into three branch instructions.
define void @test_and_not(i32 %a, i32 %b, i32 %c) {
; OPT-LABEL: test_and_not:
; OPT:       // %bb.0: // %bb1
; OPT-NEXT:    cbz w0, .LBB0_4
; OPT-NEXT:  // %bb.1: // %bb1
; OPT-NEXT:    cmp w1, #2
; OPT-NEXT:    b.lo .LBB0_4
; OPT-NEXT:  // %bb.2: // %bb1
; OPT-NEXT:    cmp w2, #2
; OPT-NEXT:    b.hi .LBB0_4
; OPT-NEXT:  // %bb.3: // %common.ret
; OPT-NEXT:    ret
; OPT-NEXT:  .LBB0_4: // %bb3
; OPT-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; OPT-NEXT:    .cfi_def_cfa_offset 16
; OPT-NEXT:    .cfi_offset w30, -16
; OPT-NEXT:    bl foo
; OPT-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; OPT-NEXT:    ret
;
; NOOPT-LABEL: test_and_not:
; NOOPT:       // %bb.0: // %bb1
; NOOPT-NEXT:    sub sp, sp, #32
; NOOPT-NEXT:    str x30, [sp, #16] // 8-byte Folded Spill
; NOOPT-NEXT:    .cfi_def_cfa_offset 32
; NOOPT-NEXT:    .cfi_offset w30, -16
; NOOPT-NEXT:    str w2, [sp, #8] // 4-byte Folded Spill
; NOOPT-NEXT:    str w1, [sp, #12] // 4-byte Folded Spill
; NOOPT-NEXT:    cbz w0, .LBB0_4
; NOOPT-NEXT:    b .LBB0_1
; NOOPT-NEXT:  .LBB0_1: // %bb1
; NOOPT-NEXT:    ldr w8, [sp, #12] // 4-byte Folded Reload
; NOOPT-NEXT:    cmp w8, #2
; NOOPT-NEXT:    b.lo .LBB0_4
; NOOPT-NEXT:    b .LBB0_2
; NOOPT-NEXT:  .LBB0_2: // %bb1
; NOOPT-NEXT:    ldr w8, [sp, #8] // 4-byte Folded Reload
; NOOPT-NEXT:    cmp w8, #2
; NOOPT-NEXT:    b.hi .LBB0_4
; NOOPT-NEXT:    b .LBB0_3
; NOOPT-NEXT:  .LBB0_3: // %bb2
; NOOPT-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; NOOPT-NEXT:    add sp, sp, #32
; NOOPT-NEXT:    ret
; NOOPT-NEXT:  .LBB0_4: // %bb3
; NOOPT-NEXT:    bl foo
; NOOPT-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; NOOPT-NEXT:    add sp, sp, #32
; NOOPT-NEXT:    ret
bb1:
  %cmp1 = icmp ult i32 %a, 1
  %cmp2 = icmp ult i32 %b, 2
  %cmp3 = icmp ult i32 %c, 3
  %or = or i1 %cmp1, %cmp2
  %not.or = xor i1 %or, -1
  %and = and i1 %not.or, %cmp3
  br i1 %and, label %bb2, label %bb3

bb2:
  ret void

bb3:
  call void @foo()
  ret void
}

; Check that non-canonicalized xor not is handled correctly by FindMergedConditions.
; CHECK-LABEL: test_and_not2:
; CHECK:       cbz w0, [[L:\.LBB[0-9_]+]]
; OPT:         cmp w1, #2
; NOOPT:       subs w{{[0-9]+}}, w{{[0-9]+}}, #2
; CHECK:       b.lo [[L]]
; OPT:         cmp w2, #2
; NOOPT:       subs w{{[0-9]+}}, w{{[0-9]+}}, #2
; CHECK:       b.hi [[L]]
define void @test_and_not2(i32 %a, i32 %b, i32 %c) {
; OPT-LABEL: test_and_not2:
; OPT:       // %bb.0: // %bb1
; OPT-NEXT:    cbz w0, .LBB1_4
; OPT-NEXT:  // %bb.1: // %bb1
; OPT-NEXT:    cmp w1, #2
; OPT-NEXT:    b.lo .LBB1_4
; OPT-NEXT:  // %bb.2: // %bb1
; OPT-NEXT:    cmp w2, #2
; OPT-NEXT:    b.hi .LBB1_4
; OPT-NEXT:  // %bb.3: // %common.ret
; OPT-NEXT:    ret
; OPT-NEXT:  .LBB1_4: // %bb3
; OPT-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; OPT-NEXT:    .cfi_def_cfa_offset 16
; OPT-NEXT:    .cfi_offset w30, -16
; OPT-NEXT:    bl foo
; OPT-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; OPT-NEXT:    ret
;
; NOOPT-LABEL: test_and_not2:
; NOOPT:       // %bb.0: // %bb1
; NOOPT-NEXT:    sub sp, sp, #32
; NOOPT-NEXT:    str x30, [sp, #16] // 8-byte Folded Spill
; NOOPT-NEXT:    .cfi_def_cfa_offset 32
; NOOPT-NEXT:    .cfi_offset w30, -16
; NOOPT-NEXT:    str w2, [sp, #8] // 4-byte Folded Spill
; NOOPT-NEXT:    str w1, [sp, #12] // 4-byte Folded Spill
; NOOPT-NEXT:    cbz w0, .LBB1_4
; NOOPT-NEXT:    b .LBB1_1
; NOOPT-NEXT:  .LBB1_1: // %bb1
; NOOPT-NEXT:    ldr w8, [sp, #12] // 4-byte Folded Reload
; NOOPT-NEXT:    cmp w8, #2
; NOOPT-NEXT:    b.lo .LBB1_4
; NOOPT-NEXT:    b .LBB1_2
; NOOPT-NEXT:  .LBB1_2: // %bb1
; NOOPT-NEXT:    ldr w8, [sp, #8] // 4-byte Folded Reload
; NOOPT-NEXT:    cmp w8, #2
; NOOPT-NEXT:    b.hi .LBB1_4
; NOOPT-NEXT:    b .LBB1_3
; NOOPT-NEXT:  .LBB1_3: // %bb2
; NOOPT-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; NOOPT-NEXT:    add sp, sp, #32
; NOOPT-NEXT:    ret
; NOOPT-NEXT:  .LBB1_4: // %bb3
; NOOPT-NEXT:    bl foo
; NOOPT-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; NOOPT-NEXT:    add sp, sp, #32
; NOOPT-NEXT:    ret
bb1:
  %cmp1 = icmp ult i32 %a, 1
  %cmp2 = icmp ult i32 %b, 2
  %cmp3 = icmp ult i32 %c, 3
  %or = or i1 %cmp1, %cmp2
  %not.or = xor i1 -1, %or
  %and = and i1 %not.or, %cmp3
  br i1 %and, label %bb2, label %bb3

bb2:
  ret void

bb3:
  call void @foo()
  ret void
}

; Check that cmps in different blocks are handled correctly by FindMergedConditions.
; CHECK-LABEL: test_cmp_other_block:
; OPT: cmp w{{[0-9]+}}, #0
; OPT: b.gt [[L:\.LBB[0-9_]+]]
; OPT: tbz w1, #0, [[L]]
;
; NOOPT: str w1, [sp, #[[SLOT2:[0-9]+]]]
; NOOPT: subs w{{[0-9]+}}, w{{[0-9]+}}, #0
; NOOPT: cset [[R1:w[0-9]+]], gt
; NOOPT: str [[R1]], [sp, #[[SLOT1:[0-9]+]]]
; NOOPT: b .LBB
; NOOPT: ldr [[R2:w[0-9]+]], [sp, #[[SLOT1]]]
; NOOPT: tbnz [[R2]], #0, [[L:\.LBB[0-9_]+]]
; NOOPT: ldr [[R3:w[0-9]+]], [sp, #[[SLOT2]]]
; NOOPT: tbz [[R3]], #0, [[L]]
define void @test_cmp_other_block(ptr %p, i1 %c) {
; OPT-LABEL: test_cmp_other_block:
; OPT:       // %bb.0: // %entry
; OPT-NEXT:    ldr w8, [x0]
; OPT-NEXT:    cmp w8, #0
; OPT-NEXT:    b.gt .LBB2_3
; OPT-NEXT:  // %bb.1: // %entry
; OPT-NEXT:    tbz w1, #0, .LBB2_3
; OPT-NEXT:  // %bb.2: // %common.ret
; OPT-NEXT:    ret
; OPT-NEXT:  .LBB2_3: // %bb3
; OPT-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; OPT-NEXT:    .cfi_def_cfa_offset 16
; OPT-NEXT:    .cfi_offset w30, -16
; OPT-NEXT:    bl foo
; OPT-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; OPT-NEXT:    ret
;
; NOOPT-LABEL: test_cmp_other_block:
; NOOPT:       // %bb.0: // %entry
; NOOPT-NEXT:    sub sp, sp, #32
; NOOPT-NEXT:    str x30, [sp, #16] // 8-byte Folded Spill
; NOOPT-NEXT:    .cfi_def_cfa_offset 32
; NOOPT-NEXT:    .cfi_offset w30, -16
; NOOPT-NEXT:    str w1, [sp, #8] // 4-byte Folded Spill
; NOOPT-NEXT:    ldr w8, [x0]
; NOOPT-NEXT:    cmp w8, #0
; NOOPT-NEXT:    cset w8, gt
; NOOPT-NEXT:    str w8, [sp, #12] // 4-byte Folded Spill
; NOOPT-NEXT:    b .LBB2_1
; NOOPT-NEXT:  .LBB2_1: // %bb1
; NOOPT-NEXT:    ldr w8, [sp, #12] // 4-byte Folded Reload
; NOOPT-NEXT:    tbnz w8, #0, .LBB2_4
; NOOPT-NEXT:    b .LBB2_2
; NOOPT-NEXT:  .LBB2_2: // %bb1
; NOOPT-NEXT:    ldr w8, [sp, #8] // 4-byte Folded Reload
; NOOPT-NEXT:    tbz w8, #0, .LBB2_4
; NOOPT-NEXT:    b .LBB2_3
; NOOPT-NEXT:  .LBB2_3: // %bb2
; NOOPT-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; NOOPT-NEXT:    add sp, sp, #32
; NOOPT-NEXT:    ret
; NOOPT-NEXT:  .LBB2_4: // %bb3
; NOOPT-NEXT:    bl foo
; NOOPT-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; NOOPT-NEXT:    add sp, sp, #32
; NOOPT-NEXT:    ret
entry:
  %l = load i32, ptr %p
  %cmp = icmp sgt i32 %l, 0
  br label %bb1

bb1:
  %cmp.i = xor i1 %cmp, true
  %or.cond1.i = and i1 %cmp.i, %c
  br i1 %or.cond1.i, label %bb2, label %bb3

bb2:
  ret void

bb3:
  call void @foo()
  ret void
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
