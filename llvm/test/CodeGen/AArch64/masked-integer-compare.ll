; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64-none-linux-gnu < %s -o -| FileCheck %s

; Test code generation support for SUBS (shifted register) from masked integer
; compare sequences. These sequences appear in isinf tests, for example.

define i1 @combine_masked_i32(i32 %x) {
; CHECK-LABEL: combine_masked_i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #-16777216 // =0xff000000
; CHECK-NEXT:    cmp w8, w0, lsl #1
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7fffffff
  %sub = sub i32 %and, u0x7f800000
  %cmp = icmp eq i32 %sub, 0
  ret i1 %cmp
}

define i1 @combine_masked_i64(i64 %x) {
; CHECK-LABEL: combine_masked_i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, #-9007199254740992 // =0xffe0000000000000
; CHECK-NEXT:    cmp x8, x0, lsl #1
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i64 %x, u0x7fffffffffffffff
  %sub = sub i64 %and, u0x7ff0000000000000
  %cmp = icmp eq i64 %sub, 0
  ret i1 %cmp
}

define i1 @combine_masked_ne(i32 %x) {
; CHECK-LABEL: combine_masked_ne:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #-16777216 // =0xff000000
; CHECK-NEXT:    cmp w8, w0, lsl #1
; CHECK-NEXT:    cset w0, ne
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7fffffff
  %cmp = icmp ne i32 %and, u0x7f800000
  ret i1 %cmp
}

define i1 @combine_masked_lsl4(i32 %x) {
; CHECK-LABEL: combine_masked_lsl4:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #-134217728 // =0xf8000000
; CHECK-NEXT:    cmp w8, w0, lsl #4
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x0fffffff
  %cmp = icmp eq i32 %and, u0x0f800000
  ret i1 %cmp
}

define i1 @dont_combine_not_mask(i32 %x) {
; CHECK-LABEL: dont_combine_not_mask:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #2139095040 // =0x7f800000
; CHECK-NEXT:    and w9, w0, #0x7ffffffe
; CHECK-NEXT:    cmp w9, w8
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7ffffffe
  %cmp = icmp eq i32 %and, u0x7f800000
  ret i1 %cmp
}

define i1 @dont_combine_cmp_not_masked(i32 %x) {
; CHECK-LABEL: dont_combine_cmp_not_masked:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #2139095040 // =0x7f800000
; CHECK-NEXT:    and w9, w0, #0x3fffffff
; CHECK-NEXT:    cmp w9, w8
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x3fffffff
  %cmp = icmp eq i32 %and, u0x7f800000
  ret i1 %cmp
}

define i1 @dont_combine_not_constant_mask(i32 %x, i32 %m) {
; CHECK-LABEL: dont_combine_not_constant_mask:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #2139095040 // =0x7f800000
; CHECK-NEXT:    and w9, w0, w1
; CHECK-NEXT:    cmp w9, w8
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, %m
  %cmp = icmp eq i32 %and, u0x7f800000
  ret i1 %cmp
}

define i1 @dont_combine_not_constant_cmp(i32 %x, i32 %c) {
; CHECK-LABEL: dont_combine_not_constant_cmp:
; CHECK:       // %bb.0:
; CHECK-NEXT:    and w8, w0, #0xfffffff
; CHECK-NEXT:    cmp w8, w1
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x0fffffff
  %cmp = icmp eq i32 %and, %c
  ret i1 %cmp
}

define i1 @dont_combine_subs_imm(i32 %x) {
; CHECK-LABEL: dont_combine_subs_imm:
; CHECK:       // %bb.0:
; CHECK-NEXT:    and w8, w0, #0x7fffffff
; CHECK-NEXT:    cmp w8, #291
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7fffffff
  %cmp = icmp eq i32 %and, u0x123
  ret i1 %cmp
}

define i1 @dont_combine_subs_imm_lsl12(i32 %x) {
; CHECK-LABEL: dont_combine_subs_imm_lsl12:
; CHECK:       // %bb.0:
; CHECK-NEXT:    and w8, w0, #0x7fffffff
; CHECK-NEXT:    cmp w8, #291, lsl #12 // =1191936
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7fffffff
  %cmp = icmp eq i32 %and, u0x123000
  ret i1 %cmp
}

define { i1, i1 } @dont_combine_multi_use_cmp(i32 %x) {
; CHECK-LABEL: dont_combine_multi_use_cmp:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #2139095040 // =0x7f800000
; CHECK-NEXT:    and w9, w0, #0x7fffffff
; CHECK-NEXT:    cmp w9, w8
; CHECK-NEXT:    cset w0, eq
; CHECK-NEXT:    cset w1, lt
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7fffffff
  %eq = icmp eq i32 %and, u0x7f800000
  %lt = icmp slt i32 %and, u0x7f800000
  %r1 = insertvalue { i1, i1 } poison, i1 %eq, 0
  %r2 = insertvalue { i1, i1 } %r1, i1 %lt, 1
  ret { i1, i1 } %r2
}

define { i32, i1 } @dont_combine_multi_use_sub(i32 %x) {
; CHECK-LABEL: dont_combine_multi_use_sub:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #-2139095040 // =0x80800000
; CHECK-NEXT:    and w9, w0, #0x7fffffff
; CHECK-NEXT:    adds w0, w9, w8
; CHECK-NEXT:    cset w1, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7fffffff
  %sub = sub i32 %and, u0x7f800000
  %cmp = icmp eq i32 %sub, 0
  %r1 = insertvalue { i32, i1 } poison, i32 %sub, 0
  %r2 = insertvalue { i32, i1 } %r1, i1 %cmp, 1
  ret { i32, i1 } %r2
}

define { i32, i1 } @dont_combine_multi_use_and(i32 %x) {
; CHECK-LABEL: dont_combine_multi_use_and:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #2139095040 // =0x7f800000
; CHECK-NEXT:    and w0, w0, #0x7fffffff
; CHECK-NEXT:    cmp w0, w8
; CHECK-NEXT:    cset w1, eq
; CHECK-NEXT:    ret
  %and = and i32 %x, u0x7fffffff
  %cmp = icmp eq i32 %and, u0x7f800000
  %r1 = insertvalue { i32, i1 } poison, i32 %and, 0
  %r2 = insertvalue { i32, i1 } %r1, i1 %cmp, 1
  ret { i32, i1 } %r2
}
