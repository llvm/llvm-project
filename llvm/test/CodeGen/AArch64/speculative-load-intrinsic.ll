; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-unknown-linux-gnu < %s | FileCheck %s

; Test that @llvm.speculative.load is lowered to a regular load
; in SelectionDAG, respecting the alignment attribute.

define <4 x i32> @speculative_load_v4i32_align16(ptr %ptr) {
; CHECK-LABEL: speculative_load_v4i32_align16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ret
  %load = call <4 x i32> @llvm.speculative.load.v4i32.p0(ptr align 16 %ptr)
  ret <4 x i32> %load
}

define <4 x i32> @speculative_load_v4i32_align4(ptr %ptr) {
; CHECK-LABEL: speculative_load_v4i32_align4:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ret
  %load = call <4 x i32> @llvm.speculative.load.v4i32.p0(ptr align 4 %ptr)
  ret <4 x i32> %load
}

define <4 x i32> @speculative_load_v4i32_noalign(ptr %ptr) {
; CHECK-LABEL: speculative_load_v4i32_noalign:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ret
  %load = call <4 x i32> @llvm.speculative.load.v4i32.p0(ptr %ptr)
  ret <4 x i32> %load
}

define <8 x i32> @speculative_load_v8i32(ptr %ptr) {
; CHECK-LABEL: speculative_load_v8i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldp q0, q1, [x0]
; CHECK-NEXT:    ret
  %load = call <8 x i32> @llvm.speculative.load.v8i32.p0(ptr align 32 %ptr)
  ret <8 x i32> %load
}

define <2 x i64> @speculative_load_v2i64(ptr %ptr) {
; CHECK-LABEL: speculative_load_v2i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ret
  %load = call <2 x i64> @llvm.speculative.load.v2i64.p0(ptr %ptr)
  ret <2 x i64> %load
}

define <4 x float> @speculative_load_v4f32(ptr %ptr) {
; CHECK-LABEL: speculative_load_v4f32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ret
  %load = call <4 x float> @llvm.speculative.load.v4f32.p0(ptr align 8 %ptr)
  ret <4 x float> %load
}

define <2 x double> @speculative_load_v2f64(ptr %ptr) {
; CHECK-LABEL: speculative_load_v2f64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ret
  %load = call <2 x double> @llvm.speculative.load.v2f64.p0(ptr align 16 %ptr)
  ret <2 x double> %load
}

declare <4 x i32> @llvm.speculative.load.v4i32.p0(ptr)
declare <8 x i32> @llvm.speculative.load.v8i32.p0(ptr)
declare <2 x i64> @llvm.speculative.load.v2i64.p0(ptr)
declare <4 x float> @llvm.speculative.load.v4f32.p0(ptr)
declare <2 x double> @llvm.speculative.load.v2f64.p0(ptr)

; Scalar type tests

define i32 @speculative_load_i32(ptr %ptr) {
; CHECK-LABEL: speculative_load_i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr w0, [x0]
; CHECK-NEXT:    ret
  %load = call i32 @llvm.speculative.load.i32.p0(ptr align 4 %ptr)
  ret i32 %load
}

define i64 @speculative_load_i64(ptr %ptr) {
; CHECK-LABEL: speculative_load_i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr x0, [x0]
; CHECK-NEXT:    ret
  %load = call i64 @llvm.speculative.load.i64.p0(ptr %ptr)
  ret i64 %load
}

define float @speculative_load_f32(ptr %ptr) {
; CHECK-LABEL: speculative_load_f32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr s0, [x0]
; CHECK-NEXT:    ret
  %load = call float @llvm.speculative.load.f32.p0(ptr %ptr)
  ret float %load
}

define double @speculative_load_f64(ptr %ptr) {
; CHECK-LABEL: speculative_load_f64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ldr d0, [x0]
; CHECK-NEXT:    ret
  %load = call double @llvm.speculative.load.f64.p0(ptr align 8 %ptr)
  ret double %load
}

declare i32 @llvm.speculative.load.i32.p0(ptr)
declare i64 @llvm.speculative.load.i64.p0(ptr)
declare float @llvm.speculative.load.f32.p0(ptr)
declare double @llvm.speculative.load.f64.p0(ptr)
