; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: not --crash llc -o - -mtriple=arm64e-apple-macosx -aarch64-min-jump-table-entries=2 %s
; REQUIRES: asserts

target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"

define swifttailcc void @test_async_with_jumptable_x16_clobbered(ptr %src, ptr swiftasync %as) #0 {
entry:
  %x16 = tail call i64 asm "", "={x16}"()
  %l = load i64, ptr %src, align 8
  switch i64 %l, label %dead [
    i64 0, label %exit
    i64 1, label %then.1
    i64 2, label %then.2
    i64 3, label %then.3
  ]

then.1:
  br label %exit

then.2:
  br label %exit

then.3:
  br label %exit

dead:                                                ; preds = %entryresume.5
  unreachable

exit:
  %p = phi ptr [ %src, %then.3 ], [ null, %then.2 ], [ %as, %entry ], [ null, %then.1 ]
  tail call void asm sideeffect "", "{x16}"(i64 %x16)
  %r = call i64 @foo()
  %fn = inttoptr i64 %r to ptr
  musttail call swifttailcc void %fn(ptr swiftasync %src, ptr %p, ptr %as)
  ret void
}

define swifttailcc void @test_async_with_jumptable_x17_clobbered(ptr %src, ptr swiftasync %as) #0 {
entry:
  %x17 = tail call i64 asm "", "={x17}"()
  %l = load i64, ptr %src, align 8
  switch i64 %l, label %dead [
    i64 0, label %exit
    i64 1, label %then.1
    i64 2, label %then.2
    i64 3, label %then.3
  ]

then.1:
  br label %exit

then.2:
  br label %exit

then.3:
  br label %exit

dead:                                                ; preds = %entryresume.5
  unreachable

exit:
  %p = phi ptr [ %src, %then.3 ], [ null, %then.2 ], [ %as, %entry ], [ null, %then.1 ]
  tail call void asm sideeffect "", "{x17}"(i64 %x17)
  %r = call i64 @foo()
  %fn = inttoptr i64 %r to ptr
  musttail call swifttailcc void %fn(ptr swiftasync %src, ptr %p, ptr %as)
  ret void
}

define swifttailcc void @test_async_with_jumptable_x1_clobbered(ptr %src, ptr swiftasync %as) #0 {
entry:
  %x1 = tail call i64 asm "", "={x1}"()
  %l = load i64, ptr %src, align 8
  switch i64 %l, label %dead [
    i64 0, label %exit
    i64 1, label %then.1
    i64 2, label %then.2
    i64 3, label %then.3
  ]

then.1:
  br label %exit

then.2:
  br label %exit

then.3:
  br label %exit

dead:                                                ; preds = %entryresume.5
  unreachable

exit:
  %p = phi ptr [ %src, %then.3 ], [ null, %then.2 ], [ %as, %entry ], [ null, %then.1 ]
  tail call void asm sideeffect "", "{x1}"(i64 %x1)
  %r = call i64 @foo()
  %fn = inttoptr i64 %r to ptr
  musttail call swifttailcc void %fn(ptr swiftasync %src, ptr %p, ptr %as)
  ret void
}

define swifttailcc void @test_async_with_jumptable_x1_x9_clobbered(ptr %src, ptr swiftasync %as) #0 {
entry:
  %x1 = tail call i64 asm "", "={x1}"()
  %x9 = tail call i64 asm "", "={x9}"()
  %l = load i64, ptr %src, align 8
  switch i64 %l, label %dead [
    i64 0, label %exit
    i64 1, label %then.1
    i64 2, label %then.2
    i64 3, label %then.3
  ]

then.1:
  br label %exit

then.2:
  br label %exit

then.3:
  br label %exit

dead:                                                ; preds = %entryresume.5
  unreachable

exit:
  %p = phi ptr [ %src, %then.3 ], [ null, %then.2 ], [ %as, %entry ], [ null, %then.1 ]
  tail call void asm sideeffect "", "{x1}"(i64 %x1)
  tail call void asm sideeffect "", "{x9}"(i64 %x9)
  %r = call i64 @foo()
  %fn = inttoptr i64 %r to ptr
  musttail call swifttailcc void %fn(ptr swiftasync %src, ptr %p, ptr %as)
  ret void
}

; There are 2 available scratch registers left, shrink-wrapping can happen.
define swifttailcc void @test_async_with_jumptable_2_available_regs_left(ptr %src, ptr swiftasync %as) #0 {
entry:
  %x1 = tail call i64 asm "", "={x1}"()
  %x2 = tail call i64 asm "", "={x2}"()
  %x3 = tail call i64 asm "", "={x3}"()
  %x4 = tail call i64 asm "", "={x4}"()
  %x5 = tail call i64 asm "", "={x5}"()
  %x6 = tail call i64 asm "", "={x6}"()
  %x7 = tail call i64 asm "", "={x7}"()
  %x8 = tail call i64 asm "", "={x8}"()
  %x9 = tail call i64 asm "", "={x9}"()
  %x11 = tail call i64 asm "", "={x11}"()
  %x12 = tail call i64 asm "", "={x12}"()
  %x13 = tail call i64 asm "", "={x13}"()
  %x14 = tail call i64 asm "", "={x14}"()
  %x15 = tail call i64 asm "", "={x15}"()
  %x16 = tail call i64 asm "", "={x16}"()
  %l = load i64, ptr %src, align 8
  switch i64 %l, label %dead [
    i64 0, label %exit
    i64 1, label %then.1
    i64 2, label %then.2
    i64 3, label %then.3
  ]

then.1:
  br label %exit

then.2:
  br label %exit

then.3:
  br label %exit

dead:                                                ; preds = %entryresume.5
  unreachable

exit:
  %p = phi ptr [ %src, %then.3 ], [ null, %then.2 ], [ %as, %entry ], [ null, %then.1 ]
  tail call void asm sideeffect "", "{x1}"(i64 %x1)
  tail call void asm sideeffect "", "{x2}"(i64 %x2)
  tail call void asm sideeffect "", "{x3}"(i64 %x3)
  tail call void asm sideeffect "", "{x4}"(i64 %x4)
  tail call void asm sideeffect "", "{x5}"(i64 %x5)
  tail call void asm sideeffect "", "{x6}"(i64 %x6)
  tail call void asm sideeffect "", "{x7}"(i64 %x7)
  tail call void asm sideeffect "", "{x8}"(i64 %x8)
  tail call void asm sideeffect "", "{x9}"(i64 %x9)
  tail call void asm sideeffect "", "{x11}"(i64 %x11)
  tail call void asm sideeffect "", "{x12}"(i64 %x12)
  tail call void asm sideeffect "", "{x13}"(i64 %x13)
  tail call void asm sideeffect "", "{x14}"(i64 %x14)
  tail call void asm sideeffect "", "{x15}"(i64 %x15)
  tail call void asm sideeffect "", "{x16}"(i64 %x16)
  %r = call i64 @foo()
  %fn = inttoptr i64 %r to ptr
  musttail call swifttailcc void %fn(ptr swiftasync %src, ptr %p, ptr %as)
  ret void
}

; There is only 1 available scratch registers left, shrink-wrapping cannot
; happen because StoreSwiftAsyncContext needs 2 free scratch registers.
define swifttailcc void @test_async_with_jumptable_1_available_reg_left(ptr %src, ptr swiftasync %as) #0 {
entry:
  %x1 = tail call i64 asm "", "={x1}"()
  %x2 = tail call i64 asm "", "={x2}"()
  %x3 = tail call i64 asm "", "={x3}"()
  %x4 = tail call i64 asm "", "={x4}"()
  %x5 = tail call i64 asm "", "={x5}"()
  %x6 = tail call i64 asm "", "={x6}"()
  %x7 = tail call i64 asm "", "={x7}"()
  %x8 = tail call i64 asm "", "={x8}"()
  %x9 = tail call i64 asm "", "={x9}"()
  %x11 = tail call i64 asm "", "={x11}"()
  %x12 = tail call i64 asm "", "={x12}"()
  %x13 = tail call i64 asm "", "={x13}"()
  %x14 = tail call i64 asm "", "={x14}"()
  %x15 = tail call i64 asm "", "={x15}"()
  %x16 = tail call i64 asm "", "={x16}"()
  %x17 = tail call i64 asm "", "={x17}"()
  %l = load i64, ptr %src, align 8
  switch i64 %l, label %dead [
    i64 0, label %exit
    i64 1, label %then.1
    i64 2, label %then.2
    i64 3, label %then.3
  ]

then.1:
  br label %exit

then.2:
  br label %exit

then.3:
  br label %exit

dead:                                                ; preds = %entryresume.5
  unreachable

exit:
  %p = phi ptr [ %src, %then.3 ], [ null, %then.2 ], [ %as, %entry ], [ null, %then.1 ]
  tail call void asm sideeffect "", "{x1}"(i64 %x1)
  tail call void asm sideeffect "", "{x2}"(i64 %x2)
  tail call void asm sideeffect "", "{x3}"(i64 %x3)
  tail call void asm sideeffect "", "{x4}"(i64 %x4)
  tail call void asm sideeffect "", "{x5}"(i64 %x5)
  tail call void asm sideeffect "", "{x6}"(i64 %x6)
  tail call void asm sideeffect "", "{x7}"(i64 %x7)
  tail call void asm sideeffect "", "{x8}"(i64 %x8)
  tail call void asm sideeffect "", "{x9}"(i64 %x9)
  tail call void asm sideeffect "", "{x11}"(i64 %x11)
  tail call void asm sideeffect "", "{x12}"(i64 %x12)
  tail call void asm sideeffect "", "{x13}"(i64 %x13)
  tail call void asm sideeffect "", "{x14}"(i64 %x14)
  tail call void asm sideeffect "", "{x15}"(i64 %x15)
  tail call void asm sideeffect "", "{x16}"(i64 %x16)
  tail call void asm sideeffect "", "{x17}"(i64 %x17)
  %r = call i64 @foo()
  %fn = inttoptr i64 %r to ptr
  musttail call swifttailcc void %fn(ptr swiftasync %src, ptr %p, ptr %as)
  ret void
}

declare i64 @foo()

attributes #0 = { "frame-pointer"="non-leaf" }
