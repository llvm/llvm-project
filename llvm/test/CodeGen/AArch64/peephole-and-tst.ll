; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64-- | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc < %s -mtriple=aarch64-- -global-isel | FileCheck %s --check-prefixes=CHECK,CHECK-GI

%struct.anon = type { ptr, ptr }

@ptr_wrapper = common global ptr null, align 8

define i32 @test_func_i32_two_uses(i32 %in, i32 %bit, i32 %mask) {
; CHECK-SD-LABEL: test_func_i32_two_uses:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    adrp x8, :got:ptr_wrapper
; CHECK-SD-NEXT:    ldr x8, [x8, :got_lo12:ptr_wrapper]
; CHECK-SD-NEXT:    ldr x9, [x8]
; CHECK-SD-NEXT:    mov w8, wzr
; CHECK-SD-NEXT:    b .LBB0_3
; CHECK-SD-NEXT:  .LBB0_1: // in Loop: Header=BB0_3 Depth=1
; CHECK-SD-NEXT:    str xzr, [x9, #8]
; CHECK-SD-NEXT:  .LBB0_2: // in Loop: Header=BB0_3 Depth=1
; CHECK-SD-NEXT:    lsl w1, w1, #1
; CHECK-SD-NEXT:    cbz w1, .LBB0_6
; CHECK-SD-NEXT:  .LBB0_3: // %do.body
; CHECK-SD-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-SD-NEXT:    ands w10, w1, w0
; CHECK-SD-NEXT:    and w11, w2, w0
; CHECK-SD-NEXT:    cinc w8, w8, ne
; CHECK-SD-NEXT:    cmp w10, w11
; CHECK-SD-NEXT:    b.eq .LBB0_1
; CHECK-SD-NEXT:  // %bb.4: // %do.body
; CHECK-SD-NEXT:    // in Loop: Header=BB0_3 Depth=1
; CHECK-SD-NEXT:    cbnz w2, .LBB0_1
; CHECK-SD-NEXT:  // %bb.5: // %do.body
; CHECK-SD-NEXT:    // in Loop: Header=BB0_3 Depth=1
; CHECK-SD-NEXT:    cbz w10, .LBB0_2
; CHECK-SD-NEXT:    b .LBB0_1
; CHECK-SD-NEXT:  .LBB0_6: // %do.end
; CHECK-SD-NEXT:    mov w0, w8
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_func_i32_two_uses:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    adrp x8, :got:ptr_wrapper
; CHECK-GI-NEXT:    ldr x8, [x8, :got_lo12:ptr_wrapper]
; CHECK-GI-NEXT:    ldr x9, [x8]
; CHECK-GI-NEXT:    mov w8, wzr
; CHECK-GI-NEXT:    b .LBB0_3
; CHECK-GI-NEXT:  .LBB0_1: // in Loop: Header=BB0_3 Depth=1
; CHECK-GI-NEXT:    str xzr, [x9, #8]
; CHECK-GI-NEXT:  .LBB0_2: // in Loop: Header=BB0_3 Depth=1
; CHECK-GI-NEXT:    lsl w1, w1, #1
; CHECK-GI-NEXT:    cbz w1, .LBB0_6
; CHECK-GI-NEXT:  .LBB0_3: // %do.body
; CHECK-GI-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-GI-NEXT:    and w10, w1, w0
; CHECK-GI-NEXT:    tst w1, w0
; CHECK-GI-NEXT:    and w11, w2, w0
; CHECK-GI-NEXT:    cinc w8, w8, ne
; CHECK-GI-NEXT:    cmp w10, w11
; CHECK-GI-NEXT:    b.eq .LBB0_1
; CHECK-GI-NEXT:  // %bb.4: // %do.body
; CHECK-GI-NEXT:    // in Loop: Header=BB0_3 Depth=1
; CHECK-GI-NEXT:    cbnz w2, .LBB0_1
; CHECK-GI-NEXT:  // %bb.5: // %do.body
; CHECK-GI-NEXT:    // in Loop: Header=BB0_3 Depth=1
; CHECK-GI-NEXT:    cbz w10, .LBB0_2
; CHECK-GI-NEXT:    b .LBB0_1
; CHECK-GI-NEXT:  .LBB0_6: // %do.end
; CHECK-GI-NEXT:    mov w0, w8
; CHECK-GI-NEXT:    ret
entry:
  %0 = load ptr, ptr @ptr_wrapper, align 8
  %result = getelementptr inbounds %struct.anon, ptr %0, i64 0, i32 1
  %tobool2 = icmp ne i32 %mask, 0
  br label %do.body

do.body:                                          ; preds = %4, %entry
  %bit.addr.0 = phi i32 [ %bit, %entry ], [ %shl, %4 ]
  %retval1.0 = phi i32 [ 0, %entry ], [ %retval1.1, %4 ]
  %and = and i32 %bit.addr.0, %in
  %tobool = icmp eq i32 %and, 0
  %not.tobool = xor i1 %tobool, true
  %inc = zext i1 %not.tobool to i32
  %retval1.1 = add nuw nsw i32 %retval1.0, %inc
  %1 = xor i1 %tobool, true
  %2 = or i1 %tobool2, %1
  %dummy = and i32 %mask, %in
  %use_and = icmp eq i32 %and, %dummy
  %dummy_or = or i1 %use_and, %2
  br i1 %dummy_or, label %3, label %4

3:                                                ; preds = %do.body
  store ptr null, ptr %result, align 8
  br label %4

4:                                                ; preds = %do.body, %3
  %shl = shl i32 %bit.addr.0, 1
  %tobool6 = icmp eq i32 %shl, 0
  br i1 %tobool6, label %do.end, label %do.body

do.end:                                           ; preds = %4
  ret i32 %retval1.1
}

define i32 @test_func_i64_one_use(i64 %in, i64 %bit, i64 %mask) {
; CHECK-SD-LABEL: test_func_i64_one_use:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    adrp x8, :got:ptr_wrapper
; CHECK-SD-NEXT:    ldr x8, [x8, :got_lo12:ptr_wrapper]
; CHECK-SD-NEXT:    ldr x9, [x8]
; CHECK-SD-NEXT:    mov w8, wzr
; CHECK-SD-NEXT:    b .LBB1_2
; CHECK-SD-NEXT:  .LBB1_1: // in Loop: Header=BB1_2 Depth=1
; CHECK-SD-NEXT:    lsl x1, x1, #1
; CHECK-SD-NEXT:    cbz x1, .LBB1_4
; CHECK-SD-NEXT:  .LBB1_2: // %do.body
; CHECK-SD-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-SD-NEXT:    ands x10, x1, x0
; CHECK-SD-NEXT:    orr x10, x2, x10
; CHECK-SD-NEXT:    cinc w8, w8, ne
; CHECK-SD-NEXT:    cbz x10, .LBB1_1
; CHECK-SD-NEXT:  // %bb.3: // in Loop: Header=BB1_2 Depth=1
; CHECK-SD-NEXT:    str xzr, [x9, #8]
; CHECK-SD-NEXT:    b .LBB1_1
; CHECK-SD-NEXT:  .LBB1_4: // %do.end
; CHECK-SD-NEXT:    mov w0, w8
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_func_i64_one_use:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    adrp x8, :got:ptr_wrapper
; CHECK-GI-NEXT:    ldr x8, [x8, :got_lo12:ptr_wrapper]
; CHECK-GI-NEXT:    ldr x9, [x8]
; CHECK-GI-NEXT:    mov w8, wzr
; CHECK-GI-NEXT:    b .LBB1_2
; CHECK-GI-NEXT:  .LBB1_1: // in Loop: Header=BB1_2 Depth=1
; CHECK-GI-NEXT:    lsl x1, x1, #1
; CHECK-GI-NEXT:    cbz x1, .LBB1_4
; CHECK-GI-NEXT:  .LBB1_2: // %do.body
; CHECK-GI-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-GI-NEXT:    and x10, x1, x0
; CHECK-GI-NEXT:    tst x1, x0
; CHECK-GI-NEXT:    orr x10, x2, x10
; CHECK-GI-NEXT:    cinc w8, w8, ne
; CHECK-GI-NEXT:    cbz x10, .LBB1_1
; CHECK-GI-NEXT:  // %bb.3: // in Loop: Header=BB1_2 Depth=1
; CHECK-GI-NEXT:    str xzr, [x9, #8]
; CHECK-GI-NEXT:    b .LBB1_1
; CHECK-GI-NEXT:  .LBB1_4: // %do.end
; CHECK-GI-NEXT:    mov w0, w8
; CHECK-GI-NEXT:    ret
entry:
  %0 = load ptr, ptr @ptr_wrapper, align 8
  %result = getelementptr inbounds %struct.anon, ptr %0, i64 0, i32 1
  %tobool2 = icmp ne i64 %mask, 0
  br label %do.body

do.body:                                          ; preds = %4, %entry
  %bit.addr.0 = phi i64 [ %bit, %entry ], [ %shl, %4 ]
  %retval1.0 = phi i32 [ 0, %entry ], [ %retval1.1, %4 ]
  %and = and i64 %bit.addr.0, %in
  %tobool = icmp eq i64 %and, 0
  %not.tobool = xor i1 %tobool, true
  %inc = zext i1 %not.tobool to i32
  %retval1.1 = add nuw nsw i32 %retval1.0, %inc
  %1 = xor i1 %tobool, true
  %2 = or i1 %tobool2, %1
  br i1 %2, label %3, label %4

3:                                                ; preds = %do.body
  store ptr null, ptr %result, align 8
  br label %4

4:                                                ; preds = %do.body, %3
  %shl = shl i64 %bit.addr.0, 1
  %tobool6 = icmp eq i64 %shl, 0
  br i1 %tobool6, label %do.end, label %do.body

do.end:                                           ; preds = %4
  ret i32 %retval1.1
}

define i64 @test_and1(i64 %x, i64 %y) {
; CHECK-SD-LABEL: test_and1:
; CHECK-SD:       // %bb.0:
; CHECK-SD-NEXT:    ands x8, x0, #0x3
; CHECK-SD-NEXT:    csel x0, x8, x1, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_and1:
; CHECK-GI:       // %bb.0:
; CHECK-GI-NEXT:    and x8, x0, #0x3
; CHECK-GI-NEXT:    tst x0, #0x3
; CHECK-GI-NEXT:    csel x0, x8, x1, eq
; CHECK-GI-NEXT:    ret
  %a = and i64 %x, 3
  %c = icmp eq i64 %a, 0
  %s = select i1 %c, i64 %a, i64 %y
  ret i64 %s
}

define i64 @test_and2(i64 %x, i64 %y) {
; CHECK-LABEL: test_and2:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tst x0, #0x3
; CHECK-NEXT:    csel x0, x0, x1, eq
; CHECK-NEXT:    ret
  %a = and i64 %x, 3
  %c = icmp eq i64 %a, 0
  %s = select i1 %c, i64 %x, i64 %y
  ret i64 %s
}

define i64 @test_and3(i64 %x, i64 %y) {
; CHECK-SD-LABEL: test_and3:
; CHECK-SD:       // %bb.0:
; CHECK-SD-NEXT:    str x30, [sp, #-32]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    stp x20, x19, [sp, #16] // 16-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 32
; CHECK-SD-NEXT:    .cfi_offset w19, -8
; CHECK-SD-NEXT:    .cfi_offset w20, -16
; CHECK-SD-NEXT:    .cfi_offset w30, -32
; CHECK-SD-NEXT:    mov x20, x0
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    mov x19, x1
; CHECK-SD-NEXT:    bl callee
; CHECK-SD-NEXT:    ands x8, x20, #0x3
; CHECK-SD-NEXT:    csel x0, x8, x19, eq
; CHECK-SD-NEXT:    ldp x20, x19, [sp, #16] // 16-byte Folded Reload
; CHECK-SD-NEXT:    ldr x30, [sp], #32 // 8-byte Folded Reload
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_and3:
; CHECK-GI:       // %bb.0:
; CHECK-GI-NEXT:    stp x30, x21, [sp, #-32]! // 16-byte Folded Spill
; CHECK-GI-NEXT:    stp x20, x19, [sp, #16] // 16-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 32
; CHECK-GI-NEXT:    .cfi_offset w19, -8
; CHECK-GI-NEXT:    .cfi_offset w20, -16
; CHECK-GI-NEXT:    .cfi_offset w21, -24
; CHECK-GI-NEXT:    .cfi_offset w30, -32
; CHECK-GI-NEXT:    mov x19, x0
; CHECK-GI-NEXT:    and x21, x0, #0x3
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    mov x20, x1
; CHECK-GI-NEXT:    bl callee
; CHECK-GI-NEXT:    tst x19, #0x3
; CHECK-GI-NEXT:    csel x0, x21, x20, eq
; CHECK-GI-NEXT:    ldp x20, x19, [sp, #16] // 16-byte Folded Reload
; CHECK-GI-NEXT:    ldp x30, x21, [sp], #32 // 16-byte Folded Reload
; CHECK-GI-NEXT:    ret
  %a = and i64 %x, 3
  %b = call i64 @callee(i64 0)
  %c = icmp eq i64 %a, 0
  %s = select i1 %c, i64 %a, i64 %y
  ret i64 %s
}

define i64 @test_and_4(i64 %x, i64 %y) {
; CHECK-SD-LABEL: test_and_4:
; CHECK-SD:       // %bb.0:
; CHECK-SD-NEXT:    stp x30, x19, [sp, #-16]! // 16-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w19, -8
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    mov x19, x0
; CHECK-SD-NEXT:    ands x0, x0, #0x3
; CHECK-SD-NEXT:    bl callee
; CHECK-SD-NEXT:    ands x8, x19, #0x3
; CHECK-SD-NEXT:    csel x0, x8, x0, eq
; CHECK-SD-NEXT:    ldp x30, x19, [sp], #16 // 16-byte Folded Reload
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_and_4:
; CHECK-GI:       // %bb.0:
; CHECK-GI-NEXT:    str x30, [sp, #-32]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    stp x20, x19, [sp, #16] // 16-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 32
; CHECK-GI-NEXT:    .cfi_offset w19, -8
; CHECK-GI-NEXT:    .cfi_offset w20, -16
; CHECK-GI-NEXT:    .cfi_offset w30, -32
; CHECK-GI-NEXT:    and x20, x0, #0x3
; CHECK-GI-NEXT:    mov x19, x0
; CHECK-GI-NEXT:    mov x0, x20
; CHECK-GI-NEXT:    bl callee
; CHECK-GI-NEXT:    tst x19, #0x3
; CHECK-GI-NEXT:    csel x0, x20, x0, eq
; CHECK-GI-NEXT:    ldp x20, x19, [sp, #16] // 16-byte Folded Reload
; CHECK-GI-NEXT:    ldr x30, [sp], #32 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
  %a = and i64 %x, 3
  %b = call i64 @callee(i64 %a)
  %c = icmp eq i64 %a, 0
  %s = select i1 %c, i64 %a, i64 %b
  ret i64 %s
}

define i64 @test_add(i64 %x, i64 %y) {
; CHECK-LABEL: test_add:
; CHECK:       // %bb.0:
; CHECK-NEXT:    stp x30, x19, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    add x19, x0, #3
; CHECK-NEXT:    mov x0, xzr
; CHECK-NEXT:    bl callee
; CHECK-NEXT:    cmp x19, #0
; CHECK-NEXT:    csel x0, x19, x0, eq
; CHECK-NEXT:    ldp x30, x19, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    ret
  %a = add i64 %x, 3
  %b = call i64 @callee(i64 0)
  %c = icmp eq i64 %a, 0
  %s = select i1 %c, i64 %a, i64 %b
  ret i64 %s
}

declare i64 @callee(i64)
