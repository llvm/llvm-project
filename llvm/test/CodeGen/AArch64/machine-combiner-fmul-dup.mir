# RUN: llc -run-pass=machine-combiner -o - -simplify-mir -mtriple=aarch64-unknown-linux-gnu -mattr=+fullfp16 %s | FileCheck %s
--- |
  ; ModuleID = 'lit.ll'
  source_filename = "lit.ll"
  target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
  target triple = "aarch64-unknown-linux-gnu"

  define void @indexed_2s(<2 x float> %shuf, <2 x float> %mu, <2 x float> %ad, <2 x float>* %ret) #0 {
  entry:
    %shuffle = shufflevector <2 x float> %shuf, <2 x float> undef, <2 x i32> zeroinitializer
    br label %for.cond

  for.cond:                                         ; preds = %for.cond, %entry
    %mul = fmul <2 x float> %mu, %shuffle
    %add = fadd <2 x float> %mul, %ad
    store <2 x float> %add, <2 x float>* %ret, align 16
    br label %for.cond
  }

  define void @indexed_2s_rev(<2 x float> %shuf, <2 x float> %mu, <2 x float> %ad, <2 x float>* %ret) #0 {
  entry:
    %shuffle = shufflevector <2 x float> %shuf, <2 x float> undef, <2 x i32> zeroinitializer
    br label %for.cond

  for.cond:                                         ; preds = %for.cond, %entry
    %mul = fmul <2 x float> %shuffle, %mu
    %add = fadd <2 x float> %mul, %ad
    store <2 x float> %add, <2 x float>* %ret, align 16
    br label %for.cond
  }

  define void @indexed_2d(<2 x double> %shuf, <2 x double> %mu, <2 x double> %ad, <2 x double>* %ret) #0 {
  entry:
    %shuffle = shufflevector <2 x double> %shuf, <2 x double> undef, <2 x i32> zeroinitializer
    br label %for.cond

  for.cond:                                         ; preds = %for.cond, %entry
    %mul = fmul <2 x double> %mu, %shuffle
    %add = fadd <2 x double> %mul, %ad
    store <2 x double> %add, <2 x double>* %ret, align 16
    br label %for.cond
  }

  define void @indexed_4s(<4 x float> %shuf, <4 x float> %mu, <4 x float> %ad, <4 x float>* %ret) #0 {
  entry:
    %shuffle = shufflevector <4 x float> %shuf, <4 x float> undef, <4 x i32> zeroinitializer
    br label %for.cond

  for.cond:                                         ; preds = %for.cond, %entry
    %mul = fmul <4 x float> %mu, %shuffle
    %add = fadd <4 x float> %mul, %ad
    store <4 x float> %add, <4 x float>* %ret, align 16
    br label %for.cond
  }

  define void @indexed_4h(<4 x half> %shuf, <4 x half> %mu, <4 x half> %ad, <4 x half>* %ret) #0 {
  entry:
    %shuffle = shufflevector <4 x half> %shuf, <4 x half> undef, <4 x i32> zeroinitializer
    br label %for.cond

  for.cond:
    %mul = fmul <4 x half> %mu, %shuffle
    %add = fadd <4 x half> %mul, %ad
    store <4 x half> %add, <4 x half>* %ret, align 16
    br label %for.cond
  }

  define void @indexed_8h(<8 x half> %shuf, <8 x half> %mu, <8 x half> %ad, <8 x half>* %ret) #0 {
  entry:
    %shuffle = shufflevector <8 x half> %shuf, <8 x half> undef, <8 x i32> zeroinitializer
    br label %for.cond

  for.cond:
    %mul = fmul <8 x half> %mu, %shuffle
    %add = fadd <8 x half> %mul, %ad
    store <8 x half> %add, <8 x half>* %ret, align 16
    br label %for.cond
  }

  attributes #0 = { "target-cpu"="cortex-a57" }

...
# CHECK-LABEL: name: indexed_2s
# CHECK:        [[OP1COPY:%.*]]:fpr64 = COPY $d1
# CHECK:        [[OP2COPY:%.*]]:fpr64 = COPY $d0
# CHECK:        [[UNDEF:%.*]]:fpr128 = IMPLICIT_DEF
# CHECK:        [[OP2:%.*]]:fpr128 = INSERT_SUBREG [[UNDEF]], [[OP2COPY]], %subreg.dsub
# CHECK:        [[OP1:%.*]]:fpr64 = COPY [[OP1COPY]]
# CHECK-NOT:    FMULv2f32
# CHECK:        :fpr64 = FMULv2i32_indexed [[OP1]], [[OP2]], 0
---
name:            indexed_2s
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: fpr64 }
  - { id: 1, class: fpr64 }
  - { id: 2, class: fpr64 }
  - { id: 3, class: fpr64 }
  - { id: 4, class: gpr64common }
  - { id: 5, class: fpr64 }
  - { id: 6, class: fpr64 }
  - { id: 7, class: fpr128 }
  - { id: 8, class: fpr128 }
  - { id: 9, class: fpr64 }
  - { id: 10, class: fpr64 }
liveins:
  - { reg: '$d0', virtual-reg: '%1' }
  - { reg: '$d1', virtual-reg: '%2' }
  - { reg: '$d2', virtual-reg: '%3' }
  - { reg: '$x0', virtual-reg: '%4' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $d0, $d1, $d2, $x0

    %4:gpr64common = COPY $x0
    %3:fpr64 = COPY $d2
    %2:fpr64 = COPY $d1
    %1:fpr64 = COPY $d0
    %8:fpr128 = IMPLICIT_DEF
    %7:fpr128 = INSERT_SUBREG %8, %1, %subreg.dsub
    %6:fpr64 = COPY %3
    %5:fpr64 = COPY %2
    %0:fpr64 = DUPv2i32lane killed %7, 0

  bb.1.for.cond:
    %9:fpr64 = FMULv2f32 %5, %0
    %10:fpr64 = FADDv2f32 killed %9, %6
    STRDui killed %10, %4, 0 :: (store 8 into %ir.ret, align 16)
    B %bb.1

...
# CHECK-LABEL: name: indexed_2s_rev
# CHECK:        [[OP2COPY:%.*]]:fpr64 = COPY $d1
# CHECK:        [[OP1COPY:%.*]]:fpr64 = COPY $d0
# CHECK:        [[UNDEF:%.*]]:fpr128 = IMPLICIT_DEF
# CHECK:        [[OP1:%.*]]:fpr128 = INSERT_SUBREG [[UNDEF]], [[OP1COPY]], %subreg.dsub
# CHECK:        [[OP2:%.*]]:fpr64 = COPY [[OP2COPY]]
# CHECK-NOT:    FMULv2f32
# CHECK:        :fpr64 = FMULv2i32_indexed [[OP2]], [[OP1]], 0
---
name:            indexed_2s_rev
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: fpr64 }
  - { id: 1, class: fpr64 }
  - { id: 2, class: fpr64 }
  - { id: 3, class: fpr64 }
  - { id: 4, class: gpr64common }
  - { id: 5, class: fpr64 }
  - { id: 6, class: fpr64 }
  - { id: 7, class: fpr128 }
  - { id: 8, class: fpr128 }
  - { id: 9, class: fpr64 }
  - { id: 10, class: fpr64 }
liveins:
  - { reg: '$d0', virtual-reg: '%1' }
  - { reg: '$d1', virtual-reg: '%2' }
  - { reg: '$d2', virtual-reg: '%3' }
  - { reg: '$x0', virtual-reg: '%4' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $d0, $d1, $d2, $x0

    %4:gpr64common = COPY $x0
    %3:fpr64 = COPY $d2
    %2:fpr64 = COPY $d1
    %1:fpr64 = COPY $d0
    %8:fpr128 = IMPLICIT_DEF
    %7:fpr128 = INSERT_SUBREG %8, %1, %subreg.dsub
    %6:fpr64 = COPY %3
    %5:fpr64 = COPY %2
    %0:fpr64 = DUPv2i32lane killed %7, 0

  bb.1.for.cond:
    %9:fpr64 = FMULv2f32 %0, %5
    %10:fpr64 = FADDv2f32 killed %9, %6
    STRDui killed %10, %4, 0 :: (store 8 into %ir.ret, align 16)
    B %bb.1

...
# CHECK-LABEL: name: indexed_2d
# CHECK:        [[OP1COPY:%.*]]:fpr128 = COPY $q1
# CHECK:        [[OP2:%.*]]:fpr128 = COPY $q0
# CHECK:        [[OP1:%.*]]:fpr128 = COPY [[OP1COPY]]
# CHECK-NOT:    FMULv2f64
# CHECK:        :fpr128 = FMULv2i64_indexed [[OP1]], [[OP2]], 0
---
name:            indexed_2d
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: fpr128 }
  - { id: 1, class: fpr128 }
  - { id: 2, class: fpr128 }
  - { id: 3, class: fpr128 }
  - { id: 4, class: gpr64common }
  - { id: 5, class: fpr128 }
  - { id: 6, class: fpr128 }
  - { id: 7, class: fpr128 }
  - { id: 8, class: fpr128 }
liveins:
  - { reg: '$q0', virtual-reg: '%1' }
  - { reg: '$q1', virtual-reg: '%2' }
  - { reg: '$q2', virtual-reg: '%3' }
  - { reg: '$x0', virtual-reg: '%4' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $q0, $q1, $q2, $x0

    %4:gpr64common = COPY $x0
    %3:fpr128 = COPY $q2
    %2:fpr128 = COPY $q1
    %1:fpr128 = COPY $q0
    %6:fpr128 = COPY %3
    %5:fpr128 = COPY %2
    %0:fpr128 = DUPv2i64lane %1, 0

  bb.1.for.cond:
    %7:fpr128 = FMULv2f64 %5, %0
    %8:fpr128 = FADDv2f64 killed %7, %6
    STRQui killed %8, %4, 0 :: (store 16 into %ir.ret)
    B %bb.1

...
# CHECK-LABEL: name: indexed_4s
# CHECK:        [[OP1COPY:%.*]]:fpr128 = COPY $q1
# CHECK:        [[OP2:%.*]]:fpr128 = COPY $q0
# CHECK:        [[OP1:%.*]]:fpr128 = COPY [[OP1COPY]]
# CHECK-NOT:    FMULv4f32
# CHECK:        :fpr128 = FMULv4i32_indexed [[OP1]], [[OP2]], 0
---
name:            indexed_4s
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: fpr128 }
  - { id: 1, class: fpr128 }
  - { id: 2, class: fpr128 }
  - { id: 3, class: fpr128 }
  - { id: 4, class: gpr64common }
  - { id: 5, class: fpr128 }
  - { id: 6, class: fpr128 }
  - { id: 7, class: fpr128 }
  - { id: 8, class: fpr128 }
liveins:
  - { reg: '$q0', virtual-reg: '%1' }
  - { reg: '$q1', virtual-reg: '%2' }
  - { reg: '$q2', virtual-reg: '%3' }
  - { reg: '$x0', virtual-reg: '%4' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $q0, $q1, $q2, $x0

    %4:gpr64common = COPY $x0
    %3:fpr128 = COPY $q2
    %2:fpr128 = COPY $q1
    %1:fpr128 = COPY $q0
    %6:fpr128 = COPY %3
    %5:fpr128 = COPY %2
    %0:fpr128 = DUPv4i32lane %1, 0

  bb.1.for.cond:
    %7:fpr128 = FMULv4f32 %5, %0
    %8:fpr128 = FADDv4f32 killed %7, %6
    STRQui killed %8, %4, 0 :: (store 16 into %ir.ret)
    B %bb.1

...
# CHECK-LABEL: name: indexed_4h
# CHECK:        [[OP1:%.*]]:fpr64 = COPY $d1
# CHECK:        [[OP2COPY:%.*]]:fpr64 = COPY $d0
# CHECK:        [[UNDEF:%.*]]:fpr128 = IMPLICIT_DEF
# CHECK:        [[OP2:%.*]]:fpr128 = INSERT_SUBREG [[UNDEF]], [[OP2COPY]], %subreg.dsub
# CHECK-NOT:    FMULv4f16
# CHECK:        :fpr64 = FMULv4i16_indexed [[OP1]], [[OP2]], 0
---
name:            indexed_4h
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: fpr64 }
  - { id: 1, class: fpr64 }
  - { id: 2, class: fpr64 }
  - { id: 3, class: fpr64 }
  - { id: 4, class: gpr64common }
  - { id: 5, class: fpr128 }
  - { id: 6, class: fpr128 }
  - { id: 7, class: fpr64 }
  - { id: 8, class: fpr64 }
liveins:
  - { reg: '$d0', virtual-reg: '%1' }
  - { reg: '$d1', virtual-reg: '%2' }
  - { reg: '$d2', virtual-reg: '%3' }
  - { reg: '$x0', virtual-reg: '%4' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $d0, $d1, $d2, $x0

    %4:gpr64common = COPY $x0
    %3:fpr64 = COPY $d2
    %2:fpr64 = COPY $d1
    %1:fpr64 = COPY $d0
    %6:fpr128 = IMPLICIT_DEF
    %5:fpr128 = INSERT_SUBREG %6, %1, %subreg.dsub
    %0:fpr64 = DUPv4i16lane killed %5, 0

  bb.1.for.cond:
    %7:fpr64 = FMULv4f16 %2, %0
    %8:fpr64 = FADDv4f16 killed %7, %3
    STRDui killed %8, %4, 0 :: (store 8 into %ir.ret, align 16)
    B %bb.1

...
# CHECK-LABEL: name: indexed_8h
# CHECK:        [[OP1:%.*]]:fpr128 = COPY $q1
# CHECK:        [[OP2:%.*]]:fpr128 = COPY $q0
# CHECK-NOT:    FMULv8f16
# CHECK:        :fpr128 = FMULv8i16_indexed [[OP1]], [[OP2]], 0
---
name:            indexed_8h
alignment:       16
tracksRegLiveness: true
registers:
  - { id: 0, class: fpr128 }
  - { id: 1, class: fpr128 }
  - { id: 2, class: fpr128 }
  - { id: 3, class: fpr128 }
  - { id: 4, class: gpr64common }
  - { id: 5, class: fpr128 }
  - { id: 6, class: fpr128 }
liveins:
  - { reg: '$q0', virtual-reg: '%1' }
  - { reg: '$q1', virtual-reg: '%2' }
  - { reg: '$q2', virtual-reg: '%3' }
  - { reg: '$x0', virtual-reg: '%4' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
machineFunctionInfo: {}
body:             |
  bb.0.entry:
    liveins: $q0, $q1, $q2, $x0

    %4:gpr64common = COPY $x0
    %3:fpr128 = COPY $q2
    %2:fpr128 = COPY $q1
    %1:fpr128 = COPY $q0
    %0:fpr128 = DUPv8i16lane %1, 0

  bb.1.for.cond:
    %5:fpr128 = FMULv8f16 %2, %0
    %6:fpr128 = FADDv8f16 killed %5, %3
    STRQui killed %6, %4, 0 :: (store 16 into %ir.ret)
    B %bb.1

...
