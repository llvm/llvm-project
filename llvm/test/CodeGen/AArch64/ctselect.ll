; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -verify-machineinstrs -mtriple=aarch64-none-eabi | FileCheck %s --check-prefixes=DEFAULT,NOFP16
; RUN: llc < %s -verify-machineinstrs -mtriple=aarch64-none-eabi -mattr=+fullfp16 | FileCheck %s --check-prefixes=DEFAULT,FP16

define i1 @ct_i1(i1 %cond, i1 %a, i1 %b) {
; DEFAULT-LABEL: ct_i1:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    csel w8, w1, w2, ne
; DEFAULT-NEXT:    and w0, w8, #0x1
; DEFAULT-NEXT:    ret
  %1 = call i1 @llvm.ct.select.i1(i1 %cond, i1 %a, i1 %b)
  ret i1 %1
}

define i8 @ct_i8(i1 %cond, i8 %a, i8 %b) {
; DEFAULT-LABEL: ct_i8:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    csel w0, w1, w2, ne
; DEFAULT-NEXT:    ret
  %1 = call i8 @llvm.ct.select.i8(i1 %cond, i8 %a, i8 %b)
  ret i8 %1
}

define i16 @ct_i16(i1 %cond, i16 %a, i16 %b) {
; DEFAULT-LABEL: ct_i16:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    csel w0, w1, w2, ne
; DEFAULT-NEXT:    ret
  %1 = call i16 @llvm.ct.select.i16(i1 %cond, i16 %a, i16 %b)
  ret i16 %1
}

define i32 @ct_i32(i1 %cond, i32 %a, i32 %b) {
; DEFAULT-LABEL: ct_i32:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    csel w0, w1, w2, ne
; DEFAULT-NEXT:    ret
  %1 = call i32 @llvm.ct.select.i32(i1 %cond, i32 %a, i32 %b)
  ret i32 %1
}

define i64 @ct_i64(i1 %cond, i64 %a, i64 %b) {
; DEFAULT-LABEL: ct_i64:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    csel x0, x1, x2, ne
; DEFAULT-NEXT:    ret
  %1 = call i64 @llvm.ct.select.i64(i1 %cond, i64 %a, i64 %b)
  ret i64 %1
}

define i128 @ct_i128(i1 %cond, i128 %a, i128 %b) {
; DEFAULT-LABEL: ct_i128:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    csel x0, x2, x4, ne
; DEFAULT-NEXT:    csel x1, x3, x5, ne
; DEFAULT-NEXT:    ret
  %1 = call i128 @llvm.ct.select.i128(i1 %cond, i128 %a, i128 %b)
  ret i128 %1
}

define half @ct_f16(i1 %cond, half %a, half %b) {
; NOFP16-LABEL: ct_f16:
; NOFP16:       // %bb.0:
; NOFP16-NEXT:    fcvt s1, h1
; NOFP16-NEXT:    fcvt s0, h0
; NOFP16-NEXT:    tst w0, #0x1
; NOFP16-NEXT:    fcsel s0, s0, s1, ne
; NOFP16-NEXT:    fcvt h0, s0
; NOFP16-NEXT:    ret
;
; FP16-LABEL: ct_f16:
; FP16:       // %bb.0:
; FP16-NEXT:    tst w0, #0x1
; FP16-NEXT:    fcsel h0, h0, h1, ne
; FP16-NEXT:    ret
  %1 = call half @llvm.ct.select.f16(i1 %cond, half %a, half %b)
  ret half %1
}

define float @ct_f32(i1 %cond, float %a, float %b) {
; DEFAULT-LABEL: ct_f32:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    fcsel s0, s0, s1, ne
; DEFAULT-NEXT:    ret
  %1 = call float @llvm.ct.select.f32(i1 %cond, float %a, float %b)
  ret float %1
}

define double @ct_f64(i1 %cond, double %a, double %b) {
; DEFAULT-LABEL: ct_f64:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    fcsel d0, d0, d1, ne
; DEFAULT-NEXT:    ret
  %1 = call double @llvm.ct.select.f64(i1 %cond, double %a, double %b)
  ret double %1
}

define <4 x i32> @ct_v4i32(i1 %cond, <4 x i32> %a, <4 x i32> %b) {
; DEFAULT-LABEL: ct_v4i32:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    mov w8, v1.s[1]
; DEFAULT-NEXT:    mov w9, v0.s[1]
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    fmov w10, s1
; DEFAULT-NEXT:    fmov w11, s0
; DEFAULT-NEXT:    csel w8, w9, w8, ne
; DEFAULT-NEXT:    csel w9, w11, w10, ne
; DEFAULT-NEXT:    mov w10, v1.s[2]
; DEFAULT-NEXT:    fmov s2, w9
; DEFAULT-NEXT:    mov w11, v0.s[2]
; DEFAULT-NEXT:    mov w9, v0.s[3]
; DEFAULT-NEXT:    mov v2.s[1], w8
; DEFAULT-NEXT:    mov w8, v1.s[3]
; DEFAULT-NEXT:    csel w10, w11, w10, ne
; DEFAULT-NEXT:    mov v2.s[2], w10
; DEFAULT-NEXT:    csel w8, w9, w8, ne
; DEFAULT-NEXT:    mov v2.s[3], w8
; DEFAULT-NEXT:    mov v0.16b, v2.16b
; DEFAULT-NEXT:    ret
  %1 = call <4 x i32> @llvm.ct.select.v4i32(i1 %cond, <4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %1
}

define <4 x float> @ct_v4f32(i1 %cond, <4 x float> %a, <4 x float> %b) {
; DEFAULT-LABEL: ct_v4f32:
; DEFAULT:       // %bb.0:
; DEFAULT-NEXT:    mov s2, v1.s[1]
; DEFAULT-NEXT:    mov s3, v0.s[1]
; DEFAULT-NEXT:    tst w0, #0x1
; DEFAULT-NEXT:    mov s4, v1.s[2]
; DEFAULT-NEXT:    mov s5, v0.s[2]
; DEFAULT-NEXT:    fcsel s3, s3, s2, ne
; DEFAULT-NEXT:    fcsel s2, s0, s1, ne
; DEFAULT-NEXT:    mov s1, v1.s[3]
; DEFAULT-NEXT:    mov s0, v0.s[3]
; DEFAULT-NEXT:    mov v2.s[1], v3.s[0]
; DEFAULT-NEXT:    fcsel s3, s5, s4, ne
; DEFAULT-NEXT:    fcsel s0, s0, s1, ne
; DEFAULT-NEXT:    mov v2.s[2], v3.s[0]
; DEFAULT-NEXT:    mov v2.s[3], v0.s[0]
; DEFAULT-NEXT:    mov v0.16b, v2.16b
; DEFAULT-NEXT:    ret
  %1 = call <4 x float> @llvm.ct.select.v4f32(i1 %cond, <4 x float> %a, <4 x float> %b)
  ret <4 x float> %1
}
