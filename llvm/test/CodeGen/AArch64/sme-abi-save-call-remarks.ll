; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64 -mattr=+sme2 --aarch64-new-sme-abi=false --pass-remarks-analysis=sme -o /dev/null < %s 2>&1 | FileCheck %s  --check-prefix=CHECK-SDAG
; RUN: llc -mtriple=aarch64 -mattr=+sme2 --pass-remarks-analysis=sme -o /dev/null < %s 2>&1 | FileCheck %s

declare void @private_za_callee()
declare void @private_za_callee_a()
declare void @private_za_callee_b()
declare void @private_za_callee_c()

declare void @shared_za_callee() "aarch64_inout_za"
declare void @shared_za_zt0_callee() "aarch64_inout_za" "aarch64_inout_zt0"

; Note: These remarks are more useful with source debug info (which gives line numbers for `<unknown>:0:0`).

define void @test_lazy_save_1_callee() nounwind "aarch64_inout_za" {
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_1_callee' to 'private_za_callee' sets up a lazy save for ZA

; CHECK:      remark: <unknown>:0:0: lazy save of ZA emitted in 'test_lazy_save_1_callee'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee' requires ZA save
  call void @private_za_callee()
  ret void
}

define void @test_lazy_save_2_callees() nounwind "aarch64_inout_za" {
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_2_callees' to 'private_za_callee' sets up a lazy save for ZA
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_2_callees' to 'private_za_callee' sets up a lazy save for ZA

; CHECK:      remark: <unknown>:0:0: lazy save of ZA emitted in 'test_lazy_save_2_callees'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee' requires ZA save
  call void @private_za_callee()
  call void @private_za_callee()
  ret void
}

define float @test_lazy_save_expanded_intrinsic(float %a) nounwind "aarch64_inout_za" {
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_expanded_intrinsic' to 'cosf' sets up a lazy save for ZA

; CHECK:      remark: <unknown>:0:0: lazy save of ZA emitted in 'test_lazy_save_expanded_intrinsic'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'cosf' requires ZA save
  %res = call float @llvm.cos.f32(float %a)
  ret float %res
}

define void @test_lazy_save_multiple_paths(i1 %a) "aarch64_inout_za" {
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_multiple_paths' to 'private_za_callee_a' sets up a lazy save for ZA
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_multiple_paths' to 'private_za_callee_b' sets up a lazy save for ZA
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_multiple_paths' to 'private_za_callee_c' sets up a lazy save for ZA

;      CHECK: remark: <unknown>:0:0: lazy save of ZA emitted in 'test_lazy_save_multiple_paths'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee_b' requires ZA save
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee_a' requires ZA save
entry:
  br i1 %a, label %if.end, label %if.else

if.else:
  call void @private_za_callee_a()
  br label %if.end

if.end:
  call void @private_za_callee_b()
  ; The new lowering won't report this call as the save is already needed due to
  ; the call to `private_za_callee_b()`.
  call void @private_za_callee_c()

  ret void
}

define void @test_lazy_save_with_zt0() "aarch64_inout_za" "aarch64_inout_zt0"
{
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_with_zt0' to 'private_za_callee' sets up a lazy save for ZA

;      CHECK: remark: <unknown>:0:0: spill of ZT0 emitted in 'test_lazy_save_with_zt0'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'shared_za_callee' requires ZT0 save
; CHECK-NEXT: remark: <unknown>:0:0: lazy save of ZA emitted in 'test_lazy_save_with_zt0'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee' requires ZA save
  call void @shared_za_callee()   ; Save ZT0 (remark ZT0 spill)
  call void @private_za_callee()  ; Save ZA  (remark ZA save)
  ret void
}

define void @test_lazy_save_with_zt0_reload() "aarch64_inout_za" "aarch64_inout_zt0"
{
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_with_zt0_reload' to 'private_za_callee' sets up a lazy save for ZA

;      CHECK: remark: <unknown>:0:0: spill of ZT0 emitted in 'test_lazy_save_with_zt0_reload'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'shared_za_callee' requires ZT0 save
; CHECK-NEXT: remark: <unknown>:0:0: spill of ZT0 emitted in 'test_lazy_save_with_zt0_reload'
; CHECK-NEXT: remark: <unknown>:0:0: lazy save of ZA emitted in 'test_lazy_save_with_zt0_reload'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee' requires ZA save
  call void @shared_za_callee()      ; Save ZT0 (remark ZT0 spill)
  call void @shared_za_zt0_callee()  ; Reload ZT0
  call void @private_za_callee()     ; Save ZA, ZT0 (remark ZT0 spill and ZA save)
  ret void
}

define void @test_za_merge_paths(i1 %a) "aarch64_za_state_agnostic" {
;; Note: The old lowering does not emit any remarks for agnostic ZA saves.

;      CHECK: remark: <unknown>:0:0: full save of ZA emitted in 'test_za_merge_paths'
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee_b' requires ZA save
; CHECK-NEXT: remark: <unknown>:0:0: call to 'private_za_callee_a' requires ZA save
entry:
  br i1 %a, label %if.end, label %if.else

if.else:
  call void @private_za_callee_a()
  br label %exit

if.end:
  call void @private_za_callee_b()
  br label %exit

exit:
  ; The new lowering won't report this call as the save is already needed due to
  ; the call to `private_za_callee_*()` calls on both paths to this BB.
  call void @private_za_callee_c()

  ret void
}

define void @test_lazy_save_function_ptr_callee(ptr %private_za_callee) nounwind "aarch64_inout_za" {
; CHECK-SDAG: remark: <unknown>:0:0: call from 'test_lazy_save_function_ptr_callee' to 'unknown callee' sets up a lazy save for ZA

; CHECK:      remark: <unknown>:0:0: lazy save of ZA emitted in 'test_lazy_save_function_ptr_callee'
; CHECK-NEXT: remark: <unknown>:0:0: call requires ZA save
  call void %private_za_callee()
  ret void
}
