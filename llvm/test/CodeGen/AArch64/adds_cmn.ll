; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64-linux-gnu -O3 -o - %s | FileCheck %s

define { i32, i32 } @adds_cmn(i32 noundef %x, i32 noundef %y) {
; CHECK-LABEL: adds_cmn:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmn w0, w1
; CHECK-NEXT:    add w1, w0, w1
; CHECK-NEXT:    cset w8, lo
; CHECK-NEXT:    mov w0, w8
; CHECK-NEXT:    ret
entry:
  %0 = tail call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %x, i32 %y)
  %_4.1 = extractvalue { i32, i1 } %0, 1
  %_5 = add nuw i32 %x, %y
  %_0.sroa.3.0 = select i1 %_4.1, i32 undef, i32 %_5
  %not._4.1 = xor i1 %_4.1, true
  %_0.sroa.0.0 = zext i1 %not._4.1 to i32
  %1 = insertvalue { i32, i32 } poison, i32 %_0.sroa.0.0, 0
  %2 = insertvalue { i32, i32 } %1, i32 %_0.sroa.3.0, 1
  ret { i32, i32 } %2
}

define { i32, i32 } @adds_cmn_c(i32 noundef %x, i32 noundef %y) {
; CHECK-LABEL: adds_cmn_c:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmn w0, w1
; CHECK-NEXT:    add w1, w1, w0
; CHECK-NEXT:    cset w8, lo
; CHECK-NEXT:    mov w0, w8
; CHECK-NEXT:    ret
entry:
  %0 = tail call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %x, i32 %y)
  %_4.1 = extractvalue { i32, i1 } %0, 1
  %_5 = add nuw i32 %y, %x
  %_0.sroa.3.0 = select i1 %_4.1, i32 undef, i32 %_5
  %not._4.1 = xor i1 %_4.1, true
  %_0.sroa.0.0 = zext i1 %not._4.1 to i32
  %1 = insertvalue { i32, i32 } poison, i32 %_0.sroa.0.0, 0
  %2 = insertvalue { i32, i32 } %1, i32 %_0.sroa.3.0, 1
  ret { i32, i32 } %2
}

define { i32, i32 } @subs_cmp(i32 noundef %x, i32 noundef %y) {
; CHECK-LABEL: subs_cmp:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    subs w1, w0, w1
; CHECK-NEXT:    cset w0, hs
; CHECK-NEXT:    ret
entry:
  %0 = tail call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %x, i32 %y)
  %_4.1 = extractvalue { i32, i1 } %0, 1
  %_5 = sub nuw i32 %x, %y
  %_0.sroa.3.0 = select i1 %_4.1, i32 undef, i32 %_5
  %not._4.1 = xor i1 %_4.1, true
  %_0.sroa.0.0 = zext i1 %not._4.1 to i32
  %1 = insertvalue { i32, i32 } poison, i32 %_0.sroa.0.0, 0
  %2 = insertvalue { i32, i32 } %1, i32 %_0.sroa.3.0, 1
  ret { i32, i32 } %2
}

define { i32, i32 } @subs_cmp_c(i32 noundef %x, i32 noundef %y) {
; CHECK-LABEL: subs_cmp_c:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    subs w1, w1, w0
; CHECK-NEXT:    cset w0, ls
; CHECK-NEXT:    ret
entry:
  %0 = tail call { i32, i1 } @llvm.usub.with.overflow.i32(i32 %x, i32 %y)
  %_4.1 = extractvalue { i32, i1 } %0, 1
  %_5 = sub nuw i32 %y, %x
  %_0.sroa.3.0 = select i1 %_4.1, i32 undef, i32 %_5
  %not._4.1 = xor i1 %_4.1, true
  %_0.sroa.0.0 = zext i1 %not._4.1 to i32
  %1 = insertvalue { i32, i32 } poison, i32 %_0.sroa.0.0, 0
  %2 = insertvalue { i32, i32 } %1, i32 %_0.sroa.3.0, 1
  ret { i32, i32 } %2
}
