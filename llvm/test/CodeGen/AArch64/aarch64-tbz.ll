; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -verify-machineinstrs -mtriple=aarch64 < %s | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -verify-machineinstrs -mtriple=aarch64 -cgp-verify-bfi-updates=true < %s | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -verify-machineinstrs -mtriple=aarch64 -global-isel < %s | FileCheck %s --check-prefixes=CHECK,CHECK-GI
; RUN: llc -verify-machineinstrs -mtriple=aarch64 -global-isel -O0 < %s | FileCheck %s --check-prefixes=CHECK-GIO0

define void @test1(i64 %A, i64 %B) {
; CHECK-LABEL: test1:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    tbz w1, #3, .LBB0_3
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    tbz w0, #2, .LBB0_3
; CHECK-NEXT:  // %bb.2: // %if.then2
; CHECK-NEXT:    b foo
; CHECK-NEXT:  .LBB0_3: // %if.end3
; CHECK-NEXT:    ret
;
; CHECK-GIO0-LABEL: test1:
; CHECK-GIO0:       // %bb.0: // %entry
; CHECK-GIO0-NEXT:    sub sp, sp, #32
; CHECK-GIO0-NEXT:    str x30, [sp, #16] // 8-byte Spill
; CHECK-GIO0-NEXT:    .cfi_def_cfa_offset 32
; CHECK-GIO0-NEXT:    .cfi_offset w30, -16
; CHECK-GIO0-NEXT:    str x0, [sp] // 8-byte Spill
; CHECK-GIO0-NEXT:    str x1, [sp, #8] // 8-byte Spill
; CHECK-GIO0-NEXT:    mov w8, w1
; CHECK-GIO0-NEXT:    tbz w8, #3, .LBB0_3
; CHECK-GIO0-NEXT:    b .LBB0_1
; CHECK-GIO0-NEXT:  .LBB0_1: // %entry
; CHECK-GIO0-NEXT:    ldr x0, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    mov w8, w0
; CHECK-GIO0-NEXT:    tbz w8, #2, .LBB0_3
; CHECK-GIO0-NEXT:    b .LBB0_2
; CHECK-GIO0-NEXT:  .LBB0_2: // %if.then2
; CHECK-GIO0-NEXT:    ldr x1, [sp, #8] // 8-byte Reload
; CHECK-GIO0-NEXT:    ldr x0, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    bl foo
; CHECK-GIO0-NEXT:    b .LBB0_3
; CHECK-GIO0-NEXT:  .LBB0_3: // %if.end3
; CHECK-GIO0-NEXT:    ldr x30, [sp, #16] // 8-byte Reload
; CHECK-GIO0-NEXT:    add sp, sp, #32
; CHECK-GIO0-NEXT:    ret
entry:
  %and = and i64 %A, 4
  %notlhs = icmp eq i64 %and, 0
  %and.1 = and i64 %B, 8
  %0 = icmp eq i64 %and.1, 0
  %1 = or i1 %0, %notlhs
  br i1 %1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %entry
  tail call void @foo(i64 %A, i64 %B)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %entry
  ret void
}

define void @test2(i64 %A, ptr readonly %B) #0 {
; CHECK-LABEL: test2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cbz x1, .LBB1_3
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    tbz w0, #3, .LBB1_3
; CHECK-NEXT:  // %bb.2: // %if.then2
; CHECK-NEXT:    ldr x1, [x1]
; CHECK-NEXT:    b foo
; CHECK-NEXT:  .LBB1_3: // %if.end3
; CHECK-NEXT:    ret
;
; CHECK-GIO0-LABEL: test2:
; CHECK-GIO0:       // %bb.0: // %entry
; CHECK-GIO0-NEXT:    sub sp, sp, #32
; CHECK-GIO0-NEXT:    str x30, [sp, #16] // 8-byte Spill
; CHECK-GIO0-NEXT:    .cfi_def_cfa_offset 32
; CHECK-GIO0-NEXT:    .cfi_offset w30, -16
; CHECK-GIO0-NEXT:    str x0, [sp] // 8-byte Spill
; CHECK-GIO0-NEXT:    str x1, [sp, #8] // 8-byte Spill
; CHECK-GIO0-NEXT:    cbz x1, .LBB1_3
; CHECK-GIO0-NEXT:    b .LBB1_1
; CHECK-GIO0-NEXT:  .LBB1_1: // %entry
; CHECK-GIO0-NEXT:    ldr x0, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    mov w8, w0
; CHECK-GIO0-NEXT:    tbz w8, #3, .LBB1_3
; CHECK-GIO0-NEXT:    b .LBB1_2
; CHECK-GIO0-NEXT:  .LBB1_2: // %if.then2
; CHECK-GIO0-NEXT:    ldr x0, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    ldr x8, [sp, #8] // 8-byte Reload
; CHECK-GIO0-NEXT:    ldr x1, [x8]
; CHECK-GIO0-NEXT:    bl foo
; CHECK-GIO0-NEXT:    b .LBB1_3
; CHECK-GIO0-NEXT:  .LBB1_3: // %if.end3
; CHECK-GIO0-NEXT:    ldr x30, [sp, #16] // 8-byte Reload
; CHECK-GIO0-NEXT:    add sp, sp, #32
; CHECK-GIO0-NEXT:    ret
entry:
  %tobool = icmp eq ptr %B, null
  %and = and i64 %A, 8
  %tobool1 = icmp eq i64 %and, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end3, label %if.then2

if.then2:                                         ; preds = %entry
  %0 = load i64, ptr %B, align 4
  tail call void @foo(i64 %A, i64 %0)
  br label %if.end3

if.end3:                                          ; preds = %entry, %if.then2
  ret void
}

; Make sure we use the W variant when log2(mask) is < 32.
define void @test3(i64 %A, i64 %B) {
; CHECK-LABEL: test3:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    tbz w1, #3, .LBB2_3
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    tbz w0, #28, .LBB2_3
; CHECK-NEXT:  // %bb.2: // %if.end3
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB2_3: // %if.then2
; CHECK-NEXT:    b foo
;
; CHECK-GIO0-LABEL: test3:
; CHECK-GIO0:       // %bb.0: // %entry
; CHECK-GIO0-NEXT:    sub sp, sp, #32
; CHECK-GIO0-NEXT:    str x30, [sp, #16] // 8-byte Spill
; CHECK-GIO0-NEXT:    .cfi_def_cfa_offset 32
; CHECK-GIO0-NEXT:    .cfi_offset w30, -16
; CHECK-GIO0-NEXT:    str x0, [sp] // 8-byte Spill
; CHECK-GIO0-NEXT:    str x1, [sp, #8] // 8-byte Spill
; CHECK-GIO0-NEXT:    mov w8, w1
; CHECK-GIO0-NEXT:    tbz w8, #3, .LBB2_2
; CHECK-GIO0-NEXT:    b .LBB2_1
; CHECK-GIO0-NEXT:  .LBB2_1: // %entry
; CHECK-GIO0-NEXT:    ldr x0, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    mov w8, w0
; CHECK-GIO0-NEXT:    tbnz w8, #28, .LBB2_3
; CHECK-GIO0-NEXT:    b .LBB2_2
; CHECK-GIO0-NEXT:  .LBB2_2: // %if.then2
; CHECK-GIO0-NEXT:    ldr x1, [sp, #8] // 8-byte Reload
; CHECK-GIO0-NEXT:    ldr x0, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    bl foo
; CHECK-GIO0-NEXT:    b .LBB2_3
; CHECK-GIO0-NEXT:  .LBB2_3: // %if.end3
; CHECK-GIO0-NEXT:    ldr x30, [sp, #16] // 8-byte Reload
; CHECK-GIO0-NEXT:    add sp, sp, #32
; CHECK-GIO0-NEXT:    ret
entry:
  %shift = shl i64 1, 28
  %and = and i64 %A, %shift
  %notlhs = icmp eq i64 %and, 0
  %and.1 = and i64 %B, 8
  %0 = icmp eq i64 %and.1, 0
  %1 = or i1 %0, %notlhs
  br i1 %1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %entry
  tail call void @foo(i64 %A, i64 %B)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %entry
  ret void
}

define void @test4(i64 %A, i64 %B) {
; CHECK-LABEL: test4:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    tbz w1, #3, .LBB3_3
; CHECK-NEXT:  // %bb.1: // %entry
; CHECK-NEXT:    tbz x0, #35, .LBB3_3
; CHECK-NEXT:  // %bb.2: // %if.end3
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB3_3: // %if.then2
; CHECK-NEXT:    b foo
;
; CHECK-GIO0-LABEL: test4:
; CHECK-GIO0:       // %bb.0: // %entry
; CHECK-GIO0-NEXT:    sub sp, sp, #32
; CHECK-GIO0-NEXT:    str x30, [sp, #16] // 8-byte Spill
; CHECK-GIO0-NEXT:    .cfi_def_cfa_offset 32
; CHECK-GIO0-NEXT:    .cfi_offset w30, -16
; CHECK-GIO0-NEXT:    str x0, [sp] // 8-byte Spill
; CHECK-GIO0-NEXT:    str x1, [sp, #8] // 8-byte Spill
; CHECK-GIO0-NEXT:    mov w8, w1
; CHECK-GIO0-NEXT:    tbz w8, #3, .LBB3_2
; CHECK-GIO0-NEXT:    b .LBB3_1
; CHECK-GIO0-NEXT:  .LBB3_1: // %entry
; CHECK-GIO0-NEXT:    ldr x8, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    tbnz x8, #35, .LBB3_3
; CHECK-GIO0-NEXT:    b .LBB3_2
; CHECK-GIO0-NEXT:  .LBB3_2: // %if.then2
; CHECK-GIO0-NEXT:    ldr x1, [sp, #8] // 8-byte Reload
; CHECK-GIO0-NEXT:    ldr x0, [sp] // 8-byte Reload
; CHECK-GIO0-NEXT:    bl foo
; CHECK-GIO0-NEXT:    b .LBB3_3
; CHECK-GIO0-NEXT:  .LBB3_3: // %if.end3
; CHECK-GIO0-NEXT:    ldr x30, [sp, #16] // 8-byte Reload
; CHECK-GIO0-NEXT:    add sp, sp, #32
; CHECK-GIO0-NEXT:    ret
entry:
  %shift = shl i64 1, 35
  %and = and i64 %A, %shift
  %notlhs = icmp eq i64 %and, 0
  %and.1 = and i64 %B, 8
  %0 = icmp eq i64 %and.1, 0
  %1 = or i1 %0, %notlhs
  br i1 %1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %entry
  tail call void @foo(i64 %A, i64 %B)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %entry
  ret void
}

define i32 @tbzfromextract(<8 x i8> %b) {
; CHECK-LABEL: tbzfromextract:
; CHECK:       // %bb.0: // %common.ret
; CHECK-NEXT:    mov w0, #1 // =0x1
; CHECK-NEXT:    ret
;
; CHECK-GIO0-LABEL: tbzfromextract:
; CHECK-GIO0:       // %bb.0:
; CHECK-GIO0-NEXT:    // kill: def $b0 killed $b0 killed $d0
; CHECK-GIO0-NEXT:    // kill: def $s0 killed $b0
; CHECK-GIO0-NEXT:    fmov w8, s0
; CHECK-GIO0-NEXT:    tbnz w8, #31, .LBB4_2
; CHECK-GIO0-NEXT:    b .LBB4_1
; CHECK-GIO0-NEXT:  .LBB4_1: // %land.rhs
; CHECK-GIO0-NEXT:    mov w0, #1 // =0x1
; CHECK-GIO0-NEXT:    ret
; CHECK-GIO0-NEXT:  .LBB4_2: // %land.end
; CHECK-GIO0-NEXT:    mov w0, wzr
; CHECK-GIO0-NEXT:    ret
  %e = extractelement <8 x i8> %b, i32 0
  %z = zext i8 %e to i32
  %cmp = icmp sge i32 %z, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:
    ret i32 1

land.end:
    ret i32 0
}


declare void @foo(i64, i64)
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK-GI: {{.*}}
; CHECK-SD: {{.*}}
