; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s | FileCheck %s

target triple = "aarch64-unknown-linux-gnu"

define <4 x i32> @no_sink_simple(<4 x i32> %a, <4 x i32> %b, i1 %c, ptr %p) {
; CHECK-LABEL: no_sink_simple:
; CHECK:       // %bb.0:
; CHECK-NEXT:    tbz w0, #0, .LBB0_2
; CHECK-NEXT:  // %bb.1: // %s
; CHECK-NEXT:    cmgt v1.4s, v1.4s, v0.4s
; CHECK-NEXT:    and v0.16b, v0.16b, v1.16b
; CHECK-NEXT:    str q0, [x1]
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_2: // %t
; CHECK-NEXT:    cmgt v0.4s, v1.4s, v0.4s
; CHECK-NEXT:    and v0.16b, v1.16b, v0.16b
; CHECK-NEXT:    ret
  %d = icmp slt <4 x i32> %a, %b
  br i1 %c, label %s, label %t

s:
  %s1 = select <4 x i1> %d, <4 x i32> %a, <4 x i32> zeroinitializer
  store <4 x i32> %s1, ptr %p
  ret <4 x i32> %s1

t:
  %s2 = select <4 x i1> %d, <4 x i32> %b, <4 x i32> zeroinitializer
  ret <4 x i32> %s2
}

define void @vector_loop_with_icmp(ptr nocapture noundef writeonly %dest) {
; CHECK-LABEL: vector_loop_with_icmp:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #15 // =0xf
; CHECK-NEXT:    mov w10, #4 // =0x4
; CHECK-NEXT:    adrp x9, .LCPI1_0
; CHECK-NEXT:    adrp x11, .LCPI1_1
; CHECK-NEXT:    dup v0.2d, x8
; CHECK-NEXT:    dup v1.2d, x10
; CHECK-NEXT:    ldr q2, [x9, :lo12:.LCPI1_0]
; CHECK-NEXT:    ldr q3, [x11, :lo12:.LCPI1_1]
; CHECK-NEXT:    add x9, x0, #8
; CHECK-NEXT:    mov w10, #16 // =0x10
; CHECK-NEXT:    mov w11, #1 // =0x1
; CHECK-NEXT:    b .LBB1_2
; CHECK-NEXT:  .LBB1_1: // %pred.store.continue18
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    add v2.2d, v2.2d, v1.2d
; CHECK-NEXT:    add v3.2d, v3.2d, v1.2d
; CHECK-NEXT:    subs x10, x10, #4
; CHECK-NEXT:    add x9, x9, #16
; CHECK-NEXT:    b.eq .LBB1_10
; CHECK-NEXT:  .LBB1_2: // %vector.body
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmhi v4.2d, v0.2d, v3.2d
; CHECK-NEXT:    xtn v4.2s, v4.2d
; CHECK-NEXT:    uzp1 v4.4h, v4.4h, v0.4h
; CHECK-NEXT:    umov w12, v4.h[0]
; CHECK-NEXT:    tbz w12, #0, .LBB1_4
; CHECK-NEXT:  // %bb.3: // %pred.store.if
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    stur w11, [x9, #-8]
; CHECK-NEXT:  .LBB1_4: // %pred.store.continue
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    dup v4.2d, x8
; CHECK-NEXT:    cmhi v4.2d, v4.2d, v3.2d
; CHECK-NEXT:    xtn v4.2s, v4.2d
; CHECK-NEXT:    uzp1 v4.4h, v4.4h, v0.4h
; CHECK-NEXT:    umov w12, v4.h[1]
; CHECK-NEXT:    tbz w12, #0, .LBB1_6
; CHECK-NEXT:  // %bb.5: // %pred.store.if5
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    stur w11, [x9, #-4]
; CHECK-NEXT:  .LBB1_6: // %pred.store.continue6
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    dup v4.2d, x8
; CHECK-NEXT:    cmhi v4.2d, v4.2d, v2.2d
; CHECK-NEXT:    xtn v4.2s, v4.2d
; CHECK-NEXT:    uzp1 v4.4h, v0.4h, v4.4h
; CHECK-NEXT:    umov w12, v4.h[2]
; CHECK-NEXT:    tbz w12, #0, .LBB1_8
; CHECK-NEXT:  // %bb.7: // %pred.store.if7
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    str w11, [x9]
; CHECK-NEXT:  .LBB1_8: // %pred.store.continue8
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    dup v4.2d, x8
; CHECK-NEXT:    cmhi v4.2d, v4.2d, v2.2d
; CHECK-NEXT:    xtn v4.2s, v4.2d
; CHECK-NEXT:    uzp1 v4.4h, v0.4h, v4.4h
; CHECK-NEXT:    umov w12, v4.h[3]
; CHECK-NEXT:    tbz w12, #0, .LBB1_1
; CHECK-NEXT:  // %bb.9: // %pred.store.if9
; CHECK-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    str w11, [x9, #4]
; CHECK-NEXT:    b .LBB1_1
; CHECK-NEXT:  .LBB1_10: // %for.cond.cleanup
; CHECK-NEXT:    ret
entry:
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %entry ], [ %index.next, %pred.store.continue18 ]
  %vec.ind = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, %entry ], [ %vec.ind.next, %pred.store.continue18 ]
  %0 = icmp ult <4 x i64> %vec.ind, <i64 15, i64 15, i64 15, i64 15>
  %1 = extractelement <4 x i1> %0, i64 0
  br i1 %1, label %pred.store.if, label %pred.store.continue

pred.store.if:
  %2 = getelementptr inbounds i32, ptr %dest, i64 %index
  store i32 1, ptr %2, align 4
  br label %pred.store.continue

pred.store.continue:
  %3 = extractelement <4 x i1> %0, i64 1
  br i1 %3, label %pred.store.if5, label %pred.store.continue6

pred.store.if5:
  %4 = or disjoint i64 %index, 1
  %5 = getelementptr inbounds i32, ptr %dest, i64 %4
  store i32 1, ptr %5, align 4
  br label %pred.store.continue6

pred.store.continue6:
  %6 = extractelement <4 x i1> %0, i64 2
  br i1 %6, label %pred.store.if7, label %pred.store.continue8

pred.store.if7:
  %7 = or disjoint i64 %index, 2
  %8 = getelementptr inbounds i32, ptr %dest, i64 %7
  store i32 1, ptr %8, align 4
  br label %pred.store.continue8

pred.store.continue8:
  %9 = extractelement <4 x i1> %0, i64 3
  br i1 %9, label %pred.store.if9, label %pred.store.continue18

pred.store.if9:
  %10 = or disjoint i64 %index, 3
  %11 = getelementptr inbounds i32, ptr %dest, i64 %10
  store i32 1, ptr %11, align 4
  br label %pred.store.continue18

pred.store.continue18:
  %index.next = add i64 %index, 4
  %vec.ind.next = add <4 x i64> %vec.ind, <i64 4, i64 4, i64 4, i64 4>
  %24 = icmp eq i64 %index.next, 16
  br i1 %24, label %for.cond.cleanup, label %vector.body

for.cond.cleanup:
  ret void
}
