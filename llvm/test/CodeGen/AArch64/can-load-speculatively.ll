; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -mtriple=aarch64-unknown-linux-gnu -passes=pre-isel-intrinsic-lowering -S < %s | FileCheck %s

; Test that @llvm.can.load.speculatively is lowered to an alignment check
; for power-of-2 sizes <= 16 bytes on AArch64, and returns false for larger sizes.
; The 16-byte limit ensures correctness with MTE (memory tagging).
; Note: non-power-of-2 constant sizes are rejected by the verifier.

define i1 @can_load_speculatively_16(ptr %ptr) {
; CHECK-LABEL: @can_load_speculatively_16(
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[PTR:%.*]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = and i64 [[TMP1]], 15
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i64 [[TMP2]], 0
; CHECK-NEXT:    ret i1 [[TMP3]]
;
  %can_load = call i1 @llvm.can.load.speculatively.p0(ptr %ptr, i64 16)
  ret i1 %can_load
}

; Size > 16 - returns false (may cross MTE tag granule boundary)
define i1 @can_load_speculatively_32(ptr %ptr) {
; CHECK-LABEL: @can_load_speculatively_32(
; CHECK-NEXT:    ret i1 false
;
  %can_load = call i1 @llvm.can.load.speculatively.p0(ptr %ptr, i64 32)
  ret i1 %can_load
}

; Size > 16 - returns false (may cross MTE tag granule boundary)
define i1 @can_load_speculatively_64(ptr %ptr) {
; CHECK-LABEL: @can_load_speculatively_64(
; CHECK-NEXT:    ret i1 false
;
  %can_load = call i1 @llvm.can.load.speculatively.p0(ptr %ptr, i64 64)
  ret i1 %can_load
}

; Test with address space
define i1 @can_load_speculatively_addrspace1(ptr addrspace(1) %ptr) {
; CHECK-LABEL: @can_load_speculatively_addrspace1(
; CHECK-NEXT:    ret i1 false
;
  %can_load = call i1 @llvm.can.load.speculatively.p1(ptr addrspace(1) %ptr, i64 16)
  ret i1 %can_load
}

; Test size 8 (within limit, power-of-2)
define i1 @can_load_speculatively_8(ptr %ptr) {
; CHECK-LABEL: @can_load_speculatively_8(
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[PTR:%.*]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = and i64 [[TMP1]], 7
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i64 [[TMP2]], 0
; CHECK-NEXT:    ret i1 [[TMP3]]
;
  %can_load = call i1 @llvm.can.load.speculatively.p0(ptr %ptr, i64 8)
  ret i1 %can_load
}

; Test with runtime size - checks size <= 16 and alignment
define i1 @can_load_speculatively_runtime(ptr %ptr, i64 %size) {
; CHECK-LABEL: @can_load_speculatively_runtime(
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[PTR:%.*]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = icmp ule i64 [[SIZE:%.*]], 16
; CHECK-NEXT:    [[TMP3:%.*]] = sub i64 [[SIZE]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = and i64 [[TMP1]], [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i64 [[TMP4]], 0
; CHECK-NEXT:    [[TMP6:%.*]] = and i1 [[TMP2]], [[TMP5]]
; CHECK-NEXT:    ret i1 [[TMP6]]
;
  %can_load = call i1 @llvm.can.load.speculatively.p0(ptr %ptr, i64 %size)
  ret i1 %can_load
}

declare i1 @llvm.can.load.speculatively.p0(ptr, i64)
declare i1 @llvm.can.load.speculatively.p1(ptr addrspace(1), i64)
