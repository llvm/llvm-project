; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=arm64-unknown-unknown -debugify-and-strip-all-safe -O3 < %s | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -mtriple=arm64-unknown-unknown -debugify-and-strip-all-safe -O3 -global-isel < %s | FileCheck %s --check-prefixes=CHECK,CHECK-GI

define i32 @foo1(i32 %b, i32 %c) nounwind readnone ssp {
; CHECK-SD-LABEL: foo1:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w1, #0
; CHECK-SD-NEXT:    add w8, w1, w0
; CHECK-SD-NEXT:    cinc w0, w8, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo1:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    add w8, w1, w0
; CHECK-GI-NEXT:    cmp w1, #0
; CHECK-GI-NEXT:    cinc w0, w8, ne
; CHECK-GI-NEXT:    ret
entry:
  %not.tobool = icmp ne i32 %c, 0
  %add = zext i1 %not.tobool to i32
  %b.add = add i32 %c, %b
  %add1 = add i32 %b.add, %add
  ret i32 %add1
}

define i32 @foo2(i32 %b, i32 %c) nounwind readnone ssp {
; CHECK-LABEL: foo2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp w1, #0
; CHECK-NEXT:    cneg w8, w0, ne
; CHECK-NEXT:    add w0, w8, w1
; CHECK-NEXT:    ret
entry:
  %mul = sub i32 0, %b
  %tobool = icmp eq i32 %c, 0
  %b.mul = select i1 %tobool, i32 %b, i32 %mul
  %add = add nsw i32 %b.mul, %c
  ret i32 %add
}

define i32 @foo3(i32 %b, i32 %c) nounwind readnone ssp {
; CHECK-SD-LABEL: foo3:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w1, #0
; CHECK-SD-NEXT:    cinv w8, w0, ne
; CHECK-SD-NEXT:    add w0, w8, w1
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo3:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w1, #0
; CHECK-GI-NEXT:    cset w8, ne
; CHECK-GI-NEXT:    sbfx w8, w8, #0, #1
; CHECK-GI-NEXT:    eor w8, w8, w0
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %not.tobool = icmp ne i32 %c, 0
  %xor = sext i1 %not.tobool to i32
  %b.xor = xor i32 %xor, %b
  %add = add nsw i32 %b.xor, %c
  ret i32 %add
}

; rdar://11632325
define i32@foo4(i32 %a) nounwind ssp {
; CHECK-LABEL: foo4:
; CHECK:       // %bb.0:
; CHECK-NEXT:    cmp w0, #0
; CHECK-NEXT:    cneg w0, w0, mi
; CHECK-NEXT:    ret
  %cmp = icmp sgt i32 %a, -1
  %neg = sub nsw i32 0, %a
  %cond = select i1 %cmp, i32 %a, i32 %neg
  ret i32 %cond
}

define i32@foo5(i32 %a, i32 %b) nounwind ssp {
; CHECK-SD-LABEL: foo5:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    subs w8, w0, w1
; CHECK-SD-NEXT:    cneg w0, w8, lt
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo5:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    subs w8, w0, w1
; CHECK-GI-NEXT:    cneg w0, w8, mi
; CHECK-GI-NEXT:    ret
entry:
  %sub = sub nsw i32 %a, %b
  %cmp = icmp sgt i32 %sub, -1
  %sub3 = sub nsw i32 0, %sub
  %cond = select i1 %cmp, i32 %sub, i32 %sub3
  ret i32 %cond
}

; make sure we can handle branch instruction in optimizeCompare.
define i32@foo6(i32 %a, i32 %b) nounwind ssp {
; CHECK-LABEL: foo6:
; CHECK:       // %bb.0: // %common.ret
; CHECK-NEXT:    subs w8, w0, w1
; CHECK-NEXT:    csinc w0, w8, wzr, le
; CHECK-NEXT:    ret
  %sub = sub nsw i32 %a, %b
  %cmp = icmp sgt i32 %sub, 0
  br i1 %cmp, label %l.if, label %l.else

l.if:
  ret i32 1

l.else:
  ret i32 %sub
}

; If CPSR is used multiple times and V flag is used, we don't remove cmp.
define i32 @foo7(i32 %a, i32 %b) nounwind {
; CHECK-SD-LABEL: foo7:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    subs w8, w0, w1
; CHECK-SD-NEXT:    cneg w9, w8, lt
; CHECK-SD-NEXT:    cmn w8, #1
; CHECK-SD-NEXT:    csel w8, w9, w0, lt
; CHECK-SD-NEXT:    csel w0, w8, w9, gt
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo7:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    subs w8, w0, w1
; CHECK-GI-NEXT:    cneg w9, w8, mi
; CHECK-GI-NEXT:    cmn w8, #1
; CHECK-GI-NEXT:    csel w10, w9, w0, lt
; CHECK-GI-NEXT:    cmp w8, #0
; CHECK-GI-NEXT:    csel w0, w10, w9, pl
; CHECK-GI-NEXT:    ret
entry:
  %sub = sub nsw i32 %a, %b
  %cmp = icmp sgt i32 %sub, -1
  %sub3 = sub nsw i32 0, %sub
  %cond = select i1 %cmp, i32 %sub, i32 %sub3
  br i1 %cmp, label %if.then, label %if.else

if.then:
  %cmp2 = icmp slt i32 %sub, -1
  %sel = select i1 %cmp2, i32 %cond, i32 %a
  ret i32 %sel

if.else:
  ret i32 %cond
}

define i32 @foo8(i32 %v, i32 %a, i32 %b) nounwind readnone ssp {
; CHECK-LABEL: foo8:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp w0, #0
; CHECK-NEXT:    csinv w0, w1, w2, ne
; CHECK-NEXT:    ret
entry:
  %tobool = icmp eq i32 %v, 0
  %neg = xor i32 -1, %b
  %cond = select i1 %tobool, i32 %neg, i32 %a
  ret i32 %cond
}

define i32 @foo9(i32 %v) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo9:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov w8, #4 // =0x4
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    cinv w0, w8, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo9:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #-5 // =0xfffffffb
; CHECK-GI-NEXT:    mov w9, #4 // =0x4
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csel w0, w9, w8, ne
; CHECK-GI-NEXT:    ret
entry:
  %tobool = icmp ne i32 %v, 0
  %cond = select i1 %tobool, i32 4, i32 -5
  ret i32 %cond
}

define i64 @foo10(i64 %v) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo10:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov w8, #4 // =0x4
; CHECK-SD-NEXT:    cmp x0, #0
; CHECK-SD-NEXT:    cinv x0, x8, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo10:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov x8, #-5 // =0xfffffffffffffffb
; CHECK-GI-NEXT:    mov w9, #4 // =0x4
; CHECK-GI-NEXT:    cmp x0, #0
; CHECK-GI-NEXT:    csel x0, x9, x8, ne
; CHECK-GI-NEXT:    ret
entry:
  %tobool = icmp ne i64 %v, 0
  %cond = select i1 %tobool, i64 4, i64 -5
  ret i64 %cond
}

define i32 @foo11(i32 %v) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo11:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov w8, #4 // =0x4
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    cneg w0, w8, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo11:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #-4 // =0xfffffffc
; CHECK-GI-NEXT:    mov w9, #4 // =0x4
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csel w0, w9, w8, ne
; CHECK-GI-NEXT:    ret
entry:
  %tobool = icmp ne i32 %v, 0
  %cond = select i1 %tobool, i32 4, i32 -4
  ret i32 %cond
}

define i64 @foo12(i64 %v) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo12:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov w8, #4 // =0x4
; CHECK-SD-NEXT:    cmp x0, #0
; CHECK-SD-NEXT:    cneg x0, x8, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo12:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov x8, #-4 // =0xfffffffffffffffc
; CHECK-GI-NEXT:    mov w9, #4 // =0x4
; CHECK-GI-NEXT:    cmp x0, #0
; CHECK-GI-NEXT:    csel x0, x9, x8, ne
; CHECK-GI-NEXT:    ret
entry:
  %tobool = icmp ne i64 %v, 0
  %cond = select i1 %tobool, i64 4, i64 -4
  ret i64 %cond
}

define i32 @foo13(i32 %v, i32 %a, i32 %b) nounwind readnone optsize ssp {
; CHECK-LABEL: foo13:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp w0, #0
; CHECK-NEXT:    csneg w0, w1, w2, ne
; CHECK-NEXT:    ret
entry:
  %tobool = icmp eq i32 %v, 0
  %sub = sub i32 0, %b
  %cond = select i1 %tobool, i32 %sub, i32 %a
  ret i32 %cond
}

define i64 @foo14(i64 %v, i64 %a, i64 %b) nounwind readnone optsize ssp {
; CHECK-LABEL: foo14:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp x0, #0
; CHECK-NEXT:    csneg x0, x1, x2, ne
; CHECK-NEXT:    ret
entry:
  %tobool = icmp eq i64 %v, 0
  %sub = sub i64 0, %b
  %cond = select i1 %tobool, i64 %sub, i64 %a
  ret i64 %cond
}

define i32 @foo15(i32 %a, i32 %b) nounwind readnone optsize ssp {
; CHECK-LABEL: foo15:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    cmp w0, w1
; CHECK-NEXT:    cinc w0, w8, gt
; CHECK-NEXT:    ret
entry:
  %cmp = icmp sgt i32 %a, %b
  %. = select i1 %cmp, i32 2, i32 1
  ret i32 %.
}

define i32 @foo16(i32 %a, i32 %b) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo16:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov w8, #1 // =0x1
; CHECK-SD-NEXT:    cmp w0, w1
; CHECK-SD-NEXT:    cinc w0, w8, le
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo16:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, w1
; CHECK-GI-NEXT:    cset w8, gt
; CHECK-GI-NEXT:    sbfx w8, w8, #0, #1
; CHECK-GI-NEXT:    add w0, w8, #2
; CHECK-GI-NEXT:    ret
entry:
  %cmp = icmp sgt i32 %a, %b
  %. = select i1 %cmp, i32 1, i32 2
  ret i32 %.
}

define i64 @foo17(i64 %a, i64 %b) nounwind readnone optsize ssp {
; CHECK-LABEL: foo17:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #1 // =0x1
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    cinc x0, x8, gt
; CHECK-NEXT:    ret
entry:
  %cmp = icmp sgt i64 %a, %b
  %. = select i1 %cmp, i64 2, i64 1
  ret i64 %.
}

define i64 @foo18(i64 %a, i64 %b) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo18:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov w8, #1 // =0x1
; CHECK-SD-NEXT:    cmp x0, x1
; CHECK-SD-NEXT:    cinc x0, x8, le
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo18:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp x0, x1
; CHECK-GI-NEXT:    cset w8, gt
; CHECK-GI-NEXT:    sbfx x8, x8, #0, #1
; CHECK-GI-NEXT:    add x0, x8, #2
; CHECK-GI-NEXT:    ret
entry:
  %cmp = icmp sgt i64 %a, %b
  %. = select i1 %cmp, i64 1, i64 2
  ret i64 %.
}

; Regression test for TrueVal + 1 overflow
define i64 @foo18_overflow1(i64 %a, i64 %b) nounwind readnone optsize ssp {
; CHECK-LABEL: foo18_overflow1:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov x8, #9223372036854775807 // =0x7fffffffffffffff
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    csel x0, x8, xzr, gt
; CHECK-NEXT:    ret
entry:
  %cmp = icmp sgt i64 %a, %b
  %. = select i1 %cmp, i64 9223372036854775807, i64 0
  ret i64 %.
}

; Regression test for FalseVal + 1 overflow
define i64 @foo18_overflow2(i64 %a, i64 %b) nounwind readnone optsize ssp {
; CHECK-LABEL: foo18_overflow2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov x8, #9223372036854775807 // =0x7fffffffffffffff
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    csel x0, xzr, x8, gt
; CHECK-NEXT:    ret
entry:
  %cmp = icmp sgt i64 %a, %b
  %. = select i1 %cmp, i64 0, i64 9223372036854775807
  ret i64 %.
}

; Regression test for FalseVal - TrueVal overflow
define i64 @foo18_overflow3(i1 %cmp) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo18_overflow3:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov x8, #-9223372036854775808 // =0x8000000000000000
; CHECK-SD-NEXT:    tst w0, #0x1
; CHECK-SD-NEXT:    csel x0, x8, xzr, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo18_overflow3:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-GI-NEXT:    and x8, x0, #0x1
; CHECK-GI-NEXT:    lsl x0, x8, #63
; CHECK-GI-NEXT:    ret
entry:
  %. = select i1 %cmp, i64 -9223372036854775808, i64 0
  ret i64 %.
}

; Regression test for TrueVal - FalseVal overflow
define i64 @foo18_overflow4(i1 %cmp) nounwind readnone optsize ssp {
; CHECK-SD-LABEL: foo18_overflow4:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    mov x8, #-9223372036854775808 // =0x8000000000000000
; CHECK-SD-NEXT:    tst w0, #0x1
; CHECK-SD-NEXT:    csel x0, xzr, x8, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo18_overflow4:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    eor w8, w0, #0x1
; CHECK-GI-NEXT:    and x8, x8, #0x1
; CHECK-GI-NEXT:    lsl x0, x8, #63
; CHECK-GI-NEXT:    ret
entry:
  %. = select i1 %cmp, i64 0, i64 -9223372036854775808
  ret i64 %.
}

define i64 @foo19(i64 %a, i64 %b, i64 %c) {
; CHECK-LABEL: foo19:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    cmp x0, x1
; CHECK-NEXT:    cinc x0, x2, lo
; CHECK-NEXT:    ret
entry:
  %cmp = icmp ult i64 %a, %b
  %inc = zext i1 %cmp to i64
  %inc.c = add i64 %inc, %c
  ret i64 %inc.c
}

define i32 @foo20(i32 %x) {
; CHECK-LABEL: foo20:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #6 // =0x6
; CHECK-NEXT:    cmp w0, #5
; CHECK-NEXT:    csinc w0, w8, wzr, eq
; CHECK-NEXT:    ret
  %cmp = icmp eq i32 %x, 5
  %res = select i1 %cmp, i32 6, i32 1
  ret i32 %res
}

define i64 @foo21(i64 %x) {
; CHECK-LABEL: foo21:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #6 // =0x6
; CHECK-NEXT:    cmp x0, #5
; CHECK-NEXT:    csinc x0, x8, xzr, eq
; CHECK-NEXT:    ret
  %cmp = icmp eq i64 %x, 5
  %res = select i1 %cmp, i64 6, i64 1
  ret i64 %res
}

define i32 @foo22(i32 %x) {
; CHECK-LABEL: foo22:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #6 // =0x6
; CHECK-NEXT:    cmp w0, #5
; CHECK-NEXT:    csinc w0, w8, wzr, ne
; CHECK-NEXT:    ret
  %cmp = icmp eq i32 %x, 5
  %res = select i1 %cmp, i32 1, i32 6
  ret i32 %res
}

define i64 @foo23(i64 %x) {
; CHECK-LABEL: foo23:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov w8, #6 // =0x6
; CHECK-NEXT:    cmp x0, #5
; CHECK-NEXT:    csinc x0, x8, xzr, ne
; CHECK-NEXT:    ret
  %cmp = icmp eq i64 %x, 5
  %res = select i1 %cmp, i64 1, i64 6
  ret i64 %res
}

define i16 @foo24(ptr nocapture readonly %A, ptr nocapture readonly %B) {
; CHECK-SD-LABEL: foo24:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    ldrb w8, [x0]
; CHECK-SD-NEXT:    ldrb w9, [x1]
; CHECK-SD-NEXT:    cmp w8, #3
; CHECK-SD-NEXT:    cset w8, hi
; CHECK-SD-NEXT:    cmp w9, #33
; CHECK-SD-NEXT:    cinc w0, w8, hi
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: foo24:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    ldrb w8, [x1]
; CHECK-GI-NEXT:    ldrb w9, [x0]
; CHECK-GI-NEXT:    cmp w8, #33
; CHECK-GI-NEXT:    cset w8, hi
; CHECK-GI-NEXT:    cmp w9, #3
; CHECK-GI-NEXT:    cinc w0, w8, hi
; CHECK-GI-NEXT:    ret
entry:
  %0 = load i8, ptr %A, align 1
  %cmp = icmp ugt i8 %0, 3
  %conv1 = zext i1 %cmp to i16
  %1 = load i8, ptr %B, align 1
  %cmp4 = icmp ugt i8 %1, 33
  %conv5 = zext i1 %cmp4 to i16
  %add = add nuw nsw i16 %conv5, %conv1
  ret i16 %add
}

define i64 @foo25(ptr nocapture readonly %A, ptr nocapture readonly %B) {
; CHECK-LABEL: foo25:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ldr x8, [x1]
; CHECK-NEXT:    ldr x9, [x0]
; CHECK-NEXT:    cmp x8, #33
; CHECK-NEXT:    cset w8, hi
; CHECK-NEXT:    cmp x9, #3
; CHECK-NEXT:    cinc x0, x8, hi
; CHECK-NEXT:    ret
entry:
  %0 = load i64, ptr %A, align 1
  %cmp = icmp ugt i64 %0, 3
  %conv1 = zext i1 %cmp to i64
  %1 = load i64, ptr %B, align 1
  %cmp4 = icmp ugt i64 %1, 33
  %conv5 = zext i1 %cmp4 to i64
  %add = add nuw nsw i64 %conv5, %conv1
  ret i64 %add
}

define i32 @or(i32 %num, i32 %x) {
; CHECK-SD-LABEL: or:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    and w8, w0, #0xff00
; CHECK-SD-NEXT:    cmp w1, #0
; CHECK-SD-NEXT:    cinc w0, w8, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: or:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w1, #0
; CHECK-GI-NEXT:    and w8, w0, #0xff00
; CHECK-GI-NEXT:    cset w9, ne
; CHECK-GI-NEXT:    orr w0, w8, w9
; CHECK-GI-NEXT:    ret
entry:
  %and = and i32 %num, 65280
  %tobool.not = icmp ne i32 %x, 0
  %cond = zext i1 %tobool.not to i32
  %or = or disjoint i32 %and, %cond
  ret i32 %or
}

define i64 @or64(i64 %num, i64 %x) {
; CHECK-SD-LABEL: or64:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    and x8, x0, #0xff00
; CHECK-SD-NEXT:    cmp x1, #0
; CHECK-SD-NEXT:    cinc x0, x8, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: or64:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp x1, #0
; CHECK-GI-NEXT:    and x8, x0, #0xff00
; CHECK-GI-NEXT:    cset w9, ne
; CHECK-GI-NEXT:    orr x0, x8, x9
; CHECK-GI-NEXT:    ret
entry:
  %and = and i64 %num, 65280
  %tobool.not = icmp ne i64 %x, 0
  %conv = zext i1 %tobool.not to i64
  %or = or disjoint i64 %and, %conv
  ret i64 %or
}

define i32 @selor32(i32 %num, i32 %x) {
; CHECK-SD-LABEL: selor32:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    and w8, w0, #0xff00
; CHECK-SD-NEXT:    cmp w1, #0
; CHECK-SD-NEXT:    cinc w0, w8, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: selor32:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    and w8, w0, #0xff00
; CHECK-GI-NEXT:    cmp w1, #0
; CHECK-GI-NEXT:    orr w9, w8, #0x1
; CHECK-GI-NEXT:    csel w0, w9, w8, ne
; CHECK-GI-NEXT:    ret
entry:
  %and = and i32 %num, 65280
  %tobool.not = icmp ne i32 %x, 0
  %or = or disjoint i32 %and, 1
  %sel = select i1 %tobool.not, i32 %or, i32 %and
  ret i32 %sel
}

define i32 @selor32_2(i32 %num, i32 %x) {
; CHECK-LABEL: selor32_2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    and w8, w0, #0xff00
; CHECK-NEXT:    cmp w1, #0
; CHECK-NEXT:    orr w9, w8, #0x2
; CHECK-NEXT:    csel w0, w9, w8, ne
; CHECK-NEXT:    ret
entry:
  %and = and i32 %num, 65280
  %tobool.not = icmp ne i32 %x, 0
  %or = or disjoint i32 %and, 2
  %sel = select i1 %tobool.not, i32 %or, i32 %and
  ret i32 %sel
}

define i64 @selor64(i64 %num, i64 %x) {
; CHECK-SD-LABEL: selor64:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    and x8, x0, #0xff00
; CHECK-SD-NEXT:    cmp x1, #0
; CHECK-SD-NEXT:    cinc x0, x8, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: selor64:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    and x8, x0, #0xff00
; CHECK-GI-NEXT:    cmp x1, #0
; CHECK-GI-NEXT:    orr x9, x8, #0x1
; CHECK-GI-NEXT:    csel x0, x9, x8, ne
; CHECK-GI-NEXT:    ret
entry:
  %and = and i64 %num, 65280
  %tobool.not = icmp ne i64 %x, 0
  %or = or disjoint i64 %and, 1
  %sel = select i1 %tobool.not, i64 %or, i64 %and
  ret i64 %sel
}

; Same as above with disjoint but without knowing haveNoCommonBitsSet.
define i64 @selor64_disjoint(i64 %num, i64 %x) {
; CHECK-SD-LABEL: selor64_disjoint:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp x1, #0
; CHECK-SD-NEXT:    cinc x0, x0, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: selor64_disjoint:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    orr x8, x0, #0x1
; CHECK-GI-NEXT:    cmp x1, #0
; CHECK-GI-NEXT:    csel x0, x8, x0, ne
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp ne i64 %x, 0
  %or = or disjoint i64 %num, 1
  %sel = select i1 %tobool.not, i64 %or, i64 %num
  ret i64 %sel
}
