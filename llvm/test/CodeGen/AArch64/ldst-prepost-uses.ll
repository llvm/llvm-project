; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -O3 -mtriple=aarch64 | FileCheck %s

; From #164775, this generates a pre-index load feeding a post-index store, that
; was checking the wrong uses for post-inc. It seems quite delicate for it to
; generate this combination at the wrong point to hit the same issue.

@g_260 = dso_local global i16 0
@g_480 = dso_local global i16 0

define i32 @func_1(ptr %l_3253) {
; CHECK-LABEL: func_1:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #128
; CHECK-NEXT:    .cfi_def_cfa_offset 128
; CHECK-NEXT:    movi v0.2d, #0000000000000000
; CHECK-NEXT:    mov w9, #2 // =0x2
; CHECK-NEXT:    mov w10, #96 // =0x60
; CHECK-NEXT:    strb wzr, [x9]
; CHECK-NEXT:    mov w9, #111 // =0x6f
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:    str wzr, [x9]
; CHECK-NEXT:    mov w9, #80 // =0x50
; CHECK-NEXT:    adrp x1, .L_MergedGlobals
; CHECK-NEXT:    add x1, x1, :lo12:.L_MergedGlobals
; CHECK-NEXT:    strh wzr, [x8]
; CHECK-NEXT:    str q0, [x9]
; CHECK-NEXT:    mov w9, #48 // =0x30
; CHECK-NEXT:    str q0, [x9]
; CHECK-NEXT:    mov w9, #32 // =0x20
; CHECK-NEXT:    str q0, [x10]
; CHECK-NEXT:    mov w10, #64 // =0x40
; CHECK-NEXT:    str q0, [x9]
; CHECK-NEXT:    mov w9, #16 // =0x10
; CHECK-NEXT:    str q0, [x10]
; CHECK-NEXT:    str q0, [x9]
; CHECK-NEXT:    str q0, [x8]
; CHECK-NEXT:    adrp x8, .L_MergedGlobals
; CHECK-NEXT:    strb wzr, [x0, #8]
; CHECK-NEXT:    strb wzr, [x0, #12]
; CHECK-NEXT:    strb wzr, [x0, #16]
; CHECK-NEXT:    strb wzr, [x0, #20]
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    ldrh wzr, [x8, :lo12:.L_MergedGlobals]
; CHECK-NEXT:    ldrh w8, [x1, #4]!
; CHECK-NEXT:    sub w8, w8, #1
; CHECK-NEXT:    strh w8, [x1]
; CHECK-NEXT:    add sp, sp, #128
; CHECK-NEXT:    b use
entry:
  %l_32531.sroa.3 = alloca [3 x i8], align 4
  %l_32531.sroa.4 = alloca [115 x i8], align 4
  call void @llvm.lifetime.start.p0(ptr %l_32531.sroa.3)
  call void @llvm.lifetime.start.p0(ptr %l_32531.sroa.4)
  call void @llvm.memset.p0.i64(ptr null, i8 0, i64 3, i1 false)
  call void @llvm.memset.p0.i64(ptr null, i8 0, i64 115, i1 false)
  %0 = getelementptr inbounds i8, ptr %l_3253, i64 8
  store i8 0, ptr %0, align 4
  %1 = getelementptr inbounds i8, ptr %l_3253, i64 12
  store i8 0, ptr %1, align 4
  %2 = getelementptr inbounds i8, ptr %l_3253, i64 16
  store i8 0, ptr %2, align 4
  %3 = getelementptr inbounds i8, ptr %l_3253, i64 20
  store i8 0, ptr %3, align 4
  %4 = load volatile i16, ptr @g_260, align 4
  %5 = load i16, ptr @g_480, align 4
  %dec.i.i = add i16 %5, -1
  store i16 %dec.i.i, ptr @g_480, align 4
  %call1 = tail call i32 @use(i32 0, ptr @g_480)
  ret i32 %call1
}

declare i32 @use(i32, ptr)
