; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=aarch64-linux-gnu < %s | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -mtriple=aarch64-linux-gnu -global-isel < %s | FileCheck %s --check-prefixes=CHECK,CHECK-GI

declare i64 @bar()

define i64 @test_or(float %a, float %b) {
; CHECK-SD-LABEL: test_or:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    fcmp s0, #0.0
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    b.ne .LBB0_3
; CHECK-SD-NEXT:  // %bb.1: // %bb1
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    b.ne .LBB0_3
; CHECK-SD-NEXT:  // %bb.2: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:  .LBB0_3: // %common.ret
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_or:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    b.ne .LBB0_3
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    b.ne .LBB0_3
; CHECK-GI-NEXT:  // %bb.2: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB0_3:
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp une float %a, 0.0
  %1 = fcmp une float %b, 0.0
  %or.cond = or i1 %0, %1
  br i1 %or.cond, label %bb3, label %bb4

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}

define i64 @test_or_select(float %a, float %b) {
; CHECK-SD-LABEL: test_or_select:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    fcmp s0, #0.0
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    b.ne .LBB1_3
; CHECK-SD-NEXT:  // %bb.1: // %bb1
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    b.ne .LBB1_3
; CHECK-SD-NEXT:  // %bb.2: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:  .LBB1_3: // %common.ret
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_or_select:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    b.ne .LBB1_3
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    b.ne .LBB1_3
; CHECK-GI-NEXT:  // %bb.2: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB1_3:
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp une float %a, 0.0
  %1 = fcmp une float %b, 0.0
  %or.cond = select i1 %0, i1 true, i1 %1
  br i1 %or.cond, label %bb3, label %bb4

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}

define i64 @test_and(float %a, float %b) {
; CHECK-SD-LABEL: test_and:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    fcmp s0, #0.0
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    b.mi .LBB2_2
; CHECK-SD-NEXT:    b.gt .LBB2_2
; CHECK-SD-NEXT:  // %bb.1: // %bb1
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    b.eq .LBB2_3
; CHECK-SD-NEXT:    b.vs .LBB2_3
; CHECK-SD-NEXT:  .LBB2_2: // %common.ret
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB2_3: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_and:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.mi .LBB2_2
; CHECK-GI-NEXT:    b.gt .LBB2_2
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.eq .LBB2_3
; CHECK-GI-NEXT:    b.vs .LBB2_3
; CHECK-GI-NEXT:  .LBB2_2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB2_3: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp ueq float %a, 0.0
  %1 = fcmp ueq float %b, 0.0
  %or.cond = and i1 %0, %1
  br i1 %or.cond, label %bb4, label %bb3

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}

define i64 @test_and_select(float %a, float %b) {
; CHECK-SD-LABEL: test_and_select:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    fcmp s0, #0.0
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    b.mi .LBB3_2
; CHECK-SD-NEXT:    b.gt .LBB3_2
; CHECK-SD-NEXT:  // %bb.1: // %bb1
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    b.eq .LBB3_3
; CHECK-SD-NEXT:    b.vs .LBB3_3
; CHECK-SD-NEXT:  .LBB3_2: // %common.ret
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB3_3: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_and_select:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.mi .LBB3_2
; CHECK-GI-NEXT:    b.gt .LBB3_2
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.eq .LBB3_3
; CHECK-GI-NEXT:    b.vs .LBB3_3
; CHECK-GI-NEXT:  .LBB3_2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB3_3: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp ueq float %a, 0.0
  %1 = fcmp ueq float %b, 0.0
  %or.cond = select i1 %0, i1 %1, i1 false
  br i1 %or.cond, label %bb4, label %bb3

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}


define i64 @test_or_fast(float %a, float %b) {
; CHECK-SD-LABEL: test_or_fast:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    movi d2, #0000000000000000
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    fccmp s0, s2, #0, eq
; CHECK-SD-NEXT:    cset w8, eq
; CHECK-SD-NEXT:    tbnz w8, #0, .LBB4_2
; CHECK-SD-NEXT:  // %bb.1:
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB4_2: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_or_fast:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    b.ne .LBB4_3
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    b.ne .LBB4_3
; CHECK-GI-NEXT:  // %bb.2: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB4_3:
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp fast une float %a, 0.0
  %1 = fcmp fast une float %b, 0.0
  %or.cond = or i1 %0, %1
  br i1 %or.cond, label %bb3, label %bb4

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}

define i64 @test_or_select_fast (float %a, float %b) {
; CHECK-SD-LABEL: test_or_select_fast:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    fcmp s0, #0.0
; CHECK-SD-NEXT:    cset w8, ne
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    cset w9, ne
; CHECK-SD-NEXT:    orr w8, w8, w9
; CHECK-SD-NEXT:    tbz w8, #0, .LBB5_2
; CHECK-SD-NEXT:  // %bb.1:
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB5_2: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_or_select_fast:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    b.ne .LBB5_3
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    b.ne .LBB5_3
; CHECK-GI-NEXT:  // %bb.2: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB5_3:
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp fast une float %a, 0.0
  %1 = fcmp fast une float %b, 0.0
  %or.cond = select i1 %0, i1 true, i1 %1
  br i1 %or.cond, label %bb3, label %bb4

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}

define i64 @test_and_fast(float %a, float %b) {
; CHECK-SD-LABEL: test_and_fast:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    movi d2, #0000000000000000
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    fccmp s0, s2, #0, eq
; CHECK-SD-NEXT:    cset w8, eq
; CHECK-SD-NEXT:    tbz w8, #0, .LBB6_2
; CHECK-SD-NEXT:  // %bb.1: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB6_2:
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_and_fast:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.mi .LBB6_2
; CHECK-GI-NEXT:    b.gt .LBB6_2
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.eq .LBB6_3
; CHECK-GI-NEXT:    b.vs .LBB6_3
; CHECK-GI-NEXT:  .LBB6_2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB6_3: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp fast ueq float %a, 0.0
  %1 = fcmp fast ueq float %b, 0.0
  %or.cond = and i1 %0, %1
  br i1 %or.cond, label %bb4, label %bb3

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}

define i64 @test_and_select_fast(float %a, float %b) {
; CHECK-SD-LABEL: test_and_select_fast:
; CHECK-SD:       // %bb.0: // %bb1
; CHECK-SD-NEXT:    fcmp s0, #0.0
; CHECK-SD-NEXT:    cset w8, eq
; CHECK-SD-NEXT:    fcmp s1, #0.0
; CHECK-SD-NEXT:    cset w9, eq
; CHECK-SD-NEXT:    and w8, w8, w9
; CHECK-SD-NEXT:    tbz w8, #0, .LBB7_2
; CHECK-SD-NEXT:  // %bb.1: // %bb4
; CHECK-SD-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SD-NEXT:    .cfi_def_cfa_offset 16
; CHECK-SD-NEXT:    .cfi_offset w30, -16
; CHECK-SD-NEXT:    bl bar
; CHECK-SD-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SD-NEXT:    ret
; CHECK-SD-NEXT:  .LBB7_2:
; CHECK-SD-NEXT:    mov x0, xzr
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: test_and_select_fast:
; CHECK-GI:       // %bb.0: // %bb1
; CHECK-GI-NEXT:    fcmp s0, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.mi .LBB7_2
; CHECK-GI-NEXT:    b.gt .LBB7_2
; CHECK-GI-NEXT:  // %bb.1: // %bb1
; CHECK-GI-NEXT:    fcmp s1, #0.0
; CHECK-GI-NEXT:    mov x0, xzr
; CHECK-GI-NEXT:    b.eq .LBB7_3
; CHECK-GI-NEXT:    b.vs .LBB7_3
; CHECK-GI-NEXT:  .LBB7_2: // %common.ret
; CHECK-GI-NEXT:    ret
; CHECK-GI-NEXT:  .LBB7_3: // %bb4
; CHECK-GI-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-GI-NEXT:    .cfi_def_cfa_offset 16
; CHECK-GI-NEXT:    .cfi_offset w30, -16
; CHECK-GI-NEXT:    bl bar
; CHECK-GI-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-GI-NEXT:    ret
bb1:
  %0 = fcmp fast ueq float %a, 0.0
  %1 = fcmp fast ueq float %b, 0.0
  %or.cond = select i1 %0, i1 %1, i1 false
  br i1 %or.cond, label %bb4, label %bb3

bb3:
  ret i64 0

bb4:
  %2 = call i64 @bar()
  ret i64 %2
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
