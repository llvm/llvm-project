; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple aarch64-unknown-windows-msvc %s -o - | FileCheck %s

declare i32 @__CxxFrameHandler3(...)

declare void @llvm.seh.try.begin() #0

define fastcc ptr @test_function(i1 %0, ptr %_Fmtfl.i.i, i1 %1) personality ptr @__CxxFrameHandler3 {
; CHECK-LABEL: test_function:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:  .seh_proc test_function
; CHECK-NEXT:    .seh_handler __CxxFrameHandler3, @unwind, @except
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 32
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .seh_set_fp
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x3, #-2 // =0xfffffffffffffffe
; CHECK-NEXT:    stur x3, [x29, #16]
; CHECK-NEXT:    tbz w0, #0, .LBB0_3
; CHECK-NEXT:  // %bb.1: // %invoke.cont.i124
; CHECK-NEXT:    mov x0, x1
; CHECK-NEXT:    b .LBB0_4
; CHECK-NEXT:  .LBB0_2: // Block address taken
; CHECK-NEXT:    // %some-block
; CHECK-NEXT:  $ehgcr_0_2:
; CHECK-NEXT:  .LBB0_3: // %left-block526
; CHECK-NEXT:    mov x0, xzr
; CHECK-NEXT:  .LBB0_4: // %common.ret1
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 32
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_handlerdata
; CHECK-NEXT:    .word ($cppxdata$test_function)@IMGREL
; CHECK-NEXT:    .text
; CHECK-NEXT:    .seh_endproc
; CHECK-NEXT:    .def "?catch$5@?0?test_function@4HA";
; CHECK-NEXT:    .scl 3;
; CHECK-NEXT:    .type 32;
; CHECK-NEXT:    .endef
; CHECK-NEXT:    .p2align 2
; CHECK-NEXT:  "?catch$5@?0?test_function@4HA":
; CHECK-NEXT:  .seh_proc "?catch$5@?0?test_function@4HA"
; CHECK-NEXT:    .seh_handler __CxxFrameHandler3, @unwind, @except
; CHECK-NEXT:  .LBB0_5: // %catch.i
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    adrp x0, .LBB0_2
; CHECK-NEXT:    add x0, x0, .LBB0_2
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
entry:
  br i1 %0, label %right-block527, label %left-block526

common.ret1:
  %common.ret1.op = phi ptr [ null, %left-block530 ], [ null, %some-block ], [ %_Fmtfl.i.i, %invoke.cont.i124 ], [ null, %left-block526 ]
  ret ptr %common.ret1.op

invoke.cont.i124:
  %.not657 = icmp eq i32 1, 0
  br i1 %.not657, label %some-block, label %common.ret1

catch.dispatch.i:
  %2 = catchswitch within none [label %catch.i] unwind to caller

catch.i:
  %3 = catchpad within %2 [ptr null, i32 0, ptr null]
  catchret from %3 to label %some-block

some-block:
  br label %common.ret1

left-block526:
  br i1 %1, label %common.ret1, label %left-block530

right-block527:
  invoke void @llvm.seh.try.begin()
          to label %invoke.cont.i124 unwind label %catch.dispatch.i

left-block530:
  %.not = icmp eq i32 0, 0
  br label %common.ret1
}

attributes #0 = { nounwind willreturn memory(write) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"eh-asynch", i32 1}
