; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple aarch64-unknown-unknown -mattr=+fullfp16,+fprcvt | FileCheck %s

; These tests ensure bitcasts are correctly emitted for scalar_to_vector
; by checking if NEON variant of conversion instruction was selected

define <2 x i32> @fcvtzs_v2i32_scalar_to_vector(float %a) {
; CHECK-LABEL: fcvtzs_v2i32_scalar_to_vector:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fcvtzs w8, s0
; CHECK-NEXT:    fmov s0, w8
; CHECK-NEXT:    ret
  %c = fptosi float %a to i32
  %v = insertelement <2 x i32> poison, i32 %c, i32 0
  ret <2 x i32> %v
}

define <4 x i32> @fcvtzs_v4i32_scalar_to_vector(float %a) {
; CHECK-LABEL: fcvtzs_v4i32_scalar_to_vector:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fcvtzs w8, d0
; CHECK-NEXT:    fmov s0, w8
; CHECK-NEXT:    ret
  %c = fptosi float %a to i32
  %v = insertelement <4 x i32> poison, i32 %c, i32 0
  ret <4 x i32> %v
}

define <1 x i64> @fcvtzs_v1i64_scalar_to_vector(double %a) {
; CHECK-LABEL: fcvtzs_v1i64_scalar_to_vector:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fcvtzs x8, h0
; CHECK-NEXT:    fmov d0, x8
; CHECK-NEXT:    ret
  %c = fptosi double %a to i64
  %v = insertelement <1 x i64> poison, i64 %c, i32 0
  ret <1 x i64> %v
}

define <2 x i64> @fcvtzs_v2i64_scalar_to_vector(double %a) {
; CHECK-LABEL: fcvtzs_v2i64_scalar_to_vector:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fcvtzs x8, s0
; CHECK-NEXT:    fmov d0, x8
; CHECK-NEXT:    ret
  %c = fptosi double %a to i64
  %v = insertelement <2 x i64> poison, i64 %c, i32 0
  ret <2 x i64> %v
}
