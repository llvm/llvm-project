; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-- -o - < %s | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -mtriple=aarch64-- -global-isel -o - < %s | FileCheck %s --check-prefixes=CHECK,CHECK-GI

; Verify that we can fold csneg/csel into csinc instruction.

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

; char csinc1 (char a, char b) { return !a ? b+1 : b+3; }
define i8 @csinc1(i8 %a, i8 %b) local_unnamed_addr #0 {
; CHECK-SD-LABEL: csinc1:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    tst w0, #0xff
; CHECK-SD-NEXT:    add w8, w1, #3
; CHECK-SD-NEXT:    csinc w0, w8, w1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc1:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #3 // =0x3
; CHECK-GI-NEXT:    tst w0, #0xff
; CHECK-GI-NEXT:    csinc w8, w8, wzr, ne
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i8 %a, 0
  %cond.v = select i1 %tobool.not, i8 1, i8 3
  %cond = add i8 %cond.v, %b
  ret i8 %cond
}

; short csinc2 (short a, short b) { return !a ? b+1 : b+3; }
define i16 @csinc2(i16 %a, i16 %b) local_unnamed_addr #0 {
; CHECK-SD-LABEL: csinc2:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    tst w0, #0xffff
; CHECK-SD-NEXT:    add w8, w1, #3
; CHECK-SD-NEXT:    csinc w0, w8, w1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc2:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #3 // =0x3
; CHECK-GI-NEXT:    tst w0, #0xffff
; CHECK-GI-NEXT:    csinc w8, w8, wzr, ne
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i16 %a, 0
  %cond.v = select i1 %tobool.not, i16 1, i16 3
  %cond = add i16 %cond.v, %b
  ret i16 %cond
}

; int csinc3 (int a, int b) { return !a ? b+1 : b+3; }
define i32 @csinc3(i32 %a, i32 %b) local_unnamed_addr #0 {
; CHECK-SD-LABEL: csinc3:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    add w8, w1, #3
; CHECK-SD-NEXT:    csinc w0, w8, w1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc3:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #3 // =0x3
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csinc w8, w8, wzr, ne
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 1, i32 3
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; long long csinc4 (long long a, long long b) { return !a ? b+1 : b+3; }
define i64 @csinc4(i64 %a, i64 %b) local_unnamed_addr #0 {
; CHECK-SD-LABEL: csinc4:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp x0, #0
; CHECK-SD-NEXT:    add x8, x1, #3
; CHECK-SD-NEXT:    csinc x0, x8, x1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc4:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #3 // =0x3
; CHECK-GI-NEXT:    cmp x0, #0
; CHECK-GI-NEXT:    csinc x8, x8, xzr, ne
; CHECK-GI-NEXT:    add x0, x8, x1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i64 %a, 0
  %cond.v = select i1 %tobool.not, i64 1, i64 3
  %cond = add nsw i64 %cond.v, %b
  ret i64 %cond
}

; long long csinc8 (long long a, long long b) { return a ? b-1 : b+1; }
define i64 @csinc8(i64 %a, i64 %b) {
; CHECK-SD-LABEL: csinc8:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub x8, x1, #1
; CHECK-SD-NEXT:    cmp x0, #0
; CHECK-SD-NEXT:    csinc x0, x8, x1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc8:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp x0, #0
; CHECK-GI-NEXT:    cset w8, ne
; CHECK-GI-NEXT:    sbfx x8, x8, #0, #1
; CHECK-GI-NEXT:    orr x8, x8, #0x1
; CHECK-GI-NEXT:    add x0, x8, x1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i64 %a, 0
  %cond.v = select i1 %tobool.not, i64 1, i64 -1
  %cond = add nsw i64 %cond.v, %b
  ret i64 %cond
}

; long long csinc9 (long long a, long long b) { return a ? b+1 : b-1; }
define i64 @csinc9(i64 %a, i64 %b) {
; CHECK-SD-LABEL: csinc9:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub x8, x1, #1
; CHECK-SD-NEXT:    cmp x0, #0
; CHECK-SD-NEXT:    csinc x0, x8, x1, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc9:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp x0, #0
; CHECK-GI-NEXT:    cset w8, eq
; CHECK-GI-NEXT:    sbfx x8, x8, #0, #1
; CHECK-GI-NEXT:    orr x8, x8, #0x1
; CHECK-GI-NEXT:    add x0, x8, x1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i64 %a, 0
  %cond.v = select i1 %tobool.not, i64 -1, i64 1
  %cond = add nsw i64 %cond.v, %b
  ret i64 %cond
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
