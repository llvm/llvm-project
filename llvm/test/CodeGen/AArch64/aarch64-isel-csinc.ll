; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-- -o - < %s | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -mtriple=aarch64-- -global-isel -o - < %s | FileCheck %s --check-prefixes=CHECK,CHECK-GI

; Verify that we can fold csneg/csel into csinc instruction.

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

; int csinc1 (int a, int b) { return !a ? b+3 : b+1; }
define i32 @csinc1(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc1:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    add w8, w1, #3
; CHECK-SD-NEXT:    csinc w0, w8, w1, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc1:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #3 // =0x3
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csinc w8, w8, wzr, eq
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 3, i32 1
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; int csinc2 (int a, int b) { return a ? b+3 : b+1; }
define i32 @csinc2(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc2:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    add w8, w1, #3
; CHECK-SD-NEXT:    csinc w0, w8, w1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc2:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #3 // =0x3
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csinc w8, w8, wzr, ne
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 1, i32 3
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; int csinc3 (int a, int b) { return !a ? b+1 : b-3; }
define i32 @csinc3(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc3:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub w8, w1, #3
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    csinc w0, w8, w1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc3:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #-3 // =0xfffffffd
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csinc w8, w8, wzr, ne
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 1, i32 -3
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; int csinc4 (int a, int b) { return a ? b+1 : b-3; }
define i32 @csinc4(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc4:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub w8, w1, #3
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    csinc w0, w8, w1, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc4:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #-3 // =0xfffffffd
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csinc w8, w8, wzr, eq
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 -3, i32 1
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; int csinc5 (int a, int b) { return a ? b+1 : b-4095; }
define i32 @csinc5(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc5:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub w8, w1, #4095
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    csinc w0, w8, w1, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc5:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #-4095 // =0xfffff001
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csinc w8, w8, wzr, eq
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 -4095, i32 1
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; int csinc6 (int a, int b) { return a ? b+1 : b-4096; }
define i32 @csinc6(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc6:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub w8, w1, #1, lsl #12 // =4096
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    csinc w0, w8, w1, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc6:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    mov w8, #-4096 // =0xfffff000
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    csinc w8, w8, wzr, eq
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 -4096, i32 1
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; prevent larger constants (the add laid after csinc)
; int csinc7 (int a, int b) { return a ? b+1 : b-4097; }
define i32 @csinc7(i32 %a, i32 %b) {
; CHECK-LABEL: csinc7:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mov w8, #-4097 // =0xffffefff
; CHECK-NEXT:    cmp w0, #0
; CHECK-NEXT:    csinc w8, w8, wzr, eq
; CHECK-NEXT:    add w0, w8, w1
; CHECK-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 -4097, i32 1
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; int csinc8 (int a, int b) { return a ? b-1 : b+1; }
define i32 @csinc8(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc8:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub w8, w1, #1
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    csinc w0, w8, w1, ne
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc8:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    cset w8, ne
; CHECK-GI-NEXT:    sbfx w8, w8, #0, #1
; CHECK-GI-NEXT:    orr w8, w8, #0x1
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 1, i32 -1
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}

; int csinc9 (int a, int b) { return a ? b+1 : b-1; }
define i32 @csinc9(i32 %a, i32 %b) {
; CHECK-SD-LABEL: csinc9:
; CHECK-SD:       // %bb.0: // %entry
; CHECK-SD-NEXT:    sub w8, w1, #1
; CHECK-SD-NEXT:    cmp w0, #0
; CHECK-SD-NEXT:    csinc w0, w8, w1, eq
; CHECK-SD-NEXT:    ret
;
; CHECK-GI-LABEL: csinc9:
; CHECK-GI:       // %bb.0: // %entry
; CHECK-GI-NEXT:    cmp w0, #0
; CHECK-GI-NEXT:    cset w8, eq
; CHECK-GI-NEXT:    sbfx w8, w8, #0, #1
; CHECK-GI-NEXT:    orr w8, w8, #0x1
; CHECK-GI-NEXT:    add w0, w8, w1
; CHECK-GI-NEXT:    ret
entry:
  %tobool.not = icmp eq i32 %a, 0
  %cond.v = select i1 %tobool.not, i32 -1, i32 1
  %cond = add nsw i32 %cond.v, %b
  ret i32 %cond
}
