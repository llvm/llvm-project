; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=aarch64 -mattr=+v8.9a --global-isel=0 < %s | FileCheck %s
; RUN: llc -mtriple=aarch64 -mattr=+v8.9a --global-isel=1 --global-isel-abort=1 < %s | FileCheck %s

define void @range_prefetch_metadata_val(ptr %a, ptr %b, i64 %metadata) {
; CHECK-LABEL: range_prefetch_metadata_val:
; CHECK:       // %bb.0:
; CHECK-NEXT:    rprfm pldkeep, x2, [x0]
; CHECK-NEXT:    rprfm pstkeep, x2, [x0]
; CHECK-NEXT:    rprfm pldstrm, x2, [x0]
; CHECK-NEXT:    rprfm pststrm, x2, [x0]
; CHECK-NEXT:    ret

  call void @llvm.aarch64.range.prefetch.reg(ptr %a, i32 0, i32 0, i64 %metadata)
  call void @llvm.aarch64.range.prefetch.reg(ptr %a, i32 1, i32 0, i64 %metadata)
  call void @llvm.aarch64.range.prefetch.reg(ptr %a, i32 0, i32 1, i64 %metadata)
  call void @llvm.aarch64.range.prefetch.reg(ptr %a, i32 1, i32 1, i64 %metadata)

  ret void
}

define void @range_prefetch_accesses(ptr %a) {
; CHECK-LABEL: range_prefetch_accesses:
; CHECK:       // %bb.0:
; CHECK-NEXT:    rprfm pldkeep, xzr, [x0]
; CHECK-NEXT:    rprfm pstkeep, xzr, [x0]
; CHECK-NEXT:    rprfm pldstrm, xzr, [x0]
; CHECK-NEXT:    rprfm pststrm, xzr, [x0]
; CHECK-NEXT:    ret

  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 0, i32 0, i32 0, i32 1, i32 0, i64 0)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 1, i32 0, i32 0, i32 1, i32 0, i64 0)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 0, i32 1, i32 0, i32 1, i32 0, i64 0)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 1, i32 1, i32 0, i32 1, i32 0, i64 0)
  ret void
}

define void @range_prefetch_metatdata_distance_rounding(ptr %a) {
; CHECK-LABEL: range_prefetch_metatdata_distance_rounding:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, #-1152921504606846976 // =0xf000000000000000
; CHECK-NEXT:    mov x9, #-2305843009213693952 // =0xe000000000000000
; CHECK-NEXT:    mov x10, #-6917529027641081856 // =0xa000000000000000
; CHECK-NEXT:    rprfm pldkeep, x8, [x0]
; CHECK-NEXT:    rprfm pldkeep, x9, [x0]
; CHECK-NEXT:    rprfm pldkeep, x10, [x0]
; CHECK-NEXT:    rprfm pldkeep, xzr, [x0]
; CHECK-NEXT:    ret

  ; Distance less than minumum, round up to first power of two (1111)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 0, i32 0, i32 0, i32 1, i32 0, i64 1)

  ; Distance 1 over minimum, round up to next power of 2 (1110)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 0, i32 0, i32 0, i32 1, i32 0, i64 32769)

  ; Distance is a power of two in range (1010)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 0, i32 0, i32 0, i32 1, i32 0, i64 1048576)

  ; Distance is out of range, set to 0 (0000)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 0, i32 0, i32 0, i32 1, i32 0, i64 536870913)

  ret void
}

define void @range_prefetch_metatdata(ptr %a) {
; CHECK-LABEL: range_prefetch_metatdata:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, #274869518336 // =0x3fff800000
; CHECK-NEXT:    mov x9, #4192256 // =0x3ff800
; CHECK-NEXT:    movk x8, #2040
; CHECK-NEXT:    orr x9, x9, #0x1fe0000000000
; CHECK-NEXT:    movk x8, #4094, lsl #48
; CHECK-NEXT:    rprfm pststrm, x8, [x0]
; CHECK-NEXT:    rprfm pststrm, x9, [x0]
; CHECK-NEXT:    ret

  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 1, i32 1, i32 2040, i32 65535, i32 -2048, i64 0)
  call void @llvm.aarch64.range.prefetch.imm(ptr %a, i32 1, i32 1, i32 -2048, i32 1, i32 2040, i64 0)
  ret void
}
