; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64 %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-SD
; RUN: llc -mtriple=aarch64 -global-isel=true -global-isel-abort=2 %s -o - 2>&1 | FileCheck %s --check-prefixes=CHECK,CHECK-GI

; CHECK-GI:       warning: Instruction selection used fallback path for unused_div_fpexcept_strict
; CHECK-GI-NEXT:  warning: Instruction selection used fallback path for unused_div_round_dynamic
; CHECK-GI-NEXT:  warning: Instruction selection used fallback path for add_twice_fpexcept_strict
; CHECK-GI-NEXT:  warning: Instruction selection used fallback path for add_twice_round_dynamic
; CHECK-GI-NEXT:  warning: Instruction selection used fallback path for set_rounding
; CHECK-GI-NEXT:  warning: Instruction selection used fallback path for set_rounding_fpexcept_strict
; CHECK-GI-NEXT:  warning: Instruction selection used fallback path for set_rounding_round_dynamic

; Div whose result is unused should be removed unless we have strict exceptions

define void @unused_div(float %x, float %y) {
; CHECK-LABEL: unused_div:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ret
entry:
  %add = fdiv float %x, %y
  ret void
}

define void @unused_div_fpexcept_strict(float %x, float %y) #0 {
; CHECK-LABEL: unused_div_fpexcept_strict:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fdiv s0, s0, s1
; CHECK-NEXT:    ret
entry:
  %add = call float @llvm.experimental.constrained.fdiv.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
  ret void
}

define void @unused_div_round_dynamic(float %x, float %y) #0 {
; CHECK-LABEL: unused_div_round_dynamic:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    ret
entry:
  %add = call float @llvm.experimental.constrained.fdiv.f32(float %x, float %y, metadata !"round.dynamic", metadata !"fpexcept.ignore") #0
  ret void
}


; Machine CSE should eliminate the second add unless we have strict exceptions
define float @add_twice(float %x, float %y, i32 %n) {
; CHECK-LABEL: add_twice:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    cmp w0, #0
; CHECK-NEXT:    fmul s1, s0, s0
; CHECK-NEXT:    fcsel s0, s0, s1, eq
; CHECK-NEXT:    ret
entry:
  %add = fadd float %x, %y
  %tobool.not = icmp eq i32 %n, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:
  %add1 = fadd float %x, %y
  %mul = fmul float %add, %add1
  br label %if.end

if.end:
  %a.0 = phi float [ %mul, %if.then ], [ %add, %entry ]
  ret float %a.0
}

define float @add_twice_fpexcept_strict(float %x, float %y, i32 %n) #0 {
; CHECK-LABEL: add_twice_fpexcept_strict:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fmov s2, s0
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    cbz w0, .LBB4_2
; CHECK-NEXT:  // %bb.1: // %if.then
; CHECK-NEXT:    fadd s1, s2, s1
; CHECK-NEXT:    fmul s0, s0, s1
; CHECK-NEXT:  .LBB4_2: // %if.end
; CHECK-NEXT:    ret
entry:
  %add = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
  %tobool.not = icmp eq i32 %n, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:
  %add1 = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
  %mul = call float @llvm.experimental.constrained.fmul.f32(float %add, float %add1, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
  br label %if.end

if.end:
  %a.0 = phi float [ %mul, %if.then ], [ %add, %entry ]
  ret float %a.0
}

define float @add_twice_round_dynamic(float %x, float %y, i32 %n) #0 {
; CHECK-LABEL: add_twice_round_dynamic:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    cbz w0, .LBB5_2
; CHECK-NEXT:  // %bb.1: // %if.then
; CHECK-NEXT:    fmul s0, s0, s0
; CHECK-NEXT:  .LBB5_2: // %if.end
; CHECK-NEXT:    ret
entry:
  %add = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.dynamic", metadata !"fpexcept.ignore") #0
  %tobool.not = icmp eq i32 %n, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:
  %add1 = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.dynamic", metadata !"fpexcept.ignore") #0
  %mul = call float @llvm.experimental.constrained.fmul.f32(float %add, float %add1, metadata !"round.dynamic", metadata !"fpexcept.ignore") #0
  br label %if.end

if.end:
  %a.0 = phi float [ %mul, %if.then ], [ %add, %entry ]
  ret float %a.0
}


; Two adds separated by llvm.set.rounding should be preserved when rounding is
; dynamic (as they may give different results) or when we have strict exceptions
; (the llvm.set.rounding is irrelevant, but both could trap).

define float @set_rounding(float %x, float %y) {
; CHECK-LABEL: set_rounding:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mrs x8, FPCR
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    orr x8, x8, #0xc00000
; CHECK-NEXT:    msr FPCR, x8
; CHECK-NEXT:    mrs x8, FPCR
; CHECK-NEXT:    and x8, x8, #0xffffffffff3fffff
; CHECK-NEXT:    msr FPCR, x8
; CHECK-NEXT:    fsub s0, s0, s0
; CHECK-NEXT:    ret
entry:
  %add1 = fadd float %x, %y
  call void @llvm.set.rounding(i32 0)
  %add2 = fadd float %x, %y
  call void @llvm.set.rounding(i32 1)
  %sub = fsub float %add1, %add2
  ret float %sub
}

define float @set_rounding_fpexcept_strict(float %x, float %y) #0 {
; CHECK-LABEL: set_rounding_fpexcept_strict:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    fadd s2, s0, s1
; CHECK-NEXT:    mrs x8, FPCR
; CHECK-NEXT:    orr x8, x8, #0xc00000
; CHECK-NEXT:    msr FPCR, x8
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    mrs x8, FPCR
; CHECK-NEXT:    and x8, x8, #0xffffffffff3fffff
; CHECK-NEXT:    msr FPCR, x8
; CHECK-NEXT:    fsub s0, s2, s0
; CHECK-NEXT:    ret
entry:
  %add1 = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
  call void @llvm.set.rounding(i32 0) #0
  %add2 = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
  call void @llvm.set.rounding(i32 1) #0
  %sub = call float @llvm.experimental.constrained.fsub.f32(float %add1, float %add2, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
  ret float %sub
}

define float @set_rounding_round_dynamic(float %x, float %y) #0 {
; CHECK-LABEL: set_rounding_round_dynamic:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    mrs x8, FPCR
; CHECK-NEXT:    fadd s2, s0, s1
; CHECK-NEXT:    orr x8, x8, #0xc00000
; CHECK-NEXT:    msr FPCR, x8
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    mrs x8, FPCR
; CHECK-NEXT:    and x8, x8, #0xffffffffff3fffff
; CHECK-NEXT:    msr FPCR, x8
; CHECK-NEXT:    fsub s0, s2, s0
; CHECK-NEXT:    ret
entry:
  %add1 = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.dynamic", metadata !"fpexcept.ignore") #0
  call void @llvm.set.rounding(i32 0) #0
  %add2 = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.dynamic", metadata !"fpexcept.ignore") #0
  call void @llvm.set.rounding(i32 1) #0
  %sub = call float @llvm.experimental.constrained.fsub.f32(float %add1, float %add2, metadata !"round.dynamic", metadata !"fpexcept.ignore") #0
  ret float %sub
}

declare float @llvm.experimental.constrained.fadd.f32(float, float, metadata, metadata)
declare float @llvm.experimental.constrained.fsub.f32(float, float, metadata, metadata)
declare float @llvm.experimental.constrained.fmul.f32(float, float, metadata, metadata)
declare float @llvm.experimental.constrained.fdiv.f32(float, float, metadata, metadata)
declare i32 @llvm.get.rounding()
declare void @llvm.set.rounding(i32)

attributes #0 = { strictfp }
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK-GI: {{.*}}
; CHECK-SD: {{.*}}
