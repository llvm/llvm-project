; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64 -mattr=+sve | FileCheck %s -check-prefix=CHECK-SVE
; RUN: llc < %s -mtriple=aarch64 -global-isel | FileCheck %s -check-prefix=CHECK-NEON

define i64 @smax(<2 x i64> %0) {
; CHECK-SVE-LABEL: smax:
; CHECK-SVE:       // %bb.0:
; CHECK-SVE-NEXT:    ptrue p0.d, vl2
; CHECK-SVE-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE-NEXT:    smaxv d0, p0, z0.d
; CHECK-SVE-NEXT:    fmov x0, d0
; CHECK-SVE-NEXT:    ret
;
; CHECK-NEON-LABEL: smax:
; CHECK-NEON:       // %bb.0:
; CHECK-NEON-NEXT:    mov d1, v0.d[1]
; CHECK-NEON-NEXT:    fmov x8, d0
; CHECK-NEON-NEXT:    fmov x9, d1
; CHECK-NEON-NEXT:    cmp x8, x9
; CHECK-NEON-NEXT:    fcsel d0, d0, d1, gt
; CHECK-NEON-NEXT:    fmov x0, d0
; CHECK-NEON-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.smax.i64(i64 %2, i64 %3)
  ret i64 %4
}

define i64 @umax(<2 x i64> %0) {
; CHECK-SVE-LABEL: umax:
; CHECK-SVE:       // %bb.0:
; CHECK-SVE-NEXT:    ptrue p0.d, vl2
; CHECK-SVE-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE-NEXT:    umaxv d0, p0, z0.d
; CHECK-SVE-NEXT:    fmov x0, d0
; CHECK-SVE-NEXT:    ret
;
; CHECK-NEON-LABEL: umax:
; CHECK-NEON:       // %bb.0:
; CHECK-NEON-NEXT:    mov d1, v0.d[1]
; CHECK-NEON-NEXT:    fmov x8, d0
; CHECK-NEON-NEXT:    fmov x9, d1
; CHECK-NEON-NEXT:    cmp x8, x9
; CHECK-NEON-NEXT:    fcsel d0, d0, d1, hi
; CHECK-NEON-NEXT:    fmov x0, d0
; CHECK-NEON-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.umax.i64(i64 %2, i64 %3)
  ret i64 %4
}

define i64 @smin(<2 x i64> %0) {
; CHECK-SVE-LABEL: smin:
; CHECK-SVE:       // %bb.0:
; CHECK-SVE-NEXT:    ptrue p0.d, vl2
; CHECK-SVE-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE-NEXT:    sminv d0, p0, z0.d
; CHECK-SVE-NEXT:    fmov x0, d0
; CHECK-SVE-NEXT:    ret
;
; CHECK-NEON-LABEL: smin:
; CHECK-NEON:       // %bb.0:
; CHECK-NEON-NEXT:    mov d1, v0.d[1]
; CHECK-NEON-NEXT:    fmov x8, d0
; CHECK-NEON-NEXT:    fmov x9, d1
; CHECK-NEON-NEXT:    cmp x8, x9
; CHECK-NEON-NEXT:    fcsel d0, d0, d1, lt
; CHECK-NEON-NEXT:    fmov x0, d0
; CHECK-NEON-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.smin.i64(i64 %2, i64 %3)
  ret i64 %4
}

define i64 @umin(<2 x i64> %0) {
; CHECK-SVE-LABEL: umin:
; CHECK-SVE:       // %bb.0:
; CHECK-SVE-NEXT:    ptrue p0.d, vl2
; CHECK-SVE-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE-NEXT:    uminv d0, p0, z0.d
; CHECK-SVE-NEXT:    fmov x0, d0
; CHECK-SVE-NEXT:    ret
;
; CHECK-NEON-LABEL: umin:
; CHECK-NEON:       // %bb.0:
; CHECK-NEON-NEXT:    mov d1, v0.d[1]
; CHECK-NEON-NEXT:    fmov x8, d0
; CHECK-NEON-NEXT:    fmov x9, d1
; CHECK-NEON-NEXT:    cmp x8, x9
; CHECK-NEON-NEXT:    fcsel d0, d0, d1, lo
; CHECK-NEON-NEXT:    fmov x0, d0
; CHECK-NEON-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.umin.i64(i64 %2, i64 %3)
  ret i64 %4
}
