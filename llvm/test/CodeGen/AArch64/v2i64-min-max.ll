; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=aarch64 -mattr=+sve2 | FileCheck %s -check-prefixes=CHECK-SVE2
; RUN: llc < %s -mtriple=aarch64 -mattr=+sve | FileCheck %s -check-prefixes=CHECK
; RUN: llc < %s -mtriple=aarch64 | FileCheck %s -check-prefixes=CHECK

define i64 @smax(<2 x i64> %0) {
; CHECK-SVE2-LABEL: smax:
; CHECK-SVE2:       // %bb.0:
; CHECK-SVE2-NEXT:    ptrue p0.d, vl2
; CHECK-SVE2-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE2-NEXT:    smaxp z0.d, p0/m, z0.d, z0.d
; CHECK-SVE2-NEXT:    fmov x0, d0
; CHECK-SVE2-NEXT:    ret
;
; CHECK-LABEL: smax:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, v0.d[1]
; CHECK-NEXT:    fmov x9, d0
; CHECK-NEXT:    cmp x9, x8
; CHECK-NEXT:    csel x0, x9, x8, gt
; CHECK-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.smax.i64(i64 %2, i64 %3)
  ret i64 %4
}

define i64 @umax(<2 x i64> %0) {
; CHECK-SVE2-LABEL: umax:
; CHECK-SVE2:       // %bb.0:
; CHECK-SVE2-NEXT:    ptrue p0.d, vl2
; CHECK-SVE2-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE2-NEXT:    umaxp z0.d, p0/m, z0.d, z0.d
; CHECK-SVE2-NEXT:    fmov x0, d0
; CHECK-SVE2-NEXT:    ret
;
; CHECK-LABEL: umax:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, v0.d[1]
; CHECK-NEXT:    fmov x9, d0
; CHECK-NEXT:    cmp x9, x8
; CHECK-NEXT:    csel x0, x9, x8, hi
; CHECK-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.umax.i64(i64 %2, i64 %3)
  ret i64 %4
}

define i64 @smin(<2 x i64> %0) {
; CHECK-SVE2-LABEL: smin:
; CHECK-SVE2:       // %bb.0:
; CHECK-SVE2-NEXT:    ptrue p0.d, vl2
; CHECK-SVE2-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE2-NEXT:    sminp z0.d, p0/m, z0.d, z0.d
; CHECK-SVE2-NEXT:    fmov x0, d0
; CHECK-SVE2-NEXT:    ret
;
; CHECK-LABEL: smin:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, v0.d[1]
; CHECK-NEXT:    fmov x9, d0
; CHECK-NEXT:    cmp x9, x8
; CHECK-NEXT:    csel x0, x9, x8, lt
; CHECK-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.smin.i64(i64 %2, i64 %3)
  ret i64 %4
}

define i64 @umin(<2 x i64> %0) {
; CHECK-SVE2-LABEL: umin:
; CHECK-SVE2:       // %bb.0:
; CHECK-SVE2-NEXT:    ptrue p0.d, vl2
; CHECK-SVE2-NEXT:    // kill: def $q0 killed $q0 def $z0
; CHECK-SVE2-NEXT:    uminp z0.d, p0/m, z0.d, z0.d
; CHECK-SVE2-NEXT:    fmov x0, d0
; CHECK-SVE2-NEXT:    ret
;
; CHECK-LABEL: umin:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, v0.d[1]
; CHECK-NEXT:    fmov x9, d0
; CHECK-NEXT:    cmp x9, x8
; CHECK-NEXT:    csel x0, x9, x8, lo
; CHECK-NEXT:    ret
  %2 = extractelement <2 x i64> %0, i64 0
  %3 = extractelement <2 x i64> %0, i64 1
  %4 = call i64 @llvm.umin.i64(i64 %2, i64 %3)
  ret i64 %4
}

define i64 @umin_different_vectors(<2 x i64> %0, <2 x i64> %1) {
; CHECK-SVE2-LABEL: umin_different_vectors:
; CHECK-SVE2:       // %bb.0:
; CHECK-SVE2-NEXT:    mov x8, v1.d[1]
; CHECK-SVE2-NEXT:    fmov x9, d0
; CHECK-SVE2-NEXT:    cmp x9, x8
; CHECK-SVE2-NEXT:    csel x0, x9, x8, lo
; CHECK-SVE2-NEXT:    ret
;
; CHECK-LABEL: umin_different_vectors:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov x8, v1.d[1]
; CHECK-NEXT:    fmov x9, d0
; CHECK-NEXT:    cmp x9, x8
; CHECK-NEXT:    csel x0, x9, x8, lo
; CHECK-NEXT:    ret
  %3 = extractelement <2 x i64> %0, i64 0
  %4 = extractelement <2 x i64> %1, i64 1
  %5 = call i64 @llvm.umin.i64(i64 %3, i64 %4)
  ret i64 %5
}
