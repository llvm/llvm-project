; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=arm64-apple-ios -o - %s | FileCheck %s
; RUN: llc -mtriple=aarch64_be-unknown-linux -o - %s | FileCheck --check-prefix=CHECK-BE %s

; CHECK-LABEL: lCPI0_0:
; CHECK-NEXT:    .byte   0                               ; 0x0
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   1                               ; 0x1
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   2                               ; 0x2
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   3                               ; 0x3
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:lCPI0_1:
; CHECK-NEXT:    .byte   4                               ; 0x4
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   5                               ; 0x5
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   6                               ; 0x6
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   7                               ; 0x7
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:lCPI0_2:
; CHECK-NEXT:    .byte   8                               ; 0x8
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   9                               ; 0x9
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   10                              ; 0xa
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   11                              ; 0xb
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:lCPI0_3:
; CHECK-NEXT:    .byte   12                              ; 0xc
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   13                              ; 0xd
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   14                              ; 0xe
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   15                              ; 0xf
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff
; CHECK-NEXT:    .byte   255                             ; 0xff

; CHECK-BE: .LCPI0_0:
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	0                               // 0x0
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	1                               // 0x1
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	2                               // 0x2
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	3                               // 0x3
; CHECK-BE-NEXT: .LCPI0_1:
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	4                               // 0x4
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	5                               // 0x5
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	6                               // 0x6
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	7                               // 0x7
; CHECK-BE-NEXT: .LCPI0_2:
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	8                               // 0x8
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	9                               // 0x9
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	10                              // 0xa
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	11                              // 0xb
; CHECK-BE-NEXT: .LCPI0_3:
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	12                              // 0xc
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	13                              // 0xd
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	14                              // 0xe
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	15                              // 0xf

; It's profitable to convert the zext to a shuffle, which in turn will be
; lowered to 4 tbl instructions. The masks are materialized outside the loop.
define void @zext_v16i8_to_v16i32_in_loop(i8* %src, i32* %dst) {
; CHECK-LABEL: zext_v16i8_to_v16i32_in_loop:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:  Lloh0:
; CHECK-NEXT:    adrp x9, lCPI0_0@PAGE
; CHECK-NEXT:  Lloh1:
; CHECK-NEXT:    adrp x10, lCPI0_1@PAGE
; CHECK-NEXT:  Lloh2:
; CHECK-NEXT:    adrp x11, lCPI0_2@PAGE
; CHECK-NEXT:  Lloh3:
; CHECK-NEXT:    adrp x12, lCPI0_3@PAGE
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:  Lloh4:
; CHECK-NEXT:    ldr q0, [x9, lCPI0_0@PAGEOFF]
; CHECK-NEXT:  Lloh5:
; CHECK-NEXT:    ldr q1, [x10, lCPI0_1@PAGEOFF]
; CHECK-NEXT:  Lloh6:
; CHECK-NEXT:    ldr q2, [x11, lCPI0_2@PAGEOFF]
; CHECK-NEXT:  Lloh7:
; CHECK-NEXT:    ldr q3, [x12, lCPI0_3@PAGEOFF]
; CHECK-NEXT:  LBB0_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr q4, [x0, x8]
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    cmp x8, #128
; CHECK-NEXT:    tbl.16b v5, { v4 }, v3
; CHECK-NEXT:    tbl.16b v6, { v4 }, v2
; CHECK-NEXT:    tbl.16b v7, { v4 }, v1
; CHECK-NEXT:    tbl.16b v4, { v4 }, v0
; CHECK-NEXT:    stp q6, q5, [x1, #32]
; CHECK-NEXT:    stp q4, q7, [x1], #64
; CHECK-NEXT:    b.ne LBB0_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdr Lloh3, Lloh7
; CHECK-NEXT:    .loh AdrpLdr Lloh2, Lloh6
; CHECK-NEXT:    .loh AdrpLdr Lloh1, Lloh5
; CHECK-NEXT:    .loh AdrpLdr Lloh0, Lloh4
;
; CHECK-BE-LABEL: zext_v16i8_to_v16i32_in_loop:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    adrp x8, .LCPI0_0
; CHECK-BE-NEXT:    add x8, x8, :lo12:.LCPI0_0
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x8]
; CHECK-BE-NEXT:    adrp x8, .LCPI0_1
; CHECK-BE-NEXT:    add x8, x8, :lo12:.LCPI0_1
; CHECK-BE-NEXT:    ld1 { v1.16b }, [x8]
; CHECK-BE-NEXT:    adrp x8, .LCPI0_2
; CHECK-BE-NEXT:    add x8, x8, :lo12:.LCPI0_2
; CHECK-BE-NEXT:    ld1 { v2.16b }, [x8]
; CHECK-BE-NEXT:    adrp x8, .LCPI0_3
; CHECK-BE-NEXT:    add x8, x8, :lo12:.LCPI0_3
; CHECK-BE-NEXT:    ld1 { v3.16b }, [x8]
; CHECK-BE-NEXT:    mov x8, xzr
; CHECK-BE-NEXT:  .LBB0_1: // %loop
; CHECK-BE-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-BE-NEXT:    add x9, x0, x8
; CHECK-BE-NEXT:    add x10, x1, #32
; CHECK-BE-NEXT:    add x8, x8, #16
; CHECK-BE-NEXT:    cmp x8, #128
; CHECK-BE-NEXT:    ld1 { v4.16b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #48
; CHECK-BE-NEXT:    tbl v5.16b, { v4.16b }, v3.16b
; CHECK-BE-NEXT:    tbl v6.16b, { v4.16b }, v0.16b
; CHECK-BE-NEXT:    tbl v7.16b, { v4.16b }, v2.16b
; CHECK-BE-NEXT:    tbl v4.16b, { v4.16b }, v1.16b
; CHECK-BE-NEXT:    st1 { v5.16b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #16
; CHECK-BE-NEXT:    st1 { v6.16b }, [x1]
; CHECK-BE-NEXT:    add x1, x1, #64
; CHECK-BE-NEXT:    st1 { v7.16b }, [x10]
; CHECK-BE-NEXT:    st1 { v4.16b }, [x9]
; CHECK-BE-NEXT:    b.ne .LBB0_1
; CHECK-BE-NEXT:  // %bb.2: // %exit
; CHECK-BE-NEXT:    ret
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %src.gep = getelementptr i8, i8* %src, i64 %iv
  %src.gep.cast = bitcast i8* %src.gep to <16 x i8>*
  %load = load <16 x i8>, <16 x i8>* %src.gep.cast
  %ext = zext <16 x i8> %load to <16 x i32>
  %dst.gep = getelementptr i32, i32* %dst, i64 %iv
  %dst.gep.cast = bitcast i32* %dst.gep to <16 x i32>*
  store <16 x i32> %ext, <16 x i32>* %dst.gep.cast
  %iv.next = add nuw i64 %iv, 16
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

define void @zext_v16i8_to_v16i32_in_loop_not_header(i8* %src, i32* %dst, i1 %c) {
; CHECK-LABEL: zext_v16i8_to_v16i32_in_loop_not_header:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:    b LBB1_2
; CHECK-NEXT:  LBB1_1: ; %loop.latch
; CHECK-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    add x1, x1, #64
; CHECK-NEXT:    cmp x8, #128
; CHECK-NEXT:    b.eq LBB1_4
; CHECK-NEXT:  LBB1_2: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    tbz w2, #0, LBB1_1
; CHECK-NEXT:  ; %bb.3: ; %then
; CHECK-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    ldr q0, [x0, x8]
; CHECK-NEXT:    ushll2.8h v1, v0, #0
; CHECK-NEXT:    ushll.8h v0, v0, #0
; CHECK-NEXT:    ushll2.4s v2, v1, #0
; CHECK-NEXT:    ushll.4s v1, v1, #0
; CHECK-NEXT:    ushll2.4s v3, v0, #0
; CHECK-NEXT:    ushll.4s v0, v0, #0
; CHECK-NEXT:    stp q1, q2, [x1, #32]
; CHECK-NEXT:    stp q0, q3, [x1]
; CHECK-NEXT:    b LBB1_1
; CHECK-NEXT:  LBB1_4: ; %exit
; CHECK-NEXT:    ret
;
; CHECK-BE-LABEL: zext_v16i8_to_v16i32_in_loop_not_header:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    mov x8, xzr
; CHECK-BE-NEXT:    b .LBB1_2
; CHECK-BE-NEXT:  .LBB1_1: // %loop.latch
; CHECK-BE-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-BE-NEXT:    add x8, x8, #16
; CHECK-BE-NEXT:    add x1, x1, #64
; CHECK-BE-NEXT:    cmp x8, #128
; CHECK-BE-NEXT:    b.eq .LBB1_4
; CHECK-BE-NEXT:  .LBB1_2: // %loop
; CHECK-BE-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-BE-NEXT:    tbz w2, #0, .LBB1_1
; CHECK-BE-NEXT:  // %bb.3: // %then
; CHECK-BE-NEXT:    // in Loop: Header=BB1_2 Depth=1
; CHECK-BE-NEXT:    add x9, x0, x8
; CHECK-BE-NEXT:    add x10, x1, #32
; CHECK-BE-NEXT:    add x11, x1, #16
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #48
; CHECK-BE-NEXT:    ushll2 v1.8h, v0.16b, #0
; CHECK-BE-NEXT:    ushll v0.8h, v0.8b, #0
; CHECK-BE-NEXT:    ushll2 v2.4s, v1.8h, #0
; CHECK-BE-NEXT:    ushll v1.4s, v1.4h, #0
; CHECK-BE-NEXT:    ushll2 v3.4s, v0.8h, #0
; CHECK-BE-NEXT:    st1 { v2.4s }, [x9]
; CHECK-BE-NEXT:    ushll v0.4s, v0.4h, #0
; CHECK-BE-NEXT:    st1 { v1.4s }, [x10]
; CHECK-BE-NEXT:    st1 { v3.4s }, [x11]
; CHECK-BE-NEXT:    st1 { v0.4s }, [x1]
; CHECK-BE-NEXT:    b .LBB1_1
; CHECK-BE-NEXT:  .LBB1_4: // %exit
; CHECK-BE-NEXT:    ret
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop.latch ]
  br i1 %c, label %then, label %loop.latch

then:
  %src.gep = getelementptr i8, i8* %src, i64 %iv
  %src.gep.cast = bitcast i8* %src.gep to <16 x i8>*
  %load = load <16 x i8>, <16 x i8>* %src.gep.cast
  %ext = zext <16 x i8> %load to <16 x i32>
  %dst.gep = getelementptr i32, i32* %dst, i64 %iv
  %dst.gep.cast = bitcast i32* %dst.gep to <16 x i32>*
  store <16 x i32> %ext, <16 x i32>* %dst.gep.cast
  br label %loop.latch

loop.latch:
  %iv.next = add nuw i64 %iv, 16
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

; Not profitable to use shuffle/tbl, as 4 tbls + materializing the masks
; require more instructions than lowering zext directly.
define void @zext_v16i8_to_v16i32_no_loop(i8* %src, i32* %dst) {
; CHECK-LABEL: zext_v16i8_to_v16i32_no_loop:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    ldr q0, [x0]
; CHECK-NEXT:    ushll2.8h v1, v0, #0
; CHECK-NEXT:    ushll.8h v0, v0, #0
; CHECK-NEXT:    ushll2.4s v2, v1, #0
; CHECK-NEXT:    ushll.4s v1, v1, #0
; CHECK-NEXT:    ushll2.4s v3, v0, #0
; CHECK-NEXT:    ushll.4s v0, v0, #0
; CHECK-NEXT:    stp q1, q2, [x1, #32]
; CHECK-NEXT:    stp q0, q3, [x1]
; CHECK-NEXT:    ret
;
; CHECK-BE-LABEL: zext_v16i8_to_v16i32_no_loop:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x0]
; CHECK-BE-NEXT:    add x8, x1, #48
; CHECK-BE-NEXT:    ushll2 v1.8h, v0.16b, #0
; CHECK-BE-NEXT:    ushll v0.8h, v0.8b, #0
; CHECK-BE-NEXT:    ushll2 v2.4s, v1.8h, #0
; CHECK-BE-NEXT:    ushll v1.4s, v1.4h, #0
; CHECK-BE-NEXT:    st1 { v2.4s }, [x8]
; CHECK-BE-NEXT:    add x8, x1, #32
; CHECK-BE-NEXT:    st1 { v1.4s }, [x8]
; CHECK-BE-NEXT:    add x8, x1, #16
; CHECK-BE-NEXT:    ushll2 v1.4s, v0.8h, #0
; CHECK-BE-NEXT:    ushll v0.4s, v0.4h, #0
; CHECK-BE-NEXT:    st1 { v1.4s }, [x8]
; CHECK-BE-NEXT:    st1 { v0.4s }, [x1]
; CHECK-BE-NEXT:    ret
entry:
  %src.cast = bitcast i8* %src to <16 x i8>*
  %load = load <16 x i8>, <16 x i8>* %src.cast
  %ext = zext <16 x i8> %load to <16 x i32>
  %dst.cast = bitcast i32* %dst to <16 x i32>*
  store <16 x i32> %ext, <16 x i32>* %dst.cast
  ret void
}

; Avoid using tbl when optimizing for size.
define void @zext_v16i8_to_v16i32_in_loop_optsize(i8* %src, i32* %dst) optsize {
; CHECK-LABEL: zext_v16i8_to_v16i32_in_loop_optsize:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:  LBB3_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr q0, [x0, x8]
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    cmp x8, #128
; CHECK-NEXT:    ushll2.8h v1, v0, #0
; CHECK-NEXT:    ushll.8h v0, v0, #0
; CHECK-NEXT:    ushll2.4s v2, v1, #0
; CHECK-NEXT:    ushll.4s v1, v1, #0
; CHECK-NEXT:    ushll2.4s v3, v0, #0
; CHECK-NEXT:    ushll.4s v0, v0, #0
; CHECK-NEXT:    stp q1, q2, [x1, #32]
; CHECK-NEXT:    stp q0, q3, [x1], #64
; CHECK-NEXT:    b.ne LBB3_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    ret
;
; CHECK-BE-LABEL: zext_v16i8_to_v16i32_in_loop_optsize:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    mov x8, xzr
; CHECK-BE-NEXT:  .LBB3_1: // %loop
; CHECK-BE-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-BE-NEXT:    add x9, x0, x8
; CHECK-BE-NEXT:    add x10, x1, #32
; CHECK-BE-NEXT:    add x8, x8, #16
; CHECK-BE-NEXT:    cmp x8, #128
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #48
; CHECK-BE-NEXT:    ushll2 v1.8h, v0.16b, #0
; CHECK-BE-NEXT:    ushll v0.8h, v0.8b, #0
; CHECK-BE-NEXT:    ushll2 v2.4s, v1.8h, #0
; CHECK-BE-NEXT:    ushll v1.4s, v1.4h, #0
; CHECK-BE-NEXT:    st1 { v2.4s }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #16
; CHECK-BE-NEXT:    ushll v2.4s, v0.4h, #0
; CHECK-BE-NEXT:    st1 { v1.4s }, [x10]
; CHECK-BE-NEXT:    ushll2 v0.4s, v0.8h, #0
; CHECK-BE-NEXT:    st1 { v2.4s }, [x1]
; CHECK-BE-NEXT:    add x1, x1, #64
; CHECK-BE-NEXT:    st1 { v0.4s }, [x9]
; CHECK-BE-NEXT:    b.ne .LBB3_1
; CHECK-BE-NEXT:  // %bb.2: // %exit
; CHECK-BE-NEXT:    ret
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %src.gep = getelementptr i8, i8* %src, i64 %iv
  %src.gep.cast = bitcast i8* %src.gep to <16 x i8>*
  %load = load <16 x i8>, <16 x i8>* %src.gep.cast
  %ext = zext <16 x i8> %load to <16 x i32>
  %dst.gep = getelementptr i32, i32* %dst, i64 %iv
  %dst.gep.cast = bitcast i32* %dst.gep to <16 x i32>*
  store <16 x i32> %ext, <16 x i32>* %dst.gep.cast
  %iv.next = add nuw i64 %iv, 16
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

; Avoid using tbl when optimizing for size.
define void @zext_v16i8_to_v16i32_in_loop_minsize(i8* %src, i32* %dst) minsize {
; CHECK-LABEL: zext_v16i8_to_v16i32_in_loop_minsize:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:  LBB4_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr q0, [x0, x8]
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    cmp x8, #128
; CHECK-NEXT:    ushll2.8h v1, v0, #0
; CHECK-NEXT:    ushll.8h v0, v0, #0
; CHECK-NEXT:    ushll2.4s v2, v1, #0
; CHECK-NEXT:    ushll.4s v1, v1, #0
; CHECK-NEXT:    ushll2.4s v3, v0, #0
; CHECK-NEXT:    ushll.4s v0, v0, #0
; CHECK-NEXT:    stp q1, q2, [x1, #32]
; CHECK-NEXT:    stp q0, q3, [x1], #64
; CHECK-NEXT:    b.ne LBB4_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    ret
;
; CHECK-BE-LABEL: zext_v16i8_to_v16i32_in_loop_minsize:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    mov x8, xzr
; CHECK-BE-NEXT:  .LBB4_1: // %loop
; CHECK-BE-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-BE-NEXT:    add x9, x0, x8
; CHECK-BE-NEXT:    add x10, x1, #32
; CHECK-BE-NEXT:    add x8, x8, #16
; CHECK-BE-NEXT:    cmp x8, #128
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #48
; CHECK-BE-NEXT:    ushll2 v1.8h, v0.16b, #0
; CHECK-BE-NEXT:    ushll v0.8h, v0.8b, #0
; CHECK-BE-NEXT:    ushll2 v2.4s, v1.8h, #0
; CHECK-BE-NEXT:    ushll v1.4s, v1.4h, #0
; CHECK-BE-NEXT:    st1 { v2.4s }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #16
; CHECK-BE-NEXT:    ushll v2.4s, v0.4h, #0
; CHECK-BE-NEXT:    st1 { v1.4s }, [x10]
; CHECK-BE-NEXT:    ushll2 v0.4s, v0.8h, #0
; CHECK-BE-NEXT:    st1 { v2.4s }, [x1]
; CHECK-BE-NEXT:    add x1, x1, #64
; CHECK-BE-NEXT:    st1 { v0.4s }, [x9]
; CHECK-BE-NEXT:    b.ne .LBB4_1
; CHECK-BE-NEXT:  // %bb.2: // %exit
; CHECK-BE-NEXT:    ret
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %src.gep = getelementptr i8, i8* %src, i64 %iv
  %src.gep.cast = bitcast i8* %src.gep to <16 x i8>*
  %load = load <16 x i8>, <16 x i8>* %src.gep.cast
  %ext = zext <16 x i8> %load to <16 x i32>
  %dst.gep = getelementptr i32, i32* %dst, i64 %iv
  %dst.gep.cast = bitcast i32* %dst.gep to <16 x i32>*
  store <16 x i32> %ext, <16 x i32>* %dst.gep.cast
  %iv.next = add nuw i64 %iv, 16
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}



define void @zext_v16i8_to_v16i16_in_loop(i8* %src, i16* %dst) {
; CHECK-LABEL: zext_v16i8_to_v16i16_in_loop:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:  LBB5_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr q0, [x0, x8]
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    cmp x8, #128
; CHECK-NEXT:    ushll2.8h v1, v0, #0
; CHECK-NEXT:    ushll.8h v0, v0, #0
; CHECK-NEXT:    stp q0, q1, [x1], #32
; CHECK-NEXT:    b.ne LBB5_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    ret
;
; CHECK-BE-LABEL: zext_v16i8_to_v16i16_in_loop:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    mov x8, xzr
; CHECK-BE-NEXT:  .LBB5_1: // %loop
; CHECK-BE-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-BE-NEXT:    add x9, x0, x8
; CHECK-BE-NEXT:    add x8, x8, #16
; CHECK-BE-NEXT:    cmp x8, #128
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #16
; CHECK-BE-NEXT:    ushll v1.8h, v0.8b, #0
; CHECK-BE-NEXT:    ushll2 v0.8h, v0.16b, #0
; CHECK-BE-NEXT:    st1 { v1.8h }, [x1]
; CHECK-BE-NEXT:    add x1, x1, #32
; CHECK-BE-NEXT:    st1 { v0.8h }, [x9]
; CHECK-BE-NEXT:    b.ne .LBB5_1
; CHECK-BE-NEXT:  // %bb.2: // %exit
; CHECK-BE-NEXT:    ret
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %src.gep = getelementptr i8, i8* %src, i64 %iv
  %src.gep.cast = bitcast i8* %src.gep to <16 x i8>*
  %load = load <16 x i8>, <16 x i8>* %src.gep.cast
  %ext = zext <16 x i8> %load to <16 x i16>
  %dst.gep = getelementptr i16, i16* %dst, i64 %iv
  %dst.gep.cast = bitcast i16* %dst.gep to <16 x i16>*
  store <16 x i16> %ext, <16 x i16>* %dst.gep.cast
  %iv.next = add nuw i64 %iv, 16
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

; CHECK-LABEL: lCPI6_0:
; CHECK-NEXT:     .byte   0                               ; 0x0
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   1                               ; 0x1
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   2                               ; 0x2
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   3                               ; 0x3
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT: lCPI6_1:
; CHECK-NEXT:     .byte   4                               ; 0x4
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   5                               ; 0x5
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   6                               ; 0x6
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   7                               ; 0x7
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff
; CHECK-NEXT:     .byte   255                             ; 0xff

; CHECK-BE:       .LCPI6_0:
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	0                               // 0x0
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	1                               // 0x1
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	2                               // 0x2
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	3                               // 0x3
; CHECK-BE-NEXT: .LCPI6_1:
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	4                               // 0x4
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	5                               // 0x5
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	6                               // 0x6
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	255                             // 0xff
; CHECK-BE-NEXT: 	.byte	7                               // 0x7

define void @zext_v8i8_to_v8i32_in_loop(i8* %src, i32* %dst) {
; CHECK-LABEL: zext_v8i8_to_v8i32_in_loop:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:  Lloh8:
; CHECK-NEXT:    adrp x9, lCPI6_0@PAGE
; CHECK-NEXT:  Lloh9:
; CHECK-NEXT:    adrp x10, lCPI6_1@PAGE
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:  Lloh10:
; CHECK-NEXT:    ldr q0, [x9, lCPI6_0@PAGEOFF]
; CHECK-NEXT:  Lloh11:
; CHECK-NEXT:    ldr q1, [x10, lCPI6_1@PAGEOFF]
; CHECK-NEXT:  LBB6_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr d2, [x0, x8]
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    cmp x8, #128
; CHECK-NEXT:    tbl.16b v3, { v2 }, v1
; CHECK-NEXT:    tbl.16b v2, { v2 }, v0
; CHECK-NEXT:    stp q2, q3, [x1], #64
; CHECK-NEXT:    b.ne LBB6_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdr Lloh9, Lloh11
; CHECK-NEXT:    .loh AdrpLdr Lloh8, Lloh10
;
; CHECK-BE-LABEL: zext_v8i8_to_v8i32_in_loop:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    adrp x8, .LCPI6_0
; CHECK-BE-NEXT:    add x8, x8, :lo12:.LCPI6_0
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x8]
; CHECK-BE-NEXT:    adrp x8, .LCPI6_1
; CHECK-BE-NEXT:    add x8, x8, :lo12:.LCPI6_1
; CHECK-BE-NEXT:    ld1 { v1.16b }, [x8]
; CHECK-BE-NEXT:    mov x8, xzr
; CHECK-BE-NEXT:  .LBB6_1: // %loop
; CHECK-BE-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-BE-NEXT:    add x9, x0, x8
; CHECK-BE-NEXT:    add x8, x8, #16
; CHECK-BE-NEXT:    cmp x8, #128
; CHECK-BE-NEXT:    ld1 { v2.8b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #16
; CHECK-BE-NEXT:    tbl v3.16b, { v2.16b }, v0.16b
; CHECK-BE-NEXT:    tbl v2.16b, { v2.16b }, v1.16b
; CHECK-BE-NEXT:    st1 { v3.16b }, [x1]
; CHECK-BE-NEXT:    add x1, x1, #64
; CHECK-BE-NEXT:    st1 { v2.16b }, [x9]
; CHECK-BE-NEXT:    b.ne .LBB6_1
; CHECK-BE-NEXT:  // %bb.2: // %exit
; CHECK-BE-NEXT:    ret
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %src.gep = getelementptr i8, i8* %src, i64 %iv
  %src.gep.cast = bitcast i8* %src.gep to <8 x i8>*
  %load = load <8 x i8>, <8 x i8>* %src.gep.cast
  %ext = zext <8 x i8> %load to <8 x i32>
  %dst.gep = getelementptr i32, i32* %dst, i64 %iv
  %dst.gep.cast = bitcast i32* %dst.gep to <8 x i32>*
  store <8 x i32> %ext, <8 x i32>* %dst.gep.cast
  %iv.next = add nuw i64 %iv, 16
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}

define void @zext_v16i8_to_v16i64_in_loop(i8* %src, i64* %dst) {
; CHECK-LABEL: zext_v16i8_to_v16i64_in_loop:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    mov x8, xzr
; CHECK-NEXT:  LBB7_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr q0, [x0, x8]
; CHECK-NEXT:    add x8, x8, #16
; CHECK-NEXT:    cmp x8, #128
; CHECK-NEXT:    ushll.8h v1, v0, #0
; CHECK-NEXT:    ushll2.8h v0, v0, #0
; CHECK-NEXT:    ushll2.4s v2, v1, #0
; CHECK-NEXT:    ushll2.4s v3, v0, #0
; CHECK-NEXT:    ushll.4s v0, v0, #0
; CHECK-NEXT:    ushll2.2d v4, v3, #0
; CHECK-NEXT:    ushll2.2d v5, v0, #0
; CHECK-NEXT:    ushll.2d v0, v0, #0
; CHECK-NEXT:    ushll.2d v3, v3, #0
; CHECK-NEXT:    stp q0, q5, [x1, #64]
; CHECK-NEXT:    ushll.4s v0, v1, #0
; CHECK-NEXT:    stp q3, q4, [x1, #96]
; CHECK-NEXT:    ushll2.2d v3, v2, #0
; CHECK-NEXT:    ushll.2d v2, v2, #0
; CHECK-NEXT:    ushll2.2d v1, v0, #0
; CHECK-NEXT:    ushll.2d v0, v0, #0
; CHECK-NEXT:    stp q2, q3, [x1, #32]
; CHECK-NEXT:    stp q0, q1, [x1], #128
; CHECK-NEXT:    b.ne LBB7_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    ret
;
; CHECK-BE-LABEL: zext_v16i8_to_v16i64_in_loop:
; CHECK-BE:       // %bb.0: // %entry
; CHECK-BE-NEXT:    mov x8, xzr
; CHECK-BE-NEXT:  .LBB7_1: // %loop
; CHECK-BE-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-BE-NEXT:    add x9, x0, x8
; CHECK-BE-NEXT:    add x10, x1, #96
; CHECK-BE-NEXT:    add x8, x8, #16
; CHECK-BE-NEXT:    cmp x8, #128
; CHECK-BE-NEXT:    ld1 { v0.16b }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #112
; CHECK-BE-NEXT:    ushll2 v1.8h, v0.16b, #0
; CHECK-BE-NEXT:    ushll v0.8h, v0.8b, #0
; CHECK-BE-NEXT:    ushll2 v2.4s, v1.8h, #0
; CHECK-BE-NEXT:    ushll v1.4s, v1.4h, #0
; CHECK-BE-NEXT:    ushll2 v3.2d, v2.4s, #0
; CHECK-BE-NEXT:    ushll v2.2d, v2.2s, #0
; CHECK-BE-NEXT:    st1 { v3.2d }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #80
; CHECK-BE-NEXT:    ushll2 v3.2d, v1.4s, #0
; CHECK-BE-NEXT:    st1 { v2.2d }, [x10]
; CHECK-BE-NEXT:    ushll2 v2.4s, v0.8h, #0
; CHECK-BE-NEXT:    add x10, x1, #48
; CHECK-BE-NEXT:    st1 { v3.2d }, [x9]
; CHECK-BE-NEXT:    add x9, x1, #64
; CHECK-BE-NEXT:    ushll v1.2d, v1.2s, #0
; CHECK-BE-NEXT:    ushll v0.4s, v0.4h, #0
; CHECK-BE-NEXT:    ushll2 v4.2d, v2.4s, #0
; CHECK-BE-NEXT:    st1 { v1.2d }, [x9]
; CHECK-BE-NEXT:    ushll v1.2d, v0.2s, #0
; CHECK-BE-NEXT:    add x9, x1, #16
; CHECK-BE-NEXT:    st1 { v4.2d }, [x10]
; CHECK-BE-NEXT:    add x10, x1, #32
; CHECK-BE-NEXT:    st1 { v1.2d }, [x1]
; CHECK-BE-NEXT:    add x1, x1, #128
; CHECK-BE-NEXT:    ushll2 v0.2d, v0.4s, #0
; CHECK-BE-NEXT:    ushll v2.2d, v2.2s, #0
; CHECK-BE-NEXT:    st1 { v0.2d }, [x9]
; CHECK-BE-NEXT:    st1 { v2.2d }, [x10]
; CHECK-BE-NEXT:    b.ne .LBB7_1
; CHECK-BE-NEXT:  // %bb.2: // %exit
; CHECK-BE-NEXT:    ret
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %src.gep = getelementptr i8, i8* %src, i64 %iv
  %src.gep.cast = bitcast i8* %src.gep to <16 x i8>*
  %load = load <16 x i8>, <16 x i8>* %src.gep.cast
  %ext = zext <16 x i8> %load to <16 x i64>
  %dst.gep = getelementptr i64, i64* %dst, i64 %iv
  %dst.gep.cast = bitcast i64* %dst.gep to <16 x i64>*
  store <16 x i64> %ext, <16 x i64>* %dst.gep.cast
  %iv.next = add nuw i64 %iv, 16
  %ec = icmp eq i64 %iv.next, 128
  br i1 %ec, label %exit, label %loop

exit:
  ret void
}
