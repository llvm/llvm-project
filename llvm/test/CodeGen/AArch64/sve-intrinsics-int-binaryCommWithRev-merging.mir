# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=aarch64 -mattr=+sve -mattr=+use-experimental-zeroing-pseudos -run-pass=aarch64-expand-pseudo %s -o - | FileCheck %s

# Should create an additional LSL to zero the lanes as the DstReg is not unique

--- |
  define <vscale x 4 x float> @fsub_s_zero(<vscale x 4 x i1> %pg, <vscale x 4 x float> %a){
    %a_z = select <vscale x 4 x i1> %pg, <vscale x 4 x float> %a, <vscale x 4 x float> zeroinitializer
    %out = call <vscale x 4 x float> @llvm.aarch64.sve.fsub.nxv4f32(<vscale x 4 x i1> %pg,
                                                                 <vscale x 4 x float> %a_z,
                                                                 <vscale x 4 x float> %a_z)
    ret <vscale x 4 x float> %out
  }

  declare <vscale x 4 x float> @llvm.aarch64.sve.fsub.nxv4f32(<vscale x 4 x i1>, <vscale x 4 x float>, <vscale x 4 x float>)
...
---
name:            fsub_s_zero
alignment:       4
tracksRegLiveness: true
tracksDebugUserValues: true
registers:       []
liveins:
  - { reg: '$p0', virtual-reg: '' }
  - { reg: '$z0', virtual-reg: '' }
body:             |
  bb.0 (%ir-block.0):
    liveins: $p0, $z0

    ; CHECK-LABEL: name: fsub_s_zero
    ; CHECK: liveins: $p0, $z0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: BUNDLE implicit-def $z0, implicit-def $q0, implicit-def $d0, implicit-def $s0, implicit-def $h0, implicit-def $b0, implicit-def $z0_hi, implicit $p0, implicit $z0 {
    ; CHECK-NEXT:   $z0 = MOVPRFX_ZPzZ_S $p0, $z0
    ; CHECK-NEXT:   $z0 = LSL_ZPmI_S renamable $p0, internal $z0, 0
    ; CHECK-NEXT:   $z0 = FSUBR_ZPmZ_S renamable $p0, internal killed $z0, internal killed renamable $z0
    ; CHECK-NEXT: }
    ; CHECK-NEXT: RET undef $lr, implicit $z0
    renamable $z0 = nnan ninf nsz arcp contract afn reassoc FSUB_ZPZZ_ZERO_S renamable $p0, killed renamable $z0, renamable $z0
    RET_ReallyLR implicit $z0
...
