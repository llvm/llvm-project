; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=thumbv7-apple-ios -disable-block-placement < %s | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-T
; RUN: llc -mtriple=armv7-apple-ios   -disable-block-placement < %s | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-A

; LSR should compare against the post-incremented induction variable.
; In this case, the immediate value is -2 which requires a cmn instruction.
;
define i32 @f(ptr nocapture %a, i32 %i) nounwind readonly ssp {
; CHECK-T-LABEL: f:
; CHECK-T:       @ %bb.0: @ %entry
; CHECK-T-NEXT:    cmn.w r1, #2
; CHECK-T-NEXT:    itt eq
; CHECK-T-NEXT:    moveq r0, #0
; CHECK-T-NEXT:    bxeq lr
; CHECK-T-NEXT:  LBB0_1: @ %for.body.preheader
; CHECK-T-NEXT:    mov r9, r0
; CHECK-T-NEXT:    movs r0, #0
; CHECK-T-NEXT:    movs r3, #0
; CHECK-T-NEXT:  LBB0_2: @ %for.body
; CHECK-T-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-T-NEXT:    ldr.w r2, [r9, r1, lsl #2]
; CHECK-T-NEXT:    cmp r2, r3
; CHECK-T-NEXT:    itt gt
; CHECK-T-NEXT:    movgt r3, r2
; CHECK-T-NEXT:    movgt r0, r1
; CHECK-T-NEXT:    subs r1, #2
; CHECK-T-NEXT:    cmn.w r1, #2
; CHECK-T-NEXT:    bne LBB0_2
; CHECK-T-NEXT:  @ %bb.3: @ %for.end
; CHECK-T-NEXT:    bx lr
;
; CHECK-A-LABEL: f:
; CHECK-A:       @ %bb.0: @ %entry
; CHECK-A-NEXT:    mov r2, #0
; CHECK-A-NEXT:    cmn r1, #2
; CHECK-A-NEXT:    beq LBB0_3
; CHECK-A-NEXT:  @ %bb.1: @ %for.body.preheader
; CHECK-A-NEXT:    mov r3, #0
; CHECK-A-NEXT:  LBB0_2: @ %for.body
; CHECK-A-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-A-NEXT:    ldr r9, [r0, r1, lsl #2]
; CHECK-A-NEXT:    cmp r9, r3
; CHECK-A-NEXT:    movgt r2, r1
; CHECK-A-NEXT:    sub r1, r1, #2
; CHECK-A-NEXT:    movgt r3, r9
; CHECK-A-NEXT:    cmn r1, #2
; CHECK-A-NEXT:    bne LBB0_2
; CHECK-A-NEXT:  LBB0_3: @ %for.end
; CHECK-A-NEXT:    mov r0, r2
; CHECK-A-NEXT:    bx lr
entry:
  %cmp3 = icmp eq i32 %i, -2
  br i1 %cmp3, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %bi.06 = phi i32 [ %i.addr.0.bi.0, %for.body ], [ 0, %entry ]
  %i.addr.05 = phi i32 [ %sub, %for.body ], [ %i, %entry ]
  %b.04 = phi i32 [ %.b.0, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i32, ptr %a, i32 %i.addr.05
  %0 = load i32, ptr %arrayidx, align 4
  %cmp1 = icmp sgt i32 %0, %b.04
  %.b.0 = select i1 %cmp1, i32 %0, i32 %b.04
  %i.addr.0.bi.0 = select i1 %cmp1, i32 %i.addr.05, i32 %bi.06
  %sub = add nsw i32 %i.addr.05, -2
  %cmp = icmp eq i32 %i.addr.05, 0
  br i1 %cmp, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  %bi.0.lcssa = phi i32 [ 0, %entry ], [ %i.addr.0.bi.0, %for.body ]
  ret i32 %bi.0.lcssa
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
