; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=thumbv7m-linux-gnu < %s | FileCheck %s --check-prefix=CHECK --check-prefix=T2
; RUN: llc -mtriple=thumbv6m-linux-gnu < %s | FileCheck %s --check-prefix=CHECK --check-prefix=T1

; CHECK-LABEL: single_bit:
; CHECK: lsls r0, r0, #23
; T2-NEXT: mov
; T2-NEXT: it
; T1-NEXT: bmi
define i32 @single_bit(i32 %p) {
; T2-LABEL: single_bit:
; T2:       @ %bb.0: @ %common.ret
; T2-NEXT:    lsls r0, r0, #23
; T2-NEXT:    mov.w r0, #2
; T2-NEXT:    it pl
; T2-NEXT:    movpl r0, #1
; T2-NEXT:    bx lr
;
; T1-LABEL: single_bit:
; T1:       @ %bb.0:
; T1-NEXT:    lsls r0, r0, #23
; T1-NEXT:    bmi .LBB0_2
; T1-NEXT:  @ %bb.1: @ %true
; T1-NEXT:    movs r0, #1
; T1-NEXT:    bx lr
; T1-NEXT:  .LBB0_2: @ %false
; T1-NEXT:    movs r0, #2
; T1-NEXT:    bx lr
  %a = and i32 %p, 256
  %b = icmp eq i32 %a, 0
  br i1 %b, label %true, label %false

true:
  ret i32 1

false:
  ret i32 2
}

; CHECK-LABEL: single_bit_multi_use:
; CHECK: lsls r0, r0, #23
; T2-NEXT: mov
; T2-NEXT: it
; T1-NEXT: bmi
define i32 @single_bit_multi_use(i32 %p, ptr %z) {
; T2-LABEL: single_bit_multi_use:
; T2:       @ %bb.0: @ %common.ret
; T2-NEXT:    str r0, [r1]
; T2-NEXT:    lsls r0, r0, #23
; T2-NEXT:    mov.w r0, #2
; T2-NEXT:    it pl
; T2-NEXT:    movpl r0, #1
; T2-NEXT:    bx lr
;
; T1-LABEL: single_bit_multi_use:
; T1:       @ %bb.0:
; T1-NEXT:    str r0, [r1]
; T1-NEXT:    lsls r0, r0, #23
; T1-NEXT:    bmi .LBB1_2
; T1-NEXT:  @ %bb.1: @ %true
; T1-NEXT:    movs r0, #1
; T1-NEXT:    bx lr
; T1-NEXT:  .LBB1_2: @ %false
; T1-NEXT:    movs r0, #2
; T1-NEXT:    bx lr
  store i32 %p, ptr %z
  %a = and i32 %p, 256
  %b = icmp eq i32 %a, 0
  br i1 %b, label %true, label %false

true:
  ret i32 1

false:
  ret i32 2
}

; CHECK-LABEL: multi_bit_lsb_ubfx:
; CHECK: lsls r0, r0, #24
; T2-NEXT: mov
; T2-NEXT: it
; T1-NEXT: beq
define i32 @multi_bit_lsb_ubfx(i32 %p) {
; T2-LABEL: multi_bit_lsb_ubfx:
; T2:       @ %bb.0: @ %common.ret
; T2-NEXT:    lsls r0, r0, #24
; T2-NEXT:    mov.w r0, #2
; T2-NEXT:    it eq
; T2-NEXT:    moveq r0, #1
; T2-NEXT:    bx lr
;
; T1-LABEL: multi_bit_lsb_ubfx:
; T1:       @ %bb.0:
; T1-NEXT:    lsls r0, r0, #24
; T1-NEXT:    beq .LBB2_2
; T1-NEXT:  @ %bb.1: @ %false
; T1-NEXT:    movs r0, #2
; T1-NEXT:    bx lr
; T1-NEXT:  .LBB2_2: @ %true
; T1-NEXT:    movs r0, #1
; T1-NEXT:    bx lr
  %a = and i32 %p, 255
  %b = icmp eq i32 %a, 0
  br i1 %b, label %true, label %false

true:
  ret i32 1

false:
  ret i32 2
}

; CHECK-LABEL: multi_bit_msb:
; CHECK: lsrs r0, r0, #24
; T2-NEXT: mov
; T2-NEXT: it
; T1-NEXT: beq
define i32 @multi_bit_msb(i32 %p) {
; T2-LABEL: multi_bit_msb:
; T2:       @ %bb.0: @ %common.ret
; T2-NEXT:    lsrs r0, r0, #24
; T2-NEXT:    mov.w r0, #2
; T2-NEXT:    it eq
; T2-NEXT:    moveq r0, #1
; T2-NEXT:    bx lr
;
; T1-LABEL: multi_bit_msb:
; T1:       @ %bb.0:
; T1-NEXT:    lsrs r0, r0, #24
; T1-NEXT:    beq .LBB3_2
; T1-NEXT:  @ %bb.1: @ %false
; T1-NEXT:    movs r0, #2
; T1-NEXT:    bx lr
; T1-NEXT:  .LBB3_2: @ %true
; T1-NEXT:    movs r0, #1
; T1-NEXT:    bx lr
  %a = and i32 %p, 4278190080  ; 0xff000000
  %b = icmp eq i32 %a, 0
  br i1 %b, label %true, label %false

true:
  ret i32 1

false:
  ret i32 2
}

; CHECK-LABEL: multi_bit_nosb:
; T1: lsls r0, r0, #8
; T1-NEXT: lsrs r0, r0, #24
; T2: tst.w
; T2-NEXT: it
; T1-NEXT: beq
define i32 @multi_bit_nosb(i32 %p) {
; T2-LABEL: multi_bit_nosb:
; T2:       @ %bb.0: @ %common.ret
; T2-NEXT:    movs r1, #2
; T2-NEXT:    tst.w r0, #16711680
; T2-NEXT:    it eq
; T2-NEXT:    moveq r1, #1
; T2-NEXT:    mov r0, r1
; T2-NEXT:    bx lr
;
; T1-LABEL: multi_bit_nosb:
; T1:       @ %bb.0:
; T1-NEXT:    lsls r0, r0, #8
; T1-NEXT:    lsrs r0, r0, #24
; T1-NEXT:    beq .LBB4_2
; T1-NEXT:  @ %bb.1: @ %false
; T1-NEXT:    movs r0, #2
; T1-NEXT:    bx lr
; T1-NEXT:  .LBB4_2: @ %true
; T1-NEXT:    movs r0, #1
; T1-NEXT:    bx lr
  %a = and i32 %p, 16711680 ; 0x00ff0000
  %b = icmp eq i32 %a, 0
  br i1 %b, label %true, label %false

true:
  ret i32 1

false:
  ret i32 2
}

; CHECK-LABEL: i16_cmpz:
; T1:      uxth    r0, r0
; T1-NEXT: lsrs    r0, r0, #9
; T1-NEXT: bne
; T2:      uxth    r0, r0
; T2-NEXT: movs    r2, #0
; T2-NEXT: cmp.w   r2, r0, lsr #9
define void @i16_cmpz(i16 %x, ptr %foo) {
; T2-LABEL: i16_cmpz:
; T2:       @ %bb.0: @ %entry
; T2-NEXT:    and r0, r0, #65024
; T2-NEXT:    movs r2, #0
; T2-NEXT:    cmp.w r2, r0, lsr #9
; T2-NEXT:    it ne
; T2-NEXT:    bxne lr
; T2-NEXT:  .LBB5_1: @ %if.then
; T2-NEXT:    movs r0, #0
; T2-NEXT:    bx r1
;
; T1-LABEL: i16_cmpz:
; T1:       @ %bb.0: @ %entry
; T1-NEXT:    push {r7, lr}
; T1-NEXT:    movs r2, #127
; T1-NEXT:    lsls r2, r2, #9
; T1-NEXT:    ands r2, r0
; T1-NEXT:    lsrs r0, r2, #9
; T1-NEXT:    bne .LBB5_2
; T1-NEXT:  @ %bb.1: @ %if.then
; T1-NEXT:    movs r0, #0
; T1-NEXT:    blx r1
; T1-NEXT:  .LBB5_2: @ %if.end
; T1-NEXT:    pop {r7, pc}
entry:
  %cmp = icmp ult i16 %x, 512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void %foo(i32 0) #1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
