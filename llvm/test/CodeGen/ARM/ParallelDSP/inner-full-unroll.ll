; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -mtriple=thumbv7em -arm-parallel-dsp -dce -S %s -o - | FileCheck %s

define void @full_unroll(ptr noalias nocapture %a, ptr noalias nocapture readonly %b, ptr noalias nocapture readonly %c, i32 %N) {
; CHECK-LABEL: @full_unroll(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP29:%.*]] = icmp eq i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP29]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_030:%.*]] = phi i32 [ [[INC12:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i32 [[I_030]]
; CHECK-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds ptr, ptr [[B:%.*]], i32 [[I_030]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARRAYIDX5]], align 4
; CHECK-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds ptr, ptr [[C:%.*]], i32 [[I_030]]
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARRAYIDX7]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[TMP0]], align 2
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP1]], align 2
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @llvm.arm.smlad(i32 [[TMP5]], i32 [[TMP3]], i32 0)
; CHECK-NEXT:    [[ARRAYIDX6_2:%.*]] = getelementptr inbounds i16, ptr [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[ARRAYIDX6_2]], align 2
; CHECK-NEXT:    [[ARRAYIDX8_2:%.*]] = getelementptr inbounds i16, ptr [[TMP1]], i32 2
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[ARRAYIDX8_2]], align 2
; CHECK-NEXT:    [[TMP11:%.*]] = call i32 @llvm.arm.smlad(i32 [[TMP10]], i32 [[TMP8]], i32 [[TMP6]])
; CHECK-NEXT:    store i32 [[TMP11]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC12]] = add nuw i32 [[I_030]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC12]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]]
;
entry:
  %cmp29 = icmp eq i32 %N, 0
  br i1 %cmp29, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.030 = phi i32 [ %inc12, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i32, ptr %a, i32 %i.030
  %arrayidx5 = getelementptr inbounds ptr, ptr %b, i32 %i.030
  %0 = load ptr, ptr %arrayidx5, align 4
  %arrayidx7 = getelementptr inbounds ptr, ptr %c, i32 %i.030
  %1 = load ptr, ptr %arrayidx7, align 4
  %2 = load i16, ptr %0, align 2
  %conv = sext i16 %2 to i32
  %3 = load i16, ptr %1, align 2
  %conv9 = sext i16 %3 to i32
  %mul = mul nsw i32 %conv9, %conv
  %arrayidx6.1 = getelementptr inbounds i16, ptr %0, i32 1
  %4 = load i16, ptr %arrayidx6.1, align 2
  %conv.1 = sext i16 %4 to i32
  %arrayidx8.1 = getelementptr inbounds i16, ptr %1, i32 1
  %5 = load i16, ptr %arrayidx8.1, align 2
  %conv9.1 = sext i16 %5 to i32
  %mul.1 = mul nsw i32 %conv9.1, %conv.1
  %add.1 = add nsw i32 %mul.1, %mul
  %arrayidx6.2 = getelementptr inbounds i16, ptr %0, i32 2
  %6 = load i16, ptr %arrayidx6.2, align 2
  %conv.2 = sext i16 %6 to i32
  %arrayidx8.2 = getelementptr inbounds i16, ptr %1, i32 2
  %7 = load i16, ptr %arrayidx8.2, align 2
  %conv9.2 = sext i16 %7 to i32
  %mul.2 = mul nsw i32 %conv9.2, %conv.2
  %add.2 = add nsw i32 %mul.2, %add.1
  %arrayidx6.3 = getelementptr inbounds i16, ptr %0, i32 3
  %8 = load i16, ptr %arrayidx6.3, align 2
  %conv.3 = sext i16 %8 to i32
  %arrayidx8.3 = getelementptr inbounds i16, ptr %1, i32 3
  %9 = load i16, ptr %arrayidx8.3, align 2
  %conv9.3 = sext i16 %9 to i32
  %mul.3 = mul nsw i32 %conv9.3, %conv.3
  %add.3 = add nsw i32 %mul.3, %add.2
  store i32 %add.3, ptr %arrayidx, align 4
  %inc12 = add nuw i32 %i.030, 1
  %exitcond = icmp eq i32 %inc12, %N
  br i1 %exitcond, label %for.cond.cleanup, label %for.body
}

define void @full_unroll_sub(ptr noalias nocapture %a, ptr noalias nocapture readonly %b, ptr noalias nocapture readonly %c, i32 %N) {
; CHECK-LABEL: @full_unroll_sub(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP29:%.*]] = icmp eq i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP29]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_030:%.*]] = phi i32 [ [[INC12:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i32 [[I_030]]
; CHECK-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds ptr, ptr [[B:%.*]], i32 [[I_030]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARRAYIDX5]], align 4
; CHECK-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds ptr, ptr [[C:%.*]], i32 [[I_030]]
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARRAYIDX7]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i16, ptr [[TMP0]], align 2
; CHECK-NEXT:    [[CONV:%.*]] = sext i16 [[TMP2]] to i32
; CHECK-NEXT:    [[TMP3:%.*]] = load i16, ptr [[TMP1]], align 2
; CHECK-NEXT:    [[CONV9:%.*]] = sext i16 [[TMP3]] to i32
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[CONV9]], [[CONV]]
; CHECK-NEXT:    [[ARRAYIDX6_1:%.*]] = getelementptr inbounds i16, ptr [[TMP0]], i32 1
; CHECK-NEXT:    [[TMP4:%.*]] = load i16, ptr [[ARRAYIDX6_1]], align 2
; CHECK-NEXT:    [[CONV_1:%.*]] = sext i16 [[TMP4]] to i32
; CHECK-NEXT:    [[ARRAYIDX8_1:%.*]] = getelementptr inbounds i16, ptr [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = load i16, ptr [[ARRAYIDX8_1]], align 2
; CHECK-NEXT:    [[CONV9_1:%.*]] = sext i16 [[TMP5]] to i32
; CHECK-NEXT:    [[MUL_1:%.*]] = mul nsw i32 [[CONV9_1]], [[CONV_1]]
; CHECK-NEXT:    [[ADD_1:%.*]] = add nsw i32 [[MUL_1]], [[SUB]]
; CHECK-NEXT:    [[ARRAYIDX6_2:%.*]] = getelementptr inbounds i16, ptr [[TMP0]], i32 2
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[ARRAYIDX6_2]], align 2
; CHECK-NEXT:    [[ARRAYIDX8_2:%.*]] = getelementptr inbounds i16, ptr [[TMP1]], i32 2
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[ARRAYIDX8_2]], align 2
; CHECK-NEXT:    [[TMP10:%.*]] = call i32 @llvm.arm.smlad(i32 [[TMP9]], i32 [[TMP7]], i32 [[ADD_1]])
; CHECK-NEXT:    store i32 [[TMP10]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC12]] = add nuw i32 [[I_030]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC12]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]]
;
entry:
  %cmp29 = icmp eq i32 %N, 0
  br i1 %cmp29, label %for.cond.cleanup, label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.030 = phi i32 [ %inc12, %for.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i32, ptr %a, i32 %i.030
  %arrayidx5 = getelementptr inbounds ptr, ptr %b, i32 %i.030
  %0 = load ptr, ptr %arrayidx5, align 4
  %arrayidx7 = getelementptr inbounds ptr, ptr %c, i32 %i.030
  %1 = load ptr, ptr %arrayidx7, align 4
  %2 = load i16, ptr %0, align 2
  %conv = sext i16 %2 to i32
  %3 = load i16, ptr %1, align 2
  %conv9 = sext i16 %3 to i32
  %sub = sub nsw i32 %conv9, %conv
  %arrayidx6.1 = getelementptr inbounds i16, ptr %0, i32 1
  %4 = load i16, ptr %arrayidx6.1, align 2
  %conv.1 = sext i16 %4 to i32
  %arrayidx8.1 = getelementptr inbounds i16, ptr %1, i32 1
  %5 = load i16, ptr %arrayidx8.1, align 2
  %conv9.1 = sext i16 %5 to i32
  %mul.1 = mul nsw i32 %conv9.1, %conv.1
  %add.1 = add nsw i32 %mul.1, %sub
  %arrayidx6.2 = getelementptr inbounds i16, ptr %0, i32 2
  %6 = load i16, ptr %arrayidx6.2, align 2
  %conv.2 = sext i16 %6 to i32
  %arrayidx8.2 = getelementptr inbounds i16, ptr %1, i32 2
  %7 = load i16, ptr %arrayidx8.2, align 2
  %conv9.2 = sext i16 %7 to i32
  %mul.2 = mul nsw i32 %conv9.2, %conv.2
  %add.2 = add nsw i32 %mul.2, %add.1
  %arrayidx6.3 = getelementptr inbounds i16, ptr %0, i32 3
  %8 = load i16, ptr %arrayidx6.3, align 2
  %conv.3 = sext i16 %8 to i32
  %arrayidx8.3 = getelementptr inbounds i16, ptr %1, i32 3
  %9 = load i16, ptr %arrayidx8.3, align 2
  %conv9.3 = sext i16 %9 to i32
  %mul.3 = mul nsw i32 %conv9.3, %conv.3
  %add.3 = add nsw i32 %mul.3, %add.2
  store i32 %add.3, ptr %arrayidx, align 4
  %inc12 = add nuw i32 %i.030, 1
  %exitcond = icmp eq i32 %inc12, %N
  br i1 %exitcond, label %for.cond.cleanup, label %for.body
}
