; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=armv7-apple-ios6.0 | FileCheck %s
; RUN: llc < %s -mtriple=thumbv7-apple-ios6.0 | FileCheck %s
; RUN: llc < %s -mtriple=armv7-unknown-nacl-gnueabi | FileCheck %s -check-prefix=NACL
; RUN: llc < %s -mtriple=armv5-none-linux-gnueabi | FileCheck %s -check-prefix=NOMOVT

; NOMOVT-NOT: movt

; rdar://9877866
%struct.SmallStruct = type { i32, [8 x i32], [37 x i8] }
%struct.LargeStruct = type { i32, [1001 x i8], [300 x i32] }

define i32 @f() nounwind ssp {
; NACL-LABEL: f:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    .save {r4, lr}
; NACL-NEXT:    push {r4, lr}
; NACL-NEXT:    .pad #152
; NACL-NEXT:    sub sp, sp, #152
; NACL-NEXT:    movw r0, :lower16:__stack_chk_guard
; NACL-NEXT:    add r3, sp, #72
; NACL-NEXT:    movt r0, :upper16:__stack_chk_guard
; NACL-NEXT:    mov lr, sp
; NACL-NEXT:    ldr r0, [r0]
; NACL-NEXT:    str r0, [sp, #148]
; NACL-NEXT:    add r0, sp, #72
; NACL-NEXT:    add r12, r0, #16
; NACL-NEXT:    ldm r3, {r0, r1, r2, r3}
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    ldr r4, [r12], #4
; NACL-NEXT:    str r4, [lr], #4
; NACL-NEXT:    bl e1
; NACL-NEXT:    movw r1, :lower16:__stack_chk_guard
; NACL-NEXT:    ldr r0, [sp, #148]
; NACL-NEXT:    movt r1, :upper16:__stack_chk_guard
; NACL-NEXT:    ldr r1, [r1]
; NACL-NEXT:    cmp r1, r0
; NACL-NEXT:    moveq r0, #0
; NACL-NEXT:    addeq sp, sp, #152
; NACL-NEXT:    popeq {r4, pc}
; NACL-NEXT:  .LBB0_1: @ %entry
; NACL-NEXT:    bl __stack_chk_fail
;
; NOMOVT-LABEL: f:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    .save {r11, lr}
; NOMOVT-NEXT:    push {r11, lr}
; NOMOVT-NEXT:    .pad #144
; NOMOVT-NEXT:    sub sp, sp, #144
; NOMOVT-NEXT:    ldr r0, .LCPI0_0
; NOMOVT-NEXT:    mov r1, sp
; NOMOVT-NEXT:    add r3, sp, #64
; NOMOVT-NEXT:    ldr r0, [r0]
; NOMOVT-NEXT:    str r0, [sp, #140]
; NOMOVT-NEXT:    add r0, sp, #64
; NOMOVT-NEXT:    add r0, r0, #16
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldr r2, [r0], #4
; NOMOVT-NEXT:    str r2, [r1], #4
; NOMOVT-NEXT:    ldm r3, {r0, r1, r2, r3}
; NOMOVT-NEXT:    bl e1
; NOMOVT-NEXT:    ldr r0, [sp, #140]
; NOMOVT-NEXT:    ldr r1, .LCPI0_0
; NOMOVT-NEXT:    ldr r1, [r1]
; NOMOVT-NEXT:    cmp r1, r0
; NOMOVT-NEXT:    moveq r0, #0
; NOMOVT-NEXT:    addeq sp, sp, #144
; NOMOVT-NEXT:    popeq {r11, pc}
; NOMOVT-NEXT:  .LBB0_1: @ %entry
; NOMOVT-NEXT:    bl __stack_chk_fail
; NOMOVT-NEXT:    .p2align 2
; NOMOVT-NEXT:  @ %bb.2:
; NOMOVT-NEXT:  .LCPI0_0:
; NOMOVT-NEXT:    .long __stack_chk_guard
entry:
  %st = alloca %struct.SmallStruct, align 4
  %call = call i32 @e1(ptr byval(%struct.SmallStruct) %st)
  ret i32 0
}

; Generate a loop for large struct byval
define i32 @g() nounwind ssp {
; NACL-LABEL: g:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    .save {r4, r5, r11, lr}
; NACL-NEXT:    push {r4, r5, r11, lr}
; NACL-NEXT:    .pad #2224
; NACL-NEXT:    sub sp, sp, #2224
; NACL-NEXT:    movw r0, :lower16:__stack_chk_guard
; NACL-NEXT:    movt r0, :upper16:__stack_chk_guard
; NACL-NEXT:    ldr r0, [r0]
; NACL-NEXT:    str r0, [sp, #2220]
; NACL-NEXT:    sub sp, sp, #2192
; NACL-NEXT:    add lr, sp, #2048
; NACL-NEXT:    ldr r1, [sp, #2208]
; NACL-NEXT:    add r0, lr, #156
; NACL-NEXT:    ldr r2, [sp, #2212]
; NACL-NEXT:    add r12, r0, #16
; NACL-NEXT:    ldr r0, [sp, #2204]
; NACL-NEXT:    ldr r3, [sp, #2216]
; NACL-NEXT:    movw lr, #2192
; NACL-NEXT:    mov r4, sp
; NACL-NEXT:  .LBB1_1: @ %entry
; NACL-NEXT:    @ =>This Inner Loop Header: Depth=1
; NACL-NEXT:    ldr r5, [r12], #4
; NACL-NEXT:    subs lr, lr, #4
; NACL-NEXT:    str r5, [r4], #4
; NACL-NEXT:    bne .LBB1_1
; NACL-NEXT:  @ %bb.2: @ %entry
; NACL-NEXT:    bl e2
; NACL-NEXT:    add sp, sp, #2192
; NACL-NEXT:    movw r1, :lower16:__stack_chk_guard
; NACL-NEXT:    ldr r0, [sp, #2220]
; NACL-NEXT:    movt r1, :upper16:__stack_chk_guard
; NACL-NEXT:    ldr r1, [r1]
; NACL-NEXT:    cmp r1, r0
; NACL-NEXT:    moveq r0, #0
; NACL-NEXT:    addeq sp, sp, #2224
; NACL-NEXT:    popeq {r4, r5, r11, pc}
; NACL-NEXT:  .LBB1_3: @ %entry
; NACL-NEXT:    bl __stack_chk_fail
;
; NOMOVT-LABEL: g:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    .save {r11, lr}
; NOMOVT-NEXT:    push {r11, lr}
; NOMOVT-NEXT:    .pad #168
; NOMOVT-NEXT:    sub sp, sp, #168
; NOMOVT-NEXT:    .pad #2048
; NOMOVT-NEXT:    sub sp, sp, #2048
; NOMOVT-NEXT:    ldr r0, .LCPI1_1
; NOMOVT-NEXT:    ldr r0, [r0]
; NOMOVT-NEXT:    str r0, [sp, #2212]
; NOMOVT-NEXT:    sub sp, sp, #2192
; NOMOVT-NEXT:    add lr, sp, #2048
; NOMOVT-NEXT:    ldr r1, .LCPI1_0
; NOMOVT-NEXT:    add r0, lr, #148
; NOMOVT-NEXT:    mov r2, sp
; NOMOVT-NEXT:    add r0, r0, #16
; NOMOVT-NEXT:  .LBB1_1: @ %entry
; NOMOVT-NEXT:    @ =>This Inner Loop Header: Depth=1
; NOMOVT-NEXT:    ldr r3, [r0], #4
; NOMOVT-NEXT:    subs r1, r1, #4
; NOMOVT-NEXT:    str r3, [r2], #4
; NOMOVT-NEXT:    bne .LBB1_1
; NOMOVT-NEXT:  @ %bb.2: @ %entry
; NOMOVT-NEXT:    ldr r0, [sp, #2196]
; NOMOVT-NEXT:    ldr r1, [sp, #2200]
; NOMOVT-NEXT:    ldr r2, [sp, #2204]
; NOMOVT-NEXT:    ldr r3, [sp, #2208]
; NOMOVT-NEXT:    bl e2
; NOMOVT-NEXT:    add sp, sp, #2192
; NOMOVT-NEXT:    ldr r0, [sp, #2212]
; NOMOVT-NEXT:    ldr r1, .LCPI1_1
; NOMOVT-NEXT:    ldr r1, [r1]
; NOMOVT-NEXT:    cmp r1, r0
; NOMOVT-NEXT:    moveq r0, #0
; NOMOVT-NEXT:    addeq sp, sp, #168
; NOMOVT-NEXT:    addeq sp, sp, #2048
; NOMOVT-NEXT:    popeq {r11, pc}
; NOMOVT-NEXT:  .LBB1_3: @ %entry
; NOMOVT-NEXT:    bl __stack_chk_fail
; NOMOVT-NEXT:    .p2align 2
; NOMOVT-NEXT:  @ %bb.4:
; NOMOVT-NEXT:  .LCPI1_0:
; NOMOVT-NEXT:    .long 2192 @ 0x890
; NOMOVT-NEXT:  .LCPI1_1:
; NOMOVT-NEXT:    .long __stack_chk_guard
entry:
; Ensure that use movw instead of constpool for the loop trip count. But don't
; match the __stack_chk_guard movw
  %st = alloca %struct.LargeStruct, align 4
  %call = call i32 @e2(ptr byval(%struct.LargeStruct) %st)
  ret i32 0
}

; Generate a loop using NEON instructions
define i32 @h() nounwind ssp {
; NACL-LABEL: h:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    .save {r4, r5, r6, r7, r8, lr}
; NACL-NEXT:    push {r4, r5, r6, r7, r8, lr}
; NACL-NEXT:    .pad #168
; NACL-NEXT:    sub sp, sp, #168
; NACL-NEXT:    .pad #2048
; NACL-NEXT:    sub sp, sp, #2048
; NACL-NEXT:    movw r0, :lower16:__stack_chk_guard
; NACL-NEXT:    movt r0, :upper16:__stack_chk_guard
; NACL-NEXT:    ldr r0, [r0]
; NACL-NEXT:    str r0, [sp, #2212]
; NACL-NEXT:    sub sp, sp, #2192
; NACL-NEXT:    add r3, sp, #2192
; NACL-NEXT:    add r0, sp, #2192
; NACL-NEXT:    add r12, r0, #16
; NACL-NEXT:    movw lr, #2192
; NACL-NEXT:    ldm r3, {r0, r1, r2, r3}
; NACL-NEXT:    mov r4, sp
; NACL-NEXT:  .LBB2_1: @ %entry
; NACL-NEXT:    @ =>This Inner Loop Header: Depth=1
; NACL-NEXT:    vld1.32 {d16, d17}, [r12]!
; NACL-NEXT:    subs lr, lr, #16
; NACL-NEXT:    vst1.32 {d16, d17}, [r4]!
; NACL-NEXT:    bne .LBB2_1
; NACL-NEXT:  @ %bb.2: @ %entry
; NACL-NEXT:    bl e3
; NACL-NEXT:    add sp, sp, #2192
; NACL-NEXT:    movw r1, :lower16:__stack_chk_guard
; NACL-NEXT:    ldr r0, [sp, #2212]
; NACL-NEXT:    movt r1, :upper16:__stack_chk_guard
; NACL-NEXT:    ldr r1, [r1]
; NACL-NEXT:    cmp r1, r0
; NACL-NEXT:    moveq r0, #0
; NACL-NEXT:    addeq sp, sp, #168
; NACL-NEXT:    addeq sp, sp, #2048
; NACL-NEXT:    popeq {r4, r5, r6, r7, r8, pc}
; NACL-NEXT:  .LBB2_3: @ %entry
; NACL-NEXT:    bl __stack_chk_fail
;
; NOMOVT-LABEL: h:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    .save {r6, r10, r11, lr}
; NOMOVT-NEXT:    push {r6, r10, r11, lr}
; NOMOVT-NEXT:    .setfp r11, sp, #8
; NOMOVT-NEXT:    add r11, sp, #8
; NOMOVT-NEXT:    .pad #2224
; NOMOVT-NEXT:    sub sp, sp, #2224
; NOMOVT-NEXT:    bic sp, sp, #15
; NOMOVT-NEXT:    ldr r0, .LCPI2_1
; NOMOVT-NEXT:    mov r6, sp
; NOMOVT-NEXT:    ldr r0, [r0]
; NOMOVT-NEXT:    str r0, [r6, #2220]
; NOMOVT-NEXT:    sub sp, sp, #2192
; NOMOVT-NEXT:    mov r0, r6
; NOMOVT-NEXT:    ldr r1, .LCPI2_0
; NOMOVT-NEXT:    add r0, r0, #16
; NOMOVT-NEXT:    mov r2, sp
; NOMOVT-NEXT:  .LBB2_1: @ %entry
; NOMOVT-NEXT:    @ =>This Inner Loop Header: Depth=1
; NOMOVT-NEXT:    ldr r3, [r0], #4
; NOMOVT-NEXT:    subs r1, r1, #4
; NOMOVT-NEXT:    str r3, [r2], #4
; NOMOVT-NEXT:    bne .LBB2_1
; NOMOVT-NEXT:  @ %bb.2: @ %entry
; NOMOVT-NEXT:    ldm r6, {r0, r1, r2, r3}
; NOMOVT-NEXT:    bl e3
; NOMOVT-NEXT:    add sp, sp, #2192
; NOMOVT-NEXT:    ldr r0, [r6, #2220]
; NOMOVT-NEXT:    ldr r1, .LCPI2_1
; NOMOVT-NEXT:    ldr r1, [r1]
; NOMOVT-NEXT:    cmp r1, r0
; NOMOVT-NEXT:    moveq r0, #0
; NOMOVT-NEXT:    subeq sp, r11, #8
; NOMOVT-NEXT:    popeq {r6, r10, r11, pc}
; NOMOVT-NEXT:  .LBB2_3: @ %entry
; NOMOVT-NEXT:    bl __stack_chk_fail
; NOMOVT-NEXT:    .p2align 2
; NOMOVT-NEXT:  @ %bb.4:
; NOMOVT-NEXT:  .LCPI2_0:
; NOMOVT-NEXT:    .long 2192 @ 0x890
; NOMOVT-NEXT:  .LCPI2_1:
; NOMOVT-NEXT:    .long __stack_chk_guard
entry:
  %st = alloca %struct.LargeStruct, align 16
  %call = call i32 @e3(ptr byval(%struct.LargeStruct) align 16 %st)
  ret i32 0
}

declare i32 @e1(ptr nocapture byval(%struct.SmallStruct) %in) nounwind
declare i32 @e2(ptr nocapture byval(%struct.LargeStruct) %in) nounwind
declare i32 @e3(ptr nocapture byval(%struct.LargeStruct) align 16 %in) nounwind

; rdar://12442472
; We can't do tail call since address of s is passed to the callee and part of
; s is in caller's local frame.
define void @f3(ptr nocapture byval(%struct.SmallStruct) %s) nounwind optsize {
; NACL-LABEL: f3:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    .pad #16
; NACL-NEXT:    sub sp, sp, #16
; NACL-NEXT:    stm sp, {r0, r1, r2, r3}
; NACL-NEXT:    mov r0, sp
; NACL-NEXT:    mov r1, #80
; NACL-NEXT:    add sp, sp, #16
; NACL-NEXT:    b consumestruct
;
; NOMOVT-LABEL: f3:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    .pad #16
; NOMOVT-NEXT:    sub sp, sp, #16
; NOMOVT-NEXT:    stm sp, {r0, r1, r2, r3}
; NOMOVT-NEXT:    mov r0, sp
; NOMOVT-NEXT:    mov r1, #80
; NOMOVT-NEXT:    add sp, sp, #16
; NOMOVT-NEXT:    b consumestruct
entry:
  tail call void @consumestruct(ptr %s, i32 80) optsize
  ret void
}

define void @f4(ptr nocapture byval(%struct.SmallStruct) %s) nounwind optsize {
; NACL-LABEL: f4:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    .pad #16
; NACL-NEXT:    sub sp, sp, #16
; NACL-NEXT:    stm sp, {r0, r1, r2, r3}
; NACL-NEXT:    mov r0, sp
; NACL-NEXT:    mov r1, #80
; NACL-NEXT:    add sp, sp, #16
; NACL-NEXT:    b consumestruct
;
; NOMOVT-LABEL: f4:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    .pad #16
; NOMOVT-NEXT:    sub sp, sp, #16
; NOMOVT-NEXT:    stm sp, {r0, r1, r2, r3}
; NOMOVT-NEXT:    mov r0, sp
; NOMOVT-NEXT:    mov r1, #80
; NOMOVT-NEXT:    add sp, sp, #16
; NOMOVT-NEXT:    b consumestruct
entry:
  tail call void @consumestruct(ptr %s, i32 80) optsize
  ret void
}

; We can do tail call here since s is in the incoming argument area.
define void @f5(i32 %a, i32 %b, i32 %c, i32 %d, ptr nocapture byval(%struct.SmallStruct) %s) nounwind optsize {
; NACL-LABEL: f5:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    mov r0, sp
; NACL-NEXT:    mov r1, #80
; NACL-NEXT:    b consumestruct
;
; NOMOVT-LABEL: f5:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    mov r0, sp
; NOMOVT-NEXT:    mov r1, #80
; NOMOVT-NEXT:    b consumestruct
entry:
  tail call void @consumestruct(ptr %s, i32 80) optsize
  ret void
}

define void @f6(i32 %a, i32 %b, i32 %c, i32 %d, ptr nocapture byval(%struct.SmallStruct) %s) nounwind optsize {
; NACL-LABEL: f6:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    mov r0, sp
; NACL-NEXT:    mov r1, #80
; NACL-NEXT:    b consumestruct
;
; NOMOVT-LABEL: f6:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    mov r0, sp
; NOMOVT-NEXT:    mov r1, #80
; NOMOVT-NEXT:    b consumestruct
entry:
  tail call void @consumestruct(ptr %s, i32 80) optsize
  ret void
}

declare void @consumestruct(ptr nocapture %structp, i32 %structsize) nounwind

; PR17309
%struct.I.8 = type { [10 x i32], [3 x i8] }

declare void @use_I(ptr byval(%struct.I.8))
define void @test_I_16() {
; NACL-LABEL: test_I_16:
; NACL:       @ %bb.0: @ %entry
; NACL-NEXT:    .save {r11, lr}
; NACL-NEXT:    push {r11, lr}
; NACL-NEXT:    .pad #40
; NACL-NEXT:    sub sp, sp, #40
; NACL-NEXT:    ldr r0, [r0]
; NACL-NEXT:    mov r1, sp
; NACL-NEXT:    vld1.32 {d16, d17}, [r2]!
; NACL-NEXT:    vst1.32 {d16, d17}, [r1]!
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    ldrb r3, [r2], #1
; NACL-NEXT:    strb r3, [r1], #1
; NACL-NEXT:    mov r2, r0
; NACL-NEXT:    mov r1, r0
; NACL-NEXT:    mov r3, r0
; NACL-NEXT:    bl use_I
; NACL-NEXT:    add sp, sp, #40
; NACL-NEXT:    pop {r11, pc}
;
; NOMOVT-LABEL: test_I_16:
; NOMOVT:       @ %bb.0: @ %entry
; NOMOVT-NEXT:    .save {r11, lr}
; NOMOVT-NEXT:    push {r11, lr}
; NOMOVT-NEXT:    .setfp r11, sp
; NOMOVT-NEXT:    mov r11, sp
; NOMOVT-NEXT:    .pad #40
; NOMOVT-NEXT:    sub sp, sp, #40
; NOMOVT-NEXT:    bic sp, sp, #15
; NOMOVT-NEXT:    ldr r0, [r1], #4
; NOMOVT-NEXT:    mov r2, sp
; NOMOVT-NEXT:    str r0, [r2], #4
; NOMOVT-NEXT:    ldr r0, [r1], #4
; NOMOVT-NEXT:    str r0, [r2], #4
; NOMOVT-NEXT:    ldr r0, [r1], #4
; NOMOVT-NEXT:    str r0, [r2], #4
; NOMOVT-NEXT:    ldr r0, [r1], #4
; NOMOVT-NEXT:    str r0, [r2], #4
; NOMOVT-NEXT:    ldr r0, [r1], #4
; NOMOVT-NEXT:    str r0, [r2], #4
; NOMOVT-NEXT:    ldr r0, [r1], #4
; NOMOVT-NEXT:    str r0, [r2], #4
; NOMOVT-NEXT:    ldr r0, [r1], #4
; NOMOVT-NEXT:    str r0, [r2], #4
; NOMOVT-NEXT:    ldr r0, [r0]
; NOMOVT-NEXT:    mov r1, r0
; NOMOVT-NEXT:    mov r2, r0
; NOMOVT-NEXT:    mov r3, r0
; NOMOVT-NEXT:    bl use_I
; NOMOVT-NEXT:    mov sp, r11
; NOMOVT-NEXT:    pop {r11, pc}
entry:
  call void @use_I(ptr byval(%struct.I.8) align 16 undef)
  ret void
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
