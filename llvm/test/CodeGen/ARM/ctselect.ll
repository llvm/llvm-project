; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=armv7-none-eabi -verify-machineinstrs | FileCheck --check-prefixes=CT %s
; RUN: llc < %s -mtriple=armv6 -verify-machineinstrs | FileCheck --check-prefix=DEFAULT %s

define i1 @ct_i1(i1 %cond, i1 %a, i1 %b) {
; CT-LABEL: ct_i1:
; CT:       @ %bb.0: @ %entry
; CT-NEXT:    and r3, r0, #1
; CT-NEXT:    rsb r12, r3, #0
; CT-NEXT:    and r0, r1, r12
; CT-NEXT:    bic r12, r2, r12
; CT-NEXT:    orr r0, r0, r12
; CT-NEXT:    bx lr
;
; DEFAULT-LABEL: ct_i1:
; DEFAULT:       @ %bb.0: @ %entry
; DEFAULT-NEXT:    and r3, r0, #1
; DEFAULT-NEXT:    rsb r12, r3, #0
; DEFAULT-NEXT:    and r0, r1, r12
; DEFAULT-NEXT:    bic r12, r2, r12
; DEFAULT-NEXT:    orr r0, r0, r12
; DEFAULT-NEXT:    bx lr
entry:
  %sel = call i1 @llvm.ct.select.i1(i1 %cond, i1 %a, i1 %b)
  ret i1 %sel
}

define i8 @ct_int8(i1 %cond, i8 %a, i8 %b) {
; CT-LABEL: ct_int8:
; CT:       @ %bb.0: @ %entry
; CT-NEXT:    and r3, r0, #1
; CT-NEXT:    rsb r12, r3, #0
; CT-NEXT:    and r0, r1, r12
; CT-NEXT:    bic r12, r2, r12
; CT-NEXT:    orr r0, r0, r12
; CT-NEXT:    bx lr
;
; DEFAULT-LABEL: ct_int8:
; DEFAULT:       @ %bb.0: @ %entry
; DEFAULT-NEXT:    and r3, r0, #1
; DEFAULT-NEXT:    rsb r12, r3, #0
; DEFAULT-NEXT:    and r0, r1, r12
; DEFAULT-NEXT:    bic r12, r2, r12
; DEFAULT-NEXT:    orr r0, r0, r12
; DEFAULT-NEXT:    bx lr
entry:
  %sel = call i8 @llvm.ct.select.i8(i1 %cond, i8 %a, i8 %b)
  ret i8 %sel
}

define i16 @ct_int16(i1 %cond, i16 %a, i16 %b) {
; CT-LABEL: ct_int16:
; CT:       @ %bb.0: @ %entry
; CT-NEXT:    and r3, r0, #1
; CT-NEXT:    rsb r12, r3, #0
; CT-NEXT:    and r0, r1, r12
; CT-NEXT:    bic r12, r2, r12
; CT-NEXT:    orr r0, r0, r12
; CT-NEXT:    bx lr
;
; DEFAULT-LABEL: ct_int16:
; DEFAULT:       @ %bb.0: @ %entry
; DEFAULT-NEXT:    and r3, r0, #1
; DEFAULT-NEXT:    rsb r12, r3, #0
; DEFAULT-NEXT:    and r0, r1, r12
; DEFAULT-NEXT:    bic r12, r2, r12
; DEFAULT-NEXT:    orr r0, r0, r12
; DEFAULT-NEXT:    bx lr
entry:
  %sel = call i16 @llvm.ct.select.i16(i1 %cond, i16 %a, i16 %b)
  ret i16 %sel
}

define i32 @ct_int32(i1 %cond, i32 %a, i32 %b) {
; CT-LABEL: ct_int32:
; CT:       @ %bb.0: @ %entry
; CT-NEXT:    and r3, r0, #1
; CT-NEXT:    rsb r12, r3, #0
; CT-NEXT:    and r0, r1, r12
; CT-NEXT:    bic r12, r2, r12
; CT-NEXT:    orr r0, r0, r12
; CT-NEXT:    bx lr
;
; DEFAULT-LABEL: ct_int32:
; DEFAULT:       @ %bb.0: @ %entry
; DEFAULT-NEXT:    and r3, r0, #1
; DEFAULT-NEXT:    rsb r12, r3, #0
; DEFAULT-NEXT:    and r0, r1, r12
; DEFAULT-NEXT:    bic r12, r2, r12
; DEFAULT-NEXT:    orr r0, r0, r12
; DEFAULT-NEXT:    bx lr
entry:
  %sel = call i32 @llvm.ct.select.i32(i1 %cond, i32 %a, i32 %b)
  ret i32 %sel
}

define i64 @ct_int64(i1 %cond, i64 %a, i64 %b) {
; CT-LABEL: ct_int64:
; CT:       @ %bb.0: @ %entry
; CT-NEXT:    .save {r4, lr}
; CT-NEXT:    push {r4, lr}
; CT-NEXT:    and lr, r0, #1
; CT-NEXT:    ldr r12, [sp, #12]
; CT-NEXT:    rsb r4, lr, #0
; CT-NEXT:    ldr r1, [sp, #8]
; CT-NEXT:    and r0, r2, r4
; CT-NEXT:    rsb r2, lr, #0
; CT-NEXT:    bic r4, r1, r4
; CT-NEXT:    and r1, r3, r2
; CT-NEXT:    bic r2, r12, r2
; CT-NEXT:    orr r0, r0, r4
; CT-NEXT:    orr r1, r1, r2
; CT-NEXT:    pop {r4, pc}
;
; DEFAULT-LABEL: ct_int64:
; DEFAULT:       @ %bb.0: @ %entry
; DEFAULT-NEXT:    push {r11, lr}
; DEFAULT-NEXT:    and r12, r0, #1
; DEFAULT-NEXT:    ldr r1, [sp, #8]
; DEFAULT-NEXT:    rsb lr, r12, #0
; DEFAULT-NEXT:    and r0, r2, lr
; DEFAULT-NEXT:    bic lr, r1, lr
; DEFAULT-NEXT:    ldr r2, [sp, #12]
; DEFAULT-NEXT:    orr r0, r0, lr
; DEFAULT-NEXT:    rsb lr, r12, #0
; DEFAULT-NEXT:    and r1, r3, lr
; DEFAULT-NEXT:    bic lr, r2, lr
; DEFAULT-NEXT:    orr r1, r1, lr
; DEFAULT-NEXT:    pop {r11, pc}
entry:
  %sel = call i64 @llvm.ct.select.i64(i1 %cond, i64 %a, i64 %b)
  ret i64 %sel
}

define float @ct_float(i1 %cond, float %a, float %b) {
; CT-LABEL: ct_float:
; CT:       @ %bb.0: @ %entry
; CT-NEXT:    vmov s0, r2
; CT-NEXT:    and r0, r0, #1
; CT-NEXT:    vmov s2, r1
; CT-NEXT:    rsb r1, r0, #0
; CT-NEXT:    vmov r3, s0
; CT-NEXT:    vmov r2, s2
; CT-NEXT:    and r2, r2, r1
; CT-NEXT:    bic r1, r3, r1
; CT-NEXT:    orr r2, r2, r1
; CT-NEXT:    vmov s4, r2
; CT-NEXT:    vmov r0, s4
; CT-NEXT:    bx lr
;
; DEFAULT-LABEL: ct_float:
; DEFAULT:       @ %bb.0: @ %entry
; DEFAULT-NEXT:    and r3, r0, #1
; DEFAULT-NEXT:    rsb r12, r3, #0
; DEFAULT-NEXT:    and r0, r1, r12
; DEFAULT-NEXT:    bic r12, r2, r12
; DEFAULT-NEXT:    orr r0, r0, r12
; DEFAULT-NEXT:    bx lr
entry:
  %sel = call float @llvm.ct.select.f32(i1 %cond, float %a, float %b)
  ret float %sel
}

define double @ct_f64(i1 %cond, double %a, double %b) {
; CT-LABEL: ct_f64:
; CT:       @ %bb.0: @ %entry
; CT-NEXT:    and r0, r0, #1
; CT-NEXT:    vldr d16, [sp]
; CT-NEXT:    rsb r1, r0, #0
; CT-NEXT:    vmov d17, r2, r3
; CT-NEXT:    vdup.32 d19, r1
; CT-NEXT:    vand d18, d17, d19
; CT-NEXT:    vbic d19, d16, d19
; CT-NEXT:    vorr d18, d18, d19
; CT-NEXT:    vmov r0, r1, d18
; CT-NEXT:    bx lr
;
; DEFAULT-LABEL: ct_f64:
; DEFAULT:       @ %bb.0: @ %entry
; DEFAULT-NEXT:    push {r11, lr}
; DEFAULT-NEXT:    and r12, r0, #1
; DEFAULT-NEXT:    ldr r1, [sp, #8]
; DEFAULT-NEXT:    rsb lr, r12, #0
; DEFAULT-NEXT:    and r0, r2, lr
; DEFAULT-NEXT:    bic lr, r1, lr
; DEFAULT-NEXT:    ldr r2, [sp, #12]
; DEFAULT-NEXT:    orr r0, r0, lr
; DEFAULT-NEXT:    rsb lr, r12, #0
; DEFAULT-NEXT:    and r1, r3, lr
; DEFAULT-NEXT:    bic lr, r2, lr
; DEFAULT-NEXT:    orr r1, r1, lr
; DEFAULT-NEXT:    pop {r11, pc}
entry:
  %sel = call double @llvm.ct.select.f64(i1 %cond, double %a, double %b)
  ret double %sel
}
