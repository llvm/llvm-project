; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=armv7-linux-gnueabihf %s -o - | FileCheck %s --check-prefixes=CHECK-COMMON,CHECK-ARM
; RUN: llc -mtriple=armv7eb-linux-gnueabihf %s -o - | FileCheck %s --check-prefixes=CHECK-BE
; RUN: llc -mtriple=thumbv7-linux-gnueabihf %s -o - | FileCheck %s --check-prefixes=CHECK-COMMON,CHECK-THUMB
; RUN: llc -mtriple=thumbv7m %s -o - | FileCheck %s --check-prefixes=CHECK-COMMON,CHECK-THUMB
; RUN: llc -mtriple=thumbv7m -mattr=+strict-align %s -o - | FileCheck %s --check-prefixes=CHECK-COMMON,CHECK-ALIGN
; RUN: llc -mtriple=thumbv6m %s -o - | FileCheck %s --check-prefix=CHECK-V6M

; -----------------------------------------------------------------
; LSL (shl) group
; -----------------------------------------------------------------

; (amount = amt + 32) => should remove the ADD and emit LSL directly.
define i32 @lsl_add_mod(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsl_add_mod:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    add r1, r1, #32
; CHECK-NEXT:    lsl r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsl_add_mod:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    add r1, r1, #32
; CHECK-ARM-NEXT:    lsl r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsl_add_mod:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    add r1, r1, #32
; CHECK-BE-NEXT:    lsl r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsl_add_mod:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    adds r1, #32
; CHECK-THUMB-NEXT:    lsls r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsl_add_mod:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    adds r1, #32
; CHECK-ALIGN-NEXT:    lsls r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsl_add_mod:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    adds r1, #32
; CHECK-V6M-NEXT:    lsls r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = add i32 %amt, 32
  %r  = shl i32 %val, %sa
  ret i32 %r
}

; (amount = 32 - amt) => should become RSB/NEG then used by LSL.
define i32 @lsl_sub_rsb(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsl_sub_rsb:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #32
; CHECK-NEXT:    lsl r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsl_sub_rsb:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #32
; CHECK-ARM-NEXT:    lsl r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsl_sub_rsb:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #32
; CHECK-BE-NEXT:    lsl r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsl_sub_rsb:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #32
; CHECK-THUMB-NEXT:    lsls r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsl_sub_rsb:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #32
; CHECK-ALIGN-NEXT:    lsls r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsl_sub_rsb:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #32
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    lsls r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 32, %amt
  %r  = shl i32 %val, %sa
  ret i32 %r
}

; (amount = 31 - amt) => should become MVN(amt) then used by LSL.
define i32 @lsl_sub_mvn(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsl_sub_mvn:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #31
; CHECK-NEXT:    lsl r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsl_sub_mvn:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #31
; CHECK-ARM-NEXT:    lsl r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsl_sub_mvn:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #31
; CHECK-BE-NEXT:    lsl r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsl_sub_mvn:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #31
; CHECK-THUMB-NEXT:    lsls r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsl_sub_mvn:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #31
; CHECK-ALIGN-NEXT:    lsls r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsl_sub_mvn:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    lsls r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 31, %amt
  %r  = shl i32 %val, %sa
  ret i32 %r
}

; (amount = amt & 31) => AND is redundant; should be removed and emit LSL only.
define i32 @lsl_and_mask(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsl_and_mask:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    and r1, r1, #31
; CHECK-NEXT:    lsl r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsl_and_mask:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    and r1, r1, #31
; CHECK-ARM-NEXT:    lsl r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsl_and_mask:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    and r1, r1, #31
; CHECK-BE-NEXT:    lsl r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsl_and_mask:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    and r1, r1, #31
; CHECK-THUMB-NEXT:    lsls r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsl_and_mask:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    and r1, r1, #31
; CHECK-ALIGN-NEXT:    lsls r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsl_and_mask:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    ands r2, r1
; CHECK-V6M-NEXT:    lsls r0, r2
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = and i32 %amt, 31
  %r  = shl i32 %val, %sa
  ret i32 %r
}

; -----------------------------------------------------------------
; LSR (logical right) group
; -----------------------------------------------------------------

; (amount = amt + 32) => should remove the ADD and emit LSR directly.
define i32 @lsr_add_mod(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsr_add_mod:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    add r1, r1, #32
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsr_add_mod:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    add r1, r1, #32
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsr_add_mod:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    add r1, r1, #32
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsr_add_mod:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    adds r1, #32
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsr_add_mod:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    adds r1, #32
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsr_add_mod:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    adds r1, #32
; CHECK-V6M-NEXT:    lsrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = add i32 %amt, 32
  %r  = lshr i32 %val, %sa
  ret i32 %r
}

; (amount = 32 - amt) => should become RSB/NEG then used by LSR (and in some targets may be lowered to ROR form).
define i32 @lsr_sub_rsb(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsr_sub_rsb:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #32
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsr_sub_rsb:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #32
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsr_sub_rsb:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #32
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsr_sub_rsb:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #32
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsr_sub_rsb:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #32
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsr_sub_rsb:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #32
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    lsrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 32, %amt
  %r  = lshr i32 %val, %sa
  ret i32 %r
}

; (amount = 31 - amt) => should become MVN(amt) then used by LSR.
define i32 @lsr_sub_mvn(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsr_sub_mvn:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #31
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsr_sub_mvn:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #31
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsr_sub_mvn:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #31
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsr_sub_mvn:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #31
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsr_sub_mvn:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #31
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsr_sub_mvn:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    lsrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 31, %amt
  %r  = lshr i32 %val, %sa
  ret i32 %r
}

; (amount = amt & 31) => AND is redundant; should be removed and emit LSR only.
define i32 @lsr_and_mask(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: lsr_and_mask:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    and r1, r1, #31
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: lsr_and_mask:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    and r1, r1, #31
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: lsr_and_mask:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    and r1, r1, #31
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: lsr_and_mask:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    and r1, r1, #31
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: lsr_and_mask:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    and r1, r1, #31
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: lsr_and_mask:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    ands r2, r1
; CHECK-V6M-NEXT:    lsrs r0, r2
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = and i32 %amt, 31
  %r  = lshr i32 %val, %sa
  ret i32 %r
}

; -----------------------------------------------------------------
; ASR (arithmetic right) group
; -----------------------------------------------------------------

; (amount = amt + 32) => should remove the ADD and emit ASR directly.
; CHECK-LABEL: asr_add_mod:
; CHECK-NOT: add
; CHECK: asr
; THUMB-LABEL: asr_add_mod:
; THUMB-NOT: add
; THUMB: asr
define i32 @asr_add_mod(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: asr_add_mod:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    add r1, r1, #32
; CHECK-NEXT:    asr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: asr_add_mod:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    add r1, r1, #32
; CHECK-ARM-NEXT:    asr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: asr_add_mod:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    add r1, r1, #32
; CHECK-BE-NEXT:    asr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: asr_add_mod:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    adds r1, #32
; CHECK-THUMB-NEXT:    asrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: asr_add_mod:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    adds r1, #32
; CHECK-ALIGN-NEXT:    asrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: asr_add_mod:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    adds r1, #32
; CHECK-V6M-NEXT:    asrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = add i32 %amt, 32
  %r  = ashr i32 %val, %sa
  ret i32 %r
}

; (amount = 32 - amt) => should become RSB/NEG then used by ASR.
; CHECK-LABEL: asr_sub_rsb:
; CHECK: rsb
; CHECK: asr
; THUMB-LABEL: asr_sub_rsb:
; THUMB: rsb
; THUMB: asr
define i32 @asr_sub_rsb(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: asr_sub_rsb:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #32
; CHECK-NEXT:    asr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: asr_sub_rsb:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #32
; CHECK-ARM-NEXT:    asr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: asr_sub_rsb:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #32
; CHECK-BE-NEXT:    asr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: asr_sub_rsb:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #32
; CHECK-THUMB-NEXT:    asrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: asr_sub_rsb:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #32
; CHECK-ALIGN-NEXT:    asrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: asr_sub_rsb:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #32
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    asrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 32, %amt
  %r  = ashr i32 %val, %sa
  ret i32 %r
}

; (amount = 31 - amt) => should become MVN(amt) then used by ASR.
; CHECK-LABEL: asr_sub_mvn:
; CHECK: mvn
; CHECK: asr
; THUMB-LABEL: asr_sub_mvn:
; THUMB: mvn
; THUMB: asr
define i32 @asr_sub_mvn(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: asr_sub_mvn:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #31
; CHECK-NEXT:    asr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: asr_sub_mvn:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #31
; CHECK-ARM-NEXT:    asr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: asr_sub_mvn:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #31
; CHECK-BE-NEXT:    asr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: asr_sub_mvn:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #31
; CHECK-THUMB-NEXT:    asrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: asr_sub_mvn:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #31
; CHECK-ALIGN-NEXT:    asrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: asr_sub_mvn:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    asrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 31, %amt
  %r  = ashr i32 %val, %sa
  ret i32 %r
}

; (amount = amt & 31) => AND is redundant; should be removed and emit ASR only.
; CHECK-LABEL: asr_and_mask:
; CHECK-NOT: and
; CHECK: asr
; THUMB-LABEL: asr_and_mask:
; THUMB-NOT: and
; THUMB: asr
define i32 @asr_and_mask(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: asr_and_mask:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    and r1, r1, #31
; CHECK-NEXT:    asr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: asr_and_mask:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    and r1, r1, #31
; CHECK-ARM-NEXT:    asr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: asr_and_mask:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    and r1, r1, #31
; CHECK-BE-NEXT:    asr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: asr_and_mask:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    and r1, r1, #31
; CHECK-THUMB-NEXT:    asrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: asr_and_mask:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    and r1, r1, #31
; CHECK-ALIGN-NEXT:    asrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: asr_and_mask:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    ands r2, r1
; CHECK-V6M-NEXT:    asrs r0, r2
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = and i32 %amt, 31
  %r  = ashr i32 %val, %sa
  ret i32 %r
}

; (amount = amt + 32) => remove ADD and emit ROR/LSR as appropriate (we check for absence of ADD and presence of LSR/ROR)
define i32 @ror_add_mod(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: ror_add_mod:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    add r1, r1, #32
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: ror_add_mod:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    add r1, r1, #32
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: ror_add_mod:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    add r1, r1, #32
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: ror_add_mod:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    adds r1, #32
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: ror_add_mod:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    adds r1, #32
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: ror_add_mod:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    adds r1, #32
; CHECK-V6M-NEXT:    lsrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = add i32 %amt, 32
  %r  = lshr i32 %val, %sa
  ret i32 %r
}

define i32 @ror_sub_rsb(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: ror_sub_rsb:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #32
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: ror_sub_rsb:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #32
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: ror_sub_rsb:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #32
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: ror_sub_rsb:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #32
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: ror_sub_rsb:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #32
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: ror_sub_rsb:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #32
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    lsrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 32, %amt
  %r  = lshr i32 %val, %sa
  ret i32 %r
}

define i32 @ror_sub_mvn(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: ror_sub_mvn:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    rsb r1, r1, #31
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: ror_sub_mvn:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #31
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: ror_sub_mvn:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #31
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: ror_sub_mvn:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #31
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: ror_sub_mvn:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #31
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: ror_sub_mvn:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    lsrs r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 31, %amt
  %r  = lshr i32 %val, %sa
  ret i32 %r
}

define i32 @ror_and_mask(i32 %val, i32 %amt) #0 {
; CHECK-LABEL: ror_and_mask:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    and r1, r1, #31
; CHECK-NEXT:    lsr r0, r0, r1
; CHECK-NEXT:    bx lr
;
; CHECK-ARM-LABEL: ror_and_mask:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    and r1, r1, #31
; CHECK-ARM-NEXT:    lsr r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: ror_and_mask:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    and r1, r1, #31
; CHECK-BE-NEXT:    lsr r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: ror_and_mask:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    and r1, r1, #31
; CHECK-THUMB-NEXT:    lsrs r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: ror_and_mask:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    and r1, r1, #31
; CHECK-ALIGN-NEXT:    lsrs r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: ror_and_mask:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    ands r2, r1
; CHECK-V6M-NEXT:    lsrs r0, r2
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = and i32 %amt, 31
  %r  = lshr i32 %val, %sa
  ret i32 %r
}


declare i32 @llvm.fshl.i32(i32, i32, i32)
declare i32 @llvm.fshr.i32(i32, i32, i32)

; -----------------------
; fshl (funnel-shift left) group
; fshl(x,x, s) == rotate-left(x, s)
; -----------------------

; amt + 32 -> REMOVE ADD (mod 32), expect rotate lowering (ror/lsl/lsr depending on selector)
define i32 @fshl_add_mod(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshl_add_mod:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    mvn r2, #31
; CHECK-ARM-NEXT:    sub r1, r2, r1
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshl_add_mod:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    mvn r2, #31
; CHECK-BE-NEXT:    sub r1, r2, r1
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshl_add_mod:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    mvn r2, #31
; CHECK-THUMB-NEXT:    subs r1, r2, r1
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshl_add_mod:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    mvn r2, #31
; CHECK-ALIGN-NEXT:    subs r1, r2, r1
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshl_add_mod:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    mvns r2, r2
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = add i32 %amt, 32
  %r  = call i32 @llvm.fshl.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

; 32 - amt -> expect RSB/NEG materialization then rotate lowering
; CHECK-LABEL: fshl_sub_rsb:
; CHECK: rsb
; CHECK: ror
; THUMB-LABEL: fshl_sub_rsb:
; THUMB: rsb
; THUMB: ror
define i32 @fshl_sub_rsb(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshl_sub_rsb:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    sub r1, r1, #32
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshl_sub_rsb:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    sub r1, r1, #32
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshl_sub_rsb:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    subs r1, #32
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshl_sub_rsb:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    subs r1, #32
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshl_sub_rsb:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    subs r1, #32
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 32, %amt
  %r  = call i32 @llvm.fshl.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

; 31 - amt -> expect MVN(amt) (i.e. NOT) then rotate lowering (selector may use NOT+rotate form)
; CHECK-LABEL: fshl_sub_mvn:
; CHECK: mvn
; CHECK: ror
; THUMB-LABEL: fshl_sub_mvn:
; THUMB: mvn
; THUMB: ror
define i32 @fshl_sub_mvn(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshl_sub_mvn:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    sub r1, r1, #31
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshl_sub_mvn:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    sub r1, r1, #31
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshl_sub_mvn:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    subs r1, #31
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshl_sub_mvn:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    subs r1, #31
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshl_sub_mvn:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    subs r1, #31
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 31, %amt
  %r  = call i32 @llvm.fshl.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

; amt & 31 -> AND redundant (hardware masks low 5 bits) -> expect rotate lowering with no AND
define i32 @fshl_and_mask(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshl_and_mask:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #0
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshl_and_mask:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #0
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshl_and_mask:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsbs r1, r1, #0
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshl_and_mask:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsbs r1, r1, #0
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshl_and_mask:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    rsbs r1, r1, #0
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = and i32 %amt, 31
  %r  = call i32 @llvm.fshl.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

; -----------------------
; fshr (funnel-shift right) group
; fshr(x,x, s) == rotate-right(x, s)
; -----------------------

; amt + 32 -> REMOVE ADD (mod 32) -> expect rotate lowering
define i32 @fshr_add_mod(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshr_add_mod:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    add r1, r1, #32
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshr_add_mod:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    add r1, r1, #32
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshr_add_mod:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    adds r1, #32
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshr_add_mod:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    adds r1, #32
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshr_add_mod:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    adds r1, #32
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = add i32 %amt, 32
  %r  = call i32 @llvm.fshr.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

; 32 - amt -> expect RSB then rotate lowering
define i32 @fshr_sub_rsb(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshr_sub_rsb:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #32
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshr_sub_rsb:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #32
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshr_sub_rsb:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #32
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshr_sub_rsb:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #32
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshr_sub_rsb:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #32
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 32, %amt
  %r  = call i32 @llvm.fshr.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

; 31 - amt -> expect MVN then rotate lowering
define i32 @fshr_sub_mvn(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshr_sub_mvn:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    rsb r1, r1, #31
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshr_sub_mvn:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    rsb r1, r1, #31
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshr_sub_mvn:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rsb.w r1, r1, #31
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshr_sub_mvn:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rsb.w r1, r1, #31
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshr_sub_mvn:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    movs r2, #31
; CHECK-V6M-NEXT:    subs r1, r2, r1
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = sub i32 31, %amt
  %r  = call i32 @llvm.fshr.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

; amt & 31 -> AND redundant -> expect rotate lowering with no AND
define i32 @fshr_and_mask(i32 %x, i32 %amt) #0 {
; CHECK-ARM-LABEL: fshr_and_mask:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    ror r0, r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-BE-LABEL: fshr_and_mask:
; CHECK-BE:       @ %bb.0: @ %entry
; CHECK-BE-NEXT:    ror r0, r0, r1
; CHECK-BE-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: fshr_and_mask:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    rors r0, r1
; CHECK-THUMB-NEXT:    bx lr
;
; CHECK-ALIGN-LABEL: fshr_and_mask:
; CHECK-ALIGN:       @ %bb.0: @ %entry
; CHECK-ALIGN-NEXT:    rors r0, r1
; CHECK-ALIGN-NEXT:    bx lr
;
; CHECK-V6M-LABEL: fshr_and_mask:
; CHECK-V6M:       @ %bb.0: @ %entry
; CHECK-V6M-NEXT:    rors r0, r1
; CHECK-V6M-NEXT:    bx lr
entry:
  %sa = and i32 %amt, 31
  %r  = call i32 @llvm.fshr.i32(i32 %x, i32 %x, i32 %sa)
  ret i32 %r
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK-COMMON: {{.*}}
