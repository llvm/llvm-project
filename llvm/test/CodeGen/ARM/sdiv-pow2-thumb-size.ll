; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=thumbv8 %s -o -       | FileCheck %s --check-prefixes=CHECK,T2
; RUN: llc -mtriple=thumbv8m.main %s -o - | FileCheck %s --check-prefixes=CHECK,T2
; RUN: llc -mtriple=thumbv8m.base %s -o - | FileCheck %s --check-prefixes=CHECK,T1
; RUN: llc -mtriple=thumbv7em %s -o -     | FileCheck %s --check-prefixes=CHECK,T2
; RUN: llc -mtriple=thumbv6m %s -o -      | FileCheck %s --check-prefixes=V6M

; Armv6m targets don't have a sdiv instruction, so sdiv should not appear at
; all in the output:

; V6M: .file {{.*}}
; V6M-NOT:  sdiv
; V6M-NOT:  idiv

; Test sdiv i16
define dso_local signext i16 @f0(i16 signext %F) local_unnamed_addr #0 {
; CHECK-LABEL: f0:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    movs r1, #2
; CHECK-NEXT:    sdiv r0, r0, r1
; CHECK-NEXT:    sxth r0, r0
; CHECK-NEXT:    bx lr
;
; V6M-LABEL: f0:
; V6M:       @ %bb.0: @ %entry
; V6M-NEXT:    uxth r1, r0
; V6M-NEXT:    lsrs r1, r1, #15
; V6M-NEXT:    adds r0, r0, r1
; V6M-NEXT:    sxth r0, r0
; V6M-NEXT:    asrs r0, r0, #1
; V6M-NEXT:    bx lr

entry:
  %0 = sdiv i16 %F, 2
  ret i16 %0
}

; Same as above, but now with i32
define dso_local i32 @f1(i32 %F) local_unnamed_addr #0 {
; CHECK-LABEL: f1:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    movs r1, #4
; CHECK-NEXT:    sdiv r0, r0, r1
; CHECK-NEXT:    bx lr
;
; V6M-LABEL: f1:
; V6M:       @ %bb.0: @ %entry
; V6M-NEXT:    asrs r1, r0, #31
; V6M-NEXT:    lsrs r1, r1, #30
; V6M-NEXT:    adds r0, r0, r1
; V6M-NEXT:    asrs r0, r0, #2
; V6M-NEXT:    bx lr

entry:
  %div = sdiv i32 %F, 4
  ret i32 %div
}

; The immediate is not a power of 2, so we expect a sdiv.
define dso_local i32 @f2(i32 %F) local_unnamed_addr #0 {
; CHECK-LABEL: f2:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    movs r1, #5
; CHECK-NEXT:    sdiv r0, r0, r1
; CHECK-NEXT:    bx lr
;
; V6M-LABEL: f2:
; V6M:       @ %bb.0: @ %entry
; V6M-NEXT:    push {r7, lr}
; V6M-NEXT:    movs r1, #5
; V6M-NEXT:    bl __divsi3
; V6M-NEXT:    pop {r7, pc}

entry:
  %div = sdiv i32 %F, 5
  ret i32 %div
}

; Try a larger power of 2 immediate: immediates larger than
; 128 don't give any code size savings.
define dso_local i32 @f3(i32 %F) local_unnamed_addr #0 {
; T2-LABEL: f3:
; T2:       @ %bb.0: @ %entry
; T2-NEXT:    asrs r1, r0, #31
; T2-NEXT:    add.w r0, r0, r1, lsr #24
; T2-NEXT:    asrs r0, r0, #8
; T2-NEXT:    bx lr
;
; T1-LABEL: f3:
; T1:       @ %bb.0: @ %entry
; T1-NEXT:    asrs r1, r0, #31
; T1-NEXT:    lsrs r1, r1, #24
; T1-NEXT:    adds r0, r0, r1
; T1-NEXT:    asrs r0, r0, #8
; T1-NEXT:    bx lr
;
; V6M-LABEL: f3:
; V6M:       @ %bb.0: @ %entry
; V6M-NEXT:    asrs r1, r0, #31
; V6M-NEXT:    lsrs r1, r1, #24
; V6M-NEXT:    adds r0, r0, r1
; V6M-NEXT:    asrs r0, r0, #8
; V6M-NEXT:    bx lr
entry:
  %div = sdiv i32 %F, 256
  ret i32 %div
}

attributes #0 = { minsize norecurse nounwind optsize readnone }


; These functions don't have the minsize attribute set, so should not lower
; the sdiv to sdiv, but to the faster instruction sequence.

define dso_local signext i16 @f4(i16 signext %F) {
; T2-LABEL: f4:
; T2:       @ %bb.0: @ %entry
; T2-NEXT:    and r1, r0, #32768
; T2-NEXT:    add.w r0, r0, r1, lsr #15
; T2-NEXT:    sxth r0, r0
; T2-NEXT:    asrs r0, r0, #1
; T2-NEXT:    bx lr
;
; T1-LABEL: f4:
; T1:       @ %bb.0: @ %entry
; T1-NEXT:    uxth r1, r0
; T1-NEXT:    lsrs r1, r1, #15
; T1-NEXT:    adds r0, r0, r1
; T1-NEXT:    sxth r0, r0
; T1-NEXT:    asrs r0, r0, #1
; T1-NEXT:    bx lr
;
; V6M-LABEL: f4:
; V6M:       @ %bb.0: @ %entry
; V6M-NEXT:    uxth r1, r0
; V6M-NEXT:    lsrs r1, r1, #15
; V6M-NEXT:    adds r0, r0, r1
; V6M-NEXT:    sxth r0, r0
; V6M-NEXT:    asrs r0, r0, #1
; V6M-NEXT:    bx lr


entry:
  %0 = sdiv i16 %F, 2
  ret i16 %0
}

define dso_local i32 @f5(i32 %F) {
; T2-LABEL: f5:
; T2:       @ %bb.0: @ %entry
; T2-NEXT:    asrs r1, r0, #31
; T2-NEXT:    add.w r0, r0, r1, lsr #30
; T2-NEXT:    asrs r0, r0, #2
; T2-NEXT:    bx lr
;
; T1-LABEL: f5:
; T1:       @ %bb.0: @ %entry
; T1-NEXT:    asrs r1, r0, #31
; T1-NEXT:    lsrs r1, r1, #30
; T1-NEXT:    adds r0, r0, r1
; T1-NEXT:    asrs r0, r0, #2
; T1-NEXT:    bx lr
;
; V6M-LABEL: f5:
; V6M:       @ %bb.0: @ %entry
; V6M-NEXT:    asrs r1, r0, #31
; V6M-NEXT:    lsrs r1, r1, #30
; V6M-NEXT:    adds r0, r0, r1
; V6M-NEXT:    asrs r0, r0, #2
; V6M-NEXT:    bx lr


entry:
  %div = sdiv i32 %F, 4
  ret i32 %div
}
