; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=arm-eabi -mattr=+v4t %s -o - | FileCheck %s  --check-prefixes=CHECK,CHECK-ARM
; RUN: llc -mtriple=thumbv6m-none-eabi %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-THUMB

;; Integer absolute value, should produce something as good as: ARM:
;;   movs r0, r0
;;   rsbmi r0, r0, #0
;;   bx lr

define i32 @test(i32 %a) {
; CHECK-ARM-LABEL: test:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    cmp r0, #0
; CHECK-ARM-NEXT:    rsbmi r0, r0, #0
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    asrs r1, r0, #31
; CHECK-THUMB-NEXT:    eors r0, r1
; CHECK-THUMB-NEXT:    subs r0, r0, r1
; CHECK-THUMB-NEXT:    bx lr
  %tmp1neg = sub i32 0, %a
  %b = icmp sgt i32 %a, -1
  %abs = select i1 %b, i32 %a, i32 %tmp1neg
  ret i32 %abs
}

; rdar://11633193
;; 3 instructions will be generated for abs(a-b):
;;   subs
;;   rsbmi
;;   bx
define i32 @test2(i32 %a, i32 %b) nounwind readnone ssp {
; CHECK-ARM-LABEL: test2:
; CHECK-ARM:       @ %bb.0: @ %entry
; CHECK-ARM-NEXT:    subs r0, r0, r1
; CHECK-ARM-NEXT:    rsblt r0, r0, #0
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test2:
; CHECK-THUMB:       @ %bb.0: @ %entry
; CHECK-THUMB-NEXT:    subs r0, r0, r1
; CHECK-THUMB-NEXT:    asrs r1, r0, #31
; CHECK-THUMB-NEXT:    eors r0, r1
; CHECK-THUMB-NEXT:    subs r0, r0, r1
; CHECK-THUMB-NEXT:    bx lr
entry:
  %sub = sub nsw i32 %a, %b
  %cmp = icmp sgt i32 %sub, -1
  %sub1 = sub nsw i32 0, %sub
  %cond = select i1 %cmp, i32 %sub, i32 %sub1
  ret i32 %cond
}

define i64 @test3(i64 %a) {
; CHECK-ARM-LABEL: test3:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    eor r0, r0, r1, asr #31
; CHECK-ARM-NEXT:    eor r2, r1, r1, asr #31
; CHECK-ARM-NEXT:    subs r0, r0, r1, asr #31
; CHECK-ARM-NEXT:    sbc r1, r2, r1, asr #31
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test3:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    asrs r2, r1, #31
; CHECK-THUMB-NEXT:    eors r1, r2
; CHECK-THUMB-NEXT:    eors r0, r2
; CHECK-THUMB-NEXT:    subs r0, r0, r2
; CHECK-THUMB-NEXT:    sbcs r1, r2
; CHECK-THUMB-NEXT:    bx lr
  %tmp1neg = sub i64 0, %a
  %b = icmp sgt i64 %a, -1
  %abs = select i1 %b, i64 %a, i64 %tmp1neg
  ret i64 %abs
}

declare void @callee(...)

define void @testcallframe(i32 %a) {
; CHECK-ARM-LABEL: testcallframe:
; CHECK-ARM:       @ %bb.0: @ %bb
; CHECK-ARM-NEXT:    .save {r11, lr}
; CHECK-ARM-NEXT:    push {r11, lr}
; CHECK-ARM-NEXT:    .pad #8
; CHECK-ARM-NEXT:    sub sp, sp, #8
; CHECK-ARM-NEXT:    cmp r0, #0
; CHECK-ARM-NEXT:    mov r1, #0
; CHECK-ARM-NEXT:    rsbmi r0, r0, #0
; CHECK-ARM-NEXT:    mov r2, #0
; CHECK-ARM-NEXT:    mov r3, #0
; CHECK-ARM-NEXT:    str r1, [sp]
; CHECK-ARM-NEXT:    bl callee
; CHECK-ARM-NEXT:    add sp, sp, #8
; CHECK-ARM-NEXT:    pop {r11, lr}
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: testcallframe:
; CHECK-THUMB:       @ %bb.0: @ %bb
; CHECK-THUMB-NEXT:    .save {r7, lr}
; CHECK-THUMB-NEXT:    push {r7, lr}
; CHECK-THUMB-NEXT:    .pad #8
; CHECK-THUMB-NEXT:    sub sp, #8
; CHECK-THUMB-NEXT:    movs r1, #0
; CHECK-THUMB-NEXT:    str r1, [sp]
; CHECK-THUMB-NEXT:    asrs r2, r0, #31
; CHECK-THUMB-NEXT:    eors r0, r2
; CHECK-THUMB-NEXT:    subs r0, r0, r2
; CHECK-THUMB-NEXT:    mov r2, r1
; CHECK-THUMB-NEXT:    mov r3, r1
; CHECK-THUMB-NEXT:    bl callee
; CHECK-THUMB-NEXT:    add sp, #8
; CHECK-THUMB-NEXT:    pop {r7, pc}
bb:
  %i = tail call i32 @llvm.abs.i32(i32 %a, i1 false)
  tail call void @callee(i32 %i, i32 0, i32 0, i32 0, i32 0)
  ret void
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
