; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=armv7-none-eabi -O0 | FileCheck %s --check-prefix=CHECK --check-prefix=LE
; RUN: llc < %s -mtriple=armv7eb-none-eabi -O0 | FileCheck %s --check-prefix=CHECK --check-prefix=BE

;; Previously, this failed during register allocation because the CMP_SWAP_64
;; pseudo-instruction has a lot of operands, many of which need to be even-odd
;; register pairs, and the over-aligned alloca in this function causes both a
;; frame pointer and a base pointer to be needed.

define void @test(ptr %ptr) {
; CHECK-LABEL: test:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r4, r5, r6, r8, r9, r10, r11, lr}
; CHECK-NEXT:    push {r4, r5, r6, r8, r9, r10, r11, lr}
; CHECK-NEXT:    .setfp r11, sp, #24
; CHECK-NEXT:    add r11, sp, #24
; CHECK-NEXT:    .pad #32
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    bfc sp, #0, #4
; CHECK-NEXT:    mov r6, sp
; CHECK-NEXT:    str r0, [r6, #28] @ 4-byte Spill
; CHECK-NEXT:    b .LBB0_1
; CHECK-NEXT:  .LBB0_1: @ %block1
; CHECK-NEXT:    ldr r0, [r6, #28] @ 4-byte Reload
; CHECK-NEXT:    mov r1, sp
; CHECK-NEXT:    sub r1, r1, #16
; CHECK-NEXT:    bic r1, r1, #15
; CHECK-NEXT:    mov sp, r1
; CHECK-NEXT:    dmb ish
; CHECK-NEXT:    ldr r1, [r0]
; CHECK-NEXT:    ldr r0, [r0, #4]
; CHECK-NEXT:    str r1, [r6, #20] @ 4-byte Spill
; CHECK-NEXT:    str r0, [r6, #24] @ 4-byte Spill
; CHECK-NEXT:    b .LBB0_2
; CHECK-NEXT:  .LBB0_2: @ %atomicrmw.start
; CHECK-NEXT:    @ =>This Loop Header: Depth=1
; CHECK-NEXT:    @ Child Loop BB0_3 Depth 2
; CHECK-NEXT:    ldr r2, [r6, #24] @ 4-byte Reload
; CHECK-NEXT:    ldr r0, [r6, #20] @ 4-byte Reload
; CHECK-NEXT:    ldr r8, [r6, #28] @ 4-byte Reload
; LE-NEXT:       str r2, [r6, #16] @ 4-byte Spill
; LE-NEXT:       str r0, [r6, #12] @ 4-byte Spill
; BE-NEXT:       str r2, [r6, #12] @ 4-byte Spill
; BE-NEXT:       str r0, [r6, #16] @ 4-byte Spill
; CHECK-NEXT:    @ implicit-def: $r1
; CHECK-NEXT:    @ implicit-def: $r3
; CHECK-NEXT:    @ kill: def $r8 killed $r8 def $r8_r9
; CHECK-NEXT:    mov r9, r1
; CHECK-NEXT:    @ kill: def $r0 killed $r0 def $r0_r1
; CHECK-NEXT:    mov r1, r2
; CHECK-NEXT:    mov r12, #0
; CHECK-NEXT:    mov r2, r12
; CHECK-NEXT:    mov r3, r12
; CHECK-NEXT:  .LBB0_3: @ %atomicrmw.start
; CHECK-NEXT:    @ Parent Loop BB0_2 Depth=1
; CHECK-NEXT:    @ => This Inner Loop Header: Depth=2
; CHECK-NEXT:    ldrexd r4, r5, [r8]
; CHECK-NEXT:    cmp r4, r0
; CHECK-NEXT:    cmpeq r5, r1
; CHECK-NEXT:    bne .LBB0_5
; CHECK-NEXT:  @ %bb.4: @ %atomicrmw.start
; CHECK-NEXT:    @ in Loop: Header=BB0_3 Depth=2
; CHECK-NEXT:    strexd r9, r2, r3, [r8]
; CHECK-NEXT:    cmp r9, #0
; CHECK-NEXT:    bne .LBB0_3
; CHECK-NEXT:  .LBB0_5: @ %atomicrmw.start
; CHECK-NEXT:    @ in Loop: Header=BB0_2 Depth=1
; CHECK-NEXT:    ldr r2, [r6, #12] @ 4-byte Reload
; LE-NEXT:       ldr r1, [r6, #16] @ 4-byte Reload
; LE-NEXT:       mov r0, r5
; LE-NEXT:       eor r3, r0, r1
; LE-NEXT:       mov r1, r4
; LE-NEXT:       eor r2, r1, r2
; BE-NEXT:       ldr r0, [r6, #16] @ 4-byte Reload
; BE-NEXT:       mov     r1, r4
; BE-NEXT:       eor     r3, r1, r0
; BE-NEXT:       mov r0, r5
; BE-NEXT:       eor     r2, r0, r2
; CHECK-NEXT:    orr r2, r2, r3
; CHECK-NEXT:    cmp r2, #0
; CHECK-NEXT:    str r1, [r6, #20] @ 4-byte Spill
; CHECK-NEXT:    str r0, [r6, #24] @ 4-byte Spill
; CHECK-NEXT:    bne .LBB0_2
; CHECK-NEXT:    b .LBB0_6
; CHECK-NEXT:  .LBB0_6: @ %atomicrmw.end
; CHECK-NEXT:    dmb ish
; CHECK-NEXT:    sub sp, r11, #24
; CHECK-NEXT:    pop {r4, r5, r6, r8, r9, r10, r11, pc}
entry:
  br label %block1

block1:
  %stuff = alloca i8, i64 16, align 16
  store atomic i64 0, ptr %ptr seq_cst, align 8
  ret void
}
