; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=armv8-none-linux-gnu -verify-machineinstrs < %s | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-LE --check-prefix=CHECK-ARM --check-prefix=CHECK-ARM-LE
; RUN: llc -mtriple=armebv8-none-linux-gnu -verify-machineinstrs < %s | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-BE --check-prefix=CHECK-ARM --check-prefix=CHECK-ARM-BE
; RUN: llc -mtriple=thumbv8-none-linux-gnu -verify-machineinstrs < %s | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-LE --check-prefix=CHECK-THUMB --check-prefix=CHECK-THUMB-LE
; RUN: llc -mtriple=thumbebv8-none-linux-gnu -verify-machineinstrs < %s | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-BE --check-prefix=CHECK-THUMB --check-prefix=CHECK-THUMB-BE

@var8 = global i8 0
@var16 = global i16 0
@var32 = global i32 0
@var64 = global i64 0

define i8 @test_atomic_load_add_i8(i8 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_add_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB0_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexb r1, [r12]
; CHECK-ARM-NEXT:    add r3, r1, r0
; CHECK-ARM-NEXT:    stlexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB0_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_add_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB0_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexb r1, [r12]
; CHECK-THUMB-NEXT:    adds r3, r1, r0
; CHECK-THUMB-NEXT:    stlexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB0_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw add ptr @var8, i8 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i8 %old
}

define i16 @test_atomic_load_add_i16(i16 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_add_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB1_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexh r1, [r12]
; CHECK-ARM-NEXT:    add r3, r1, r0
; CHECK-ARM-NEXT:    strexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB1_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_add_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB1_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexh r1, [r12]
; CHECK-THUMB-NEXT:    adds r3, r1, r0
; CHECK-THUMB-NEXT:    strexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB1_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw add ptr @var16, i16 %offset acquire

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i16 %old
}

define i32 @test_atomic_load_add_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_add_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB2_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrex r1, [r12]
; CHECK-ARM-NEXT:    add r3, r1, r0
; CHECK-ARM-NEXT:    stlex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB2_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_add_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB2_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrex r1, [r12]
; CHECK-THUMB-NEXT:    adds r3, r1, r0
; CHECK-THUMB-NEXT:    stlex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB2_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw add ptr @var32, i32 %offset release

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i32 %old
}

define void @test_atomic_load_add_i64(i64 %offset) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_load_add_i64:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-LE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-LE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-LE-NEXT:  .LBB3_1: @ %atomicrmw.start
; CHECK-ARM-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-LE-NEXT:    ldrexd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    adds r4, r6, r0
; CHECK-ARM-LE-NEXT:    adc r5, r7, r1
; CHECK-ARM-LE-NEXT:    strexd r2, r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    cmp r2, #0
; CHECK-ARM-LE-NEXT:    bne .LBB3_1
; CHECK-ARM-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-LE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-ARM-BE-LABEL: test_atomic_load_add_i64:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-BE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-BE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-BE-NEXT:  .LBB3_1: @ %atomicrmw.start
; CHECK-ARM-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-BE-NEXT:    ldrexd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    adds r5, r7, r1
; CHECK-ARM-BE-NEXT:    adc r4, r6, r0
; CHECK-ARM-BE-NEXT:    strexd r2, r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    cmp r2, #0
; CHECK-ARM-BE-NEXT:    bne .LBB3_1
; CHECK-ARM-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-BE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LE-LABEL: test_atomic_load_add_i64:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-LE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-LE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-LE-NEXT:  .LBB3_1: @ %atomicrmw.start
; CHECK-THUMB-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-LE-NEXT:    ldrexd r3, r2, [r12]
; CHECK-THUMB-LE-NEXT:    adds.w lr, r3, r0
; CHECK-THUMB-LE-NEXT:    adc.w r4, r2, r1
; CHECK-THUMB-LE-NEXT:    strexd r5, lr, r4, [r12]
; CHECK-THUMB-LE-NEXT:    cmp r5, #0
; CHECK-THUMB-LE-NEXT:    bne .LBB3_1
; CHECK-THUMB-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-LE-NEXT:    strd r3, r2, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r7, pc}
;
; CHECK-THUMB-BE-LABEL: test_atomic_load_add_i64:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-BE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-BE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-BE-NEXT:  .LBB3_1: @ %atomicrmw.start
; CHECK-THUMB-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-BE-NEXT:    ldrexd r3, r2, [r12]
; CHECK-THUMB-BE-NEXT:    adds.w lr, r2, r1
; CHECK-THUMB-BE-NEXT:    adc.w r4, r3, r0
; CHECK-THUMB-BE-NEXT:    strexd r5, r4, lr, [r12]
; CHECK-THUMB-BE-NEXT:    cmp r5, #0
; CHECK-THUMB-BE-NEXT:    bne .LBB3_1
; CHECK-THUMB-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-BE-NEXT:    strd r3, r2, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw add ptr @var64, i64 %offset monotonic

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

  store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_sub_i8(i8 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_sub_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB4_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexb r1, [r12]
; CHECK-ARM-NEXT:    sub r3, r1, r0
; CHECK-ARM-NEXT:    strexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB4_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_sub_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB4_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexb r1, [r12]
; CHECK-THUMB-NEXT:    subs r3, r1, r0
; CHECK-THUMB-NEXT:    strexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB4_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw sub ptr @var8, i8 %offset monotonic

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i8 %old
}

define i16 @test_atomic_load_sub_i16(i16 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_sub_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB5_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexh r1, [r12]
; CHECK-ARM-NEXT:    sub r3, r1, r0
; CHECK-ARM-NEXT:    stlexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB5_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_sub_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB5_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexh r1, [r12]
; CHECK-THUMB-NEXT:    subs r3, r1, r0
; CHECK-THUMB-NEXT:    stlexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB5_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw sub ptr @var16, i16 %offset release

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i16 %old
}

define i32 @test_atomic_load_sub_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_sub_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB6_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaex r1, [r12]
; CHECK-ARM-NEXT:    sub r3, r1, r0
; CHECK-ARM-NEXT:    strex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB6_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_sub_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB6_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaex r1, [r12]
; CHECK-THUMB-NEXT:    subs r3, r1, r0
; CHECK-THUMB-NEXT:    strex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB6_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw sub ptr @var32, i32 %offset acquire

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i32 %old
}

define void @test_atomic_load_sub_i64(i64 %offset) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_load_sub_i64:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-LE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-LE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-LE-NEXT:  .LBB7_1: @ %atomicrmw.start
; CHECK-ARM-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-LE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    subs r4, r6, r0
; CHECK-ARM-LE-NEXT:    sbc r5, r7, r1
; CHECK-ARM-LE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    cmp r2, #0
; CHECK-ARM-LE-NEXT:    bne .LBB7_1
; CHECK-ARM-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-LE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-ARM-BE-LABEL: test_atomic_load_sub_i64:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-BE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-BE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-BE-NEXT:  .LBB7_1: @ %atomicrmw.start
; CHECK-ARM-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-BE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    subs r5, r7, r1
; CHECK-ARM-BE-NEXT:    sbc r4, r6, r0
; CHECK-ARM-BE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    cmp r2, #0
; CHECK-ARM-BE-NEXT:    bne .LBB7_1
; CHECK-ARM-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-BE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LE-LABEL: test_atomic_load_sub_i64:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-LE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-LE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-LE-NEXT:  .LBB7_1: @ %atomicrmw.start
; CHECK-THUMB-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-LE-NEXT:    ldaexd r3, r2, [r12]
; CHECK-THUMB-LE-NEXT:    subs.w lr, r3, r0
; CHECK-THUMB-LE-NEXT:    sbc.w r4, r2, r1
; CHECK-THUMB-LE-NEXT:    stlexd r5, lr, r4, [r12]
; CHECK-THUMB-LE-NEXT:    cmp r5, #0
; CHECK-THUMB-LE-NEXT:    bne .LBB7_1
; CHECK-THUMB-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-LE-NEXT:    strd r3, r2, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r7, pc}
;
; CHECK-THUMB-BE-LABEL: test_atomic_load_sub_i64:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-BE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-BE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-BE-NEXT:  .LBB7_1: @ %atomicrmw.start
; CHECK-THUMB-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-BE-NEXT:    ldaexd r3, r2, [r12]
; CHECK-THUMB-BE-NEXT:    subs.w lr, r2, r1
; CHECK-THUMB-BE-NEXT:    sbc.w r4, r3, r0
; CHECK-THUMB-BE-NEXT:    stlexd r5, r4, lr, [r12]
; CHECK-THUMB-BE-NEXT:    cmp r5, #0
; CHECK-THUMB-BE-NEXT:    bne .LBB7_1
; CHECK-THUMB-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-BE-NEXT:    strd r3, r2, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw sub ptr @var64, i64 %offset seq_cst

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_and_i8(i8 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_and_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB8_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexb r1, [r12]
; CHECK-ARM-NEXT:    and r3, r1, r0
; CHECK-ARM-NEXT:    stlexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB8_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_and_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB8_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexb r1, [r12]
; CHECK-THUMB-NEXT:    and.w r3, r1, r0
; CHECK-THUMB-NEXT:    stlexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB8_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw and ptr @var8, i8 %offset release

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i8 %old
}

define i16 @test_atomic_load_and_i16(i16 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_and_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB9_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexh r1, [r12]
; CHECK-ARM-NEXT:    and r3, r1, r0
; CHECK-ARM-NEXT:    strexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB9_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_and_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB9_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexh r1, [r12]
; CHECK-THUMB-NEXT:    and.w r3, r1, r0
; CHECK-THUMB-NEXT:    strexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB9_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw and ptr @var16, i16 %offset monotonic

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i16 %old
}

define i32 @test_atomic_load_and_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_and_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB10_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaex r1, [r12]
; CHECK-ARM-NEXT:    and r3, r1, r0
; CHECK-ARM-NEXT:    stlex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB10_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_and_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB10_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaex r1, [r12]
; CHECK-THUMB-NEXT:    and.w r3, r1, r0
; CHECK-THUMB-NEXT:    stlex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB10_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw and ptr @var32, i32 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i32 %old
}

define void @test_atomic_load_and_i64(i64 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_and_i64:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-NEXT:  .LBB11_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-NEXT:    and r5, r7, r1
; CHECK-ARM-NEXT:    and r4, r6, r0
; CHECK-ARM-NEXT:    strexd r2, r4, r5, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB11_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LABEL: test_atomic_load_and_i64:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-NEXT:  .LBB11_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexd r3, r2, [r12]
; CHECK-THUMB-NEXT:    and.w lr, r2, r1
; CHECK-THUMB-NEXT:    and.w r4, r3, r0
; CHECK-THUMB-NEXT:    strexd r5, r4, lr, [r12]
; CHECK-THUMB-NEXT:    cmp r5, #0
; CHECK-THUMB-NEXT:    bne .LBB11_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    strd r3, r2, [r12]
; CHECK-THUMB-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw and ptr @var64, i64 %offset acquire

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_or_i8(i8 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_or_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB12_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexb r1, [r12]
; CHECK-ARM-NEXT:    orr r3, r1, r0
; CHECK-ARM-NEXT:    stlexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB12_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_or_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB12_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexb r1, [r12]
; CHECK-THUMB-NEXT:    orr.w r3, r1, r0
; CHECK-THUMB-NEXT:    stlexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB12_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw or ptr @var8, i8 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i8 %old
}

define i16 @test_atomic_load_or_i16(i16 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_or_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB13_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexh r1, [r12]
; CHECK-ARM-NEXT:    orr r3, r1, r0
; CHECK-ARM-NEXT:    strexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB13_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_or_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB13_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexh r1, [r12]
; CHECK-THUMB-NEXT:    orr.w r3, r1, r0
; CHECK-THUMB-NEXT:    strexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB13_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw or ptr @var16, i16 %offset monotonic

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i16 %old
}

define i32 @test_atomic_load_or_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_or_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB14_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaex r1, [r12]
; CHECK-ARM-NEXT:    orr r3, r1, r0
; CHECK-ARM-NEXT:    strex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB14_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_or_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB14_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaex r1, [r12]
; CHECK-THUMB-NEXT:    orr.w r3, r1, r0
; CHECK-THUMB-NEXT:    strex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB14_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw or ptr @var32, i32 %offset acquire

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i32 %old
}

define void @test_atomic_load_or_i64(i64 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_or_i64:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-NEXT:  .LBB15_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexd r6, r7, [r12]
; CHECK-ARM-NEXT:    orr r5, r7, r1
; CHECK-ARM-NEXT:    orr r4, r6, r0
; CHECK-ARM-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB15_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LABEL: test_atomic_load_or_i64:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-NEXT:  .LBB15_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexd r3, r2, [r12]
; CHECK-THUMB-NEXT:    orr.w lr, r2, r1
; CHECK-THUMB-NEXT:    orr.w r4, r3, r0
; CHECK-THUMB-NEXT:    stlexd r5, r4, lr, [r12]
; CHECK-THUMB-NEXT:    cmp r5, #0
; CHECK-THUMB-NEXT:    bne .LBB15_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    strd r3, r2, [r12]
; CHECK-THUMB-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw or ptr @var64, i64 %offset release

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_xor_i8(i8 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_xor_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB16_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexb r1, [r12]
; CHECK-ARM-NEXT:    eor r3, r1, r0
; CHECK-ARM-NEXT:    strexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB16_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_xor_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB16_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexb r1, [r12]
; CHECK-THUMB-NEXT:    eor.w r3, r1, r0
; CHECK-THUMB-NEXT:    strexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB16_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw xor ptr @var8, i8 %offset acquire

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i8 %old
}

define i16 @test_atomic_load_xor_i16(i16 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_xor_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB17_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexh r1, [r12]
; CHECK-ARM-NEXT:    eor r3, r1, r0
; CHECK-ARM-NEXT:    stlexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB17_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_xor_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB17_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexh r1, [r12]
; CHECK-THUMB-NEXT:    eor.w r3, r1, r0
; CHECK-THUMB-NEXT:    stlexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB17_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw xor ptr @var16, i16 %offset release

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i16 %old
}

define i32 @test_atomic_load_xor_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_xor_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB18_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaex r1, [r12]
; CHECK-ARM-NEXT:    eor r3, r1, r0
; CHECK-ARM-NEXT:    stlex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB18_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_xor_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB18_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaex r1, [r12]
; CHECK-THUMB-NEXT:    eor.w r3, r1, r0
; CHECK-THUMB-NEXT:    stlex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB18_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw xor ptr @var32, i32 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i32 %old
}

define void @test_atomic_load_xor_i64(i64 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_xor_i64:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-NEXT:  .LBB19_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexd r6, r7, [r12]
; CHECK-ARM-NEXT:    eor r5, r7, r1
; CHECK-ARM-NEXT:    eor r4, r6, r0
; CHECK-ARM-NEXT:    strexd r2, r4, r5, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB19_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LABEL: test_atomic_load_xor_i64:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-NEXT:  .LBB19_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexd r3, r2, [r12]
; CHECK-THUMB-NEXT:    eor.w lr, r2, r1
; CHECK-THUMB-NEXT:    eor.w r4, r3, r0
; CHECK-THUMB-NEXT:    strexd r5, r4, lr, [r12]
; CHECK-THUMB-NEXT:    cmp r5, #0
; CHECK-THUMB-NEXT:    bne .LBB19_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    strd r3, r2, [r12]
; CHECK-THUMB-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw xor ptr @var64, i64 %offset monotonic

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_xchg_i8(i8 %offset) nounwind {
; CHECK-LABEL: test_atomic_load_xchg_i8:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r2, :lower16:var8
; CHECK-NEXT:    movt r2, :upper16:var8
; CHECK-NEXT:  .LBB20_1: @ %atomicrmw.start
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldrexb r1, [r2]
; CHECK-NEXT:    strexb r3, r0, [r2]
; CHECK-NEXT:    cmp r3, #0
; CHECK-NEXT:    bne .LBB20_1
; CHECK-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-NEXT:    mov r0, r1
; CHECK-NEXT:    bx lr
   %old = atomicrmw xchg ptr @var8, i8 %offset monotonic

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i8 %old
}

define i16 @test_atomic_load_xchg_i16(i16 %offset) nounwind {
; CHECK-LABEL: test_atomic_load_xchg_i16:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r2, :lower16:var16
; CHECK-NEXT:    movt r2, :upper16:var16
; CHECK-NEXT:  .LBB21_1: @ %atomicrmw.start
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldaexh r1, [r2]
; CHECK-NEXT:    stlexh r3, r0, [r2]
; CHECK-NEXT:    cmp r3, #0
; CHECK-NEXT:    bne .LBB21_1
; CHECK-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-NEXT:    mov r0, r1
; CHECK-NEXT:    bx lr
   %old = atomicrmw xchg ptr @var16, i16 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i16 %old
}

define i32 @test_atomic_load_xchg_i32(i32 %offset) nounwind {
; CHECK-LABEL: test_atomic_load_xchg_i32:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r2, :lower16:var32
; CHECK-NEXT:    movt r2, :upper16:var32
; CHECK-NEXT:  .LBB22_1: @ %atomicrmw.start
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldrex r1, [r2]
; CHECK-NEXT:    stlex r3, r0, [r2]
; CHECK-NEXT:    cmp r3, #0
; CHECK-NEXT:    bne .LBB22_1
; CHECK-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-NEXT:    mov r0, r1
; CHECK-NEXT:    bx lr
   %old = atomicrmw xchg ptr @var32, i32 %offset release

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.

   ret i32 %old
}

define void @test_atomic_load_xchg_i64(i64 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_xchg_i64:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    push {r4, r5, r11, lr}
; CHECK-ARM-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-NEXT:    @ kill: def $r1 killed $r1 killed $r0_r1 def $r0_r1
; CHECK-ARM-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-NEXT:    @ kill: def $r0 killed $r0 killed $r0_r1 def $r0_r1
; CHECK-ARM-NEXT:  .LBB23_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexd r4, r5, [r12]
; CHECK-ARM-NEXT:    strexd r2, r0, r1, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB23_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    strd r4, r5, [r12]
; CHECK-ARM-NEXT:    pop {r4, r5, r11, pc}
;
; CHECK-THUMB-LABEL: test_atomic_load_xchg_i64:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    push {r7, lr}
; CHECK-THUMB-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-NEXT:  .LBB23_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexd r3, lr, [r12]
; CHECK-THUMB-NEXT:    strexd r2, r0, r1, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB23_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-NEXT:    pop {r7, pc}
   %old = atomicrmw xchg ptr @var64, i64 %offset acquire

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_min_i8(i8 signext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_min_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB24_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexb r1, [r12]
; CHECK-ARM-NEXT:    sxtb r3, r1
; CHECK-ARM-NEXT:    cmp r3, r0
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    movle r3, r1
; CHECK-ARM-NEXT:    strexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB24_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_min_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB24_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexb r1, [r12]
; CHECK-THUMB-NEXT:    sxtb r3, r1
; CHECK-THUMB-NEXT:    cmp r3, r0
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    it le
; CHECK-THUMB-NEXT:    movle r3, r1
; CHECK-THUMB-NEXT:    strexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB24_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw min ptr @var8, i8 %offset acquire

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it le

   ret i8 %old
}

define i16 @test_atomic_load_min_i16(i16 signext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_min_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB25_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexh r1, [r12]
; CHECK-ARM-NEXT:    sxth r3, r1
; CHECK-ARM-NEXT:    cmp r3, r0
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    movle r3, r1
; CHECK-ARM-NEXT:    stlexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB25_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_min_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB25_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexh r1, [r12]
; CHECK-THUMB-NEXT:    sxth r3, r1
; CHECK-THUMB-NEXT:    cmp r3, r0
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    it le
; CHECK-THUMB-NEXT:    movle r3, r1
; CHECK-THUMB-NEXT:    stlexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB25_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw min ptr @var16, i16 %offset release

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it le

   ret i16 %old
}

define i32 @test_atomic_load_min_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_min_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB26_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrex r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movle r3, r1
; CHECK-ARM-NEXT:    strex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB26_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_min_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB26_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrex r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it le
; CHECK-THUMB-NEXT:    movle r3, r1
; CHECK-THUMB-NEXT:    strex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB26_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw min ptr @var32, i32 %offset monotonic

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it le

   ret i32 %old
}

define void @test_atomic_load_min_i64(i64 %offset) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_load_min_i64:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-LE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-LE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-LE-NEXT:  .LBB27_1: @ %atomicrmw.start
; CHECK-ARM-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-LE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    subs r5, r0, r6
; CHECK-ARM-LE-NEXT:    sbcs r5, r1, r7
; CHECK-ARM-LE-NEXT:    mov r5, #0
; CHECK-ARM-LE-NEXT:    movwge r5, #1
; CHECK-ARM-LE-NEXT:    cmp r5, #0
; CHECK-ARM-LE-NEXT:    mov r5, r1
; CHECK-ARM-LE-NEXT:    movne r5, r7
; CHECK-ARM-LE-NEXT:    mov r4, r0
; CHECK-ARM-LE-NEXT:    movne r4, r6
; CHECK-ARM-LE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    cmp r2, #0
; CHECK-ARM-LE-NEXT:    bne .LBB27_1
; CHECK-ARM-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-LE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-ARM-BE-LABEL: test_atomic_load_min_i64:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-BE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-BE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-BE-NEXT:  .LBB27_1: @ %atomicrmw.start
; CHECK-ARM-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-BE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    subs r5, r1, r7
; CHECK-ARM-BE-NEXT:    sbcs r5, r0, r6
; CHECK-ARM-BE-NEXT:    mov r5, #0
; CHECK-ARM-BE-NEXT:    movwge r5, #1
; CHECK-ARM-BE-NEXT:    cmp r5, #0
; CHECK-ARM-BE-NEXT:    mov r5, r1
; CHECK-ARM-BE-NEXT:    movne r5, r7
; CHECK-ARM-BE-NEXT:    mov r4, r0
; CHECK-ARM-BE-NEXT:    movne r4, r6
; CHECK-ARM-BE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    cmp r2, #0
; CHECK-ARM-BE-NEXT:    bne .LBB27_1
; CHECK-ARM-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-BE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LE-LABEL: test_atomic_load_min_i64:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-LE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-LE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-LE-NEXT:  .LBB27_1: @ %atomicrmw.start
; CHECK-THUMB-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-LE-NEXT:    ldaexd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    mov r4, r0
; CHECK-THUMB-LE-NEXT:    subs r2, r0, r3
; CHECK-THUMB-LE-NEXT:    sbcs.w r2, r1, lr
; CHECK-THUMB-LE-NEXT:    mov.w r2, #0
; CHECK-THUMB-LE-NEXT:    it ge
; CHECK-THUMB-LE-NEXT:    movge r2, #1
; CHECK-THUMB-LE-NEXT:    cmp r2, #0
; CHECK-THUMB-LE-NEXT:    mov r2, r1
; CHECK-THUMB-LE-NEXT:    itt ne
; CHECK-THUMB-LE-NEXT:    movne r2, lr
; CHECK-THUMB-LE-NEXT:    movne r4, r3
; CHECK-THUMB-LE-NEXT:    stlexd r5, r4, r2, [r12]
; CHECK-THUMB-LE-NEXT:    cmp r5, #0
; CHECK-THUMB-LE-NEXT:    bne .LBB27_1
; CHECK-THUMB-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-LE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r7, pc}
;
; CHECK-THUMB-BE-LABEL: test_atomic_load_min_i64:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-BE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-BE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-BE-NEXT:  .LBB27_1: @ %atomicrmw.start
; CHECK-THUMB-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-BE-NEXT:    ldaexd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    mov r4, r0
; CHECK-THUMB-BE-NEXT:    subs.w r2, r1, lr
; CHECK-THUMB-BE-NEXT:    sbcs.w r2, r0, r3
; CHECK-THUMB-BE-NEXT:    mov.w r2, #0
; CHECK-THUMB-BE-NEXT:    it ge
; CHECK-THUMB-BE-NEXT:    movge r2, #1
; CHECK-THUMB-BE-NEXT:    cmp r2, #0
; CHECK-THUMB-BE-NEXT:    mov r2, r1
; CHECK-THUMB-BE-NEXT:    itt ne
; CHECK-THUMB-BE-NEXT:    movne r2, lr
; CHECK-THUMB-BE-NEXT:    movne r4, r3
; CHECK-THUMB-BE-NEXT:    stlexd r5, r4, r2, [r12]
; CHECK-THUMB-BE-NEXT:    cmp r5, #0
; CHECK-THUMB-BE-NEXT:    bne .LBB27_1
; CHECK-THUMB-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-BE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw min ptr @var64, i64 %offset seq_cst

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_max_i8(i8 signext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_max_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB28_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexb r1, [r12]
; CHECK-ARM-NEXT:    sxtb r3, r1
; CHECK-ARM-NEXT:    cmp r3, r0
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    movgt r3, r1
; CHECK-ARM-NEXT:    stlexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB28_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_max_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB28_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexb r1, [r12]
; CHECK-THUMB-NEXT:    sxtb r3, r1
; CHECK-THUMB-NEXT:    cmp r3, r0
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    it gt
; CHECK-THUMB-NEXT:    movgt r3, r1
; CHECK-THUMB-NEXT:    stlexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB28_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw max ptr @var8, i8 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it gt

   ret i8 %old
}

define i16 @test_atomic_load_max_i16(i16 signext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_max_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB29_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexh r1, [r12]
; CHECK-ARM-NEXT:    sxth r3, r1
; CHECK-ARM-NEXT:    cmp r3, r0
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    movgt r3, r1
; CHECK-ARM-NEXT:    strexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB29_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_max_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB29_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexh r1, [r12]
; CHECK-THUMB-NEXT:    sxth r3, r1
; CHECK-THUMB-NEXT:    cmp r3, r0
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    it gt
; CHECK-THUMB-NEXT:    movgt r3, r1
; CHECK-THUMB-NEXT:    strexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB29_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw max ptr @var16, i16 %offset acquire

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it gt

   ret i16 %old
}

define i32 @test_atomic_load_max_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_max_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB30_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrex r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movgt r3, r1
; CHECK-ARM-NEXT:    stlex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB30_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_max_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB30_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrex r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it gt
; CHECK-THUMB-NEXT:    movgt r3, r1
; CHECK-THUMB-NEXT:    stlex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB30_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw max ptr @var32, i32 %offset release

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it gt

   ret i32 %old
}

define void @test_atomic_load_max_i64(i64 %offset) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_load_max_i64:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-LE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-LE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-LE-NEXT:  .LBB31_1: @ %atomicrmw.start
; CHECK-ARM-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-LE-NEXT:    ldrexd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    subs r5, r0, r6
; CHECK-ARM-LE-NEXT:    sbcs r5, r1, r7
; CHECK-ARM-LE-NEXT:    mov r5, #0
; CHECK-ARM-LE-NEXT:    movwlt r5, #1
; CHECK-ARM-LE-NEXT:    cmp r5, #0
; CHECK-ARM-LE-NEXT:    mov r5, r1
; CHECK-ARM-LE-NEXT:    movne r5, r7
; CHECK-ARM-LE-NEXT:    mov r4, r0
; CHECK-ARM-LE-NEXT:    movne r4, r6
; CHECK-ARM-LE-NEXT:    strexd r2, r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    cmp r2, #0
; CHECK-ARM-LE-NEXT:    bne .LBB31_1
; CHECK-ARM-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-LE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-ARM-BE-LABEL: test_atomic_load_max_i64:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-BE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-BE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-BE-NEXT:  .LBB31_1: @ %atomicrmw.start
; CHECK-ARM-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-BE-NEXT:    ldrexd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    subs r5, r1, r7
; CHECK-ARM-BE-NEXT:    sbcs r5, r0, r6
; CHECK-ARM-BE-NEXT:    mov r5, #0
; CHECK-ARM-BE-NEXT:    movwlt r5, #1
; CHECK-ARM-BE-NEXT:    cmp r5, #0
; CHECK-ARM-BE-NEXT:    mov r5, r1
; CHECK-ARM-BE-NEXT:    movne r5, r7
; CHECK-ARM-BE-NEXT:    mov r4, r0
; CHECK-ARM-BE-NEXT:    movne r4, r6
; CHECK-ARM-BE-NEXT:    strexd r2, r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    cmp r2, #0
; CHECK-ARM-BE-NEXT:    bne .LBB31_1
; CHECK-ARM-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-BE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LE-LABEL: test_atomic_load_max_i64:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-LE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-LE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-LE-NEXT:  .LBB31_1: @ %atomicrmw.start
; CHECK-THUMB-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-LE-NEXT:    ldrexd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    mov r4, r0
; CHECK-THUMB-LE-NEXT:    subs r2, r0, r3
; CHECK-THUMB-LE-NEXT:    sbcs.w r2, r1, lr
; CHECK-THUMB-LE-NEXT:    mov.w r2, #0
; CHECK-THUMB-LE-NEXT:    it lt
; CHECK-THUMB-LE-NEXT:    movlt r2, #1
; CHECK-THUMB-LE-NEXT:    cmp r2, #0
; CHECK-THUMB-LE-NEXT:    mov r2, r1
; CHECK-THUMB-LE-NEXT:    itt ne
; CHECK-THUMB-LE-NEXT:    movne r2, lr
; CHECK-THUMB-LE-NEXT:    movne r4, r3
; CHECK-THUMB-LE-NEXT:    strexd r5, r4, r2, [r12]
; CHECK-THUMB-LE-NEXT:    cmp r5, #0
; CHECK-THUMB-LE-NEXT:    bne .LBB31_1
; CHECK-THUMB-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-LE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r7, pc}
;
; CHECK-THUMB-BE-LABEL: test_atomic_load_max_i64:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-BE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-BE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-BE-NEXT:  .LBB31_1: @ %atomicrmw.start
; CHECK-THUMB-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-BE-NEXT:    ldrexd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    mov r4, r0
; CHECK-THUMB-BE-NEXT:    subs.w r2, r1, lr
; CHECK-THUMB-BE-NEXT:    sbcs.w r2, r0, r3
; CHECK-THUMB-BE-NEXT:    mov.w r2, #0
; CHECK-THUMB-BE-NEXT:    it lt
; CHECK-THUMB-BE-NEXT:    movlt r2, #1
; CHECK-THUMB-BE-NEXT:    cmp r2, #0
; CHECK-THUMB-BE-NEXT:    mov r2, r1
; CHECK-THUMB-BE-NEXT:    itt ne
; CHECK-THUMB-BE-NEXT:    movne r2, lr
; CHECK-THUMB-BE-NEXT:    movne r4, r3
; CHECK-THUMB-BE-NEXT:    strexd r5, r4, r2, [r12]
; CHECK-THUMB-BE-NEXT:    cmp r5, #0
; CHECK-THUMB-BE-NEXT:    bne .LBB31_1
; CHECK-THUMB-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-BE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw max ptr @var64, i64 %offset monotonic

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_umin_i8(i8 zeroext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_umin_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB32_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexb r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movls r3, r1
; CHECK-ARM-NEXT:    strexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB32_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_umin_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB32_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexb r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it ls
; CHECK-THUMB-NEXT:    movls r3, r1
; CHECK-THUMB-NEXT:    strexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB32_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw umin ptr @var8, i8 %offset monotonic

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it ls

   ret i8 %old
}

define i16 @test_atomic_load_umin_i16(i16 zeroext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_umin_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB33_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexh r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movls r3, r1
; CHECK-ARM-NEXT:    strexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB33_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_umin_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB33_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexh r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it ls
; CHECK-THUMB-NEXT:    movls r3, r1
; CHECK-THUMB-NEXT:    strexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB33_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw umin ptr @var16, i16 %offset acquire

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it ls

   ret i16 %old
}

define i32 @test_atomic_load_umin_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_umin_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB34_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaex r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movls r3, r1
; CHECK-ARM-NEXT:    stlex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB34_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_umin_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB34_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaex r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it ls
; CHECK-THUMB-NEXT:    movls r3, r1
; CHECK-THUMB-NEXT:    stlex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB34_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw umin ptr @var32, i32 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it ls

   ret i32 %old
}

define void @test_atomic_load_umin_i64(i64 %offset) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_load_umin_i64:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-LE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-LE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-LE-NEXT:  .LBB35_1: @ %atomicrmw.start
; CHECK-ARM-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-LE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    subs r5, r0, r6
; CHECK-ARM-LE-NEXT:    sbcs r5, r1, r7
; CHECK-ARM-LE-NEXT:    mov r5, #0
; CHECK-ARM-LE-NEXT:    movwhs r5, #1
; CHECK-ARM-LE-NEXT:    cmp r5, #0
; CHECK-ARM-LE-NEXT:    mov r5, r1
; CHECK-ARM-LE-NEXT:    movne r5, r7
; CHECK-ARM-LE-NEXT:    mov r4, r0
; CHECK-ARM-LE-NEXT:    movne r4, r6
; CHECK-ARM-LE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    cmp r2, #0
; CHECK-ARM-LE-NEXT:    bne .LBB35_1
; CHECK-ARM-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-LE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-ARM-BE-LABEL: test_atomic_load_umin_i64:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-BE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-BE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-BE-NEXT:  .LBB35_1: @ %atomicrmw.start
; CHECK-ARM-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-BE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    subs r5, r1, r7
; CHECK-ARM-BE-NEXT:    sbcs r5, r0, r6
; CHECK-ARM-BE-NEXT:    mov r5, #0
; CHECK-ARM-BE-NEXT:    movwhs r5, #1
; CHECK-ARM-BE-NEXT:    cmp r5, #0
; CHECK-ARM-BE-NEXT:    mov r5, r1
; CHECK-ARM-BE-NEXT:    movne r5, r7
; CHECK-ARM-BE-NEXT:    mov r4, r0
; CHECK-ARM-BE-NEXT:    movne r4, r6
; CHECK-ARM-BE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    cmp r2, #0
; CHECK-ARM-BE-NEXT:    bne .LBB35_1
; CHECK-ARM-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-BE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LE-LABEL: test_atomic_load_umin_i64:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-LE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-LE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-LE-NEXT:  .LBB35_1: @ %atomicrmw.start
; CHECK-THUMB-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-LE-NEXT:    ldaexd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    mov r4, r0
; CHECK-THUMB-LE-NEXT:    subs r2, r0, r3
; CHECK-THUMB-LE-NEXT:    sbcs.w r2, r1, lr
; CHECK-THUMB-LE-NEXT:    mov.w r2, #0
; CHECK-THUMB-LE-NEXT:    it hs
; CHECK-THUMB-LE-NEXT:    movhs r2, #1
; CHECK-THUMB-LE-NEXT:    cmp r2, #0
; CHECK-THUMB-LE-NEXT:    mov r2, r1
; CHECK-THUMB-LE-NEXT:    itt ne
; CHECK-THUMB-LE-NEXT:    movne r2, lr
; CHECK-THUMB-LE-NEXT:    movne r4, r3
; CHECK-THUMB-LE-NEXT:    stlexd r5, r4, r2, [r12]
; CHECK-THUMB-LE-NEXT:    cmp r5, #0
; CHECK-THUMB-LE-NEXT:    bne .LBB35_1
; CHECK-THUMB-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-LE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r7, pc}
;
; CHECK-THUMB-BE-LABEL: test_atomic_load_umin_i64:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-BE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-BE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-BE-NEXT:  .LBB35_1: @ %atomicrmw.start
; CHECK-THUMB-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-BE-NEXT:    ldaexd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    mov r4, r0
; CHECK-THUMB-BE-NEXT:    subs.w r2, r1, lr
; CHECK-THUMB-BE-NEXT:    sbcs.w r2, r0, r3
; CHECK-THUMB-BE-NEXT:    mov.w r2, #0
; CHECK-THUMB-BE-NEXT:    it hs
; CHECK-THUMB-BE-NEXT:    movhs r2, #1
; CHECK-THUMB-BE-NEXT:    cmp r2, #0
; CHECK-THUMB-BE-NEXT:    mov r2, r1
; CHECK-THUMB-BE-NEXT:    itt ne
; CHECK-THUMB-BE-NEXT:    movne r2, lr
; CHECK-THUMB-BE-NEXT:    movne r4, r3
; CHECK-THUMB-BE-NEXT:    stlexd r5, r4, r2, [r12]
; CHECK-THUMB-BE-NEXT:    cmp r5, #0
; CHECK-THUMB-BE-NEXT:    bne .LBB35_1
; CHECK-THUMB-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-BE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw umin ptr @var64, i64 %offset seq_cst

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_umax_i8(i8 zeroext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_umax_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB36_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexb r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movhi r3, r1
; CHECK-ARM-NEXT:    stlexb r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB36_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_umax_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB36_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexb r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it hi
; CHECK-THUMB-NEXT:    movhi r3, r1
; CHECK-THUMB-NEXT:    stlexb r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB36_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw umax ptr @var8, i8 %offset acq_rel

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it hi

   ret i8 %old
}

define i16 @test_atomic_load_umax_i16(i16 zeroext %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_umax_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB37_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexh r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movhi r3, r1
; CHECK-ARM-NEXT:    strexh r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB37_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_umax_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB37_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexh r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it hi
; CHECK-THUMB-NEXT:    movhi r3, r1
; CHECK-THUMB-NEXT:    strexh r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB37_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw umax ptr @var16, i16 %offset monotonic

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it hi

   ret i16 %old
}

define i32 @test_atomic_load_umax_i32(i32 %offset) nounwind {
; CHECK-ARM-LABEL: test_atomic_load_umax_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB38_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaex r1, [r12]
; CHECK-ARM-NEXT:    mov r3, r0
; CHECK-ARM-NEXT:    cmp r1, r0
; CHECK-ARM-NEXT:    movhi r3, r1
; CHECK-ARM-NEXT:    stlex r2, r3, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB38_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_load_umax_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB38_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaex r1, [r12]
; CHECK-THUMB-NEXT:    mov r3, r0
; CHECK-THUMB-NEXT:    cmp r1, r0
; CHECK-THUMB-NEXT:    it hi
; CHECK-THUMB-NEXT:    movhi r3, r1
; CHECK-THUMB-NEXT:    stlex r2, r3, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB38_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    mov r0, r1
; CHECK-THUMB-NEXT:    bx lr
   %old = atomicrmw umax ptr @var32, i32 %offset seq_cst

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
; Thumb mode: it hi

   ret i32 %old
}

define void @test_atomic_load_umax_i64(i64 %offset) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_load_umax_i64:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-LE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-LE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-LE-NEXT:  .LBB39_1: @ %atomicrmw.start
; CHECK-ARM-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-LE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    subs r5, r0, r6
; CHECK-ARM-LE-NEXT:    sbcs r5, r1, r7
; CHECK-ARM-LE-NEXT:    mov r5, #0
; CHECK-ARM-LE-NEXT:    movwlo r5, #1
; CHECK-ARM-LE-NEXT:    cmp r5, #0
; CHECK-ARM-LE-NEXT:    mov r5, r1
; CHECK-ARM-LE-NEXT:    movne r5, r7
; CHECK-ARM-LE-NEXT:    mov r4, r0
; CHECK-ARM-LE-NEXT:    movne r4, r6
; CHECK-ARM-LE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    cmp r2, #0
; CHECK-ARM-LE-NEXT:    bne .LBB39_1
; CHECK-ARM-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-LE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-ARM-BE-LABEL: test_atomic_load_umax_i64:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    push {r4, r5, r6, r7, r11, lr}
; CHECK-ARM-BE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-BE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-BE-NEXT:  .LBB39_1: @ %atomicrmw.start
; CHECK-ARM-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-BE-NEXT:    ldaexd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    subs r5, r1, r7
; CHECK-ARM-BE-NEXT:    sbcs r5, r0, r6
; CHECK-ARM-BE-NEXT:    mov r5, #0
; CHECK-ARM-BE-NEXT:    movwlo r5, #1
; CHECK-ARM-BE-NEXT:    cmp r5, #0
; CHECK-ARM-BE-NEXT:    mov r5, r1
; CHECK-ARM-BE-NEXT:    movne r5, r7
; CHECK-ARM-BE-NEXT:    mov r4, r0
; CHECK-ARM-BE-NEXT:    movne r4, r6
; CHECK-ARM-BE-NEXT:    stlexd r2, r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    cmp r2, #0
; CHECK-ARM-BE-NEXT:    bne .LBB39_1
; CHECK-ARM-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-BE-NEXT:    strd r6, r7, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, r7, r11, pc}
;
; CHECK-THUMB-LE-LABEL: test_atomic_load_umax_i64:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-LE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-LE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-LE-NEXT:  .LBB39_1: @ %atomicrmw.start
; CHECK-THUMB-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-LE-NEXT:    ldaexd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    mov r4, r0
; CHECK-THUMB-LE-NEXT:    subs r2, r0, r3
; CHECK-THUMB-LE-NEXT:    sbcs.w r2, r1, lr
; CHECK-THUMB-LE-NEXT:    mov.w r2, #0
; CHECK-THUMB-LE-NEXT:    it lo
; CHECK-THUMB-LE-NEXT:    movlo r2, #1
; CHECK-THUMB-LE-NEXT:    cmp r2, #0
; CHECK-THUMB-LE-NEXT:    mov r2, r1
; CHECK-THUMB-LE-NEXT:    itt ne
; CHECK-THUMB-LE-NEXT:    movne r2, lr
; CHECK-THUMB-LE-NEXT:    movne r4, r3
; CHECK-THUMB-LE-NEXT:    stlexd r5, r4, r2, [r12]
; CHECK-THUMB-LE-NEXT:    cmp r5, #0
; CHECK-THUMB-LE-NEXT:    bne .LBB39_1
; CHECK-THUMB-LE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-LE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r7, pc}
;
; CHECK-THUMB-BE-LABEL: test_atomic_load_umax_i64:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    push {r4, r5, r7, lr}
; CHECK-THUMB-BE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-BE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-BE-NEXT:  .LBB39_1: @ %atomicrmw.start
; CHECK-THUMB-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-BE-NEXT:    ldaexd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    mov r4, r0
; CHECK-THUMB-BE-NEXT:    subs.w r2, r1, lr
; CHECK-THUMB-BE-NEXT:    sbcs.w r2, r0, r3
; CHECK-THUMB-BE-NEXT:    mov.w r2, #0
; CHECK-THUMB-BE-NEXT:    it lo
; CHECK-THUMB-BE-NEXT:    movlo r2, #1
; CHECK-THUMB-BE-NEXT:    cmp r2, #0
; CHECK-THUMB-BE-NEXT:    mov r2, r1
; CHECK-THUMB-BE-NEXT:    itt ne
; CHECK-THUMB-BE-NEXT:    movne r2, lr
; CHECK-THUMB-BE-NEXT:    movne r4, r3
; CHECK-THUMB-BE-NEXT:    stlexd r5, r4, r2, [r12]
; CHECK-THUMB-BE-NEXT:    cmp r5, #0
; CHECK-THUMB-BE-NEXT:    bne .LBB39_1
; CHECK-THUMB-BE-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-BE-NEXT:    strd r3, lr, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r7, pc}
   %old = atomicrmw umax ptr @var64, i64 %offset seq_cst

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_cmpxchg_i8(i8 zeroext %wanted, i8 zeroext %new) nounwind {
; CHECK-ARM-LABEL: test_atomic_cmpxchg_i8:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var8
; CHECK-ARM-NEXT:    movt r12, :upper16:var8
; CHECK-ARM-NEXT:  .LBB40_1: @ %cmpxchg.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexb r2, [r12]
; CHECK-ARM-NEXT:    cmp r2, r0
; CHECK-ARM-NEXT:    bne .LBB40_4
; CHECK-ARM-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-ARM-NEXT:    @ in Loop: Header=BB40_1 Depth=1
; CHECK-ARM-NEXT:    strexb r3, r1, [r12]
; CHECK-ARM-NEXT:    cmp r3, #0
; CHECK-ARM-NEXT:    bne .LBB40_1
; CHECK-ARM-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-ARM-NEXT:    mov r0, r2
; CHECK-ARM-NEXT:    bx lr
; CHECK-ARM-NEXT:  .LBB40_4: @ %cmpxchg.nostore
; CHECK-ARM-NEXT:    clrex
; CHECK-ARM-NEXT:    mov r0, r2
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_cmpxchg_i8:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var8
; CHECK-THUMB-NEXT:    mov r2, r0
; CHECK-THUMB-NEXT:    movt r12, :upper16:var8
; CHECK-THUMB-NEXT:  .LBB40_1: @ %cmpxchg.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexb r0, [r12]
; CHECK-THUMB-NEXT:    cmp r0, r2
; CHECK-THUMB-NEXT:    bne .LBB40_3
; CHECK-THUMB-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-THUMB-NEXT:    @ in Loop: Header=BB40_1 Depth=1
; CHECK-THUMB-NEXT:    strexb r3, r1, [r12]
; CHECK-THUMB-NEXT:    cmp r3, #0
; CHECK-THUMB-NEXT:    it eq
; CHECK-THUMB-NEXT:    bxeq lr
; CHECK-THUMB-NEXT:    b .LBB40_1
; CHECK-THUMB-NEXT:  .LBB40_3: @ %cmpxchg.nostore
; CHECK-THUMB-NEXT:    clrex
; CHECK-THUMB-NEXT:    bx lr
   %pair = cmpxchg ptr @var8, i8 %wanted, i8 %new acquire acquire
   %old = extractvalue { i8, i1 } %pair, 0

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
  ; As above, r1 is a reasonable guess.
   ret i8 %old
}

define i16 @test_atomic_cmpxchg_i16(i16 zeroext %wanted, i16 zeroext %new) nounwind {
; CHECK-ARM-LABEL: test_atomic_cmpxchg_i16:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var16
; CHECK-ARM-NEXT:    movt r12, :upper16:var16
; CHECK-ARM-NEXT:  .LBB41_1: @ %cmpxchg.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldaexh r2, [r12]
; CHECK-ARM-NEXT:    cmp r2, r0
; CHECK-ARM-NEXT:    bne .LBB41_4
; CHECK-ARM-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-ARM-NEXT:    @ in Loop: Header=BB41_1 Depth=1
; CHECK-ARM-NEXT:    stlexh r3, r1, [r12]
; CHECK-ARM-NEXT:    cmp r3, #0
; CHECK-ARM-NEXT:    bne .LBB41_1
; CHECK-ARM-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-ARM-NEXT:    mov r0, r2
; CHECK-ARM-NEXT:    bx lr
; CHECK-ARM-NEXT:  .LBB41_4: @ %cmpxchg.nostore
; CHECK-ARM-NEXT:    clrex
; CHECK-ARM-NEXT:    mov r0, r2
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_cmpxchg_i16:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var16
; CHECK-THUMB-NEXT:    mov r2, r0
; CHECK-THUMB-NEXT:    movt r12, :upper16:var16
; CHECK-THUMB-NEXT:  .LBB41_1: @ %cmpxchg.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldaexh r0, [r12]
; CHECK-THUMB-NEXT:    cmp r0, r2
; CHECK-THUMB-NEXT:    bne .LBB41_3
; CHECK-THUMB-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-THUMB-NEXT:    @ in Loop: Header=BB41_1 Depth=1
; CHECK-THUMB-NEXT:    stlexh r3, r1, [r12]
; CHECK-THUMB-NEXT:    cmp r3, #0
; CHECK-THUMB-NEXT:    it eq
; CHECK-THUMB-NEXT:    bxeq lr
; CHECK-THUMB-NEXT:    b .LBB41_1
; CHECK-THUMB-NEXT:  .LBB41_3: @ %cmpxchg.nostore
; CHECK-THUMB-NEXT:    clrex
; CHECK-THUMB-NEXT:    bx lr
   %pair = cmpxchg ptr @var16, i16 %wanted, i16 %new seq_cst seq_cst
   %old = extractvalue { i16, i1 } %pair, 0

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
  ; As above, r1 is a reasonable guess.

   ret i16 %old
}

define void @test_atomic_cmpxchg_i32(i32 %wanted, i32 %new) nounwind {
; CHECK-ARM-LABEL: test_atomic_cmpxchg_i32:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    movw r12, :lower16:var32
; CHECK-ARM-NEXT:    movt r12, :upper16:var32
; CHECK-ARM-NEXT:  .LBB42_1: @ %cmpxchg.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrex r3, [r12]
; CHECK-ARM-NEXT:    cmp r3, r0
; CHECK-ARM-NEXT:    bne .LBB42_4
; CHECK-ARM-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-ARM-NEXT:    @ in Loop: Header=BB42_1 Depth=1
; CHECK-ARM-NEXT:    stlex r2, r1, [r12]
; CHECK-ARM-NEXT:    cmp r2, #0
; CHECK-ARM-NEXT:    bne .LBB42_1
; CHECK-ARM-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-ARM-NEXT:    str r3, [r12]
; CHECK-ARM-NEXT:    bx lr
; CHECK-ARM-NEXT:  .LBB42_4: @ %cmpxchg.nostore
; CHECK-ARM-NEXT:    clrex
; CHECK-ARM-NEXT:    str r3, [r12]
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: test_atomic_cmpxchg_i32:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var32
; CHECK-THUMB-NEXT:    movt r12, :upper16:var32
; CHECK-THUMB-NEXT:  .LBB42_1: @ %cmpxchg.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrex r3, [r12]
; CHECK-THUMB-NEXT:    cmp r3, r0
; CHECK-THUMB-NEXT:    bne .LBB42_4
; CHECK-THUMB-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-THUMB-NEXT:    @ in Loop: Header=BB42_1 Depth=1
; CHECK-THUMB-NEXT:    stlex r2, r1, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB42_1
; CHECK-THUMB-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-THUMB-NEXT:    str.w r3, [r12]
; CHECK-THUMB-NEXT:    bx lr
; CHECK-THUMB-NEXT:  .LBB42_4: @ %cmpxchg.nostore
; CHECK-THUMB-NEXT:    clrex
; CHECK-THUMB-NEXT:    str.w r3, [r12]
; CHECK-THUMB-NEXT:    bx lr
   %pair = cmpxchg ptr @var32, i32 %wanted, i32 %new release monotonic
   %old = extractvalue { i32, i1 } %pair, 0
   store i32 %old, ptr @var32

  ; r0 below is a reasonable guess but could change: it certainly comes into the
  ;  function there.
  ; As above, r1 is a reasonable guess.

   ret void
}

define void @test_atomic_cmpxchg_i64(i64 %wanted, i64 %new) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_cmpxchg_i64:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    push {r4, r5, r6, lr}
; CHECK-ARM-LE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-LE-NEXT:    @ kill: def $r3 killed $r3 killed $r2_r3 def $r2_r3
; CHECK-ARM-LE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-LE-NEXT:    @ kill: def $r2 killed $r2 killed $r2_r3 def $r2_r3
; CHECK-ARM-LE-NEXT:  .LBB43_1: @ %cmpxchg.start
; CHECK-ARM-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-LE-NEXT:    ldrexd r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    eor lr, r5, r1
; CHECK-ARM-LE-NEXT:    eor r6, r4, r0
; CHECK-ARM-LE-NEXT:    orrs r6, r6, lr
; CHECK-ARM-LE-NEXT:    bne .LBB43_4
; CHECK-ARM-LE-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-ARM-LE-NEXT:    @ in Loop: Header=BB43_1 Depth=1
; CHECK-ARM-LE-NEXT:    strexd r6, r2, r3, [r12]
; CHECK-ARM-LE-NEXT:    cmp r6, #0
; CHECK-ARM-LE-NEXT:    bne .LBB43_1
; CHECK-ARM-LE-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-ARM-LE-NEXT:    strd r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, pc}
; CHECK-ARM-LE-NEXT:  .LBB43_4: @ %cmpxchg.nostore
; CHECK-ARM-LE-NEXT:    clrex
; CHECK-ARM-LE-NEXT:    strd r4, r5, [r12]
; CHECK-ARM-LE-NEXT:    pop {r4, r5, r6, pc}
;
; CHECK-ARM-BE-LABEL: test_atomic_cmpxchg_i64:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    push {r4, r5, r6, lr}
; CHECK-ARM-BE-NEXT:    movw r12, :lower16:var64
; CHECK-ARM-BE-NEXT:    @ kill: def $r3 killed $r3 killed $r2_r3 def $r2_r3
; CHECK-ARM-BE-NEXT:    movt r12, :upper16:var64
; CHECK-ARM-BE-NEXT:    @ kill: def $r2 killed $r2 killed $r2_r3 def $r2_r3
; CHECK-ARM-BE-NEXT:  .LBB43_1: @ %cmpxchg.start
; CHECK-ARM-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-BE-NEXT:    ldrexd r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    eor lr, r4, r0
; CHECK-ARM-BE-NEXT:    eor r6, r5, r1
; CHECK-ARM-BE-NEXT:    orrs r6, r6, lr
; CHECK-ARM-BE-NEXT:    bne .LBB43_4
; CHECK-ARM-BE-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-ARM-BE-NEXT:    @ in Loop: Header=BB43_1 Depth=1
; CHECK-ARM-BE-NEXT:    strexd r6, r2, r3, [r12]
; CHECK-ARM-BE-NEXT:    cmp r6, #0
; CHECK-ARM-BE-NEXT:    bne .LBB43_1
; CHECK-ARM-BE-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-ARM-BE-NEXT:    strd r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, pc}
; CHECK-ARM-BE-NEXT:  .LBB43_4: @ %cmpxchg.nostore
; CHECK-ARM-BE-NEXT:    clrex
; CHECK-ARM-BE-NEXT:    strd r4, r5, [r12]
; CHECK-ARM-BE-NEXT:    pop {r4, r5, r6, pc}
;
; CHECK-THUMB-LE-LABEL: test_atomic_cmpxchg_i64:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    push {r4, r5, r6, lr}
; CHECK-THUMB-LE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-LE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-LE-NEXT:  .LBB43_1: @ %cmpxchg.start
; CHECK-THUMB-LE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-LE-NEXT:    ldrexd lr, r4, [r12]
; CHECK-THUMB-LE-NEXT:    eor.w r5, r4, r1
; CHECK-THUMB-LE-NEXT:    eor.w r6, lr, r0
; CHECK-THUMB-LE-NEXT:    orrs r5, r6
; CHECK-THUMB-LE-NEXT:    bne .LBB43_4
; CHECK-THUMB-LE-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-THUMB-LE-NEXT:    @ in Loop: Header=BB43_1 Depth=1
; CHECK-THUMB-LE-NEXT:    strexd r5, r2, r3, [r12]
; CHECK-THUMB-LE-NEXT:    cmp r5, #0
; CHECK-THUMB-LE-NEXT:    bne .LBB43_1
; CHECK-THUMB-LE-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-THUMB-LE-NEXT:    strd lr, r4, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r6, pc}
; CHECK-THUMB-LE-NEXT:  .LBB43_4: @ %cmpxchg.nostore
; CHECK-THUMB-LE-NEXT:    clrex
; CHECK-THUMB-LE-NEXT:    strd lr, r4, [r12]
; CHECK-THUMB-LE-NEXT:    pop {r4, r5, r6, pc}
;
; CHECK-THUMB-BE-LABEL: test_atomic_cmpxchg_i64:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    push {r4, r5, r6, lr}
; CHECK-THUMB-BE-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-BE-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-BE-NEXT:  .LBB43_1: @ %cmpxchg.start
; CHECK-THUMB-BE-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-BE-NEXT:    ldrexd lr, r4, [r12]
; CHECK-THUMB-BE-NEXT:    eor.w r5, lr, r0
; CHECK-THUMB-BE-NEXT:    eor.w r6, r4, r1
; CHECK-THUMB-BE-NEXT:    orrs r5, r6
; CHECK-THUMB-BE-NEXT:    bne .LBB43_4
; CHECK-THUMB-BE-NEXT:  @ %bb.2: @ %cmpxchg.trystore
; CHECK-THUMB-BE-NEXT:    @ in Loop: Header=BB43_1 Depth=1
; CHECK-THUMB-BE-NEXT:    strexd r5, r2, r3, [r12]
; CHECK-THUMB-BE-NEXT:    cmp r5, #0
; CHECK-THUMB-BE-NEXT:    bne .LBB43_1
; CHECK-THUMB-BE-NEXT:  @ %bb.3: @ %cmpxchg.end
; CHECK-THUMB-BE-NEXT:    strd lr, r4, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r6, pc}
; CHECK-THUMB-BE-NEXT:  .LBB43_4: @ %cmpxchg.nostore
; CHECK-THUMB-BE-NEXT:    clrex
; CHECK-THUMB-BE-NEXT:    strd lr, r4, [r12]
; CHECK-THUMB-BE-NEXT:    pop {r4, r5, r6, pc}
   %pair = cmpxchg ptr @var64, i64 %wanted, i64 %new monotonic monotonic
   %old = extractvalue { i64, i1 } %pair, 0

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.
  ; As above, r2, r3 is a reasonable guess.

   store i64 %old, ptr @var64
   ret void
}

define i8 @test_atomic_load_monotonic_i8() nounwind {
; CHECK-LABEL: test_atomic_load_monotonic_i8:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r0, :lower16:var8
; CHECK-NEXT:    movt r0, :upper16:var8
; CHECK-NEXT:    ldrb r0, [r0]
; CHECK-NEXT:    bx lr
  %val = load atomic i8, ptr @var8 monotonic, align 1

  ret i8 %val
}

define i8 @test_atomic_load_monotonic_regoff_i8(i64 %base, i64 %off) nounwind {
; CHECK-LE-LABEL: test_atomic_load_monotonic_regoff_i8:
; CHECK-LE:       @ %bb.0:
; CHECK-LE-NEXT:    ldrb r0, [r0, r2]
; CHECK-LE-NEXT:    bx lr
;
; CHECK-BE-LABEL: test_atomic_load_monotonic_regoff_i8:
; CHECK-BE:       @ %bb.0:
; CHECK-BE-NEXT:    ldrb r0, [r1, r3]
; CHECK-BE-NEXT:    bx lr
  %addr_int = add i64 %base, %off
  %addr = inttoptr i64 %addr_int to ptr

  %val = load atomic i8, ptr %addr monotonic, align 1

  ret i8 %val
}

define i8 @test_atomic_load_acquire_i8() nounwind {
; CHECK-LABEL: test_atomic_load_acquire_i8:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r0, :lower16:var8
; CHECK-NEXT:    movt r0, :upper16:var8
; CHECK-NEXT:    ldab r0, [r0]
; CHECK-NEXT:    bx lr
  %val = load atomic i8, ptr @var8 acquire, align 1
  ret i8 %val
}

define i8 @test_atomic_load_seq_cst_i8() nounwind {
; CHECK-LABEL: test_atomic_load_seq_cst_i8:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r0, :lower16:var8
; CHECK-NEXT:    movt r0, :upper16:var8
; CHECK-NEXT:    ldab r0, [r0]
; CHECK-NEXT:    bx lr
  %val = load atomic i8, ptr @var8 seq_cst, align 1
  ret i8 %val
}

define i16 @test_atomic_load_monotonic_i16() nounwind {
; CHECK-LABEL: test_atomic_load_monotonic_i16:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r0, :lower16:var16
; CHECK-NEXT:    movt r0, :upper16:var16
; CHECK-NEXT:    ldrh r0, [r0]
; CHECK-NEXT:    bx lr
  %val = load atomic i16, ptr @var16 monotonic, align 2

  ret i16 %val
}

define i32 @test_atomic_load_monotonic_regoff_i32(i64 %base, i64 %off) nounwind {
; CHECK-LE-LABEL: test_atomic_load_monotonic_regoff_i32:
; CHECK-LE:       @ %bb.0:
; CHECK-LE-NEXT:    ldr r0, [r0, r2]
; CHECK-LE-NEXT:    bx lr
;
; CHECK-BE-LABEL: test_atomic_load_monotonic_regoff_i32:
; CHECK-BE:       @ %bb.0:
; CHECK-BE-NEXT:    ldr r0, [r1, r3]
; CHECK-BE-NEXT:    bx lr
  %addr_int = add i64 %base, %off
  %addr = inttoptr i64 %addr_int to ptr

  %val = load atomic i32, ptr %addr monotonic, align 4

  ret i32 %val
}

define i64 @test_atomic_load_seq_cst_i64() nounwind {
; CHECK-LABEL: test_atomic_load_seq_cst_i64:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r0, :lower16:var64
; CHECK-NEXT:    movt r0, :upper16:var64
; CHECK-NEXT:    ldaexd r0, r1, [r0]
; CHECK-NEXT:    clrex
; CHECK-NEXT:    bx lr
  %val = load atomic i64, ptr @var64 seq_cst, align 8
  ret i64 %val
}

define void @test_atomic_store_monotonic_i8(i8 %val) nounwind {
; CHECK-LABEL: test_atomic_store_monotonic_i8:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r1, :lower16:var8
; CHECK-NEXT:    movt r1, :upper16:var8
; CHECK-NEXT:    strb r0, [r1]
; CHECK-NEXT:    bx lr
  store atomic i8 %val, ptr @var8 monotonic, align 1

  ret void
}

define void @test_atomic_store_monotonic_regoff_i8(i64 %base, i64 %off, i8 %val) nounwind {
; CHECK-ARM-LE-LABEL: test_atomic_store_monotonic_regoff_i8:
; CHECK-ARM-LE:       @ %bb.0:
; CHECK-ARM-LE-NEXT:    ldrb r1, [sp]
; CHECK-ARM-LE-NEXT:    strb r1, [r0, r2]
; CHECK-ARM-LE-NEXT:    bx lr
;
; CHECK-ARM-BE-LABEL: test_atomic_store_monotonic_regoff_i8:
; CHECK-ARM-BE:       @ %bb.0:
; CHECK-ARM-BE-NEXT:    ldrb r0, [sp, #3]
; CHECK-ARM-BE-NEXT:    strb r0, [r1, r3]
; CHECK-ARM-BE-NEXT:    bx lr
;
; CHECK-THUMB-LE-LABEL: test_atomic_store_monotonic_regoff_i8:
; CHECK-THUMB-LE:       @ %bb.0:
; CHECK-THUMB-LE-NEXT:    ldrb.w r1, [sp]
; CHECK-THUMB-LE-NEXT:    strb r1, [r0, r2]
; CHECK-THUMB-LE-NEXT:    bx lr
;
; CHECK-THUMB-BE-LABEL: test_atomic_store_monotonic_regoff_i8:
; CHECK-THUMB-BE:       @ %bb.0:
; CHECK-THUMB-BE-NEXT:    ldrb.w r0, [sp, #3]
; CHECK-THUMB-BE-NEXT:    strb r0, [r1, r3]
; CHECK-THUMB-BE-NEXT:    bx lr

  %addr_int = add i64 %base, %off
  %addr = inttoptr i64 %addr_int to ptr

  store atomic i8 %val, ptr %addr monotonic, align 1

  ret void
}

define void @test_atomic_store_release_i8(i8 %val) nounwind {
; CHECK-LABEL: test_atomic_store_release_i8:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r1, :lower16:var8
; CHECK-NEXT:    movt r1, :upper16:var8
; CHECK-NEXT:    stlb r0, [r1]
; CHECK-NEXT:    bx lr
  store atomic i8 %val, ptr @var8 release, align 1
  ret void
}

define void @test_atomic_store_seq_cst_i8(i8 %val) nounwind {
; CHECK-LABEL: test_atomic_store_seq_cst_i8:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r1, :lower16:var8
; CHECK-NEXT:    movt r1, :upper16:var8
; CHECK-NEXT:    stlb r0, [r1]
; CHECK-NEXT:    bx lr
  store atomic i8 %val, ptr @var8 seq_cst, align 1
  ret void
}

define void @test_atomic_store_monotonic_i16(i16 %val) nounwind {
; CHECK-LABEL: test_atomic_store_monotonic_i16:
; CHECK:       @ %bb.0:
; CHECK-NEXT:    movw r1, :lower16:var16
; CHECK-NEXT:    movt r1, :upper16:var16
; CHECK-NEXT:    strh r0, [r1]
; CHECK-NEXT:    bx lr
  store atomic i16 %val, ptr @var16 monotonic, align 2
  ret void
}

define void @test_atomic_store_monotonic_regoff_i32(i64 %base, i64 %off, i32 %val) nounwind {
; CHECK-LE-LABEL: test_atomic_store_monotonic_regoff_i32:
; CHECK-LE:       @ %bb.0:
; CHECK-LE-NEXT:    ldr r1, [sp]
; CHECK-LE-NEXT:    str r1, [r0, r2]
; CHECK-LE-NEXT:    bx lr
;
; CHECK-BE-LABEL: test_atomic_store_monotonic_regoff_i32:
; CHECK-BE:       @ %bb.0:
; CHECK-BE-NEXT:    ldr r0, [sp]
; CHECK-BE-NEXT:    str r0, [r1, r3]
; CHECK-BE-NEXT:    bx lr

  %addr_int = add i64 %base, %off
  %addr = inttoptr i64 %addr_int to ptr

  store atomic i32 %val, ptr %addr monotonic, align 4

  ret void
}

define void @test_atomic_store_release_i64(i64 %val) nounwind {
; CHECK-ARM-LABEL: test_atomic_store_release_i64:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    push {r4, r5, r11, lr}
; CHECK-ARM-NEXT:    movw r2, :lower16:var64
; CHECK-ARM-NEXT:    @ kill: def $r1 killed $r1 killed $r0_r1 def $r0_r1
; CHECK-ARM-NEXT:    movt r2, :upper16:var64
; CHECK-ARM-NEXT:    @ kill: def $r0 killed $r0 killed $r0_r1 def $r0_r1
; CHECK-ARM-NEXT:  .LBB57_1: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrexd r4, r5, [r2]
; CHECK-ARM-NEXT:    stlexd r3, r0, r1, [r2]
; CHECK-ARM-NEXT:    cmp r3, #0
; CHECK-ARM-NEXT:    bne .LBB57_1
; CHECK-ARM-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-ARM-NEXT:    pop {r4, r5, r11, pc}
;
; CHECK-THUMB-LABEL: test_atomic_store_release_i64:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    movw r12, :lower16:var64
; CHECK-THUMB-NEXT:    movt r12, :upper16:var64
; CHECK-THUMB-NEXT:  .LBB57_1: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrexd r3, r2, [r12]
; CHECK-THUMB-NEXT:    stlexd r2, r0, r1, [r12]
; CHECK-THUMB-NEXT:    cmp r2, #0
; CHECK-THUMB-NEXT:    bne .LBB57_1
; CHECK-THUMB-NEXT:  @ %bb.2: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    bx lr
  store atomic i64 %val, ptr @var64 release, align 8

  ; r0, r1 below is a reasonable guess but could change: it certainly comes into the
  ; function there.

  ret void
}

define i32 @not_barriers(ptr %var, i1 %cond) {
; CHECK-ARM-LABEL: not_barriers:
; CHECK-ARM:       @ %bb.0:
; CHECK-ARM-NEXT:    tst r1, #1
; CHECK-ARM-NEXT:    beq .LBB58_4
; CHECK-ARM-NEXT:  @ %bb.1: @ %atomic_ver
; CHECK-ARM-NEXT:    dmb ish
; CHECK-ARM-NEXT:  .LBB58_2: @ %atomicrmw.start
; CHECK-ARM-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-ARM-NEXT:    ldrex r1, [r0]
; CHECK-ARM-NEXT:    sub r2, r1, #1
; CHECK-ARM-NEXT:    strex r3, r2, [r0]
; CHECK-ARM-NEXT:    cmp r3, #0
; CHECK-ARM-NEXT:    bne .LBB58_2
; CHECK-ARM-NEXT:  @ %bb.3: @ %atomicrmw.end
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    dmb ish
; CHECK-ARM-NEXT:    bx lr
; CHECK-ARM-NEXT:  .LBB58_4: @ %simple_ver
; CHECK-ARM-NEXT:    ldr r1, [r0]
; CHECK-ARM-NEXT:    sub r1, r1, #1
; CHECK-ARM-NEXT:    str r1, [r0]
; CHECK-ARM-NEXT:    mov r0, r1
; CHECK-ARM-NEXT:    bx lr
;
; CHECK-THUMB-LABEL: not_barriers:
; CHECK-THUMB:       @ %bb.0:
; CHECK-THUMB-NEXT:    mov r2, r0
; CHECK-THUMB-NEXT:    lsls r0, r1, #31
; CHECK-THUMB-NEXT:    itttt eq
; CHECK-THUMB-NEXT:    ldreq r0, [r2]
; CHECK-THUMB-NEXT:    subeq r0, #1
; CHECK-THUMB-NEXT:    streq r0, [r2]
; CHECK-THUMB-NEXT:    bxeq lr
; CHECK-THUMB-NEXT:  .LBB58_1: @ %atomic_ver
; CHECK-THUMB-NEXT:    dmb ish
; CHECK-THUMB-NEXT:  .LBB58_2: @ %atomicrmw.start
; CHECK-THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-THUMB-NEXT:    ldrex r0, [r2]
; CHECK-THUMB-NEXT:    subs r1, r0, #1
; CHECK-THUMB-NEXT:    strex r3, r1, [r2]
; CHECK-THUMB-NEXT:    cmp r3, #0
; CHECK-THUMB-NEXT:    bne .LBB58_2
; CHECK-THUMB-NEXT:  @ %bb.3: @ %atomicrmw.end
; CHECK-THUMB-NEXT:    dmb ish
; CHECK-THUMB-NEXT:    bx lr
  br i1 %cond, label %atomic_ver, label %simple_ver
simple_ver:
  %oldval = load i32, ptr %var
  %newval = add nsw i32 %oldval, -1
  store i32 %newval, ptr %var
  br label %somewhere
atomic_ver:
  fence seq_cst
  %val = atomicrmw add ptr %var, i32 -1 monotonic
  fence seq_cst
  br label %somewhere
  ; The key point here is that the second dmb isn't immediately followed by the
  ; simple_ver basic block, which LLVM attempted to do when DMB had been marked
  ; with isBarrier. For now, look for something that looks like "somewhere".
somewhere:
  %combined = phi i32 [ %val, %atomic_ver ], [ %newval, %simple_ver]
  ret i32 %combined
}
