; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s | FileCheck %s

target triple = "nvptx64-unknown-unknown"

;; Verify that 64-bit loads are not split into more 32-bit
;; loads. Loads are more expensive than shifts/conversions.
define float @test(ptr %in) {
;
; CHECK-LABEL: test(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<5>;
; CHECK-NEXT:    .reg .f32 %f<8>;
; CHECK-NEXT:    .reg .b64 %rd<4>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.u64 %rd1, [test_param_0];
; CHECK-NEXT:    ld.u64 %rd2, [%rd1];
; CHECK-NEXT:    ld.u64 %rd3, [%rd1+8];
; CHECK-NEXT:    cvt.u32.u64 %r1, %rd2;
; CHECK-NEXT:    cvt.u32.u64 %r2, %rd3;
; CHECK-NEXT:    mov.b32 %f1, %r1;
; CHECK-NEXT:    mov.b32 %f2, %r2;
; CHECK-NEXT:    add.rn.f32 %f3, %f1, %f2;
; CHECK-NEXT:    { .reg .b32 tmp; mov.b64 {tmp, %r3}, %rd2; }
; CHECK-NEXT:    { .reg .b32 tmp; mov.b64 {tmp, %r4}, %rd3; }
; CHECK-NEXT:    mov.b32 %f4, %r3;
; CHECK-NEXT:    mov.b32 %f5, %r4;
; CHECK-NEXT:    add.rn.f32 %f6, %f4, %f5;
; CHECK-NEXT:    add.rn.f32 %f7, %f3, %f6;
; CHECK-NEXT:    st.param.f32 [func_retval0], %f7;
; CHECK-NEXT:    ret;
  %ptr0 = getelementptr inbounds i64, ptr %in, i64 0
  %ptr1 = getelementptr inbounds i64, ptr %in, i64 1

  %load0 = load i64, ptr %ptr0, align 8
  %load1 = load i64, ptr %ptr1, align 8
  %trunc_lo_0 = trunc i64 %load0 to i32
  %trunc_lo_1 = trunc i64 %load1 to i32
  %float_lo_0 = bitcast i32 %trunc_lo_0 to float
  %float_lo_1 = bitcast i32 %trunc_lo_1 to float
  %add_lo = fadd float %float_lo_0, %float_lo_1

  %shift0 = lshr i64 %load0, 32
  %shift1 = lshr i64 %load1, 32
  %trunc_hi_0 = trunc i64 %shift0 to i32
  %trunc_hi_1 = trunc i64 %shift1 to i32
  %float_hi_0 = bitcast i32 %trunc_hi_0 to float
  %float_hi_1 = bitcast i32 %trunc_hi_1 to float
  %add_hi = fadd float %float_hi_0, %float_hi_1

  %res = fadd float %add_lo, %add_hi
  ret float %res
}
