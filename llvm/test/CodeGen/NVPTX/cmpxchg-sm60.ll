; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -march=nvptx64 -mcpu=sm_60 -mattr=+ptx50 | FileCheck %s --check-prefix=SM60
; RUN: %if ptxas %{ llc < %s -march=nvptx64 -mcpu=sm_60 -mattr=+ptx50 | %ptxas-verify -arch=sm_60 %}

define i8 @weak_monotonic_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_monotonic_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r6, [weak_monotonic_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r7, [weak_monotonic_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_monotonic_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_monotonic_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_acquire_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r6, [weak_monotonic_acquire_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r7, [weak_monotonic_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_monotonic_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_monotonic_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_monotonic_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_monotonic_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_acquire_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acquire_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acquire_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r7, [weak_acquire_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_acquire_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acquire_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_acquire_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acquire_acquire_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r7, [weak_acquire_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_acquire_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acquire_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acquire_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_acquire_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_release_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_release_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_release_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_release_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_release_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_release_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_acquire_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_release_acquire_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_release_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_release_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_release_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_release_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_release_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_acq_rel_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acq_rel_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acq_rel_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_acq_rel_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_acq_rel_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_acquire_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acq_rel_acquire_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_acq_rel_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_acq_rel_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acq_rel_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acq_rel_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_acq_rel_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_seq_cst_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_seq_cst_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_seq_cst_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_seq_cst_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_seq_cst_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_seq_cst_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_acquire_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_seq_cst_acquire_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_seq_cst_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_seq_cst_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_seq_cst_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_seq_cst_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_seq_cst_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i16 @weak_monotonic_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_monotonic_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r6, [weak_monotonic_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r7, [weak_monotonic_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_monotonic_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_monotonic_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_acquire_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r6, [weak_monotonic_acquire_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r7, [weak_monotonic_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_monotonic_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_monotonic_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_monotonic_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_monotonic_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_acquire_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_acquire_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r6, [weak_acquire_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r7, [weak_acquire_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_acquire_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_acquire_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_acquire_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r6, [weak_acquire_acquire_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r7, [weak_acquire_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_acquire_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_acquire_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_acquire_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_acquire_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_release_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_release_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_release_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_release_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_release_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_release_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_acquire_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_release_acquire_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_release_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_release_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_release_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_release_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_release_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_acq_rel_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_acq_rel_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_acq_rel_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_acq_rel_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_acq_rel_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_acquire_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_acq_rel_acquire_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_acq_rel_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_acq_rel_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_acq_rel_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_acq_rel_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_acq_rel_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_seq_cst_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_seq_cst_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_seq_cst_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_seq_cst_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_seq_cst_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_seq_cst_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_acquire_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_seq_cst_acquire_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_seq_cst_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @weak_seq_cst_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: weak_seq_cst_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r6, [weak_seq_cst_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [weak_seq_cst_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 65535;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i32 @weak_monotonic_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_monotonic_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_monotonic_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_monotonic_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_monotonic_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_monotonic_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_monotonic_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_monotonic_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_monotonic_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_monotonic_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_monotonic_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_monotonic_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_monotonic_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [weak_monotonic_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_monotonic_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acquire_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acquire_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acquire_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acquire_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acquire_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acquire_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acquire_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acquire_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acquire_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acquire_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acquire_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acquire_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acquire_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [weak_acquire_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acquire_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_release_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_release_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_release_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_release_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_release_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_release_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_release_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_release_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_release_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_release_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_release_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_release_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_release_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [weak_release_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_release_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acq_rel_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acq_rel_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acq_rel_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_seq_cst_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_seq_cst_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_seq_cst_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [weak_seq_cst_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_seq_cst_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_seq_cst_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_seq_cst_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_seq_cst_acquire_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [weak_seq_cst_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_seq_cst_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_seq_cst_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_seq_cst_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_seq_cst_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [weak_seq_cst_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_seq_cst_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i64 @weak_monotonic_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_monotonic_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_monotonic_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_monotonic_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_monotonic_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_monotonic_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_monotonic_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_monotonic_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_monotonic_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_monotonic_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_monotonic_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [weak_monotonic_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_monotonic_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_acquire_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_acquire_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acquire_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_acquire_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_acquire_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_acquire_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acquire_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_acquire_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_acquire_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_acquire_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acquire_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acquire_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_acquire_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_release_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_release_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_release_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_release_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_release_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_release_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_release_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_release_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_release_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_release_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_release_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [weak_release_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_release_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_acq_rel_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_acq_rel_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_acq_rel_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_acq_rel_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_acq_rel_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_acq_rel_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_acq_rel_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_acq_rel_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_seq_cst_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_seq_cst_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_seq_cst_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_seq_cst_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_seq_cst_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_seq_cst_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_seq_cst_acquire_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_seq_cst_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @weak_seq_cst_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: weak_seq_cst_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_seq_cst_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [weak_seq_cst_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [weak_seq_cst_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i8 @weak_acq_rel_acquire_i8_global(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i8_global(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_acquire_i8_global_param_0];
; SM60-NEXT:    membar.sys;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acq_rel_acquire_i8_global_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_acq_rel_acquire_i8_global_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.sys.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.sys;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i8 %cmp, i8 %new acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i32 @weak_acq_rel_acquire_i32_global(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i32_global(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_acquire_i32_global_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_acquire_i32_global_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_acquire_i32_global_param_2];
; SM60-NEXT:    atom.sys.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acq_rel_acquire_i32_global_sys(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i32_global_sys(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_acquire_i32_global_sys_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_acquire_i32_global_sys_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_acquire_i32_global_sys_param_2];
; SM60-NEXT:    atom.sys.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acq_rel_acquire_i32_global_gpu(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i32_global_gpu(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_acquire_i32_global_gpu_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_acquire_i32_global_gpu_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_acquire_i32_global_gpu_param_2];
; SM60-NEXT:    atom.gpu.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("device") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i8 @weak_acq_rel_acquire_i8_generic_cta(ptr %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i8_generic_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_acquire_i8_generic_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acq_rel_acquire_i8_generic_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_acq_rel_acquire_i8_generic_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr %addr, i8 %cmp, i8 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @weak_acq_rel_acquire_i8_shared_cta(ptr addrspace(3) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i8_shared_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<17>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [weak_acq_rel_acquire_i8_shared_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r6, [weak_acq_rel_acquire_i8_shared_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [weak_acq_rel_acquire_i8_shared_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r8, %rd2;
; SM60-NEXT:    and.b32 %r9, %r8, 3;
; SM60-NEXT:    shl.b32 %r1, %r9, 3;
; SM60-NEXT:    mov.b32 %r10, 255;
; SM60-NEXT:    shl.b32 %r11, %r10, %r1;
; SM60-NEXT:    not.b32 %r12, %r11;
; SM60-NEXT:    shl.b32 %r2, %r7, %r1;
; SM60-NEXT:    shl.b32 %r3, %r6, %r1;
; SM60-NEXT:    ld.shared.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r4, %r13, %r12;
; SM60-NEXT:    or.b32 %r14, %r4, %r2;
; SM60-NEXT:    or.b32 %r15, %r4, %r3;
; SM60-NEXT:    atom.cta.shared.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(3) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i32 @weak_acq_rel_acquire_i32_generic_cta(ptr %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i32_generic_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_acquire_i32_generic_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_acquire_i32_generic_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_acquire_i32_generic_cta_param_2];
; SM60-NEXT:    atom.cta.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr %addr, i32 %cmp, i32 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @weak_acq_rel_acquire_i32_shared_cta(ptr addrspace(3) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: weak_acq_rel_acquire_i32_shared_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [weak_acq_rel_acquire_i32_shared_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [weak_acq_rel_acquire_i32_shared_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [weak_acq_rel_acquire_i32_shared_cta_param_2];
; SM60-NEXT:    atom.cta.shared.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg weak ptr addrspace(3) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i8 @strong_monotonic_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_monotonic_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [strong_monotonic_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r8, [strong_monotonic_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB68_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB68_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB68_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB68_1;
; SM60-NEXT:  $L__BB68_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_monotonic_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_monotonic_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_acquire_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [strong_monotonic_acquire_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r8, [strong_monotonic_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB69_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB69_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB69_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB69_1;
; SM60-NEXT:  $L__BB69_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_monotonic_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_monotonic_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_monotonic_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_monotonic_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB70_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB70_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB70_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB70_1;
; SM60-NEXT:  $L__BB70_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_acquire_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acquire_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acquire_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r8, [strong_acquire_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB71_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB71_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB71_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB71_1;
; SM60-NEXT:  $L__BB71_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_acquire_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acquire_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_acquire_i8_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acquire_acquire_i8_global_cta_param_1];
; SM60-NEXT:    ld.param.b8 %r8, [strong_acquire_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB72_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB72_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB72_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB72_1;
; SM60-NEXT:  $L__BB72_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_acquire_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acquire_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acquire_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_acquire_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB73_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB73_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB73_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB73_1;
; SM60-NEXT:  $L__BB73_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_release_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_release_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_release_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_release_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB74_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB74_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB74_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB74_1;
; SM60-NEXT:  $L__BB74_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_release_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_release_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_acquire_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_release_acquire_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_release_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB75_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB75_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB75_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB75_1;
; SM60-NEXT:  $L__BB75_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_release_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_release_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_release_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_release_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB76_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB76_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB76_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB76_1;
; SM60-NEXT:  $L__BB76_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_acq_rel_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acq_rel_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acq_rel_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_acq_rel_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB77_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB77_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB77_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB77_1;
; SM60-NEXT:  $L__BB77_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_acq_rel_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_acquire_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acq_rel_acquire_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_acq_rel_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB78_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB78_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB78_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB78_1;
; SM60-NEXT:  $L__BB78_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_acq_rel_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acq_rel_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acq_rel_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_acq_rel_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB79_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB79_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB79_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB79_1;
; SM60-NEXT:  $L__BB79_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_seq_cst_monotonic_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_seq_cst_monotonic_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_monotonic_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_seq_cst_monotonic_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_seq_cst_monotonic_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB80_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB80_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB80_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB80_1;
; SM60-NEXT:  $L__BB80_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_seq_cst_acquire_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_seq_cst_acquire_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_acquire_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_seq_cst_acquire_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_seq_cst_acquire_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB81_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB81_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB81_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB81_1;
; SM60-NEXT:  $L__BB81_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_seq_cst_seq_cst_i8_global_cta(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_seq_cst_seq_cst_i8_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_seq_cst_i8_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_seq_cst_seq_cst_i8_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_seq_cst_seq_cst_i8_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB82_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB82_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB82_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB82_1;
; SM60-NEXT:  $L__BB82_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i16 @strong_monotonic_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_monotonic_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [strong_monotonic_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r8, [strong_monotonic_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB83_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB83_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB83_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB83_1;
; SM60-NEXT:  $L__BB83_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_monotonic_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_monotonic_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_acquire_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [strong_monotonic_acquire_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r8, [strong_monotonic_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB84_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB84_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB84_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB84_1;
; SM60-NEXT:  $L__BB84_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_monotonic_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_monotonic_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_monotonic_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_monotonic_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB85_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB85_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB85_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB85_1;
; SM60-NEXT:  $L__BB85_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_acquire_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_acquire_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [strong_acquire_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r8, [strong_acquire_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB86_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB86_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB86_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB86_1;
; SM60-NEXT:  $L__BB86_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_acquire_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_acquire_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_acquire_i16_global_cta_param_0];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r7, [strong_acquire_acquire_i16_global_cta_param_1];
; SM60-NEXT:    ld.param.b16 %r8, [strong_acquire_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB87_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB87_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB87_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB87_1;
; SM60-NEXT:  $L__BB87_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_acquire_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_acquire_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_acquire_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_acquire_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB88_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB88_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB88_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB88_1;
; SM60-NEXT:  $L__BB88_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_release_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_release_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_release_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_release_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB89_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB89_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB89_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB89_1;
; SM60-NEXT:  $L__BB89_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_release_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_release_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_acquire_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_release_acquire_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_release_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB90_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB90_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB90_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB90_1;
; SM60-NEXT:  $L__BB90_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_release_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_release_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_release_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_release_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB91_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB91_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB91_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB91_1;
; SM60-NEXT:  $L__BB91_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_acq_rel_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_acq_rel_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_acq_rel_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_acq_rel_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB92_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB92_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB92_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB92_1;
; SM60-NEXT:  $L__BB92_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_acq_rel_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_acquire_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_acq_rel_acquire_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_acq_rel_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB93_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB93_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB93_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB93_1;
; SM60-NEXT:  $L__BB93_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_acq_rel_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_acq_rel_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_acq_rel_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_acq_rel_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB94_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB94_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB94_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB94_1;
; SM60-NEXT:  $L__BB94_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_seq_cst_monotonic_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_seq_cst_monotonic_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_monotonic_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_seq_cst_monotonic_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_seq_cst_monotonic_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB95_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB95_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB95_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB95_1;
; SM60-NEXT:  $L__BB95_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_seq_cst_acquire_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_seq_cst_acquire_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_acquire_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_seq_cst_acquire_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_seq_cst_acquire_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB96_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB96_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB96_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB96_1;
; SM60-NEXT:  $L__BB96_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i16 @strong_seq_cst_seq_cst_i16_global_cta(ptr addrspace(1) %addr, i16 %cmp, i16 %new) {
; SM60-LABEL: strong_seq_cst_seq_cst_i16_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_seq_cst_i16_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b16 %r7, [strong_seq_cst_seq_cst_i16_global_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b16 %r8, [strong_seq_cst_seq_cst_i16_global_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 65535;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB97_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB97_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB97_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB97_1;
; SM60-NEXT:  $L__BB97_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i16 %cmp, i16 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i16, i1 } %pairold, 0
    ret i16 %oldvalue
}

define i32 @strong_monotonic_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_monotonic_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_monotonic_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_monotonic_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_monotonic_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_monotonic_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_monotonic_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_monotonic_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_monotonic_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_monotonic_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_monotonic_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_monotonic_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_monotonic_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [strong_monotonic_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_monotonic_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acquire_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acquire_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acquire_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acquire_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acquire_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acquire_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acquire_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acquire_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acquire_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acquire_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acquire_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acquire_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acquire_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [strong_acquire_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acquire_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_release_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_release_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_release_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_release_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_release_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_release_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_release_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_release_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_release_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_release_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_release_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_release_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_release_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [strong_release_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_release_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acq_rel_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acq_rel_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_acquire_i32_global_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acq_rel_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_seq_cst_monotonic_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_seq_cst_monotonic_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_seq_cst_monotonic_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [strong_seq_cst_monotonic_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_seq_cst_monotonic_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_seq_cst_acquire_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_seq_cst_acquire_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_seq_cst_acquire_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [strong_seq_cst_acquire_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_seq_cst_acquire_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_seq_cst_seq_cst_i32_global_cta(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_seq_cst_seq_cst_i32_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_seq_cst_seq_cst_i32_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b32 %r1, [strong_seq_cst_seq_cst_i32_global_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_seq_cst_seq_cst_i32_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i64 @strong_monotonic_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_monotonic_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_monotonic_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_monotonic_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") monotonic monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_monotonic_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_monotonic_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_monotonic_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_monotonic_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") monotonic acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_monotonic_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_monotonic_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_monotonic_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [strong_monotonic_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_monotonic_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") monotonic seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_acquire_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_acquire_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acquire_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_acquire_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acquire monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_acquire_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_acquire_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acquire_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_acquire_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acquire acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_acquire_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_acquire_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acquire_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acquire_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_acquire_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acquire seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_release_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_release_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_release_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_release_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") release monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_release_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_release_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_release_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_release_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") release acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_release_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_release_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_release_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [strong_release_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_release_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") release seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_acq_rel_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_acq_rel_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_acq_rel_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acq_rel monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_acq_rel_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_acquire_i64_global_cta_param_0];
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_acq_rel_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_acq_rel_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_acq_rel_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_acq_rel_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") acq_rel seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_seq_cst_monotonic_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_seq_cst_monotonic_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_seq_cst_monotonic_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_monotonic_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_seq_cst_monotonic_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") seq_cst monotonic
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_seq_cst_acquire_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_seq_cst_acquire_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_seq_cst_acquire_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_acquire_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_seq_cst_acquire_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") seq_cst acquire
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i64 @strong_seq_cst_seq_cst_i64_global_cta(ptr addrspace(1) %addr, i64 %cmp, i64 %new) {
; SM60-LABEL: strong_seq_cst_seq_cst_i64_global_cta(
; SM60:       {
; SM60-NEXT:    .reg .b64 %rd<5>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_seq_cst_seq_cst_i64_global_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b64 %rd2, [strong_seq_cst_seq_cst_i64_global_cta_param_1];
; SM60-NEXT:    ld.param.b64 %rd3, [strong_seq_cst_seq_cst_i64_global_cta_param_2];
; SM60-NEXT:    atom.cta.global.cas.b64 %rd4, [%rd1], %rd2, %rd3;
; SM60-NEXT:    st.param.b64 [func_retval0], %rd4;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i64 %cmp, i64 %new syncscope("block") seq_cst seq_cst
    %oldvalue = extractvalue { i64, i1 } %pairold, 0
    ret i64 %oldvalue
}

define i8 @strong_acq_rel_acquire_i8_global(ptr addrspace(1) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i8_global(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_acquire_i8_global_param_0];
; SM60-NEXT:    membar.sys;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acq_rel_acquire_i8_global_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_acq_rel_acquire_i8_global_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.global.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB128_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.sys.global.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB128_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB128_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB128_1;
; SM60-NEXT:  $L__BB128_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.sys;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i8 %cmp, i8 %new acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i32 @strong_acq_rel_acquire_i32_global(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i32_global(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_acquire_i32_global_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_acquire_i32_global_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_acquire_i32_global_param_2];
; SM60-NEXT:    atom.sys.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acq_rel_acquire_i32_global_sys(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i32_global_sys(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_acquire_i32_global_sys_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_acquire_i32_global_sys_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_acquire_i32_global_sys_param_2];
; SM60-NEXT:    atom.sys.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acq_rel_acquire_i32_global_gpu(ptr addrspace(1) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i32_global_gpu(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_acquire_i32_global_gpu_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_acquire_i32_global_gpu_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_acquire_i32_global_gpu_param_2];
; SM60-NEXT:    atom.gpu.global.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(1) %addr, i32 %cmp, i32 %new syncscope("device") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i8 @strong_acq_rel_acquire_i8_generic_cta(ptr %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i8_generic_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_acquire_i8_generic_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acq_rel_acquire_i8_generic_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_acq_rel_acquire_i8_generic_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB132_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB132_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB132_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB132_1;
; SM60-NEXT:  $L__BB132_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr %addr, i8 %cmp, i8 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i8 @strong_acq_rel_acquire_i8_shared_cta(ptr addrspace(3) %addr, i8 %cmp, i8 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i8_shared_cta(
; SM60:       {
; SM60-NEXT:    .reg .pred %p<3>;
; SM60-NEXT:    .reg .b32 %r<18>;
; SM60-NEXT:    .reg .b64 %rd<3>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd2, [strong_acq_rel_acquire_i8_shared_cta_param_0];
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    ld.param.b8 %r7, [strong_acq_rel_acquire_i8_shared_cta_param_1];
; SM60-NEXT:    and.b64 %rd1, %rd2, -4;
; SM60-NEXT:    ld.param.b8 %r8, [strong_acq_rel_acquire_i8_shared_cta_param_2];
; SM60-NEXT:    cvt.u32.u64 %r9, %rd2;
; SM60-NEXT:    and.b32 %r10, %r9, 3;
; SM60-NEXT:    shl.b32 %r1, %r10, 3;
; SM60-NEXT:    mov.b32 %r11, 255;
; SM60-NEXT:    shl.b32 %r12, %r11, %r1;
; SM60-NEXT:    not.b32 %r2, %r12;
; SM60-NEXT:    shl.b32 %r3, %r8, %r1;
; SM60-NEXT:    shl.b32 %r4, %r7, %r1;
; SM60-NEXT:    ld.shared.b32 %r13, [%rd1];
; SM60-NEXT:    and.b32 %r17, %r13, %r2;
; SM60-NEXT:  $L__BB133_1: // %partword.cmpxchg.loop
; SM60-NEXT:    // =>This Inner Loop Header: Depth=1
; SM60-NEXT:    or.b32 %r14, %r17, %r3;
; SM60-NEXT:    or.b32 %r15, %r17, %r4;
; SM60-NEXT:    atom.cta.shared.cas.b32 %r5, [%rd1], %r15, %r14;
; SM60-NEXT:    setp.eq.b32 %p1, %r5, %r15;
; SM60-NEXT:    @%p1 bra $L__BB133_3;
; SM60-NEXT:  // %bb.2: // %partword.cmpxchg.failure
; SM60-NEXT:    // in Loop: Header=BB133_1 Depth=1
; SM60-NEXT:    and.b32 %r6, %r5, %r2;
; SM60-NEXT:    setp.ne.b32 %p2, %r17, %r6;
; SM60-NEXT:    mov.b32 %r17, %r6;
; SM60-NEXT:    @%p2 bra $L__BB133_1;
; SM60-NEXT:  $L__BB133_3: // %partword.cmpxchg.end
; SM60-NEXT:    shr.u32 %r16, %r5, %r1;
; SM60-NEXT:    membar.cta;
; SM60-NEXT:    st.param.b32 [func_retval0], %r16;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(3) %addr, i8 %cmp, i8 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i8, i1 } %pairold, 0
    ret i8 %oldvalue
}

define i32 @strong_acq_rel_acquire_i32_generic_cta(ptr %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i32_generic_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_acquire_i32_generic_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_acquire_i32_generic_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_acquire_i32_generic_cta_param_2];
; SM60-NEXT:    atom.cta.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr %addr, i32 %cmp, i32 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

define i32 @strong_acq_rel_acquire_i32_shared_cta(ptr addrspace(3) %addr, i32 %cmp, i32 %new) {
; SM60-LABEL: strong_acq_rel_acquire_i32_shared_cta(
; SM60:       {
; SM60-NEXT:    .reg .b32 %r<4>;
; SM60-NEXT:    .reg .b64 %rd<2>;
; SM60-EMPTY:
; SM60-NEXT:  // %bb.0:
; SM60-NEXT:    ld.param.b64 %rd1, [strong_acq_rel_acquire_i32_shared_cta_param_0];
; SM60-NEXT:    ld.param.b32 %r1, [strong_acq_rel_acquire_i32_shared_cta_param_1];
; SM60-NEXT:    ld.param.b32 %r2, [strong_acq_rel_acquire_i32_shared_cta_param_2];
; SM60-NEXT:    atom.cta.shared.cas.b32 %r3, [%rd1], %r1, %r2;
; SM60-NEXT:    st.param.b32 [func_retval0], %r3;
; SM60-NEXT:    ret;
    %pairold = cmpxchg  ptr addrspace(3) %addr, i32 %cmp, i32 %new syncscope("block") acq_rel acquire
    %oldvalue = extractvalue { i32, i1 } %pairold, 0
    ret i32 %oldvalue
}

