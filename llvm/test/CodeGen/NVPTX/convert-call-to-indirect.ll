; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -march=nvptx64 -mcpu=sm_90 | FileCheck %s
; RUN: %if ptxas-sm_90 %{ llc < %s -march=nvptx64 -mcpu=sm_90 | %ptxas-verify -arch=sm_90 %}

%struct.64 = type <{ i64 }>
declare i64 @callee(ptr %p);
declare i64 @callee_variadic(ptr %p, ...);

define %struct.64 @test_return_type_mismatch(ptr %p) {
; CHECK-LABEL: test_return_type_mismatch(
; CHECK:       {
; CHECK-NEXT:    .reg .b64 %rd<32>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.b64 %rd1, [test_return_type_mismatch_param_0];
; CHECK-NEXT:    { // callseq 0, 0
; CHECK-NEXT:    .param .b64 param0;
; CHECK-NEXT:    .param .align 1 .b8 retval0[8];
; CHECK-NEXT:    st.param.b64 [param0], %rd1;
; CHECK-NEXT:    prototype_0 : .callprototype (.param .align 1 .b8 _[8]) _ (.param .b64 _);
; CHECK-NEXT:    mov.b64 %rd2, callee;
; CHECK-NEXT:    call (retval0), %rd2, (param0), prototype_0;
; CHECK-NEXT:    ld.param.b8 %rd3, [retval0+7];
; CHECK-NEXT:    ld.param.b8 %rd4, [retval0+6];
; CHECK-NEXT:    ld.param.b8 %rd5, [retval0+5];
; CHECK-NEXT:    ld.param.b8 %rd6, [retval0+4];
; CHECK-NEXT:    ld.param.b8 %rd7, [retval0+3];
; CHECK-NEXT:    ld.param.b8 %rd8, [retval0+2];
; CHECK-NEXT:    ld.param.b8 %rd9, [retval0+1];
; CHECK-NEXT:    ld.param.b8 %rd10, [retval0];
; CHECK-NEXT:    } // callseq 0
; CHECK-NEXT:    shl.b64 %rd11, %rd9, 8;
; CHECK-NEXT:    or.b64 %rd12, %rd11, %rd10;
; CHECK-NEXT:    shl.b64 %rd13, %rd8, 16;
; CHECK-NEXT:    shl.b64 %rd14, %rd7, 24;
; CHECK-NEXT:    or.b64 %rd15, %rd14, %rd13;
; CHECK-NEXT:    or.b64 %rd16, %rd15, %rd12;
; CHECK-NEXT:    shl.b64 %rd17, %rd5, 8;
; CHECK-NEXT:    or.b64 %rd18, %rd17, %rd6;
; CHECK-NEXT:    shl.b64 %rd19, %rd4, 16;
; CHECK-NEXT:    shl.b64 %rd20, %rd3, 24;
; CHECK-NEXT:    or.b64 %rd21, %rd20, %rd19;
; CHECK-NEXT:    or.b64 %rd22, %rd21, %rd18;
; CHECK-NEXT:    shl.b64 %rd23, %rd22, 32;
; CHECK-NEXT:    or.b64 %rd24, %rd23, %rd16;
; CHECK-NEXT:    st.param.b8 [func_retval0], %rd10;
; CHECK-NEXT:    shr.u64 %rd25, %rd24, 56;
; CHECK-NEXT:    st.param.b8 [func_retval0+7], %rd25;
; CHECK-NEXT:    shr.u64 %rd26, %rd24, 48;
; CHECK-NEXT:    st.param.b8 [func_retval0+6], %rd26;
; CHECK-NEXT:    shr.u64 %rd27, %rd24, 40;
; CHECK-NEXT:    st.param.b8 [func_retval0+5], %rd27;
; CHECK-NEXT:    shr.u64 %rd28, %rd24, 32;
; CHECK-NEXT:    st.param.b8 [func_retval0+4], %rd28;
; CHECK-NEXT:    shr.u64 %rd29, %rd24, 24;
; CHECK-NEXT:    st.param.b8 [func_retval0+3], %rd29;
; CHECK-NEXT:    shr.u64 %rd30, %rd24, 16;
; CHECK-NEXT:    st.param.b8 [func_retval0+2], %rd30;
; CHECK-NEXT:    shr.u64 %rd31, %rd24, 8;
; CHECK-NEXT:    st.param.b8 [func_retval0+1], %rd31;
; CHECK-NEXT:    ret;
  %ret = call %struct.64 @callee(ptr %p)
  ret %struct.64 %ret
}

define i64 @test_param_type_mismatch(ptr %p) {
; CHECK-LABEL: test_param_type_mismatch(
; CHECK:       {
; CHECK-NEXT:    .reg .b64 %rd<3>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    { // callseq 1, 0
; CHECK-NEXT:    .param .b64 param0;
; CHECK-NEXT:    .param .b64 retval0;
; CHECK-NEXT:    prototype_1 : .callprototype (.param .b64 _) _ (.param .b64 _);
; CHECK-NEXT:    st.param.b64 [param0], 7;
; CHECK-NEXT:    mov.b64 %rd1, callee;
; CHECK-NEXT:    call (retval0), %rd1, (param0), prototype_1;
; CHECK-NEXT:    ld.param.b64 %rd2, [retval0];
; CHECK-NEXT:    } // callseq 1
; CHECK-NEXT:    st.param.b64 [func_retval0], %rd2;
; CHECK-NEXT:    ret;
  %ret = call i64 @callee(i64 7)
  ret i64 %ret
}

define i64 @test_param_count_mismatch(ptr %p) {
; CHECK-LABEL: test_param_count_mismatch(
; CHECK:       {
; CHECK-NEXT:    .reg .b64 %rd<4>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.b64 %rd1, [test_param_count_mismatch_param_0];
; CHECK-NEXT:    { // callseq 2, 0
; CHECK-NEXT:    .param .b64 param0;
; CHECK-NEXT:    .param .b64 param1;
; CHECK-NEXT:    .param .b64 retval0;
; CHECK-NEXT:    st.param.b64 [param0], %rd1;
; CHECK-NEXT:    prototype_2 : .callprototype (.param .b64 _) _ (.param .b64 _, .param .b64 _);
; CHECK-NEXT:    st.param.b64 [param1], 7;
; CHECK-NEXT:    mov.b64 %rd2, callee;
; CHECK-NEXT:    call (retval0), %rd2, (param0, param1), prototype_2;
; CHECK-NEXT:    ld.param.b64 %rd3, [retval0];
; CHECK-NEXT:    } // callseq 2
; CHECK-NEXT:    st.param.b64 [func_retval0], %rd3;
; CHECK-NEXT:    ret;
  %ret = call i64 @callee(ptr %p, i64 7)
  ret i64 %ret
}

define %struct.64 @test_return_type_mismatch_variadic(ptr %p) {
; CHECK-LABEL: test_return_type_mismatch_variadic(
; CHECK:       {
; CHECK-NEXT:    .reg .b64 %rd<32>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.b64 %rd1, [test_return_type_mismatch_variadic_param_0];
; CHECK-NEXT:    { // callseq 3, 0
; CHECK-NEXT:    .param .b64 param0;
; CHECK-NEXT:    .param .align 1 .b8 retval0[8];
; CHECK-NEXT:    st.param.b64 [param0], %rd1;
; CHECK-NEXT:    prototype_3 : .callprototype (.param .align 1 .b8 _[8]) _ (.param .b64 _);
; CHECK-NEXT:    mov.b64 %rd2, callee_variadic;
; CHECK-NEXT:    call (retval0), %rd2, (param0), prototype_3;
; CHECK-NEXT:    ld.param.b8 %rd3, [retval0+7];
; CHECK-NEXT:    ld.param.b8 %rd4, [retval0+6];
; CHECK-NEXT:    ld.param.b8 %rd5, [retval0+5];
; CHECK-NEXT:    ld.param.b8 %rd6, [retval0+4];
; CHECK-NEXT:    ld.param.b8 %rd7, [retval0+3];
; CHECK-NEXT:    ld.param.b8 %rd8, [retval0+2];
; CHECK-NEXT:    ld.param.b8 %rd9, [retval0+1];
; CHECK-NEXT:    ld.param.b8 %rd10, [retval0];
; CHECK-NEXT:    } // callseq 3
; CHECK-NEXT:    shl.b64 %rd11, %rd9, 8;
; CHECK-NEXT:    or.b64 %rd12, %rd11, %rd10;
; CHECK-NEXT:    shl.b64 %rd13, %rd8, 16;
; CHECK-NEXT:    shl.b64 %rd14, %rd7, 24;
; CHECK-NEXT:    or.b64 %rd15, %rd14, %rd13;
; CHECK-NEXT:    or.b64 %rd16, %rd15, %rd12;
; CHECK-NEXT:    shl.b64 %rd17, %rd5, 8;
; CHECK-NEXT:    or.b64 %rd18, %rd17, %rd6;
; CHECK-NEXT:    shl.b64 %rd19, %rd4, 16;
; CHECK-NEXT:    shl.b64 %rd20, %rd3, 24;
; CHECK-NEXT:    or.b64 %rd21, %rd20, %rd19;
; CHECK-NEXT:    or.b64 %rd22, %rd21, %rd18;
; CHECK-NEXT:    shl.b64 %rd23, %rd22, 32;
; CHECK-NEXT:    or.b64 %rd24, %rd23, %rd16;
; CHECK-NEXT:    st.param.b8 [func_retval0], %rd10;
; CHECK-NEXT:    shr.u64 %rd25, %rd24, 56;
; CHECK-NEXT:    st.param.b8 [func_retval0+7], %rd25;
; CHECK-NEXT:    shr.u64 %rd26, %rd24, 48;
; CHECK-NEXT:    st.param.b8 [func_retval0+6], %rd26;
; CHECK-NEXT:    shr.u64 %rd27, %rd24, 40;
; CHECK-NEXT:    st.param.b8 [func_retval0+5], %rd27;
; CHECK-NEXT:    shr.u64 %rd28, %rd24, 32;
; CHECK-NEXT:    st.param.b8 [func_retval0+4], %rd28;
; CHECK-NEXT:    shr.u64 %rd29, %rd24, 24;
; CHECK-NEXT:    st.param.b8 [func_retval0+3], %rd29;
; CHECK-NEXT:    shr.u64 %rd30, %rd24, 16;
; CHECK-NEXT:    st.param.b8 [func_retval0+2], %rd30;
; CHECK-NEXT:    shr.u64 %rd31, %rd24, 8;
; CHECK-NEXT:    st.param.b8 [func_retval0+1], %rd31;
; CHECK-NEXT:    ret;
  %ret = call %struct.64 (ptr, ...) @callee_variadic(ptr %p)
  ret %struct.64 %ret
}

define i64 @test_param_type_mismatch_variadic(ptr %p) {
; CHECK-LABEL: test_param_type_mismatch_variadic(
; CHECK:       {
; CHECK-NEXT:    .reg .b64 %rd<3>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.b64 %rd1, [test_param_type_mismatch_variadic_param_0];
; CHECK-NEXT:    { // callseq 4, 0
; CHECK-NEXT:    .param .align 8 .b8 param1[8];
; CHECK-NEXT:    .param .b64 param0;
; CHECK-NEXT:    .param .b64 retval0;
; CHECK-NEXT:    st.param.b64 [param0], %rd1;
; CHECK-NEXT:    st.param.b64 [param1], 7;
; CHECK-NEXT:    call.uni (retval0), callee_variadic, (param0, param1);
; CHECK-NEXT:    ld.param.b64 %rd2, [retval0];
; CHECK-NEXT:    } // callseq 4
; CHECK-NEXT:    st.param.b64 [func_retval0], %rd2;
; CHECK-NEXT:    ret;
  %ret = call i64 (ptr, ...) @callee_variadic(ptr %p, i64 7)
  ret i64 %ret
}

define i64 @test_param_count_mismatch_variadic(ptr %p) {
; CHECK-LABEL: test_param_count_mismatch_variadic(
; CHECK:       {
; CHECK-NEXT:    .reg .b64 %rd<3>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    ld.param.b64 %rd1, [test_param_count_mismatch_variadic_param_0];
; CHECK-NEXT:    { // callseq 5, 0
; CHECK-NEXT:    .param .align 8 .b8 param1[8];
; CHECK-NEXT:    .param .b64 param0;
; CHECK-NEXT:    .param .b64 retval0;
; CHECK-NEXT:    st.param.b64 [param0], %rd1;
; CHECK-NEXT:    st.param.b64 [param1], 7;
; CHECK-NEXT:    call.uni (retval0), callee_variadic, (param0, param1);
; CHECK-NEXT:    ld.param.b64 %rd2, [retval0];
; CHECK-NEXT:    } // callseq 5
; CHECK-NEXT:    st.param.b64 [func_retval0], %rd2;
; CHECK-NEXT:    ret;
  %ret = call i64 (ptr, ...) @callee_variadic(ptr %p, i64 7)
  ret i64 %ret
}
