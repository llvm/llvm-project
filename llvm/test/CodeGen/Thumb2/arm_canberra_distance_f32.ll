; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc < %s -mtriple thumbv8.1m.main-unknown-none-eabihf -mattr=+mve.fp | FileCheck %s

define nofpclass(nan inf) float @arm_canberra_distance_f32(ptr noundef readonly captures(none) %pA, ptr noundef readonly captures(none) %pB, i32 noundef %blockSize) {
; CHECK-LABEL: arm_canberra_distance_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vldr s0, .LCPI0_0
; CHECK-NEXT:    cmp r2, #0
; CHECK-NEXT:    it eq
; CHECK-NEXT:    bxeq lr
; CHECK-NEXT:  .LBB0_1: @ %while.body
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    vldr s2, [r1]
; CHECK-NEXT:    vldr s4, [r0]
; CHECK-NEXT:    vcmp.f32 s2, #0
; CHECK-NEXT:    vmrs APSR_nzcv, fpscr
; CHECK-NEXT:    vcmp.f32 s4, #0
; CHECK-NEXT:    cset r12, ne
; CHECK-NEXT:    vmrs APSR_nzcv, fpscr
; CHECK-NEXT:    cset r3, ne
; CHECK-NEXT:    orr.w r3, r3, r12
; CHECK-NEXT:    lsls r3, r3, #31
; CHECK-NEXT:    beq .LBB0_3
; CHECK-NEXT:  @ %bb.2: @ %if.then
; CHECK-NEXT:    @ in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    @APP
; CHECK-NEXT:    vabs.f32 s6, s4
; CHECK-NEXT:    @NO_APP
; CHECK-NEXT:    @APP
; CHECK-NEXT:    vabs.f32 s8, s2
; CHECK-NEXT:    @NO_APP
; CHECK-NEXT:    vsub.f32 s2, s4, s2
; CHECK-NEXT:    vadd.f32 s6, s8, s6
; CHECK-NEXT:    @APP
; CHECK-NEXT:    vabs.f32 s2, s2
; CHECK-NEXT:    @NO_APP
; CHECK-NEXT:    vdiv.f32 s2, s2, s6
; CHECK-NEXT:    vadd.f32 s0, s2, s0
; CHECK-NEXT:  .LBB0_3: @ %if.end
; CHECK-NEXT:    @ in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    adds r1, #4
; CHECK-NEXT:    adds r0, #4
; CHECK-NEXT:    subs r2, #1
; CHECK-NEXT:    bne .LBB0_1
; CHECK-NEXT:  @ %bb.4: @ %while.end
; CHECK-NEXT:    bx lr
; CHECK-NEXT:    .p2align 2
; CHECK-NEXT:  @ %bb.5:
; CHECK-NEXT:  .LCPI0_0:
; CHECK-NEXT:    .long 0x00000000 @ float 0
entry:
  %cmp.not13 = icmp eq i32 %blockSize, 0
  br i1 %cmp.not13, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %pA.addr.017 = phi ptr [ %incdec.ptr, %if.end ], [ %pA, %entry ]
  %pB.addr.016 = phi ptr [ %incdec.ptr1, %if.end ], [ %pB, %entry ]
  %blockSize.addr.015 = phi i32 [ %dec, %if.end ], [ %blockSize, %entry ]
  %accum.014 = phi float [ %accum.1, %if.end ], [ 0.000000e+00, %entry ]
  %incdec.ptr = getelementptr inbounds nuw i8, ptr %pA.addr.017, i32 4
  %0 = load float, ptr %pA.addr.017, align 4
  %incdec.ptr1 = getelementptr inbounds nuw i8, ptr %pB.addr.016, i32 4
  %1 = load float, ptr %pB.addr.016, align 4
  %cmp4 = fcmp fast une float %0, 0.000000e+00
  %cmp5 = fcmp fast une float %1, 0.000000e+00
  %or.cond = select i1 %cmp4, i1 true, i1 %cmp5
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %2 = tail call fast nofpclass(nan inf) float asm "vabs.f32\09$0, $1", "=t,t"(float nofpclass(nan inf) %0) #1
  %3 = tail call fast nofpclass(nan inf) float asm "vabs.f32\09$0, $1", "=t,t"(float nofpclass(nan inf) %1) #1
  %add = fadd fast float %3, %2
  %sub = fsub fast float %0, %1
  %4 = tail call fast nofpclass(nan inf) float asm "vabs.f32\09$0, $1", "=t,t"(float nofpclass(nan inf) %sub) #1
  %div = fdiv fast float %4, %add
  %add6 = fadd fast float %div, %accum.014
  br label %if.end

if.end:                                           ; preds = %while.body, %if.then
  %accum.1 = phi nsz float [ %add6, %if.then ], [ %accum.014, %while.body ]
  %dec = add i32 %blockSize.addr.015, -1
  %cmp.not = icmp eq i32 %dec, 0
  br i1 %cmp.not, label %while.end, label %while.body

while.end:                                        ; preds = %if.end, %entry
  %accum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %accum.1, %if.end ]
  ret float %accum.0.lcssa
}
