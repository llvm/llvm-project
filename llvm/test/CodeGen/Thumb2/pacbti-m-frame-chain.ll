; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=thumbv8.1m.main-none-eabi < %s --force-dwarf-frame-section -frame-pointer=all -mattr=+aapcs-frame-chain | FileCheck %s

; int test1() {
;     return 0;
; }
; Here, r11 is used as the frame pointer before it is pushed to the stack, so
; it's value isn't preserved.
define i32 @test1() "sign-return-address"="non-leaf" {
; CHECK-LABEL: test1:
; CHECK:         .cfi_sections .debug_frame
; CHECK-NEXT:    .cfi_startproc
; CHECK-NEXT:  @ %bb.0: @ %entry
; CHECK-NEXT:    pac r12, lr, sp
; CHECK-NEXT:    .save {r11, ra_auth_code, lr}
; CHECK-NEXT:    push.w {r11, r12, lr}
; CHECK-NEXT:    .cfi_def_cfa_offset 12
; CHECK-NEXT:    .cfi_offset lr, -4
; CHECK-NEXT:    .cfi_offset ra_auth_code, -8
; CHECK-NEXT:    .cfi_offset r11, -12
; CHECK-NEXT:    .setfp r11, sp
; CHECK-NEXT:    mov r11, sp
; CHECK-NEXT:    .cfi_def_cfa_register r11
; CHECK-NEXT:    movs r0, #0
; CHECK-NEXT:    pop.w {r11, r12, lr}
; CHECK-NEXT:    aut r12, lr, sp
; CHECK-NEXT:    bx lr
entry:
    ret i32 0
}

; void foo(int n) {
;   int a[n];
;   bar(a);
; }
define dso_local void @test2(i32 noundef %n) "sign-return-address"="non-leaf" {
; CHECK-LABEL: test2:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  @ %bb.0: @ %entry
; CHECK-NEXT:    pac r12, lr, sp
; CHECK-NEXT:    .save {r4, r7, r11, ra_auth_code, lr}
; CHECK-NEXT:    push.w {r4, r7, r11, r12, lr}
; CHECK-NEXT:    .cfi_def_cfa_offset 20
; CHECK-NEXT:    .cfi_offset lr, -4
; CHECK-NEXT:    .cfi_offset ra_auth_code, -8
; CHECK-NEXT:    .cfi_offset r11, -12
; CHECK-NEXT:    .cfi_offset r7, -16
; CHECK-NEXT:    .cfi_offset r4, -20
; CHECK-NEXT:    .setfp r11, sp, #8
; CHECK-NEXT:    add.w r11, sp, #8
; CHECK-NEXT:    .cfi_def_cfa r11, 12
; CHECK-NEXT:    .pad #4
; CHECK-NEXT:    sub sp, #4
; CHECK-NEXT:    movs r1, #7
; CHECK-NEXT:    add.w r0, r1, r0, lsl #2
; CHECK-NEXT:    bic r0, r0, #7
; CHECK-NEXT:    sub.w r0, sp, r0
; CHECK-NEXT:    mov sp, r0
; CHECK-NEXT:    bl take_ptr
; CHECK-NEXT:    sub.w r4, r11, #8
; CHECK-NEXT:    mov sp, r4
; CHECK-NEXT:    pop.w {r4, r7, r11, r12, lr}
; CHECK-NEXT:    aut r12, lr, sp
; CHECK-NEXT:    bx lr
entry:
  %vla = alloca i32, i32 %n, align 4
  call void @take_ptr(ptr noundef nonnull %vla)
  ret void
}

; void test3(int c, float e, int z) {
;   if (c)
;     knr();
;   take_ptr(alloca(z));
;   if (e)
;     knr();
; }
define void @test3(i32 noundef %c, float noundef %e, i32 noundef %z) "sign-return-address"="non-leaf" {
; CHECK-LABEL: test3:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  @ %bb.0: @ %entry
; CHECK-NEXT:    pac r12, lr, sp
; CHECK-NEXT:    .save {r4, r5, r6, r7, r11, ra_auth_code, lr}
; CHECK-NEXT:    push.w {r4, r5, r6, r7, r11, r12, lr}
; CHECK-NEXT:    .cfi_def_cfa_offset 28
; CHECK-NEXT:    .cfi_offset lr, -4
; CHECK-NEXT:    .cfi_offset ra_auth_code, -8
; CHECK-NEXT:    .cfi_offset r11, -12
; CHECK-NEXT:    .cfi_offset r7, -16
; CHECK-NEXT:    .cfi_offset r6, -20
; CHECK-NEXT:    .cfi_offset r5, -24
; CHECK-NEXT:    .cfi_offset r4, -28
; CHECK-NEXT:    .setfp r11, sp, #16
; CHECK-NEXT:    add.w r11, sp, #16
; CHECK-NEXT:    .cfi_def_cfa r11, 12
; CHECK-NEXT:    .pad #4
; CHECK-NEXT:    sub sp, #4
; CHECK-NEXT:    cmp r0, #0
; CHECK-NEXT:    mov r5, r2
; CHECK-NEXT:    mov r4, r1
; CHECK-NEXT:    it ne
; CHECK-NEXT:    blne knr
; CHECK-NEXT:    adds r0, r5, #7
; CHECK-NEXT:    bic r0, r0, #7
; CHECK-NEXT:    sub.w r0, sp, r0
; CHECK-NEXT:    mov sp, r0
; CHECK-NEXT:    bl take_ptr
; CHECK-NEXT:    mov r0, r4
; CHECK-NEXT:    movs r1, #0
; CHECK-NEXT:    bl __aeabi_fcmpeq
; CHECK-NEXT:    cmp r0, #0
; CHECK-NEXT:    it eq
; CHECK-NEXT:    bleq knr
; CHECK-NEXT:    sub.w r4, r11, #16
; CHECK-NEXT:    mov sp, r4
; CHECK-NEXT:    pop.w {r4, r5, r6, r7, r11, r12, lr}
; CHECK-NEXT:    aut r12, lr, sp
; CHECK-NEXT:    bx lr
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @knr()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %0 = alloca i8, i32 %z, align 8
  call void @take_ptr(ptr noundef nonnull %0)
  %tobool1 = fcmp une float %e, 0.000000e+00
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @knr()
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  ret void
}

declare void @knr(...)
declare void @take_ptr(ptr noundef)
