; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc --force-dwarf-frame-section %s -o - | FileCheck %s
; RUN: llc --filetype=obj %s -o - | llvm-readelf --unwind - | FileCheck %s --check-prefix=UNWIND
target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "thumbv8.1m.main-arm-none-eabi"

; C++
; int g(int);
;
; int f(int n, ...) {
;   __builtin_va_list ap;
;   __builtin_va_start(ap, n);
;   int s = 0;
;   for (int i = 0; i < n; ++i)
;     s += g(__builtin_va_arg(ap, int));
;   __builtin_va_end(ap);
;   return s;
; }

%"struct.std::__va_list" = type { ptr }

define hidden i32 @_Z1fiz(i32 %n, ...) local_unnamed_addr #0 {
; CHECK-LABEL: _Z1fiz:
; CHECK:         .cfi_sections .debug_frame
; CHECK-NEXT:    .cfi_startproc
; CHECK-NEXT:  @ %bb.0: @ %entry
; CHECK-NEXT:    pac r12, lr, sp
; CHECK-NEXT:    .pad #12
; CHECK-NEXT:    sub sp, #12
; CHECK-NEXT:    .cfi_def_cfa_offset 12
; CHECK-NEXT:    .save {r4, r5, r7, ra_auth_code, lr}
; CHECK-NEXT:    push.w {r4, r5, r7, r12, lr}
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset lr, -16
; CHECK-NEXT:    .cfi_offset ra_auth_code, -20
; CHECK-NEXT:    .cfi_offset r7, -24
; CHECK-NEXT:    .cfi_offset r5, -28
; CHECK-NEXT:    .cfi_offset r4, -32
; CHECK-NEXT:    .pad #8
; CHECK-NEXT:    sub sp, #8
; CHECK-NEXT:    .cfi_def_cfa_offset 40
; CHECK-NEXT:    mov r4, r0
; CHECK-NEXT:    add r0, sp, #28
; CHECK-NEXT:    movs r5, #0
; CHECK-NEXT:    stm r0!, {r1, r2, r3}
; CHECK-NEXT:    add r0, sp, #28
; CHECK-NEXT:    cmp r4, #1
; CHECK-NEXT:    str r0, [sp, #4]
; CHECK-NEXT:    blt .LBB0_2
; CHECK-NEXT:  .LBB0_1: @ %for.body
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr r0, [sp, #4]
; CHECK-NEXT:    adds r1, r0, #4
; CHECK-NEXT:    str r1, [sp, #4]
; CHECK-NEXT:    ldr r0, [r0]
; CHECK-NEXT:    bl _Z1gi
; CHECK-NEXT:    add r5, r0
; CHECK-NEXT:    subs r4, #1
; CHECK-NEXT:    bne .LBB0_1
; CHECK-NEXT:  .LBB0_2: @ %for.cond.cleanup
; CHECK-NEXT:    mov r0, r5
; CHECK-NEXT:    add sp, #8
; CHECK-NEXT:    pop.w {r4, r5, r7, r12, lr}
; CHECK-NEXT:    add sp, #12
; CHECK-NEXT:    aut r12, lr, sp
; CHECK-NEXT:    bx lr
entry:
  %ap = alloca %"struct.std::__va_list", align 4
  call void @llvm.va_start(ptr nonnull %ap)
  %cmp7 = icmp sgt i32 %n, 0
  br i1 %cmp7, label %for.body.lr.ph, label %for.cond.cleanup

for.body.lr.ph:                                   ; preds = %entry
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %s.0.lcssa = phi i32 [ 0, %entry ], [ %add, %for.body ]
  call void @llvm.va_end(ptr nonnull %ap)
  ret i32 %s.0.lcssa

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %i.09 = phi i32 [ 0, %for.body.lr.ph ], [ %inc, %for.body ]
  %s.08 = phi i32 [ 0, %for.body.lr.ph ], [ %add, %for.body ]
  %argp.cur = load ptr, ptr %ap, align 4
  %argp.next = getelementptr inbounds i8, ptr %argp.cur, i32 4
  store ptr %argp.next, ptr %ap, align 4
  %0 = load i32, ptr %argp.cur, align 4
  %call = call i32 @_Z1gi(i32 %0)
  %add = add nsw i32 %call, %s.08
  %inc = add nuw nsw i32 %i.09, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

declare void @llvm.va_start(ptr) #1
declare void @llvm.va_end(ptr) #1

declare dso_local i32 @_Z1gi(i32) local_unnamed_addr

attributes #0 = { optsize "sign-return-address"="non-leaf"}
attributes #1 = { nounwind "sign-return-address"="non-leaf"}

!llvm.module.flags = !{!0, !1, !2}

!0 = !{i32 8, !"branch-target-enforcement", i32 0}
!1 = !{i32 8, !"sign-return-address", i32 1}
!2 = !{i32 8, !"sign-return-address-all", i32 0}

; UNWIND-LABEL: FunctionAddress
; UNWIND:      0x01      ; vsp = vsp + 8
; UNWIND-NEXT: 0x80 0x0B ; pop {r4, r5, r7}
; UNWIND-NEXT: 0xB4      ; pop ra_auth_code
; UNWIND-NEXT: 0x84 0x00 ; pop {lr}
; UNWIND-NEXT: 0x02      ; vsp = vsp + 12

