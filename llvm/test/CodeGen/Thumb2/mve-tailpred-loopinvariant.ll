; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=thumbv8.1m.main-none-none-eabi -mattr=+mve -verify-machineinstrs %s -o - | FileCheck %s

; This test has an instruction that gets sunk into the loop, that is a
; active.lane.mask operand. (%exitcount.ptrcnt.to.int = ptrtoint). We
; need to make sure it is loop invariant.

define i32 @a(ptr readnone %b, ptr %c) {
; CHECK-LABEL: a:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r4, r5, r6, lr}
; CHECK-NEXT:    push {r4, r5, r6, lr}
; CHECK-NEXT:    .vsave {d8, d9, d10, d11, d12, d13, d14, d15}
; CHECK-NEXT:    vpush {d8, d9, d10, d11, d12, d13, d14, d15}
; CHECK-NEXT:    .pad #64
; CHECK-NEXT:    sub sp, #64
; CHECK-NEXT:    cmp r0, r1
; CHECK-NEXT:    bls .LBB0_3
; CHECK-NEXT:  @ %bb.1: @ %while.body.preheader
; CHECK-NEXT:    subs r2, r0, r1
; CHECK-NEXT:    movs r3, #1
; CHECK-NEXT:    add.w r0, r2, #15
; CHECK-NEXT:    vdup.32 q1, r2
; CHECK-NEXT:    bic r0, r0, #15
; CHECK-NEXT:    adr r2, .LCPI0_1
; CHECK-NEXT:    subs r0, #16
; CHECK-NEXT:    vldrw.u32 q4, [r2]
; CHECK-NEXT:    adr r2, .LCPI0_2
; CHECK-NEXT:    add r5, sp, #32
; CHECK-NEXT:    add.w lr, r3, r0, lsr #4
; CHECK-NEXT:    adr r3, .LCPI0_0
; CHECK-NEXT:    vldrw.u32 q5, [r2]
; CHECK-NEXT:    adr r2, .LCPI0_3
; CHECK-NEXT:    vldrw.u32 q0, [r3]
; CHECK-NEXT:    vldrw.u32 q6, [r2]
; CHECK-NEXT:    add r3, sp, #16
; CHECK-NEXT:    add r6, sp, #48
; CHECK-NEXT:    movs r0, #0
; CHECK-NEXT:    vmov.i8 q2, #0x0
; CHECK-NEXT:    vmov.i8 q3, #0xff
; CHECK-NEXT:    mov r2, r1
; CHECK-NEXT:    vstrw.32 q0, [sp] @ 16-byte Spill
; CHECK-NEXT:  .LBB0_2: @ %vector.body
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    vldrw.u32 q0, [sp] @ 16-byte Reload
; CHECK-NEXT:    adds r4, r1, r0
; CHECK-NEXT:    vqadd.u32 q7, q0, r0
; CHECK-NEXT:    vcmp.u32 hi, q1, q7
; CHECK-NEXT:    vpsel q7, q3, q2
; CHECK-NEXT:    vstrh.32 q7, [r5, #8]
; CHECK-NEXT:    vqadd.u32 q7, q4, r0
; CHECK-NEXT:    vcmp.u32 hi, q1, q7
; CHECK-NEXT:    vpsel q7, q3, q2
; CHECK-NEXT:    vstrh.32 q7, [r5]
; CHECK-NEXT:    vqadd.u32 q7, q5, r0
; CHECK-NEXT:    vcmp.u32 hi, q1, q7
; CHECK-NEXT:    vpsel q7, q3, q2
; CHECK-NEXT:    vstrh.32 q7, [r3, #8]
; CHECK-NEXT:    vqadd.u32 q7, q6, r0
; CHECK-NEXT:    vcmp.u32 hi, q1, q7
; CHECK-NEXT:    adds r0, #16
; CHECK-NEXT:    vpsel q7, q3, q2
; CHECK-NEXT:    vstrh.32 q7, [r3]
; CHECK-NEXT:    vldrw.u32 q7, [r5]
; CHECK-NEXT:    vcmp.i16 ne, q7, zr
; CHECK-NEXT:    vpsel q7, q3, q2
; CHECK-NEXT:    vstrb.16 q7, [r6, #8]
; CHECK-NEXT:    vldrw.u32 q7, [r3]
; CHECK-NEXT:    vcmp.i16 ne, q7, zr
; CHECK-NEXT:    vpsel q7, q3, q2
; CHECK-NEXT:    vstrb.16 q7, [r6]
; CHECK-NEXT:    vidup.u8 q7, r4, #1
; CHECK-NEXT:    vldrw.u32 q0, [r6]
; CHECK-NEXT:    vpt.i8 ne, q0, zr
; CHECK-NEXT:    vstrbt.8 q7, [r2], #16
; CHECK-NEXT:    le lr, .LBB0_2
; CHECK-NEXT:  .LBB0_3: @ %while.end
; CHECK-NEXT:    add sp, #64
; CHECK-NEXT:    vpop {d8, d9, d10, d11, d12, d13, d14, d15}
; CHECK-NEXT:    pop {r4, r5, r6, pc}
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  @ %bb.4:
; CHECK-NEXT:  .LCPI0_0:
; CHECK-NEXT:    .long 12 @ 0xc
; CHECK-NEXT:    .long 13 @ 0xd
; CHECK-NEXT:    .long 14 @ 0xe
; CHECK-NEXT:    .long 15 @ 0xf
; CHECK-NEXT:  .LCPI0_1:
; CHECK-NEXT:    .long 8 @ 0x8
; CHECK-NEXT:    .long 9 @ 0x9
; CHECK-NEXT:    .long 10 @ 0xa
; CHECK-NEXT:    .long 11 @ 0xb
; CHECK-NEXT:  .LCPI0_2:
; CHECK-NEXT:    .long 4 @ 0x4
; CHECK-NEXT:    .long 5 @ 0x5
; CHECK-NEXT:    .long 6 @ 0x6
; CHECK-NEXT:    .long 7 @ 0x7
; CHECK-NEXT:  .LCPI0_3:
; CHECK-NEXT:    .long 0 @ 0x0
; CHECK-NEXT:    .long 1 @ 0x1
; CHECK-NEXT:    .long 2 @ 0x2
; CHECK-NEXT:    .long 3 @ 0x3
entry:
  %cmp3 = icmp ugt ptr %b, %c
  br i1 %cmp3, label %while.body.preheader, label %while.end

while.body.preheader:                             ; preds = %entry
  %c5 = ptrtoint ptr %c to i32
  %0 = sub i32 0, %c5
  %uglygep = getelementptr i8, ptr %b, i32 %0
  %exitcount.ptrcnt.to.int = ptrtoint ptr %uglygep to i32
  %n.rnd.up = add i32 %exitcount.ptrcnt.to.int, 15
  %n.vec = and i32 %n.rnd.up, -16
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %while.body.preheader
  %index = phi i32 [ 0, %while.body.preheader ], [ %index.next, %vector.body ]
  %next.gep = getelementptr i8, ptr %c, i32 %index
  %1 = or disjoint i32 %index, 1
  %next.gep7 = getelementptr i8, ptr %c, i32 %1
  %2 = or disjoint i32 %index, 2
  %next.gep8 = getelementptr i8, ptr %c, i32 %2
  %3 = or disjoint i32 %index, 3
  %next.gep9 = getelementptr i8, ptr %c, i32 %3
  %4 = or disjoint i32 %index, 4
  %next.gep10 = getelementptr i8, ptr %c, i32 %4
  %5 = or disjoint i32 %index, 5
  %next.gep11 = getelementptr i8, ptr %c, i32 %5
  %6 = or disjoint i32 %index, 6
  %next.gep12 = getelementptr i8, ptr %c, i32 %6
  %7 = or disjoint i32 %index, 7
  %next.gep13 = getelementptr i8, ptr %c, i32 %7
  %8 = or disjoint i32 %index, 8
  %next.gep14 = getelementptr i8, ptr %c, i32 %8
  %9 = or disjoint i32 %index, 9
  %next.gep15 = getelementptr i8, ptr %c, i32 %9
  %10 = or disjoint i32 %index, 10
  %next.gep16 = getelementptr i8, ptr %c, i32 %10
  %11 = or disjoint i32 %index, 11
  %next.gep17 = getelementptr i8, ptr %c, i32 %11
  %12 = or disjoint i32 %index, 12
  %next.gep18 = getelementptr i8, ptr %c, i32 %12
  %13 = or disjoint i32 %index, 13
  %next.gep19 = getelementptr i8, ptr %c, i32 %13
  %14 = or disjoint i32 %index, 14
  %next.gep20 = getelementptr i8, ptr %c, i32 %14
  %15 = or disjoint i32 %index, 15
  %next.gep21 = getelementptr i8, ptr %c, i32 %15
  %16 = insertelement <16 x ptr> poison, ptr %next.gep, i32 0
  %17 = insertelement <16 x ptr> %16, ptr %next.gep7, i32 1
  %18 = insertelement <16 x ptr> %17, ptr %next.gep8, i32 2
  %19 = insertelement <16 x ptr> %18, ptr %next.gep9, i32 3
  %20 = insertelement <16 x ptr> %19, ptr %next.gep10, i32 4
  %21 = insertelement <16 x ptr> %20, ptr %next.gep11, i32 5
  %22 = insertelement <16 x ptr> %21, ptr %next.gep12, i32 6
  %23 = insertelement <16 x ptr> %22, ptr %next.gep13, i32 7
  %24 = insertelement <16 x ptr> %23, ptr %next.gep14, i32 8
  %25 = insertelement <16 x ptr> %24, ptr %next.gep15, i32 9
  %26 = insertelement <16 x ptr> %25, ptr %next.gep16, i32 10
  %27 = insertelement <16 x ptr> %26, ptr %next.gep17, i32 11
  %28 = insertelement <16 x ptr> %27, ptr %next.gep18, i32 12
  %29 = insertelement <16 x ptr> %28, ptr %next.gep19, i32 13
  %30 = insertelement <16 x ptr> %29, ptr %next.gep20, i32 14
  %31 = insertelement <16 x ptr> %30, ptr %next.gep21, i32 15
  %active.lane.mask = call <16 x i1> @llvm.get.active.lane.mask.v16i1.i32(i32 %index, i32 %exitcount.ptrcnt.to.int)
  %32 = ptrtoint <16 x ptr> %31 to <16 x i32>
  %33 = trunc <16 x i32> %32 to <16 x i8>
  call void @llvm.masked.store.v16i8.p0(<16 x i8> %33, ptr %next.gep, i32 1, <16 x i1> %active.lane.mask)
  %index.next = add i32 %index, 16
  %34 = icmp eq i32 %index.next, %n.vec
  br i1 %34, label %while.end, label %vector.body

while.end:                                        ; preds = %vector.body, %entry
  ret i32 undef
}

declare <16 x i1> @llvm.get.active.lane.mask.v16i1.i32(i32, i32)
declare void @llvm.masked.store.v16i8.p0(<16 x i8>, ptr, i32 immarg, <16 x i1>)
