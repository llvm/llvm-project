; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=thumbv7m-none-none-eabi < %s  | FileCheck %s

target datalayout = "e-m:o-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"

%struct.wibble = type { [30 x i8], i8, i32 }
%struct.eggs = type { i32, [30 x i8], i8, i8, i8, [3 x i8] }

@global = external global [3 x %struct.wibble], align 4
@global.1 = external global [3 x %struct.wibble], align 4

; Test case to make sure calling an outlined function does not clobber LR used
; by a tail call in caller.
; FIXME: Currently bl OUTLINED_FUNCTION_0 clobbers LR, which in turn is used
;        by the later call to memcpy to return to the caller.
define void @test(ptr nocapture noundef writeonly %arg, i32 noundef %arg1, i8 noundef zeroext %arg2) unnamed_addr #0 {
; CHECK-LABEL: test:
; CHECK:       @ %bb.0: @ %bb
; CHECK-NEXT:    cmp r1, #2
; CHECK-NEXT:    beq .LBB0_3
; CHECK-NEXT:  @ %bb.1: @ %bb
; CHECK-NEXT:    cmp r1, #1
; CHECK-NEXT:    bne .LBB0_5
; CHECK-NEXT:  @ %bb.2: @ %bb4
; CHECK-NEXT:    bl OUTLINED_FUNCTION_0
; CHECK-NEXT:    ldr r2, .LCPI0_1
; CHECK-NEXT:    b .LBB0_4
; CHECK-NEXT:  .LBB0_3: @ %bb14
; CHECK-NEXT:    bl OUTLINED_FUNCTION_0
; CHECK-NEXT:    ldr r2, .LCPI0_0
; CHECK-NEXT:  .LBB0_4: @ %bb4
; CHECK-NEXT:    add.w r1, r2, r1, lsl #2
; CHECK-NEXT:    adds r0, #4
; CHECK-NEXT:    movs r2, #30
; CHECK-NEXT:    b __aeabi_memcpy
; CHECK-NEXT:  .LBB0_5: @ %bb24
; CHECK-NEXT:    .save {r7, lr}
; CHECK-NEXT:    push {r7, lr}
; CHECK-NEXT:    bl wombat
; CHECK-NEXT:    @APP
; CHECK-NEXT:    @NO_APP
; CHECK-NEXT:    pop {r7, pc}
; CHECK-NEXT:    .p2align 2
; CHECK-NEXT:  @ %bb.6:
; CHECK-NEXT:  .LCPI0_0:
; CHECK-NEXT:    .long global.1
; CHECK-NEXT:  .LCPI0_1:
; CHECK-NEXT:    .long global
bb:
  %gep = getelementptr inbounds %struct.eggs, ptr %arg, i32 0, i32 4
  %zext = zext i8 %arg2 to i32
  switch i32 %arg1, label %bb24 [
    i32 1, label %bb4
    i32 2, label %bb14
  ]

bb4:                                              ; preds = %bb3
  store i8 1, ptr %gep, align 4, !tbaa !6
  %gep5 = getelementptr inbounds [3 x %struct.wibble], ptr @global, i32 0, i32 %zext
  %gep6 = getelementptr inbounds [3 x %struct.wibble], ptr @global, i32 0, i32 %zext, i32 2
  %load = load i32, ptr %gep6, align 4, !tbaa !11
  %gep7 = getelementptr inbounds [3 x %struct.wibble], ptr @global, i32 0, i32 %zext, i32 1
  %load8 = load i8, ptr %gep7, align 2, !tbaa !13
  %gep9 = getelementptr inbounds %struct.eggs, ptr %arg, i32 0, i32 3
  %gep10 = getelementptr inbounds %struct.eggs, ptr %arg, i32 0, i32 2
  store i8 30, ptr %gep10, align 2, !tbaa !16
  %gep11 = getelementptr inbounds %struct.eggs, ptr %arg, i32 0, i32 1
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 1 dereferenceable(30) %gep11, ptr noundef nonnull align 4 dereferenceable(30) %gep5, i32 30, i1 false)
  br label %bb26

bb14:                                             ; preds = %bb12
  store i8 1, ptr %gep, align 4, !tbaa !6
  %gep16 = getelementptr inbounds [3 x %struct.wibble], ptr @global.1, i32 0, i32 %zext
  %gep17 = getelementptr inbounds [3 x %struct.wibble], ptr @global.1, i32 0, i32 %zext, i32 2
  %load18 = load i32, ptr %gep17, align 4, !tbaa !21
  %gep19 = getelementptr inbounds [3 x %struct.wibble], ptr @global.1, i32 0, i32 %zext, i32 1
  %load20 = load i8, ptr %gep19, align 2, !tbaa !23
  %gep21 = getelementptr inbounds %struct.eggs, ptr %arg, i32 0, i32 3
  %gep22 = getelementptr inbounds %struct.eggs, ptr %arg, i32 0, i32 2
  store i8 30, ptr %gep22, align 2, !tbaa !16
  %gep23 = getelementptr inbounds %struct.eggs, ptr %arg, i32 0, i32 1
  tail call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 1 dereferenceable(30) %gep23, ptr noundef nonnull align 4 dereferenceable(30) %gep16, i32 30, i1 false)
  br label %bb26

bb24:                                             ; preds = %bb
  tail call void @wombat()
  tail call void asm sideeffect "", ""()
  br label %bb26

bb26:                                             ; preds = %bb24, %bb14, %bb12, %bb4, %bb3
  ret void
}

declare void @wombat()

declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #2

attributes #0 = { minsize noimplicitfloat nounwind optsize }

!6 = !{!7, !9, i64 36}
!7 = !{!"", !8, i64 0, !9, i64 4, !9, i64 34, !9, i64 35, !9, i64 36, !9, i64 37}
!8 = !{!"long", !9, i64 0}
!9 = !{!"omnipotent char", !10, i64 0}
!10 = !{!"Simple C/C++ TBAA"}
!11 = !{!12, !8, i64 32}
!12 = !{!"B", !9, i64 0, !9, i64 30, !8, i64 32}
!13 = !{!12, !9, i64 30}
!14 = !{!7, !8, i64 0}
!15 = !{!7, !9, i64 35}
!16 = !{!7, !9, i64 34}
!21 = !{!22, !8, i64 32}
!22 = !{!"A", !9, i64 0, !9, i64 30, !8, i64 32}
!23 = !{!22, !9, i64 30}
