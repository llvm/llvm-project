; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc --force-dwarf-frame-section %s -o - | FileCheck %s
target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "thumbv8.1m.main-arm-none-eabi"

; int g(int, int *);
;
; int f(int n) {
;   int a[n];
;   g(n, a);
;   int s = 0;
;   for (int i = 0; i < n; ++i)
;     s += a[i];
;   return s;
; }

define hidden i32 @f(i32 %n) local_unnamed_addr #0 {
; CHECK-LABEL: f:
; CHECK:         .cfi_sections .debug_frame
; CHECK-NEXT:    .cfi_startproc
; CHECK-NEXT:  @ %bb.0: @ %entry
; CHECK-NEXT:    pac r12, lr, sp
; CHECK-NEXT:    .save {r4, r5, r6, r7, r8, r9, ra_auth_code, lr}
; CHECK-NEXT:    push.w {r4, r5, r6, r7, r8, r9, r12, lr}
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset lr, -4
; CHECK-NEXT:    .cfi_offset ra_auth_code, -8
; CHECK-NEXT:    .cfi_offset r9, -12
; CHECK-NEXT:    .cfi_offset r8, -16
; CHECK-NEXT:    .cfi_offset r7, -20
; CHECK-NEXT:    .cfi_offset r6, -24
; CHECK-NEXT:    .cfi_offset r5, -28
; CHECK-NEXT:    .cfi_offset r4, -32
; CHECK-NEXT:    .setfp r7, sp, #12
; CHECK-NEXT:    add r7, sp, #12
; CHECK-NEXT:    .cfi_def_cfa r7, 20
; CHECK-NEXT:    mov r5, r0
; CHECK-NEXT:    movs r0, #7
; CHECK-NEXT:    add.w r0, r0, r5, lsl #2
; CHECK-NEXT:    bic r0, r0, #7
; CHECK-NEXT:    sub.w r4, sp, r0
; CHECK-NEXT:    mov sp, r4
; CHECK-NEXT:    mov r0, r5
; CHECK-NEXT:    mov r1, r4
; CHECK-NEXT:    bl g
; CHECK-NEXT:    cmp r5, #1
; CHECK-NEXT:    blt .LBB0_3
; CHECK-NEXT:  @ %bb.1: @ %for.body.preheader
; CHECK-NEXT:    subs r0, r5, #1
; CHECK-NEXT:    and r12, r5, #3
; CHECK-NEXT:    cmp r0, #3
; CHECK-NEXT:    bhs .LBB0_4
; CHECK-NEXT:  @ %bb.2:
; CHECK-NEXT:    movs r2, #0
; CHECK-NEXT:    movs r0, #0
; CHECK-NEXT:    b .LBB0_6
; CHECK-NEXT:  .LBB0_3:
; CHECK-NEXT:    movs r0, #0
; CHECK-NEXT:    b .LBB0_9
; CHECK-NEXT:  .LBB0_4: @ %for.body.preheader.new
; CHECK-NEXT:    bic r0, r5, #3
; CHECK-NEXT:    movs r2, #1
; CHECK-NEXT:    subs r0, #4
; CHECK-NEXT:    sub.w r3, r4, #16
; CHECK-NEXT:    add.w lr, r2, r0, lsr #2
; CHECK-NEXT:    movs r2, #0
; CHECK-NEXT:    movs r0, #0
; CHECK-NEXT:  .LBB0_5: @ %for.body
; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    ldr r5, [r3, #16]!
; CHECK-NEXT:    adds r2, #4
; CHECK-NEXT:    add r0, r5
; CHECK-NEXT:    ldrd r5, r1, [r3, #4]
; CHECK-NEXT:    ldr r6, [r3, #12]
; CHECK-NEXT:    add r0, r5
; CHECK-NEXT:    add r0, r1
; CHECK-NEXT:    add r0, r6
; CHECK-NEXT:    le lr, .LBB0_5
; CHECK-NEXT:  .LBB0_6: @ %for.cond.cleanup.loopexit.unr-lcssa
; CHECK-NEXT:    cmp.w r12, #0
; CHECK-NEXT:    beq .LBB0_9
; CHECK-NEXT:  @ %bb.7: @ %for.body.epil
; CHECK-NEXT:    ldr.w r3, [r4, r2, lsl #2]
; CHECK-NEXT:    cmp.w r12, #1
; CHECK-NEXT:    add r0, r3
; CHECK-NEXT:    beq .LBB0_9
; CHECK-NEXT:  @ %bb.8: @ %for.body.epil.1
; CHECK-NEXT:    add.w r2, r4, r2, lsl #2
; CHECK-NEXT:    cmp.w r12, #2
; CHECK-NEXT:    ldr r1, [r2, #4]
; CHECK-NEXT:    add r0, r1
; CHECK-NEXT:    itt ne
; CHECK-NEXT:    ldrne r1, [r2, #8]
; CHECK-NEXT:    addne r0, r1
; CHECK-NEXT:  .LBB0_9: @ %for.cond.cleanup
; CHECK-NEXT:    sub.w r4, r7, #12
; CHECK-NEXT:    mov sp, r4
; CHECK-NEXT:    pop.w {r4, r5, r6, r7, r8, r9, r12, lr}
; CHECK-NEXT:    aut r12, lr, sp
; CHECK-NEXT:    bx lr
entry:
  %vla = alloca i32, i32 %n, align 4
  %call = call i32 @g(i32 %n, ptr nonnull %vla) #0
  %cmp8 = icmp sgt i32 %n, 0
  br i1 %cmp8, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %0 = add i32 %n, -1
  %xtraiter = and i32 %n, 3
  %1 = icmp ult i32 %0, 3
  br i1 %1, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body.preheader.new

for.body.preheader.new:                           ; preds = %for.body.preheader
  %unroll_iter = and i32 %n, -4
  br label %for.body

for.cond.cleanup.loopexit.unr-lcssa:              ; preds = %for.body, %for.body.preheader
  %add.lcssa.ph = phi i32 [ undef, %for.body.preheader ], [ %add.3, %for.body ]
  %i.010.unr = phi i32 [ 0, %for.body.preheader ], [ %inc.3, %for.body ]
  %s.09.unr = phi i32 [ 0, %for.body.preheader ], [ %add.3, %for.body ]
  %lcmp.mod.not = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod.not, label %for.cond.cleanup, label %for.body.epil

for.body.epil:                                    ; preds = %for.cond.cleanup.loopexit.unr-lcssa
  %arrayidx.epil = getelementptr inbounds i32, ptr %vla, i32 %i.010.unr
  %2 = load i32, ptr %arrayidx.epil, align 4
  %add.epil = add nsw i32 %2, %s.09.unr
  %epil.iter.cmp.not = icmp eq i32 %xtraiter, 1
  br i1 %epil.iter.cmp.not, label %for.cond.cleanup, label %for.body.epil.1

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit.unr-lcssa, %for.body.epil.2, %for.body.epil.1, %for.body.epil, %entry
  %s.0.lcssa = phi i32 [ 0, %entry ], [ %add.lcssa.ph, %for.cond.cleanup.loopexit.unr-lcssa ], [ %add.epil, %for.body.epil ], [ %add.epil.1, %for.body.epil.1 ], [ %add.epil.2, %for.body.epil.2 ]
  ret i32 %s.0.lcssa

for.body:                                         ; preds = %for.body, %for.body.preheader.new
  %i.010 = phi i32 [ 0, %for.body.preheader.new ], [ %inc.3, %for.body ]
  %s.09 = phi i32 [ 0, %for.body.preheader.new ], [ %add.3, %for.body ]
  %niter = phi i32 [ %unroll_iter, %for.body.preheader.new ], [ %niter.nsub.3, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %vla, i32 %i.010
  %3 = load i32, ptr %arrayidx, align 4
  %add = add nsw i32 %3, %s.09
  %inc = or disjoint i32 %i.010, 1
  %arrayidx.1 = getelementptr inbounds i32, ptr %vla, i32 %inc
  %4 = load i32, ptr %arrayidx.1, align 4
  %add.1 = add nsw i32 %4, %add
  %inc.1 = or disjoint i32 %i.010, 2
  %arrayidx.2 = getelementptr inbounds i32, ptr %vla, i32 %inc.1
  %5 = load i32, ptr %arrayidx.2, align 4
  %add.2 = add nsw i32 %5, %add.1
  %inc.2 = or disjoint i32 %i.010, 3
  %arrayidx.3 = getelementptr inbounds i32, ptr %vla, i32 %inc.2
  %6 = load i32, ptr %arrayidx.3, align 4
  %add.3 = add nsw i32 %6, %add.2
  %inc.3 = add nuw nsw i32 %i.010, 4
  %niter.nsub.3 = add i32 %niter, -4
  %niter.ncmp.3 = icmp eq i32 %niter.nsub.3, 0
  br i1 %niter.ncmp.3, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body

for.body.epil.1:                                  ; preds = %for.body.epil
  %inc.epil = add nuw nsw i32 %i.010.unr, 1
  %arrayidx.epil.1 = getelementptr inbounds i32, ptr %vla, i32 %inc.epil
  %7 = load i32, ptr %arrayidx.epil.1, align 4
  %add.epil.1 = add nsw i32 %7, %add.epil
  %epil.iter.cmp.1.not = icmp eq i32 %xtraiter, 2
  br i1 %epil.iter.cmp.1.not, label %for.cond.cleanup, label %for.body.epil.2

for.body.epil.2:                                  ; preds = %for.body.epil.1
  %inc.epil.1 = add nuw nsw i32 %i.010.unr, 2
  %arrayidx.epil.2 = getelementptr inbounds i32, ptr %vla, i32 %inc.epil.1
  %8 = load i32, ptr %arrayidx.epil.2, align 4
  %add.epil.2 = add nsw i32 %8, %add.epil.1
  br label %for.cond.cleanup
}

declare dso_local i32 @g(i32, ptr) local_unnamed_addr #0

attributes #0 = { nounwind "sign-return-address"="non-leaf"}

!llvm.module.flags = !{!0, !1, !2}

!0 = !{i32 8, !"branch-target-enforcement", i32 0}
!1 = !{i32 8, !"sign-return-address", i32 1}
!2 = !{i32 8, !"sign-return-address-all", i32 0}
