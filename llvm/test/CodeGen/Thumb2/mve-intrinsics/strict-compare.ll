; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=thumbv8.1m.main -mattr=+mve.fp -o - %s | FileCheck %s

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_f16(<8 x half> %a, <8 x half> %b) #0 {
; CHECK-LABEL: test_vcmpeqq_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f16 eq, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.eq.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_f32(<4 x float> %a, <4 x float> %b) #0 {
; CHECK-LABEL: test_vcmpeqq_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f32 eq, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.eq.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_n_f16(<8 x half> %a, half %b) #0 {
; CHECK-LABEL: test_vcmpeqq_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r0, s4
; CHECK-NEXT:    vcmp.f16 eq, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.eq.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_n_f32(<4 x float> %a, float %b) #0 {
; CHECK-LABEL: test_vcmpeqq_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r0, s4
; CHECK-NEXT:    vcmp.f32 eq, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.eq.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_m_f16(<8 x half> %a, <8 x half> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpeqq_m_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 eq, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.eq.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_m_f32(<4 x float> %a, <4 x float> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpeqq_m_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 eq, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.eq.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_m_n_f16(<8 x half> %a, half %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpeqq_m_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 eq, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.eq.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpeqq_m_n_f32(<4 x float> %a, float %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpeqq_m_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 eq, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.eq.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_f16(<8 x half> %a, <8 x half> %b) #0 {
; CHECK-LABEL: test_vcmpneq_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f16 ne, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.ne.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_f32(<4 x float> %a, <4 x float> %b) #0 {
; CHECK-LABEL: test_vcmpneq_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f32 ne, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.ne.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_n_f16(<8 x half> %a, half %b) #0 {
; CHECK-LABEL: test_vcmpneq_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r0, s4
; CHECK-NEXT:    vcmp.f16 ne, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.ne.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_n_f32(<4 x float> %a, float %b) #0 {
; CHECK-LABEL: test_vcmpneq_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r0, s4
; CHECK-NEXT:    vcmp.f32 ne, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.ne.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_m_f16(<8 x half> %a, <8 x half> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpneq_m_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 ne, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.ne.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_m_f32(<4 x float> %a, <4 x float> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpneq_m_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 ne, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.ne.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_m_n_f16(<8 x half> %a, half %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpneq_m_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 ne, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.ne.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpneq_m_n_f32(<4 x float> %a, float %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpneq_m_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 ne, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.ne.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_f16(<8 x half> %a, <8 x half> %b) #0 {
; CHECK-LABEL: test_vcmpgeq_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f16 ge, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.ge.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_f32(<4 x float> %a, <4 x float> %b) #0 {
; CHECK-LABEL: test_vcmpgeq_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f32 ge, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.ge.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_n_f16(<8 x half> %a, half %b) #0 {
; CHECK-LABEL: test_vcmpgeq_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r0, s4
; CHECK-NEXT:    vcmp.f16 ge, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.ge.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_n_f32(<4 x float> %a, float %b) #0 {
; CHECK-LABEL: test_vcmpgeq_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r0, s4
; CHECK-NEXT:    vcmp.f32 ge, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.ge.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_m_f16(<8 x half> %a, <8 x half> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgeq_m_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 ge, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.ge.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_m_f32(<4 x float> %a, <4 x float> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgeq_m_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 ge, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.ge.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_m_n_f16(<8 x half> %a, half %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgeq_m_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 ge, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.ge.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgeq_m_n_f32(<4 x float> %a, float %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgeq_m_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 ge, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.ge.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_f16(<8 x half> %a, <8 x half> %b) #0 {
; CHECK-LABEL: test_vcmpgtq_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f16 gt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.gt.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_f32(<4 x float> %a, <4 x float> %b) #0 {
; CHECK-LABEL: test_vcmpgtq_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f32 gt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.gt.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_n_f16(<8 x half> %a, half %b) #0 {
; CHECK-LABEL: test_vcmpgtq_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r0, s4
; CHECK-NEXT:    vcmp.f16 gt, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.gt.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_n_f32(<4 x float> %a, float %b) #0 {
; CHECK-LABEL: test_vcmpgtq_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r0, s4
; CHECK-NEXT:    vcmp.f32 gt, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.gt.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_m_f16(<8 x half> %a, <8 x half> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgtq_m_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 gt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.gt.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_m_f32(<4 x float> %a, <4 x float> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgtq_m_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 gt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.gt.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_m_n_f16(<8 x half> %a, half %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgtq_m_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 gt, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.gt.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpgtq_m_n_f32(<4 x float> %a, float %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpgtq_m_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 gt, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.gt.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_f16(<8 x half> %a, <8 x half> %b) #0 {
; CHECK-LABEL: test_vcmpleq_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f16 le, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.le.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_f32(<4 x float> %a, <4 x float> %b) #0 {
; CHECK-LABEL: test_vcmpleq_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f32 le, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.le.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_n_f16(<8 x half> %a, half %b) #0 {
; CHECK-LABEL: test_vcmpleq_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r0, s4
; CHECK-NEXT:    vcmp.f16 le, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.le.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_n_f32(<4 x float> %a, float %b) #0 {
; CHECK-LABEL: test_vcmpleq_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r0, s4
; CHECK-NEXT:    vcmp.f32 le, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.le.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_m_f16(<8 x half> %a, <8 x half> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpleq_m_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 le, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.le.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_m_f32(<4 x float> %a, <4 x float> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpleq_m_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 le, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.le.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_m_n_f16(<8 x half> %a, half %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpleq_m_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 le, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.le.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpleq_m_n_f32(<4 x float> %a, float %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpleq_m_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 le, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.le.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_f16(<8 x half> %a, <8 x half> %b) #0 {
; CHECK-LABEL: test_vcmpltq_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f16 lt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.lt.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_f32(<4 x float> %a, <4 x float> %b) #0 {
; CHECK-LABEL: test_vcmpltq_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vcmp.f32 lt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.lt.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_n_f16(<8 x half> %a, half %b) #0 {
; CHECK-LABEL: test_vcmpltq_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r0, s4
; CHECK-NEXT:    vcmp.f16 lt, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %0 = tail call <8 x i1> @llvm.arm.mve.cmp.lt.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_n_f32(<4 x float> %a, float %b) #0 {
; CHECK-LABEL: test_vcmpltq_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r0, s4
; CHECK-NEXT:    vcmp.f32 lt, q0, r0
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %0 = tail call <4 x i1> @llvm.arm.mve.cmp.lt.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %1 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %0) #2
  %2 = trunc nuw i32 %1 to i16
  ret i16 %2
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_m_f16(<8 x half> %a, <8 x half> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpltq_m_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 lt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.lt.v8i1.v8f16(<8 x half> %a, <8 x half> %b) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_m_f32(<4 x float> %a, <4 x float> %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpltq_m_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 lt, q0, q1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.lt.v4i1.v4f32(<4 x float> %a, <4 x float> %b) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_m_n_f16(<8 x half> %a, half %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpltq_m_n_f16:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov.f16 r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f16 lt, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <8 x i1> @llvm.arm.mve.pred.i2v.v8i1(i32 %0) #2
  %.splatinsert = insertelement <8 x half> poison, half %b, i64 0
  %.splat = shufflevector <8 x half> %.splatinsert, <8 x half> poison, <8 x i32> zeroinitializer
  %2 = tail call <8 x i1> @llvm.arm.mve.cmp.lt.v8i1.v8f16(<8 x half> %a, <8 x half> %.splat) #2
  %3 = and <8 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v8i1(<8 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

define arm_aapcs_vfpcc zeroext i16 @test_vcmpltq_m_n_f32(<4 x float> %a, float %b, i16 zeroext %p) #0 {
; CHECK-LABEL: test_vcmpltq_m_n_f32:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    vmov r1, s4
; CHECK-NEXT:    vmsr p0, r0
; CHECK-NEXT:    vpst
; CHECK-NEXT:    vcmpt.f32 lt, q0, r1
; CHECK-NEXT:    vmrs r0, p0
; CHECK-NEXT:    bx lr
entry:
  %0 = zext i16 %p to i32
  %1 = tail call <4 x i1> @llvm.arm.mve.pred.i2v.v4i1(i32 %0) #2
  %.splatinsert = insertelement <4 x float> poison, float %b, i64 0
  %.splat = shufflevector <4 x float> %.splatinsert, <4 x float> poison, <4 x i32> zeroinitializer
  %2 = tail call <4 x i1> @llvm.arm.mve.cmp.lt.v4i1.v4f32(<4 x float> %a, <4 x float> %.splat) #2
  %3 = and <4 x i1> %1, %2
  %4 = tail call range(i32 0, 65536) i32 @llvm.arm.mve.pred.v2i.v4i1(<4 x i1> %3) #2
  %5 = trunc nuw i32 %4 to i16
  ret i16 %5
}

attributes #0 = { strictfp }
