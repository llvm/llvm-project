; LLVM IR for the test can be generated by SYCL Clang Compiler -
; see https://github.com/intel/llvm
; SYCL source code can be found below:

; struct st {
;   int a;
;   float b;
; };
;
; union un {
;   int a;
;   char c[4];
; };
;
; class A {
; public:
;   A(int a) {
;     m_val = a;
;   }
;   A(const A &a) {
;     m_val = a.m_val;
;   }
; private:
;     int m_val;
; };
;
; typedef int myInt;

; void foo() {
;   int a=123;
;   myInt myA = 321;
;   int b = __builtin_intel_fpga_reg(a);
;   int myB = __builtin_intel_fpga_reg(myA);
;   int c = __builtin_intel_fpga_reg(2.0f);
;   int d = __builtin_intel_fpga_reg( __builtin_intel_fpga_reg( b+12 ));
;   int e = __builtin_intel_fpga_reg( __builtin_intel_fpga_reg( a+b ));
;   int f;
;   f = __builtin_intel_fpga_reg(a);
;
;   struct st i = {1, 5.0f};
;   struct st i2 = i;
;   struct st ii = __builtin_intel_fpga_reg(i);
;   struct st iii;
;   iii = __builtin_intel_fpga_reg(ii);
;
;   struct st *iiii = __builtin_intel_fpga_reg(&iii);
;
;   union un u1 = {1};
;   union un u2, *u3;
;   u2 = __builtin_intel_fpga_reg(u1);
;
;   u3 = __builtin_intel_fpga_reg(&u2);
;
;   A ca(213);
;   A cb = __builtin_intel_fpga_reg(ca);
; }

; RUN: llc -verify-machineinstrs -O0 -mtriple=spirv64-unknown-unknown --spirv-ext=+SPV_INTEL_fpga_reg %s -o - | FileCheck %s


; CHECK: OpCapability FPGARegINTEL
; CHECK: OpExtension "SPV_INTEL_fpga_reg"

; CHECK-DAG: %[[#TYPE_INT64:]] = OpTypeInt 64 0
; CHECK-DAG: %[[#TYPE_INT32:]] = OpTypeInt 32 0
; CHECK-DAG: %[[#TYPE_INT8:]] = OpTypeInt 8 0
; CHECK-DAG: %[[#TYPE_PTR:]] = OpTypePointer Function %[[#TYPE_INT8]]

target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "spir64-unknown-linux"

%struct._ZTS2st.st = type { i32, float }
%union._ZTS2un.un = type { i32 }
%"class._ZTSZ4mainE3$_0.anon" = type { i8 }
%class._ZTS1A.A = type { i32 }

$_ZN1AC1Ei = comdat any

$_ZN1AC2Ei = comdat any

@.str = private unnamed_addr addrspace(1) constant [25 x i8] c"__builtin_intel_fpga_reg\00", section "llvm.metadata"
@.str.1 = private unnamed_addr addrspace(1) constant [9 x i8] c"test.cpp\00", section "llvm.metadata"
@__const._Z3foov.i = private unnamed_addr addrspace(1) constant %struct._ZTS2st.st { i32 1, float 5.000000e+00 }, align 4
@__const._Z3foov.u1 = private unnamed_addr addrspace(1) constant %union._ZTS2un.un { i32 1 }, align 4

; Function Attrs: nounwind
define spir_kernel void @_ZTSZ4mainE11fake_kernel() #0 !kernel_arg_addr_space !4 !kernel_arg_access_qual !4 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !4 {
entry:
  %0 = alloca %"class._ZTSZ4mainE3$_0.anon", align 1
  call void @llvm.lifetime.start.p0(i64 1, ptr %0) #4
  %1 = addrspacecast ptr %0 to ptr addrspace(4)
  call spir_func void @"_ZZ4mainENK3$_0clEv"(ptr addrspace(4) %1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %0) #4
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: inlinehint nounwind
define internal spir_func void @"_ZZ4mainENK3$_0clEv"(ptr addrspace(4) %this) #2 align 2 {
entry:
  %this.addr = alloca ptr addrspace(4), align 8
  store ptr addrspace(4) %this, ptr %this.addr, align 8
  %this1 = load ptr addrspace(4), ptr %this.addr, align 8
  call spir_func void @_Z3foov()
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nounwind
define spir_func void @_Z3foov() #3 {
entry:
  %a = alloca i32, align 4
  %myA = alloca i32, align 4
  %b = alloca i32, align 4
  %myB = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i32, align 4
  %e = alloca i32, align 4
  %f = alloca i32, align 4
  %i = alloca %struct._ZTS2st.st, align 4
  %i2 = alloca %struct._ZTS2st.st, align 4
  %ii = alloca %struct._ZTS2st.st, align 4
  %agg-temp = alloca %struct._ZTS2st.st, align 4
  %iii = alloca %struct._ZTS2st.st, align 4
  %ref.tmp = alloca %struct._ZTS2st.st, align 4
  %agg-temp2 = alloca %struct._ZTS2st.st, align 4
  %iiii = alloca ptr addrspace(4), align 8
  %u1 = alloca %union._ZTS2un.un, align 4
  %u2 = alloca %union._ZTS2un.un, align 4
  %u3 = alloca ptr addrspace(4), align 8
  %ref.tmp3 = alloca %union._ZTS2un.un, align 4
  %agg-temp4 = alloca %union._ZTS2un.un, align 4
  %ca = alloca %class._ZTS1A.A, align 4
  %cb = alloca %class._ZTS1A.A, align 4
  %agg-temp5 = alloca %class._ZTS1A.A, align 4
  %ap = alloca ptr addrspace(4), align 8
  %bp = alloca ptr addrspace(4), align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %a) #4
  store i32 123, ptr %a, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %myA) #4
  store i32 321, ptr %myA, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %b) #4
  %0 = load i32, ptr %a, align 4
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  %1 = call i32 @llvm.annotation.i32.p1(i32 %0, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 35)
  store i32 %1, ptr %b, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %myB) #4
  %2 = load i32, ptr %myA, align 4
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  %3 = call i32 @llvm.annotation.i32.p1(i32 %2, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 39)
  store i32 %3, ptr %myB, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %c) #4
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  %4 = call i32 @llvm.annotation.i32.p1(i32 1073741824, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 43)
  %5 = bitcast i32 %4 to float
  %conv = fptosi float %5 to i32
  store i32 %conv, ptr %c, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %d) #4
  %6 = load i32, ptr %b, align 4
  %add = add nsw i32 %6, 12
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  
  %7 = call i32 @llvm.annotation.i32.p1(i32 %add, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 48)
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  %8 = call i32 @llvm.annotation.i32.p1(i32 %7, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 48)
  store i32 %8, ptr %d, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %e) #4
  %9 = load i32, ptr %a, align 4
  %10 = load i32, ptr %b, align 4
  %add1 = add nsw i32 %9, %10
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  %11 = call i32 @llvm.annotation.i32.p1(i32 %add1, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 54)
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  %12 = call i32 @llvm.annotation.i32.p1(i32 %11, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 54)
  store i32 %12, ptr %e, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %f) #4
  %13 = load i32, ptr %a, align 4
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT32]] %[[#]]
  %14 = call i32 @llvm.annotation.i32.p1(i32 %13, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 62)
  store i32 %14, ptr %f, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #4
  call void @llvm.memcpy.p0.p1.i64(ptr align 4 %i, ptr addrspace(1) align 4 @__const._Z3foov.i, i64 8, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i2) #4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %i2, ptr align 4 %i, i64 8, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %ii) #4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg-temp, ptr align 4 %i, i64 8, i1 false)
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_PTR]] %[[#]]
  %15 = call ptr @llvm.ptr.annotation.p0.p1(ptr %agg-temp, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 69, ptr addrspace(1) null)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ii, ptr align 4 %15, i64 8, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %iii) #4
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp) #4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg-temp2, ptr align 4 %ii, i64 8, i1 false)
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_PTR]] %[[#]]
  %16 = call ptr @llvm.ptr.annotation.p0.p1(ptr %agg-temp2, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 80, ptr addrspace(1) null)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ref.tmp, ptr align 4 %16, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %iii, ptr align 4 %ref.tmp, i64 8, i1 false)
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp) #4
  call void @llvm.lifetime.start.p0(i64 8, ptr %iiii) #4
  %17 = ptrtoint ptr %iii to i64
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT64]] %[[#]]
  %18 = call i64 @llvm.annotation.i64(i64 %17, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 94)
  %19 = inttoptr i64 %18 to ptr
  %20 = addrspacecast ptr %19 to ptr addrspace(4)
  store ptr addrspace(4) %20, ptr %iiii, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %u1) #4
  call void @llvm.memcpy.p0.p1.i64(ptr align 4 %u1, ptr addrspace(1) align 4 @__const._Z3foov.u1, i64 4, i1 false)
  call void @llvm.lifetime.start.p0(i64 4, ptr %u2) #4
  call void @llvm.lifetime.start.p0(i64 8, ptr %u3) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %ref.tmp3) #4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg-temp4, ptr align 4 %u1, i64 4, i1 false)
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_PTR]] %[[#]]
  %21 = call ptr @llvm.ptr.annotation.p0.p1(ptr %agg-temp4, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 103, ptr addrspace(1) null)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ref.tmp3, ptr align 4 %21, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %u2, ptr align 4 %ref.tmp3, i64 4, i1 false)
  call void @llvm.lifetime.end.p0(i64 4, ptr %ref.tmp3) #4
  %22 = ptrtoint ptr %u2 to i64
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT64]] %[[#]]
  %23 = call i64 @llvm.annotation.i64(i64 %22, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 117)
  %24 = inttoptr i64 %23 to ptr
  %25 = addrspacecast ptr %24 to ptr addrspace(4)
  store ptr addrspace(4) %25, ptr %u3, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %ca) #4
  %26 = addrspacecast ptr %ca to ptr addrspace(4)
  call spir_func void @_ZN1AC1Ei(ptr addrspace(4) %26, i32 213)
  call void @llvm.lifetime.start.p0(i64 4, ptr %cb) #4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %agg-temp5, ptr align 4 %ca, i64 4, i1 false)
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_PTR]] %[[#]]
  %27 = call ptr @llvm.ptr.annotation.p0.p1(ptr %agg-temp5, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 125, ptr addrspace(1) null)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %cb, ptr align 4 %27, i64 8, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %ap) #4
  %28 = addrspacecast ptr %a to ptr addrspace(4)
  store ptr addrspace(4) %28, ptr %ap, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %bp) #4
  %29 = load ptr addrspace(4), ptr %ap, align 8
  %30 = ptrtoint ptr addrspace(4) %29 to i64
  ; CHECK: %[[#]] = OpFPGARegINTEL %[[#TYPE_INT64]] %[[#]]
  %31 = call i64 @llvm.annotation.i64(i64 %30, ptr addrspace(1) @.str, ptr addrspace(1) @.str.1, i32 137)
  %32 = inttoptr i64 %31 to ptr addrspace(4)
  store ptr addrspace(4) %32, ptr %bp, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr %bp) #4
  call void @llvm.lifetime.end.p0(i64 8, ptr %ap) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %cb) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %ca) #4
  call void @llvm.lifetime.end.p0(i64 8, ptr %u3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %u2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %u1) #4
  call void @llvm.lifetime.end.p0(i64 8, ptr %iiii) #4
  call void @llvm.lifetime.end.p0(i64 8, ptr %iii) #4
  call void @llvm.lifetime.end.p0(i64 8, ptr %ii) #4
  call void @llvm.lifetime.end.p0(i64 8, ptr %i2) #4
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %f) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %e) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %d) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %c) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %myB) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %b) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %myA) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %a) #4
  ret void
}

; Function Attrs: nounwind
declare i32 @llvm.annotation.i32.p1(i32, ptr addrspace(1), ptr addrspace(1), i32) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0.p1.i64(ptr nocapture writeonly, ptr addrspace(1) nocapture readonly, i64, i1 immarg) #1

; Function Attrs: nounwind
declare ptr @llvm.ptr.annotation.p0(ptr, ptr, ptr, i32, ptr) #4

; Function Attrs: nounwind
declare ptr @llvm.ptr.annotation.p0.p1(ptr, ptr addrspace(1), ptr addrspace(1), i32, ptr addrspace(1)) #4

; Function Attrs: nounwind
declare i64 @llvm.annotation.i64(i64, ptr addrspace(1), ptr addrspace(1), i32) #4

; Function Attrs: nounwind
define linkonce_odr spir_func void @_ZN1AC1Ei(ptr addrspace(4) %this, i32 %a) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr addrspace(4), align 8
  %a.addr = alloca i32, align 4
  store ptr addrspace(4) %this, ptr %this.addr, align 8
  store i32 %a, ptr %a.addr, align 4
  %this1 = load ptr addrspace(4), ptr %this.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  call spir_func void @_ZN1AC2Ei(ptr addrspace(4) %this1, i32 %0)
  ret void
}

; Function Attrs: nounwind
define linkonce_odr spir_func void @_ZN1AC2Ei(ptr addrspace(4) %this, i32 %a) unnamed_addr #3 comdat align 2 {
entry:
  %this.addr = alloca ptr addrspace(4), align 8
  %a.addr = alloca i32, align 4
  store ptr addrspace(4) %this, ptr %this.addr, align 8
  store i32 %a, ptr %a.addr, align 4
  %this1 = load ptr addrspace(4), ptr %this.addr, align 8
  %0 = load i32, ptr %a.addr, align 4
  store i32 %0, ptr addrspace(4) %this1, align 4
  ret void
}

attributes #0 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "uniform-work-group-size"="true" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { inlinehint nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }

!llvm.module.flags = !{!0}
!opencl.spir.version = !{!1}
!spirv.Source = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, i32 2}
!2 = !{i32 4, i32 100000}
!3 = !{!"clang version 9.0.0"}
!4 = !{}
!5 = !{!"any pointer", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C++ TBAA"}
