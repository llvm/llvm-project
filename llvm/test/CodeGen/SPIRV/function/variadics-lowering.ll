; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -mtriple=spirv64-- --passes=expand-variadics --expand-variadics-override=lowering < %s | FileCheck %s

%struct.S = type { i64, i64 }
%struct.anon = type { i32, i8, i32 }
%struct.anon.0 = type { i8, i8 }

@__const.foo.a = private unnamed_addr addrspace(1) constant { i32, i8, [3 x i8], i32 } { i32 1, i8 1, [3 x i8] zeroinitializer, i32 1 }, align 4
@__const.bar.s = private unnamed_addr addrspace(1) constant %struct.S { i64 1, i64 1 }, align 8

define spir_func void @foo() {
; CHECK-LABEL: define spir_func void @foo() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[C:%.*]] = alloca i8, align 1
; CHECK-NEXT:    [[S:%.*]] = alloca i16, align 2
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[L:%.*]] = alloca i64, align 8
; CHECK-NEXT:    [[F:%.*]] = alloca float, align 4
; CHECK-NEXT:    [[D:%.*]] = alloca double, align 8
; CHECK-NEXT:    [[A:%.*]] = alloca [[STRUCT_ANON:%.*]], align 4
; CHECK-NEXT:    [[V:%.*]] = alloca <4 x i32>, align 16
; CHECK-NEXT:    [[T:%.*]] = alloca [[STRUCT_ANON_0:%.*]], align 1
; CHECK-NEXT:    [[VARARG_BUFFER:%.*]] = alloca [[FOO_VARARG:%.*]], align 4
; CHECK-NEXT:    [[VARARG_BUFFER1:%.*]] = alloca [[FOO_VARARG_0:%.*]], align 16
; CHECK-NEXT:    [[VARARG_BUFFER2:%.*]] = alloca [[FOO_VARARG_1:%.*]], align 4
; CHECK-NEXT:    [[VARARG_BUFFER3:%.*]] = alloca [[FOO_VARARG_2:%.*]], align 8
; CHECK-NEXT:    [[VARARG_BUFFER4:%.*]] = alloca [[FOO_VARARG_3:%.*]], align 8
; CHECK-NEXT:    store i8 1, ptr [[C]], align 1
; CHECK-NEXT:    store i16 1, ptr [[S]], align 2
; CHECK-NEXT:    store i32 1, ptr [[I]], align 4
; CHECK-NEXT:    store i64 1, ptr [[L]], align 8
; CHECK-NEXT:    store float 1.000000e+00, ptr [[F]], align 4
; CHECK-NEXT:    store double 1.000000e+00, ptr [[D]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[C]], align 1
; CHECK-NEXT:    [[CONV:%.*]] = sext i8 [[TMP0]] to i32
; CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[S]], align 2
; CHECK-NEXT:    [[CONV1:%.*]] = sext i16 [[TMP1]] to i32
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[I]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[L]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[F]], align 4
; CHECK-NEXT:    [[CONV2:%.*]] = fpext float [[TMP4]] to double
; CHECK-NEXT:    [[TMP5:%.*]] = load double, ptr [[D]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[VARARG_BUFFER3]])
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_2]], ptr [[VARARG_BUFFER3]], i32 0, i32 0
; CHECK-NEXT:    store i32 [[CONV]], ptr [[TMP13]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_2]], ptr [[VARARG_BUFFER3]], i32 0, i32 1
; CHECK-NEXT:    store i32 [[CONV1]], ptr [[TMP7]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_2]], ptr [[VARARG_BUFFER3]], i32 0, i32 2
; CHECK-NEXT:    store i32 [[TMP2]], ptr [[TMP8]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_2]], ptr [[VARARG_BUFFER3]], i32 0, i32 4
; CHECK-NEXT:    store i64 [[TMP3]], ptr [[TMP9]], align 8
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_2]], ptr [[VARARG_BUFFER3]], i32 0, i32 5
; CHECK-NEXT:    store double [[CONV2]], ptr [[TMP10]], align 8
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_2]], ptr [[VARARG_BUFFER3]], i32 0, i32 6
; CHECK-NEXT:    store double [[TMP5]], ptr [[TMP11]], align 8
; CHECK-NEXT:    call spir_func void @varargs_simple(i32 0, ptr [[VARARG_BUFFER3]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[VARARG_BUFFER3]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p1.i64(ptr align 4 [[A]], ptr addrspace(1) align 4 @__const.foo.a, i64 12, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[VARARG_BUFFER2]])
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_1]], ptr [[VARARG_BUFFER2]], i32 0, i32 0
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[TMP12]], ptr [[A]], i64 12, i1 false)
; CHECK-NEXT:    call spir_func void @varargs_simple(i32 0, ptr [[VARARG_BUFFER2]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[VARARG_BUFFER2]])
; CHECK-NEXT:    store <4 x i32> splat (i32 1), ptr [[V]], align 16
; CHECK-NEXT:    [[TMP6:%.*]] = load <4 x i32>, ptr [[V]], align 16
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[VARARG_BUFFER1]])
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_0]], ptr [[VARARG_BUFFER1]], i32 0, i32 0
; CHECK-NEXT:    store <4 x i32> [[TMP6]], ptr [[TMP14]], align 16
; CHECK-NEXT:    call spir_func void @varargs_simple(i32 0, ptr [[VARARG_BUFFER1]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[VARARG_BUFFER1]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[VARARG_BUFFER]])
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds nuw [[FOO_VARARG]], ptr [[VARARG_BUFFER]], i32 0, i32 0
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[TMP15]], ptr [[T]], i64 2, i1 false)
; CHECK-NEXT:    [[TMP16:%.*]] = getelementptr inbounds nuw [[FOO_VARARG]], ptr [[VARARG_BUFFER]], i32 0, i32 1
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[TMP16]], ptr [[T]], i64 2, i1 false)
; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr inbounds nuw [[FOO_VARARG]], ptr [[VARARG_BUFFER]], i32 0, i32 2
; CHECK-NEXT:    store i32 0, ptr [[TMP17]], align 4
; CHECK-NEXT:    [[TMP18:%.*]] = getelementptr inbounds nuw [[FOO_VARARG]], ptr [[VARARG_BUFFER]], i32 0, i32 3
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[TMP18]], ptr [[T]], i64 2, i1 false)
; CHECK-NEXT:    call spir_func void @varargs_simple(i32 0, ptr [[VARARG_BUFFER]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[VARARG_BUFFER]])
; CHECK-NEXT:    [[R:%.*]] = alloca [[STRUCT_S:%.*]], align 8
; CHECK-NEXT:    call void @llvm.memcpy.p0.p1.i64(ptr align 8 [[R]], ptr addrspace(1) align 8 @__const.bar.s, i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr [[VARARG_BUFFER4]])
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_3]], ptr [[VARARG_BUFFER4]], i32 0, i32 0
; CHECK-NEXT:    store i32 1, ptr [[TMP19]], align 4
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_3]], ptr [[VARARG_BUFFER4]], i32 0, i32 2
; CHECK-NEXT:    store i64 1, ptr [[TMP20]], align 8
; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr inbounds nuw [[FOO_VARARG_3]], ptr [[VARARG_BUFFER4]], i32 0, i32 3
; CHECK-NEXT:    store double 1.000000e+00, ptr [[TMP21]], align 8
; CHECK-NEXT:    call spir_func void @varargs_complex(ptr byval([[STRUCT_S]]) align 8 [[R]], ptr byval([[STRUCT_S]]) align 8 [[S]], ptr [[VARARG_BUFFER4]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr [[VARARG_BUFFER4]])
; CHECK-NEXT:    ret void
;
entry:
  %c = alloca i8, align 1
  %s = alloca i16, align 2
  %i = alloca i32, align 4
  %l = alloca i64, align 8
  %f = alloca float, align 4
  %d = alloca double, align 8
  %a = alloca %struct.anon, align 4
  %v = alloca <4 x i32>, align 16
  %t = alloca %struct.anon.0, align 1
  store i8 1, ptr %c, align 1
  store i16 1, ptr %s, align 2
  store i32 1, ptr %i, align 4
  store i64 1, ptr %l, align 8
  store float 1.000000e+00, ptr %f, align 4
  store double 1.000000e+00, ptr %d, align 8
  %0 = load i8, ptr %c, align 1
  %conv = sext i8 %0 to i32
  %1 = load i16, ptr %s, align 2
  %conv1 = sext i16 %1 to i32
  %2 = load i32, ptr %i, align 4
  %3 = load i64, ptr %l, align 8
  %4 = load float, ptr %f, align 4
  %conv2 = fpext float %4 to double
  %5 = load double, ptr %d, align 8
  call spir_func void (i32, ...) @varargs_simple(i32 0, i32 %conv, i32 %conv1, i32 %2, i64 %3, double %conv2, double %5)
  call void @llvm.memcpy.p0.p1.i64(ptr align 4 %a, ptr addrspace(1) align 4 @__const.foo.a, i64 12, i1 false)
  call spir_func void (i32, ...) @varargs_simple(i32 0, ptr byval(%struct.anon) align 4 %a)
  store <4 x i32> splat (i32 1), ptr %v, align 16
  %6 = load <4 x i32>, ptr %v, align 16
  call spir_func void (i32, ...) @varargs_simple(i32 0, <4 x i32> %6)
  call spir_func void (i32, ...) @varargs_simple(i32 0, ptr byval(%struct.anon.0) align 1 %t, ptr byval(%struct.anon.0) align 1 %t, i32 0, ptr byval(%struct.anon.0) align 1 %t)
  %r = alloca %struct.S, align 8
  call void @llvm.memcpy.p0.p1.i64(ptr align 8 %r, ptr addrspace(1) align 8 @__const.bar.s, i64 16, i1 false)
  call spir_func void (ptr, ptr, ...) @varargs_complex(ptr byval(%struct.S) align 8 %r, ptr byval(%struct.S) align 8 %s, i32 1, i64 1, double 1.000000e+00)
  ret void
}

declare spir_func void @varargs_simple(i32 noundef, ...)

declare spir_func void @varargs_complex(ptr byval(%struct.S) align 8, ptr byval(%struct.S) align 8, ...)
