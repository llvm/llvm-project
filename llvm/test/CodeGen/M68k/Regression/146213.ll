; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=m68k-linux | FileCheck %s

; In this bug, we can see that a chain was generated that started from an ADJCALLSTACKUP
; (lowered callseq_end for fmul) and crossed over to join the unrelated chain going through
; the ADJCALLSTACKUP/DOWN for @double_arg. This resulted in an assertion firing during
; scheduling, as the ADJCALLSTACKDOWN nodes do not depend on each other. This meant that
; two ADJCALLSTACKUP (lowered callseq_end) nodes were encountered for the chain branch for
; @double_arg, but only one ADJCALLSTACKDOWN would be present as they did not depend on
; each other.

declare float @float_arg(float)
declare float @double_arg(double)

; This works correctly
define float @float_arg_test(ptr %inout) nounwind {
; CHECK-LABEL: float_arg_test:
; CHECK:       ; %bb.0: ; %start
; CHECK-NEXT:    suba.l #12, %sp
; CHECK-NEXT:    movem.l %a2, (8,%sp) ; 8-byte Folded Spill
; CHECK-NEXT:    move.l #0, (%sp)
; CHECK-NEXT:    jsr float_arg
; CHECK-NEXT:    move.l (16,%sp), %a2
; CHECK-NEXT:    move.l (%a2), %d0
; CHECK-NEXT:    move.l %d0, (%sp)
; CHECK-NEXT:    move.l #0, (4,%sp)
; CHECK-NEXT:    jsr __mulsf3
; CHECK-NEXT:    move.l %d0, (%a2)
; CHECK-NEXT:    moveq #0, %d0
; CHECK-NEXT:    movem.l (8,%sp), %a2 ; 8-byte Folded Reload
; CHECK-NEXT:    adda.l #12, %sp
; CHECK-NEXT:    rts
start:
  %_58 = call float @float_arg(float 0.000000e+00)
  %_60 = load float, ptr %inout, align 8
  %_57 = fmul float 0.000000e+00, %_60
  store float %_57, ptr %inout, align 8
  ret float 0.000000e+00
}

; This fails to find a chain
define float @double_arg_test(ptr %inout) nounwind {
; CHECK-LABEL: double_arg_test:
; CHECK:       ; %bb.0: ; %start
; CHECK-NEXT:    suba.l #12, %sp
; CHECK-NEXT:    movem.l %a2, (8,%sp) ; 8-byte Folded Spill
; CHECK-NEXT:    move.l #0, (4,%sp)
; CHECK-NEXT:    move.l #0, (%sp)
; CHECK-NEXT:    jsr double_arg
; CHECK-NEXT:    move.l (16,%sp), %a2
; CHECK-NEXT:    move.l (%a2), %d0
; CHECK-NEXT:    move.l %d0, (%sp)
; CHECK-NEXT:    move.l #0, (4,%sp)
; CHECK-NEXT:    jsr __mulsf3
; CHECK-NEXT:    move.l %d0, (%a2)
; CHECK-NEXT:    moveq #0, %d0
; CHECK-NEXT:    movem.l (8,%sp), %a2 ; 8-byte Folded Reload
; CHECK-NEXT:    adda.l #12, %sp
; CHECK-NEXT:    rts
start:
  %_58 = call float @double_arg(double 0.000000e+00)
  %_60 = load float, ptr %inout, align 8
  %_57 = fmul float 0.000000e+00, %_60
  store float %_57, ptr %inout, align 8
  ret float 0.000000e+00
}
