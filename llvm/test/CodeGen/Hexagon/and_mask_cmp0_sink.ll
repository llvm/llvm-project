; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; Test that 'and' mask is sunk to the cmp use block only if it is masking a single bit
; RUN: llc -march=hexagon --verify-machineinstrs < %s | FileCheck %s

@A = global i32 zeroinitializer

define i32 @and_sink1(i32 %a) {
; CHECK-LABEL: and_sink1:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    {
; CHECK-NEXT:     p0 = !tstbit(r0,#11)
; CHECK-NEXT:     r0 = ##A
; CHECK-NEXT:    }
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB0_1: // %bb0
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    {
; CHECK-NEXT:     if (p0) jump:nt .LBB0_1
; CHECK-NEXT:     memw(r0+#0) = #0
; CHECK-NEXT:    }
; CHECK-NEXT:  // %bb.2: // %bb2
; CHECK-NEXT:    {
; CHECK-NEXT:     r0 = #0
; CHECK-NEXT:     jumpr r31
; CHECK-NEXT:    }
  %and = and i32 %a, 2048
  br label %bb0
bb0:
  %cmp = icmp eq i32 %and, 0
  store i32 0, ptr @A
  br i1 %cmp, label %bb0, label %bb2
bb2:
  ret i32 0
}

define i32 @and_sink2(i32 %a) {
; CHECK-LABEL: and_sink2:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    {
; CHECK-NEXT:     r1 = and(r0,##2049)
; CHECK-NEXT:     r0 = ##A
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     p0 = cmp.eq(r1,#0)
; CHECK-NEXT:    }
; CHECK-NEXT:    .p2align 4
; CHECK-NEXT:  .LBB1_1: // %bb0
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    {
; CHECK-NEXT:     if (p0) jump:nt .LBB1_1
; CHECK-NEXT:     memw(r0+#0) = #0
; CHECK-NEXT:    }
; CHECK-NEXT:  // %bb.2: // %bb2
; CHECK-NEXT:    {
; CHECK-NEXT:     r0 = #0
; CHECK-NEXT:     jumpr r31
; CHECK-NEXT:    }
  %and = and i32 %a, 2049
  br label %bb0
bb0:
  %cmp = icmp eq i32 %and, 0
  store i32 0, ptr @A
  br i1 %cmp, label %bb0, label %bb2
bb2:
  ret i32 0
}
