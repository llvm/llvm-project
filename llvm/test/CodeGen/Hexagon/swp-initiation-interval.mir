# RUN: llc -mtriple=hexagon -mcpu=hexagonv73 -O2 -mattr=+hvxv73,hvx-length64b \
# RUN: -run-pass=pipeliner -debug-only=pipeliner 2>&1 \
# RUN: %s -o - | FileCheck %s
# REQUIRES: asserts

# Check that the loop is software pipelined.

# CHECK: Schedule Found? 1 (II=4)

--- |
  target datalayout = "e-m:e-p:32:32:32-a:0-n16:32-i64:64:64-i32:32:32-i16:16:16-i1:8:8-f32:32:32-f64:64:64-v32:32:32-v64:64:64-v512:512:512-v1024:1024:1024-v2048:2048:2048"
  target triple = "hexagon"

  ; Function Attrs: nounwind
  define void @ham(ptr noalias nocapture readonly %arg, i32 %arg1, i32 %arg2, i32 %arg3, ptr noalias nocapture %arg4, i32 %arg5) #0 {
  bb:
    %ashr = ashr i32 %arg3, 2
    %ashr6 = ashr i32 %arg3, 1
    %add = add nsw i32 %ashr6, %ashr
    %icmp = icmp sgt i32 %arg2, 0
    br i1 %icmp, label %bb7, label %bb61

  bb7:                                              ; preds = %bb
    %sdiv = sdiv i32 %arg1, 64
    br label %bb9

  bb9:                                              ; preds = %bb57, %bb7
    %phi = phi i32 [ 0, %bb7 ], [ %add58, %bb57 ]
    %0 = icmp sgt i32 %arg1, 63
    %ashr10 = ashr exact i32 %phi, 1
    %mul = mul nsw i32 %ashr10, %arg3
    br i1 %0, label %bb11, label %bb57

  bb11:                                             ; preds = %bb9
    %add12 = add nsw i32 %phi, 1
    %mul13 = mul nsw i32 %add12, %arg5
    %mul14 = mul nsw i32 %phi, %arg5
    %add15 = add i32 %add, %mul
    %add16 = add i32 %mul, %ashr
    %add17 = add i32 %mul, %ashr6
    %cgep = getelementptr inbounds i8, ptr %arg4, i32 %mul13
    %cgep1 = getelementptr inbounds i8, ptr %arg4, i32 %mul14
    %cgep2 = getelementptr inbounds i16, ptr %arg, i32 %add15
    %cgep3 = getelementptr inbounds i16, ptr %arg, i32 %add16
    %cgep4 = getelementptr inbounds i16, ptr %arg, i32 %add17
    %cgep5 = getelementptr inbounds i16, ptr %arg, i32 %mul
    br label %bb28

  bb28:                                             ; preds = %bb28, %bb11
    %phi29 = phi i32 [ 0, %bb11 ], [ %add54, %bb28 ]
    %phi30 = phi ptr [ %cgep5, %bb11 ], [ %cgep6, %bb28 ]
    %phi31 = phi ptr [ %cgep4, %bb11 ], [ %cgep7, %bb28 ]
    %phi32 = phi ptr [ %cgep3, %bb11 ], [ %cgep8, %bb28 ]
    %phi33 = phi ptr [ %cgep2, %bb11 ], [ %cgep9, %bb28 ]
    %phi34 = phi ptr [ %cgep, %bb11 ], [ %cgep11, %bb28 ]
    %phi35 = phi ptr [ %cgep1, %bb11 ], [ %cgep10, %bb28 ]
    %load = load <16 x i32>, ptr %phi30, align 64
    %load38 = load <16 x i32>, ptr %phi31, align 64
    %load40 = load <16 x i32>, ptr %phi32, align 64
    %load42 = load <16 x i32>, ptr %phi33, align 64
    %call = tail call <16 x i32> @llvm.hexagon.V6.vaddh(<16 x i32> %load, <16 x i32> %load38)
    %call43 = tail call <16 x i32> @llvm.hexagon.V6.vsubh(<16 x i32> %load, <16 x i32> %load38)
    %call44 = tail call <16 x i32> @llvm.hexagon.V6.vaddh(<16 x i32> %load40, <16 x i32> %load42)
    %call45 = tail call <16 x i32> @llvm.hexagon.V6.vsubh(<16 x i32> %load40, <16 x i32> %load42)
    %call46 = tail call <16 x i32> @llvm.hexagon.V6.vavgh(<16 x i32> %call, <16 x i32> %call44)
    %call47 = tail call <16 x i32> @llvm.hexagon.V6.vnavgh(<16 x i32> %call, <16 x i32> %call44)
    %call48 = tail call <16 x i32> @llvm.hexagon.V6.vavgh(<16 x i32> %call43, <16 x i32> %call45)
    %call49 = tail call <16 x i32> @llvm.hexagon.V6.vnavgh(<16 x i32> %call43, <16 x i32> %call45)
    %call50 = tail call <16 x i32> @llvm.hexagon.V6.vsathub(<16 x i32> %call47, <16 x i32> %call46)
    %call51 = tail call <16 x i32> @llvm.hexagon.V6.vsathub(<16 x i32> %call49, <16 x i32> %call48)
    store <16 x i32> %call50, ptr %phi35, align 64
    store <16 x i32> %call51, ptr %phi34, align 64
    %add54 = add nsw i32 %phi29, 1
    %icmp55 = icmp slt i32 %add54, %sdiv
    %cgep6 = getelementptr inbounds <16 x i32>, ptr %phi30, i32 1
    %cgep7 = getelementptr inbounds <16 x i32>, ptr %phi31, i32 1
    %cgep8 = getelementptr inbounds <16 x i32>, ptr %phi32, i32 1
    %cgep9 = getelementptr inbounds <16 x i32>, ptr %phi33, i32 1
    %cgep10 = getelementptr inbounds <16 x i32>, ptr %phi35, i32 1
    %cgep11 = getelementptr inbounds <16 x i32>, ptr %phi34, i32 1
    br i1 %icmp55, label %bb28, label %bb57

  bb57:                                             ; preds = %bb28, %bb9
    %add58 = add nsw i32 %phi, 2
    %icmp59 = icmp slt i32 %add58, %arg2
    br i1 %icmp59, label %bb9, label %bb61

  bb61:                                             ; preds = %bb57, %bb
    ret void
  }

  ; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
  declare <16 x i32> @llvm.hexagon.V6.vaddh(<16 x i32>, <16 x i32>) #1

  ; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
  declare <16 x i32> @llvm.hexagon.V6.vsubh(<16 x i32>, <16 x i32>) #1

  ; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
  declare <16 x i32> @llvm.hexagon.V6.vavgh(<16 x i32>, <16 x i32>) #1

  ; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
  declare <16 x i32> @llvm.hexagon.V6.vnavgh(<16 x i32>, <16 x i32>) #1

  ; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
  declare <16 x i32> @llvm.hexagon.V6.vsathub(<16 x i32>, <16 x i32>) #1

  attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="hexagonv73" "target-features"="+hvxv73,+hvx-length64b" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nocallback nofree nosync nounwind willreturn memory(none) "target-cpu"="hexagonv73" "target-features"="+hvxv73,+hvx-length64b" }

...
---
name:            ham
alignment:       16
tracksRegLiveness: true
body:             |
  bb.0.bb:
    successors: %bb.1(0x50000000), %bb.6(0x30000000)
    liveins: $r0, $r1, $r2, $r3, $r4, $r5
  
    %32:intregs = COPY $r5
    %31:intregs = COPY $r4
    %30:intregs = COPY $r3
    %29:intregs = COPY $r2
    %28:intregs = COPY $r1
    %27:intregs = COPY $r0
    %33:predregs = C2_cmpgti %29, 0
    J2_jumpf %33, %bb.6, implicit-def dead $pc
    J2_jump %bb.1, implicit-def dead $pc
  
  bb.1.bb7:
    successors: %bb.2(0x80000000)
  
    %0:intregs = S2_asr_i_r %30, 2
    %1:intregs = S2_asr_i_r %30, 1
    %2:intregs = nsw A2_add %1, %0
    %36:intregs = S2_asr_i_r %28, 31
    %37:intregs = S2_lsr_i_r_acc %28, killed %36, 26
    %3:intregs = S2_asr_i_r killed %37, 6
    %35:intregs = A2_tfrsi 0
    %38:predregs = C2_cmpgti %28, 63
    %63:intregs = A2_addi %29, 1
    %64:intregs = S2_lsr_i_r %63, 1
    %65:intregs = COPY %64
    J2_loop1r %bb.2, %65, implicit-def $lc1, implicit-def $sa1
  
  bb.2.bb9 (machine-block-address-taken):
    successors: %bb.3(0x40000000), %bb.5(0x40000000)
  
    %4:intregs = PHI %35, %bb.1, %26, %bb.5
    J2_jumpf %38, %bb.5, implicit-def dead $pc
    J2_jump %bb.3, implicit-def dead $pc
  
  bb.3.bb11:
    successors: %bb.4(0x80000000)
  
    %40:intregs = exact S2_asr_i_r %4, 1
    %5:intregs = nsw M2_mpyi %40, %30
    %42:intregs = nsw A2_addi %4, 1
    %43:intregs = A2_add %2, %5
    %44:intregs = A2_add %5, %0
    %45:intregs = A2_add %5, %1
    %6:intregs = M2_maci %31, killed %42, %32
    %7:intregs = M2_maci %31, %4, %32
    %8:intregs = S2_addasl_rrri %27, killed %43, 1
    %9:intregs = S2_addasl_rrri %27, killed %44, 1
    %10:intregs = S2_addasl_rrri %27, killed %45, 1
    %11:intregs = S2_addasl_rrri %27, %5, 1
    %62:intregs = COPY %3
    J2_loop0r %bb.4, %62, implicit-def $lc0, implicit-def $sa0, implicit-def $usr
  
  bb.4.bb28 (machine-block-address-taken):
    successors: %bb.4(0x7c000000), %bb.5(0x04000000)
  
    %13:intregs = PHI %11, %bb.3, %20, %bb.4
    %14:intregs = PHI %10, %bb.3, %21, %bb.4
    %15:intregs = PHI %9, %bb.3, %22, %bb.4
    %16:intregs = PHI %8, %bb.3, %23, %bb.4
    %17:intregs = PHI %6, %bb.3, %25, %bb.4
    %18:intregs = PHI %7, %bb.3, %24, %bb.4
    %46:hvxvr, %20:intregs = V6_vL32b_pi %13, 64 :: (load (s512) from %ir.phi30)
    %47:hvxvr, %21:intregs = V6_vL32b_pi %14, 64 :: (load (s512) from %ir.phi31)
    %48:hvxvr, %22:intregs = V6_vL32b_pi %15, 64 :: (load (s512) from %ir.phi32)
    %49:hvxvr, %23:intregs = V6_vL32b_pi %16, 64 :: (load (s512) from %ir.phi33)
    %50:hvxvr = V6_vaddh %46, %47
    %51:hvxvr = V6_vsubh %46, %47
    %52:hvxvr = V6_vaddh %48, %49
    %53:hvxvr = V6_vsubh %48, %49
    %54:hvxvr = V6_vavgh %50, %52
    %55:hvxvr = V6_vnavgh %50, %52
    %56:hvxvr = V6_vavgh %51, %53
    %57:hvxvr = V6_vnavgh %51, %53
    %58:hvxvr = V6_vsathub killed %55, killed %54
    %59:hvxvr = V6_vsathub killed %57, killed %56
    %24:intregs = V6_vS32b_pi %18, 64, killed %58 :: (store (s512) into %ir.phi35)
    %25:intregs = V6_vS32b_pi %17, 64, killed %59 :: (store (s512) into %ir.phi34)
    ENDLOOP0 %bb.4, implicit-def $pc, implicit-def $lc0, implicit $sa0, implicit $lc0
    J2_jump %bb.5, implicit-def dead $pc
  
  bb.5.bb57:
    successors: %bb.2(0x7c000000), %bb.6(0x04000000)
  
    %26:intregs = nsw A2_addi %4, 2
    ENDLOOP1 %bb.2, implicit-def $pc, implicit-def $lc1, implicit $sa1, implicit $lc1
    J2_jump %bb.6, implicit-def dead $pc
  
  bb.6.bb61:
    PS_jmpret $r31, implicit-def dead $pc

...
