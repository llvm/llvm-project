; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=hexagon < %s | FileCheck %s

; Function Attrs: nounwind
define <32 x i32> @f0(ptr %a0, i32 %a1) #0 {
; CHECK-LABEL: f0:
; CHECK:       // %bb.0: // %b0
; CHECK-NEXT:    {
; CHECK-NEXT:     [[RADD:[r0-9]+]] = add([[R1:[r0-9]+]],[[R0:[r0-9]+]])
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[RLCPI:[r0-9]+]] = ##.LCPI0_0
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[RNEG:[r0-9]+]] = #-1
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[RADD136:[r0-9]+]] = add([[RADD]],#136)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[V1:[v0-9]+]] = vmem([[RLCPI]]+#0)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[RADD128:[r0-9]+]] = add([[RADD]],#128)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[Q0:[q0-9]+]] = vand([[V1]],[[RNEG]])
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[V2:[v0-9]+]] = vmemu([[RADD136]]+#0)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[V3:[v0-9]+]] = vmem([[RADD]]+#1)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     [[V0:[v0-9]+]].w = vadd([[V3]].w,[[V2]].w)
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     if ([[Q0]]) vmem([[RADD128]]+#0) = [[V0]]
; CHECK-NEXT:    }
; CHECK-NEXT:    {
; CHECK-NEXT:     jumpr r31
; CHECK-NEXT:    }
b0:
  %v0 = add i32 %a1, 128
  %v1 = getelementptr i8, ptr %a0, i32 %v0
  %v3 = tail call <32 x i32> @llvm.masked.load.v32i32.p0(ptr %v1, i32 128, <32 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <32 x i32> undef)
  %v4 = add i32 %a1, 136
  %v5 = getelementptr i8, ptr %a0, i32 %v4
  %v7 = tail call <32 x i32> @llvm.masked.load.v32i32.p0(ptr %v5, i32 8, <32 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>, <32 x i32> undef)
  %v8 = add <32 x i32> %v3, %v7
  tail call void @llvm.masked.store.v32i32.p0(<32 x i32> %v8, ptr %v1, i32 128, <32 x i1> <i1 true, i1 true, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false, i1 false>)
  ret <32 x i32> %v8
}

; Function Attrs: argmemonly nounwind readonly willreturn
declare <32 x i32> @llvm.masked.load.v32i32.p0(ptr, i32 immarg, <32 x i1>, <32 x i32>) #1

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.masked.store.v32i32.p0(<32 x i32>, ptr, i32 immarg, <32 x i1>) #2

attributes #0 = { nounwind "target-cpu"="hexagonv66" "target-features"="+hvxv66,+hvx-length128b,-packets" }
attributes #1 = { argmemonly nounwind readonly willreturn }
attributes #2 = { argmemonly nounwind willreturn }
