; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -hexagon-vc -S -mtriple=hexagon < %s | FileCheck %s

; A safety check was accidentally modified, allowing moving memory
; instructions over other aliased memory instructions. In this case
; a load was moved over a memset.

; This testcase should be left untouched by the vector alignment code.

define internal fastcc i32 @f0(ptr noalias nocapture align 64 %a0, ptr noalias nocapture readonly align 64 %a1, ptr noalias nocapture readonly align 64 %a2) unnamed_addr #0 {
; CHECK-LABEL: define internal fastcc i32 @f0
; CHECK-SAME: (ptr noalias nocapture align 64 [[A0:%.*]], ptr noalias nocapture readonly align 64 [[A1:%.*]], ptr noalias nocapture readonly align 64 [[A2:%.*]]) unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  b0:
; CHECK-NEXT:    [[V0:%.*]] = load <32 x i32>, ptr [[A2]], align 64, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    br label [[B1:%.*]]
; CHECK:       b1:
; CHECK-NEXT:    [[V1:%.*]] = phi i32 [ [[V13:%.*]], [[B1]] ], [ 1024, [[B0:%.*]] ]
; CHECK-NEXT:    [[V2:%.*]] = phi ptr [ [[A0]], [[B0]] ], [ [[V9:%.*]], [[B1]] ]
; CHECK-NEXT:    [[V3:%.*]] = phi ptr [ [[A1]], [[B0]] ], [ [[V8:%.*]], [[B1]] ]
; CHECK-NEXT:    tail call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(128) [[V2]], i8 0, i32 128, i1 false), !tbaa [[TBAA7:![0-9]+]]
; CHECK-NEXT:    [[V4:%.*]] = getelementptr i8, ptr [[V2]], i32 0
; CHECK-NEXT:    [[V5:%.*]] = load <32 x i32>, ptr [[V4]], align 64, !tbaa [[TBAA7]]
; CHECK-NEXT:    [[V6:%.*]] = load <32 x i32>, ptr [[V3]], align 64, !tbaa [[TBAA9:![0-9]+]]
; CHECK-NEXT:    [[V7:%.*]] = tail call <32 x i32> @llvm.hexagon.V6.vrmpyubv.acc.128B(<32 x i32> [[V5]], <32 x i32> [[V6]], <32 x i32> [[V0]])
; CHECK-NEXT:    store <32 x i32> [[V7]], ptr [[V2]], align 64, !tbaa [[TBAA7]]
; CHECK-NEXT:    [[V8]] = getelementptr i8, ptr [[V3]], i32 128
; CHECK-NEXT:    [[V9]] = getelementptr i8, ptr [[V2]], i32 128
; CHECK-NEXT:    tail call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(128) [[V9]], i8 0, i32 128, i1 false), !tbaa [[TBAA7]]
; CHECK-NEXT:    [[V10:%.*]] = load <32 x i32>, ptr [[V9]], align 64, !tbaa [[TBAA7]]
; CHECK-NEXT:    [[V11:%.*]] = load <32 x i32>, ptr [[V8]], align 64, !tbaa [[TBAA9]]
; CHECK-NEXT:    [[V12:%.*]] = tail call <32 x i32> @llvm.hexagon.V6.vrmpyubv.acc.128B(<32 x i32> [[V10]], <32 x i32> [[V11]], <32 x i32> [[V0]])
; CHECK-NEXT:    store <32 x i32> [[V12]], ptr [[V9]], align 64, !tbaa [[TBAA7]]
; CHECK-NEXT:    [[V13]] = add nsw i32 [[V1]], -16
; CHECK-NEXT:    [[V14:%.*]] = icmp eq i32 [[V13]], 0
; CHECK-NEXT:    br i1 [[V14]], label [[B2:%.*]], label [[B1]], !prof [[PROF11:![0-9]+]]
; CHECK:       b2:
; CHECK-NEXT:    ret i32 0
;
b0:
  %v0 = load <32 x i32>, ptr %a2, align 64, !tbaa !0
  br label %b1

b1:                                               ; preds = %b1, %b0
  %v1 = phi i32 [ %v13, %b1 ], [ 1024, %b0 ]
  %v2 = phi ptr [ %a0, %b0 ], [ %v9, %b1 ]
  %v3 = phi ptr [ %a1, %b0 ], [ %v8, %b1 ]
  tail call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(128) %v2, i8 0, i32 128, i1 false), !tbaa !7
  %v4 = getelementptr i8, ptr %v2, i32 0
  %v5 = load <32 x i32>, ptr %v4, align 64, !tbaa !7
  %v6 = load <32 x i32>, ptr %v3, align 64, !tbaa !9
  %v7 = tail call <32 x i32> @llvm.hexagon.V6.vrmpyubv.acc.128B(<32 x i32> %v5, <32 x i32> %v6, <32 x i32> %v0)
  store <32 x i32> %v7, ptr %v2, align 64, !tbaa !7
  %v8 = getelementptr i8, ptr %v3, i32 128
  %v9 = getelementptr i8, ptr %v2, i32 128
  tail call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(128) %v9, i8 0, i32 128, i1 false), !tbaa !7
  %v10 = load <32 x i32>, ptr %v9, align 64, !tbaa !7
  %v11 = load <32 x i32>, ptr %v8, align 64, !tbaa !9
  %v12 = tail call <32 x i32> @llvm.hexagon.V6.vrmpyubv.acc.128B(<32 x i32> %v10, <32 x i32> %v11, <32 x i32> %v0)
  store <32 x i32> %v12, ptr %v9, align 64, !tbaa !7
  %v13 = add nsw i32 %v1, -16
  %v14 = icmp eq i32 %v13, 0
  br i1 %v14, label %b2, label %b1, !prof !11

b2:                                               ; preds = %b1
  ret i32 0
}

declare <32 x i32> @llvm.hexagon.V6.vrmpyubv.acc.128B(<32 x i32>, <32 x i32>, <32 x i32>) #1
declare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1 immarg) #2

attributes #0 = { noinline "target-cpu"="hexagonv68" "target-features"="+hvxv68,+hvx-length128b" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: write) }

!0 = !{!1, !1, i64 0}
!1 = !{!"0x3a8ee80.w128.b0", !2, i64 0}
!2 = !{!"0x3a8ee80.w256.b0", !3, i64 0}
!3 = !{!"0x3a8ee80.w512.b0", !4, i64 0}
!4 = !{!"0x3a8ee80.w1024.b0", !5, i64 0}
!5 = !{!"0x3a8ee80", !6, i64 0}
!6 = !{!"tvm-tbaa"}
!7 = !{!8, !8, i64 0}
!8 = !{!"0x3a0d520", !6, i64 0}
!9 = !{!10, !10, i64 0}
!10 = !{!"0x1d56420", !6, i64 0}
!11 = !{!"branch_weights", i32 1, i32 65535}
