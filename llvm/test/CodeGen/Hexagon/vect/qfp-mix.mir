# RUN: llc -march=hexagon -mcpu=hexagonv68 -mattr=+hvxv68,+hvx-length128b \
# RUN: -run-pass hexagon-qfp-optimizer %s -o - | FileCheck %s


# Test that the operands are swapped for Add if the second operand
# is a qf32 to sf conversion. V6_vadd_qf32_mix supports first operand
# as qf32.
# CHECK-LABEL: name: qfpAddMix
# CHECK: %[[REG:([0-9]+)]]:hvxvr = V6_vmpy_qf32_sf
# CHECK: V6_vadd_qf32_mix %[[REG]]

---
name: qfpAddMix
tracksRegLiveness: true

body: |
  bb.0:
    liveins: $r0, $r1, $r2, $r3
    %0:intregs = COPY $r0
    %1:intregs = COPY $r1
    %2:intregs = COPY $r2
    %3:hvxvr = V6_vL32Ub_ai %0:intregs, 0
    %4:hvxvr = V6_vL32Ub_ai %1:intregs, 0
    %5:hvxvr = V6_vL32Ub_ai %2:intregs, 0
    %6:hvxvr = V6_vmpy_qf32_sf %4, %5
    %7:hvxvr = V6_vconv_sf_qf32 %6:hvxvr
    %8:hvxvr = V6_vadd_sf %3:hvxvr, %7:hvxvr
...


# Test that we do not generate V6_vsub_qf32_mix for the below test.
# V6_vsub_qf32_mix only allowes qf32 as first operand. In the test qf32
# is passed as second operand. As sub is not commutative, we should not
# generate the mix instruction.
# CHECK-LABEL: name: qfpSubNoMix
# CHECK-NOT: V6_vsub_qf32_mix

---
name: qfpSubNoMix
tracksRegLiveness: true

body: |
  bb.0:
    liveins: $r0, $r1, $r2, $r3
    %0:intregs = COPY $r0
    %1:intregs = COPY $r1
    %2:intregs = COPY $r2
    %3:hvxvr = V6_vL32Ub_ai %0:intregs, 0
    %4:hvxvr = V6_vL32Ub_ai %1:intregs, 0
    %5:hvxvr = V6_vL32Ub_ai %2:intregs, 0
    %6:hvxvr = V6_vmpy_qf32_sf %4, %5
    %7:hvxvr = V6_vconv_sf_qf32 %6:hvxvr
    %8:hvxvr = V6_vsub_sf %3:hvxvr, %7:hvxvr
...


# Test that we do generate V6_vsub_qf32_mix for the below test.
# V6_vsub_qf32_mix only allowes qf32 as first operand. In the test qf32
# is passed as first operand. So, V6_vsub_qf32_mix must be generated.
# CHECK-LABEL: name: qfpSubMix
# CHECK: V6_vsub_qf32_mix

---
name: qfpSubMix
tracksRegLiveness: true

body: |
  bb.0:
    liveins: $r0, $r1, $r2, $r3
    %0:intregs = COPY $r0
    %1:intregs = COPY $r1
    %2:intregs = COPY $r2
    %3:hvxvr = V6_vL32Ub_ai %0:intregs, 0
    %4:hvxvr = V6_vL32Ub_ai %1:intregs, 0
    %5:hvxvr = V6_vL32Ub_ai %2:intregs, 0
    %6:hvxvr = V6_vmpy_qf32_sf %4, %5
    %7:hvxvr = V6_vconv_sf_qf32 %6:hvxvr
    %8:hvxvr = V6_vsub_sf %7:hvxvr, %3:hvxvr
...
