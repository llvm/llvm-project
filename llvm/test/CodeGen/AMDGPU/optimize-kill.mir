# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx900 -start-before=greedy,1 -stop-after=virtregrewriter,1 -verify-machineinstrs %s -o - | FileCheck -check-prefix=GCN %s

# The virtregrewriter pass should not insert a KILL when found an identical copy with an implicit reserved register.
# For the following instruction,
#      %4:vgpr_32 = COPY %3:vgpr_32, implicit $exec
# if the register allocated for both the source and destination operands remain the same (vgpr0, for instance), there is
# no need to insert the KILL instruction as the implicit operand (exec) is a reserved register.
#     $vgpr0 = KILL killed renamable $vgpr0, implicit $exec
---
name:            test
tracksRegLiveness: true
machineFunctionInfo:
  isEntryFunction: true
  stackPtrOffsetReg: '$sgpr32'
body:             |
  bb.0:
    liveins: $sgpr0, $sgpr1
    ; GCN-LABEL: name: test
    ; GCN: liveins: $sgpr0, $sgpr1
    ; GCN-NEXT: {{  $}}
    ; GCN-NEXT: renamable $sgpr2_sgpr3 = COPY $exec
    ; GCN-NEXT: $exec = S_WQM_B64 $exec, implicit-def $scc
    ; GCN-NEXT: renamable $vgpr0 = COPY renamable $sgpr0
    ; GCN-NEXT: renamable $vgpr0 = BUFFER_LOAD_DWORD_IDXEN killed renamable $vgpr0, undef renamable $sgpr0_sgpr1_sgpr2_sgpr3, 0, 0, 0, 0, implicit $exec
    ; GCN-NEXT: $exec = S_AND_B64 $exec, killed renamable $sgpr2_sgpr3, implicit-def $scc
    ; GCN-NEXT: SI_RETURN_TO_EPILOG $vgpr0
    renamable $sgpr2_sgpr3 = COPY $exec
    $exec = S_WQM_B64 $exec, implicit-def $scc
    %2:vgpr_32 = COPY killed renamable $sgpr0
    %3:vgpr_32 = BUFFER_LOAD_DWORD_IDXEN %2, undef renamable $sgpr0_sgpr1_sgpr2_sgpr3, 0, 0, 0, 0, implicit $exec
    %4:vgpr_32 = COPY %3:vgpr_32, implicit $exec
    $exec = S_AND_B64 $exec, killed renamable $sgpr2_sgpr3, implicit-def $scc
    $vgpr0 = COPY %4
    SI_RETURN_TO_EPILOG killed $vgpr0
...
