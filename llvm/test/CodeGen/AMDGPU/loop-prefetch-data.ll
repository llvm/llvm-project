; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -march=amdgcn -mcpu=gfx1200 -amdgpu-loop-prefetch -stop-after=postmisched < %s | FileCheck --check-prefix=GCN %s

; FIXME: We cannot produce code for GFX12 yet. Remove -stop-after=postmisched when we can.

define amdgpu_kernel void @copy_flat(<4 x i32>* nocapture %d, <4 x i32>* nocapture readonly %s, i32 %n) {
  ; GCN-LABEL: name: copy_flat
  ; GCN: bb.0.entry:
  ; GCN-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
  ; GCN-NEXT:   liveins: $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr4 = S_LOAD_DWORD_IMM renamable $sgpr0_sgpr1, 52, 0 :: (dereferenceable invariant load (s32) from %ir.n.kernarg.offset.cast, addrspace 4)
  ; GCN-NEXT:   S_CMP_EQ_U32 renamable $sgpr4, 0, implicit-def $scc
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.3, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.1.for.body.preheader:
  ; GCN-NEXT:   successors: %bb.2(0x80000000)
  ; GCN-NEXT:   liveins: $sgpr4, $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr0_sgpr1_sgpr2_sgpr3 = S_LOAD_DWORDX4_IMM killed renamable $sgpr0_sgpr1, 36, 0 :: (dereferenceable invariant load (s128) from %ir.0, align 4, addrspace 4)
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.2.for.body:
  ; GCN-NEXT:   successors: %bb.3(0x04000000), %bb.2(0x7c000000)
  ; GCN-NEXT:   liveins: $sgpr4, $sgpr0_sgpr1_sgpr2_sgpr3:0x00000000000000FF
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   $vgpr0 = V_MOV_B32_e32 $sgpr2, implicit $exec, implicit-def $vgpr0_vgpr1, implicit $sgpr2_sgpr3
  ; GCN-NEXT:   $vgpr1 = V_MOV_B32_e32 $sgpr3, implicit $exec, implicit $sgpr2_sgpr3, implicit $exec
  ; GCN-NEXT:   S_PREFETCH_DATA renamable $sgpr2_sgpr3, 176, $sgpr_null, 0 :: (load (s8) from %ir.scevgep4)
  ; GCN-NEXT:   renamable $sgpr2 = S_ADD_U32 killed renamable $sgpr2, 16, implicit-def $scc
  ; GCN-NEXT:   $vgpr5 = V_MOV_B32_e32 $sgpr1, implicit $exec, implicit-def $vgpr4_vgpr5, implicit $sgpr0_sgpr1
  ; GCN-NEXT:   $vgpr4 = V_MOV_B32_e32 $sgpr0, implicit $exec, implicit $sgpr0_sgpr1, implicit $exec
  ; GCN-NEXT:   renamable $vgpr0_vgpr1_vgpr2_vgpr3 = FLAT_LOAD_DWORDX4 killed renamable $vgpr0_vgpr1, 0, 0, implicit $exec, implicit $flat_scr :: (load (s128) from %ir.lsr.iv, align 4)
  ; GCN-NEXT:   renamable $sgpr3 = S_ADDC_U32 killed renamable $sgpr3, 0, implicit-def dead $scc, implicit killed $scc
  ; GCN-NEXT:   renamable $sgpr4 = S_ADD_I32 killed renamable $sgpr4, -1, implicit-def dead $scc
  ; GCN-NEXT:   renamable $sgpr0 = S_ADD_U32 killed renamable $sgpr0, 16, implicit-def $scc
  ; GCN-NEXT:   renamable $sgpr1 = S_ADDC_U32 killed renamable $sgpr1, 0, implicit-def dead $scc, implicit killed $scc
  ; GCN-NEXT:   S_CMP_LG_U32 renamable $sgpr4, 0, implicit-def $scc
  ; GCN-NEXT:   FLAT_STORE_DWORDX4 killed renamable $vgpr4_vgpr5, killed renamable $vgpr0_vgpr1_vgpr2_vgpr3, 0, 0, implicit $exec, implicit $flat_scr :: (store (s128) into %ir.lsr.iv6, align 4)
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.2, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.3.for.end:
  ; GCN-NEXT:   S_ENDPGM 0
entry:
  %cmp6.not = icmp eq i32 %n, 0
  br i1 %cmp6.not, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.07 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %idxprom = zext i32 %i.07 to i64
  %arrayidx = getelementptr inbounds <4 x i32>, <4 x i32>* %s, i64 %idxprom
  %ld = load <4 x i32>, <4 x i32>* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds <4 x i32>, <4 x i32>* %d, i64 %idxprom
  store <4 x i32> %ld, <4 x i32>* %arrayidx2, align 4
  %inc = add nuw i32 %i.07, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

define amdgpu_kernel void @copy_global(<4 x i32> addrspace(1)* nocapture %d, <4 x i32> addrspace(1)* nocapture readonly %s, i32 %n) {
  ; GCN-LABEL: name: copy_global
  ; GCN: bb.0.entry:
  ; GCN-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
  ; GCN-NEXT:   liveins: $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr4 = S_LOAD_DWORD_IMM renamable $sgpr0_sgpr1, 52, 0 :: (dereferenceable invariant load (s32) from %ir.n.kernarg.offset.cast, addrspace 4)
  ; GCN-NEXT:   S_CMP_EQ_U32 renamable $sgpr4, 0, implicit-def $scc
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.3, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.1.for.body.preheader:
  ; GCN-NEXT:   successors: %bb.2(0x80000000)
  ; GCN-NEXT:   liveins: $sgpr4, $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr0_sgpr1_sgpr2_sgpr3 = S_LOAD_DWORDX4_IMM killed renamable $sgpr0_sgpr1, 36, 0 :: (dereferenceable invariant load (s128) from %ir.0, align 4, addrspace 4)
  ; GCN-NEXT:   renamable $vgpr0 = V_MOV_B32_e32 0, implicit $exec
  ; GCN-NEXT:   renamable $sgpr2 = S_ADD_U32 killed renamable $sgpr2, 176, implicit-def $scc
  ; GCN-NEXT:   renamable $sgpr3 = S_ADDC_U32 killed renamable $sgpr3, 0, implicit-def dead $scc, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.2.for.body:
  ; GCN-NEXT:   successors: %bb.3(0x04000000), %bb.2(0x7c000000)
  ; GCN-NEXT:   liveins: $sgpr4, $vgpr0, $sgpr0_sgpr1_sgpr2_sgpr3:0x000000000000000F, $sgpr2_sgpr3:0x000000000000000F
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $vgpr1_vgpr2_vgpr3_vgpr4 = GLOBAL_LOAD_DWORDX4_SADDR renamable $sgpr2_sgpr3, renamable $vgpr0, -176, 0, implicit $exec :: (load (s128) from %ir.scevgep8, align 4, addrspace 1)
  ; GCN-NEXT:   S_PREFETCH_DATA renamable $sgpr2_sgpr3, 0, $sgpr_null, 0 :: (load (s8) from %ir.lsr.iv4, addrspace 1)
  ; GCN-NEXT:   renamable $sgpr2 = S_ADD_U32 killed renamable $sgpr2, 16, implicit-def $scc
  ; GCN-NEXT:   renamable $sgpr3 = S_ADDC_U32 killed renamable $sgpr3, 0, implicit-def dead $scc, implicit killed $scc
  ; GCN-NEXT:   renamable $sgpr4 = S_ADD_I32 killed renamable $sgpr4, -1, implicit-def dead $scc
  ; GCN-NEXT:   GLOBAL_STORE_DWORDX4_SADDR renamable $vgpr0, killed renamable $vgpr1_vgpr2_vgpr3_vgpr4, renamable $sgpr0_sgpr1, 0, 0, implicit $exec :: (store (s128) into %ir.lsr.iv6, align 4, addrspace 1)
  ; GCN-NEXT:   renamable $sgpr0 = S_ADD_U32 killed renamable $sgpr0, 16, implicit-def $scc
  ; GCN-NEXT:   renamable $sgpr1 = S_ADDC_U32 killed renamable $sgpr1, 0, implicit-def dead $scc, implicit killed $scc
  ; GCN-NEXT:   S_CMP_LG_U32 renamable $sgpr4, 0, implicit-def $scc
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.2, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.3.for.end:
  ; GCN-NEXT:   S_ENDPGM 0
entry:
  %cmp6.not = icmp eq i32 %n, 0
  br i1 %cmp6.not, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.07 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %idxprom = zext i32 %i.07 to i64
  %arrayidx = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(1)* %s, i64 %idxprom
  %ld = load <4 x i32>, <4 x i32> addrspace(1)* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(1)* %d, i64 %idxprom
  store <4 x i32> %ld, <4 x i32> addrspace(1)* %arrayidx2, align 4
  %inc = add nuw i32 %i.07, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

define amdgpu_kernel void @copy_constant(<4 x i32> addrspace(1)* nocapture %d, <4 x i32> addrspace(4)* nocapture readonly %s, i32 %n) {
  ; GCN-LABEL: name: copy_constant
  ; GCN: bb.0.entry:
  ; GCN-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
  ; GCN-NEXT:   liveins: $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr4 = S_LOAD_DWORD_IMM renamable $sgpr0_sgpr1, 52, 0 :: (dereferenceable invariant load (s32) from %ir.n.kernarg.offset.cast, addrspace 4)
  ; GCN-NEXT:   S_CMP_EQ_U32 renamable $sgpr4, 0, implicit-def $scc
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.3, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.1.for.body.preheader:
  ; GCN-NEXT:   successors: %bb.2(0x80000000)
  ; GCN-NEXT:   liveins: $sgpr4, $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr0_sgpr1_sgpr2_sgpr3 = S_LOAD_DWORDX4_IMM killed renamable $sgpr0_sgpr1, 36, 0 :: (dereferenceable invariant load (s128) from %ir.0, align 4, addrspace 4)
  ; GCN-NEXT:   renamable $vgpr0 = V_MOV_B32_e32 0, implicit $exec
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.2.for.body:
  ; GCN-NEXT:   successors: %bb.3(0x04000000), %bb.2(0x7c000000)
  ; GCN-NEXT:   liveins: $sgpr4, $vgpr0, $sgpr0_sgpr1_sgpr2_sgpr3:0x00000000000000FF
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr8_sgpr9_sgpr10_sgpr11 = S_LOAD_DWORDX4_IMM renamable $sgpr2_sgpr3, 0, 0 :: (dereferenceable invariant load (s128) from %ir.lsr.iv, align 4, addrspace 4)
  ; GCN-NEXT:   S_PREFETCH_DATA renamable $sgpr2_sgpr3, 176, $sgpr_null, 0 :: (load (s8) from %ir.scevgep4, addrspace 4)
  ; GCN-NEXT:   renamable $sgpr2 = S_ADD_U32 killed renamable $sgpr2, 16, implicit-def $scc
  ; GCN-NEXT:   renamable $sgpr3 = S_ADDC_U32 killed renamable $sgpr3, 0, implicit-def dead $scc, implicit killed $scc
  ; GCN-NEXT:   renamable $sgpr4 = S_ADD_I32 killed renamable $sgpr4, -1, implicit-def dead $scc
  ; GCN-NEXT:   $vgpr1 = V_MOV_B32_e32 $sgpr8, implicit $exec, implicit-def $vgpr1_vgpr2_vgpr3_vgpr4, implicit $sgpr8_sgpr9_sgpr10_sgpr11
  ; GCN-NEXT:   $vgpr2 = V_MOV_B32_e32 $sgpr9, implicit $exec, implicit $sgpr8_sgpr9_sgpr10_sgpr11
  ; GCN-NEXT:   $vgpr3 = V_MOV_B32_e32 $sgpr10, implicit $exec, implicit $sgpr8_sgpr9_sgpr10_sgpr11
  ; GCN-NEXT:   $vgpr4 = V_MOV_B32_e32 killed $sgpr11, implicit $exec, implicit $sgpr8_sgpr9_sgpr10_sgpr11, implicit $exec
  ; GCN-NEXT:   GLOBAL_STORE_DWORDX4_SADDR renamable $vgpr0, killed renamable $vgpr1_vgpr2_vgpr3_vgpr4, renamable $sgpr0_sgpr1, 0, 0, implicit $exec :: (store (s128) into %ir.lsr.iv6, align 4, addrspace 1)
  ; GCN-NEXT:   renamable $sgpr0 = S_ADD_U32 killed renamable $sgpr0, 16, implicit-def $scc
  ; GCN-NEXT:   renamable $sgpr1 = S_ADDC_U32 killed renamable $sgpr1, 0, implicit-def dead $scc, implicit killed $scc
  ; GCN-NEXT:   S_CMP_LG_U32 renamable $sgpr4, 0, implicit-def $scc
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.2, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.3.for.end:
  ; GCN-NEXT:   S_ENDPGM 0
entry:
  %cmp6.not = icmp eq i32 %n, 0
  br i1 %cmp6.not, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.07 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %idxprom = zext i32 %i.07 to i64
  %arrayidx = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(4)* %s, i64 %idxprom
  %ld = load <4 x i32>, <4 x i32> addrspace(4)* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(1)* %d, i64 %idxprom
  store <4 x i32> %ld, <4 x i32> addrspace(1)* %arrayidx2, align 4
  %inc = add nuw i32 %i.07, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}

define amdgpu_kernel void @copy_local(<4 x i32> addrspace(3)* nocapture %d, <4 x i32> addrspace(3)* nocapture readonly %s, i32 %n) {
  ; GCN-LABEL: name: copy_local
  ; GCN: bb.0.entry:
  ; GCN-NEXT:   successors: %bb.1(0x50000000), %bb.3(0x30000000)
  ; GCN-NEXT:   liveins: $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr2 = S_LOAD_DWORD_IMM renamable $sgpr0_sgpr1, 44, 0 :: (dereferenceable invariant load (s32) from %ir.0 + 8, addrspace 4)
  ; GCN-NEXT:   S_CMP_EQ_U32 renamable $sgpr2, 0, implicit-def $scc
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.3, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.1.for.body.preheader:
  ; GCN-NEXT:   successors: %bb.2(0x80000000)
  ; GCN-NEXT:   liveins: $sgpr2, $sgpr0_sgpr1
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   renamable $sgpr0_sgpr1 = S_LOAD_DWORDX2_IMM killed renamable $sgpr0_sgpr1, 36, 0 :: (dereferenceable invariant load (s64) from %ir.0, align 4, addrspace 4)
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.2.for.body:
  ; GCN-NEXT:   successors: %bb.3(0x04000000), %bb.2(0x7c000000)
  ; GCN-NEXT:   liveins: $sgpr2, $sgpr0_sgpr1:0x000000000000000F
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT:   $vgpr2 = V_MOV_B32_e32 $sgpr1, implicit $exec, implicit $exec
  ; GCN-NEXT:   $vgpr4 = V_MOV_B32_e32 $sgpr0, implicit $exec, implicit $exec
  ; GCN-NEXT:   renamable $sgpr2 = S_ADD_I32 killed renamable $sgpr2, -1, implicit-def dead $scc
  ; GCN-NEXT:   renamable $sgpr0 = S_ADD_I32 killed renamable $sgpr0, 16, implicit-def dead $scc
  ; GCN-NEXT:   renamable $sgpr1 = S_ADD_I32 killed renamable $sgpr1, 16, implicit-def dead $scc
  ; GCN-NEXT:   BUNDLE implicit-def $vgpr0_vgpr1, implicit-def $vgpr0, implicit-def $vgpr0_lo16, implicit-def $vgpr0_hi16, implicit-def $vgpr1, implicit-def $vgpr1_lo16, implicit-def $vgpr1_hi16, implicit-def $vgpr2_vgpr3, implicit-def $vgpr2, implicit-def $vgpr2_lo16, implicit-def $vgpr2_hi16, implicit-def $vgpr3, implicit-def $vgpr3_lo16, implicit-def $vgpr3_hi16, implicit killed $vgpr2, implicit $exec {
  ; GCN-NEXT:     renamable $vgpr0_vgpr1 = DS_READ2_B32_gfx9 renamable $vgpr2, 2, 3, 0, implicit $exec :: (load (s64) from %ir.lsr.iv3 + 8, align 4, addrspace 3)
  ; GCN-NEXT:     renamable $vgpr2_vgpr3 = DS_READ2_B32_gfx9 killed renamable $vgpr2, 0, 1, 0, implicit $exec :: (load (s64) from %ir.lsr.iv3, align 4, addrspace 3)
  ; GCN-NEXT:   }
  ; GCN-NEXT:   S_CMP_LG_U32 renamable $sgpr2, 0, implicit-def $scc
  ; GCN-NEXT:   BUNDLE implicit killed $vgpr4, implicit killed $vgpr0, implicit killed $vgpr1, implicit $exec, implicit killed $vgpr2, implicit killed $vgpr3 {
  ; GCN-NEXT:     DS_WRITE2_B32_gfx9 renamable $vgpr4, killed renamable $vgpr0, killed renamable $vgpr1, 2, 3, 0, implicit $exec :: (store (s64) into %ir.lsr.iv + 8, align 4, addrspace 3)
  ; GCN-NEXT:     DS_WRITE2_B32_gfx9 killed renamable $vgpr4, killed renamable $vgpr2, killed renamable $vgpr3, 0, 1, 0, implicit $exec :: (store (s64) into %ir.lsr.iv, align 4, addrspace 3)
  ; GCN-NEXT:   }
  ; GCN-NEXT:   S_CBRANCH_SCC1 %bb.2, implicit killed $scc
  ; GCN-NEXT: {{  $}}
  ; GCN-NEXT: bb.3.for.end:
  ; GCN-NEXT:   S_ENDPGM 0
entry:
  %cmp6.not = icmp eq i32 %n, 0
  br i1 %cmp6.not, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.07 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  %idxprom = zext i32 %i.07 to i64
  %arrayidx = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(3)* %s, i64 %idxprom
  %ld = load <4 x i32>, <4 x i32> addrspace(3)* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds <4 x i32>, <4 x i32> addrspace(3)* %d, i64 %idxprom
  store <4 x i32> %ld, <4 x i32> addrspace(3)* %arrayidx2, align 4
  %inc = add nuw i32 %i.07, 1
  %exitcond.not = icmp eq i32 %inc, %n
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body, %entry
  ret void
}
