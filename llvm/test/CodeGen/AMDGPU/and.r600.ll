; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN:  llc -amdgpu-scalarize-global-loads=false  -mtriple=r600 -mcpu=redwood < %s | FileCheck -check-prefix=EG %s


define amdgpu_kernel void @test2(ptr addrspace(1) %out, ptr addrspace(1) %in) {
; EG-LABEL: test2:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 3, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_128 T0.XYZW, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, KC0[2].Z,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     AND_INT * T0.Y, T0.Y, T0.W,
; EG-NEXT:     AND_INT T0.X, T0.X, T0.Z,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %b_ptr = getelementptr <2 x i32>, ptr addrspace(1) %in, i32 1
  %a = load <2 x i32>, ptr addrspace(1) %in
  %b = load <2 x i32>, ptr addrspace(1) %b_ptr
  %result = and <2 x i32> %a, %b
  store <2 x i32> %result, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test4(ptr addrspace(1) %out, ptr addrspace(1) %in) {
; EG-LABEL: test4:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @10, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 1 @6
; EG-NEXT:    ALU 5, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XYZW, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_128 T1.XYZW, T0.X, 16, #1
; EG-NEXT:     VTX_READ_128 T0.XYZW, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 10:
; EG-NEXT:     MOV * T0.X, KC0[2].Z,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T0.W, T0.W, T1.W,
; EG-NEXT:     AND_INT * T0.Z, T0.Z, T1.Z,
; EG-NEXT:     AND_INT * T0.Y, T0.Y, T1.Y,
; EG-NEXT:     AND_INT T0.X, T0.X, T1.X,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %b_ptr = getelementptr <4 x i32>, ptr addrspace(1) %in, i32 1
  %a = load <4 x i32>, ptr addrspace(1) %in
  %b = load <4 x i32>, ptr addrspace(1) %b_ptr
  %result = and <4 x i32> %a, %b
  store <4 x i32> %result, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @s_and_i32(ptr addrspace(1) %out, i32 %a, i32 %b) {
; EG-LABEL: s_and_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T0.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     LSHR T0.X, KC0[2].Y, literal.x,
; EG-NEXT:     AND_INT * T1.X, KC0[2].Z, KC0[2].W,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i32 %a, %b
  store i32 %and, ptr addrspace(1) %out, align 4
  ret void
}

define amdgpu_kernel void @s_and_constant_i32(ptr addrspace(1) %out, i32 %a) {
; EG-LABEL: s_and_constant_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T0.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     LSHR T0.X, KC0[2].Y, literal.x,
; EG-NEXT:     AND_INT * T1.X, KC0[2].Z, literal.y,
; EG-NEXT:    2(2.802597e-45), 1234567(1.729997e-39)
  %and = and i32 %a, 1234567
  store i32 %and, ptr addrspace(1) %out, align 4
  ret void
}

; FIXME: We should really duplicate the constant so that the SALU use
; can fold into the s_and_b32 and the VALU one is materialized
; directly without copying from the SGPR.

; Second use is a VGPR use of the constant.

define amdgpu_kernel void @s_and_multi_use_constant_i32_0(ptr addrspace(1) %out, i32 %a, i32 %b) {
; EG-LABEL: s_and_multi_use_constant_i32_0:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 5, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T2.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T2.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     MOV T0.X, literal.x,
; EG-NEXT:     AND_INT * T0.W, KC0[2].Z, literal.x,
; EG-NEXT:    1234567(1.729997e-39), 0(0.000000e+00)
; EG-NEXT:     ADD_INT T1.X, PV.W, KC0[2].W,
; EG-NEXT:     LSHR * T2.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i32 %a, 1234567

  ; Just to stop future replacement of copy to vgpr + store with VALU op.
  %foo = add i32 %and, %b
  store volatile i32 %foo, ptr addrspace(1) %out
  store volatile i32 1234567, ptr addrspace(1) %out
  ret void
}

; Second use is another SGPR use of the constant.

define amdgpu_kernel void @s_and_multi_use_constant_i32_1(ptr addrspace(1) %out, i32 %a, i32 %b) {
; EG-LABEL: s_and_multi_use_constant_i32_1:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 5, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.W, KC0[2].Z, literal.x,
; EG-NEXT:    1234567(1.729997e-39), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.W, PV.W, KC0[2].W,
; EG-NEXT:     ADD_INT T0.X, PV.W, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    1234567(1.729997e-39), 2(2.802597e-45)
  %and = and i32 %a, 1234567
  %foo = add i32 %and, 1234567
  %bar = add i32 %foo, %b
  store volatile i32 %bar, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @v_and_i32_vgpr_vgpr(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr) {
; EG-LABEL: v_and_i32_vgpr_vgpr:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @10, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 1 @6
; EG-NEXT:    ALU 3, @14, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T1.X, T1.X, 0, #1
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 10:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT T0.X, KC0[2].Z, PV.W,
; EG-NEXT:     ADD_INT * T1.X, KC0[2].W, PV.W,
; EG-NEXT:    ALU clause starting at 14:
; EG-NEXT:     AND_INT T0.X, T0.X, T1.X,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LSHR * T1.X, PV.W, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.a = getelementptr i32, ptr addrspace(1) %aptr, i32 %tid
  %gep.b = getelementptr i32, ptr addrspace(1) %bptr, i32 %tid
  %gep.out = getelementptr i32, ptr addrspace(1) %out, i32 %tid
  %a = load i32, ptr addrspace(1) %gep.a
  %b = load i32, ptr addrspace(1) %gep.b
  %and = and i32 %a, %b
  store i32 %and, ptr addrspace(1) %gep.out
  ret void
}

define amdgpu_kernel void @v_and_i32_sgpr_vgpr(ptr addrspace(1) %out, i32 %a, ptr addrspace(1) %bptr) {
; EG-LABEL: v_and_i32_sgpr_vgpr:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 3, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].W, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, KC0[2].Z, T0.X,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LSHR * T1.X, PV.W, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.b = getelementptr i32, ptr addrspace(1) %bptr, i32 %tid
  %gep.out = getelementptr i32, ptr addrspace(1) %out, i32 %tid
  %b = load i32, ptr addrspace(1) %gep.b
  %and = and i32 %a, %b
  store i32 %and, ptr addrspace(1) %gep.out
  ret void
}

define amdgpu_kernel void @v_and_i32_vgpr_sgpr(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i32 %b) {
; EG-LABEL: v_and_i32_vgpr_sgpr:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 3, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, T0.X, KC0[2].W,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LSHR * T1.X, PV.W, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.a = getelementptr i32, ptr addrspace(1) %aptr, i32 %tid
  %gep.out = getelementptr i32, ptr addrspace(1) %out, i32 %tid
  %a = load i32, ptr addrspace(1) %gep.a
  %and = and i32 %a, %b
  store i32 %and, ptr addrspace(1) %gep.out
  ret void
}

define amdgpu_kernel void @v_and_constant_i32(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_constant_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 2, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    1234567(1.729997e-39), 2(2.802597e-45)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep = getelementptr i32, ptr addrspace(1) %aptr, i32 %tid
  %a = load i32, ptr addrspace(1) %gep, align 4
  %and = and i32 %a, 1234567
  store i32 %and, ptr addrspace(1) %out, align 4
  ret void
}

define amdgpu_kernel void @v_and_inline_imm_64_i32(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_inline_imm_64_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 2, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    64(8.968310e-44), 2(2.802597e-45)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep = getelementptr i32, ptr addrspace(1) %aptr, i32 %tid
  %a = load i32, ptr addrspace(1) %gep, align 4
  %and = and i32 %a, 64
  store i32 %and, ptr addrspace(1) %out, align 4
  ret void
}

define amdgpu_kernel void @v_and_inline_imm_neg_16_i32(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_inline_imm_neg_16_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 2, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    -16(nan), 2(2.802597e-45)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep = getelementptr i32, ptr addrspace(1) %aptr, i32 %tid
  %a = load i32, ptr addrspace(1) %gep, align 4
  %and = and i32 %a, -16
  store i32 %and, ptr addrspace(1) %out, align 4
  ret void
}

define amdgpu_kernel void @s_and_i64(ptr addrspace(1) %out, i64 %a, i64 %b) {
; EG-LABEL: s_and_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, KC0[3].Z,
; EG-NEXT:     AND_INT * T0.X, KC0[2].W, KC0[3].Y,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, %b
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_i1(ptr addrspace(1) %out, i1 %a, i1 %b) {
; EG-LABEL: s_and_i1:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @10, KC0[], KC1[]
; EG-NEXT:    TEX 1 @6
; EG-NEXT:    ALU 12, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_8 T1.X, T0.X, 40, #3
; EG-NEXT:     VTX_READ_8 T0.X, T0.X, 41, #3
; EG-NEXT:    ALU clause starting at 10:
; EG-NEXT:     MOV * T0.X, 0.0,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.W, KC0[2].Y, literal.x,
; EG-NEXT:     AND_INT * T1.W, T1.X, T0.X,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     AND_INT T1.W, PS, 1,
; EG-NEXT:     LSHL * T0.W, PV.W, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    255(3.573311e-43), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i1 %a, %b
  store i1 %and, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @s_and_constant_i64(ptr addrspace(1) %out, i64 %a) {
; EG-LABEL: s_and_constant_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    128(1.793662e-43), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.X, KC0[2].W, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    524288(7.346840e-40), 2(2.802597e-45)
  %and = and i64 %a, 549756338176
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_multi_use_constant_i64(ptr addrspace(1) %out, i64 %a, i64 %b) {
; EG-LABEL: s_and_multi_use_constant_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 10, @6, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T5.X, T4.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T3.X, T2.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T2.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T4.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    ALU clause starting at 6:
; EG-NEXT:     AND_INT T0.X, KC0[3].Y, literal.x,
; EG-NEXT:     AND_INT * T1.X, KC0[3].Z, literal.y,
; EG-NEXT:    524288(7.346840e-40), 128(1.793662e-43)
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, literal.x,
; EG-NEXT:    4(5.605194e-45), 0(0.000000e+00)
; EG-NEXT:     LSHR T2.X, PV.W, literal.x,
; EG-NEXT:     AND_INT * T3.X, KC0[3].X, literal.y,
; EG-NEXT:    2(2.802597e-45), 128(1.793662e-43)
; EG-NEXT:     LSHR T4.X, KC0[2].Y, literal.x,
; EG-NEXT:     AND_INT * T5.X, KC0[2].W, literal.y,
; EG-NEXT:    2(2.802597e-45), 524288(7.346840e-40)
  %and0 = and i64 %a, 549756338176
  %and1 = and i64 %b, 549756338176
  store volatile i64 %and0, ptr addrspace(1) %out
  store volatile i64 %and1, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @s_and_32_bit_constant_i64(ptr addrspace(1) %out, i32, i64 %a) {
; EG-LABEL: s_and_32_bit_constant_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT T0.X, KC0[2].W, literal.x,
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    1234567(1.729997e-39), 2(2.802597e-45)
  %and = and i64 %a, 1234567
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_multi_use_inline_imm_i64(ptr addrspace(1) %out, i32, i64 %a, i32, i64 %b, i32, i64 %c) {
; EG-LABEL: s_and_multi_use_inline_imm_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 17, @6, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T4.X, T5.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T2.X, T3.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T3.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T5.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    ALU clause starting at 6:
; EG-NEXT:     LSHL T0.W, KC0[3].W, 1,
; EG-NEXT:     LSHL * T1.W, KC0[2].W, 1,
; EG-NEXT:     AND_INT * T0.W, PV.W, literal.x,
; EG-NEXT:    62(8.688050e-44), 0(0.000000e+00)
; EG-NEXT:     ADD_INT T0.X, PV.W, KC0[4].W,
; EG-NEXT:     AND_INT T1.W, T1.W, literal.x,
; EG-NEXT:     ADDC_UINT * T0.W, PV.W, KC0[4].W,
; EG-NEXT:    62(8.688050e-44), 0(0.000000e+00)
; EG-NEXT:     ADD_INT T1.X, KC0[5].X, PS,
; EG-NEXT:     ADDC_UINT * T0.W, PV.W, KC0[4].W,
; EG-NEXT:     ADD_INT T2.X, KC0[5].X, PV.W,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, literal.x,
; EG-NEXT:    4(5.605194e-45), 0(0.000000e+00)
; EG-NEXT:     LSHR T3.X, PV.W, literal.x,
; EG-NEXT:     ADD_INT * T4.X, T1.W, KC0[4].W,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     LSHR * T5.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %shl.a = shl i64 %a, 1
  %shl.b = shl i64 %b, 1
  %and0 = and i64 %shl.a, 62
  %and1 = and i64 %shl.b, 62
  %add0 = add i64 %and0, %c
  %add1 = add i64 %and1, %c
  store volatile i64 %add0, ptr addrspace(1) %out
  store volatile i64 %add1, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @v_and_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr) {
; EG-LABEL: v_and_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @10, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 1 @6
; EG-NEXT:    ALU 3, @14, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_64 T1.XY, T1.X, 0, #1
; EG-NEXT:     VTX_READ_64 T0.XY, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 10:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT T0.X, KC0[2].Z, PV.W,
; EG-NEXT:     ADD_INT * T1.X, KC0[2].W, PV.W,
; EG-NEXT:    ALU clause starting at 14:
; EG-NEXT:     AND_INT * T0.Y, T0.Y, T1.Y,
; EG-NEXT:     AND_INT T0.X, T0.X, T1.X,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.a = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %a = load i64, ptr addrspace(1) %gep.a, align 8
  %gep.b = getelementptr i64, ptr addrspace(1) %bptr, i32 %tid
  %b = load i64, ptr addrspace(1) %gep.b, align 8
  %and = and i64 %a, %b
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @v_and_constant_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_constant_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 4, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_64 T0.XY, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T0.Y, T0.Y, literal.x,
; EG-NEXT:    286(4.007714e-43), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    -1424379385(-5.460358e-13), 2(2.802597e-45)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.a = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %a = load i64, ptr addrspace(1) %gep.a, align 8
  %and = and i64 %a, 1231231234567
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @v_and_multi_use_constant_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_multi_use_constant_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 1, @20, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @12
; EG-NEXT:    ALU 0, @22, KC0[], KC1[]
; EG-NEXT:    TEX 0 @14
; EG-NEXT:    ALU 0, @23, KC0[], KC1[]
; EG-NEXT:    TEX 1 @16
; EG-NEXT:    ALU 10, @24, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T5.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T2.X, T4.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T3.X, T5.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T4.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    Fetch clause starting at 12:
; EG-NEXT:     VTX_READ_32 T1.X, T1.X, 4, #1
; EG-NEXT:    Fetch clause starting at 14:
; EG-NEXT:     VTX_READ_32 T2.X, T2.X, 0, #1
; EG-NEXT:    Fetch clause starting at 16:
; EG-NEXT:     VTX_READ_32 T3.X, T3.X, 4, #1
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 20:
; EG-NEXT:     MOV * T0.X, KC0[2].Z,
; EG-NEXT:     MOV * T1.X, PV.X,
; EG-NEXT:    ALU clause starting at 22:
; EG-NEXT:     MOV * T2.X, T0.X,
; EG-NEXT:    ALU clause starting at 23:
; EG-NEXT:     MOV * T3.X, T0.X,
; EG-NEXT:    ALU clause starting at 24:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     AND_INT * T3.X, T3.X, literal.y,
; EG-NEXT:    -1424379385(-5.460358e-13), 286(4.007714e-43)
; EG-NEXT:     AND_INT T2.X, T2.X, literal.x,
; EG-NEXT:     LSHR * T4.X, KC0[2].Y, literal.y,
; EG-NEXT:    -1424379385(-5.460358e-13), 2(2.802597e-45)
; EG-NEXT:     AND_INT T1.X, T1.X, literal.x,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, literal.y,
; EG-NEXT:    286(4.007714e-43), 4(5.605194e-45)
; EG-NEXT:     LSHR * T5.X, PV.W, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %a = load volatile i64, ptr addrspace(1) %aptr
  %b = load volatile i64, ptr addrspace(1) %aptr
  %and0 = and i64 %a, 1231231234567
  %and1 = and i64 %b, 1231231234567
  store volatile i64 %and0, ptr addrspace(1) %out
  store volatile i64 %and1, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @v_and_multi_use_inline_imm_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_multi_use_inline_imm_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 1, @20, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @12
; EG-NEXT:    ALU 0, @22, KC0[], KC1[]
; EG-NEXT:    TEX 0 @14
; EG-NEXT:    ALU 0, @23, KC0[], KC1[]
; EG-NEXT:    TEX 1 @16
; EG-NEXT:    ALU 8, @24, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T4.X, T3.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T2.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T4.X, T3.X, 0
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T2.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    Fetch clause starting at 12:
; EG-NEXT:     VTX_READ_32 T1.X, T1.X, 4, #1
; EG-NEXT:    Fetch clause starting at 14:
; EG-NEXT:     VTX_READ_32 T1.X, T1.X, 0, #1
; EG-NEXT:    Fetch clause starting at 16:
; EG-NEXT:     VTX_READ_32 T2.X, T2.X, 4, #1
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 20:
; EG-NEXT:     MOV * T0.X, KC0[2].Z,
; EG-NEXT:     MOV * T1.X, PV.X,
; EG-NEXT:    ALU clause starting at 22:
; EG-NEXT:     MOV * T1.X, T0.X,
; EG-NEXT:    ALU clause starting at 23:
; EG-NEXT:     MOV * T2.X, T0.X,
; EG-NEXT:    ALU clause starting at 24:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     AND_INT * T1.X, T1.X, literal.x,
; EG-NEXT:    63(8.828180e-44), 0(0.000000e+00)
; EG-NEXT:     LSHR T2.X, KC0[2].Y, literal.x,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, literal.y,
; EG-NEXT:    2(2.802597e-45), 4(5.605194e-45)
; EG-NEXT:     LSHR T3.X, PV.W, literal.x,
; EG-NEXT:     MOV * T4.X, literal.y,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %a = load volatile i64, ptr addrspace(1) %aptr
  %b = load volatile i64, ptr addrspace(1) %aptr
  %and0 = and i64 %a, 63
  %and1 = and i64 %b, 63
  store volatile i64 %and0, ptr addrspace(1) %out
  store volatile i64 %and1, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @v_and_i64_32_bit_constant(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_i64_32_bit_constant:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 3, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    1234567(1.729997e-39), 2(2.802597e-45)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.a = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %a = load i64, ptr addrspace(1) %gep.a, align 8
  %and = and i64 %a, 1234567
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @v_and_inline_imm_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_inline_imm_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 3, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    64(8.968310e-44), 2(2.802597e-45)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.a = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %a = load i64, ptr addrspace(1) %gep.a, align 8
  %and = and i64 %a, 64
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

; FIXME: Should be able to reduce load width

define amdgpu_kernel void @v_and_inline_neg_imm_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr) {
; EG-LABEL: v_and_inline_neg_imm_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 2, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_64 T0.XY, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT T0.X, T0.X, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    -8(nan), 2(2.802597e-45)
  %tid = call i32 @llvm.amdgcn.workitem.id.x() #0
  %gep.a = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %a = load i64, ptr addrspace(1) %gep.a, align 8
  %and = and i64 %a, -8
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_64_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_64_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT T0.X, KC0[2].W, literal.x,
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    64(8.968310e-44), 2(2.802597e-45)
  %and = and i64 %a, 64
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_64_i64_noshrink(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a, i32, i64 %b) {
; EG-LABEL: s_and_inline_imm_64_i64_noshrink:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 7, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     LSHL * T0.W, KC0[2].W, 1,
; EG-NEXT:     AND_INT * T0.W, PV.W, literal.x,
; EG-NEXT:    64(8.968310e-44), 0(0.000000e+00)
; EG-NEXT:     ADD_INT T0.X, PV.W, KC0[3].W,
; EG-NEXT:     ADDC_UINT T0.W, PV.W, KC0[3].W,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.Y, KC0[4].X, PV.W,
  %shl = shl i64 %a, 1
  %and = and i64 %shl, 64
  %add = add i64 %and, %b
  store i64 %add, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_1_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_1_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT T0.X, KC0[2].W, 1,
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 1
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_1.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_1.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    1072693248(1.875000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 4607182418800017408
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_neg_1.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_neg_1.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    -1074790400(-1.875000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 13830554455654793216
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_0.5_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_0.5_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    1071644672(1.750000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 4602678819172646912
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_neg_0.5_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_neg_0.5_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    -1075838976(-1.750000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 13826050856027422720
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_2.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_2.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    1073741824(2.000000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 4611686018427387904
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_neg_2.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_neg_2.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    -1073741824(-2.000000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 13835058055282163712
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_4.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_4.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    1074790400(2.250000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 4616189618054758400
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_neg_4.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_neg_4.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    -1072693248(-2.250000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 13839561654909534208
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

; Test with the 64-bit integer bitpattern for a 32-bit float in the
; low 32-bits, which is not a valid 64-bit inline immmediate.

define amdgpu_kernel void @s_and_inline_imm_f32_4.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_f32_4.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT T0.X, KC0[2].W, literal.x,
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    1082130432(4.000000e+00), 2(2.802597e-45)
  %and = and i64 %a, 1082130432
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_imm_f32_neg_4.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_imm_f32_neg_4.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     MOV * T0.Y, KC0[3].X,
; EG-NEXT:     AND_INT T0.X, KC0[2].W, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    -1065353216(-4.000000e+00), 2(2.802597e-45)
  %and = and i64 %a, -1065353216
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

; Shift into upper 32-bits

define amdgpu_kernel void @s_and_inline_high_imm_f32_4.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_high_imm_f32_4.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    1082130432(4.000000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 4647714815446351872
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}

define amdgpu_kernel void @s_and_inline_high_imm_f32_neg_4.0_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, i64 %a) {
; EG-LABEL: s_and_inline_high_imm_f32_neg_4.0_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 4, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.Y, KC0[3].X, literal.x,
; EG-NEXT:    -1065353216(-4.000000e+00), 0(0.000000e+00)
; EG-NEXT:     MOV T0.X, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and = and i64 %a, 13871086852301127680
  store i64 %and, ptr addrspace(1) %out, align 8
  ret void
}
attributes #0 = { nounwind readnone }
