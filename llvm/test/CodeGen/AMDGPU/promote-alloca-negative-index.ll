; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -passes=amdgpu-promote-alloca -disable-promote-alloca-to-lds=1 < %s | FileCheck %s

; Check that the extracted index is correctly sign-extended when 32-bit scratch
; address arithmetic is promoted to 64-bit vector index arithmetic.

define amdgpu_kernel void @negative_index_byte(ptr %out, i64 %offset) {
; CHECK-LABEL: @negative_index_byte(
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i8> [[STACK]], i8 0, i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <4 x i8> [[TMP1]], i8 1, i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i8> [[TMP2]], i8 2, i32 2
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <4 x i8> [[TMP3]], i8 3, i32 3
; CHECK-NEXT:    [[TMP5:%.*]] = add i64 [[OFFSET:%.*]], -1
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x i8> [[TMP4]], i64 [[TMP5]]
; CHECK-NEXT:    store i8 [[TMP6]], ptr [[OUT:%.*]], align 1
; CHECK-NEXT:    ret void
;
  %stack = alloca [4 x i8], align 4, addrspace(5)
  %gep.0 = getelementptr inbounds [4 x i8], ptr addrspace(5) %stack, i64 0, i64 0
  %gep.1 = getelementptr inbounds [4 x i8], ptr addrspace(5) %stack, i64 0, i64 1
  %gep.2 = getelementptr inbounds [4 x i8], ptr addrspace(5) %stack, i64 0, i64 2
  %gep.3 = getelementptr inbounds [4 x i8], ptr addrspace(5) %stack, i64 0, i64 3
  store i8 0, ptr addrspace(5) %gep.0
  store i8 1, ptr addrspace(5) %gep.1
  store i8 2, ptr addrspace(5) %gep.2
  store i8 3, ptr addrspace(5) %gep.3
  %vgep = getelementptr inbounds [4 x i8], ptr addrspace(5) %stack, i64 0, i64 %offset
  %cgep = getelementptr inbounds [4 x i8], ptr addrspace(5) %vgep, i64 0, i64 -1
  %load = load i8, ptr addrspace(5) %cgep
  store i8 %load, ptr %out
  ret void
}

define amdgpu_kernel void @negative_index_word(ptr %out, i64 %offset) {
; CHECK-LABEL: @negative_index_word(
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i32> poison
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <4 x i32> [[STACK]], i32 0, i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <4 x i32> [[TMP1]], i32 1, i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <4 x i32> [[TMP2]], i32 2, i32 2
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <4 x i32> [[TMP3]], i32 3, i32 3
; CHECK-NEXT:    [[TMP5:%.*]] = add i64 [[OFFSET:%.*]], -1
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x i32> [[TMP4]], i64 [[TMP5]]
; CHECK-NEXT:    store i32 [[TMP6]], ptr [[OUT:%.*]], align 4
; CHECK-NEXT:    ret void
;
  %stack = alloca [4 x i32], align 4, addrspace(5)
  %gep.0 = getelementptr inbounds [4 x i32], ptr addrspace(5) %stack, i64 0, i64 0
  %gep.1 = getelementptr inbounds [4 x i32], ptr addrspace(5) %stack, i64 0, i64 1
  %gep.2 = getelementptr inbounds [4 x i32], ptr addrspace(5) %stack, i64 0, i64 2
  %gep.3 = getelementptr inbounds [4 x i32], ptr addrspace(5) %stack, i64 0, i64 3
  store i32 0, ptr addrspace(5) %gep.0
  store i32 1, ptr addrspace(5) %gep.1
  store i32 2, ptr addrspace(5) %gep.2
  store i32 3, ptr addrspace(5) %gep.3
  %vgep = getelementptr inbounds [4 x i32], ptr addrspace(5) %stack, i64 0, i64 %offset
  %cgep = getelementptr inbounds [4 x i32], ptr addrspace(5) %vgep, i64 0, i64 -1
  %load = load i32, ptr addrspace(5) %cgep
  store i32 %load, ptr %out
  ret void
}


