# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc -mtriple=amdgcn -mcpu=gfx1200 -run-pass=prologepilog -o - %s | FileCheck %s

---
name:            save_inactive_lanes_non_csr_vgpr
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
frameInfo:
  maxAlignment:    1
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  sgprForEXECCopy: '$sgpr105'
  isWholeWaveFunction: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: save_inactive_lanes_non_csr_vgpr
    ; CHECK: liveins: $vgpr0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $sgpr0 = S_XOR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr0, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 -1
    ; CHECK-NEXT: $vgpr0 = V_MOV_B32_e32 14, implicit $exec
    ; CHECK-NEXT: $exec_lo = S_XOR_B32 $sgpr0, -1, implicit-def $scc
    ; CHECK-NEXT: $vgpr0 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr, implicit $vgpr0(tied-def 0) :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $sgpr0
    ; CHECK-NEXT: SI_RETURN implicit killed $vgpr0
    renamable $sgpr0 = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    $vgpr0 = V_MOV_B32_e32 14, implicit $exec
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $sgpr0, implicit killed $vgpr0

...
---
name:            save_all_lanes_csr_vgpr
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
frameInfo:
  maxAlignment:    1
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  sgprForEXECCopy: '$sgpr105'
  isWholeWaveFunction: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: save_all_lanes_csr_vgpr
    ; CHECK: liveins: $vgpr40
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $sgpr0 = S_OR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr40, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: $vgpr40 = V_MOV_B32_e32 14, implicit $exec
    ; CHECK-NEXT: $vgpr40 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $sgpr0
    ; CHECK-NEXT: SI_RETURN
    renamable $sgpr0 = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    $vgpr40 = V_MOV_B32_e32 14, implicit $exec
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $sgpr0

...
---
name:            save_csr_sgpr_to_non_csr_vgpr
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
frameInfo:
  maxAlignment:    1
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  sgprForEXECCopy: '$sgpr105'
  isWholeWaveFunction: true
body:             |
  bb.0:
    liveins: $sgpr20, $vgpr191
    ; CHECK-LABEL: name: save_csr_sgpr_to_non_csr_vgpr
    ; CHECK: liveins: $sgpr20, $vgpr191, $vgpr192
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $vcc_lo = S_XOR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr192, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 -1
    ; CHECK-NEXT: $vgpr192 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr192
    ; CHECK-NEXT: $sgpr20 = S_MOV_B32 14, implicit $exec
    ; CHECK-NEXT: $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr192, 0
    ; CHECK-NEXT: $exec_lo = S_XOR_B32 $vcc_lo, -1, implicit-def $scc
    ; CHECK-NEXT: $vgpr192 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $vcc_lo
    ; CHECK-NEXT: SI_RETURN
    $vgpr192 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr192
    renamable $vcc_lo = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    $sgpr20 = S_MOV_B32 14, implicit $exec
    $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr192, 0
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $vcc_lo

...
---
name:            save_csr_sgpr_to_csr_vgpr
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
frameInfo:
  maxAlignment:    1
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  sgprForEXECCopy: '$sgpr105'
  isWholeWaveFunction: true
body:             |
  bb.0:
    liveins: $sgpr20, $vgpr191
    ; CHECK-LABEL: name: save_csr_sgpr_to_csr_vgpr
    ; CHECK: liveins: $sgpr20, $vgpr191
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $vcc_lo = S_OR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr191, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: $vgpr191 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr191
    ; CHECK-NEXT: $sgpr20 = S_MOV_B32 14, implicit $exec
    ; CHECK-NEXT: $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr191, 0
    ; CHECK-NEXT: $vgpr191 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $vcc_lo
    ; CHECK-NEXT: SI_RETURN
    $vgpr191 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr191
    renamable $vcc_lo = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    $sgpr20 = S_MOV_B32 14, implicit $exec
    $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr191, 0
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $vcc_lo

...
---
name:            vgpr_and_sgpr_csr
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
liveins:
  - { reg: '$vgpr0' }
  - { reg: '$vgpr1' }
frameInfo:
  maxAlignment:    4
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  hasSpilledSGPRs: true
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  spillPhysVGPRs:
    - '$vgpr191'
  wwmReservedRegs:
    - '$vgpr191'
  isWholeWaveFunction: true
body:             |
  bb.0:
    liveins: $sgpr20, $vgpr0, $vgpr1, $vgpr191

    ; CHECK-LABEL: name: vgpr_and_sgpr_csr
    ; CHECK: liveins: $sgpr20, $vgpr0, $vgpr1, $vgpr40, $vgpr49
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $vcc_lo = S_XOR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr0, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr49, $sgpr32, 8, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.2, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 -1
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr40, $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.1, addrspace 5)
    ; CHECK-NEXT: $vgpr0 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr0
    ; CHECK-NEXT: S_NOP 0, implicit-def $vgpr40, implicit-def $sgpr20
    ; CHECK-NEXT: S_NOP 0, implicit-def $vgpr49, implicit-def $sgpr40
    ; CHECK-NEXT: $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr0, 0
    ; CHECK-NEXT: $vgpr40 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.1, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_XOR_B32 $vcc_lo, -1, implicit-def $scc
    ; CHECK-NEXT: $vgpr0 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $vgpr49 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 8, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.2, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $vcc_lo
    ; CHECK-NEXT: SI_RETURN
    $vgpr191 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr191
    renamable $vcc_lo = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    S_NOP 0, implicit-def $vgpr40, implicit-def $sgpr20
    S_NOP 0, implicit-def $vgpr49, implicit-def $sgpr40
    $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr191, 0
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $vcc_lo

...
---
name:            split_orig_exec
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
liveins:
  - { reg: '$vgpr0' }
  - { reg: '$vgpr1' }
frameInfo:
  maxAlignment:    4
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  hasSpilledSGPRs: true
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  spillPhysVGPRs:
    - '$vgpr191'
  wwmReservedRegs:
    - '$vgpr191'
  isWholeWaveFunction: true
body:             |
  bb.0:
    liveins: $sgpr20, $vgpr0, $vgpr1, $vgpr191

    ; CHECK-LABEL: name: split_orig_exec
    ; CHECK: liveins: $sgpr20, $vgpr0, $vgpr1, $vgpr40, $vgpr49
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $vcc_lo = S_XOR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr0, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr49, $sgpr32, 8, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.2, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 -1
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr40, $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.1, addrspace 5)
    ; CHECK-NEXT: $vgpr0 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr0
    ; CHECK-NEXT: S_NOP 0, implicit-def $vgpr40, implicit-def $sgpr20
    ; CHECK-NEXT: $sgpr3 = COPY $vcc_lo
    ; CHECK-NEXT: S_NOP 0, implicit-def $vgpr49, implicit-def $sgpr40
    ; CHECK-NEXT: $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr0, 0
    ; CHECK-NEXT: $vgpr40 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.1, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_XOR_B32 $sgpr3, -1, implicit-def $scc
    ; CHECK-NEXT: $vgpr0 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $vgpr49 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 8, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.2, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $sgpr3
    ; CHECK-NEXT: SI_RETURN
    $vgpr191 = SI_SPILL_S32_TO_VGPR killed $sgpr20, 0, $vgpr191
    renamable $vcc_lo = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    S_NOP 0, implicit-def $vgpr40, implicit-def $sgpr20
    $sgpr3 = COPY $vcc_lo
    S_NOP 0, implicit-def $vgpr49, implicit-def $sgpr40
    $sgpr20 = SI_RESTORE_S32_FROM_VGPR $vgpr191, 0
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $sgpr3

...
---
name:            vgpr_superregs
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
frameInfo:
  maxAlignment:    1
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  sgprForEXECCopy: '$sgpr105'
  isWholeWaveFunction: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: vgpr_superregs
    ; CHECK: liveins: $vgpr0, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr40, $vgpr41, $vgpr42
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $sgpr0 = S_XOR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr0, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr2, $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.1, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr3, $sgpr32, 8, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.2, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr4, $sgpr32, 12, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.3, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr5, $sgpr32, 16, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.4, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 -1
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr40, $sgpr32, 20, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.5, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr41, $sgpr32, 24, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.6, addrspace 5)
    ; CHECK-NEXT: SCRATCH_STORE_DWORD_SADDR $vgpr42, $sgpr32, 28, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.7, addrspace 5)
    ; CHECK-NEXT: $vgpr0 = V_MOV_B32_e32 14, implicit $exec
    ; CHECK-NEXT: S_NOP 0, implicit-def $vgpr2_vgpr3_vgpr4_vgpr5, implicit-def $vgpr40_vgpr41_vgpr42
    ; CHECK-NEXT: $vgpr40 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 20, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.5, addrspace 5)
    ; CHECK-NEXT: $vgpr41 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 24, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.6, addrspace 5)
    ; CHECK-NEXT: $vgpr42 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 28, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.7, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_XOR_B32 $sgpr0, -1, implicit-def $scc
    ; CHECK-NEXT: $vgpr0 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr, implicit $vgpr0(tied-def 0) :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $vgpr2 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.1, addrspace 5)
    ; CHECK-NEXT: $vgpr3 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 8, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.2, addrspace 5)
    ; CHECK-NEXT: $vgpr4 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 12, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.3, addrspace 5)
    ; CHECK-NEXT: $vgpr5 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 16, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.4, addrspace 5)
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $sgpr0
    ; CHECK-NEXT: SI_RETURN implicit killed $vgpr0
    renamable $sgpr0 = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    $vgpr0 = V_MOV_B32_e32 14, implicit $exec
    S_NOP 0, implicit-def $vgpr2_vgpr3_vgpr4_vgpr5, implicit-def $vgpr40_vgpr41_vgpr42
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $sgpr0, implicit killed $vgpr0

...
---
name:            dont_restore_used_vgprs
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
liveins:
  - { reg: '$vgpr0' }
  - { reg: '$vgpr20' }
  - { reg: '$vgpr40' }
frameInfo:
  maxAlignment:    1
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  sgprForEXECCopy: '$sgpr105'
  isWholeWaveFunction: true
body:             |
  bb.0:
    liveins: $vgpr0, $vgpr20, $vgpr40

    ; CHECK-LABEL: name: dont_restore_used_vgprs
    ; CHECK: liveins: $vgpr0, $vgpr20, $vgpr40
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $sgpr0 = S_XOR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
    ; CHECK-NEXT: S_NOP 0, implicit $vgpr0, implicit $vgpr20, implicit $vgpr40
    ; CHECK-NEXT: $exec_lo = S_MOV_B32 $sgpr0
    ; CHECK-NEXT: SI_RETURN implicit killed $vgpr0
    renamable $sgpr0 = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    S_NOP 0, implicit $vgpr0, implicit $vgpr20, implicit $vgpr40
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $sgpr0, implicit killed $vgpr0

...
---
name:            multiple_blocks
alignment:       1
tracksRegLiveness: true
noPhis:          true
isSSA:           false
noVRegs:         true
hasFakeUses:     false
tracksDebugUserValues: true
liveins:
  - { reg: '$vgpr0' }
  - { reg: '$vgpr1' }
frameInfo:
  maxAlignment:    1
  isCalleeSavedInfoValid: true
machineFunctionInfo:
  maxKernArgAlign: 1
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  returnsVoid:     false
  occupancy:       16
  sgprForEXECCopy: '$sgpr105'
  isWholeWaveFunction: true
body:             |
  ; CHECK-LABEL: name: multiple_blocks
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $vcc_lo = S_XOR_SAVEEXEC_B32 -1, implicit-def $exec, implicit-def dead $scc, implicit $exec
  ; CHECK-NEXT:   SCRATCH_STORE_DWORD_SADDR $vgpr0, $sgpr32, 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.0, addrspace 5)
  ; CHECK-NEXT:   SCRATCH_STORE_DWORD_SADDR $vgpr1, $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %stack.1, addrspace 5)
  ; CHECK-NEXT:   $exec_lo = S_MOV_B32 -1
  ; CHECK-NEXT:   $sgpr1 = S_MOV_B32 $exec_lo
  ; CHECK-NEXT:   V_CMPX_EQ_U32_nosdst_e64 $vgpr0, $vgpr1, implicit-def $exec, implicit $exec
  ; CHECK-NEXT:   S_CBRANCH_EXECZ %bb.2, implicit $exec
  ; CHECK-NEXT:   S_BRANCH %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $vcc_lo, $sgpr1, $vgpr0, $vgpr1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $vgpr1 = V_ADD_U32_e64 $vgpr0, $vgpr1, 0, implicit $exec
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   liveins: $vcc_lo, $sgpr1, $vgpr0, $vgpr1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $exec_lo = S_OR_B32 $exec_lo, killed renamable $sgpr1, implicit-def $scc
  ; CHECK-NEXT:   renamable $vgpr0 = V_CNDMASK_B32_e64 0, $vgpr1, 0, $vgpr0, $vcc_lo, implicit $exec
  ; CHECK-NEXT:   $exec_lo = S_XOR_B32 $vcc_lo, -1, implicit-def $scc
  ; CHECK-NEXT:   $vgpr0 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 0, 0, implicit $exec, implicit $flat_scr, implicit $vgpr0(tied-def 0) :: (load (s32) from %stack.0, addrspace 5)
  ; CHECK-NEXT:   $vgpr1 = SCRATCH_LOAD_DWORD_SADDR $sgpr32, 4, 0, implicit $exec, implicit $flat_scr :: (load (s32) from %stack.1, addrspace 5)
  ; CHECK-NEXT:   $exec_lo = S_MOV_B32 $vcc_lo
  ; CHECK-NEXT:   SI_RETURN implicit $vgpr0
  bb.0:
    successors: %bb.1, %bb.2
    liveins: $vgpr0, $vgpr1

    renamable $vcc_lo = SI_WHOLE_WAVE_FUNC_SETUP implicit-def dead $exec, implicit $exec
    $sgpr1 = S_MOV_B32 $exec_lo
    V_CMPX_EQ_U32_nosdst_e64 $vgpr0, $vgpr1, implicit-def $exec, implicit $exec
    S_CBRANCH_EXECZ %bb.2, implicit $exec
    S_BRANCH %bb.1

  bb.1:
    liveins: $vcc_lo, $sgpr1, $vgpr0, $vgpr1

    renamable $vgpr1 = V_ADD_U32_e64 $vgpr0, $vgpr1, 0, implicit $exec

  bb.2:
    liveins: $vcc_lo, $sgpr1, $vgpr0, $vgpr1

    $exec_lo = S_OR_B32 $exec_lo, killed renamable $sgpr1, implicit-def $scc
    renamable $vgpr0 = V_CNDMASK_B32_e64 0, $vgpr1, 0, $vgpr0, $vcc_lo, implicit $exec
    SI_WHOLE_WAVE_FUNC_RETURN killed renamable $vcc_lo, implicit $vgpr0

...
