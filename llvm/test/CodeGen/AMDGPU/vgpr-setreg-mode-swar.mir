# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 6
# RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1250 -run-pass=amdgpu-lower-vgpr-encoding -o - %s | FileCheck %s

# On certain targets, s_setreg_imm32_b32 always writes imm32[12:19] to mode[12:19]
# regardless of offset/mask. The pass must handle three cases:
#
# Case 1: Size <= 12 - Safe to set imm32[12:19] to VGPR MSBs
# Case 2: Size > 12, imm32[12:19] matches VGPR MSBs - No modification needed
# Case 3: Size > 12, imm32[12:19] doesn't match - Insert s_set_vgpr_msb after

# HwregEncoding: simm16 = (HwRegId) | (Offset << 6) | ((Size-1) << 11)
# ID_MODE = 1
# size=4:  simm16 = 1 | (0 << 6) | (3 << 11)  = 0x1801 = 6145
# size=12: simm16 = 1 | (0 << 6) | (11 << 11) = 0x5801 = 22529
# size=16: simm16 = 1 | (0 << 6) | (15 << 11) = 0x7801 = 30721

---
# Case 1a: Size < 12 (size=4), imm32[12:19]=0
# The pass should set imm32[12:19] to the VGPR MSBs (0x41 for dst=1,src0=1).
# New imm = 0x5 | (0x41 << 12) = 0x41005 = 266245
name:            setreg_size_lt_12
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_lt_12
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 266245, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    S_SETREG_IMM32_B32 5, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 1b: Size == 12 (boundary), imm32[12:19]=0
# The pass should set imm32[12:19] to the VGPR MSBs.
# New imm = 0xABC | (0x41 << 12) = 0x41ABC = 268988
name:            setreg_size_eq_12
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_eq_12
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 268988, 22529, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=12, offset=0, hwreg=MODE: simm16 = 0x5801 = 22529
    S_SETREG_IMM32_B32 2748, 22529, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 1c: Size <= 12 with existing non-zero bits in imm32[12:19]
# imm32 = 0x23005 (bits 12:19 = 0x23), should become 0x63005 after OR with VGPR MSBs (0x41)
# Result = 0x23005 | (0x41 << 12) = 0x63005 = 405509
name:            setreg_size_lt_12_nonzero_upper
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_lt_12_nonzero_upper
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 405509, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    ; imm32 = 0x23005 = 143365 (bits 12:19 = 0x23)
    S_SETREG_IMM32_B32 143365, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 2: Size > 12 (size=16), imm32[12:19] already matches VGPR MSBs (0x41)
# imm32 = 0x41ABC = 268988 (bits 12:19 = 0x41), no modification needed
name:            setreg_size_gt_12_match
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_gt_12_match
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 268988, 30721, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=16, offset=0, hwreg=MODE: simm16 = 0x7801 = 30721
    ; imm32 = 0x41ABC = 268988 (bits 12:19 = 0x41 = VGPR MSBs)
    S_SETREG_IMM32_B32 268988, 30721, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 3: Size > 12 (size=16), imm32[12:19] doesn't match VGPR MSBs
# imm32 = 0x23ABC = 146108 (bits 12:19 = 0x23 != 0x41), must insert s_set_vgpr_msb after
name:            setreg_size_gt_12_mismatch
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_gt_12_mismatch
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 146108, 30721, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=16, offset=0, hwreg=MODE: simm16 = 0x7801 = 30721
    ; imm32 = 0x23ABC = 146108 (bits 12:19 = 0x23 != 0x41)
    S_SETREG_IMM32_B32 146108, 30721, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 4: Non-MODE hwreg should not be modified
# This uses ID_STATUS=2 instead of ID_MODE=1
name:            setreg_non_mode_hwreg
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_non_mode_hwreg
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 5, 6146, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=STATUS(2): simm16 = 2 | (0 << 6) | (3 << 11) = 0x1802 = 6146
    S_SETREG_IMM32_B32 5, 6146, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 5: Size <= 12 but VGPR MSBs already present (no change needed)
# imm32 = 0x41005 = 266245 (bits 12:19 = 0x41), OR with 0x41 yields same value
name:            setreg_size_lt_12_already_correct
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_lt_12_already_correct
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 266245, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    ; imm32 = 0x41005 = 266245 (bits 12:19 = 0x41 = VGPR MSBs)
    S_SETREG_IMM32_B32 266245, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 6: Different VGPR MSB value (using different high VGPRs)
# vgpr512/513 uses MSB=2 for both dst and src0, so mode value = 0x82
# New imm = 0x5 | (0x82 << 12) = 0x82005 = 532485
name:            setreg_different_vgpr_msb
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_different_vgpr_msb
    ; CHECK: S_SET_VGPR_MSB 130, implicit-def $mode
    ; CHECK-NEXT: $vgpr512 = V_MOV_B32_e32 $vgpr513, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 532485, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr512 = V_MOV_B32_e32 $vgpr513, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    ; VGPR MSBs for vgpr512/513: mode = 0x82 = 130
    ; New imm = 0x5 | (0x82 << 12) = 0x82005 = 532485
    S_SETREG_IMM32_B32 5, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...
