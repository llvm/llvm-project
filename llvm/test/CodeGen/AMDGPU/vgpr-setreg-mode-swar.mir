# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 6
# RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1250 -run-pass=amdgpu-lower-vgpr-encoding -o - %s | FileCheck %s

---
# Case 1a: Size < 12 (size=4), imm32[12:19]=0
# The pass should set imm32[12:19] to the VGPR MSBs (0x41 for dst=1,src0=1).
# New imm = 0x5 | (0x41 << 12) = 0x41005 = 266245
name:            setreg_size_lt_12
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_lt_12
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 266245, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    S_SETREG_IMM32_B32 5, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 1b: Size == 12 (boundary), imm32[12:19]=0
# The pass should set imm32[12:19] to the VGPR MSBs.
# New imm = 0xABC | (0x41 << 12) = 0x41ABC = 268988
name:            setreg_size_eq_12
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_eq_12
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 268988, 22529, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=12, offset=0, hwreg=MODE: simm16 = 0x5801 = 22529
    S_SETREG_IMM32_B32 2748, 22529, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 1c: Size <= 12 with existing non-zero bits in imm32[12:19]
# imm32 = 0x23005 (bits 12:19 = 0x23), should become 0x63005 after OR with VGPR MSBs (0x41)
# Result = 0x23005 | (0x41 << 12) = 0x63005 = 405509
name:            setreg_size_lt_12_nonzero_upper
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_lt_12_nonzero_upper
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 266245, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    ; imm32 = 0x23005 = 143365 (bits 12:19 = 0x23)
    S_SETREG_IMM32_B32 143365, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 2: Size > 12 (size=16), imm32[12:19] already matches VGPR MSBs (0x41)
# imm32 = 0x41ABC = 268988 (bits 12:19 = 0x41), no modification needed
name:            setreg_size_gt_12_match
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_gt_12_match
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 268988, 30721, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=16, offset=0, hwreg=MODE: simm16 = 0x7801 = 30721
    ; imm32 = 0x41ABC = 268988 (bits 12:19 = 0x41 = VGPR MSBs)
    S_SETREG_IMM32_B32 268988, 30721, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 3: Size > 12 (size=16), imm32[12:19] doesn't match VGPR MSBs
# imm32 = 0x23ABC = 146108 (bits 12:19 = 0x23 != 0x41), must insert s_set_vgpr_msb after
name:            setreg_size_gt_12_mismatch
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_gt_12_mismatch
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 146108, 30721, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=16, offset=0, hwreg=MODE: simm16 = 0x7801 = 30721
    ; imm32 = 0x23ABC = 146108 (bits 12:19 = 0x23 != 0x41)
    S_SETREG_IMM32_B32 146108, 30721, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 4: Non-MODE hwreg should not be modified
# This uses ID_STATUS=2 instead of ID_MODE=1
name:            setreg_non_mode_hwreg
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_non_mode_hwreg
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 5, 6146, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=STATUS(2): simm16 = 2 | (0 << 6) | (3 << 11) = 0x1802 = 6146
    S_SETREG_IMM32_B32 5, 6146, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 5: Size <= 12 but VGPR MSBs already present (no change needed)
# imm32 = 0x41005 = 266245 (bits 12:19 = 0x41), OR with 0x41 yields same value
name:            setreg_size_lt_12_already_correct
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_lt_12_already_correct
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 266245, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    ; imm32 = 0x41005 = 266245 (bits 12:19 = 0x41 = VGPR MSBs)
    S_SETREG_IMM32_B32 266245, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 6: Different VGPR MSB value (using different high VGPRs)
# vgpr512/513 uses MSB=2 for both dst and src0, so mode value = 0x82
# New imm = 0x5 | (0x82 << 12) = 0x82005 = 532485
name:            setreg_different_vgpr_msb
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_different_vgpr_msb
    ; CHECK: S_SET_VGPR_MSB 130, implicit-def $mode
    ; CHECK-NEXT: $vgpr512 = V_MOV_B32_e32 $vgpr513, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 532485, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr512 = V_MOV_B32_e32 $vgpr513, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    ; VGPR MSBs for vgpr512/513: mode = 0x82 = 130
    ; New imm = 0x5 | (0x82 << 12) = 0x82005 = 532485
    S_SETREG_IMM32_B32 5, 6145, implicit-def $mode, implicit $mode
    S_ENDPGM 0
...

---
# Case 7: Piggybacking successfully updates s_setreg_imm32_b32 (Size <= 12)
# First VGPR: V_MOV sets mode for dst_msb=1, src0_msb=1
# Second VGPR: V_ADD_U32 with same dst/src0 (MSB=1) but src1 has MSB=2 (new bits)
# The second instruction's mode is a SUPERSET of the first - it includes all bits
# from the first plus additional src1 bits. Piggybacking updates the setreg's
# imm32[12:19] to the combined mode, no extra s_set_vgpr_msb needed.
name:            setreg_size_le_12_piggyback_superset
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_le_12_piggyback_superset
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 299013, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: $vgpr256 = V_ADD_U32_e32 $vgpr257, $vgpr512, implicit $exec
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    S_SETREG_IMM32_B32 5, 6145, implicit-def $mode, implicit $mode
    ; Second instruction uses same dst/src0 (MSB=1) but adds src1 (MSB=2)
    $vgpr256 = V_ADD_U32_e32 $vgpr257, $vgpr512, implicit $exec
    S_ENDPGM 0
...

---
# Case 8: s_setreg_imm32_b32 (Size <= 12) followed by VGPR with different mode bits
# Mode encoding: mode = (dst_msb << 6) | src0_msb
# First VGPR: vgpr256=V_MOV vgpr0 → mode = (1 << 6) | 0 = 64
# Second VGPR: vgpr256=V_MOV vgpr256 → mode = (1 << 6) | 1 = 65
# After setreg: MostRecentModeSet = &setreg with bits 12:19 = 64
# Second VGPR: Delta = 65 ^ 64 = 1, not subset of CurrentMask(64), new s_set_vgpr_msb
# New imm = NewMode | (OldMode << 8) = 65 | (64 << 8) = 65 | 16384 = 16449
name:            setreg_size_le_12_then_different_vgpr
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $vgpr0

    ; CHECK-LABEL: name: setreg_size_le_12_then_different_vgpr
    ; CHECK: liveins: $vgpr0
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: S_SET_VGPR_MSB 64, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr0, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 262149, 6145, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_SET_VGPR_MSB 16449, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr256, implicit $exec
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr0, implicit $exec
    ; size=4, offset=0, hwreg=MODE: simm16 = 0x1801 = 6145
    S_SETREG_IMM32_B32 5, 6145, implicit-def $mode, implicit $mode
    $vgpr256 = V_MOV_B32_e32 $vgpr256, implicit $exec
    S_ENDPGM 0
...

---
# Case 9: After s_setreg_imm32_b32 (Size > 12, matching), new s_set_vgpr_msb needed
# First VGPR sets mode = 0x41 (65). Setreg has size=16 with imm32[12:19]=0x41 (matches).
# handleSetregMode sets MostRecentModeSet = nullptr (can't piggyback on Size > 12).
# Second VGPR needs mode = 0x82 (130), which is independent of 0x41.
# Since MostRecentModeSet = nullptr, a new s_set_vgpr_msb is inserted.
# New s_set_vgpr_msb imm = NewMode | (OldMode << 8) = 130 | (65 << 8) = 130 | 16640 = 16770
name:            setreg_size_gt_12_match_then_different_vgpr
tracksRegLiveness: true
body:             |
  bb.0:
    ; CHECK-LABEL: name: setreg_size_gt_12_match_then_different_vgpr
    ; CHECK: S_SET_VGPR_MSB 65, implicit-def $mode
    ; CHECK-NEXT: $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; CHECK-NEXT: S_SETREG_IMM32_B32 268988, 30721, implicit-def $mode, implicit $mode
    ; CHECK-NEXT: S_SET_VGPR_MSB 16770, implicit-def $mode
    ; CHECK-NEXT: $vgpr512 = V_MOV_B32_e32 $vgpr513, implicit $exec
    ; CHECK-NEXT: S_ENDPGM 0
    $vgpr256 = V_MOV_B32_e32 $vgpr257, implicit $exec
    ; size=16, offset=0, hwreg=MODE: simm16 = 0x7801 = 30721
    ; imm32 = 0x41ABC = 268988 (bits 12:19 = 0x41 = VGPR MSBs, matches!)
    S_SETREG_IMM32_B32 268988, 30721, implicit-def $mode, implicit $mode
    $vgpr512 = V_MOV_B32_e32 $vgpr513, implicit $exec
    S_ENDPGM 0
...
