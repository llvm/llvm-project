; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -S -O1 -mtriple=amdgcn-- -amdgpu-simplify-libcall=1 < %s | FileCheck %s

; Test the realistic HIP sin/cos → sincos optimisation path.
; In a real HIP compilation:
;  1. HIP math wrappers are static inline, producing _ZL-prefixed names
;     (e.g. _ZL3sind instead of _Z3sind).
;  2. CodeGenAction injects __ocml_sincos_f{32,64} declarations and adds
;     them to @llvm.compiler.used so the demand-linker pulls them in.
;  3. AMDGPUSimplifyLibCallsPass (at PeepholeEP) recognises the _ZL names
;     and merges sin/cos into __ocml_sincos_f{32,64}.
;  4. AMDGPUUnusedLibFuncCleanupPass (at OptimizerLastEP) removes unused
;     sincos entries from @llvm.compiler.used.
;
; This test mirrors that flow: functions use _ZL mangling,
; __ocml_sincos is kept alive by @llvm.compiler.used, and the pass
; runs as part of the -O1 pipeline (non-prelink).

; _ZL mangled sin/cos — as produced by HIP's static inline wrappers.
declare float @_ZL3sinf(float) #0
declare float @_ZL3cosf(float) #0
declare double @_ZL3sind(double) #0
declare double @_ZL3cosd(double) #0

; Only OCML-style sincos is available — no _Z6sincos* declarations.
declare float @__ocml_sincos_f32(float, ptr addrspace(5) writeonly) #1
declare double @__ocml_sincos_f64(double, ptr addrspace(5) writeonly) #1

; Keep sincos alive through the pipeline, as CodeGenAction does.
@llvm.compiler.used = appending global [2 x ptr] [
  ptr @__ocml_sincos_f32,
  ptr @__ocml_sincos_f64
], section "llvm.metadata"

define void @sincos_f32_ocml(float %x, ptr addrspace(1) nocapture writeonly %sin_out, ptr addrspace(1) nocapture writeonly %cos_out) {
; CHECK-LABEL: define void @sincos_f32_ocml
; CHECK-SAME: (float [[X:%.*]], ptr addrspace(1) writeonly captures(none) initializes((0, 4)) [[SIN_OUT:%.*]], ptr addrspace(1) writeonly captures(none) initializes((0, 4)) [[COS_OUT:%.*]]) local_unnamed_addr #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[__SINCOS_:%.*]] = alloca float, align 4, addrspace(5)
; CHECK-NEXT:    [[TMP0:%.*]] = call contract float @__ocml_sincos_f32(float [[X]], ptr addrspace(5) [[__SINCOS_]])
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr addrspace(5) [[__SINCOS_]], align 4
; CHECK-NEXT:    store float [[TMP0]], ptr addrspace(1) [[SIN_OUT]], align 4
; CHECK-NEXT:    store float [[TMP1]], ptr addrspace(1) [[COS_OUT]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %call_sin = tail call contract float @_ZL3sinf(float %x)
  store float %call_sin, ptr addrspace(1) %sin_out, align 4
  %call_cos = tail call contract float @_ZL3cosf(float %x)
  store float %call_cos, ptr addrspace(1) %cos_out, align 4
  ret void
}

define void @sincos_f64_ocml(double %x, ptr addrspace(1) nocapture writeonly %sin_out, ptr addrspace(1) nocapture writeonly %cos_out) {
; CHECK-LABEL: define void @sincos_f64_ocml
; CHECK-SAME: (double [[X:%.*]], ptr addrspace(1) writeonly captures(none) initializes((0, 8)) [[SIN_OUT:%.*]], ptr addrspace(1) writeonly captures(none) initializes((0, 8)) [[COS_OUT:%.*]]) local_unnamed_addr #[[ATTR2]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[__SINCOS_:%.*]] = alloca double, align 8, addrspace(5)
; CHECK-NEXT:    [[TMP0:%.*]] = call contract double @__ocml_sincos_f64(double [[X]], ptr addrspace(5) [[__SINCOS_]])
; CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr addrspace(5) [[__SINCOS_]], align 8
; CHECK-NEXT:    store double [[TMP0]], ptr addrspace(1) [[SIN_OUT]], align 8
; CHECK-NEXT:    store double [[TMP1]], ptr addrspace(1) [[COS_OUT]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %call_sin = tail call contract double @_ZL3sind(double %x)
  store double %call_sin, ptr addrspace(1) %sin_out, align 8
  %call_cos = tail call contract double @_ZL3cosd(double %x)
  store double %call_cos, ptr addrspace(1) %cos_out, align 8
  ret void
}

; Verify that sin/cos with different arguments are NOT merged,
; even when __ocml_sincos is available.
define void @sincos_f32_ocml_no_merge_different_args(float %x, float %y, ptr addrspace(1) nocapture writeonly %sin_out, ptr addrspace(1) nocapture writeonly %cos_out) {
; CHECK-LABEL: define void @sincos_f32_ocml_no_merge_different_args
; CHECK-SAME: (float [[X:%.*]], float [[Y:%.*]], ptr addrspace(1) writeonly captures(none) initializes((0, 4)) [[SIN_OUT:%.*]], ptr addrspace(1) writeonly captures(none) initializes((0, 4)) [[COS_OUT:%.*]]) local_unnamed_addr #[[ATTR3:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL_SIN:%.*]] = tail call contract float @_ZL3sinf(float [[X]])
; CHECK-NEXT:    store float [[CALL_SIN]], ptr addrspace(1) [[SIN_OUT]], align 4
; CHECK-NEXT:    [[CALL_COS:%.*]] = tail call contract float @_ZL3cosf(float [[Y]])
; CHECK-NEXT:    store float [[CALL_COS]], ptr addrspace(1) [[COS_OUT]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %call_sin = tail call contract float @_ZL3sinf(float %x)
  store float %call_sin, ptr addrspace(1) %sin_out, align 4
  %call_cos = tail call contract float @_ZL3cosf(float %y)
  store float %call_cos, ptr addrspace(1) %cos_out, align 4
  ret void
}

attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #1 = { argmemonly nounwind willreturn }
