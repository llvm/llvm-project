; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -mtriple=amdgcn--amdpal -mcpu=gfx1100 | FileCheck --check-prefixes=PAL,CI --enable-var-scope %s
; RUN: llc < %s -mtriple=amdgcn--amdpal -mcpu=gfx1200 | FileCheck --check-prefixes=PAL,VI --enable-var-scope %s

define amdgpu_kernel void @simple(ptr addrspace(1) %out) {
; CI-LABEL: simple:
; CI:       ; %bb.0: ; %entry
; CI-NEXT:    s_load_b64 s[0:1], s[4:5], 0x0
; CI-NEXT:    v_mov_b32_e32 v0, 0
; CI-NEXT:    s_waitcnt lgkmcnt(0)
; CI-NEXT:    global_store_b32 v0, v0, s[0:1]
; CI-NEXT:    s_endpgm
;
; VI-LABEL: simple:
; VI:       ; %bb.0: ; %entry
; VI-NEXT:    s_load_b64 s[0:1], s[4:5], 0x0
; VI-NEXT:    v_mov_b32_e32 v0, 0
; VI-NEXT:    s_wait_kmcnt 0x0
; VI-NEXT:    global_store_b32 v0, v0, s[0:1]
; VI-NEXT:    s_endpgm
entry:
  store i32 0, ptr addrspace(1) %out
  ret void
}

; Check code sequence for amdpal use of scratch for alloca. This is the case
; where the high half of the address comes from s_getpc.

define amdgpu_kernel void @scratch(<2 x i32> %in, i32 %idx, ptr addrspace(5) %out) {
; CI-LABEL: scratch:
; CI:       ; %bb.0: ; %entry
; CI-NEXT:    s_load_b128 s[0:3], s[4:5], 0x0
; CI-NEXT:    s_waitcnt lgkmcnt(0)
; CI-NEXT:    s_cmp_eq_u32 s2, 1
; CI-NEXT:    s_cselect_b32 s0, s1, s0
; CI-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; CI-NEXT:    v_mov_b32_e32 v0, s0
; CI-NEXT:    scratch_store_b32 off, v0, s3
; CI-NEXT:    s_endpgm
;
; VI-LABEL: scratch:
; VI:       ; %bb.0: ; %entry
; VI-NEXT:    s_load_b128 s[0:3], s[4:5], 0x0
; VI-NEXT:    s_wait_kmcnt 0x0
; VI-NEXT:    s_cmp_eq_u32 s2, 1
; VI-NEXT:    s_cselect_b32 s0, s1, s0
; VI-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; VI-NEXT:    v_mov_b32_e32 v0, s0
; VI-NEXT:    scratch_store_b32 off, v0, s3
; VI-NEXT:    s_endpgm
entry:
  %v = alloca [2 x i32], addrspace(5)
  store <2 x i32> %in, ptr addrspace(5) %v
  %e = getelementptr [2 x i32], ptr addrspace(5) %v, i32 0, i32 %idx
  %x = load i32, ptr addrspace(5) %e
  store i32 %x, ptr addrspace(5) %out
  ret void
}

; Check code sequence for amdpal use of scratch for alloca. This is the case
; where the amdgpu-git-ptr-high function attribute gives the high half of the
; address to use.
; Looks like you can't do arithmetic on a filecheck variable, so we can't test
; that the s_movk_i32 is into a reg that is one more than the following
; s_mov_b32.

define amdgpu_kernel void @scratch2(<2 x i32> %in, i32 %idx, ptr addrspace(5) %out) #0 {
; CI-LABEL: scratch2:
; CI:       ; %bb.0: ; %entry
; CI-NEXT:    s_load_b128 s[0:3], s[4:5], 0x0
; CI-NEXT:    s_waitcnt lgkmcnt(0)
; CI-NEXT:    s_cmp_eq_u32 s2, 1
; CI-NEXT:    s_cselect_b32 s0, s1, s0
; CI-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; CI-NEXT:    v_mov_b32_e32 v0, s0
; CI-NEXT:    scratch_store_b32 off, v0, s3
; CI-NEXT:    s_endpgm
;
; VI-LABEL: scratch2:
; VI:       ; %bb.0: ; %entry
; VI-NEXT:    s_load_b128 s[0:3], s[4:5], 0x0
; VI-NEXT:    s_wait_kmcnt 0x0
; VI-NEXT:    s_cmp_eq_u32 s2, 1
; VI-NEXT:    s_cselect_b32 s0, s1, s0
; VI-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; VI-NEXT:    v_mov_b32_e32 v0, s0
; VI-NEXT:    scratch_store_b32 off, v0, s3
; VI-NEXT:    s_endpgm
entry:
  %v = alloca [2 x i32], addrspace(5)
  store <2 x i32> %in, ptr addrspace(5) %v
  %e = getelementptr [2 x i32], ptr addrspace(5) %v, i32 0, i32 %idx
  %x = load i32, ptr addrspace(5) %e
  store i32 %x, ptr addrspace(5) %out
  ret void
}

; Check code sequence for amdpal use of scratch for alloca in a compute shader.
; The scratch descriptor is loaded from offset 0x10 of the GIT, rather than offset
; 0 in a graphics shader.
; Prior to GCN3 s_load_dword offsets are dwords, so the offset will be 0x4.

define amdgpu_cs void @scratch2_cs(i32 inreg, i32 inreg, i32 inreg, <3 x i32> inreg, i32 inreg, <3 x i32> %coord, <2 x i32> %in, i32 %extra, i32 %idx) #0 {
; CI-LABEL: scratch2_cs:
; CI:       ; %bb.0: ; %entry
; CI-NEXT:    v_lshlrev_b32_e32 v0, 2, v6
; CI-NEXT:    v_mov_b32_e32 v2, v5
; CI-NEXT:    s_delay_alu instid0(VALU_DEP_2)
; CI-NEXT:    v_add3_u32 v0, 0, v0, 4
; CI-NEXT:    scratch_store_b96 off, v[2:4], off
; CI-NEXT:    scratch_load_b32 v0, v0, off
; CI-NEXT:    s_waitcnt vmcnt(0)
; CI-NEXT:    buffer_store_b32 v0, off, s[0:3], 0
; CI-NEXT:    s_endpgm
;
; VI-LABEL: scratch2_cs:
; VI:       ; %bb.0: ; %entry
; VI-NEXT:    v_mov_b32_e32 v2, v5
; VI-NEXT:    v_lshlrev_b32_e32 v0, 2, v6
; VI-NEXT:    scratch_store_b96 off, v[2:4], off
; VI-NEXT:    scratch_load_b32 v0, v0, off offset:4
; VI-NEXT:    s_wait_loadcnt 0x0
; VI-NEXT:    buffer_store_b32 v0, off, s[0:3], null
; VI-NEXT:    s_endpgm
entry:
  %v = alloca [3 x i32], addrspace(5)
  %v1 = getelementptr [3 x i32], ptr addrspace(5) %v, i32 0, i32 1
  store i32 %extra, ptr addrspace(5) %v
  store <2 x i32> %in, ptr addrspace(5) %v1
  %e = getelementptr [2 x i32], ptr addrspace(5) %v1, i32 0, i32 %idx
  %x = load i32, ptr addrspace(5) %e
  %xf = bitcast i32 %x to float
  call void @llvm.amdgcn.raw.ptr.buffer.store.f32(float %xf, ptr addrspace(8) poison, i32 0, i32 0, i32 0)
  ret void
}

attributes #0 = { nounwind "amdgpu-git-ptr-high"="0x1234" }

declare void @llvm.amdgcn.raw.ptr.buffer.store.f32(float, ptr addrspace(8), i32, i32, i32 immarg)
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; PAL: {{.*}}
