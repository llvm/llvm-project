; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -passes=amdgpu-promote-alloca < %s | FileCheck %s
define amdgpu_ps void @scalar_alloca_ptr_with_vector_gep_of_gep(i32 %j) #0 {
; CHECK-LABEL: define amdgpu_ps void @scalar_alloca_ptr_with_vector_gep_of_gep(
; CHECK-SAME: i32 [[J:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SORTEDFRAGMENTS:%.*]] = freeze <20 x i32> poison
; CHECK-NEXT:    [[TMP0:%.*]] = mul i32 [[J]], 2
; CHECK-NEXT:    [[TMP1:%.*]] = mul i32 [[J]], 2
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 1, [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = extractelement <20 x i32> [[SORTEDFRAGMENTS]], i32 [[TMP2]]
; CHECK-NEXT:    ret void
;
entry:
  %SortedFragments = alloca [10 x <2 x i32>], align 8, addrspace(5)
  %row = getelementptr [10 x <2 x i32>], ptr addrspace(5) %SortedFragments, i32 0, i32 %j
  %elt1 = getelementptr i8, ptr addrspace(5) %row, i32 4
  %val = load i32, ptr addrspace(5) %elt1, align 4
  ret void
}

attributes #0 = { "amdgpu-promote-alloca-to-vector-max-regs"="32" }

define amdgpu_cs void @scalar_alloca_ptr_with_vector_gep_of_scratch(i32 inreg %0, i32 inreg %1, i32 inreg %2, <3 x i32> inreg %coord, i32 inreg %4, <3 x i32> %v_in, <2 x i32> %in, i32 %extra, i32 %idx, ptr addrspace(8) %buffer) #0 {
; CHECK-LABEL: define amdgpu_cs void @scalar_alloca_ptr_with_vector_gep_of_scratch(
; CHECK-SAME: i32 inreg [[TMP0:%.*]], i32 inreg [[TMP1:%.*]], i32 inreg [[TMP2:%.*]], <3 x i32> inreg [[COORD:%.*]], i32 inreg [[TMP3:%.*]], <3 x i32> [[V_IN:%.*]], <2 x i32> [[IN:%.*]], i32 [[EXTRA:%.*]], i32 [[IDX:%.*]], ptr addrspace(8) [[BUFFER:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[V:%.*]] = freeze <3 x i32> poison
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <3 x i32> [[V]], i32 [[EXTRA]], i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x i32> [[IN]], i64 0
; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <3 x i32> [[TMP4]], i32 [[TMP5]], i32 1
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x i32> [[IN]], i64 1
; CHECK-NEXT:    [[TMP8:%.*]] = insertelement <3 x i32> [[TMP6]], i32 [[TMP7]], i32 2
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 1, [[IDX]]
; CHECK-NEXT:    [[TMP10:%.*]] = extractelement <3 x i32> [[TMP8]], i32 [[TMP9]]
; CHECK-NEXT:    [[XF:%.*]] = bitcast i32 [[TMP10]] to float
; CHECK-NEXT:    store float [[XF]], ptr addrspace(8) [[BUFFER]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %v = alloca [3 x i32], addrspace(5)
  %v1 = getelementptr [3 x i32], ptr addrspace(5) %v, i32 0, i32 1
  store i32 %extra, ptr addrspace(5) %v
  store <2 x i32> %in, ptr addrspace(5) %v1
  %e = getelementptr [2 x i32], ptr addrspace(5) %v1, i32 0, i32 %idx
  %x = load i32, ptr addrspace(5) %e
  %xf = bitcast i32 %x to float
  store float %xf, ptr addrspace(8) %buffer, align 4
  ret void
}
