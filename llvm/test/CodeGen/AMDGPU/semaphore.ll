; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -global-isel=0 -mtriple=amdgcn -mcpu=gfx1300 < %s | FileCheck -check-prefix=GFX13 %s

; TODO-GFX13: Add GlobalISel support.

@sem = internal addrspace(3) global target("amdgcn.semaphore", 0) poison
@sem2 = internal addrspace(3) global target("amdgcn.semaphore", 0) poison
@sem3 = internal addrspace(3) global target("amdgcn.semaphore", 3) poison

define amdgpu_kernel void @test_sema(i32 %arg) {
; GFX13-LABEL: test_sema:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    s_load_b32 s0, s[4:5], 0x24
; GFX13-NEXT:    s_setreg_imm32_b32 hwreg(HW_REG_WAVE_SEMA2_STATE), 0
; GFX13-NEXT:    s_setreg_imm32_b32 hwreg(HW_REG_WAVE_SEMA1_STATE), 0xbc614e
; GFX13-NEXT:    s_wait_kmcnt 0x0
; GFX13-NEXT:    s_setreg_b32 hwreg(HW_REG_WAVE_SEMA1_STATE), s0
; GFX13-NEXT:    s_sema_set_limit 0x4000
; GFX13-NEXT:    s_sema_set_limit 0x2000
; GFX13-NEXT:    s_sema_set_limit 0x2003
; GFX13-NEXT:    s_sema_signal 2
; GFX13-NEXT:    s_sema_signal 1
; GFX13-NEXT:    s_sema_signal 49
; GFX13-NEXT:    s_sema_wait 2
; GFX13-NEXT:    s_sema_wait 1
; GFX13-NEXT:    s_sema_wait 1
; GFX13-NEXT:    s_endpgm
  call void @llvm.amdgcn.s.sema.set.state(ptr addrspace(3) @sem, i32 0)
  call void @llvm.amdgcn.s.sema.set.state(ptr addrspace(3) @sem2, i32 12345678)
  call void @llvm.amdgcn.s.sema.set.state(ptr addrspace(3) @sem3, i32 %arg)
  call void @llvm.amdgcn.s.sema.set.limit(ptr addrspace(3) @sem, i32 0)
  call void @llvm.amdgcn.s.sema.set.limit(ptr addrspace(3) @sem2, i32 0)
  call void @llvm.amdgcn.s.sema.set.limit(ptr addrspace(3) @sem3, i32 3)
  call void @llvm.amdgcn.s.sema.signal(ptr addrspace(3) @sem)
  call void @llvm.amdgcn.s.sema.signal(ptr addrspace(3) @sem2)
  call void @llvm.amdgcn.s.sema.signal(ptr addrspace(3) @sem3)
  call void @llvm.amdgcn.s.sema.wait(ptr addrspace(3) @sem)
  call void @llvm.amdgcn.s.sema.wait(ptr addrspace(3) @sem2)
  call void @llvm.amdgcn.s.sema.wait(ptr addrspace(3) @sem3)
  ret void
}

; Regression test for generating illegal MIR.
define amdgpu_ps <2 x half> @test_sema_tensor() {
; GFX13-LABEL: test_sema_tensor:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v0, 0
; GFX13-NEXT:    s_sema_wait 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_dual_mov_b32 v1, v0 :: v_dual_mov_b32 v2, v0
; GFX13-NEXT:    v_mov_b32_e32 v3, v0
; GFX13-NEXT:    v_cvt_to_tensor_f16_f32 v0, v1, v[0:3], 0 aux_data:3
; GFX13-NEXT:    ; return to shader part epilog
  tail call void @llvm.amdgcn.s.sema.wait(ptr addrspace(3) null)
  %i = tail call { <2 x half>, <2 x half> } @llvm.amdgcn.cvt.to.tensor.f16.f32.scatter2.v4f32(<4 x float> zeroinitializer, i8 0, i32 3, i1 false)
  %i1 = extractvalue { <2 x half>, <2 x half> } %i, 0
  ret <2 x half> %i1
}
