; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -march=amdgcn -mcpu=gfx1030 -verify-machineinstrs < %s | FileCheck -enable-var-scope -check-prefix=GFX10 %s

define float @v_bfi_single_nesting_level(float %x, float %y, float %z) {
; GFX10-LABEL: v_bfi_single_nesting_level:
; GFX10:       ; %bb.0: ; %.entry
; GFX10-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX10-NEXT:    s_waitcnt_vscnt null, 0x0
; GFX10-NEXT:    v_mul_f32_e32 v0, 0x447fc000, v0
; GFX10-NEXT:    v_cvt_u32_f32_e32 v1, v1
; GFX10-NEXT:    v_mul_f32_e32 v2, 0x447fc000, v2
; GFX10-NEXT:    v_cvt_u32_f32_e32 v0, v0
; GFX10-NEXT:    v_lshlrev_b32_e32 v1, 10, v1
; GFX10-NEXT:    v_cvt_u32_f32_e32 v2, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v0, 20, v0
; GFX10-NEXT:    v_and_b32_e32 v1, 0xffc00, v1
; GFX10-NEXT:    v_and_b32_e32 v2, 0xc00003ff, v2
; GFX10-NEXT:    v_and_b32_e32 v0, 0x3ff00000, v0
; GFX10-NEXT:    v_or3_b32 v0, v1, v2, v0
; GFX10-NEXT:    s_setpc_b64 s[30:31]
.entry:
  %mul.base = fmul reassoc nnan nsz arcp contract afn float %z, 1.023000e+03
  %mul.base.i32 = fptoui float %mul.base to i32
  %y.i32 = fptoui float %y to i32
  %shl.inner.insert = shl i32 %y.i32, 10
  %bfi1.and = and i32 %shl.inner.insert, 1047552
  %bfi1.andnot = and i32 %mul.base.i32, -1073740801
  %bfi1.or = or i32 %bfi1.and, %bfi1.andnot
  %mul.outer.insert = fmul reassoc nnan nsz arcp contract afn float %x, 1.023000e+03
  %mul.outer.insert.i32 = fptoui float %mul.outer.insert to i32
  %shl.outer.insert = shl i32 %mul.outer.insert.i32, 20
  %and.outer = and i32 %shl.outer.insert, 1072693248
  %or.outer = or i32 %bfi1.or, %and.outer
  %result = bitcast i32 %or.outer to float
  ret float %result
}

define float @v_bfi_single_nesting_level_swapped_operands(float %x, float %y, float %z) {
; GFX10-LABEL: v_bfi_single_nesting_level_swapped_operands:
; GFX10:       ; %bb.0: ; %.entry
; GFX10-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX10-NEXT:    s_waitcnt_vscnt null, 0x0
; GFX10-NEXT:    v_mul_f32_e32 v2, 0x447fc000, v2
; GFX10-NEXT:    v_cvt_u32_f32_e32 v1, v1
; GFX10-NEXT:    v_mul_f32_e32 v0, 0x447fc000, v0
; GFX10-NEXT:    v_cvt_u32_f32_e32 v2, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v1, 10, v1
; GFX10-NEXT:    v_cvt_u32_f32_e32 v0, v0
; GFX10-NEXT:    v_and_b32_e32 v2, 0xc00003ff, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v0, 20, v0
; GFX10-NEXT:    v_and_or_b32 v1, 0xffc00, v1, v2
; GFX10-NEXT:    v_and_or_b32 v0, 0x3ff00000, v0, v1
; GFX10-NEXT:    s_setpc_b64 s[30:31]
.entry:
  %mul.base = fmul reassoc nnan nsz arcp contract afn float %z, 1.023000e+03
  %mul.base.i32 = fptoui float %mul.base to i32
  %y.i32 = fptoui float %y to i32
  %shl.inner.insert = shl i32 %y.i32, 10
  %bfi1.and = and i32 1047552, %shl.inner.insert
  %bfi1.andnot = and i32 -1073740801, %mul.base.i32
  %bfi1.or = or i32 %bfi1.and, %bfi1.andnot
  %mul.outer.insert = fmul reassoc nnan nsz arcp contract afn float %x, 1.023000e+03
  %mul.outer.insert.i32 = fptoui float %mul.outer.insert to i32
  %shl.outer.insert = shl i32 %mul.outer.insert.i32, 20
  %and.outer = and i32 %shl.outer.insert, 1072693248
  %or.outer = or i32 %and.outer, %bfi1.or
  %result = bitcast i32 %or.outer to float
  ret float %result
}

define float @v_bfi_single_nesting_level_unbalanced_subtree(float %x, float %y, float %z) {
; GFX10-LABEL: v_bfi_single_nesting_level_unbalanced_subtree:
; GFX10:       ; %bb.0: ; %.entry
; GFX10-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX10-NEXT:    s_waitcnt_vscnt null, 0x0
; GFX10-NEXT:    v_mul_f32_e32 v2, 0x447fc000, v2
; GFX10-NEXT:    v_cvt_u32_f32_e32 v1, v1
; GFX10-NEXT:    v_mul_f32_e32 v0, 0x447fc000, v0
; GFX10-NEXT:    v_cvt_u32_f32_e32 v2, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v1, 10, v1
; GFX10-NEXT:    v_cvt_u32_f32_e32 v0, v0
; GFX10-NEXT:    v_and_b32_e32 v3, 0x3e0, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v0, 20, v0
; GFX10-NEXT:    v_and_or_b32 v1, 0xffc00, v1, v3
; GFX10-NEXT:    v_and_or_b32 v1, 0xc000001f, v2, v1
; GFX10-NEXT:    v_and_or_b32 v0, 0x3ff00000, v0, v1
; GFX10-NEXT:    s_setpc_b64 s[30:31]
.entry:
  %mul.base = fmul reassoc nnan nsz arcp contract afn float %z, 1.023000e+03
  %mul.base.i32 = fptoui float %mul.base to i32
  %y.i32 = fptoui float %y to i32
  %shl.inner.2.insert = shl i32 %y.i32, 10
  %bfi.inner.2.and.1 = and i32 %shl.inner.2.insert, 1047552
  %bfi.inner.2.and.2 = and i32 %mul.base.i32, 992
  %bfi.inner.2 = or i32 %bfi.inner.2.and.1, %bfi.inner.2.and.2
  %mul.inner.1.insert = fmul reassoc nnan nsz arcp contract afn float %x, 1.023000e+03
  %mul.inner.1.insert.1.i32 = fptoui float %mul.inner.1.insert to i32
  %shl.inner.1.insert.1 = shl i32 %mul.inner.1.insert.1.i32, 20
  %bfi.inner.1.and.1 = and i32 %shl.inner.1.insert.1, 1072693248
  %bfi.inner.1.and.2 = and i32 %mul.base.i32, -1073741793
  %bfi.inner.1 = or i32 %bfi.inner.1.and.2, %bfi.inner.2
  %bfi.outer = or i32 %bfi.inner.1.and.1, %bfi.inner.1
  %result = bitcast i32 %bfi.outer to float
  ret float %result
}

define float @v_bfi_single_nesting_level_inner_use(float %x, float %y, float %z) {
; GFX10-LABEL: v_bfi_single_nesting_level_inner_use:
; GFX10:       ; %bb.0: ; %.entry
; GFX10-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX10-NEXT:    s_waitcnt_vscnt null, 0x0
; GFX10-NEXT:    v_mul_f32_e32 v0, 0x447fc000, v2
; GFX10-NEXT:    v_cvt_u32_f32_e32 v1, v1
; GFX10-NEXT:    v_cvt_u32_f32_e32 v0, v0
; GFX10-NEXT:    v_lshlrev_b32_e32 v1, 10, v1
; GFX10-NEXT:    v_and_b32_e32 v0, 0x400003ff, v0
; GFX10-NEXT:    v_and_or_b32 v0, 0xffc00, v1, v0
; GFX10-NEXT:    v_lshlrev_b32_e32 v0, 1, v0
; GFX10-NEXT:    s_setpc_b64 s[30:31]
.entry:
  %mul.base = fmul reassoc nnan nsz arcp contract afn float %z, 1.023000e+03
  %mul.base.i32 = fptoui float %mul.base to i32
  %y.i32 = fptoui float %y to i32
  %shl.inner.insert = shl i32 %y.i32, 10
  %bfi1.and = and i32 %shl.inner.insert, 1047552
  %bfi1.andnot = and i32 %mul.base.i32, -1073740801
  %bfi1.or = or i32 %bfi1.and, %bfi1.andnot
  %mul.outer.insert = fmul reassoc nnan nsz arcp contract afn float %x, 1.023000e+03
  %mul.outer.insert.i32 = fptoui float %mul.outer.insert to i32
  %shl.outer.insert = shl i32 %mul.outer.insert.i32, 20
  %and.outer = and i32 %shl.outer.insert, 1072693248
  %or.outer = or i32 %bfi1.or, %and.outer
  %bfi1.or.seconduse = mul i32 %bfi1.or, 2
  %result = bitcast i32 %bfi1.or.seconduse to float
  ret float %result
}

define float @v_bfi_no_nesting(float %x, float %y, float %z) {
; GFX10-LABEL: v_bfi_no_nesting:
; GFX10:       ; %bb.0: ; %.entry
; GFX10-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX10-NEXT:    s_waitcnt_vscnt null, 0x0
; GFX10-NEXT:    v_mul_f32_e32 v0, 0x447fc000, v0
; GFX10-NEXT:    v_cvt_u32_f32_e32 v1, v1
; GFX10-NEXT:    v_mul_f32_e32 v2, 0x447fc000, v2
; GFX10-NEXT:    v_cvt_u32_f32_e32 v0, v0
; GFX10-NEXT:    v_lshlrev_b32_e32 v1, 10, v1
; GFX10-NEXT:    v_cvt_u32_f32_e32 v2, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v0, 20, v0
; GFX10-NEXT:    v_and_b32_e32 v1, 0xffc00, v1
; GFX10-NEXT:    v_and_b32_e32 v2, 0xc0000400, v2
; GFX10-NEXT:    v_and_b32_e32 v0, 0x3ff00000, v0
; GFX10-NEXT:    v_or3_b32 v0, v1, v2, v0
; GFX10-NEXT:    s_setpc_b64 s[30:31]
.entry:
  %mul.base = fmul reassoc nnan nsz arcp contract afn float %z, 1.023000e+03
  %mul.base.i32 = fptoui float %mul.base to i32
  %y.i32 = fptoui float %y to i32
  %shl.inner.insert = shl i32 %y.i32, 10
  %inner.and = and i32 %shl.inner.insert, 1047552
  %inner.and2 = and i32 %mul.base.i32, -1073740800
  %inner.or = or i32 %inner.and, %inner.and2
  %mul.outer.insert = fmul reassoc nnan nsz arcp contract afn float %x, 1.023000e+03
  %mul.outer.insert.i32 = fptoui float %mul.outer.insert to i32
  %shl.outer.insert = shl i32 %mul.outer.insert.i32, 20
  %and.outer = and i32 %shl.outer.insert, 1072693248
  %or.outer = or i32 %inner.or, %and.outer
  %result = bitcast i32 %or.outer to float
  ret float %result
}

define float @v_bfi_two_levels(float %x, float %y, float %z) {
; GFX10-LABEL: v_bfi_two_levels:
; GFX10:       ; %bb.0: ; %.entry
; GFX10-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX10-NEXT:    s_waitcnt_vscnt null, 0x0
; GFX10-NEXT:    v_mul_f32_e32 v0, 0x447fc000, v0
; GFX10-NEXT:    v_cvt_u32_f32_e32 v1, v1
; GFX10-NEXT:    v_cvt_u32_f32_e32 v2, v2
; GFX10-NEXT:    v_cvt_u32_f32_e32 v0, v0
; GFX10-NEXT:    v_lshlrev_b32_e32 v3, 5, v1
; GFX10-NEXT:    v_and_b32_e32 v2, 0xc000001f, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v1, 10, v1
; GFX10-NEXT:    v_lshlrev_b32_e32 v0, 20, v0
; GFX10-NEXT:    v_and_or_b32 v2, 0x3e0, v3, v2
; GFX10-NEXT:    v_and_b32_e32 v1, 0xffc00, v1
; GFX10-NEXT:    v_and_b32_e32 v0, 0x3ff00000, v0
; GFX10-NEXT:    v_or3_b32 v0, v2, v1, v0
; GFX10-NEXT:    s_setpc_b64 s[30:31]
.entry:
  %y.i32 = fptoui float %y to i32
  %shl.insert.inner = shl i32 %y.i32, 5
  %and.insert.inner = and i32 %shl.insert.inner, 992
  %z.i32 = fptoui float %z to i32
  %base.inner = and i32 %z.i32, -1073741793
  %or.inner = or i32 %and.insert.inner , %base.inner
  %shl.insert.mid = shl i32 %y.i32, 10
  %and.insert.mid = and i32 %shl.insert.mid, 1047552
  %or.mid = or i32 %or.inner, %and.insert.mid
  %fmul.insert.outer = fmul reassoc nnan nsz arcp contract afn float %x, 1.023000e+03
  %cast.insert.outer = fptoui float %fmul.insert.outer to i32
  %shl.insert.outer = shl i32 %cast.insert.outer, 20
  %and.insert.outer = and i32 %shl.insert.outer, 1072693248
  %or.outer = or i32 %or.mid, %and.insert.outer
  %result = bitcast i32 %or.outer to float
  ret float %result
}

define float @v_bfi_single_constant_as_partition(float %x, float %y, float %z) {
; GFX10-LABEL: v_bfi_single_constant_as_partition:
; GFX10:       ; %bb.0: ; %.entry
; GFX10-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX10-NEXT:    s_waitcnt_vscnt null, 0x0
; GFX10-NEXT:    v_mul_f32_e32 v0, 0x447fc000, v0
; GFX10-NEXT:    v_mul_f32_e32 v2, 0x447fc000, v2
; GFX10-NEXT:    v_cvt_u32_f32_e32 v1, v1
; GFX10-NEXT:    v_cvt_u32_f32_e32 v0, v0
; GFX10-NEXT:    v_cvt_u32_f32_e32 v2, v2
; GFX10-NEXT:    v_lshlrev_b32_e32 v1, 10, v1
; GFX10-NEXT:    v_lshlrev_b32_e32 v0, 20, v0
; GFX10-NEXT:    v_or3_b32 v0, v1, v2, v0
; GFX10-NEXT:    s_setpc_b64 s[30:31]
.entry:
  %mul.base = fmul reassoc nnan nsz arcp contract afn float %z, 1.023000e+03
  %mul.base.i32 = fptoui float %mul.base to i32
  %y.i32 = fptoui float %y to i32
  %shl.inner.insert = shl i32 %y.i32, 10
  %bfi1.or = or i32 %shl.inner.insert, %mul.base.i32
  %mul.outer.insert = fmul reassoc nnan nsz arcp contract afn float %x, 1.023000e+03
  %mul.outer.insert.i32 = fptoui float %mul.outer.insert to i32
  %shl.outer.insert = shl i32 %mul.outer.insert.i32, 20
  %and.outer = and i32 %shl.outer.insert, -1
  %or.outer = or i32 %bfi1.or, %and.outer
  %result = bitcast i32 %or.outer to float
  ret float %result
}
