; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=amdgcn -mcpu=gfx1101 -verify-machineinstrs < %s | FileCheck --check-prefix=GCN %s

; Test pattern: (and (not (srl X, C)), 1)
define i32 @bittest_5_i32(i32 inreg %a) {
; GCN-LABEL: bittest_5_i32:
; GCN:       ; %bb.0:
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_bitcmp0_b32 s0, 5
; GCN-NEXT:    s_cselect_b32 s0, -1, 0
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_cndmask_b32_e64 v0, 0, 1, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
  %shr = lshr i32 %a, 5
  %not = xor i32 %shr, -1
  %and = and i32 %not, 1
  ret i32 %and
}

define i32 @bittest_7_i32(i32 inreg %a) {
; GCN-LABEL: bittest_7_i32:
; GCN:       ; %bb.0: ; %entry
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_bitcmp0_b32 s0, 7
; GCN-NEXT:    s_cselect_b32 s0, -1, 0
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_cndmask_b32_e64 v0, 0, 1, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
entry:
  %shr = lshr i32 %a, 7
  %not = xor i32 %shr, -1
  %and = and i32 %not, 1
  ret i32 %and
}

define i32 @bittest_11_i32(i32 inreg %a) {
; GCN-LABEL: bittest_11_i32:
; GCN:       ; %bb.0: ; %entry
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_bitcmp0_b32 s0, 11
; GCN-NEXT:    s_cselect_b32 s0, -1, 0
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_cndmask_b32_e64 v0, 0, 1, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
entry:
  %shr = lshr i32 %a, 11
  %not = xor i32 %shr, -1
  %and = and i32 %not, 1
  ret i32 %and
}

define i32 @bittest_31_i32(i32 inreg %a) {
; GCN-LABEL: bittest_31_i32:
; GCN:       ; %bb.0: ; %entry
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_not_b32 s0, s0
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1) | instskip(NEXT) | instid1(SALU_CYCLE_1)
; GCN-NEXT:    s_lshr_b32 s0, s0, 31
; GCN-NEXT:    v_mov_b32_e32 v0, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
entry:
  %shr = lshr i32 %a, 31
  %not = xor i32 %shr, -1
  %and = and i32 %not, 1
  ret i32 %and
}

define i64 @bittest_7_i64(i64 inreg %a) {
; GCN-LABEL: bittest_7_i64:
; GCN:       ; %bb.0:
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_and_not1_b32 s0, 1, s1
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_dual_mov_b32 v1, 0 :: v_dual_mov_b32 v0, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
  %shr = lshr i64 %a, 32
  %not = xor i64 %shr, -1
  %and = and i64 %not, 1
  ret i64 %and
}

define i64 @bittest_10_i64(i64 inreg %a) {
; GCN-LABEL: bittest_10_i64:
; GCN:       ; %bb.0:
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_and_not1_b32 s0, 1, s1
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_dual_mov_b32 v1, 0 :: v_dual_mov_b32 v0, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
  %shr = lshr i64 %a, 32
  %not = xor i64 %shr, -1
  %and = and i64 %not, 1
  ret i64 %and
}

define i64 @bittest_11_i64(i64 inreg %a) {
; GCN-LABEL: bittest_11_i64:
; GCN:       ; %bb.0:
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_and_not1_b32 s0, 1, s1
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_dual_mov_b32 v1, 0 :: v_dual_mov_b32 v0, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
  %shr = lshr i64 %a, 32
  %not = xor i64 %shr, -1
  %and = and i64 %not, 1
  ret i64 %and
}

define i64 @bittest_31_i64(i64 inreg %a) {
; GCN-LABEL: bittest_31_i64:
; GCN:       ; %bb.0:
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_and_not1_b32 s0, 1, s1
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_dual_mov_b32 v1, 0 :: v_dual_mov_b32 v0, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
  %shr = lshr i64 %a, 32
  %not = xor i64 %shr, -1
  %and = and i64 %not, 1
  ret i64 %and
}

define i64 @bittest_32_i64(i64 inreg %a) {
; GCN-LABEL: bittest_32_i64:
; GCN:       ; %bb.0:
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_and_not1_b32 s0, 1, s1
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_dual_mov_b32 v1, 0 :: v_dual_mov_b32 v0, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
  %shr = lshr i64 %a, 32
  %not = xor i64 %shr, -1
  %and = and i64 %not, 1
  ret i64 %and
}

define i64 @bittest_63_i64(i64 inreg %a) {
; GCN-LABEL: bittest_63_i64:
; GCN:       ; %bb.0:
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_and_not1_b32 s0, 1, s1
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_dual_mov_b32 v1, 0 :: v_dual_mov_b32 v0, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
  %shr = lshr i64 %a, 32
  %not = xor i64 %shr, -1
  %and = and i64 %not, 1
  ret i64 %and
}

; Test pattern: (and (lshr (not X), C), 1)
define i32 @bittest_srl_not(i32 inreg %a) {
; GCN-LABEL: bittest_srl_not:
; GCN:       ; %bb.0: ; %entry
; GCN-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GCN-NEXT:    s_bitcmp0_b32 s0, 5
; GCN-NEXT:    s_cselect_b32 s0, -1, 0
; GCN-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; GCN-NEXT:    v_cndmask_b32_e64 v0, 0, 1, s0
; GCN-NEXT:    s_setpc_b64 s[30:31]
entry:
    %not = xor i32 %a, -1
    %shr = lshr i32 %not, 5
    %and = and i32 %shr, 1
    ret i32 %and
}
