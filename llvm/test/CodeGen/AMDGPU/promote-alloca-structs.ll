; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -passes=amdgpu-promote-alloca-to-vector -amdgpu-promote-alloca-to-vector-limit=512 %s | FileCheck %s

define i8 @test_v4i8(i32 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_v4i8(
; CHECK-SAME: i32 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[BITS]] to <4 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca <4 x i8>, align 4, addrspace(5)
  store i32 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_a4i8(i32 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_a4i8(
; CHECK-SAME: i32 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[BITS]] to <4 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca [4 x i8], align 4, addrspace(5)
  store i32 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_a2v4i8(i64 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_a2v4i8(
; CHECK-SAME: i64 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 [[BITS]] to <8 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <8 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca [2 x <4 x i8>], align 4, addrspace(5)
  store i64 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_a2v3i8(i64 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_a2v3i8(
; CHECK-SAME: i64 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 [[BITS]] to <8 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <8 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca [2 x <3 x i8>], align 4, addrspace(5)
  store i64 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_a2a4i8(i64 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_a2a4i8(
; CHECK-SAME: i64 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 [[BITS]] to <8 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <8 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca [2 x [4 x i8]], align 4, addrspace(5)
  store i64 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_a2a3i8(i48 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_a2a3i8(
; CHECK-SAME: i48 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <6 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i48 [[BITS]] to <6 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <6 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca [2 x [3 x i8]], align 4, addrspace(5)
  store i48 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s1v4i8(i32 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s1v4i8(
; CHECK-SAME: i32 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[BITS]] to <4 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {<4 x i8>}, align 4, addrspace(5)
  store i32 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s1a4i8(i32 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s1a4i8(
; CHECK-SAME: i32 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[BITS]] to <4 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {[4 x i8]}, align 4, addrspace(5)
  store i32 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s4i8(i32 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s4i8(
; CHECK-SAME: i32 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[BITS]] to <4 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {i8, i8, i8, i8}, align 4, addrspace(5)
  store i32 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s2v4i8(i64 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s2v4i8(
; CHECK-SAME: i64 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 [[BITS]] to <8 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <8 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {<4 x i8>, <4 x i8>}, align 4, addrspace(5)
  store i64 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s2v2i8v4i8(i64 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s2v2i8v4i8(
; CHECK-SAME: i64 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 [[BITS]] to <8 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <8 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {<2 x i8>, <4 x i8>}, align 4, addrspace(5)
  store i64 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s2v2i8v3i8(i64 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s2v2i8v3i8(
; CHECK-SAME: i64 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 [[BITS]] to <8 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <8 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {<2 x i8>, <3 x i8>}, align 4, addrspace(5)
  store i64 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s2s2i8s4i8(i48 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s2s2i8s4i8(
; CHECK-SAME: i48 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <6 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i48 [[BITS]] to <6 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <6 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {{i8, i8}, {i8, i8, i8, i8}}, align 4, addrspace(5)
  store i48 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s2s2i8s3i8(i40 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s2s2i8s3i8(
; CHECK-SAME: i40 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <5 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i40 [[BITS]] to <5 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <5 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {{i8, i8}, {i8, i8, i8}}, align 4, addrspace(5)
  store i40 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s3i8s1i8v2i8(i32 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s3i8s1i8v2i8(
; CHECK-SAME: i32 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 [[BITS]] to <4 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {i8, {i8}, <2 x i8>}, align 4, addrspace(5)
  store i32 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

define i8 @test_s3i8i8s0(i16 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_s3i8i8s0(
; CHECK-SAME: i16 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <2 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i16 [[BITS]] to <2 x i8>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <2 x i8> [[TMP1]], i64 [[IDX]]
; CHECK-NEXT:    ret i8 [[TMP2]]
;
  %stack = alloca {i8, i8, {}}, align 4, addrspace(5)
  store i16 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

; heterogeneous element types are not supported
define i8 @test_heterogeneous(i32 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_heterogeneous(
; CHECK-SAME: i32 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = alloca { i8, i8, i16 }, align 4, addrspace(5)
; CHECK-NEXT:    store i32 [[BITS]], ptr addrspace(5) [[STACK]], align 4
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(5) [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load i8, ptr addrspace(5) [[PTR]], align 1
; CHECK-NEXT:    ret i8 [[VAL]]
;
  %stack = alloca {i8, i8, i16}, align 4, addrspace(5)
  store i32 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}

; empty types are not supported
define void @test_empty() {
; CHECK-LABEL: define void @test_empty() {
; CHECK-NEXT:    [[STACK:%.*]] = alloca {}, align 4, addrspace(5)
; CHECK-NEXT:    ret void
;
  %stack = alloca {}, align 4, addrspace(5)
  ret void
}

; singleton types are not supported
define i8 @test_singleton(i8 %bits, i64 %idx) {
; CHECK-LABEL: define i8 @test_singleton(
; CHECK-SAME: i8 [[BITS:%.*]], i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = alloca { i8, {} }, align 4, addrspace(5)
; CHECK-NEXT:    store i8 [[BITS]], ptr addrspace(5) [[STACK]], align 1
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(5) [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load i8, ptr addrspace(5) [[PTR]], align 1
; CHECK-NEXT:    ret i8 [[VAL]]
;
  %stack = alloca {i8, {}}, align 4, addrspace(5)
  store i8 %bits, ptr addrspace(5) %stack
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  ret i8 %val
}
