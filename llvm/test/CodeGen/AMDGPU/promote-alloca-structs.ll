; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -passes=amdgpu-promote-alloca-to-vector -amdgpu-promote-alloca-to-vector-limit=512 %s | FileCheck %s

declare void @clobber_i8(i8)

define void @test_v4i8(i64 %idx) {
; CHECK-LABEL: define void @test_v4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <4 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca <4 x i8>, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_a4i8(i64 %idx) {
; CHECK-LABEL: define void @test_a4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <4 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca [4 x i8], align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_a2v4i8(i64 %idx) {
; CHECK-LABEL: define void @test_a2v4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <8 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca [2 x <4 x i8>], align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_a2v3i8(i64 %idx) {
; CHECK-LABEL: define void @test_a2v3i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <8 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca [2 x <3 x i8>], align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_a2a4i8(i64 %idx) {
; CHECK-LABEL: define void @test_a2a4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <8 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca [2 x [4 x i8]], align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_a2a3i8(i64 %idx) {
; CHECK-LABEL: define void @test_a2a3i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <6 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <6 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca [2 x [3 x i8]], align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s1v4i8(i64 %idx) {
; CHECK-LABEL: define void @test_s1v4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <4 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {<4 x i8>}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s1a4i8(i64 %idx) {
; CHECK-LABEL: define void @test_s1a4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <4 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {[4 x i8]}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s4i8(i64 %idx) {
; CHECK-LABEL: define void @test_s4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <4 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {i8, i8, i8, i8}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s2v4i8(i64 %idx) {
; CHECK-LABEL: define void @test_s2v4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <8 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {<4 x i8>, <4 x i8>}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s2v2i8v4i8(i64 %idx) {
; CHECK-LABEL: define void @test_s2v2i8v4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <8 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {<2 x i8>, <4 x i8>}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s2v2i8v3i8(i64 %idx) {
; CHECK-LABEL: define void @test_s2v2i8v3i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <8 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <8 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {<2 x i8>, <3 x i8>}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s2s2i8s4i8(i64 %idx) {
; CHECK-LABEL: define void @test_s2s2i8s4i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <6 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <6 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {{i8, i8}, {i8, i8, i8, i8}}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s2s2i8s3i8(i64 %idx) {
; CHECK-LABEL: define void @test_s2s2i8s3i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <5 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <5 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {{i8, i8}, {i8, i8, i8}}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s3i8s1i8v2i8(i64 %idx) {
; CHECK-LABEL: define void @test_s3i8s1i8v2i8(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <4 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <4 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {i8, {i8}, <2 x i8>}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

define void @test_s3i8i8s0(i64 %idx) {
; CHECK-LABEL: define void @test_s3i8i8s0(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = freeze <2 x i8> poison
; CHECK-NEXT:    [[TMP1:%.*]] = extractelement <2 x i8> [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    call void @clobber_i8(i8 [[TMP1]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {i8, i8, {}}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

; heterogeneous element types are not supported
define void @test_heterogeneous(i64 %idx) {
; CHECK-LABEL: define void @test_heterogeneous(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = alloca { i8, i8, i16 }, align 4, addrspace(5)
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(5) [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load i8, ptr addrspace(5) [[PTR]], align 1
; CHECK-NEXT:    call void @clobber_i8(i8 [[VAL]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {i8, i8, i16}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

; empty types are not supported
define void @test_empty(i64 %idx) {
; CHECK-LABEL: define void @test_empty(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = alloca {}, align 4, addrspace(5)
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(5) [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load i8, ptr addrspace(5) [[PTR]], align 1
; CHECK-NEXT:    call void @clobber_i8(i8 [[VAL]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}

; singleton types are not supported
define void @test_singleton(i64 %idx) {
; CHECK-LABEL: define void @test_singleton(
; CHECK-SAME: i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[STACK:%.*]] = alloca { i8, {} }, align 4, addrspace(5)
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(5) [[STACK]], i64 [[IDX]]
; CHECK-NEXT:    [[VAL:%.*]] = load i8, ptr addrspace(5) [[PTR]], align 1
; CHECK-NEXT:    call void @clobber_i8(i8 [[VAL]])
; CHECK-NEXT:    ret void
;
  %stack = alloca {i8, {}}, align 4, addrspace(5)
  %ptr = getelementptr inbounds i8, ptr addrspace(5) %stack, i64 %idx
  %val = load i8, ptr addrspace(5) %ptr, align 1
  call void @clobber_i8(i8 %val)
  ret void
}
