# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 6
# RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx900 -run-pass=machine-loops,livevars,phi-node-elimination -no-phi-elim-live-out-early-exit -o - %s | FileCheck %s

# Test that PHIElimination accesses MachineLoopInfo if available for
# loop-aware edge splitting. The -no-phi-elim-live-out-early-exit flag
# ensures we reach the loop exiting edge optimization code path.

---
name:            test_loop_exit_edge_split
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: test_loop_exit_edge_split
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $sgpr0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:sgpr_32 = COPY killed $sgpr0
  ; CHECK-NEXT:   [[V_MOV_B32_e32_:%[0-9]+]]:vgpr_32 = V_MOV_B32_e32 0, implicit $exec
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed [[V_MOV_B32_e32_]]
  ; CHECK-NEXT:   S_BRANCH %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.4(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed [[COPY2]]
  ; CHECK-NEXT:   [[V_CMP_LT_I32_e64_:%[0-9]+]]:sreg_64_xexec = V_CMP_LT_I32_e64 [[COPY3]], [[COPY1]], implicit $exec
  ; CHECK-NEXT:   $vcc = COPY killed [[V_CMP_LT_I32_e64_]]
  ; CHECK-NEXT:   S_CBRANCH_VCCZ %bb.2, implicit killed $vcc
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vgpr_32 = COPY killed [[COPY3]]
  ; CHECK-NEXT:   S_BRANCH %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   successors: %bb.5(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_ADD_U32_e64_:%[0-9]+]]:vgpr_32 = V_ADD_U32_e64 killed [[COPY3]], [[COPY]], 0, implicit $exec
  ; CHECK-NEXT:   [[V_CMP_EQ_U32_e64_:%[0-9]+]]:sreg_64_xexec = V_CMP_EQ_U32_e64 [[V_ADD_U32_e64_]], [[COPY1]], implicit $exec
  ; CHECK-NEXT:   $vcc = COPY killed [[V_CMP_EQ_U32_e64_]]
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY [[V_ADD_U32_e64_]]
  ; CHECK-NEXT:   S_CBRANCH_VCCZ %bb.1, implicit killed $vcc
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.5:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vgpr_32 = COPY killed [[V_ADD_U32_e64_]]
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3:
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:vgpr_32 = COPY killed [[COPY4]]
  ; CHECK-NEXT:   $vgpr0 = COPY killed [[COPY5]]
  ; CHECK-NEXT:   SI_RETURN implicit killed $vgpr0
  bb.0:
    liveins: $vgpr0, $sgpr0
    %0:vgpr_32 = COPY $vgpr0
    %1:sgpr_32 = COPY $sgpr0
    %2:vgpr_32 = V_MOV_B32_e32 0, implicit $exec
    S_BRANCH %bb.1

  bb.1:
    ; Loop header with PHI (multiple predecessors: bb.0, bb.2)
    %3:vgpr_32 = PHI %2, %bb.0, %4, %bb.2

    %10:sreg_64_xexec = V_CMP_LT_I32_e64 %3, %1, implicit $exec
    $vcc = COPY %10
    S_CBRANCH_VCCNZ %bb.3, implicit $vcc
    S_BRANCH %bb.2

  bb.2:
    ; Loop body with two successors
    %4:vgpr_32 = V_ADD_U32_e64 %3, %0, 0, implicit $exec

    %11:sreg_64_xexec = V_CMP_EQ_U32_e64 %4, %1, implicit $exec
    $vcc = COPY %11
    S_CBRANCH_VCCNZ %bb.3, implicit $vcc
    S_BRANCH %bb.1

  bb.3:
    ; Exit - PHI with values from both bb.1 and bb.2
    %5:vgpr_32 = PHI %3, %bb.1, %4, %bb.2
    $vgpr0 = COPY %5
    SI_RETURN implicit $vgpr0
...
