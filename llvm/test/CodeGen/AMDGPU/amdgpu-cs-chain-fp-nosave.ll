; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=amdgcn -mcpu=gfx1200 -o - < %s 2>&1 | FileCheck %s

; These situations are "special" in that they have an alloca not in the entry
; block, which affects prolog/epilog generation.

declare amdgpu_gfx void @foo()

define amdgpu_cs_chain void @test_alloca() {
; CHECK-LABEL: test_alloca:
; CHECK:       ; %bb.0: ; %.entry
; CHECK-NEXT:    s_wait_loadcnt_dscnt 0x0
; CHECK-NEXT:    s_wait_expcnt 0x0
; CHECK-NEXT:    s_wait_samplecnt 0x0
; CHECK-NEXT:    s_wait_bvhcnt 0x0
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    v_mov_b32_e32 v0, 0
; CHECK-NEXT:    s_mov_b32 s32, 16
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_mov_b32 s0, s32
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_add_co_i32 s32, s0, 0x200
; CHECK-NEXT:    scratch_store_b32 off, v0, s0
; CHECK-NEXT:    s_endpgm
.entry:
  br label %SW_C

SW_C:                                             ; preds = %.entry
  %v = alloca i32, i32 1, align 4, addrspace(5)
  store i32 0, ptr addrspace(5) %v, align 4
  ret void
}

define amdgpu_cs_chain void @test_alloca_and_call() {
; CHECK-LABEL: test_alloca_and_call:
; CHECK:       ; %bb.0: ; %.entry
; CHECK-NEXT:    s_wait_loadcnt_dscnt 0x0
; CHECK-NEXT:    s_wait_expcnt 0x0
; CHECK-NEXT:    s_wait_samplecnt 0x0
; CHECK-NEXT:    s_wait_bvhcnt 0x0
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    s_getpc_b64 s[0:1]
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_sext_i32_i16 s1, s1
; CHECK-NEXT:    s_add_co_u32 s0, s0, foo@gotpcrel32@lo+12
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_add_co_ci_u32 s1, s1, foo@gotpcrel32@hi+24
; CHECK-NEXT:    v_mov_b32_e32 v0, 0
; CHECK-NEXT:    s_load_b64 s[0:1], s[0:1], 0x0
; CHECK-NEXT:    s_mov_b32 s32, 16
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_mov_b32 s2, s32
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_add_co_i32 s32, s2, 0x200
; CHECK-NEXT:    scratch_store_b32 off, v0, s2
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_swappc_b64 s[30:31], s[0:1]
; CHECK-NEXT:    s_endpgm
.entry:
  br label %SW_C

SW_C:                                             ; preds = %.entry
  %v = alloca i32, i32 1, align 4, addrspace(5)
  store i32 0, ptr addrspace(5) %v, align 4
  call amdgpu_gfx void @foo()
  ret void
}

define amdgpu_cs_chain void @test_call_and_alloca() {
; CHECK-LABEL: test_call_and_alloca:
; CHECK:       ; %bb.0: ; %.entry
; CHECK-NEXT:    s_wait_loadcnt_dscnt 0x0
; CHECK-NEXT:    s_wait_expcnt 0x0
; CHECK-NEXT:    s_wait_samplecnt 0x0
; CHECK-NEXT:    s_wait_bvhcnt 0x0
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    s_getpc_b64 s[0:1]
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_sext_i32_i16 s1, s1
; CHECK-NEXT:    s_add_co_u32 s0, s0, foo@gotpcrel32@lo+12
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_add_co_ci_u32 s1, s1, foo@gotpcrel32@hi+24
; CHECK-NEXT:    s_mov_b32 s32, 16
; CHECK-NEXT:    s_load_b64 s[0:1], s[0:1], 0x0
; CHECK-NEXT:    s_mov_b32 s4, s32
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_add_co_i32 s32, s4, 0x200
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    s_wait_alu 0xfffe
; CHECK-NEXT:    s_swappc_b64 s[30:31], s[0:1]
; CHECK-NEXT:    v_mov_b32_e32 v0, 0
; CHECK-NEXT:    scratch_store_b32 off, v0, s4
; CHECK-NEXT:    s_endpgm
.entry:
  br label %SW_C

SW_C:                                             ; preds = %.entry
  %v = alloca i32, i32 1, align 4, addrspace(5)
  call amdgpu_gfx void @foo()
  store i32 0, ptr addrspace(5) %v, align 4
  ret void
}
