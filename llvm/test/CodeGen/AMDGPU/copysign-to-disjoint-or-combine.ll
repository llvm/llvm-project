; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx900 < %s | FileCheck -check-prefix=GFX9 %s

; Negative test, don't know %x is positive
define half @copysign_known_signmask_f16(half %x, i16 %sign) {
; GFX9-LABEL: copysign_known_signmask_f16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b16_e32 v1, 15, v1
; GFX9-NEXT:    s_movk_i32 s4, 0x7fff
; GFX9-NEXT:    v_bfi_b32 v0, s4, v0, v1
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i16 %sign, 15
  %signmask.bitcast = bitcast i16 %signmask to half
  %result = call half @llvm.copysign.f16(half %x, half %signmask.bitcast)
  ret half %result
}

; Negative test, don't know %x is positive
define float @copysign_known_signmask_f32(float %x, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b32_e32 v1, 31, v1
; GFX9-NEXT:    s_brev_b32 s4, -2
; GFX9-NEXT:    v_bfi_b32 v0, s4, v0, v1
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %result = call float @llvm.copysign.f32(float %x, float %signmask.bitcast)
  ret float %result
}

; Negative test, don't know %x is positive
define double @copysign_known_signmask_f64(double %x, i64 %sign) {
; GFX9-LABEL: copysign_known_signmask_f64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 31, v2
; GFX9-NEXT:    s_brev_b32 s4, -2
; GFX9-NEXT:    v_bfi_b32 v1, s4, v1, v2
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i64 %sign, 63
  %signmask.bitcast = bitcast i64 %signmask to double
  %result = call double @llvm.copysign.f64(double %x, double %signmask.bitcast)
  ret double %result
}

; Negative test, don't know %x is positive
define float @copysign_known_signmask_f32_known_not_known_positive_mag_maybe_nan(float nofpclass(ninf nzero nsub nnorm) %sign.bit.known.zero, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32_known_not_known_positive_mag_maybe_nan:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b32_e32 v1, 31, v1
; GFX9-NEXT:    s_brev_b32 s4, -2
; GFX9-NEXT:    v_bfi_b32 v0, s4, v0, v1
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %result = call float @llvm.copysign.f32(float %sign.bit.known.zero, float %signmask.bitcast)
  ret float %result
}

; Negative test, don't know %x is positive
define float @copysign_known_signmask_f32_known_not_known_positive_mag_maybe_negzero(float nofpclass(nan ninf nsub nnorm) %sign.bit.known.zero, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32_known_not_known_positive_mag_maybe_negzero:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b32_e32 v1, 31, v1
; GFX9-NEXT:    s_brev_b32 s4, -2
; GFX9-NEXT:    v_bfi_b32 v0, s4, v0, v1
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %result = call float @llvm.copysign.f32(float %sign.bit.known.zero, float %signmask.bitcast)
  ret float %result
}

define half @copysign_known_signmask_f16_known_positive_mag(half nofpclass(nan ninf nzero nsub nnorm) %sign.bit.known.zero, i16 %sign) {
; GFX9-LABEL: copysign_known_signmask_f16_known_positive_mag:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b16_e32 v1, 15, v1
; GFX9-NEXT:    v_or_b32_e32 v0, v0, v1
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i16 %sign, 15
  %signmask.bitcast = bitcast i16 %signmask to half
  %result = call half @llvm.copysign.f16(half %sign.bit.known.zero, half %signmask.bitcast)
  ret half %result
}

define float @copysign_known_signmask_f32_known_positive_mag(float nofpclass(nan ninf nzero nsub nnorm) %sign.bit.known.zero, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32_known_positive_mag:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshl_or_b32 v0, v1, 31, v0
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %result = call float @llvm.copysign.f32(float %sign.bit.known.zero, float %signmask.bitcast)
  ret float %result
}

define double @copysign_known_signmask_f64_known_positive_mag(double nofpclass(nan ninf nzero nsub nnorm) %sign.bit.known.zero, i64 %sign) {
; GFX9-LABEL: copysign_known_signmask_f64_known_positive_mag:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 31, v2
; GFX9-NEXT:    v_or_b32_e32 v1, v1, v2
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i64 %sign, 63
  %signmask.bitcast = bitcast i64 %signmask to double
  %result = call double @llvm.copysign.f64(double %sign.bit.known.zero, double %signmask.bitcast)
  ret double %result
}

; exp always returns a positive result, excluding the unknown nan sign
; bit.
define float @copysign_known_signmask_f32_known_positive_mag__nnan_exp(float %x, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32_known_positive_mag__nnan_exp:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s4, 0xc2aeac50
; GFX9-NEXT:    v_add_f32_e32 v2, 0x42800000, v0
; GFX9-NEXT:    v_cmp_gt_f32_e32 vcc, s4, v0
; GFX9-NEXT:    v_cndmask_b32_e32 v0, v0, v2, vcc
; GFX9-NEXT:    v_mul_f32_e32 v0, 0x3fb8aa3b, v0
; GFX9-NEXT:    v_exp_f32_e32 v0, v0
; GFX9-NEXT:    v_mul_f32_e32 v2, 0x114b4ea4, v0
; GFX9-NEXT:    v_cndmask_b32_e32 v0, v0, v2, vcc
; GFX9-NEXT:    v_lshl_or_b32 v0, v1, 31, v0
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signbit.known.zero = call nnan afn float @llvm.exp.f32(float %x)
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %result = call float @llvm.copysign.f32(float %signbit.known.zero, float %signmask.bitcast)
  ret float %result
}

define float @copysign_known_signmask_f32_known_positive_mag__nnan_exp2(float %x, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32_known_positive_mag__nnan_exp2:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s4, 0xc2fc0000
; GFX9-NEXT:    v_cmp_gt_f32_e32 vcc, s4, v0
; GFX9-NEXT:    v_mov_b32_e32 v3, 0x42800000
; GFX9-NEXT:    v_cndmask_b32_e32 v3, 0, v3, vcc
; GFX9-NEXT:    v_add_f32_e32 v0, v0, v3
; GFX9-NEXT:    v_exp_f32_e32 v0, v0
; GFX9-NEXT:    v_not_b32_e32 v2, 63
; GFX9-NEXT:    v_cndmask_b32_e32 v2, 0, v2, vcc
; GFX9-NEXT:    v_ldexp_f32 v0, v0, v2
; GFX9-NEXT:    v_lshl_or_b32 v0, v1, 31, v0
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signbit.known.zero = call nnan afn float @llvm.exp2.f32(float %x)
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %result = call float @llvm.copysign.f32(float %signbit.known.zero, float %signmask.bitcast)
  ret float %result
}

define float @copysign_known_signmask_f32_known_positive_mag__nnan_exp10(float %x, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32_known_positive_mag__nnan_exp10:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s4, 0xc2fc0000
; GFX9-NEXT:    v_cmp_gt_f32_e32 vcc, s4, v0
; GFX9-NEXT:    v_mov_b32_e32 v3, 0x42800000
; GFX9-NEXT:    v_cndmask_b32_e32 v3, 0, v3, vcc
; GFX9-NEXT:    v_add_f32_e32 v0, v0, v3
; GFX9-NEXT:    v_exp_f32_e32 v0, v0
; GFX9-NEXT:    v_not_b32_e32 v2, 63
; GFX9-NEXT:    v_cndmask_b32_e32 v2, 0, v2, vcc
; GFX9-NEXT:    v_ldexp_f32 v0, v0, v2
; GFX9-NEXT:    v_lshl_or_b32 v0, v1, 31, v0
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signbit.known.zero = call nnan afn float @llvm.exp2.f32(float %x)
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %result = call float @llvm.copysign.f32(float %signbit.known.zero, float %signmask.bitcast)
  ret float %result
}

define float @copysign_known_signmask_f32_known_positive_mag_through_fence(float nofpclass(nan ninf nzero nsub nnorm) %sign.bit.known.zero, i32 %sign) {
; GFX9-LABEL: copysign_known_signmask_f32_known_positive_mag_through_fence:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GFX9-NEXT:    v_lshlrev_b32_e32 v1, 31, v1
; GFX9-NEXT:    ;ARITH_FENCE
; GFX9-NEXT:    s_brev_b32 s4, -2
; GFX9-NEXT:    v_bfi_b32 v0, s4, v0, v1
; GFX9-NEXT:    s_setpc_b64 s[30:31]
  %signmask = shl i32 %sign, 31
  %signmask.bitcast = bitcast i32 %signmask to float
  %fence = call float @llvm.arithmetic.fence.f32(float %sign.bit.known.zero)
  %result = call float @llvm.copysign.f32(float %fence, float %signmask.bitcast)
  ret float %result
}
