# RUN: llc -mtriple amdgcn -run-pass phi-node-elimination -o - %s | FileCheck %s

---
# The test is to make sure that two phis, with the same right-hand-site but different
# register classes for their left-hand-sites, are not doing phi reuse optimization.
# Not sure whether this test makes any sense for the AMDGPU target, but it is a valid
# case for aother GPU target that is not in LLVM trunk yet. Thus, this test uses the
# ADMGPU target as a proof of concept.

# Because of no reuse for the two phis, there are two temps: CP0 and CP1
# They are translated to:
#   phi1 (%1:sreg_32) = CP0
#   phi2 (%4:vgpr_32) = CP1
#
# CHECK-LABEL: check-phi-reuse
# CHECK-LABEL: bb.1:
# CHECK: %1:sreg_32 = COPY %[[#CP0:]]
# CHECK: %[[#CP0]]:sreg_32 = COPY {{.+}}
# CHECK: %[[#CP1:]]:vgpr_32 = COPY {{.+}}
# CHECK-LABEL: bb.2:
# CHECK: %4:vgpr_32 = COPY %[[#CP1]]



name:            check-phi-reuse
tracksRegLiveness: true
body:             |
  bb.0:
    %1:sreg_32 = S_MOV_B32 255
    S_CBRANCH_SCC0 %bb.2, implicit undef $scc

  bb.1:
    %3:sreg_32 = PHI %4, %bb.1, %1, %bb.0
    %2:sreg_32 = S_ADD_I32 %3, 1, implicit-def $scc
    %4:vgpr_32 = COPY %2
    S_CBRANCH_SCC0 %bb.1, implicit killed $scc
    S_BRANCH %bb.2

  bb.2:
    %5:vgpr_32 = PHI %4, %bb.1, %1, %bb.0
...

