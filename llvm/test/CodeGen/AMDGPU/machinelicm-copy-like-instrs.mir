# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 4
# RUN: llc -mtriple=amdgcn -run-pass=early-machinelicm -simplify-mir -o - %s | FileCheck %s
# RUN: llc -mtriple=amdgcn -passes=early-machinelicm -simplify-mir -o - %s | FileCheck %s

# Test to check machine LICM does not hoist convergent instructions,
# DS_PERMUTE_B32 in this example.

---
name: licm_reg_sequence
body: |
  ; CHECK-LABEL: name: licm_reg_sequence
  ; CHECK: bb.0:
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY $vgpr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY $vgpr1
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE [[COPY]], %subreg.sub0, [[COPY1]], %subreg.sub1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   S_NOP 0, implicit [[REG_SEQUENCE]]
  ; CHECK-NEXT:   S_CBRANCH_SCC1 %bb.1, implicit undef $scc
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   $vgpr0 = COPY [[REG_SEQUENCE]]
  ; CHECK-NEXT:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0, $vgpr1
    successors: %bb.1

    %0:vgpr_32 = COPY $vgpr0
    %1:vgpr_32 = COPY $vgpr1

  bb.1:
    successors: %bb.1, %bb.2

    %3:vreg_64 = REG_SEQUENCE %0, %subreg.sub0, %1, %subreg.sub1
    S_NOP 0, implicit %3
    S_CBRANCH_SCC1 %bb.1, implicit undef $scc
    S_BRANCH %bb.2

  bb.2:
    $vgpr0 = COPY %3
    S_ENDPGM 0

...

# Don't bother handling reg_sequence with physreg uses (is there any
# reason for these to be legal)?
---
name: licm_reg_sequence_physreg_use
body: |
  ; CHECK-LABEL: name: licm_reg_sequence_physreg_use
  ; CHECK: bb.0:
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY $vgpr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY $vgpr1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   liveins: $vgpr0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE [[COPY]], %subreg.sub0, $vgpr1, %subreg.sub1
  ; CHECK-NEXT:   S_NOP 0, implicit [[REG_SEQUENCE]]
  ; CHECK-NEXT:   S_CBRANCH_SCC1 %bb.1, implicit undef $scc
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   $vgpr0 = COPY [[REG_SEQUENCE]]
  ; CHECK-NEXT:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0, $vgpr1
    successors: %bb.1

    %0:vgpr_32 = COPY $vgpr0
    %1:vgpr_32 = COPY $vgpr1

  bb.1:
    successors: %bb.1, %bb.2
    liveins: $vgpr0

    %3:vreg_64 = REG_SEQUENCE %0, %subreg.sub0, $vgpr1, %subreg.sub1
    S_NOP 0, implicit %3
    S_CBRANCH_SCC1 %bb.1, implicit undef $scc
    S_BRANCH %bb.2

  bb.2:
    $vgpr0 = COPY %3
    S_ENDPGM 0

...

---
name: licm_insert_subreg
body: |
  ; CHECK-LABEL: name: licm_insert_subreg
  ; CHECK: bb.0:
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY $vgpr0
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY $vgpr1
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:vreg_64 = IMPLICIT_DEF
  ; CHECK-NEXT:   [[INSERT_SUBREG:%[0-9]+]]:vreg_64 = INSERT_SUBREG [[DEF]], [[COPY]], %subreg.sub0
  ; CHECK-NEXT:   [[INSERT_SUBREG1:%[0-9]+]]:vreg_64 = INSERT_SUBREG [[INSERT_SUBREG]], [[COPY1]], %subreg.sub1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   S_NOP 0, implicit [[INSERT_SUBREG1]]
  ; CHECK-NEXT:   S_CBRANCH_SCC1 %bb.1, implicit undef $scc
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   $vgpr0_vgpr1 = COPY [[INSERT_SUBREG1]]
  ; CHECK-NEXT:   S_ENDPGM 0
  bb.0:
    liveins: $vgpr0, $vgpr1
    successors: %bb.1

    %0:vgpr_32 = COPY $vgpr0
    %1:vgpr_32 = COPY $vgpr1

  bb.1:
    successors: %bb.1, %bb.2

    %3:vreg_64 = IMPLICIT_DEF
    %4:vreg_64 = INSERT_SUBREG %3, %0, %subreg.sub0
    %5:vreg_64 = INSERT_SUBREG %4, %1, %subreg.sub1
    S_NOP 0, implicit %5
    S_CBRANCH_SCC1 %bb.1, implicit undef $scc
    S_BRANCH %bb.2

  bb.2:
    $vgpr0_vgpr1 = COPY %5
    S_ENDPGM 0

...
