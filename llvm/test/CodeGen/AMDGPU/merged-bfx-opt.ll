; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=amdgcn -mcpu=fiji < %s | FileCheck %s --check-prefixes=CHECK,DAGISEL
; RUN: llc -mtriple=amdgcn -mcpu=fiji -global-isel < %s | FileCheck %s --check-prefixes=CHECK,GISEL

; FIXME?: G_UBFX is not legal for i16, so GlobalISel version doesn't match.
define i1 @basic_eq_i16_3x5(i16 %arg) {
; DAGISEL-LABEL: basic_eq_i16_3x5:
; DAGISEL:       ; %bb.0: ; %entry
; DAGISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; DAGISEL-NEXT:    v_and_b32_e32 v0, 0x7fff, v0
; DAGISEL-NEXT:    v_cmp_eq_u16_e32 vcc, 0, v0
; DAGISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; DAGISEL-NEXT:    s_setpc_b64 s[30:31]
;
; GISEL-LABEL: basic_eq_i16_3x5:
; GISEL:       ; %bb.0: ; %entry
; GISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GISEL-NEXT:    v_lshrrev_b16_e32 v1, 5, v0
; GISEL-NEXT:    v_or_b32_e32 v1, v0, v1
; GISEL-NEXT:    v_lshrrev_b16_e32 v0, 10, v0
; GISEL-NEXT:    v_or_b32_e32 v0, v1, v0
; GISEL-NEXT:    v_and_b32_e32 v0, 31, v0
; GISEL-NEXT:    v_cmp_eq_u16_e32 vcc, 0, v0
; GISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; GISEL-NEXT:    s_setpc_b64 s[30:31]
entry:
  %a = and i16 %arg, 31
  %sh5 = lshr i16 %arg, 5
  %b = and i16 %sh5, 31
  %or = or i16 %a, %b
  %sh10 = lshr i16 %arg, 10
  %c = and i16 %sh10, 31
  %or1 = or i16 %or, %c
  %cmp = icmp eq i16 %or1, 0
  ret i1 %cmp
}

define i1 @basic_eq_i32_3x5(i32 %arg) {
; CHECK-LABEL: basic_eq_i32_3x5:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_and_b32_e32 v0, 0x7fff, v0
; CHECK-NEXT:    v_cmp_eq_u32_e32 vcc, 0, v0
; CHECK-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; CHECK-NEXT:    s_setpc_b64 s[30:31]
entry:
  %a = and i32 %arg, 31
  %sh5 = lshr i32 %arg, 5
  %b = and i32 %sh5, 31
  %or = or i32 %a, %b
  %sh10 = lshr i32 %arg, 10
  %c = and i32 %sh10, 31
  %or1 = or i32 %or, %c
  %cmp = icmp eq i32 %or1, 0
  ret i1 %cmp
}

define i1 @basic_eq_i64_3x5(i64 %arg) {
; DAGISEL-LABEL: basic_eq_i64_3x5:
; DAGISEL:       ; %bb.0: ; %entry
; DAGISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; DAGISEL-NEXT:    v_and_b32_e32 v0, 0x7fff, v0
; DAGISEL-NEXT:    v_cmp_eq_u32_e32 vcc, 0, v0
; DAGISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; DAGISEL-NEXT:    s_setpc_b64 s[30:31]
;
; GISEL-LABEL: basic_eq_i64_3x5:
; GISEL:       ; %bb.0: ; %entry
; GISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GISEL-NEXT:    v_and_b32_e32 v0, 0x7fff, v0
; GISEL-NEXT:    v_mov_b32_e32 v1, 0
; GISEL-NEXT:    v_cmp_eq_u64_e32 vcc, 0, v[0:1]
; GISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; GISEL-NEXT:    s_setpc_b64 s[30:31]
entry:
  %a = and i64 %arg, 31
  %sh5 = lshr i64 %arg, 5
  %b = and i64 %sh5, 31
  %or = or i64 %a, %b
  %sh10 = lshr i64 %arg, 10
  %c = and i64 %sh10, 31
  %or1 = or i64 %or, %c
  %cmp = icmp eq i64 %or1, 0
  ret i1 %cmp
}

define i1 @basic_ne_i32_3x5(i32 %arg) {
; CHECK-LABEL: basic_ne_i32_3x5:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_and_b32_e32 v0, 0x7fff, v0
; CHECK-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v0
; CHECK-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; CHECK-NEXT:    s_setpc_b64 s[30:31]
entry:
  %a = and i32 %arg, 31
  %sh5 = lshr i32 %arg, 5
  %b = and i32 %sh5, 31
  %or = or i32 %a, %b
  %sh10 = lshr i32 %arg, 10
  %c = and i32 %sh10, 31
  %or1 = or i32 %or, %c
  %cmp = icmp ne i32 %or1, 0
  ret i1 %cmp
}

define i1 @eq_i32_3x5_holes_in_mask(i32 %arg) {
; CHECK-LABEL: eq_i32_3x5_holes_in_mask:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_and_b32_e32 v0, 0x7f9f, v0
; CHECK-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v0
; CHECK-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; CHECK-NEXT:    s_setpc_b64 s[30:31]
entry:
  %a = and i32 %arg, 31
  %sh5 = lshr i32 %arg, 7
  %b = and i32 %sh5, 31
  %or = or i32 %a, %b
  %sh10 = lshr i32 %arg, 10
  %c = and i32 %sh10, 31
  %or1 = or i32 %or, %c
  %cmp = icmp ne i32 %or1, 0
  ret i1 %cmp
}

define i1 @eq_i32_3x5_all_shifted(i32 %arg) {
; CHECK-LABEL: eq_i32_3x5_all_shifted:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_and_b32_e32 v0, 0x7ffc, v0
; CHECK-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v0
; CHECK-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; CHECK-NEXT:    s_setpc_b64 s[30:31]
entry:
  %sh2 = lshr i32 %arg, 2
  %a = and i32 %sh2, 31
  %sh5 = lshr i32 %arg, 7
  %b = and i32 %sh5, 31
  %or = or i32 %a, %b
  %sh10 = lshr i32 %arg, 10
  %c = and i32 %sh10, 31
  %or1 = or i32 %or, %c
  %cmp = icmp ne i32 %or1, 0
  ret i1 %cmp
}

define <2 x i1> @basic_eq_v2i16_3x5(<2 x i16> %arg) {
; DAGISEL-LABEL: basic_eq_v2i16_3x5:
; DAGISEL:       ; %bb.0: ; %entry
; DAGISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; DAGISEL-NEXT:    v_lshrrev_b32_e32 v1, 5, v0
; DAGISEL-NEXT:    v_and_b32_e32 v1, 0x1f0000, v1
; DAGISEL-NEXT:    v_lshrrev_b16_e32 v2, 5, v0
; DAGISEL-NEXT:    v_or_b32_e32 v1, v2, v1
; DAGISEL-NEXT:    v_lshrrev_b32_e32 v2, 10, v0
; DAGISEL-NEXT:    v_or_b32_e32 v1, v0, v1
; DAGISEL-NEXT:    v_and_b32_e32 v2, 0x1f0000, v2
; DAGISEL-NEXT:    v_lshrrev_b16_e32 v0, 10, v0
; DAGISEL-NEXT:    v_or_b32_e32 v0, v0, v2
; DAGISEL-NEXT:    v_or_b32_e32 v0, v1, v0
; DAGISEL-NEXT:    v_and_b32_e32 v1, 0x1f001f, v0
; DAGISEL-NEXT:    v_bfe_u32 v2, v0, 16, 5
; DAGISEL-NEXT:    v_cmp_eq_u16_e32 vcc, 0, v1
; DAGISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; DAGISEL-NEXT:    v_cmp_eq_u16_e32 vcc, 0, v2
; DAGISEL-NEXT:    v_cndmask_b32_e64 v1, 0, 1, vcc
; DAGISEL-NEXT:    s_setpc_b64 s[30:31]
;
; GISEL-LABEL: basic_eq_v2i16_3x5:
; GISEL:       ; %bb.0: ; %entry
; GISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GISEL-NEXT:    v_mov_b32_e32 v1, 21
; GISEL-NEXT:    v_lshrrev_b32_sdwa v1, v1, v0 dst_sel:WORD_1 dst_unused:UNUSED_PAD src0_sel:DWORD src1_sel:DWORD
; GISEL-NEXT:    v_lshrrev_b16_e32 v2, 5, v0
; GISEL-NEXT:    v_or_b32_e32 v1, v2, v1
; GISEL-NEXT:    v_mov_b32_e32 v2, 26
; GISEL-NEXT:    v_or_b32_e32 v1, v0, v1
; GISEL-NEXT:    v_lshrrev_b32_sdwa v2, v2, v0 dst_sel:WORD_1 dst_unused:UNUSED_PAD src0_sel:DWORD src1_sel:DWORD
; GISEL-NEXT:    v_lshrrev_b16_e32 v0, 10, v0
; GISEL-NEXT:    v_or_b32_e32 v0, v0, v2
; GISEL-NEXT:    v_or_b32_e32 v0, v1, v0
; GISEL-NEXT:    v_and_b32_e32 v0, 0x1f001f, v0
; GISEL-NEXT:    v_lshrrev_b32_e32 v1, 16, v0
; GISEL-NEXT:    v_cmp_eq_u16_e32 vcc, 0, v0
; GISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; GISEL-NEXT:    v_cmp_eq_u16_e32 vcc, 0, v1
; GISEL-NEXT:    v_cndmask_b32_e64 v1, 0, 1, vcc
; GISEL-NEXT:    s_setpc_b64 s[30:31]
entry:
  %a = and <2 x i16> %arg, <i16 31, i16 31>
  %sh5 = lshr <2 x i16> %arg, <i16 5, i16 5>
  %b = and <2 x i16> %sh5, <i16 31, i16 31>
  %or = or <2 x i16> %a, %b
  %sh10 = lshr <2 x i16> %arg, <i16 10, i16 10>
  %c = and <2 x i16> %sh10, <i16 31, i16 31>
  %or1 = or <2 x i16> %or, %c
  %cmp = icmp eq <2 x i16> %or1, <i16 0, i16 0>
  ret <2 x i1> %cmp
}

define <4 x i1> @basic_ne_v4i32_3x5(<4 x i32> %arg) {
; DAGISEL-LABEL: basic_ne_v4i32_3x5:
; DAGISEL:       ; %bb.0: ; %entry
; DAGISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; DAGISEL-NEXT:    v_and_b32_e32 v0, 0x7fff, v0
; DAGISEL-NEXT:    v_and_b32_e32 v1, 0x7fff, v1
; DAGISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v0
; DAGISEL-NEXT:    v_and_b32_e32 v2, 0x7fff, v2
; DAGISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; DAGISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v1
; DAGISEL-NEXT:    v_and_b32_e32 v3, 0x7fff, v3
; DAGISEL-NEXT:    v_cndmask_b32_e64 v1, 0, 1, vcc
; DAGISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v2
; DAGISEL-NEXT:    v_cndmask_b32_e64 v2, 0, 1, vcc
; DAGISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v3
; DAGISEL-NEXT:    v_cndmask_b32_e64 v3, 0, 1, vcc
; DAGISEL-NEXT:    s_setpc_b64 s[30:31]
;
; GISEL-LABEL: basic_ne_v4i32_3x5:
; GISEL:       ; %bb.0: ; %entry
; GISEL-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; GISEL-NEXT:    v_lshrrev_b32_e32 v4, 5, v0
; GISEL-NEXT:    v_lshrrev_b32_e32 v5, 5, v1
; GISEL-NEXT:    v_or_b32_e32 v4, v0, v4
; GISEL-NEXT:    v_lshrrev_b32_e32 v0, 10, v0
; GISEL-NEXT:    v_lshrrev_b32_e32 v6, 5, v2
; GISEL-NEXT:    v_or_b32_e32 v5, v1, v5
; GISEL-NEXT:    v_lshrrev_b32_e32 v1, 10, v1
; GISEL-NEXT:    v_or_b32_e32 v0, v4, v0
; GISEL-NEXT:    v_lshrrev_b32_e32 v7, 5, v3
; GISEL-NEXT:    v_or_b32_e32 v6, v2, v6
; GISEL-NEXT:    v_lshrrev_b32_e32 v2, 10, v2
; GISEL-NEXT:    v_or_b32_e32 v1, v5, v1
; GISEL-NEXT:    v_and_b32_e32 v0, 31, v0
; GISEL-NEXT:    v_or_b32_e32 v7, v3, v7
; GISEL-NEXT:    v_lshrrev_b32_e32 v3, 10, v3
; GISEL-NEXT:    v_or_b32_e32 v2, v6, v2
; GISEL-NEXT:    v_and_b32_e32 v1, 31, v1
; GISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v0
; GISEL-NEXT:    v_or_b32_e32 v3, v7, v3
; GISEL-NEXT:    v_and_b32_e32 v2, 31, v2
; GISEL-NEXT:    v_cndmask_b32_e64 v0, 0, 1, vcc
; GISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v1
; GISEL-NEXT:    v_and_b32_e32 v3, 31, v3
; GISEL-NEXT:    v_cndmask_b32_e64 v1, 0, 1, vcc
; GISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v2
; GISEL-NEXT:    v_cndmask_b32_e64 v2, 0, 1, vcc
; GISEL-NEXT:    v_cmp_ne_u32_e32 vcc, 0, v3
; GISEL-NEXT:    v_cndmask_b32_e64 v3, 0, 1, vcc
; GISEL-NEXT:    s_setpc_b64 s[30:31]
entry:
  %a = and <4 x i32> %arg, <i32 31, i32 31, i32 31, i32 31>
  %sh5 = lshr <4 x i32> %arg, <i32 5, i32 5, i32 5, i32 5>
  %b = and <4 x i32> %sh5, <i32 31, i32 31, i32 31, i32 31>
  %or = or <4 x i32> %a, %b
  %sh10 = lshr <4 x i32> %arg, <i32 10, i32 10, i32 10, i32 10>
  %c = and <4 x i32> %sh10, <i32 31, i32 31, i32 31, i32 31>
  %or1 = or <4 x i32> %or, %c
  %cmp = icmp ne <4 x i32> %or1, <i32 0, i32 0, i32 0, i32 0>
  ret <4 x i1> %cmp
}
