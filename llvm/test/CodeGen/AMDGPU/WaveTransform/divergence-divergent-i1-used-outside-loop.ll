; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 3
; RUN: llc -mtriple=amdgcn-amd-amdpal -mcpu=gfx1200 -stop-before=phi-node-elimination -amdgpu-wave-transform-cf=1 -verify-machineinstrs < %s | FileCheck %s

; This file contains various tests that have divergent i1s used outside of
; the loop. These are lane masks is sgpr and need to have correct value in
; corresponding bit at the iteration lane exits the loop.
; Achieved by merging lane mask with same lane mask from previous iteration
; and using that merged lane mask outside of the loop.

; Phi used outside of the loop directly (loopfinder will figure out that it
; needs to merge lane mask across all iterations)
define void @divergent_i1_phi_used_outside_loop(float %val, float %pre.cond.val, ptr %addr) {
  ; CHECK-LABEL: name: divergent_i1_phi_used_outside_loop
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr3
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY killed $vgpr2
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed $vgpr1
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed $vgpr0
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY1]], %subreg.sub0, killed [[COPY]], %subreg.sub1
  ; CHECK-NEXT:   [[V_CMP_LT_F32_e64_:%[0-9]+]]:sreg_32_xm0_xexec = nofpexcept V_CMP_LT_F32_e64 0, 1065353216, 0, killed [[COPY2]], 0, implicit $mode, implicit $exec
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32 = S_MOV_B32 0
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[V_CMP_LT_F32_e64_]], implicit $exec
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop:
  ; CHECK-NEXT:   successors: %bb.2(0x04000000), %bb.1(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_]], %bb.0, %4, %bb.1
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:vgpr_32 = PHI [[V_CNDMASK_B32_e64_]], %bb.0, %39, %bb.1
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 0, [[PHI1]], implicit $exec
  ; CHECK-NEXT:   [[S_XOR_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_XOR_B32 killed [[V_CMP_NE_U32_e64_]], -1, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_1:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[S_XOR_B32_]], implicit $exec
  ; CHECK-NEXT:   [[S_CVT_F32_U32_:%[0-9]+]]:sgpr_32 = S_CVT_F32_U32 [[PHI]], implicit $mode
  ; CHECK-NEXT:   [[V_CMP_NGT_F32_e64_:%[0-9]+]]:sreg_32 = nofpexcept V_CMP_NGT_F32_e64 0, killed [[S_CVT_F32_U32_]], 0, [[COPY3]], 0, implicit $mode, implicit $exec
  ; CHECK-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = S_ADD_I32 killed [[PHI]], 1, implicit-def dead $scc
  ; CHECK-NEXT:   SI_BRCOND %bb.1, killed [[V_CMP_NGT_F32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.exit:
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_NE_U32_e64 0, killed [[PHI1]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_2:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, 1065353216, killed [[V_CMP_NE_U32_e64_1]], implicit $exec
  ; CHECK-NEXT:   FLAT_STORE_DWORD killed [[REG_SEQUENCE]], killed [[V_CNDMASK_B32_e64_2]], 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %ir.addr)
  ; CHECK-NEXT:   SI_RETURN
entry:
  %pre.cond = fcmp ogt float %pre.cond.val, 1.0
  br label %loop

loop:
  %counter = phi i32 [ 0, %entry ], [ %counter.plus.1, %loop ]
  %bool.counter = phi i1 [ %pre.cond, %entry ], [ %neg.bool.counter, %loop ]
  %neg.bool.counter = xor i1 %bool.counter, true
  %f.counter = uitofp i32 %counter to float
  %cond = fcmp ogt float %f.counter, %val
  %counter.plus.1 = add i32 %counter, 1
  br i1 %cond, label %exit, label %loop

exit:
  %select = select i1 %bool.counter, float 1.000000e+00, float 0.000000e+00
  store float %select, ptr %addr
  ret void
}

define void @divergent_i1_phi_used_outside_loop_larger_loop_body(float %val, ptr addrspace(1) %a, ptr %addr) {
  ; CHECK-LABEL: name: divergent_i1_phi_used_outside_loop_larger_loop_body
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $vgpr1, $vgpr2, $vgpr3, $vgpr4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr4
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY killed $vgpr3
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed $vgpr2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed $vgpr1
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY1]], %subreg.sub0, killed [[COPY]], %subreg.sub1
  ; CHECK-NEXT:   [[REG_SEQUENCE1:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY3]], %subreg.sub0, killed [[COPY2]], %subreg.sub1
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_MOV_B32 -1
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, [[S_MOV_B32_]], implicit $exec
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vreg_64 = COPY killed [[REG_SEQUENCE1]]
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop.start:
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.3(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_]], %bb.0, %6, %bb.3
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:vreg_64 = PHI [[COPY4]], %bb.0, %5, %bb.3
  ; CHECK-NEXT:   [[PHI2:%[0-9]+]]:vgpr_32 = PHI [[V_CNDMASK_B32_e64_]], %bb.0, %54, %bb.3
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_NE_U32_e64 0, [[PHI2]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_1:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, 1, killed [[V_CMP_NE_U32_e64_]], implicit $exec
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_1:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 1, killed [[V_CNDMASK_B32_e64_1]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.3, killed [[V_CMP_NE_U32_e64_1]]
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.is.eq.zero:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[GLOBAL_LOAD_DWORD:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD [[PHI1]], 0, 0, implicit $exec :: (load (s32) from %ir.lsr.iv, addrspace 1)
  ; CHECK-NEXT:   [[V_CMP_EQ_U32_e64_:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_EQ_U32_e64 0, killed [[GLOBAL_LOAD_DWORD]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_2:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[V_CMP_EQ_U32_e64_]], implicit $exec
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.loop.cond:
  ; CHECK-NEXT:   successors: %bb.4(0x04000000), %bb.1(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI3:%[0-9]+]]:vgpr_32 = PHI [[PHI2]], %bb.1, [[V_CNDMASK_B32_e64_2]], %bb.2
  ; CHECK-NEXT:   [[V_ADD_CO_U32_e64_:%[0-9]+]]:vgpr_32, [[V_ADD_CO_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_ADD_CO_U32_e64 [[PHI1]].sub0, 4, 0, implicit $exec
  ; CHECK-NEXT:   %57:vgpr_32, dead $sgpr_null = V_ADDC_U32_e64 0, killed [[PHI1]].sub1, killed [[V_ADD_CO_U32_e64_1]], 0, implicit $exec
  ; CHECK-NEXT:   [[REG_SEQUENCE2:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[V_ADD_CO_U32_e64_]], %subreg.sub0, killed %57, %subreg.sub1
  ; CHECK-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = nsw S_ADD_I32 killed [[PHI]], 1, implicit-def dead $scc
  ; CHECK-NEXT:   S_CMP_GT_I32 [[S_ADD_I32_]], 9, implicit-def $scc
  ; CHECK-NEXT:   [[S_CSELECT_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_CSELECT_B32 -1, 0, implicit killed $scc
  ; CHECK-NEXT:   SI_BRCOND_UNIFORM %bb.1, killed [[S_CSELECT_B32_]]
  ; CHECK-NEXT:   S_BRANCH %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.exit:
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_2:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_NE_U32_e64 0, killed [[PHI2]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_3:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, 1065353216, killed [[V_CMP_NE_U32_e64_2]], implicit $exec
  ; CHECK-NEXT:   FLAT_STORE_DWORD killed [[REG_SEQUENCE]], killed [[V_CNDMASK_B32_e64_3]], 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %ir.addr)
  ; CHECK-NEXT:   SI_RETURN
entry:
  br label %loop.start

loop.start:
  %i = phi i32 [ 0, %entry ], [ %i.plus.1, %loop.cond ]
  %all.eq.zero = phi i1 [ true, %entry ], [ %eq.zero, %loop.cond ]
  br i1 %all.eq.zero, label %is.eq.zero, label %loop.cond

is.eq.zero:
  %a.plus.i = getelementptr i32, ptr addrspace(1) %a, i32 %i
  %elt.i = load i32, ptr addrspace(1) %a.plus.i
  %elt.i.eq.zero = icmp eq i32 %elt.i, 0
  br label %loop.cond

loop.cond:
  %eq.zero = phi i1 [ %all.eq.zero, %loop.start ], [ %elt.i.eq.zero, %is.eq.zero ]
  %cond = icmp slt i32 %i, 10
  %i.plus.1 = add i32 %i, 1
  br i1 %cond, label %exit, label %loop.start

exit:
  %select = select i1 %all.eq.zero, float 1.000000e+00, float 0.000000e+00
  store float %select, ptr %addr
  ret void
}

; Non-phi used outside of the loop

define void @divergent_i1_xor_used_outside_loop(float %val, float %pre.cond.val, ptr %addr) {
  ; CHECK-LABEL: name: divergent_i1_xor_used_outside_loop
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr3
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY killed $vgpr2
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed $vgpr1
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed $vgpr0
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY1]], %subreg.sub0, killed [[COPY]], %subreg.sub1
  ; CHECK-NEXT:   [[V_CMP_LT_F32_e64_:%[0-9]+]]:sreg_32_xm0_xexec = nofpexcept V_CMP_LT_F32_e64 0, 1065353216, 0, killed [[COPY2]], 0, implicit $mode, implicit $exec
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32 = S_MOV_B32 0
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[V_CMP_LT_F32_e64_]], implicit $exec
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop:
  ; CHECK-NEXT:   successors: %bb.2(0x04000000), %bb.1(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_]], %bb.0, %4, %bb.1
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:vgpr_32 = PHI [[V_CNDMASK_B32_e64_]], %bb.0, %39, %bb.1
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 0, killed [[PHI1]], implicit $exec
  ; CHECK-NEXT:   [[S_XOR_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_XOR_B32 killed [[V_CMP_NE_U32_e64_]], -1, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_1:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[S_XOR_B32_]], implicit $exec
  ; CHECK-NEXT:   [[S_CVT_F32_U32_:%[0-9]+]]:sgpr_32 = S_CVT_F32_U32 [[PHI]], implicit $mode
  ; CHECK-NEXT:   [[V_CMP_NGT_F32_e64_:%[0-9]+]]:sreg_32 = nofpexcept V_CMP_NGT_F32_e64 0, killed [[S_CVT_F32_U32_]], 0, [[COPY3]], 0, implicit $mode, implicit $exec
  ; CHECK-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = S_ADD_I32 killed [[PHI]], 1, implicit-def dead $scc
  ; CHECK-NEXT:   SI_BRCOND %bb.1, killed [[V_CMP_NGT_F32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.exit:
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_NE_U32_e64 0, killed [[V_CNDMASK_B32_e64_1]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_2:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, 1065353216, killed [[V_CMP_NE_U32_e64_1]], implicit $exec
  ; CHECK-NEXT:   FLAT_STORE_DWORD killed [[REG_SEQUENCE]], killed [[V_CNDMASK_B32_e64_2]], 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %ir.addr)
  ; CHECK-NEXT:   SI_RETURN
entry:
  %pre.cond = fcmp ogt float %pre.cond.val, 1.0
  br label %loop

loop:
  %counter = phi i32 [ 0, %entry ], [ %counter.plus.1, %loop ]
  %bool.counter = phi i1 [ %pre.cond, %entry ], [ %neg.bool.counter, %loop ]
  %neg.bool.counter = xor i1 %bool.counter, true
  %f.counter = uitofp i32 %counter to float
  %cond = fcmp ogt float %f.counter, %val
  %counter.plus.1 = add i32 %counter, 1
  br i1 %cond, label %exit, label %loop

exit:
  %select = select i1 %neg.bool.counter, float 1.000000e+00, float 0.000000e+00
  store float %select, ptr %addr
  ret void
}

;void xor(int num_elts, int* a, int* addr) {
;for(int i=0; i<num_elts; ++i) {
;  if(a[i]==0)
;    return;
;}
;addr[0] = 5
;return;
;}

define void @divergent_i1_xor_used_outside_loop_larger_loop_body(i32 %num.elts, ptr addrspace(1) %a, ptr %addr) {
  ; CHECK-LABEL: name: divergent_i1_xor_used_outside_loop_larger_loop_body
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x30000000), %bb.4(0x50000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr4
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY killed $vgpr3
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed $vgpr2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed $vgpr1
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vgpr_32 = COPY killed $vgpr0
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_MOV_B32 0
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 0, [[COPY4]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.4, killed [[V_CMP_NE_U32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop.start.preheader:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[S_MOV_B32_1:%[0-9]+]]:sreg_32_xm0_xexec = S_MOV_B32 -1
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[S_MOV_B32_1]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_1:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, [[S_MOV_B32_]], implicit $exec
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.loop.start:
  ; CHECK-NEXT:   successors: %bb.6(0x04000000), %bb.3(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_]], %bb.1, %1, %bb.3
  ; CHECK-NEXT:   [[S_ASHR_I32_:%[0-9]+]]:sreg_32_xm0 = S_ASHR_I32 [[PHI]], 31, implicit-def dead $scc
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:sreg_64 = REG_SEQUENCE [[PHI]], %subreg.sub0, killed [[S_ASHR_I32_]], %subreg.sub1
  ; CHECK-NEXT:   [[S_LSHL_B64_:%[0-9]+]]:sreg_64 = S_LSHL_B64 killed [[REG_SEQUENCE]], 2, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_ADD_CO_U32_e64_:%[0-9]+]]:vgpr_32, [[V_ADD_CO_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_ADD_CO_U32_e64 [[COPY3]], [[S_LSHL_B64_]].sub0, 0, implicit $exec
  ; CHECK-NEXT:   %50:vgpr_32, dead $sgpr_null = V_ADDC_U32_e64 killed [[S_LSHL_B64_]].sub1, [[COPY2]], killed [[V_ADD_CO_U32_e64_1]], 0, implicit $exec
  ; CHECK-NEXT:   [[REG_SEQUENCE1:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[V_ADD_CO_U32_e64_]], %subreg.sub0, killed %50, %subreg.sub1
  ; CHECK-NEXT:   [[GLOBAL_LOAD_DWORD:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD killed [[REG_SEQUENCE1]], 0, 0, implicit $exec :: (load (s32) from %ir.a.plus.i, addrspace 1)
  ; CHECK-NEXT:   [[V_CMP_EQ_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_EQ_U32_e64 0, killed [[GLOBAL_LOAD_DWORD]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.6, killed [[V_CMP_EQ_U32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.loop.cond:
  ; CHECK-NEXT:   successors: %bb.6(0x04000000), %bb.2(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = S_ADD_I32 [[PHI]], 1, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_CMP_LT_I32_e64_:%[0-9]+]]:sreg_32 = V_CMP_LT_I32_e64 killed [[PHI]], [[COPY4]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.6, killed [[V_CMP_LT_I32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.block.after.loop:
  ; CHECK-NEXT:   successors: %bb.5(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[REG_SEQUENCE2:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY1]], %subreg.sub0, killed [[COPY]], %subreg.sub1
  ; CHECK-NEXT:   [[V_MOV_B32_e32_:%[0-9]+]]:vgpr_32 = V_MOV_B32_e32 5, implicit $exec
  ; CHECK-NEXT:   FLAT_STORE_DWORD killed [[REG_SEQUENCE2]], killed [[V_MOV_B32_e32_]], 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %ir.addr)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.5.exit:
  ; CHECK-NEXT:   SI_RETURN
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.6.loop.exit.guard:
  ; CHECK-NEXT:   successors: %bb.5(0x40000000), %bb.4(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:vgpr_32 = PHI [[V_CNDMASK_B32_e64_]], %bb.2, [[V_CNDMASK_B32_e64_1]], %bb.3
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_1:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 0, killed [[PHI1]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.5, killed [[V_CMP_NE_U32_e64_1]]
  ; CHECK-NEXT:   S_BRANCH %bb.4
entry:
  %start.cond = icmp eq i32 %num.elts, 0
  br i1 %start.cond, label %loop.start, label %block.after.loop

loop.start:
  %i = phi i32 [ 0, %entry ], [ %i.plus.1, %loop.cond ]
  %a.plus.i = getelementptr i32, ptr addrspace(1) %a, i32 %i
  %elt.i = load i32, ptr addrspace(1) %a.plus.i
  %elt.i.eq.zero = icmp eq i32 %elt.i, 0
  br i1 %elt.i.eq.zero, label %exit, label %loop.cond

loop.cond:
  %cond = icmp slt i32 %i, %num.elts
  %i.plus.1 = add i32 %i, 1
  br i1 %cond, label %block.after.loop, label %loop.start

block.after.loop:
  store i32 5, ptr %addr
  br label %exit

exit:
  ret void
}


;void icmp(int num_elts, int* a, int* addr) {
;for(;;) {
;  if(a[i]==0)
;    return;
;}
;addr[0] = 5
;return;
;}

define void @divergent_i1_icmp_used_outside_loop(i32 %v0, i32 %v1, ptr addrspace(1) %a, ptr addrspace(1) %b, ptr addrspace(1) %c, ptr %addr) {
  ; CHECK-LABEL: name: divergent_i1_icmp_used_outside_loop
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr6, $vgpr7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr7
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY killed $vgpr6
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed $vgpr3
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed $vgpr2
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vgpr_32 = COPY killed $vgpr1
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:vgpr_32 = COPY killed $vgpr0
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY1]], %subreg.sub0, killed [[COPY]], %subreg.sub1
  ; CHECK-NEXT:   [[REG_SEQUENCE1:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY3]], %subreg.sub0, killed [[COPY2]], %subreg.sub1
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32 = S_MOV_B32 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop.start:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_]], %bb.0, %2, %bb.6
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.cond.block.0:
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.4(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 [[PHI]], [[COPY5]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.4, killed [[V_CMP_NE_U32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.if.block.0:
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[S_ASHR_I32_:%[0-9]+]]:sreg_32_xm0 = S_ASHR_I32 [[PHI]], 31, implicit-def dead $scc
  ; CHECK-NEXT:   [[REG_SEQUENCE2:%[0-9]+]]:sreg_64 = REG_SEQUENCE [[PHI]], %subreg.sub0, killed [[S_ASHR_I32_]], %subreg.sub1
  ; CHECK-NEXT:   [[S_LSHL_B64_:%[0-9]+]]:sreg_64 = S_LSHL_B64 killed [[REG_SEQUENCE2]], 2, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_ADD_CO_U32_e64_:%[0-9]+]]:vgpr_32, [[V_ADD_CO_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_ADD_CO_U32_e64 [[REG_SEQUENCE1]].sub0, [[S_LSHL_B64_]].sub0, 0, implicit $exec
  ; CHECK-NEXT:   %53:vgpr_32, dead $sgpr_null = V_ADDC_U32_e64 killed [[S_LSHL_B64_]].sub1, [[REG_SEQUENCE1]].sub1, killed [[V_ADD_CO_U32_e64_1]], 0, implicit $exec
  ; CHECK-NEXT:   [[REG_SEQUENCE3:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[V_ADD_CO_U32_e64_]], %subreg.sub0, killed %53, %subreg.sub1
  ; CHECK-NEXT:   [[COPY6:%[0-9]+]]:vgpr_32 = COPY [[PHI]]
  ; CHECK-NEXT:   GLOBAL_STORE_DWORD killed [[REG_SEQUENCE3]], killed [[COPY6]], 0, 0, implicit $exec :: (store (s32) into %ir.a.plus.i, addrspace 1)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.loop.break.block:
  ; CHECK-NEXT:   successors: %bb.5(0x04000000), %bb.6(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_CMP_EQ_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_EQ_U32_e64 [[PHI]], [[COPY4]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND_Z %bb.6, killed [[V_CMP_EQ_U32_e64_]]
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.5:
  ; CHECK-NEXT:   successors: %bb.7(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY7:%[0-9]+]]:vgpr_32 = COPY [[PHI]], implicit $exec
  ; CHECK-NEXT:   S_BRANCH %bb.7
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.6.loop.cond:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = S_ADD_I32 killed [[PHI]], 1, implicit-def dead $scc
  ; CHECK-NEXT:   S_BRANCH %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.7.cond.block.1:
  ; CHECK-NEXT:   successors: %bb.8(0x40000000), %bb.9(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_CMP_EQ_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_EQ_U32_e64 killed [[PHI]], killed [[COPY5]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[V_CMP_EQ_U32_e64_1]], implicit $exec
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_NE_U32_e64 0, killed [[V_CNDMASK_B32_e64_]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_1:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, 1, killed [[V_CMP_NE_U32_e64_1]], implicit $exec
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_2:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 1, killed [[V_CNDMASK_B32_e64_1]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.9, killed [[V_CMP_NE_U32_e64_2]]
  ; CHECK-NEXT:   S_BRANCH %bb.8
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.8.if.block.1:
  ; CHECK-NEXT:   successors: %bb.9(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   GLOBAL_STORE_DWORD killed [[REG_SEQUENCE]], killed [[COPY7]], 0, 0, implicit $exec :: (store (s32) into %ir.c, addrspace 1)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.9.exit:
  ; CHECK-NEXT:   SI_RETURN
entry:
  br label %loop.start

loop.start:
  %i = phi i32 [ 0, %entry ], [ %i.plus.1, %loop.cond ]
  br label %cond.block.0

cond.block.0:
  %cond.0 = icmp eq i32 %v0, %i
  br i1 %cond.0, label %if.block.0, label %loop.break.block

if.block.0:
  %a.plus.i = getelementptr i32, ptr addrspace(1) %a, i32 %i
  store i32 %i, ptr addrspace(1) %a.plus.i
  br label %loop.break.block

loop.break.block:
  %cond.1 = icmp eq i32 %v1, %i
  br i1 %cond.1, label %cond.block.1, label %loop.cond

loop.cond:
  ; no cond, infinite loop with one break
  %i.plus.1 = add i32 %i, 1
  br label %loop.start

cond.block.1:
  %cond.2 = icmp eq i32 %v0, %i
  br i1 %cond.2, label %if.block.1, label %exit

if.block.1:
  store i32 %i, ptr addrspace(1) %c
  br label %exit

exit:
  ret void
}


; bool all_eq_zero = true;
; i32 i = 0;
; do {
;   if(all_eq_zero)
;     all_eq_zero = (a[i] == 0);
;
;   i += 1;
; } while ( i < n )

; *addr = all_eq_zero ? 1.0 : 0.0;

; check that all elements in an array of size n are zero, loop has divergent
; exit condition based on array size, but zero check does not break out of the
; loop but instead skips zero check in remaining iterations
; llpc "freezes" zero check since it is (via phi) used in a conditional branch
define amdgpu_ps void @divergent_i1_freeze_used_outside_loop(i32 %n, ptr addrspace(1) %a, ptr %addr) {
  ; CHECK-LABEL: name: divergent_i1_freeze_used_outside_loop
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr4
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY killed $vgpr3
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed $vgpr2
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed $vgpr1
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vgpr_32 = COPY killed $vgpr0
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY1]], %subreg.sub0, killed [[COPY]], %subreg.sub1
  ; CHECK-NEXT:   [[REG_SEQUENCE1:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY3]], %subreg.sub0, killed [[COPY2]], %subreg.sub1
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_MOV_B32 -1
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[S_MOV_B32_]], implicit $exec
  ; CHECK-NEXT:   [[S_MOV_B32_1:%[0-9]+]]:sreg_32 = S_MOV_B32 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.loop.start:
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.3(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_1]], %bb.0, %5, %bb.3
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:vgpr_32 = PHI [[V_CNDMASK_B32_e64_]], %bb.0, %48, %bb.3
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_NE_U32_e64 0, [[PHI1]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_1:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, 1, killed [[V_CMP_NE_U32_e64_]], implicit $exec
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_1:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 1, killed [[V_CNDMASK_B32_e64_1]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.3, killed [[V_CMP_NE_U32_e64_1]]
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.is.eq.zero:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[S_ASHR_I32_:%[0-9]+]]:sreg_32_xm0 = S_ASHR_I32 [[PHI]], 31, implicit-def dead $scc
  ; CHECK-NEXT:   [[REG_SEQUENCE2:%[0-9]+]]:sreg_64 = REG_SEQUENCE [[PHI]], %subreg.sub0, killed [[S_ASHR_I32_]], %subreg.sub1
  ; CHECK-NEXT:   [[S_LSHL_B64_:%[0-9]+]]:sreg_64 = S_LSHL_B64 killed [[REG_SEQUENCE2]], 2, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_ADD_CO_U32_e64_:%[0-9]+]]:vgpr_32, [[V_ADD_CO_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_ADD_CO_U32_e64 [[REG_SEQUENCE1]].sub0, [[S_LSHL_B64_]].sub0, 0, implicit $exec
  ; CHECK-NEXT:   %52:vgpr_32, dead $sgpr_null = V_ADDC_U32_e64 killed [[S_LSHL_B64_]].sub1, [[REG_SEQUENCE1]].sub1, killed [[V_ADD_CO_U32_e64_1]], 0, implicit $exec
  ; CHECK-NEXT:   [[REG_SEQUENCE3:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[V_ADD_CO_U32_e64_]], %subreg.sub0, killed %52, %subreg.sub1
  ; CHECK-NEXT:   [[GLOBAL_LOAD_DWORD:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD killed [[REG_SEQUENCE3]], 0, 0, implicit $exec :: (load (s32) from %ir.a.plus.i, addrspace 1)
  ; CHECK-NEXT:   [[V_CMP_EQ_U32_e64_:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_EQ_U32_e64 0, killed [[GLOBAL_LOAD_DWORD]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_2:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[V_CMP_EQ_U32_e64_]], implicit $exec
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.loop.cond:
  ; CHECK-NEXT:   successors: %bb.4(0x04000000), %bb.1(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI2:%[0-9]+]]:vgpr_32 = PHI [[PHI1]], %bb.1, [[V_CNDMASK_B32_e64_2]], %bb.2
  ; CHECK-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = S_ADD_I32 [[PHI]], 1, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_CMP_GE_I32_e64_:%[0-9]+]]:sreg_32 = V_CMP_GE_I32_e64 killed [[PHI]], [[COPY4]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.1, killed [[V_CMP_GE_I32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.exit:
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_2:%[0-9]+]]:sreg_32_xm0_xexec = V_CMP_NE_U32_e64 0, killed [[PHI2]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_3:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, 1065353216, killed [[V_CMP_NE_U32_e64_2]], implicit $exec
  ; CHECK-NEXT:   FLAT_STORE_DWORD killed [[REG_SEQUENCE]], killed [[V_CNDMASK_B32_e64_3]], 0, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %ir.addr)
  ; CHECK-NEXT:   S_ENDPGM 0
entry:
  br label %loop.start

loop.start:
  %i = phi i32 [ 0, %entry ], [ %i.plus.1, %loop.cond ]
  %all.eq.zero = phi i1 [ true, %entry ], [ %eq.zero.fr, %loop.cond ]
  br i1 %all.eq.zero, label %is.eq.zero, label %loop.cond

is.eq.zero:
  %a.plus.i = getelementptr i32, ptr addrspace(1) %a, i32 %i
  %elt.i = load i32, ptr addrspace(1) %a.plus.i
  %elt.i.eq.zero = icmp eq i32 %elt.i, 0
  br label %loop.cond

loop.cond:
  %eq.zero = phi i1 [ %all.eq.zero, %loop.start ], [ %elt.i.eq.zero, %is.eq.zero ]
  %eq.zero.fr = freeze i1 %eq.zero
  %cond = icmp slt i32 %i, %n
  %i.plus.1 = add i32 %i, 1
  br i1 %cond, label %exit, label %loop.start

exit:
  %select = select i1 %eq.zero.fr, float 1.000000e+00, float 0.000000e+00
  store float %select, ptr %addr
  ret void
}

; Divergent i1 phi from structurize-cfg used outside of the loop
define amdgpu_cs void @loop_with_1break(ptr addrspace(1) %x, ptr addrspace(1) %a, ptr addrspace(1) %a.break) {
  ; CHECK-LABEL: name: loop_with_1break
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:vgpr_32 = COPY killed $vgpr5
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32 = COPY killed $vgpr4
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY killed $vgpr3
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vgpr_32 = COPY killed $vgpr2
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vgpr_32 = COPY killed $vgpr1
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:vgpr_32 = COPY killed $vgpr0
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY1]], %subreg.sub0, killed [[COPY]], %subreg.sub1
  ; CHECK-NEXT:   [[REG_SEQUENCE1:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY3]], %subreg.sub0, killed [[COPY2]], %subreg.sub1
  ; CHECK-NEXT:   [[REG_SEQUENCE2:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[COPY5]], %subreg.sub0, killed [[COPY4]], %subreg.sub1
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_MOV_B32 0
  ; CHECK-NEXT:   [[S_MOV_B32_1:%[0-9]+]]:sreg_32_xm0_xexec = S_MOV_B32 -1
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, killed [[S_MOV_B32_1]], implicit $exec
  ; CHECK-NEXT:   [[V_CNDMASK_B32_e64_1:%[0-9]+]]:vgpr_32 = V_CNDMASK_B32_e64 0, 0, 0, -1, [[S_MOV_B32_]], implicit $exec
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.A:
  ; CHECK-NEXT:   successors: %bb.5(0x04000000), %bb.3(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:sreg_32 = PHI [[S_MOV_B32_]], %bb.0, %2, %bb.3
  ; CHECK-NEXT:   [[S_ASHR_I32_:%[0-9]+]]:sreg_32_xm0 = S_ASHR_I32 [[PHI]], 31, implicit-def dead $scc
  ; CHECK-NEXT:   [[REG_SEQUENCE3:%[0-9]+]]:sreg_64 = REG_SEQUENCE killed [[PHI]], %subreg.sub0, killed [[S_ASHR_I32_]], %subreg.sub1
  ; CHECK-NEXT:   [[S_LSHL_B64_:%[0-9]+]]:sreg_64 = nsw S_LSHL_B64 [[REG_SEQUENCE3]], 2, implicit-def dead $scc
  ; CHECK-NEXT:   [[V_ADD_CO_U32_e64_:%[0-9]+]]:vgpr_32, [[V_ADD_CO_U32_e64_1:%[0-9]+]]:sreg_32_xm0_xexec = V_ADD_CO_U32_e64 [[REG_SEQUENCE1]].sub0, [[S_LSHL_B64_]].sub0, 0, implicit $exec
  ; CHECK-NEXT:   %55:vgpr_32, dead $sgpr_null = V_ADDC_U32_e64 [[S_LSHL_B64_]].sub1, [[REG_SEQUENCE1]].sub1, killed [[V_ADD_CO_U32_e64_1]], 0, implicit $exec
  ; CHECK-NEXT:   [[REG_SEQUENCE4:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[V_ADD_CO_U32_e64_]], %subreg.sub0, killed %55, %subreg.sub1
  ; CHECK-NEXT:   [[GLOBAL_LOAD_DWORD:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD killed [[REG_SEQUENCE4]], 0, 0, implicit $exec :: (load (s32) from %ir.a.plus.counter, addrspace 1)
  ; CHECK-NEXT:   [[V_CMP_EQ_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_EQ_U32_e64 0, killed [[GLOBAL_LOAD_DWORD]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.5, killed [[V_CMP_EQ_U32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.break.body:
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_MOV_B32_e32_:%[0-9]+]]:vgpr_32 = V_MOV_B32_e32 10, implicit $exec
  ; CHECK-NEXT:   GLOBAL_STORE_DWORD killed [[REG_SEQUENCE]], killed [[V_MOV_B32_e32_]], 0, 0, implicit $exec :: (store (s32) into %ir.a.break, addrspace 1)
  ; CHECK-NEXT:   S_BRANCH %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.loop.body:
  ; CHECK-NEXT:   successors: %bb.5(0x04000000), %bb.1(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_ADD_CO_U32_e64_2:%[0-9]+]]:vgpr_32, [[V_ADD_CO_U32_e64_3:%[0-9]+]]:sreg_32_xm0_xexec = V_ADD_CO_U32_e64 [[REG_SEQUENCE2]].sub0, [[S_LSHL_B64_]].sub0, 0, implicit $exec
  ; CHECK-NEXT:   %63:vgpr_32, dead $sgpr_null = V_ADDC_U32_e64 killed [[S_LSHL_B64_]].sub1, [[REG_SEQUENCE2]].sub1, killed [[V_ADD_CO_U32_e64_3]], 0, implicit $exec
  ; CHECK-NEXT:   [[REG_SEQUENCE5:%[0-9]+]]:vreg_64 = REG_SEQUENCE killed [[V_ADD_CO_U32_e64_2]], %subreg.sub0, killed %63, %subreg.sub1
  ; CHECK-NEXT:   [[GLOBAL_LOAD_DWORD1:%[0-9]+]]:vgpr_32 = GLOBAL_LOAD_DWORD [[REG_SEQUENCE5]], 0, 0, implicit $exec :: (load (s32) from %ir.x.plus.counter, addrspace 1)
  ; CHECK-NEXT:   [[V_ADD_U32_e64_:%[0-9]+]]:vgpr_32 = V_ADD_U32_e64 1, killed [[GLOBAL_LOAD_DWORD1]], 0, implicit $exec
  ; CHECK-NEXT:   GLOBAL_STORE_DWORD killed [[REG_SEQUENCE5]], killed [[V_ADD_U32_e64_]], 0, 0, implicit $exec :: (store (s32) into %ir.x.plus.counter, addrspace 1)
  ; CHECK-NEXT:   [[S_ADD_I32_:%[0-9]+]]:sreg_32 = S_ADD_I32 [[REG_SEQUENCE3]].sub0, 1, implicit-def dead $scc
  ; CHECK-NEXT:   S_CMP_LT_U32 killed [[REG_SEQUENCE3]].sub0, 100, implicit-def $scc
  ; CHECK-NEXT:   [[S_CSELECT_B32_:%[0-9]+]]:sreg_32_xm0_xexec = S_CSELECT_B32 -1, 0, implicit killed $scc
  ; CHECK-NEXT:   SI_BRCOND_UNIFORM %bb.5, killed [[S_CSELECT_B32_]]
  ; CHECK-NEXT:   S_BRANCH %bb.1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.exit:
  ; CHECK-NEXT:   S_ENDPGM 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.5.loop.exit.guard:
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.4(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:vgpr_32 = PHI [[V_CNDMASK_B32_e64_]], %bb.1, [[V_CNDMASK_B32_e64_1]], %bb.3
  ; CHECK-NEXT:   [[V_CMP_NE_U32_e64_:%[0-9]+]]:sreg_32 = V_CMP_NE_U32_e64 0, killed [[PHI1]], implicit $exec
  ; CHECK-NEXT:   SI_BRCOND %bb.2, killed [[V_CMP_NE_U32_e64_]]
  ; CHECK-NEXT:   S_BRANCH %bb.4
entry:
  br label %A

A:
  %counter = phi i32 [ %counter.plus.1, %loop.body ], [ 0, %entry ]
  %a.plus.counter = getelementptr inbounds i32, ptr addrspace(1) %a, i32 %counter
  %a.val = load i32, ptr addrspace(1) %a.plus.counter
  %a.cond = icmp eq i32 %a.val, 0
  br i1 %a.cond, label %break.body, label %loop.body

break.body:
  store i32 10, ptr addrspace(1) %a.break
  br label %exit

loop.body:
  %x.plus.counter = getelementptr inbounds i32, ptr addrspace(1) %x, i32 %counter
  %x.val = load i32, ptr addrspace(1) %x.plus.counter
  %x.val.plus.1 = add i32 %x.val, 1
  store i32 %x.val.plus.1, ptr addrspace(1) %x.plus.counter
  %counter.plus.1 = add i32 %counter, 1
  %x.cond = icmp ult i32 %counter, 100
  br i1 %x.cond, label %exit, label %A

exit:
  ret void
}

