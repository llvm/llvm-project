# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc -mtriple=amdgcn -mcpu=gfx942 -run-pass=si-fix-sgpr-copies -o - %s | FileCheck --check-prefix=GCN %s
--- |
  source_filename = "test1.ll"
  target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-p7:160:256:256:32-p8:128:128-p9:192:256:256:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7:8:9"
  target triple = "amdgcn"

  define amdgpu_kernel void @test_should_convert_to_v_readfirstlane_b32(float %fval, i32 %arg1, i32 %arg2, ptr addrspace(4) %out) #0 {
  entry:
    %test_should_convert_to_v_readfirstlane_b32.kernarg.segment = call nonnull align 16 dereferenceable(280) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
    %fval.kernarg.offset = getelementptr inbounds i8, ptr addrspace(4) %test_should_convert_to_v_readfirstlane_b32.kernarg.segment, i64 36, !amdgpu.uniform !0
    %0 = load <3 x i32>, ptr addrspace(4) %fval.kernarg.offset, align 4, !invariant.load !0
    %fval.load1 = extractelement <3 x i32> %0, i32 0
    %1 = bitcast i32 %fval.load1 to float
    %arg1.load2 = extractelement <3 x i32> %0, i32 1
    %arg2.load3 = extractelement <3 x i32> %0, i32 2
    %conv = fptoui float %1 to i32
    %shl = shl i32 %conv, 16
    %or = or i32 %shl, %arg1.load2
    %and = and i32 %or, %arg2.load3
    %shr = lshr i32 %and, 2
    %sgpr128_0 = insertelement <4 x i32> undef, i32 %shr, i32 0
    %sgpr128_1 = insertelement <4 x i32> %sgpr128_0, i32 %or, i32 1
    %sgpr128_2 = insertelement <4 x i32> %sgpr128_1, i32 %and, i32 2
    %sgpr128_3 = insertelement <4 x i32> %sgpr128_2, i32 %shr, i32 3
    call void @llvm.amdgcn.raw.buffer.store.i32(i32 %arg1.load2, <4 x i32> %sgpr128_3, i32 0, i32 0, i32 2)
    ret void
  }

  declare void @llvm.amdgcn.raw.buffer.store.i32(i32, <4 x i32>, i32, i32, i32 immarg) #1

  declare noundef align 4 ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr() #2

  attributes #0 = { "target-cpu"="gfx942" }
  attributes #1 = { nocallback nofree nosync nounwind willreturn memory(write) "target-cpu"="gfx942" }
  attributes #2 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }

  !0 = !{}
...
---
name:            test_should_convert_to_v_readfirstlane_b32
alignment:       1
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
noPhis:          false
isSSA:           true
noVRegs:         false
hasFakeUses:     false
callsEHReturn:   false
callsUnwindInit: false
hasEHContTarget: false
hasEHScopes:     false
hasEHFunclets:   false
isOutlined:      false
debugInstrRef:   false
failsVerification: false
tracksDebugUserValues: false
registers:
  - { id: 0, class: vgpr_32, preferred-register: '', flags: [  ] }
  - { id: 1, class: sgpr_64, preferred-register: '', flags: [  ] }
  - { id: 2, class: sgpr_64, preferred-register: '', flags: [  ] }
  - { id: 3, class: sgpr_64, preferred-register: '', flags: [  ] }
  - { id: 4, class: sgpr_64, preferred-register: '', flags: [  ] }
  - { id: 5, class: sgpr_32, preferred-register: '', flags: [  ] }
  - { id: 6, class: sgpr_32, preferred-register: '', flags: [  ] }
  - { id: 7, class: sgpr_32, preferred-register: '', flags: [  ] }
  - { id: 8, class: sgpr_128, preferred-register: '', flags: [  ] }
  - { id: 9, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 10, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 11, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 12, class: vgpr_32, preferred-register: '', flags: [  ] }
  - { id: 13, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 14, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 15, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 16, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 17, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 18, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 19, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 20, class: sgpr_128, preferred-register: '', flags: [  ] }
  - { id: 21, class: sreg_32, preferred-register: '', flags: [  ] }
  - { id: 22, class: vgpr_32, preferred-register: '', flags: [  ] }
liveins:
  - { reg: '$sgpr4_sgpr5', virtual-reg: '%3' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  functionContext: ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  hasTailCall:     false
  isCalleeSavedInfoValid: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
entry_values:    []
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo:
  explicitKernArgSize: 24
  maxKernArgAlign: 8
  ldsSize:         0
  gdsSize:         0
  dynLDSAlign:     1
  isEntryFunction: true
  isChainFunction: false
  noSignedZerosFPMath: false
  memoryBound:     false
  waveLimiter:     false
  hasSpilledSGPRs: false
  hasSpilledVGPRs: false
  scratchRSrcReg:  '$private_rsrc_reg'
  frameOffsetReg:  '$fp_reg'
  stackPtrOffsetReg: '$sp_reg'
  bytesInStackArgArea: 0
  returnsVoid:     true
  argumentInfo:
    dispatchPtr:     { reg: '$sgpr0_sgpr1' }
    queuePtr:        { reg: '$sgpr2_sgpr3' }
    kernargSegmentPtr: { reg: '$sgpr4_sgpr5' }
    dispatchID:      { reg: '$sgpr6_sgpr7' }
    workGroupIDX:    { reg: '$sgpr8' }
    workGroupIDY:    { reg: '$sgpr9' }
    workGroupIDZ:    { reg: '$sgpr10' }
    workItemIDX:     { reg: '$vgpr0', mask: 1023 }
    workItemIDY:     { reg: '$vgpr0', mask: 1047552 }
    workItemIDZ:     { reg: '$vgpr0', mask: 1072693248 }
  psInputAddr:     0
  psInputEnable:   0
  maxMemoryClusterDWords: 8
  mode:
    ieee:            true
    dx10-clamp:      true
    fp32-input-denormals: true
    fp32-output-denormals: true
    fp64-fp16-input-denormals: true
    fp64-fp16-output-denormals: true
  highBitsOf32BitAddress: 0
  occupancy:       8
  vgprForAGPRCopy: ''
  sgprForEXECCopy: ''
  longBranchReservedReg: ''
  hasInitWholeWave: false
body:             |
  bb.0.entry:
    liveins: $sgpr4_sgpr5

    ; GCN-LABEL: name: test_should_convert_to_v_readfirstlane_b32
    ; GCN: liveins: $sgpr4_sgpr5
    ; GCN-NEXT: {{  $}}
    ; GCN-NEXT: [[COPY:%[0-9]+]]:sgpr_64(p4) = COPY $sgpr4_sgpr5
    ; GCN-NEXT: early-clobber %8:sgpr_128 = S_LOAD_DWORDX4_IMM_ec [[COPY]](p4), 36, 0 :: (dereferenceable invariant load (s128) from %ir.fval.kernarg.offset, align 4, addrspace 4)
    ; GCN-NEXT: [[COPY1:%[0-9]+]]:sreg_32 = COPY %8.sub2
    ; GCN-NEXT: [[COPY2:%[0-9]+]]:sreg_32 = COPY %8.sub1
    ; GCN-NEXT: [[COPY3:%[0-9]+]]:sreg_32 = COPY %8.sub0
    ; GCN-NEXT: [[V_CVT_U32_F32_e64_:%[0-9]+]]:vgpr_32 = nofpexcept V_CVT_U32_F32_e64 0, killed [[COPY3]], 0, 0, implicit $mode, implicit $exec
    ; GCN-NEXT: [[S_MOV_B32_:%[0-9]+]]:sreg_32 = S_MOV_B32 16
    ; GCN-NEXT: [[V_READFIRSTLANE_B32_:%[0-9]+]]:sreg_32_xm0 = V_READFIRSTLANE_B32 [[V_CVT_U32_F32_e64_]], implicit $exec
    ; GCN-NEXT: [[S_LSHL_B32_:%[0-9]+]]:sreg_32 = S_LSHL_B32 killed [[V_READFIRSTLANE_B32_]], killed [[S_MOV_B32_]], implicit-def dead $scc
    ; GCN-NEXT: [[S_OR_B32_:%[0-9]+]]:sreg_32 = S_OR_B32 killed [[S_LSHL_B32_]], [[COPY2]], implicit-def dead $scc
    ; GCN-NEXT: [[S_AND_B32_:%[0-9]+]]:sreg_32 = S_AND_B32 [[S_OR_B32_]], killed [[COPY1]], implicit-def dead $scc
    ; GCN-NEXT: [[S_MOV_B32_1:%[0-9]+]]:sreg_32 = S_MOV_B32 2
    ; GCN-NEXT: [[S_LSHR_B32_:%[0-9]+]]:sreg_32 = S_LSHR_B32 [[S_AND_B32_]], killed [[S_MOV_B32_1]], implicit-def dead $scc
    ; GCN-NEXT: [[REG_SEQUENCE:%[0-9]+]]:sgpr_128 = REG_SEQUENCE [[S_LSHR_B32_]], %subreg.sub0, [[S_OR_B32_]], %subreg.sub1, [[S_AND_B32_]], %subreg.sub2, [[S_LSHR_B32_]], %subreg.sub3
    ; GCN-NEXT: [[S_MOV_B32_2:%[0-9]+]]:sreg_32 = S_MOV_B32 0
    ; GCN-NEXT: [[COPY4:%[0-9]+]]:vgpr_32 = COPY [[COPY2]]
    ; GCN-NEXT: BUFFER_STORE_DWORD_OFFSET_exact [[COPY4]], killed [[REG_SEQUENCE]], killed [[S_MOV_B32_2]], 0, 2, 0, implicit $exec :: (dereferenceable store (s32), align 1, addrspace 8)
    ; GCN-NEXT: S_ENDPGM 0
    %3:sgpr_64(p4) = COPY $sgpr4_sgpr5
    early-clobber %8:sgpr_128 = S_LOAD_DWORDX4_IMM_ec %3(p4), 36, 0 :: (dereferenceable invariant load (s128) from %ir.fval.kernarg.offset, align 4, addrspace 4)
    %9:sreg_32 = COPY %8.sub2
    %10:sreg_32 = COPY %8.sub1
    %11:sreg_32 = COPY %8.sub0
    %12:vgpr_32 = nofpexcept V_CVT_U32_F32_e64 0, killed %11, 0, 0, implicit $mode, implicit $exec
    %13:sreg_32 = S_MOV_B32 16
    %15:sreg_32 = COPY %12
    %14:sreg_32 = S_LSHL_B32 killed %15, killed %13, implicit-def dead $scc
    %16:sreg_32 = S_OR_B32 killed %14, %10, implicit-def dead $scc
    %17:sreg_32 = S_AND_B32 %16, killed %9, implicit-def dead $scc
    %18:sreg_32 = S_MOV_B32 2
    %19:sreg_32 = S_LSHR_B32 %17, killed %18, implicit-def dead $scc
    %20:sgpr_128 = REG_SEQUENCE %19, %subreg.sub0, %16, %subreg.sub1, %17, %subreg.sub2, %19, %subreg.sub3
    %21:sreg_32 = S_MOV_B32 0
    %22:vgpr_32 = COPY %10
    BUFFER_STORE_DWORD_OFFSET_exact %22, killed %20, killed %21, 0, 2, 0, implicit $exec :: (dereferenceable store (s32), align 1, addrspace 8)
    S_ENDPGM 0
...
