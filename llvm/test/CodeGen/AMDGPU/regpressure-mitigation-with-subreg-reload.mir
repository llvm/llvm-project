# RUN: not llc -mcpu=gfx1100 -mtriple=amdgcn-amd-amdhsa -stress-regalloc=4 -run-pass=greedy -filetype=null %s 2>&1 | FileCheck %s

# This test demonstrates register pressure mitigation through subreg-aware
# reloads during register allocation. Currently, the test would fail during
# RA due to insufficient registers. Subreg-aware reload, when implemented,
# mitigates register pressure by reloading only the used portions of tuple
# registers from their spilled locations instead of reloading entire tuples,
# thereby enhancing register allocation.

# CHECK: error: <unknown>:0:0: ran out of registers during register allocation

---
name:            subreg-reload
tracksRegLiveness: true
machineFunctionInfo:
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
body:             |
  bb.0:
    liveins: $vgpr1, $sgpr0_sgpr1, $sgpr2_sgpr3

    %1:vgpr_32 = COPY $vgpr1
    %2:vreg_64 = COPY killed renamable $sgpr0_sgpr1
    %3:vreg_128 = FLAT_LOAD_DWORDX4 %2, 0, 0, implicit $exec, implicit $flat_scr
    undef early-clobber %4.sub0_sub1:vreg_128, $sgpr_null = V_MAD_U64_U32_gfx11_e64 %3.sub0, 42, 0, 0, implicit $exec
    undef %5.sub0:vreg_64 = COPY %4.sub1
    early-clobber %4.sub1_sub2:vreg_128, $sgpr_null = V_MAD_U64_U32_gfx11_e64 %3.sub1, 42, %5, 0, implicit $exec
    early-clobber %6:vreg_64, $sgpr_null = V_MAD_U64_U32_gfx11_e64 %3.sub2, 42, 0, 0, implicit $exec
    undef %7.sub0:vreg_64 = COPY %6.sub1
    early-clobber %8:vreg_64, $sgpr_null = V_MAD_U64_U32_gfx11_e64 %3.sub3, 42, %7, 0, implicit $exec
    %4.sub2:vreg_128 = COPY %6.sub0
    %4.sub3:vreg_128 = COPY %8.sub0
    $vgpr31 = COPY %1
    INLINEASM &"; use v1", 1, 327690, $vgpr1
    FLAT_STORE_DWORDX4 %2, %4, 0, 0, implicit $exec, implicit $flat_scr
    SI_RETURN
...
