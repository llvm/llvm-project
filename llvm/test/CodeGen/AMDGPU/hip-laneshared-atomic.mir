# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# REQUIRES: asserts
# RUN: llc -mtriple=amdgcn -mcpu=gfx1300 -verify-machineinstrs -run-pass=si-memory-legalizer -o - %s | FileCheck %s

---
name:            _Z3fooiiii
tracksRegLiveness: true
machineFunctionInfo:
  occupancy:       16
body:             |
  bb.0.entry:
    liveins: $sgpr2_sgpr3

    ; CHECK-LABEL: name: _Z3fooiiii
    ; CHECK: liveins: $sgpr2_sgpr3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: $sgpr0_sgpr1 = S_LOAD_DWORDX2_IMM killed renamable $sgpr2_sgpr3, 36, 0 :: (dereferenceable invariant load (s64), addrspace 4)
    ; CHECK-NEXT: $sgpr33 = S_MOV_B32 0
    ; CHECK-NEXT: $sgpr2 = S_LOAD_DWORD_IMM renamable $sgpr0_sgpr1, 0, 0 :: ("amdgpu-noclobber" load (s32), addrspace 1)
    ; CHECK-NEXT: $vgpr0, $vgpr1 = V_DUAL_MOV_B32_e32_X_MOV_B32_e32_gfx1250 0, killed $sgpr2, implicit $exec, implicit $exec, implicit $exec, implicit $exec
    ; CHECK-NEXT: $sgpr2 = S_MOV_B32 0
    ; CHECK-NEXT: $idx1 = S_SET_GPR_IDX_U32 killed renamable $sgpr2
    ; CHECK-NEXT: S_WAIT_BVHCNT_soft 0
    ; CHECK-NEXT: S_WAIT_SAMPLECNT_soft 0
    ; CHECK-NEXT: S_WAIT_LOADCNT_soft 0
    ; CHECK-NEXT: S_WAIT_STORECNT_soft 0
    ; CHECK-NEXT: S_WAIT_DSCNT_soft 0
    ; CHECK-NEXT: $vgpr0, $vgpr1 = BUNDLE {
    ; CHECK-NEXT:   $vgpr1 = GLOBAL_ATOMIC_INC_SADDR_RTN renamable $vgpr0, killed renamable $vgpr1, renamable $sgpr0_sgpr1, 0, 1, implicit $exec :: (load store syncscope("workgroup") seq_cst (s32), addrspace 1)
    ; CHECK-NEXT:   V_STORE_IDX killed $vgpr1, $idx1, 0, implicit $exec :: (store (s32), addrspace 10)
    ; CHECK-NEXT: }
    ; CHECK-NEXT: S_WAIT_STORECNT_soft 0
    ; CHECK-NEXT: S_WAIT_BVHCNT_soft 0
    ; CHECK-NEXT: S_WAIT_SAMPLECNT_soft 0
    ; CHECK-NEXT: S_WAIT_LOADCNT_soft 0
    ; CHECK-NEXT: S_WAIT_STORECNT_soft 0
    ; CHECK-NEXT: S_WAIT_DSCNT_soft 0
    ; CHECK-NEXT: S_WAIT_BVHCNT_soft 0
    ; CHECK-NEXT: S_WAIT_SAMPLECNT_soft 0
    ; CHECK-NEXT: S_WAIT_LOADCNT_soft 0
    ; CHECK-NEXT: S_WAIT_STORECNT_soft 0
    ; CHECK-NEXT: S_WAIT_DSCNT_soft 0
    ; CHECK-NEXT: $vgpr0, $vgpr1 = BUNDLE {
    ; CHECK-NEXT:   $vgpr1 = V_LOAD_IDX $idx1, 0, implicit $exec :: (dereferenceable load (s32), addrspace 10)
    ; CHECK-NEXT:   $vgpr0 = GLOBAL_ATOMIC_DEC_SADDR_RTN killed renamable $vgpr0, killed renamable $vgpr1, killed renamable $sgpr0_sgpr1, 0, 1, implicit $exec :: (load store syncscope("workgroup") seq_cst (s32), addrspace 1)
    ; CHECK-NEXT:   V_STORE_IDX killed $vgpr0, killed $idx1, 0, implicit $exec :: (store (s32), addrspace 10)
    ; CHECK-NEXT: }
    ; CHECK-NEXT: S_WAIT_STORECNT_soft 0
    ; CHECK-NEXT: S_ENDPGM 0
    $sgpr0_sgpr1 = S_LOAD_DWORDX2_IMM killed renamable $sgpr2_sgpr3, 36, 0 :: (dereferenceable invariant load (s64), addrspace 4)
    $sgpr33 = S_MOV_B32 0
    $sgpr2 = S_LOAD_DWORD_IMM renamable $sgpr0_sgpr1, 0, 0 :: ("amdgpu-noclobber" load (s32), addrspace 1)
    $vgpr0, $vgpr1 = V_DUAL_MOV_B32_e32_X_MOV_B32_e32_gfx1250 0, killed $sgpr2, implicit $exec, implicit $exec, implicit $exec, implicit $exec
    $sgpr2 = S_MOV_B32 0
    $idx1 = S_SET_GPR_IDX_U32 killed renamable $sgpr2
    $vgpr0, $vgpr1 = BUNDLE {
    $vgpr1 = GLOBAL_ATOMIC_INC_SADDR_RTN renamable $vgpr0, killed renamable $vgpr1, renamable $sgpr0_sgpr1, 0, 1, implicit $exec :: (load store syncscope("workgroup") seq_cst (s32), addrspace 1)
    V_STORE_IDX killed $vgpr1, $idx1, 0, implicit $exec :: (store (s32), addrspace 10)
    }
    ATOMIC_FENCE 7, 2
    $vgpr0, $vgpr1 = BUNDLE {
    $vgpr1 = V_LOAD_IDX $idx1, 0, implicit $exec :: (dereferenceable load (s32), addrspace 10)
    $vgpr0 = GLOBAL_ATOMIC_DEC_SADDR_RTN killed renamable $vgpr0, killed renamable $vgpr1, killed renamable $sgpr0_sgpr1, 0, 1, implicit $exec :: (load store syncscope("workgroup") seq_cst (s32), addrspace 1)
    V_STORE_IDX killed $vgpr0, killed $idx1, 0, implicit $exec :: (store (s32), addrspace 10)
    }
    S_ENDPGM 0
