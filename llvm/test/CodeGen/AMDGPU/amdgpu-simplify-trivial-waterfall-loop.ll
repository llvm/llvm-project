; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5

; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -passes="default<O1>" -S < %s | FileCheck %s --check-prefixes=GFX,GFX10
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1100 -passes="default<O1>" -S < %s | FileCheck %s --check-prefixes=GFX,GFX11
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1200 -passes="default<O1>" -S < %s | FileCheck %s --check-prefixes=GFX,GFX12

define amdgpu_kernel void @trivial_waterfall_loop(ptr addrspace(1) %out, i32 %src) {
; CHECK-LABEL: define amdgpu_kernel void @trivial_waterfall_loop(
; CHECK:       store i32 %src, ptr addrspace(1) %out, align 4
; CHECK-NOT:   br label %loop
; GFX-LABEL: define amdgpu_kernel void @trivial_waterfall_loop(
; GFX-SAME: ptr addrspace(1) nocapture writeonly [[OUT:%.*]], i32 [[SRC:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; GFX-NEXT:  [[ENTRY:.*:]]
; GFX-NEXT:    store i32 [[SRC]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
entry:
  ; Initialize result to zero
  %result = alloca i32, align 4
  store i32 0, ptr %result, align 4
  br label %loop

loop:
  ; Load the current result
  %cur_result = load i32, ptr %result, align 4

  ; Compute the next value
  %next_value = add i32 %cur_result, %src

  ; Apply the readfirstlane intrinsic for uniformity
  %uniform_value = call i32 @llvm.amdgcn.readfirstlane(i32 %next_value)

  ; Store the uniform result back
  store i32 %uniform_value, ptr %result, align 4

  ; This is a trivial loop that always exits after one iteration
  br i1 true, label %exit, label %loop

exit:
  ; Store the result to the output pointer
  %final_result = load i32, ptr %result, align 4
  store i32 %final_result, ptr addrspace(1) %out, align 4
  ret void
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; GFX10: {{.*}}
; GFX11: {{.*}}
; GFX12: {{.*}}
