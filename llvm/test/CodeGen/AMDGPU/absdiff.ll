; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=amdgcn-amd-amdpal -mcpu=gfx900 < %s | FileCheck %s


define amdgpu_gs float @absdiff_valu_input_regression() {
; CHECK-LABEL: absdiff_valu_input_regression:
; CHECK:       ; %bb.0: ; %bb
; CHECK-NEXT:    s_mov_b32 s0, 0
; CHECK-NEXT:  .LBB0_1: ; %bb1
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    s_mov_b32 s1, s0
; CHECK-NEXT:    s_or_b32 s0, s0, 1
; CHECK-NEXT:    s_cmp_gt_i32 s1, 0
; CHECK-NEXT:    s_cbranch_scc1 .LBB0_1
; CHECK-NEXT:  ; %bb.2: ; %bb11
; CHECK-NEXT:    v_med3_i32 v0, s1, 0, 1
; CHECK-NEXT:    v_sub_u32_e32 v0, 0, v0
; CHECK-NEXT:    v_sub_u32_e32 v1, 0, v0
; CHECK-NEXT:    v_max_i32_e32 v0, v0, v1
; CHECK-NEXT:    ; return to shader part epilog
bb:
  br label %bb1

bb1:                                              ; preds = %bb1, %bb
  %i = phi i32 [ 0, %bb ], [ %i9, %bb1 ]
  %i2 = phi i32 [ 0, %bb ], [ %i5, %bb1 ]
  %i3 = or i32 %i2, 1
  %i4 = or i32 %i3, 0
  %i5 = call i32 @llvm.smax.i32(i32 %i, i32 0)
  %i6 = call i32 @llvm.umin.i32(i32 %i5, i32 1)
  %i7 = sub i32 0, %i6
  %i8 = call i32 @llvm.abs.i32(i32 %i7, i1 false)
  %i9 = or i32 %i, 1
  %i10 = icmp sgt i32 %i, 0
  br i1 %i10, label %bb1, label %bb11

bb11:                                             ; preds = %bb1
  %i12 = bitcast i32 %i8 to float
  ret float %i12
}

define amdgpu_ps i16 @absdiff_i16_false(i16 inreg %arg0, i16 inreg %arg1) {
; CHECK-LABEL: absdiff_i16_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_sub_i32 s0, s0, s1
; CHECK-NEXT:    s_sext_i32_i16 s1, s0
; CHECK-NEXT:    s_sub_i32 s0, 0, s0
; CHECK-NEXT:    s_sext_i32_i16 s0, s0
; CHECK-NEXT:    s_max_i32 s0, s1, s0
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i16 %arg0, %arg1
  %res = call i16 @llvm.abs.i16(i16 %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret i16 %res
}

define amdgpu_ps i16 @absdiff_i16_true(i16 inreg %arg0, i16 inreg %arg1) {
; CHECK-LABEL: absdiff_i16_true:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_sub_i32 s0, s0, s1
; CHECK-NEXT:    s_sext_i32_i16 s1, s0
; CHECK-NEXT:    s_sub_i32 s0, 0, s0
; CHECK-NEXT:    s_sext_i32_i16 s0, s0
; CHECK-NEXT:    s_max_i32 s0, s1, s0
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i16 %arg0, %arg1
  %res = call i16 @llvm.abs.i16(i16 %diff, i1 true) ; INT_MIN input returns poison
  ret i16 %res
}

define amdgpu_ps i32 @absdiff_i32_false(i32 inreg %arg0, i32 inreg %arg1) {
; CHECK-LABEL: absdiff_i32_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_absdiff_i32 s0, s0, s1
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i32 %arg0, %arg1
  %res = call i32 @llvm.abs.i32(i32 %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret i32 %res
}

define amdgpu_ps i32 @absdiff_i32_true(i32 inreg %arg0, i32 inreg %arg1) {
; CHECK-LABEL: absdiff_i32_true:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_absdiff_i32 s0, s0, s1
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i32 %arg0, %arg1
  %res = call i32 @llvm.abs.i32(i32 %diff, i1 true) ; INT_MIN input returns poison
  ret i32 %res
}

; Multiple uses of %diff.  No benefit for using s_absdiff_i32.
define amdgpu_ps i32 @absdiff_i32_false_multi_use(i32 inreg %arg0, i32 inreg %arg1) {
; CHECK-LABEL: absdiff_i32_false_multi_use:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_sub_i32 s1, s0, s1
; CHECK-NEXT:    s_abs_i32 s0, s1
; CHECK-NEXT:    ;;#ASMSTART
; CHECK-NEXT:    ; use s1
; CHECK-NEXT:    ;;#ASMEND
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i32 %arg0, %arg1
  %res = call i32 @llvm.abs.i32(i32 %diff, i1 false) ; INT_MIN input returns INT_MIN
  call void asm "; use $0", "s"(i32 %diff)
  ret i32 %res
}

define <2 x i32> @absdiff_2xi32_false(<2 x i32> %arg0, <2 x i32> %arg1) {
; CHECK-LABEL: absdiff_2xi32_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_sub_u32_e32 v0, v0, v2
; CHECK-NEXT:    v_sub_u32_e32 v1, v1, v3
; CHECK-NEXT:    v_sub_u32_e32 v2, 0, v0
; CHECK-NEXT:    v_max_i32_e32 v0, v2, v0
; CHECK-NEXT:    v_sub_u32_e32 v2, 0, v1
; CHECK-NEXT:    v_max_i32_e32 v1, v2, v1
; CHECK-NEXT:    s_setpc_b64 s[30:31]
  %diff = sub <2 x i32> %arg0, %arg1
  %res = call <2 x i32> @llvm.abs.v2i32(<2 x i32> %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret <2 x i32> %res
}

define <4 x i32> @absdiff_4xi32_false(<4 x i32> %arg0, <4 x i32> %arg1) {
; CHECK-LABEL: absdiff_4xi32_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_sub_u32_e32 v0, v0, v4
; CHECK-NEXT:    v_sub_u32_e32 v1, v1, v5
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v0
; CHECK-NEXT:    v_sub_u32_e32 v2, v2, v6
; CHECK-NEXT:    v_max_i32_e32 v0, v4, v0
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v1
; CHECK-NEXT:    v_sub_u32_e32 v3, v3, v7
; CHECK-NEXT:    v_max_i32_e32 v1, v4, v1
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v2
; CHECK-NEXT:    v_max_i32_e32 v2, v4, v2
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v3
; CHECK-NEXT:    v_max_i32_e32 v3, v4, v3
; CHECK-NEXT:    s_setpc_b64 s[30:31]
  %diff = sub <4 x i32> %arg0, %arg1
  %res = call <4 x i32> @llvm.abs.v4i32(<4 x i32> %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret <4 x i32> %res
}
