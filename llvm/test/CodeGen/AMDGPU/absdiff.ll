; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=amdgcn-amd-amdpal -mcpu=gfx900 < %s | FileCheck %s

define amdgpu_ps i16 @absdiff_i16_false(i16 inreg %arg0, i16 inreg %arg1) {
; CHECK-LABEL: absdiff_i16_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_sub_i32 s0, s0, s1
; CHECK-NEXT:    s_sext_i32_i16 s1, s0
; CHECK-NEXT:    s_sub_i32 s0, 0, s0
; CHECK-NEXT:    s_sext_i32_i16 s0, s0
; CHECK-NEXT:    s_max_i32 s0, s1, s0
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i16 %arg0, %arg1
  %res = call i16 @llvm.abs.i16(i16 %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret i16 %res
}

define amdgpu_ps i16 @absdiff_i16_true(i16 inreg %arg0, i16 inreg %arg1) {
; CHECK-LABEL: absdiff_i16_true:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_sub_i32 s0, s0, s1
; CHECK-NEXT:    s_sext_i32_i16 s1, s0
; CHECK-NEXT:    s_sub_i32 s0, 0, s0
; CHECK-NEXT:    s_sext_i32_i16 s0, s0
; CHECK-NEXT:    s_max_i32 s0, s1, s0
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i16 %arg0, %arg1
  %res = call i16 @llvm.abs.i16(i16 %diff, i1 true) ; INT_MIN input returns poison
  ret i16 %res
}

define amdgpu_ps i32 @absdiff_i32_false(i32 inreg %arg0, i32 inreg %arg1) {
; CHECK-LABEL: absdiff_i32_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_absdiff_i32 s0, s0, s1
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i32 %arg0, %arg1
  %res = call i32 @llvm.abs.i32(i32 %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret i32 %res
}

define amdgpu_ps i32 @absdiff_i32_true(i32 inreg %arg0, i32 inreg %arg1) {
; CHECK-LABEL: absdiff_i32_true:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_absdiff_i32 s0, s0, s1
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i32 %arg0, %arg1
  %res = call i32 @llvm.abs.i32(i32 %diff, i1 true) ; INT_MIN input returns poison
  ret i32 %res
}

; Multiple uses of %diff.  No benefit for using s_absdiff_i32.
define amdgpu_ps i32 @absdiff_i32_false_multi_use(i32 inreg %arg0, i32 inreg %arg1) {
; CHECK-LABEL: absdiff_i32_false_multi_use:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_sub_i32 s1, s0, s1
; CHECK-NEXT:    s_abs_i32 s0, s1
; CHECK-NEXT:    ;;#ASMSTART
; CHECK-NEXT:    ; use s1
; CHECK-NEXT:    ;;#ASMEND
; CHECK-NEXT:    ; return to shader part epilog
  %diff = sub i32 %arg0, %arg1
  %res = call i32 @llvm.abs.i32(i32 %diff, i1 false) ; INT_MIN input returns INT_MIN
  call void asm "; use $0", "s"(i32 %diff)
  ret i32 %res
}

define <2 x i32> @absdiff_2xi32_false(<2 x i32> %arg0, <2 x i32> %arg1) {
; CHECK-LABEL: absdiff_2xi32_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_sub_u32_e32 v0, v0, v2
; CHECK-NEXT:    v_sub_u32_e32 v1, v1, v3
; CHECK-NEXT:    v_sub_u32_e32 v2, 0, v0
; CHECK-NEXT:    v_max_i32_e32 v0, v2, v0
; CHECK-NEXT:    v_sub_u32_e32 v2, 0, v1
; CHECK-NEXT:    v_max_i32_e32 v1, v2, v1
; CHECK-NEXT:    s_setpc_b64 s[30:31]
  %diff = sub <2 x i32> %arg0, %arg1
  %res = call <2 x i32> @llvm.abs.v2i32(<2 x i32> %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret <2 x i32> %res
}

define <4 x i32> @absdiff_4xi32_false(<4 x i32> %arg0, <4 x i32> %arg1) {
; CHECK-LABEL: absdiff_4xi32_false:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)
; CHECK-NEXT:    v_sub_u32_e32 v0, v0, v4
; CHECK-NEXT:    v_sub_u32_e32 v1, v1, v5
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v0
; CHECK-NEXT:    v_sub_u32_e32 v2, v2, v6
; CHECK-NEXT:    v_max_i32_e32 v0, v4, v0
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v1
; CHECK-NEXT:    v_sub_u32_e32 v3, v3, v7
; CHECK-NEXT:    v_max_i32_e32 v1, v4, v1
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v2
; CHECK-NEXT:    v_max_i32_e32 v2, v4, v2
; CHECK-NEXT:    v_sub_u32_e32 v4, 0, v3
; CHECK-NEXT:    v_max_i32_e32 v3, v4, v3
; CHECK-NEXT:    s_setpc_b64 s[30:31]
  %diff = sub <4 x i32> %arg0, %arg1
  %res = call <4 x i32> @llvm.abs.v4i32(<4 x i32> %diff, i1 false) ; INT_MIN input returns INT_MIN
  ret <4 x i32> %res
}
