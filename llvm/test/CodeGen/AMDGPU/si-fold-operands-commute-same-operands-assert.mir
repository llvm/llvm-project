# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=fiji -run-pass=peephole-opt,si-fold-operands -o - %s | FileCheck %s

# Check for assert when trying later folds after commuting an
# instruction where both operands are the same register. This depended
# on use list ordering, so we need to run peephole-opt first to
# reproduce.

---
name:            commute_add_same_inputs_assert
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3

    ; CHECK-LABEL: name: commute_add_same_inputs_assert
    ; CHECK: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:vgpr_32 = COPY $vgpr0
    ; CHECK-NEXT: [[V_ADD_CO_U32_e32_:%[0-9]+]]:vgpr_32 = V_ADD_CO_U32_e32 0, killed [[COPY]], implicit-def $vcc, implicit $exec
    ; CHECK-NEXT: [[V_MOV_B32_e32_:%[0-9]+]]:vgpr_32 = V_MOV_B32_e32 0, implicit $exec
    ; CHECK-NEXT: [[V_ADDC_U32_e32_:%[0-9]+]]:vgpr_32 = V_ADDC_U32_e32 0, [[V_MOV_B32_e32_]], implicit-def $vcc, implicit $vcc, implicit $exec
    ; CHECK-NEXT: $vgpr4 = COPY [[V_ADDC_U32_e32_]]
    ; CHECK-NEXT: SI_RETURN implicit $vgpr4
    %0:vgpr_32 = COPY $vgpr0
    %1:sreg_64 = S_MOV_B64 0
    %2:sreg_32 = COPY %1.sub0
    %3:vgpr_32 = V_ADD_CO_U32_e32 %2, killed %0, implicit-def $vcc, implicit $exec
    %4:vgpr_32 = COPY %2
    %5:vgpr_32 = COPY %2
    %6:vgpr_32 = V_ADDC_U32_e32 %4, %5, implicit-def $vcc, implicit $vcc, implicit $exec
    $vgpr4 = COPY %6
    SI_RETURN implicit $vgpr4

...

---
name:            commute_sub_same_inputs_assert
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3

    ; CHECK-LABEL: name: commute_sub_same_inputs_assert
    ; CHECK: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:vgpr_32 = COPY $vgpr0
    ; CHECK-NEXT: [[V_SUB_CO_U32_e32_:%[0-9]+]]:vgpr_32 = V_SUB_CO_U32_e32 0, killed [[COPY]], implicit-def $vcc, implicit $exec
    ; CHECK-NEXT: [[V_MOV_B32_e32_:%[0-9]+]]:vgpr_32 = V_MOV_B32_e32 0, implicit $exec
    ; CHECK-NEXT: [[V_SUBBREV_U32_e32_:%[0-9]+]]:vgpr_32 = V_SUBBREV_U32_e32 0, [[V_MOV_B32_e32_]], implicit-def $vcc, implicit $vcc, implicit $exec
    ; CHECK-NEXT: $vgpr4 = COPY [[V_SUBBREV_U32_e32_]]
    ; CHECK-NEXT: SI_RETURN implicit $vgpr4
    %0:vgpr_32 = COPY $vgpr0
    %1:sreg_64 = S_MOV_B64 0
    %2:sreg_32 = COPY %1.sub0
    %3:vgpr_32 = V_SUB_CO_U32_e32 %2, killed %0, implicit-def $vcc, implicit $exec
    %4:vgpr_32 = COPY %2
    %5:vgpr_32 = COPY %2
    %6:vgpr_32 = V_SUBB_U32_e32 %5, %4, implicit-def $vcc, implicit $vcc, implicit $exec
    $vgpr4 = COPY %6
    SI_RETURN implicit $vgpr4

...
