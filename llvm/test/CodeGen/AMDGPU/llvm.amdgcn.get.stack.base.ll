; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -global-isel=0 -mtriple=amdgcn -mcpu=gfx1200 -mattr=+real-true16 < %s | FileCheck %s
; RUN: llc -global-isel=0 -mtriple=amdgcn -mcpu=gfx1200 -mattr=-real-true16 < %s | FileCheck %s
; RUN: llc -global-isel=1 -mtriple=amdgcn -mcpu=gfx1200 -mattr=+real-true16 < %s | FileCheck %s
; RUN: llc -global-isel=1 -mtriple=amdgcn -mcpu=gfx1200 -mattr=-real-true16 < %s | FileCheck %s

; Test that the llvm.amdgcn.get.stack.base intrinsic returns the correct value:
; - for functions that need to reserve space for CWSR, it should return the offset
; past the reserved area (i.e. the offset of the first spill or local variables)
; - for functions that don't reserve any space, it should return 0

define amdgpu_cs i32 @stack_base_cs_dvgpr_16(i32 %val) #0 {
; CHECK-LABEL: stack_base_cs_dvgpr_16:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_getreg_b32 s33, hwreg(HW_REG_WAVE_HW_ID2, 8, 2)
; CHECK-NEXT:    s_getreg_b32 s0, hwreg(HW_REG_WAVE_HW_ID2, 8, 2)
; CHECK-NEXT:    s_cmp_lg_u32 0, s33
; CHECK-NEXT:    s_cmovk_i32 s33, 0x1c0
; CHECK-NEXT:    s_cmp_lg_u32 0, s0
; CHECK-NEXT:    scratch_store_b32 off, v0, s33 scope:SCOPE_SYS
; CHECK-NEXT:    s_wait_storecnt 0x0
; CHECK-NEXT:    s_cmovk_i32 s0, 0x1c0
; CHECK-NEXT:    ; return to shader part epilog
  %local = alloca i32, addrspace(5)
  store volatile i32 %val, ptr addrspace(5) %local
  %stack.base = call i32 @llvm.amdgcn.get.stack.base()
  ret i32 %stack.base
}

define amdgpu_cs i32 @stack_base_cs_dvgpr_32(i32 %val) #1 {
; CHECK-LABEL: stack_base_cs_dvgpr_32:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_getreg_b32 s33, hwreg(HW_REG_WAVE_HW_ID2, 8, 2)
; CHECK-NEXT:    s_getreg_b32 s0, hwreg(HW_REG_WAVE_HW_ID2, 8, 2)
; CHECK-NEXT:    s_cmp_lg_u32 0, s33
; CHECK-NEXT:    s_cmovk_i32 s33, 0x380
; CHECK-NEXT:    s_cmp_lg_u32 0, s0
; CHECK-NEXT:    scratch_store_b32 off, v0, s33 scope:SCOPE_SYS
; CHECK-NEXT:    s_wait_storecnt 0x0
; CHECK-NEXT:    s_cmovk_i32 s0, 0x380
; CHECK-NEXT:    ; return to shader part epilog
  %local = alloca i32, addrspace(5)
  store volatile i32 %val, ptr addrspace(5) %local
  %stack.base = call i32 @llvm.amdgcn.get.stack.base()
  ret i32 %stack.base
}

define amdgpu_cs i32 @stack_base_cs_no_dvgpr(i32 %val) #2 {
; CHECK-LABEL: stack_base_cs_no_dvgpr:
; CHECK:       ; %bb.0:
; CHECK-NEXT:    s_mov_b32 s0, 0
; CHECK-NEXT:    scratch_store_b32 off, v0, off scope:SCOPE_SYS
; CHECK-NEXT:    s_wait_storecnt 0x0
; CHECK-NEXT:    ; return to shader part epilog
  %local = alloca i32, addrspace(5)
  store volatile i32 %val, ptr addrspace(5) %local
  %stack.base = call i32 @llvm.amdgcn.get.stack.base()
  ret i32 %stack.base
}

define amdgpu_cs i32 @stack_base_cs_dvgpr_control_flow(i32 %val) #0 {
; CHECK-LABEL: stack_base_cs_dvgpr_control_flow:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_getreg_b32 s33, hwreg(HW_REG_WAVE_HW_ID2, 8, 2)
; CHECK-NEXT:    s_mov_b32 s0, exec_lo
; CHECK-NEXT:    s_cmp_lg_u32 0, s33
; CHECK-NEXT:    s_cmovk_i32 s33, 0x1c0
; CHECK-NEXT:    scratch_store_b32 off, v0, s33 scope:SCOPE_SYS
; CHECK-NEXT:    s_wait_storecnt 0x0
; CHECK-NEXT:    v_cmpx_gt_i32_e32 0x43, v0
; CHECK-NEXT:  ; %bb.1: ; %if.then
; CHECK-NEXT:    s_getreg_b32 s1, hwreg(HW_REG_WAVE_HW_ID2, 8, 2)
; CHECK-NEXT:    s_delay_alu instid0(SALU_CYCLE_1) | instskip(SKIP_1) | instid1(SALU_CYCLE_1)
; CHECK-NEXT:    s_cmp_lg_u32 0, s1
; CHECK-NEXT:    s_cmovk_i32 s1, 0x1c0
; CHECK-NEXT:    v_mov_b32_e32 v0, s1
; CHECK-NEXT:  ; %bb.2: ; %if.end
; CHECK-NEXT:    s_or_b32 exec_lo, exec_lo, s0
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; CHECK-NEXT:    v_readfirstlane_b32 s0, v0
; CHECK-NEXT:    s_wait_alu depctr_va_sdst(0)
; CHECK-NEXT:    ; return to shader part epilog
entry:
  %local = alloca i32, addrspace(5)
  store volatile i32 %val, ptr addrspace(5) %local
  %which = icmp slt i32 %val, 67
  br i1 %which, label %if.then, label %if.end

if.then:
  %stack.base = call i32 @llvm.amdgcn.get.stack.base()
  br label %if.end

if.end:
  %ret = phi i32 [ %stack.base, %if.then ], [ %val, %entry ]
  ret i32 %ret
}


attributes #0 = { nounwind "amdgpu-dynamic-vgpr-block-size"="16" }
attributes #1 = { nounwind "amdgpu-dynamic-vgpr-block-size"="32" }
attributes #2 = { nounwind "amdgpu-dynamic-vgpr-block-size"="0" }
