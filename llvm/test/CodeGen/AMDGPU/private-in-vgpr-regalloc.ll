; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=amdgcn-- -mcpu=gfx1300 -amdgpu-promote-private=true -verify-machineinstrs -o - %s | FileCheck %s
; RUN: llc -mtriple=amdgcn-- -mcpu=gfx1300 -amdgpu-promote-private=true -verify-machineinstrs -stop-after=amdgpu-private-object-vgprs -o - %s | FileCheck --check-prefix=LIVEINS %s

; LIVEINS-LABEL: name: basic
; LIVEINS: bb.0.entry:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $sgpr4_sgpr5{{$}}
;
; LIVEINS: bb.1.bb:
; LIVEINS-NEXT: successors:
; LIVEINS-NOT: liveins:
;
; LIVEINS: bb.2.bb2:
; LIVEINS-NEXT: successors:
; LIVEINS-NOT: liveins:
;
; LIVEINS: bb.3.bb3:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr6, $vgpr7, $vgpr8, $vgpr9, $vgpr10, $vgpr11, $vgpr12, $vgpr13, $vgpr14, $vgpr15, $vgpr16, $vgpr17, $vgpr18, $vgpr19, $vgpr20, $vgpr21, $vgpr22, $vgpr23, $vgpr24, $vgpr25, $vgpr26, $vgpr27, $vgpr28, $vgpr29{{$}}
;
; LIVEINS: bb.4.bb4:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr6, $vgpr7, $vgpr8, $vgpr9, $vgpr10, $vgpr11, $vgpr12, $vgpr13, $vgpr14, $vgpr15, $vgpr16, $vgpr17, $vgpr18, $vgpr19, $vgpr20, $vgpr21, $vgpr22, $vgpr23, $vgpr24, $vgpr25, $vgpr26, $vgpr27, $vgpr28, $vgpr29{{$}}
;
; LIVEINS: bb.5.exit:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr6, $vgpr7, $vgpr8, $vgpr9, $vgpr10, $vgpr11, $vgpr12, $vgpr13, $vgpr14, $vgpr15, $vgpr16, $vgpr17, $vgpr18, $vgpr19, $vgpr20, $vgpr21, $vgpr22, $vgpr23, $vgpr24, $vgpr25, $vgpr26, $vgpr27, $vgpr28, $vgpr29{{$}}
;
; LIVEINS: bb.6.ret:
; LIVEINS-NEXT: S_ENDPGM 0

define amdgpu_kernel void @basic(ptr addrspace(5) %out, ptr addrspace(5) %in) {
; CHECK-LABEL: basic:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_load_b64 s[0:1], s[4:5], 0x24
; CHECK-NEXT:    v_mov_b32_e32 v0, 3
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    scratch_store_b32 off, v0, s0 offset:12 scope:SCOPE_SE
; CHECK-NEXT:    s_cbranch_scc1 .LBB0_6
; CHECK-NEXT:  ; %bb.1: ; %bb
; CHECK-NEXT:    v_mov_b32_e32 v0, 5
; CHECK-NEXT:    scratch_store_b32 off, v0, s0 offset:20 scope:SCOPE_SE
; CHECK-NEXT:    s_cbranch_scc1 .LBB0_6
; CHECK-NEXT:  ; %bb.2: ; %bb2
; CHECK-NEXT:    scratch_load_b32 v0, off, s1
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    ; implicit-def: $vgpr1
; CHECK-NEXT:    ; implicit-def: $vgpr2
; CHECK-NEXT:    ; implicit-def: $vgpr3
; CHECK-NEXT:    ; implicit-def: $vgpr4
; CHECK-NEXT:    ; implicit-def: $vgpr5
; CHECK-NEXT:    ; implicit-def: $vgpr6
; CHECK-NEXT:    ; implicit-def: $vgpr7
; CHECK-NEXT:    ; implicit-def: $vgpr8
; CHECK-NEXT:    ; implicit-def: $vgpr9
; CHECK-NEXT:    ; implicit-def: $vgpr10
; CHECK-NEXT:    ; implicit-def: $vgpr11
; CHECK-NEXT:    ; implicit-def: $vgpr12
; CHECK-NEXT:    ; implicit-def: $vgpr13
; CHECK-NEXT:    ; implicit-def: $vgpr14
; CHECK-NEXT:    ; implicit-def: $vgpr15
; CHECK-NEXT:    ; implicit-def: $vgpr16
; CHECK-NEXT:    ; implicit-def: $vgpr17
; CHECK-NEXT:    ; implicit-def: $vgpr18
; CHECK-NEXT:    ; implicit-def: $vgpr19
; CHECK-NEXT:    ; implicit-def: $vgpr20
; CHECK-NEXT:    ; implicit-def: $vgpr21
; CHECK-NEXT:    ; implicit-def: $vgpr22
; CHECK-NEXT:    ; implicit-def: $vgpr23
; CHECK-NEXT:    ; implicit-def: $vgpr24
; CHECK-NEXT:    ; implicit-def: $vgpr25
; CHECK-NEXT:    ; implicit-def: $vgpr26
; CHECK-NEXT:    ; implicit-def: $vgpr27
; CHECK-NEXT:    ; implicit-def: $vgpr28
; CHECK-NEXT:    ; implicit-def: $vgpr29
; CHECK-NEXT:    s_wait_loadcnt 0x0
; CHECK-NEXT:    v_mul_f32_e32 v0, v0, v0
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_1) | instskip(SKIP_1) | instid1(VALU_DEP_1)
; CHECK-NEXT:    v_add_f32_e32 v30, 2.0, v0
; CHECK-NEXT:    ; implicit-def: $vgpr0
; CHECK-NEXT:    s_set_vgpr_frames 64 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    v_mov_b32_e32 g1[1], v30
; CHECK-NEXT:    s_set_vgpr_frames 0 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    s_cbranch_scc1 .LBB0_5
; CHECK-NEXT:  ; %bb.3: ; %bb3
; CHECK-NEXT:    s_cbranch_scc1 .LBB0_5
; CHECK-NEXT:  ; %bb.4: ; %bb4
; CHECK-NEXT:    v_mul_f32_e32 v0, v30, v30
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    s_set_vgpr_frames 64 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; CHECK-NEXT:    v_add_f32_e64 g1[1], v0, 2.0
; CHECK-NEXT:  .LBB0_5: ; %exit
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    s_set_vgpr_frames 4 ; vsrc0_idx=0 vsrc1_idx=1 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    scratch_store_b32 off, g1[1], s0
; CHECK-NEXT:    scratch_load_b32 v0, off, s0 offset:28
; CHECK-NEXT:    s_wait_loadcnt 0x0
; CHECK-NEXT:    s_set_vgpr_frames 0 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    v_add_nc_u32_e32 v0, 7, v0
; CHECK-NEXT:    scratch_store_b32 off, v0, s0 offset:28 scope:SCOPE_SE
; CHECK-NEXT:  .LBB0_6: ; %ret
; CHECK-NEXT:    s_endpgm
entry:
  ; Give VGPR0 some use.
  %out.3 = getelementptr i32, ptr addrspace(5) %out, i32 3
  store i32 3, ptr addrspace(5) %out.3

  %p = alloca [30 x float], align 4, addrspace(5)
  %p.1 = getelementptr [30 x float], ptr addrspace(5) %p, i32 0, i32 1

  br i1 undef, label %bb, label %ret

bb:
  ; Use VPGR0 again in a basic block on a path between the entry and the
  ; block containing the first use of the private object.
  %out.5 = getelementptr i32, ptr addrspace(5) %out, i32 5
  store i32 5, ptr addrspace(5) %out.5
  br i1 undef, label %bb2, label %ret

bb2:
  ; The private object starts to live, so VGPR0 and other registers
  ; allocated to the object are not available to the main register
  ; allocator beginning this point.
  %v2 = load float, ptr addrspace(5) %in, align 4
  %mul2 = fmul float %v2, %v2
  %add2 = fadd float %mul2, 2.0
  store float %add2, ptr addrspace(5) %p.1, align 4
  br i1 undef, label %bb3, label %exit

bb3:
  ; Have a basic block where the private object is live but is not
  ; accessed, to test that such blocks still get the allocated VGPRs as
  ; their live-ins.
  br i1 undef, label %bb4, label %exit

bb4:
  %v = load float, ptr addrspace(5) %p.1, align 4
  %mul = fmul float %v, %v
  %add = fadd float %mul, 2.0
  store float %add, ptr addrspace(5) %p.1, align 4
  br label %exit

exit:
  %v3 = load float, ptr addrspace(5) %p.1, align 4
  store float %v3, ptr addrspace(5) %out

  ; The private object is not live anymore, so VGPR0 is available for
  ; allocation again.
  %out.7 = getelementptr i32, ptr addrspace(5) %out, i32 7
  %v7 = load i32, ptr addrspace(5) %out.7
  %add7 = add i32 %v7, 7
  store i32 %add7, ptr addrspace(5) %out.7
  br label %ret

ret:
  ret void
}

; LIVEINS-LABEL: name: load_without_store
; LIVEINS: bb.0.entry:
; LIVEINS-NEXT: liveins: $sgpr4_sgpr5{{$}}

define amdgpu_kernel void @load_without_store(ptr addrspace(5) %out) {
; CHECK-LABEL: load_without_store:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_load_b32 s0, s[4:5], 0x24
; CHECK-NEXT:    v_mov_b32_e32 v0, 3
; CHECK-NEXT:    ; implicit-def: $vgpr1
; CHECK-NEXT:    ; implicit-def: $vgpr2
; CHECK-NEXT:    ; implicit-def: $vgpr3
; CHECK-NEXT:    ; implicit-def: $vgpr4
; CHECK-NEXT:    ; implicit-def: $vgpr5
; CHECK-NEXT:    ; implicit-def: $vgpr6
; CHECK-NEXT:    ; implicit-def: $vgpr7
; CHECK-NEXT:    ; implicit-def: $vgpr8
; CHECK-NEXT:    ; implicit-def: $vgpr9
; CHECK-NEXT:    ; implicit-def: $vgpr10
; CHECK-NEXT:    ; implicit-def: $vgpr11
; CHECK-NEXT:    ; implicit-def: $vgpr12
; CHECK-NEXT:    ; implicit-def: $vgpr13
; CHECK-NEXT:    ; implicit-def: $vgpr14
; CHECK-NEXT:    ; implicit-def: $vgpr15
; CHECK-NEXT:    ; implicit-def: $vgpr16
; CHECK-NEXT:    ; implicit-def: $vgpr17
; CHECK-NEXT:    ; implicit-def: $vgpr18
; CHECK-NEXT:    ; implicit-def: $vgpr19
; CHECK-NEXT:    ; implicit-def: $vgpr20
; CHECK-NEXT:    ; implicit-def: $vgpr21
; CHECK-NEXT:    ; implicit-def: $vgpr22
; CHECK-NEXT:    ; implicit-def: $vgpr23
; CHECK-NEXT:    ; implicit-def: $vgpr24
; CHECK-NEXT:    ; implicit-def: $vgpr25
; CHECK-NEXT:    ; implicit-def: $vgpr26
; CHECK-NEXT:    ; implicit-def: $vgpr27
; CHECK-NEXT:    ; implicit-def: $vgpr28
; CHECK-NEXT:    ; implicit-def: $vgpr29
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    scratch_store_b32 off, v0, s0 offset:12 scope:SCOPE_SE
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    s_set_vgpr_frames 4 ; vsrc0_idx=0 vsrc1_idx=1 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    scratch_store_b32 off, g1[1], s0 offset:28
; CHECK-NEXT:    ; implicit-def: $vgpr0
; CHECK-NEXT:    s_endpgm
entry:
  %out.3 = getelementptr i32, ptr addrspace(5) %out, i32 3
  store i32 3, ptr addrspace(5) %out.3

  %p = alloca [30 x float], align 4, addrspace(5)
  %p.1 = getelementptr [30 x float], ptr addrspace(5) %p, i32 0, i32 1

  %v = load float, ptr addrspace(5) %p.1, align 4

  %out.7 = getelementptr i32, ptr addrspace(5) %out, i32 7
  store float %v, ptr addrspace(5) %out.7
  ret void
}

; LIVEINS-LABEL: name: bypassed_store
; LIVEINS: bb.0.entry:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $sgpr4_sgpr5{{$}}
;
; LIVEINS: bb.1.store:
; LIVEINS-NEXT: successors:
; LIVEINS-NXT: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr6, $vgpr7, $vgpr8, $vgpr9, $vgpr10, $vgpr11, $vgpr12, $vgpr13, $vgpr14, $vgpr15, $vgpr16, $vgpr17, $vgpr18, $vgpr19, $vgpr20, $vgpr21, $vgpr22, $vgpr23, $vgpr24, $vgpr25, $vgpr26, $vgpr27, $vgpr28, $vgpr29{{$}}
;
; LIVEINS: bb.2.skip:
; LIVEINS-NEXT: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr6, $vgpr7, $vgpr8, $vgpr9, $vgpr10, $vgpr11, $vgpr12, $vgpr13, $vgpr14, $vgpr15, $vgpr16, $vgpr17, $vgpr18, $vgpr19, $vgpr20, $vgpr21, $vgpr22, $vgpr23, $vgpr24, $vgpr25, $vgpr26, $vgpr27, $vgpr28, $vgpr29{{$}}

define amdgpu_kernel void @bypassed_store(ptr addrspace(5) %out, i32 %x) {
; CHECK-LABEL: bypassed_store:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_load_b64 s[0:1], s[4:5], 0x24
; CHECK-NEXT:    v_mov_b32_e32 v0, 3
; CHECK-NEXT:    ; implicit-def: $vgpr1
; CHECK-NEXT:    ; implicit-def: $vgpr2
; CHECK-NEXT:    ; implicit-def: $vgpr3
; CHECK-NEXT:    ; implicit-def: $vgpr4
; CHECK-NEXT:    ; implicit-def: $vgpr5
; CHECK-NEXT:    ; implicit-def: $vgpr6
; CHECK-NEXT:    ; implicit-def: $vgpr7
; CHECK-NEXT:    ; implicit-def: $vgpr8
; CHECK-NEXT:    ; implicit-def: $vgpr9
; CHECK-NEXT:    ; implicit-def: $vgpr10
; CHECK-NEXT:    ; implicit-def: $vgpr11
; CHECK-NEXT:    ; implicit-def: $vgpr12
; CHECK-NEXT:    ; implicit-def: $vgpr13
; CHECK-NEXT:    ; implicit-def: $vgpr14
; CHECK-NEXT:    ; implicit-def: $vgpr15
; CHECK-NEXT:    ; implicit-def: $vgpr16
; CHECK-NEXT:    ; implicit-def: $vgpr17
; CHECK-NEXT:    ; implicit-def: $vgpr18
; CHECK-NEXT:    ; implicit-def: $vgpr19
; CHECK-NEXT:    ; implicit-def: $vgpr20
; CHECK-NEXT:    ; implicit-def: $vgpr21
; CHECK-NEXT:    ; implicit-def: $vgpr22
; CHECK-NEXT:    ; implicit-def: $vgpr23
; CHECK-NEXT:    ; implicit-def: $vgpr24
; CHECK-NEXT:    ; implicit-def: $vgpr25
; CHECK-NEXT:    ; implicit-def: $vgpr26
; CHECK-NEXT:    ; implicit-def: $vgpr27
; CHECK-NEXT:    ; implicit-def: $vgpr28
; CHECK-NEXT:    ; implicit-def: $vgpr29
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    s_cmp_eq_u32 s1, 9
; CHECK-NEXT:    scratch_store_b32 off, v0, s0 offset:12 scope:SCOPE_SE
; CHECK-NEXT:    ; implicit-def: $vgpr0
; CHECK-NEXT:    s_cbranch_scc1 .LBB2_2
; CHECK-NEXT:  ; %bb.1: ; %store
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    s_set_vgpr_frames 64 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    v_mov_b32_e32 g1[1], 1.0
; CHECK-NEXT:  .LBB2_2: ; %skip
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    s_set_vgpr_frames 4 ; vsrc0_idx=0 vsrc1_idx=1 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    scratch_store_b32 off, g1[1], s0 offset:28
; CHECK-NEXT:    s_endpgm
entry:
  %out.3 = getelementptr i32, ptr addrspace(5) %out, i32 3
  store i32 3, ptr addrspace(5) %out.3

  %p = alloca [30 x float], align 4, addrspace(5)
  %p.1 = getelementptr [30 x float], ptr addrspace(5) %p, i32 0, i32 1

  %cond = icmp eq i32 %x, 9
  br i1 %cond, label %skip, label %store

store:
  store float 1.0, ptr addrspace(5) %p.1, align 4
  br label %skip

skip:
  %v = load float, ptr addrspace(5) %p.1, align 4
  %out.7 = getelementptr i32, ptr addrspace(5) %out, i32 7
  store float %v, ptr addrspace(5) %out.7
  ret void
}

; LIVEINS-LABEL: name: def_in_nonentry_block
; LIVEINS: bb.0.entry:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $sgpr4_sgpr5{{$}}
;
; LIVEINS: bb.1.bb:
; LIVEINS-NEXT: successors:
; LIVEINS-NOT: liveins:
; LIVEINS: V_STORE_IDX
;
; LIVEINS: bb.2.ret:
; LIVEINS-NEXT: S_ENDPGM

define amdgpu_kernel void @def_in_nonentry_block(ptr addrspace(5) %out, float %x) {
; CHECK-LABEL: def_in_nonentry_block:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_load_b64 s[0:1], s[4:5], 0x24
; CHECK-NEXT:    v_mov_b32_e32 v0, 3
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    s_cmp_nge_f32 s1, 0x41100000
; CHECK-NEXT:    scratch_store_b32 off, v0, s0 offset:12 scope:SCOPE_SE
; CHECK-NEXT:    s_cbranch_scc1 .LBB3_2
; CHECK-NEXT:  ; %bb.1: ; %bb
; CHECK-NEXT:    v_mov_b32_e32 v30, s1
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    ; implicit-def: $vgpr1
; CHECK-NEXT:    ; implicit-def: $vgpr0
; CHECK-NEXT:    ; implicit-def: $vgpr2
; CHECK-NEXT:    ; implicit-def: $vgpr3
; CHECK-NEXT:    ; implicit-def: $vgpr4
; CHECK-NEXT:    ; implicit-def: $vgpr5
; CHECK-NEXT:    ; implicit-def: $vgpr6
; CHECK-NEXT:    ; implicit-def: $vgpr7
; CHECK-NEXT:    ; implicit-def: $vgpr8
; CHECK-NEXT:    ; implicit-def: $vgpr9
; CHECK-NEXT:    ; implicit-def: $vgpr10
; CHECK-NEXT:    ; implicit-def: $vgpr11
; CHECK-NEXT:    ; implicit-def: $vgpr12
; CHECK-NEXT:    ; implicit-def: $vgpr13
; CHECK-NEXT:    ; implicit-def: $vgpr14
; CHECK-NEXT:    ; implicit-def: $vgpr15
; CHECK-NEXT:    ; implicit-def: $vgpr16
; CHECK-NEXT:    ; implicit-def: $vgpr17
; CHECK-NEXT:    ; implicit-def: $vgpr18
; CHECK-NEXT:    ; implicit-def: $vgpr19
; CHECK-NEXT:    ; implicit-def: $vgpr20
; CHECK-NEXT:    ; implicit-def: $vgpr21
; CHECK-NEXT:    ; implicit-def: $vgpr22
; CHECK-NEXT:    ; implicit-def: $vgpr23
; CHECK-NEXT:    ; implicit-def: $vgpr24
; CHECK-NEXT:    ; implicit-def: $vgpr25
; CHECK-NEXT:    ; implicit-def: $vgpr26
; CHECK-NEXT:    ; implicit-def: $vgpr27
; CHECK-NEXT:    ; implicit-def: $vgpr28
; CHECK-NEXT:    ; implicit-def: $vgpr29
; CHECK-NEXT:    s_set_vgpr_frames 64 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; CHECK-NEXT:    v_mov_b32_e32 g1[1], v30
; CHECK-NEXT:    scratch_store_b32 off, v30, s0 offset:28 scope:SCOPE_SE
; CHECK-NEXT:  .LBB3_2: ; %ret
; CHECK-NEXT:    s_endpgm
entry:
  %out.3 = getelementptr i32, ptr addrspace(5) %out, i32 3
  store i32 3, ptr addrspace(5) %out.3

  %p = alloca [30 x float], align 4, addrspace(5)
  %p.1 = getelementptr [30 x float], ptr addrspace(5) %p, i32 0, i32 1

  %cond = fcmp ult float %x, 9.0
  br i1 %cond, label %ret, label %bb

bb:
  store float %x, ptr addrspace(5) %p.1, align 4
  %v = load float, ptr addrspace(5) %p.1, align 4
  %out.7 = getelementptr i32, ptr addrspace(5) %out, i32 7
  store float %v, ptr addrspace(5) %out.7
  br label %ret

ret:
  ret void
}

; LIVEINS-LABEL: name: loop
; LIVEINS: bb.0.entry:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $sgpr4_sgpr5{{$}}
;
; LIVEINS: bb.1.loop:
; LIVEINS-NEXT: successors:
; LIVEINS-NEXT: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr6, $vgpr7, $vgpr8, $vgpr9, $vgpr10, $vgpr11, $vgpr12, $vgpr13, $vgpr14, $vgpr15, $vgpr16, $vgpr17, $vgpr18, $vgpr19, $vgpr20, $vgpr21, $vgpr22, $vgpr23, $vgpr24, $vgpr25, $vgpr26, $vgpr27, $vgpr28, $vgpr29{{$}}
; LIVEINS: V_STORE_IDX
; LIVEINS: S_CBRANCH_SCC1 %bb.1,
;
; LIVEINS: bb.2.exit:
; LIVEINS-NEXT: liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3, $vgpr4, $vgpr5, $vgpr6, $vgpr7, $vgpr8, $vgpr9, $vgpr10, $vgpr11, $vgpr12, $vgpr13, $vgpr14, $vgpr15, $vgpr16, $vgpr17, $vgpr18, $vgpr19, $vgpr20, $vgpr21, $vgpr22, $vgpr23, $vgpr24, $vgpr25, $vgpr26, $vgpr27, $vgpr28, $vgpr29{{$}}
; LIVEINS: S_ENDPGM

define amdgpu_kernel void @loop(ptr addrspace(5) %out, i32 %x) {
; CHECK-LABEL: loop:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_load_b64 s[0:1], s[4:5], 0x24
; CHECK-NEXT:    v_mov_b32_e32 v30, 3
; CHECK-NEXT:    s_mov_b32 s2, -1
; CHECK-NEXT:    s_mov_b32 s3, 0
; CHECK-NEXT:    ; implicit-def: $vgpr0
; CHECK-NEXT:    ; implicit-def: $vgpr1
; CHECK-NEXT:    ; implicit-def: $vgpr2
; CHECK-NEXT:    ; implicit-def: $vgpr3
; CHECK-NEXT:    ; implicit-def: $vgpr4
; CHECK-NEXT:    ; implicit-def: $vgpr5
; CHECK-NEXT:    ; implicit-def: $vgpr6
; CHECK-NEXT:    ; implicit-def: $vgpr7
; CHECK-NEXT:    ; implicit-def: $vgpr8
; CHECK-NEXT:    ; implicit-def: $vgpr9
; CHECK-NEXT:    ; implicit-def: $vgpr10
; CHECK-NEXT:    ; implicit-def: $vgpr11
; CHECK-NEXT:    ; implicit-def: $vgpr12
; CHECK-NEXT:    ; implicit-def: $vgpr13
; CHECK-NEXT:    ; implicit-def: $vgpr14
; CHECK-NEXT:    ; implicit-def: $vgpr15
; CHECK-NEXT:    ; implicit-def: $vgpr16
; CHECK-NEXT:    ; implicit-def: $vgpr17
; CHECK-NEXT:    ; implicit-def: $vgpr18
; CHECK-NEXT:    ; implicit-def: $vgpr19
; CHECK-NEXT:    ; implicit-def: $vgpr20
; CHECK-NEXT:    ; implicit-def: $vgpr21
; CHECK-NEXT:    ; implicit-def: $vgpr22
; CHECK-NEXT:    ; implicit-def: $vgpr23
; CHECK-NEXT:    ; implicit-def: $vgpr24
; CHECK-NEXT:    ; implicit-def: $vgpr25
; CHECK-NEXT:    ; implicit-def: $vgpr26
; CHECK-NEXT:    ; implicit-def: $vgpr27
; CHECK-NEXT:    ; implicit-def: $vgpr28
; CHECK-NEXT:    ; implicit-def: $vgpr29
; CHECK-NEXT:  .LBB4_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    s_delay_alu instid0(SALU_CYCLE_1)
; CHECK-NEXT:    s_lshr_b32 s4, s3, 2
; CHECK-NEXT:    s_add_co_i32 s2, s2, 1
; CHECK-NEXT:    s_add_co_i32 s3, s3, 4
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, s4
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    s_cmp_lt_u32 s2, s1
; CHECK-NEXT:    s_set_vgpr_frames 64 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    v_mov_b32_e32 g1[0], v30
; CHECK-NEXT:    s_set_vgpr_frames 0 ; vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    s_cbranch_scc1 .LBB4_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    s_set_gpr_idx_u32 idx1, 0
; CHECK-NEXT:    s_set_vgpr_frames 4 ; vsrc0_idx=0 vsrc1_idx=1 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
; CHECK-NEXT:    scratch_store_b32 off, g1[5], s0
; CHECK-NEXT:    s_endpgm
entry:
  %p = alloca [30 x i32], align 4, addrspace(5)
  %p.5 = getelementptr [30 x i32], ptr addrspace(5) %p, i32 0, i32 5
  br label %loop

loop:
  %i = phi i32 [0, %entry], [%i1, %loop]
  %p.i = getelementptr i32, ptr addrspace(5) %p, i32 %i
  store i32 3, ptr addrspace(5) %p.i, align 4

  %cond = icmp ult i32 %i, %x
  %i1 = add i32 %i, 1
  br i1 %cond, label %loop, label %exit

exit:
  %v = load i32, ptr addrspace(5) %p.5, align 4
  store i32 %v, ptr addrspace(5) %out
  ret void
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; LIVEINS: {{.*}}
