; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -amdgpu-vector-idiom-enable -mtriple=amdgcn-amd-amdhsa -passes=amdgpu-vector-idiom -S %s | FileCheck %s

; This test verifies the AMDGPUVectorIdiomCombinePass transforms:
; 1) memcpy with select-fed source into a value-level select between two loads,
;    followed by one store (when it's safe to speculate both loads).
; 2) memcpy with select-fed destination into a control-flow split with two memcpys.

@G0 = addrspace(1) global [4 x i32] zeroinitializer, align 16
@G1 = addrspace(1) global [4 x i32] zeroinitializer, align 16

declare void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) nocapture writeonly, ptr addrspace(1) nocapture readonly, i64, i1 immarg)

; -----------------------------------------------------------------------------
; Source is a select. Expect value-level select of two <4 x i32> loads
; and a single store, with no remaining memcpy.
;
define amdgpu_kernel void @value_select_src(ptr addrspace(1) %dst, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @value_select_src(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [4 x i32], ptr addrspace(1) @G0, i64 0, i64 0
; CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [4 x i32], ptr addrspace(1) @G1, i64 0, i64 0
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[A]], ptr addrspace(1) [[B]]
; CHECK-NEXT:    [[LA:%.*]] = load <4 x i32>, ptr addrspace(1) [[A]], align 16
; CHECK-NEXT:    [[LB:%.*]] = load <4 x i32>, ptr addrspace(1) [[B]], align 16
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], <4 x i32> [[LA]], <4 x i32> [[LB]]
; CHECK-NEXT:    store <4 x i32> [[SEL]], ptr addrspace(1) [[DST]], align 16
; CHECK-NEXT:    ret void
;
entry:
  ; Pointers to two 16-byte aligned buffers in the same addrspace(1).
  %pa = getelementptr inbounds [4 x i32], ptr addrspace(1) @G0, i64 0, i64 0
  %pb = getelementptr inbounds [4 x i32], ptr addrspace(1) @G1, i64 0, i64 0
  %src = select i1 %cond, ptr addrspace(1) %pa, ptr addrspace(1) %pb

  ; Provide explicit operand alignments so the pass can emit an aligned store.
  call void @llvm.memcpy.p1.p1.i64(
  ptr addrspace(1) align 16 %dst,
  ptr addrspace(1) align 16 %src,
  i64 16, i1 false)

  ret void
}

; -----------------------------------------------------------------------------
; Destination is a select. Expect CFG split with two memcpys guarded
; by a branch (we do not speculate stores in this pass).
;
define amdgpu_kernel void @dest_select_cfg_split(ptr addrspace(1) %da, ptr addrspace(1) %db,
; CHECK-LABEL: define amdgpu_kernel void @dest_select_cfg_split(
; CHECK-SAME: ptr addrspace(1) [[DA:%.*]], ptr addrspace(1) [[DB:%.*]], ptr addrspace(1) [[SRC:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DST:%.*]] = select i1 [[COND]], ptr addrspace(1) [[DA]], ptr addrspace(1) [[DB]]
; CHECK-NEXT:    br i1 [[COND]], label %[[MEMCPY_THEN:.*]], label %[[MEMCPY_ELSE:.*]]
; CHECK:       [[MEMCPY_JOIN:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[MEMCPY_THEN]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DA]], ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
; CHECK:       [[MEMCPY_ELSE]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DB]], ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
;
  ptr addrspace(1) %src, i1 %cond) {
entry:
  %dst = select i1 %cond, ptr addrspace(1) %da, ptr addrspace(1) %db
  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst, ptr addrspace(1) %src, i64 16, i1 false)
  ret void
}

; -----------------------------------------------------------------------------
; Source is a select, 4 x double (32 bytes).
; Expect value-level select of two <4 x i64> loads and a single store, no memcpy.
;
@G2 = addrspace(1) global [4 x double] zeroinitializer, align 32
@G3 = addrspace(1) global [4 x double] zeroinitializer, align 32
define amdgpu_kernel void @value_select_src_4xd(ptr addrspace(1) %dst, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @value_select_src_4xd(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[PA:%.*]] = getelementptr inbounds [4 x double], ptr addrspace(1) @G2, i64 0, i64 0
; CHECK-NEXT:    [[PB:%.*]] = getelementptr inbounds [4 x double], ptr addrspace(1) @G3, i64 0, i64 0
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PA]], ptr addrspace(1) [[PB]]
; CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i64>, ptr addrspace(1) [[PA]], align 32
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i64>, ptr addrspace(1) [[PB]], align 32
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[COND]], <4 x i64> [[TMP0]], <4 x i64> [[TMP1]]
; CHECK-NEXT:    store <4 x i64> [[TMP2]], ptr addrspace(1) [[DST]], align 32
; CHECK-NEXT:    ret void
;
entry:
  %pa = getelementptr inbounds [4 x double], ptr addrspace(1) @G2, i64 0, i64 0
  %pb = getelementptr inbounds [4 x double], ptr addrspace(1) @G3, i64 0, i64 0
  %src = select i1 %cond, ptr addrspace(1) %pa, ptr addrspace(1) %pb

  call void @llvm.memcpy.p1.p1.i64(
  ptr addrspace(1) align 32 %dst,
  ptr addrspace(1) align 32 %src,
  i64 32, i1 false)

  ret void
}

; -----------------------------------------------------------------------------
; Source is a select, 3 x char (3 bytes).
; Expect value-level select using <3 x i8> loads/stores, no memcpy.
;
@G4 = addrspace(1) global [3 x i8] zeroinitializer, align 1
@G5 = addrspace(1) global [3 x i8] zeroinitializer, align 1
define amdgpu_kernel void @value_select_src_3xc(ptr addrspace(1) %dst, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @value_select_src_3xc(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[PA:%.*]] = getelementptr inbounds [3 x i8], ptr addrspace(1) @G4, i64 0, i64 0
; CHECK-NEXT:    [[PB:%.*]] = getelementptr inbounds [3 x i8], ptr addrspace(1) @G5, i64 0, i64 0
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PA]], ptr addrspace(1) [[PB]]
; CHECK-NEXT:    [[TMP0:%.*]] = load <3 x i8>, ptr addrspace(1) [[PA]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = load <3 x i8>, ptr addrspace(1) [[PB]], align 1
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[COND]], <3 x i8> [[TMP0]], <3 x i8> [[TMP1]]
; CHECK-NEXT:    store <3 x i8> [[TMP2]], ptr addrspace(1) [[DST]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %pa = getelementptr inbounds [3 x i8], ptr addrspace(1) @G4, i64 0, i64 0
  %pb = getelementptr inbounds [3 x i8], ptr addrspace(1) @G5, i64 0, i64 0
  %src = select i1 %cond, ptr addrspace(1) %pa, ptr addrspace(1) %pb

  call void @llvm.memcpy.p1.p1.i64(
  ptr addrspace(1) align 1 %dst,
  ptr addrspace(1) align 1 %src,
  i64 3, i1 false)

  ret void
}

; -----------------------------------------------------------------------------
; Source is a select with constant expression GEP arms.
; Expect value-level select: two loads + select + store, no memcpy.
;
@GEPA = addrspace(1) global [4 x i32] zeroinitializer, align 16
@GEPB = addrspace(1) global [4 x i32] zeroinitializer, align 16
define amdgpu_kernel void @value_select_src_constexpr_gep(ptr addrspace(1) %dst, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @value_select_src_constexpr_gep(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) @GEPA, ptr addrspace(1) @GEPB
; CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr addrspace(1) @GEPA, align 16
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr addrspace(1) @GEPB, align 16
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[COND]], <4 x i32> [[TMP0]], <4 x i32> [[TMP1]]
; CHECK-NEXT:    store <4 x i32> [[TMP2]], ptr addrspace(1) [[DST]], align 16
; CHECK-NEXT:    ret void
;
entry:
  ; Constant expression GEPs to the base elements
  %src = select i1 %cond,
  ptr addrspace(1) getelementptr inbounds ([4 x i32], ptr addrspace(1) @GEPA, i64 0, i64 0),
  ptr addrspace(1) getelementptr inbounds ([4 x i32], ptr addrspace(1) @GEPB, i64 0, i64 0)

  call void @llvm.memcpy.p1.p1.i64(
  ptr addrspace(1) align 16 %dst,
  ptr addrspace(1) align 16 %src,
  i64 16, i1 false)

  ret void
}
; -----------------------------------------------------------------------------
; Destination is a select with constant expression GEP arms.
; Expect CFG split with two memcpys.
;
define amdgpu_kernel void @dest_select_constexpr_gep(ptr addrspace(1) %src, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @dest_select_constexpr_gep(
; CHECK-SAME: ptr addrspace(1) [[SRC:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DST:%.*]] = select i1 [[COND]], ptr addrspace(1) @GEPA, ptr addrspace(1) @GEPB
; CHECK-NEXT:    br i1 [[COND]], label %[[MEMCPY_THEN:.*]], label %[[MEMCPY_ELSE:.*]]
; CHECK:       [[MEMCPY_JOIN:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[MEMCPY_THEN]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) @GEPA, ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
; CHECK:       [[MEMCPY_ELSE]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) @GEPB, ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
;
entry:
  %dst = select i1 %cond,
  ptr addrspace(1) getelementptr inbounds ([4 x i32], ptr addrspace(1) @GEPA, i64 0, i64 0),
  ptr addrspace(1) getelementptr inbounds ([4 x i32], ptr addrspace(1) @GEPB, i64 0, i64 0)

  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst, ptr addrspace(1) %src, i64 16, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; Source is a select where one arm is null.
; Expect CFG split (no speculative loads).
;
@GN = addrspace(1) global [4 x i32] zeroinitializer, align 16
define amdgpu_kernel void @src_select_null_arm(ptr addrspace(1) %dst, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @src_select_null_arm(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[NONNULL:%.*]] = getelementptr inbounds [4 x i32], ptr addrspace(1) @GN, i64 0, i64 0
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[NONNULL]], ptr addrspace(1) null
; CHECK-NEXT:    br i1 [[COND]], label %[[MEMCPY_THEN:.*]], label %[[MEMCPY_ELSE:.*]]
; CHECK:       [[MEMCPY_JOIN:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[MEMCPY_THEN]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) [[NONNULL]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
; CHECK:       [[MEMCPY_ELSE]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) null, i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
;
entry:
  %nonnull = getelementptr inbounds [4 x i32], ptr addrspace(1) @GN, i64 0, i64 0
  %src = select i1 %cond, ptr addrspace(1) %nonnull, ptr addrspace(1) null

  call void @llvm.memcpy.p1.p1.i64(
  ptr addrspace(1) %dst, ptr addrspace(1) %src, i64 16, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; Destination is a select where one arm is null.
; Expect CFG split (no speculative stores).
;
define amdgpu_kernel void @dst_select_null_arm(ptr addrspace(1) %src, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @dst_select_null_arm(
; CHECK-SAME: ptr addrspace(1) [[SRC:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DST:%.*]] = select i1 [[COND]], ptr addrspace(1) null, ptr addrspace(1) @GN
; CHECK-NEXT:    br i1 [[COND]], label %[[MEMCPY_THEN:.*]], label %[[MEMCPY_ELSE:.*]]
; CHECK:       [[MEMCPY_JOIN:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[MEMCPY_THEN]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) null, ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
; CHECK:       [[MEMCPY_ELSE]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) @GN, ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
;
entry:
  %dst = select i1 %cond, ptr addrspace(1) null,
  ptr addrspace(1) getelementptr inbounds ([4 x i32], ptr addrspace(1) @GN, i64 0, i64 0)

  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst, ptr addrspace(1) %src, i64 16, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; Source is a select where one arm is poison.
; Expect CFG split (speculative use of poison is not allowed).
;
@GP = addrspace(1) global [4 x i32] zeroinitializer, align 16
define amdgpu_kernel void @src_select_poison_arm(ptr addrspace(1) %dst, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @src_select_poison_arm(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[NONNULL:%.*]] = getelementptr inbounds [4 x i32], ptr addrspace(1) @GP, i64 0, i64 0
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[NONNULL]], ptr addrspace(1) poison
; CHECK-NEXT:    br i1 [[COND]], label %[[MEMCPY_THEN:.*]], label %[[MEMCPY_ELSE:.*]]
; CHECK:       [[MEMCPY_JOIN:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[MEMCPY_THEN]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) [[NONNULL]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
; CHECK:       [[MEMCPY_ELSE]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) poison, i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
;
entry:
  %nonnull = getelementptr inbounds [4 x i32], ptr addrspace(1) @GP, i64 0, i64 0
  %src = select i1 %cond, ptr addrspace(1) %nonnull, ptr addrspace(1) poison

  call void @llvm.memcpy.p1.p1.i64(
  ptr addrspace(1) %dst, ptr addrspace(1) %src, i64 16, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; Destination is a select where one arm is poison.
; Expect CFG split.
;
define amdgpu_kernel void @dst_select_poison_arm(ptr addrspace(1) %src, i1 %cond) {
; CHECK-LABEL: define amdgpu_kernel void @dst_select_poison_arm(
; CHECK-SAME: ptr addrspace(1) [[SRC:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DST:%.*]] = select i1 [[COND]], ptr addrspace(1) poison, ptr addrspace(1) @GP
; CHECK-NEXT:    br i1 [[COND]], label %[[MEMCPY_THEN:.*]], label %[[MEMCPY_ELSE:.*]]
; CHECK:       [[MEMCPY_JOIN:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[MEMCPY_THEN]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) poison, ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
; CHECK:       [[MEMCPY_ELSE]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) @GP, ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
;
entry:
  %dst = select i1 %cond, ptr addrspace(1) poison,
  ptr addrspace(1) getelementptr inbounds ([4 x i32], ptr addrspace(1) @GP, i64 0, i64 0)

  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst, ptr addrspace(1) %src, i64 16, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; Non-constant memcpy length: the pass should not transform.
; Expect: memcpy remains as-is (no load/select/store, no CFG split).
;
define amdgpu_kernel void @memcpy_nonconst_length_src_select(ptr addrspace(1) %dst,
; CHECK-LABEL: define amdgpu_kernel void @memcpy_nonconst_length_src_select(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], ptr addrspace(1) [[PA:%.*]], ptr addrspace(1) [[PB:%.*]], i1 [[COND:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PA]], ptr addrspace(1) [[PB]]
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) [[SRC]], i64 [[N]], i1 false)
; CHECK-NEXT:    ret void
;
  ptr addrspace(1) %pa,
  ptr addrspace(1) %pb,
  i1 %cond, i64 %n) {
entry:
  %src = select i1 %cond, ptr addrspace(1) %pa, ptr addrspace(1) %pb
  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst,
  ptr addrspace(1) %src,
  i64 %n, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; Non-constant memcpy length with destination select: pass should not transform.
; Expect: memcpy remains, no CFG split.
;
define amdgpu_kernel void @memcpy_nonconst_length_dst_select(ptr addrspace(1) %da,
; CHECK-LABEL: define amdgpu_kernel void @memcpy_nonconst_length_dst_select(
; CHECK-SAME: ptr addrspace(1) [[DA:%.*]], ptr addrspace(1) [[DB:%.*]], ptr addrspace(1) [[SRC:%.*]], i1 [[COND:%.*]], i64 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DST:%.*]] = select i1 [[COND]], ptr addrspace(1) [[DA]], ptr addrspace(1) [[DB]]
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) [[SRC]], i64 [[N]], i1 false)
; CHECK-NEXT:    ret void
;
  ptr addrspace(1) %db,
  ptr addrspace(1) %src,
  i1 %cond, i64 %n) {
entry:
  %dst = select i1 %cond, ptr addrspace(1) %da, ptr addrspace(1) %db
  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst,
  ptr addrspace(1) %src,
  i64 %n, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; "Non-constant source" scenario: select arms are function args (not globals).
; No strong dereferenceable/align attrs -> speculation should be unsafe,
; so the pass should split CFG and materialize two memcpys.
;
define amdgpu_kernel void @memcpy_src_select_arg_arms_cfg_split(ptr addrspace(1) %dst,
; CHECK-LABEL: define amdgpu_kernel void @memcpy_src_select_arg_arms_cfg_split(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], ptr addrspace(1) [[PA:%.*]], ptr addrspace(1) [[PB:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PA]], ptr addrspace(1) [[PB]]
; CHECK-NEXT:    br i1 [[COND]], label %[[MEMCPY_THEN:.*]], label %[[MEMCPY_ELSE:.*]]
; CHECK:       [[MEMCPY_JOIN:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[MEMCPY_THEN]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) [[PA]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
; CHECK:       [[MEMCPY_ELSE]]:
; CHECK-NEXT:    call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) [[PB]], i64 16, i1 false)
; CHECK-NEXT:    br label %[[MEMCPY_JOIN]]
;
  ptr addrspace(1) %pa,
  ptr addrspace(1) %pb,
  i1 %cond) {
entry:
  %src = select i1 %cond, ptr addrspace(1) %pa, ptr addrspace(1) %pb
  call void @llvm.memcpy.p1.p1.i64(ptr addrspace(1) %dst,
  ptr addrspace(1) %src,
  i64 16, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; memmove should be ignored by the pass even with select-fed source/dest.
; Expect: memmove remains as-is (no CFG split, no speculative transform).
;
declare void @llvm.memmove.p1.p1.i64(ptr addrspace(1) nocapture writeonly,
  ptr addrspace(1) nocapture readonly,
  i64, i1 immarg)

define amdgpu_kernel void @memmove_ignored_src_select(ptr addrspace(1) %dst,
; CHECK-LABEL: define amdgpu_kernel void @memmove_ignored_src_select(
; CHECK-SAME: ptr addrspace(1) [[DST:%.*]], ptr addrspace(1) [[PA:%.*]], ptr addrspace(1) [[PB:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SRC:%.*]] = select i1 [[COND]], ptr addrspace(1) [[PA]], ptr addrspace(1) [[PB]]
; CHECK-NEXT:    call void @llvm.memmove.p1.p1.i64(ptr addrspace(1) [[DST]], ptr addrspace(1) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    ret void
;
  ptr addrspace(1) %pa,
  ptr addrspace(1) %pb,
  i1 %cond) {
entry:
  %src = select i1 %cond, ptr addrspace(1) %pa, ptr addrspace(1) %pb
  call void @llvm.memmove.p1.p1.i64(ptr addrspace(1) %dst,
  ptr addrspace(1) %src,
  i64 16, i1 false)
  ret void
}
; -----------------------------------------------------------------------------
; memset should be ignored by the pass, even if destination is a select.
; Expect: memset remains as-is (no CFG split).
;
declare void @llvm.memset.p1.i64(ptr addrspace(1) nocapture writeonly,
  i8, i64, i1 immarg)

define amdgpu_kernel void @memset_ignored_dst_select(ptr addrspace(1) %da,
; CHECK-LABEL: define amdgpu_kernel void @memset_ignored_dst_select(
; CHECK-SAME: ptr addrspace(1) [[DA:%.*]], ptr addrspace(1) [[DB:%.*]], i1 [[COND:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[DST:%.*]] = select i1 [[COND]], ptr addrspace(1) [[DA]], ptr addrspace(1) [[DB]]
; CHECK-NEXT:    call void @llvm.memset.p1.i64(ptr addrspace(1) [[DST]], i8 0, i64 16, i1 false)
; CHECK-NEXT:    ret void
;
  ptr addrspace(1) %db,
  i1 %cond) {
entry:
  %dst = select i1 %cond, ptr addrspace(1) %da, ptr addrspace(1) %db
  call void @llvm.memset.p1.i64(ptr addrspace(1) %dst, i8 0, i64 16, i1 false)
  ret void
}
