; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx942 -passes='amdgpu-attributor,amdgpu-preload-kernel-arguments,function(amdgpu-lower-kernel-arguments)' -amdgpu-kernarg-preload=0 -S < %s | FileCheck -check-prefix=NO-PRELOAD %s
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx942 -passes='amdgpu-attributor,amdgpu-preload-kernel-arguments,function(amdgpu-lower-kernel-arguments)' -amdgpu-kernarg-preload-count=3 -S < %s | FileCheck -check-prefix=PRELOAD-3 %s

; Test preloading of aggregate types (structs and arrays) without pointers.

%struct.SimplePair = type { i32, i32 }
%struct.ThreeInts = type { i32, i32, i32 }
%struct.MixedPair = type { i32, float }
%struct.Nested = type { %struct.SimplePair, i32 }
%struct.DeeplyNested = type { %struct.Nested, float }
%struct.WithPointer = type { i32, ptr addrspace(1) }
%struct.NestedWithPointer = type { %struct.SimplePair, ptr addrspace(1) }
%struct.DeeplyNestedWithPointer = type { %struct.Nested, ptr addrspace(1) }
%struct.ArrayInStruct = type { [4 x i32] }

define amdgpu_kernel void @test_preload_struct_simple(%struct.SimplePair %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_struct_simple
; NO-PRELOAD-SAME: ([[STRUCT_SIMPLEPAIR:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_STRUCT_SIMPLE_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(16) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_SIMPLE_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_SIMPLEPAIR]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0:![0-9]+]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_SIMPLE_KERNARG_SEGMENT]], i64 8
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG_LOAD]], 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG_LOAD]], 1
; NO-PRELOAD-NEXT:    [[SUM:%.*]] = add i32 [[VAL0]], [[VAL1]]
; NO-PRELOAD-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_struct_simple
; PRELOAD-3-SAME: ([[STRUCT_SIMPLEPAIR:%.*]] inreg [[ARG:%.*]], ptr addrspace(1) inreg [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_STRUCT_SIMPLE_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(16) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG]], 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG]], 1
; PRELOAD-3-NEXT:    [[SUM:%.*]] = add i32 [[VAL0]], [[VAL1]]
; PRELOAD-3-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.SimplePair %arg, 0
  %val1 = extractvalue %struct.SimplePair %arg, 1
  %sum = add i32 %val0, %val1
  store i32 %sum, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_preload_struct_mixed(%struct.MixedPair %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_struct_mixed
; NO-PRELOAD-SAME: ([[STRUCT_MIXEDPAIR:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_STRUCT_MIXED_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(16) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_MIXED_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_MIXEDPAIR]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_MIXED_KERNARG_SEGMENT]], i64 8
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_MIXEDPAIR]] [[ARG_LOAD]], 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_MIXEDPAIR]] [[ARG_LOAD]], 1
; NO-PRELOAD-NEXT:    [[CONV:%.*]] = sitofp i32 [[VAL0]] to float
; NO-PRELOAD-NEXT:    [[SUM:%.*]] = fadd float [[CONV]], [[VAL1]]
; NO-PRELOAD-NEXT:    store float [[SUM]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_struct_mixed
; PRELOAD-3-SAME: ([[STRUCT_MIXEDPAIR:%.*]] inreg [[ARG:%.*]], ptr addrspace(1) inreg [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_STRUCT_MIXED_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(16) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_MIXEDPAIR]] [[ARG]], 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_MIXEDPAIR]] [[ARG]], 1
; PRELOAD-3-NEXT:    [[CONV:%.*]] = sitofp i32 [[VAL0]] to float
; PRELOAD-3-NEXT:    [[SUM:%.*]] = fadd float [[CONV]], [[VAL1]]
; PRELOAD-3-NEXT:    store float [[SUM]], ptr addrspace(1) [[OUT]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.MixedPair %arg, 0
  %val1 = extractvalue %struct.MixedPair %arg, 1
  %conv = sitofp i32 %val0 to float
  %sum = fadd float %conv, %val1
  store float %sum, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_preload_struct_nested(%struct.Nested %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_struct_nested
; NO-PRELOAD-SAME: ([[STRUCT_NESTED:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_STRUCT_NESTED_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_NESTED_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_NESTED]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_NESTED_KERNARG_SEGMENT]], i64 16
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_NESTED]] [[ARG_LOAD]], 0, 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_NESTED]] [[ARG_LOAD]], 0, 1
; NO-PRELOAD-NEXT:    [[VAL2:%.*]] = extractvalue [[STRUCT_NESTED]] [[ARG_LOAD]], 1
; NO-PRELOAD-NEXT:    [[SUM0:%.*]] = add i32 [[VAL0]], [[VAL1]]
; NO-PRELOAD-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL2]]
; NO-PRELOAD-NEXT:    store i32 [[SUM1]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_struct_nested
; PRELOAD-3-SAME: ([[STRUCT_NESTED:%.*]] inreg [[ARG:%.*]], ptr addrspace(1) inreg [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_STRUCT_NESTED_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_NESTED]] [[ARG]], 0, 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_NESTED]] [[ARG]], 0, 1
; PRELOAD-3-NEXT:    [[VAL2:%.*]] = extractvalue [[STRUCT_NESTED]] [[ARG]], 1
; PRELOAD-3-NEXT:    [[SUM0:%.*]] = add i32 [[VAL0]], [[VAL1]]
; PRELOAD-3-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL2]]
; PRELOAD-3-NEXT:    store i32 [[SUM1]], ptr addrspace(1) [[OUT]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.Nested %arg, 0, 0
  %val1 = extractvalue %struct.Nested %arg, 0, 1
  %val2 = extractvalue %struct.Nested %arg, 1
  %sum0 = add i32 %val0, %val1
  %sum1 = add i32 %sum0, %val2
  store i32 %sum1, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_preload_struct_deeply_nested(%struct.DeeplyNested %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_struct_deeply_nested
; NO-PRELOAD-SAME: ([[STRUCT_DEEPLYNESTED:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_STRUCT_DEEPLY_NESTED_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_DEEPLY_NESTED_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_DEEPLYNESTED]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_DEEPLY_NESTED_KERNARG_SEGMENT]], i64 16
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG_LOAD]], 0, 0, 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG_LOAD]], 0, 0, 1
; NO-PRELOAD-NEXT:    [[VAL2:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG_LOAD]], 0, 1
; NO-PRELOAD-NEXT:    [[VALF:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG_LOAD]], 1
; NO-PRELOAD-NEXT:    [[SUM0:%.*]] = add i32 [[VAL0]], [[VAL1]]
; NO-PRELOAD-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL2]]
; NO-PRELOAD-NEXT:    [[CONV:%.*]] = sitofp i32 [[SUM1]] to float
; NO-PRELOAD-NEXT:    [[SUM2:%.*]] = fadd float [[CONV]], [[VALF]]
; NO-PRELOAD-NEXT:    store float [[SUM2]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_struct_deeply_nested
; PRELOAD-3-SAME: ([[STRUCT_DEEPLYNESTED:%.*]] inreg [[ARG:%.*]], ptr addrspace(1) inreg [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_STRUCT_DEEPLY_NESTED_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG]], 0, 0, 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG]], 0, 0, 1
; PRELOAD-3-NEXT:    [[VAL2:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG]], 0, 1
; PRELOAD-3-NEXT:    [[VALF:%.*]] = extractvalue [[STRUCT_DEEPLYNESTED]] [[ARG]], 1
; PRELOAD-3-NEXT:    [[SUM0:%.*]] = add i32 [[VAL0]], [[VAL1]]
; PRELOAD-3-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL2]]
; PRELOAD-3-NEXT:    [[CONV:%.*]] = sitofp i32 [[SUM1]] to float
; PRELOAD-3-NEXT:    [[SUM2:%.*]] = fadd float [[CONV]], [[VALF]]
; PRELOAD-3-NEXT:    store float [[SUM2]], ptr addrspace(1) [[OUT]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.DeeplyNested %arg, 0, 0, 0
  %val1 = extractvalue %struct.DeeplyNested %arg, 0, 0, 1
  %val2 = extractvalue %struct.DeeplyNested %arg, 0, 1
  %valf = extractvalue %struct.DeeplyNested %arg, 1
  %sum0 = add i32 %val0, %val1
  %sum1 = add i32 %sum0, %val2
  %conv = sitofp i32 %sum1 to float
  %sum2 = fadd float %conv, %valf
  store float %sum2, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_preload_array([4 x i32] %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_array
; NO-PRELOAD-SAME: ([4 x i32] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_ARRAY_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_ARRAY_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [4 x i32], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_ARRAY_KERNARG_SEGMENT]], i64 16
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [4 x i32] [[ARG_LOAD]], 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [4 x i32] [[ARG_LOAD]], 1
; NO-PRELOAD-NEXT:    [[VAL2:%.*]] = extractvalue [4 x i32] [[ARG_LOAD]], 2
; NO-PRELOAD-NEXT:    [[VAL3:%.*]] = extractvalue [4 x i32] [[ARG_LOAD]], 3
; NO-PRELOAD-NEXT:    [[SUM0:%.*]] = add i32 [[VAL0]], [[VAL1]]
; NO-PRELOAD-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL2]]
; NO-PRELOAD-NEXT:    [[SUM2:%.*]] = add i32 [[SUM1]], [[VAL3]]
; NO-PRELOAD-NEXT:    store i32 [[SUM2]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_array
; PRELOAD-3-SAME: ([4 x i32] inreg [[ARG:%.*]], ptr addrspace(1) inreg [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_ARRAY_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [4 x i32] [[ARG]], 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [4 x i32] [[ARG]], 1
; PRELOAD-3-NEXT:    [[VAL2:%.*]] = extractvalue [4 x i32] [[ARG]], 2
; PRELOAD-3-NEXT:    [[VAL3:%.*]] = extractvalue [4 x i32] [[ARG]], 3
; PRELOAD-3-NEXT:    [[SUM0:%.*]] = add i32 [[VAL0]], [[VAL1]]
; PRELOAD-3-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL2]]
; PRELOAD-3-NEXT:    [[SUM2:%.*]] = add i32 [[SUM1]], [[VAL3]]
; PRELOAD-3-NEXT:    store i32 [[SUM2]], ptr addrspace(1) [[OUT]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue [4 x i32] %arg, 0
  %val1 = extractvalue [4 x i32] %arg, 1
  %val2 = extractvalue [4 x i32] %arg, 2
  %val3 = extractvalue [4 x i32] %arg, 3
  %sum0 = add i32 %val0, %val1
  %sum1 = add i32 %sum0, %val2
  %sum2 = add i32 %sum1, %val3
  store i32 %sum2, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_preload_struct_with_array(%struct.ArrayInStruct %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_struct_with_array
; NO-PRELOAD-SAME: ([[STRUCT_ARRAYINSTRUCT:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_STRUCT_WITH_ARRAY_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_WITH_ARRAY_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_ARRAYINSTRUCT]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STRUCT_WITH_ARRAY_KERNARG_SEGMENT]], i64 16
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_ARRAYINSTRUCT]] [[ARG_LOAD]], 0, 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_ARRAYINSTRUCT]] [[ARG_LOAD]], 0, 1
; NO-PRELOAD-NEXT:    [[SUM:%.*]] = add i32 [[VAL0]], [[VAL1]]
; NO-PRELOAD-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_struct_with_array
; PRELOAD-3-SAME: ([[STRUCT_ARRAYINSTRUCT:%.*]] inreg [[ARG:%.*]], ptr addrspace(1) inreg [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_STRUCT_WITH_ARRAY_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_ARRAYINSTRUCT]] [[ARG]], 0, 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_ARRAYINSTRUCT]] [[ARG]], 0, 1
; PRELOAD-3-NEXT:    [[SUM:%.*]] = add i32 [[VAL0]], [[VAL1]]
; PRELOAD-3-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.ArrayInStruct %arg, 0, 0
  %val1 = extractvalue %struct.ArrayInStruct %arg, 0, 1
  %sum = add i32 %val0, %val1
  store i32 %sum, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_no_preload_struct_with_pointer(%struct.WithPointer %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_no_preload_struct_with_pointer
; NO-PRELOAD-SAME: ([[STRUCT_WITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_NO_PRELOAD_STRUCT_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_WITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 16
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_WITHPOINTER]] [[ARG_LOAD]], 0
; NO-PRELOAD-NEXT:    store i32 [[VAL0]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_no_preload_struct_with_pointer
; PRELOAD-3-SAME: ([[STRUCT_WITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_NO_PRELOAD_STRUCT_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 0
; PRELOAD-3-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_WITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0:![0-9]+]]
; PRELOAD-3-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 16
; PRELOAD-3-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_WITHPOINTER]] [[ARG_LOAD]], 0
; PRELOAD-3-NEXT:    store i32 [[VAL0]], ptr addrspace(1) [[OUT_LOAD]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.WithPointer %arg, 0
  store i32 %val0, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_no_preload_struct_nested_with_pointer(%struct.NestedWithPointer %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_no_preload_struct_nested_with_pointer
; NO-PRELOAD-SAME: ([[STRUCT_NESTEDWITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_NO_PRELOAD_STRUCT_NESTED_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_NESTEDWITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 16
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_NESTEDWITHPOINTER]] [[ARG_LOAD]], 0, 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_NESTEDWITHPOINTER]] [[ARG_LOAD]], 0, 1
; NO-PRELOAD-NEXT:    [[SUM:%.*]] = add i32 [[VAL0]], [[VAL1]]
; NO-PRELOAD-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_no_preload_struct_nested_with_pointer
; PRELOAD-3-SAME: ([[STRUCT_NESTEDWITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_NO_PRELOAD_STRUCT_NESTED_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 0
; PRELOAD-3-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_NESTEDWITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 16
; PRELOAD-3-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_NESTEDWITHPOINTER]] [[ARG_LOAD]], 0, 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_NESTEDWITHPOINTER]] [[ARG_LOAD]], 0, 1
; PRELOAD-3-NEXT:    [[SUM:%.*]] = add i32 [[VAL0]], [[VAL1]]
; PRELOAD-3-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT_LOAD]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.NestedWithPointer %arg, 0, 0
  %val1 = extractvalue %struct.NestedWithPointer %arg, 0, 1
  %sum = add i32 %val0, %val1
  store i32 %sum, ptr addrspace(1) %out
  ret void
}

; Deeply nested struct with pointer - should NOT be preloaded
define amdgpu_kernel void @test_no_preload_struct_deeply_nested_with_pointer(%struct.DeeplyNestedWithPointer %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_no_preload_struct_deeply_nested_with_pointer
; NO-PRELOAD-SAME: ([[STRUCT_DEEPLYNESTEDWITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_NO_PRELOAD_STRUCT_DEEPLY_NESTED_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(32) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_DEEPLY_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_DEEPLYNESTEDWITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_DEEPLY_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 24
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_DEEPLYNESTEDWITHPOINTER]] [[ARG_LOAD]], 0, 0, 0
; NO-PRELOAD-NEXT:    store i32 [[VAL0]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_no_preload_struct_deeply_nested_with_pointer
; PRELOAD-3-SAME: ([[STRUCT_DEEPLYNESTEDWITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_NO_PRELOAD_STRUCT_DEEPLY_NESTED_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(32) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_DEEPLY_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 0
; PRELOAD-3-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_DEEPLYNESTEDWITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_STRUCT_DEEPLY_NESTED_WITH_POINTER_KERNARG_SEGMENT]], i64 24
; PRELOAD-3-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_DEEPLYNESTEDWITHPOINTER]] [[ARG_LOAD]], 0, 0, 0
; PRELOAD-3-NEXT:    store i32 [[VAL0]], ptr addrspace(1) [[OUT_LOAD]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.DeeplyNestedWithPointer %arg, 0, 0, 0
  store i32 %val0, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_no_preload_array_of_pointers([4 x ptr addrspace(1)] %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_no_preload_array_of_pointers
; NO-PRELOAD-SAME: ([4 x ptr addrspace(1)] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_NO_PRELOAD_ARRAY_OF_POINTERS_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(40) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_ARRAY_OF_POINTERS_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [4 x ptr addrspace(1)], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_ARRAY_OF_POINTERS_KERNARG_SEGMENT]], i64 32
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[PTR0:%.*]] = extractvalue [4 x ptr addrspace(1)] [[ARG_LOAD]], 0
; NO-PRELOAD-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR0]], align 4
; NO-PRELOAD-NEXT:    store i32 [[VAL]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_no_preload_array_of_pointers
; PRELOAD-3-SAME: ([4 x ptr addrspace(1)] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_NO_PRELOAD_ARRAY_OF_POINTERS_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(40) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_ARRAY_OF_POINTERS_KERNARG_SEGMENT]], i64 0
; PRELOAD-3-NEXT:    [[ARG_LOAD:%.*]] = load [4 x ptr addrspace(1)], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_NO_PRELOAD_ARRAY_OF_POINTERS_KERNARG_SEGMENT]], i64 32
; PRELOAD-3-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[PTR0:%.*]] = extractvalue [4 x ptr addrspace(1)] [[ARG_LOAD]], 0
; PRELOAD-3-NEXT:    [[VAL:%.*]] = load i32, ptr addrspace(1) [[PTR0]], align 4
; PRELOAD-3-NEXT:    store i32 [[VAL]], ptr addrspace(1) [[OUT_LOAD]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %ptr0 = extractvalue [4 x ptr addrspace(1)] %arg, 0
  %val = load i32, ptr addrspace(1) %ptr0
  store i32 %val, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_preload_stops_at_struct_with_pointer(i32 %scalar, %struct.WithPointer %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_stops_at_struct_with_pointer
; NO-PRELOAD-SAME: (i32 [[SCALAR:%.*]], [[STRUCT_WITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_STOPS_AT_STRUCT_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(32) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[SCALAR_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STOPS_AT_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[SCALAR_LOAD:%.*]] = load i32, ptr addrspace(4) [[SCALAR_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STOPS_AT_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 8
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_WITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STOPS_AT_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 24
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_WITHPOINTER]] [[ARG_LOAD]], 0
; NO-PRELOAD-NEXT:    [[SUM:%.*]] = add i32 [[SCALAR_LOAD]], [[VAL0]]
; NO-PRELOAD-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_stops_at_struct_with_pointer
; PRELOAD-3-SAME: (i32 inreg [[SCALAR:%.*]], [[STRUCT_WITHPOINTER:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_STOPS_AT_STRUCT_WITH_POINTER_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(32) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STOPS_AT_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 8
; PRELOAD-3-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_WITHPOINTER]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_STOPS_AT_STRUCT_WITH_POINTER_KERNARG_SEGMENT]], i64 24
; PRELOAD-3-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 8, !invariant.load [[META0]]
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_WITHPOINTER]] [[ARG_LOAD]], 0
; PRELOAD-3-NEXT:    [[SUM:%.*]] = add i32 [[SCALAR]], [[VAL0]]
; PRELOAD-3-NEXT:    store i32 [[SUM]], ptr addrspace(1) [[OUT_LOAD]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.WithPointer %arg, 0
  %sum = add i32 %scalar, %val0
  store i32 %sum, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @test_preload_scalar_and_struct(i32 %scalar, %struct.SimplePair %arg, ptr addrspace(1) %out) {
; NO-PRELOAD-LABEL: define {{[^@]+}}@test_preload_scalar_and_struct
; NO-PRELOAD-SAME: (i32 [[SCALAR:%.*]], [[STRUCT_SIMPLEPAIR:%.*]] [[ARG:%.*]], ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; NO-PRELOAD-NEXT:    [[TEST_PRELOAD_SCALAR_AND_STRUCT_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; NO-PRELOAD-NEXT:    [[SCALAR_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_SCALAR_AND_STRUCT_KERNARG_SEGMENT]], i64 0
; NO-PRELOAD-NEXT:    [[SCALAR_LOAD:%.*]] = load i32, ptr addrspace(4) [[SCALAR_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[ARG_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_SCALAR_AND_STRUCT_KERNARG_SEGMENT]], i64 4
; NO-PRELOAD-NEXT:    [[ARG_LOAD:%.*]] = load [[STRUCT_SIMPLEPAIR]], ptr addrspace(4) [[ARG_KERNARG_OFFSET]], align 4, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[OUT_KERNARG_OFFSET:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[TEST_PRELOAD_SCALAR_AND_STRUCT_KERNARG_SEGMENT]], i64 16
; NO-PRELOAD-NEXT:    [[OUT_LOAD:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[OUT_KERNARG_OFFSET]], align 16, !invariant.load [[META0]]
; NO-PRELOAD-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG_LOAD]], 0
; NO-PRELOAD-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG_LOAD]], 1
; NO-PRELOAD-NEXT:    [[SUM0:%.*]] = add i32 [[SCALAR_LOAD]], [[VAL0]]
; NO-PRELOAD-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL1]]
; NO-PRELOAD-NEXT:    store i32 [[SUM1]], ptr addrspace(1) [[OUT_LOAD]], align 4
; NO-PRELOAD-NEXT:    ret void
;
; PRELOAD-3-LABEL: define {{[^@]+}}@test_preload_scalar_and_struct
; PRELOAD-3-SAME: (i32 inreg [[SCALAR:%.*]], [[STRUCT_SIMPLEPAIR:%.*]] inreg [[ARG:%.*]], ptr addrspace(1) inreg [[OUT:%.*]]) #[[ATTR0]] {
; PRELOAD-3-NEXT:    [[TEST_PRELOAD_SCALAR_AND_STRUCT_KERNARG_SEGMENT:%.*]] = call nonnull align 16 dereferenceable(24) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
; PRELOAD-3-NEXT:    [[VAL0:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG]], 0
; PRELOAD-3-NEXT:    [[VAL1:%.*]] = extractvalue [[STRUCT_SIMPLEPAIR]] [[ARG]], 1
; PRELOAD-3-NEXT:    [[SUM0:%.*]] = add i32 [[SCALAR]], [[VAL0]]
; PRELOAD-3-NEXT:    [[SUM1:%.*]] = add i32 [[SUM0]], [[VAL1]]
; PRELOAD-3-NEXT:    store i32 [[SUM1]], ptr addrspace(1) [[OUT]], align 4
; PRELOAD-3-NEXT:    ret void
;
  %val0 = extractvalue %struct.SimplePair %arg, 0
  %val1 = extractvalue %struct.SimplePair %arg, 1
  %sum0 = add i32 %scalar, %val0
  %sum1 = add i32 %sum0, %val1
  store i32 %sum1, ptr addrspace(1) %out
  ret void
}
