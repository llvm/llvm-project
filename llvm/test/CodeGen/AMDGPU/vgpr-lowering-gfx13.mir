# NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
# RUN: llc -march=amdgcn -mcpu=gfx1300 -verify-machineinstrs -start-before=amdgpu-lower-vgpr-encoding -o - %s | FileCheck -check-prefixes=GCN,ASM %s
# RUN: llc -march=amdgcn -mcpu=gfx1300 -start-before=amdgpu-lower-vgpr-encoding -o - %s | llvm-mc -arch=amdgcn -mcpu=gfx1300 -filetype=obj -o - | llvm-objdump -d --mcpu=gfx1300 - | FileCheck -check-prefixes=GCN,DIS %s

# ASM-LABEL: {{^}}high_vgprs:
# DIS-LABEL: <high_vgprs>:
---
name:            high_vgprs
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:

    ; VOP1

    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: v_mov_b32_e32 v256, v511
    $vgpr256 = V_MOV_B32_e32 undef $vgpr511, implicit $exec

    ; No mask change
    ; GCN-NEXT: v_mov_b32_e32 v257, v510
    $vgpr257 = V_MOV_B32_e32 undef $vgpr510, implicit $exec

    ; Single bit change
    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_rcp_f32_e64 v255, v258
    $vgpr255 = V_RCP_F32_e64 0, undef $vgpr258, 0, 0, implicit $exec, implicit $mode

    ; Reset
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_rcp_f32_e64 v255, v1
    $vgpr255 = V_RCP_F32_e64 0, undef $vgpr1, 0, 0, implicit $exec, implicit $mode

    ; VOP2

    ; GCN-NEXT: s_set_vgpr_frames 0x500
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=1 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_add_nc_u32_e32 v0, v509, v508
    $vgpr0 = V_ADD_U32_e32 undef $vgpr509, undef $vgpr508, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4400
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=1 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: s_delay_alu instid0(VALU_DEP_1)
    ; GCN-NEXT: v_add_f32_e64 v258, v0, v507
    $vgpr258 = V_ADD_F32_e64 0, $vgpr0, 0, undef $vgpr507, 0, 0, implicit $exec, implicit $mode

    ; VOP3

    ; GCN-NEXT: s_set_vgpr_frames 0x5500
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=1 vsrc2_msb=1 vdst_msb=1
    ; GCN-NEXT: v_fma_f32 v259, v260, v261, v262
    $vgpr259 = V_FMA_F32_e64 0, undef $vgpr260, 0, undef $vgpr261, 0, undef $vgpr262, 0, 0, implicit $exec, implicit $mode

    ; No change
    ; GCN-NEXT: v_fma_f32 v259, v260, v261, v262
    $vgpr259 = V_FMA_F32_e64 0, undef $vgpr260, 0, undef $vgpr261, 0, undef $vgpr262, 0, 0, implicit $exec, implicit $mode

    ; Tuple crossing the 256 boundary
    ; GCN-NEXT: s_set_vgpr_frames 0x1100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=1 vdst_msb=0
    ; GCN-NEXT: v_mqsad_u32_u8 v[254:257], v[258:259], v0, v[500:503]
    $vgpr254_vgpr255_vgpr256_vgpr257 = V_MQSAD_U32_U8_e64 $vgpr258_vgpr259, $vgpr0, undef $vgpr500_vgpr501_vgpr502_vgpr503, 0, implicit $exec

    ; DPP/tied operand
    ; GCN-NEXT: s_set_vgpr_frames 0x4500
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=1 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: s_delay_alu instid0(VALU_DEP_1)
    ; GCN-NEXT: v_add_nc_u16_e64_dpp v256, v257, v258 quad_perm:[1,0,0,0] row_mask:0xf bank_mask:0xf bound_ctrl:1
    $vgpr256 = V_ADD_NC_U16_fake16_e64_dpp $vgpr256, 0, $vgpr257, 0, undef $vgpr258, 0, 0, 1, 15, 15, 1, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x1100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=1 vdst_msb=0
    ; GCN-NEXT: v_add3_u32_e64_dpp v0, v257, v0, v258 quad_perm:[1,0,0,0] row_mask:0xf bank_mask:0xf bound_ctrl:1
    $vgpr0 = V_ADD3_U32_e64_dpp $vgpr0, $vgpr257, $vgpr0, undef $vgpr258, 1, 15, 15, 1, implicit $exec

    ; DS (addr, data0, and data1 operands)

    ; GCN-NEXT: s_set_vgpr_frames 0x1400
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=1 vsrc2_msb=1 vdst_msb=0
    ; GCN-NEXT: ds_store_2addr_b32 v0, v504, v505 offset1:1
    DS_WRITE2_B32_gfx9 $vgpr0, undef $vgpr504, undef $vgpr505, 0, 1, 0, implicit $exec

    ; Reset
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: ds_store_2addr_b32 v0, v248, v249 offset1:1
    DS_WRITE2_B32_gfx9 $vgpr0, undef $vgpr248, undef $vgpr249, 0, 1, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: ds_load_b32 v0, v511
    $vgpr0 = DS_READ_B32_gfx9 $vgpr511, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4400
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=1 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: ds_add_rtn_u32 v511, v0, v504
    $vgpr511 = DS_ADD_RTN_U32_gfx9 $vgpr0, undef $vgpr504, 0, 0, implicit $exec

    ; Reset
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: ds_add_rtn_u32 v0, v0, v0
    $vgpr0 = DS_ADD_RTN_U32_gfx9 $vgpr0, $vgpr0, 0, 0, implicit $exec

    ; FLAT (vaddr, vdata and vdst operands)

    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: global_load_b32 v2, v[258:259], off
    $vgpr2 = GLOBAL_LOAD_DWORD undef $vgpr258_vgpr259, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: global_load_b32 v511, v0, s[0:1]
    $vgpr511 = GLOBAL_LOAD_DWORD_SADDR undef $sgpr0_sgpr1, $vgpr0, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: scratch_load_u8 v0, v511, s0
    $vgpr0 = SCRATCH_LOAD_UBYTE_SVS $vgpr511, undef $sgpr0, 0, 0, implicit $exec, implicit $flat_scr

    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: global_store_b32 v[0:1], v2, off
    GLOBAL_STORE_DWORD $vgpr0_vgpr1, $vgpr2, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x500
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=1 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: global_store_b32 v[256:257], v511, off
    GLOBAL_STORE_DWORD $vgpr256_vgpr257, $vgpr511, 0, 0, implicit $exec

    ; No change
    ; GCN-NEXT: global_store_b96 v[256:257], v[500:502], off
    GLOBAL_STORE_DWORDX3 $vgpr256_vgpr257, $vgpr500_vgpr501_vgpr502, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4400
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=1 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: flat_atomic_add_u32 v510, v[0:1], v511 th:TH_ATOMIC_RETURN
    $vgpr510 = FLAT_ATOMIC_ADD_RTN $vgpr0_vgpr1, $vgpr511, 0, 1, implicit $exec, implicit $flat_scr

    ; Reset
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: flat_atomic_add_u32 v0, v[0:1], v255 th:TH_ATOMIC_RETURN
    $vgpr0 = FLAT_ATOMIC_ADD_RTN $vgpr0_vgpr1, $vgpr255, 0, 1, implicit $exec, implicit $flat_scr

    ; VBUFFER (vdata, vaddr operands)

    ; GCN-NEXT: buffer_load_b32 v1, v0, s[8:11], s3 offen
    $vgpr1 = BUFFER_LOAD_DWORD_VBUFFER_OFFEN $vgpr0, undef $sgpr8_sgpr9_sgpr10_sgpr11, undef $sgpr3, 0, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: buffer_load_b32 v257, v0, s[8:11], s3 offen
    $vgpr257 = BUFFER_LOAD_DWORD_VBUFFER_OFFEN $vgpr0, undef $sgpr8_sgpr9_sgpr10_sgpr11, undef $sgpr3, 0, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: buffer_load_b32 v257, v256, s[8:11], s3 offen
    $vgpr257 = BUFFER_LOAD_DWORD_VBUFFER_OFFEN $vgpr256, undef $sgpr8_sgpr9_sgpr10_sgpr11, undef $sgpr3, 0, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: buffer_store_b32 v0, v1, s[0:3], s3 offen
    BUFFER_STORE_DWORD_VBUFFER_OFFEN $vgpr0, $vgpr1, undef $sgpr0_sgpr1_sgpr2_sgpr3, undef $sgpr3, 0, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: buffer_store_b32 v256, v257, s[0:3], s3 offen
    BUFFER_STORE_DWORD_VBUFFER_OFFEN $vgpr256, $vgpr257, undef $sgpr0_sgpr1_sgpr2_sgpr3, undef $sgpr3, 0, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: buffer_atomic_add_f32 v0, v1, s[0:3], s3 offen
    BUFFER_ATOMIC_ADD_F32_VBUFFER_OFFEN $vgpr0, $vgpr1, undef $sgpr0_sgpr1_sgpr2_sgpr3, undef $sgpr3, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: buffer_atomic_add_f32 v256, v257, s[0:3], s3 offen
    BUFFER_ATOMIC_ADD_F32_VBUFFER_OFFEN $vgpr256, $vgpr257, undef $sgpr0_sgpr1_sgpr2_sgpr3, undef $sgpr3, 0, 0, implicit $exec

    ; VGPRs above 512

    ; GCN-NEXT: s_set_vgpr_frames 0xaa00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=2 vsrc1_msb=2 vsrc2_msb=2 vdst_msb=2
    ; GCN-NEXT: v_fma_f32 v512, v513, v514, v515
    $vgpr512 = V_FMA_F32_e64 0, undef $vgpr513, 0, undef $vgpr514, 0, undef $vgpr515, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0xab00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=3 vsrc1_msb=2 vsrc2_msb=2 vdst_msb=2
    ; GCN-NEXT: v_fma_f32 v512, v768, v514, v515
    $vgpr512 = V_FMA_F32_e64 0, undef $vgpr768, 0, undef $vgpr514, 0, undef $vgpr515, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0xae00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=2 vsrc1_msb=3 vsrc2_msb=2 vdst_msb=2
    ; GCN-NEXT: v_fma_f32 v512, v513, v770, v515
    $vgpr512 = V_FMA_F32_e64 0, undef $vgpr513, 0, undef $vgpr770, 0, undef $vgpr515, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0xba00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=2 vsrc1_msb=2 vsrc2_msb=3 vdst_msb=2
    ; GCN-NEXT: v_fma_f32 v512, v513, v514, v771
    $vgpr512 = V_FMA_F32_e64 0, undef $vgpr513, 0, undef $vgpr514, 0, undef $vgpr771, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0xea00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=2 vsrc1_msb=2 vsrc2_msb=2 vdst_msb=3
    ; GCN-NEXT: v_fma_f32 v1023, v513, v514, v515
    $vgpr1023 = V_FMA_F32_e64 0, undef $vgpr513, 0, undef $vgpr514, 0, undef $vgpr515, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0xff00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=3 vsrc1_msb=3 vsrc2_msb=3 vdst_msb=3
    ; GCN-NEXT: v_fma_f32 v768, v769, v770, v771
    $vgpr768 = V_FMA_F32_e64 0, undef $vgpr769, 0, undef $vgpr770, 0, undef $vgpr771, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x4200
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=2 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: v_mov_b32_e32 v256, v512
    $vgpr256 = V_MOV_B32_e32 undef $vgpr512, implicit $exec

    ; Reset

    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_fma_f32 v0, v1, v2, v3
    $vgpr0 = V_FMA_F32_e64 0, undef $vgpr1, 0, undef $vgpr2, 0, undef $vgpr3, 0, 0, implicit $exec, implicit $mode

    ; Tuples

    ; GCN-NEXT: s_set_vgpr_frames 0xa00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=2 vsrc1_msb=2 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: global_store_b96 v[512:513], v[512:514], off
    GLOBAL_STORE_DWORDX3 $vgpr512_vgpr513, $vgpr512_vgpr513_vgpr514, 0, 0, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0xb00
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=3 vsrc1_msb=2 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: global_store_b64 v[1022:1023], v[766:767], off
    GLOBAL_STORE_DWORDX2 $vgpr1022_vgpr1023, $vgpr766_vgpr767, 0, 0, implicit $exec

    ; ASM: NumVgprs: 1024

...

# ASM-LABEL: {{^}}fmaak_fmamk:
# DIS-LABEL: <fmaak_fmamk>:
---
name:            fmaak_fmamk
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:

    ; GCN-NEXT: s_set_vgpr_frames 0x4500
    ; GCN-NEXT: v_fmaak_f32 v256, v257, v258, 0x1
    $vgpr256 = V_FMAAK_F32 undef $vgpr257, undef $vgpr258, 1, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x500
    ; GCN-NEXT: v_fmaak_f32 v0, v257, v258, 0x1
    $vgpr0 = V_FMAAK_F32 undef $vgpr257, undef $vgpr258, 1, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; GCN-NEXT: v_fmaak_f32 v256, v257, v2, 0x1
    $vgpr256 = V_FMAAK_F32 undef $vgpr257, undef $vgpr2, 1, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x4400
    ; GCN-NEXT: v_fmaak_f32 v256, v1, v258, 0x1
    $vgpr256 = V_FMAAK_F32 undef $vgpr1, undef $vgpr258, 1, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x4500
    ; GCN-NEXT: v_fmamk_f32 v256, v257, 0x1, v258
    $vgpr256 = V_FMAMK_F32 undef $vgpr257, 1, undef $vgpr258, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x500
    ; GCN-NEXT: v_fmamk_f32 v0, v257, 0x1, v258
    $vgpr0 = V_FMAMK_F32 undef $vgpr257, 1, undef $vgpr258, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; GCN-NEXT: v_fmamk_f32 v256, v257, 0x1, v2
    $vgpr256 = V_FMAMK_F32 undef $vgpr257, 1, undef $vgpr2, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x4400
    ; GCN-NEXT: v_fmamk_f32 v256, v1, 0x1, v258
    $vgpr256 = V_FMAMK_F32 undef $vgpr1, 1, undef $vgpr258, implicit $exec, implicit $mode

    ; ASM: NumVgprs: 259

...

# ASM-LABEL: {{^}}fmac:
# DIS-LABEL: <fmac>:
---
name:            fmac
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:

    ; Accumulation instructions apply DST to both the destination and one of the source VGPRs
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_fmac_f32_e64 v256, |v0|, |v1| clamp mul:4
    $vgpr256 = V_FMAC_F32_e64 2, undef $vgpr0, 2, undef $vgpr1, 2, undef $vgpr256, 1, 2, implicit $mode, implicit $exec

    ; ASM: NumVgprs: 257

...

# ASM-LABEL: {{^}}rev_opcodes:
# DIS-LABEL: <rev_opcodes>:
---
name:            rev_opcodes
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:

    ; V_LSHLREV, V_SUBREV: SRC0 and SRC1 apply to the operands in the order in the ISA (before "reversing")
    ; e.g. v_lshlrev_b32 v0(vdst), v1(src0), v2(src1) // v0 = v2 << v1
    ; DST applies to V0, SRC0 applies to V1, and SRC1 applies to V2.

    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; GCN-NEXT: v_lshlrev_b32_e64 v0, v256, v2
    $vgpr0 = V_LSHLREV_B32_e64 undef $vgpr256, undef $vgpr2, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x400
    ; GCN-NEXT: v_lshlrev_b32_e64 v0, v1, v256
    $vgpr0 = V_LSHLREV_B32_e64 undef $vgpr1, undef $vgpr256, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; GCN-NEXT: v_subrev_nc_u32_e32 v0, v256, v2
    $vgpr0 = V_SUBREV_U32_e32 undef $vgpr256, undef $vgpr2, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x400
    ; GCN-NEXT: v_subrev_nc_u32_e32 v0, v1, v256
    $vgpr0 = V_SUBREV_U32_e32 undef $vgpr1, undef $vgpr256, implicit $exec

    ; ASM: NumVgprs: 257
...

# ASM-LABEL: {{^}}minimal_mode_change:
# DIS-LABEL: <minimal_mode_change>:
---
name:            minimal_mode_change
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:

    ; GCN-NEXT: s_set_vgpr_frames 0x5500
    ; GCN-NEXT: v_fma_f32 v259, v260, v261, v262
    $vgpr259 = V_FMA_F32_e64 0, undef $vgpr260, 0, undef $vgpr261, 0, undef $vgpr262, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: v_add_nc_u32_e32 v0, v1, v2
    $vgpr0 = V_ADD_U32_e32 undef $vgpr1, undef $vgpr2, implicit $exec

    ; GCN-NEXT: v_mov_b32_e32 v0, v1
    $vgpr0 = V_MOV_B32_e32 undef $vgpr1, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v259, v1
    $vgpr259 = V_MOV_B32_e32 undef $vgpr1, implicit $exec

    ; GCN-NEXT: v_add_nc_u32_e32 v256, v1, v2
    $vgpr256 = V_ADD_U32_e32 undef $vgpr1, undef $vgpr2, implicit $exec

    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: v_fma_f32 v3, v4, v5, s2
    $vgpr3 = V_FMA_F32_e64 0, undef $vgpr4, 0, undef $vgpr5, 0, undef $sgpr2, 0, 0, implicit $exec, implicit $mode

    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; GCN-NEXT: v_fma_f32 v3, v260, v5, 1
    $vgpr3 = V_FMA_F32_e64 0, undef $vgpr260, 0, undef $vgpr5, 0, 1, 0, 0, implicit $exec, implicit $mode

    ; ASM: NumVgprs: 263

...

# ASM-LABEL: {{^}}terminators:
# DIS-LABEL: <terminators>:
---
name:            terminators
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:
    ; GCN-NEXT: s_nop 0
    ; GCN-NEXT: s_branch
    S_NOP 0
    S_BRANCH %bb.1

    ; No mode switch if it was zero

  bb.1:
    ; ASM: .LBB{{.*_1}}:
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec

    ; No mode switch on fall through

  bb.2:
    ; ASM-NEXT: %bb.2:
    ; GCN-NEXT: s_nop 0
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: s_branch
    S_NOP 0
    S_BRANCH %bb.3

    ; Reset mode on terminator

  bb.3:
    ; ASM: .LBB{{.*_3}}:
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: s_swap_pc_i64
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    $exec = S_SWAPPC_B64 undef $sgpr0_sgpr1

    ; Reset mode before a call

  bb.4:
    ; ASM-NEXT: %bb.4:
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_endpgm
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    S_ENDPGM 0

    ; No mode reset before S_ENDPGM

  bb.5:
    ; ASM-NEXT: %bb.5:
    ; GCN-NEXT: v_mov_b32_e32 v0, v1
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: s_set_pc_i64
    $vgpr0 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    S_SETPC_B64 undef $sgpr0_sgpr1, implicit-def $exec

    ; Assume mode zero at block begin even if we did not reset if before
    ; Reset mode before branch

  bb.6:
    ; ASM-NEXT: %bb.6:
    ; GCN-NEXT: s_set_pc_i64
    S_SETPC_B64 undef $sgpr0_sgpr1, implicit-def $exec

    ; But do not reset mode before a branch if it was zero

  bb.7:
    ; ASM-NEXT: %bb.7:
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-NEXT: ; return to shader part epilog
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    SI_RETURN_TO_EPILOG undef $vgpr0, implicit-def $exec

    ; Reset mode before returning from a call

  bb.8:
    ; ASM-NEXT: %bb.8:
    ; ASM-NEXT: ; return to shader part epilog
    SI_RETURN_TO_EPILOG undef $vgpr0, implicit-def $exec

    ; But do not reset mode before a call return if it was zero

  bb.9:
    ; ASM-NEXT: %bb.9:
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: s_set_pc_i64
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    S_SETPC_B64_return undef $sgpr0_sgpr1, implicit-def $exec

    ; ASM: NumVgprs: 257
...

# ASM-LABEL: {{^}}inline_asm:
# DIS-LABEL: <inline_asm>:
---
name:            inline_asm
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM:      def v0
    ; GCN-NOT:  s_set_vgpr_msb
    ; ASM:      use v0
    ; GCN-NOT:  s_set_vgpr_msb
    ; ASM:      use v1
    ; GCN:    s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NOT:  s_set_vgpr_msb
    ; ASM:      no vgprs, mode preserved
    ; GCN-NOT:  s_set_vgpr_msb
    ; GCN:      v_mov_b32_e32 v256, v1
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    INLINEASM &"; def v0", 1, 327690, def $vgpr0
    INLINEASM &"; use v0", 1, 327690, $vgpr0
    INLINEASM &"; use v1", 1, 327690, undef $vgpr1
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    INLINEASM &"; no vgprs, mode preserved", 1, 327690, undef $sgpr0
    $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec

    ; ASM: NumVgprs: 257
...

# ASM-LABEL: {{^}}bundle:
# DIS-LABEL: <bundle>:
---
name:            bundle
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_nop 0
    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; GCN-NEXT: v_mov_b32_e32 v1, v256
    BUNDLE implicit-def $vgpr256 {
      $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    }
    BUNDLE implicit $vgpr256 {
      S_NOP 0
      $vgpr1 = V_MOV_B32_e32 $vgpr256, implicit $exec
    }

    ; ASM: NumVgprs: 257
...

# ASM-LABEL: {{^}}hard_clauses:
# DIS-LABEL: <hard_clauses>:
---
name:            hard_clauses
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:

    ; s_set_vgpr_msb cannot be a first instruction in a clause and must be placed before it.

    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: s_clause 0x2
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: v_mov_b32_e32 v257, v1
    ; GCN-NEXT: v_mov_b32_e32 v258, v1
    BUNDLE implicit-def $vgpr256, implicit-def $vgpr257, implicit-def $vgpr248, implicit undef $vgpr1 {
      S_CLAUSE 2
      $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr257 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr258 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    }

    ; S_CLAUSE 515 means 4 instructions broken in groups of 2.
    ; A mode change cannot be a first instruction of each group.
    ; If we cannot insert a mode change right before the clause just drop it.

    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: v_mov_b32_e32 v257, v1
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: v_mov_b32_e32 v2, v1
    ; GCN-NEXT: v_mov_b32_e32 v3, v1
    BUNDLE implicit-def $vgpr256, implicit-def $vgpr257, implicit-def $vgpr2, implicit-def $vgpr3, implicit undef $vgpr1 {
      S_CLAUSE 515
      $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr257 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr2 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr3 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    }

    ; Check that we properly update the clause length.

    ; GCN-NEXT: s_clause 0x3
    ; GCN-NEXT: v_mov_b32_e32 v0, v1
    ; GCN-NEXT: s_set_vgpr_frames 0x4000
    ; GCN-NEXT: v_mov_b32_e32 v257, v1
    ; GCN-NEXT: v_mov_b32_e32 v258, v1
    BUNDLE implicit-def $vgpr0, implicit-def $vgpr257, implicit-def $vgpr248, implicit undef $vgpr1 {
      S_CLAUSE 2
      $vgpr0 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr257 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr258 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    }

    ; Check that we do not exceed the limit of 63 instructions or simm16 value of 62.

    ; GCN-NEXT: s_clause 0x3e
    ; GCN-NEXT: v_mov_b32_e32 v256, v1
    ; GCN-NEXT: s_set_vgpr_frames 0
    ; GCN-NEXT: v_mov_b32_e32 v1, v1
    ; GCN-NEXT: v_mov_b32_e32 v2, v1
    ; GCN-COUNT-60: v_mov_b32_e32 v1, v1
    BUNDLE implicit-def $vgpr256, implicit-def $vgpr1, implicit-def $vgpr2, implicit undef $vgpr1 {
      S_CLAUSE 62
      $vgpr256 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr2 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
      $vgpr1 = V_MOV_B32_e32 undef $vgpr1, implicit $exec
    }

    ; ASM: NumVgprs: 259
...

# ASM-LABEL: {{^}}pseudo:
# DIS-LABEL: <pseudo>:
---
name:            pseudo
body:             |
  bb.0:
    liveins: $vgpr0

    $sgpr0 = SI_ILLEGAL_COPY killed $vgpr0, implicit-def $exec, implicit-def $vcc, implicit $exec
    ; Just do not assert here.
    ; ASM: illegal copy v0 to s0
    SI_RETURN_TO_EPILOG killed $sgpr0
    S_ENDPGM 0
...

# ASM-LABEL: {{^}}idx_sel_mov:
# DIS-LABEL: <idx_sel_mov>:
---
name:            idx_sel_mov
machineFunctionInfo:
  laneSharedVGPRSize: 1000
tracksRegLiveness: true
body:             |
  bb.0:
    ; ASM: %bb.0:

    ; GCN-NEXT: s_set_gpr_idx_u32 idx1, s2
    $idx1 = S_SET_GPR_IDX_U32 undef $sgpr2

    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: v_mov_b32_e32 v256, v511
    $vgpr256 = V_MOV_B32_e32 undef $vgpr511, implicit $exec

    ; set dst use idx1, reset msb
    ; GCN-NEXT: s_set_vgpr_frames 64
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 g1[0], v10
    V_STORE_IDX undef $vgpr10, $idx1, 0, implicit $exec :: (store (s32), addrspace 10)

    ; reset idx, set msb 0 & dst
    ; GCN-NEXT: s_set_vgpr_frames 0x4100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: v_mov_b32_e32 v257, v510
    $vgpr257 = V_MOV_B32_e32 undef $vgpr510, implicit $exec

    ; set dst use idx1, reset dst msb, no modify src0 msb
    ; GCN-NEXT: s_set_vgpr_frames 0x140
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 g1[0], v280
    V_STORE_IDX undef $vgpr280, $idx1, 0, implicit $exec :: (store (s32), addrspace 10)

    ; reset idx, set dst msb, set src0 msb
    ; GCN-NEXT: s_set_vgpr_frames 0x4300
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=3 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: v_mov_b32_e32 v257, v998
    $vgpr257 = V_MOV_B32_e32 undef $vgpr998, implicit $exec

    ; set src0 idx, reset dst msb
    ; GCN-NEXT: s_set_vgpr_frames 0x301
    ; ASM-SAME:                                         ;  vsrc0_idx=1 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=3 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 v11, g1[999]
    renamable $vgpr11 = V_LOAD_IDX $idx1, 999, implicit $exec :: (load (s32), addrspace 10)

    ; no set_vgpr_frames
    ; GCN-NEXT: v_mov_b32_e32 v12, g1[998]
    renamable $vgpr12 = V_LOAD_IDX $idx1, 998, implicit $exec :: (load (s32), addrspace 10)

    ; FLAT (vaddr, vdata and vdst operands)

    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: global_load_b32 v2, v[258:259], off
    $vgpr2 = GLOBAL_LOAD_DWORD undef $vgpr258_vgpr259, 0, 0, implicit $exec

    ; set src0 idx, reset src0 msb
    ; GCN-NEXT: s_set_vgpr_frames 1
    ; ASM-SAME:                                         ;  vsrc0_idx=1 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 v11, g1[1]
    renamable $vgpr11 = V_LOAD_IDX $idx1, 1, implicit $exec :: (load (s32), addrspace 10)

    ; set dst idx, reset src0 idx, set src0 msb
    ; GCN-NEXT: s_set_vgpr_frames 0x140
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=1 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 g1[1], v280
    V_STORE_IDX undef $vgpr280, $idx1, 1, implicit $exec :: (store (s32), addrspace 10)

    ; reset idx, no mod src0 msb
    ; GCN-NEXT: s_set_vgpr_frames 0x100
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: scratch_load_u8 v0, v511, s0
    $vgpr0 = SCRATCH_LOAD_UBYTE_SVS $vgpr511, undef $sgpr0, 0, 0, implicit $exec, implicit $flat_scr

    ; use idx0-3

    ; GCN-NEXT: s_set_gpr_idx_u32 idx2, s4
    $idx2 = S_SET_GPR_IDX_U32 undef $sgpr4

    ; GCN-NEXT: s_set_vgpr_frames 2
    ; ASM-SAME:                                         ;  vsrc0_idx=2 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 v11, g2[5]
    renamable $vgpr11 = V_LOAD_IDX $idx2, 5, implicit $exec :: (load (s32), addrspace 10)

    ; GCN-NEXT: s_set_gpr_idx_u32 idx3, s5
    $idx3 = S_SET_GPR_IDX_U32 undef $sgpr5

    ; GCN-NEXT: s_set_vgpr_frames 0xc0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=3 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 g3[0], v10
    V_STORE_IDX undef $vgpr10, $idx3, 0, implicit $exec :: (store (s32), addrspace 10)

    ; GCN-NEXT: s_set_gpr_idx_u32 idx0, s6
    $idx0 = S_SET_GPR_IDX_U32 undef $sgpr6

    ; GCN-NEXT: s_set_vgpr_frames 0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 v11, v6
    renamable $vgpr11 = V_LOAD_IDX $idx0, 6, implicit $exec :: (load (s32), addrspace 10)

    ; GCN-NEXT: s_set_vgpr_frames 2
    ; ASM-SAME:                                         ;  vsrc0_idx=2 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 v10, g2[254]
    ; GCN-NEXT: v_mov_b32_e32 v11, g2[255]
    ; GCN-NEXT: s_set_vgpr_frames 0x102
    ; ASM-SAME:                                         ;  vsrc0_idx=2 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=1 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 v12, g2[256]
    ; GCN-NEXT: v_mov_b32_e32 v13, g2[257]
    renamable $vgpr10_vgpr11_vgpr12_vgpr13 = V_LOAD_IDX $idx2, 254, implicit $exec :: (load (s128), addrspace 10)

    ; GCN-NEXT: s_set_vgpr_frames 0xc0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=3 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: v_mov_b32_e32 g3[254], v4
    ; GCN-NEXT: v_mov_b32_e32 g3[255], v5
    ; GCN-NEXT: s_set_vgpr_frames 0x40c0
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=0 vsrc2_idx=0 vdst_idx=3 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=1
    ; GCN-NEXT: v_mov_b32_e32 g3[256], v6
    ; GCN-NEXT: v_mov_b32_e32 g3[257], v7
    V_STORE_IDX undef $vgpr4_vgpr5_vgpr6_vgpr7, $idx3, 254, implicit $exec :: (store (s128), addrspace 10)

    ; TODO-GFX13 tests with idx bits
    ; Tuple crossing the 256 boundary
    ; DPP/tied operand
    ; DS (addr, data0, and data1 operands)
    ; VBUFFER (vdata, vaddr operands)
    ; BUNDLE (and VOP2, VOP3, VOP3P)
...

# ASM-LABEL: {{^}}waitcnt_in_bundle
# DIS-LABEL: <waitcnt_in_bundle>:
---
name:            waitcnt_in_bundle
machineFunctionInfo:
  laneSharedVGPRSize: 1000
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $vgpr0, $vgpr2
    $idx1 = S_SET_GPR_IDX_U32 0
    BUNDLE implicit-def dead renamable $vgpr2, implicit killed renamable $vgpr2, implicit renamable $vgpr0, implicit $exec, implicit $idx1 {
      S_WAIT_LOADCNT 0
      renamable $vgpr2 = V_ADD_U32_e64 killed $vgpr2, $vgpr0, 0, implicit $exec
      V_STORE_IDX internal $vgpr2, $idx1, 7, implicit $exec :: (store (s32), addrspace 10)
    }
...

# ASM-LABEL: {{^}}waitcnt_in_bundle2
# DIS-LABEL: <waitcnt_in_bundle2>:
---
name:            waitcnt_in_bundle2
machineFunctionInfo:
  laneSharedVGPRSize: 1000
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $vgpr2
    $idx1 = S_SET_GPR_IDX_U32 0
    BUNDLE implicit-def dead renamable $vgpr2, implicit-def dead renamable $vgpr0, implicit killed renamable $vgpr2, implicit $exec, implicit $idx1 {
      $vgpr0 = V_LOAD_IDX $idx1, 8, implicit $exec :: (load (s32), addrspace 10)
      S_WAIT_LOADCNT 0
      S_WAIT_DSCNT 0
      S_WAIT_KMCNT 0
      renamable $vgpr2 = V_ADD_U32_e64 killed $vgpr2, internal $vgpr0, 0, implicit $exec
      V_STORE_IDX internal $vgpr2, $idx1, 7, implicit $exec :: (store (s32), addrspace 10)
    }
...

# We should not get the reg allocation erroneously using $vgpr1 twice. But it is still lowerable.
# ASM-LABEL: {{^}}internal_reg_reused
# DIS-LABEL: <internal_reg_reused>:
---
name:            internal_reg_reused
machineFunctionInfo:
  laneSharedVGPRSize: 1000
tracksRegLiveness: true
body:             |
  bb.0:
    liveins: $sgpr2_sgpr3, $idx1, $vgpr1
    ; ASM: %bb.0:
    ; GCN-NEXT: s_set_vgpr_frames 4
    ; ASM-SAME:                                         ;  vsrc0_idx=0 vsrc1_idx=1 vsrc2_idx=0 vdst_idx=0 vsrc0_msb=0 vsrc1_msb=0 vsrc2_msb=0 vdst_msb=0
    ; GCN-NEXT: global_store_b32 v1, g1[0], s[2:3] offset:28 scale_offset
    BUNDLE implicit-def dead $vgpr1, implicit $idx1, implicit $exec, implicit killed $vgpr1, implicit renamable $sgpr2_sgpr3 {
      $vgpr1 = V_LOAD_IDX $idx1, 0, implicit $exec :: (dereferenceable load (s32), addrspace 10)
      GLOBAL_STORE_DWORD_SADDR $vgpr1, internal $vgpr1, renamable $sgpr2_sgpr3, 28, 512, implicit $exec :: (store (s32), addrspace 1)
    }
...
## NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
# ASM: {{.*}}
# GCN: {{.*}}
