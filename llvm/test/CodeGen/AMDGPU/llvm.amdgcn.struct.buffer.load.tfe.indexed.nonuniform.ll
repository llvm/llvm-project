; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mcpu=gfx1300 -mtriple=amdgcn-- < %s | FileCheck %s -check-prefix=GFX13

define amdgpu_ps void @struct_buffer_load_i8_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_i8_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_mov_b32_e32 v6, v5
; GFX13-NEXT:    buffer_load_u8 v[5:6], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b8 v[1:2], v5, off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v6, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { i8, i32 } @llvm.amdgcn.struct.buffer.load.sl_i8i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { i8, i32 } %res, 0
  store i8 %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { i8, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_i16_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_i16_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_mov_b32_e32 v6, v5
; GFX13-NEXT:    buffer_load_u16 v[5:6], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b16 v[1:2], v5, off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v6, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { i16, i32 } @llvm.amdgcn.struct.buffer.load.sl_i16i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { i16, i32 } %res, 0
  store i16 %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { i16, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_f16_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_f16_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_mov_b32_e32 v6, v5
; GFX13-NEXT:    buffer_load_u16 v[5:6], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b16 v[1:2], v5, off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v6, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { half, i32 } @llvm.amdgcn.struct.buffer.load.sl_f16i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { half, i32 } %res, 0
  store half %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { half, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_i32_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_i32_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_mov_b32_e32 v6, v5
; GFX13-NEXT:    buffer_load_b32 v[5:6], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b32 v[1:2], v5, off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v6, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { i32, i32 } @llvm.amdgcn.struct.buffer.load.sl_i32i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { i32, i32 } %res, 0
  store i32 %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { i32, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_v2i32_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_v2i32_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_dual_mov_b32 v6, v5 :: v_dual_mov_b32 v7, v5
; GFX13-NEXT:    buffer_load_b64 v[5:7], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b64 v[1:2], v[5:6], off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v7, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { <2 x i32>, i32 } @llvm.amdgcn.struct.buffer.load.sl_v2i32i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { <2 x i32>, i32 } %res, 0
  store <2 x i32> %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { <2 x i32>, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_v2f32_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_v2f32_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_dual_mov_b32 v6, v5 :: v_dual_mov_b32 v7, v5
; GFX13-NEXT:    buffer_load_b64 v[5:7], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b64 v[1:2], v[5:6], off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v7, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { <2 x float>, i32 } @llvm.amdgcn.struct.buffer.load.sl_v2f32i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { <2 x float>, i32 } %res, 0
  store <2 x float> %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { <2 x float>, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_v3i32_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_v3i32_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_dual_mov_b32 v6, v5 :: v_dual_mov_b32 v7, v5
; GFX13-NEXT:    v_mov_b32_e32 v8, v5
; GFX13-NEXT:    buffer_load_b96 v[5:8], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b96 v[1:2], v[5:7], off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v8, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { <3 x i32>, i32 } @llvm.amdgcn.struct.buffer.load.sl_v3i32i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { <3 x i32>, i32 } %res, 0
  store <3 x i32> %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { <3 x i32>, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_v3f32_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_v3f32_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_dual_mov_b32 v6, v5 :: v_dual_mov_b32 v7, v5
; GFX13-NEXT:    v_mov_b32_e32 v8, v5
; GFX13-NEXT:    buffer_load_b96 v[5:8], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b96 v[1:2], v[5:7], off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v8, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { <3 x float>, i32 } @llvm.amdgcn.struct.buffer.load.sl_v3f32i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { <3 x float>, i32 } %res, 0
  store <3 x float> %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { <3 x float>, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_v4i32_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_v4i32_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_dual_mov_b32 v6, v5 :: v_dual_mov_b32 v7, v5
; GFX13-NEXT:    v_dual_mov_b32 v8, v5 :: v_dual_mov_b32 v9, v5
; GFX13-NEXT:    buffer_load_b128 v[5:9], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b128 v[1:2], v[5:8], off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v9, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { <4 x i32>, i32 } @llvm.amdgcn.struct.buffer.load.sl_v4i32i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { <4 x i32>, i32 } %res, 0
  store <4 x i32> %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { <4 x i32>, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}

define amdgpu_ps void @struct_buffer_load_v4f32_tfe(i32 %rsrc, ptr addrspace(1) %data_addr, ptr addrspace(1) %tfe_addr) {
; GFX13-LABEL: struct_buffer_load_v4f32_tfe:
; GFX13:       ; %bb.0:
; GFX13-NEXT:    v_mov_b32_e32 v5, 0
; GFX13-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX13-NEXT:    v_dual_mov_b32 v6, v5 :: v_dual_mov_b32 v7, v5
; GFX13-NEXT:    v_dual_mov_b32 v8, v5 :: v_dual_mov_b32 v9, v5
; GFX13-NEXT:    buffer_load_b128 v[5:9], v5, v0, null idxen tfe
; GFX13-NEXT:    s_wait_loadcnt 0x0
; GFX13-NEXT:    global_store_b128 v[1:2], v[5:8], off scope:SCOPE_SE
; GFX13-NEXT:    global_store_b32 v[3:4], v9, off scope:SCOPE_SE
; GFX13-NEXT:    s_endpgm
  %res = call { <4 x float>, i32 } @llvm.amdgcn.struct.buffer.load.sl_v4f32i32s(i32 %rsrc, i32 0, i32 0, i32 0, i32 0)
  %data = extractvalue { <4 x float>, i32 } %res, 0
  store <4 x float> %data, ptr addrspace(1) %data_addr
  %tfe = extractvalue { <4 x float>, i32 } %res, 1
  store i32 %tfe, ptr addrspace(1) %tfe_addr
  ret void
}
