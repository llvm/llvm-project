; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -S -mcpu=gfx900 -amdgpu-lower-buffer-fat-pointers < %s | FileCheck %s
; RUN: opt -S -mcpu=gfx900 -passes=amdgpu-lower-buffer-fat-pointers < %s | FileCheck %s

target triple = "amdgcn--"

define void @scalar_copy(ptr %a, ptr %b) {
; CHECK-LABEL: define void @scalar_copy
; CHECK-SAME: (ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[X:%.*]] = load i160, ptr [[A]], align 32
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i160 [[X]], 32
; CHECK-NEXT:    [[TMP2:%.*]] = trunc i160 [[TMP1]] to i128
; CHECK-NEXT:    [[X_PTR_RSRC:%.*]] = inttoptr i128 [[TMP2]] to ptr addrspace(8)
; CHECK-NEXT:    [[X_PTR_OFF:%.*]] = trunc i160 [[X]] to i32
; CHECK-NEXT:    [[B1:%.*]] = getelementptr i160, ptr [[B]], i64 1
; CHECK-NEXT:    store i160 [[X]], ptr [[B1]], align 32
; CHECK-NEXT:    ret void
;
  %x = load ptr addrspace(7), ptr %a
  %b1 = getelementptr ptr addrspace(7), ptr %b, i64 1
  store ptr addrspace(7) %x, ptr %b1
  ret void
}

define void @vector_copy(ptr %a, ptr %b) {
; CHECK-LABEL: define void @vector_copy
; CHECK-SAME: (ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X:%.*]] = load <4 x i160>, ptr [[A]], align 128
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i160> [[X]], splat (i160 32)
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i160> [[TMP1]] to <4 x i128>
; CHECK-NEXT:    [[X_PTR_RSRC:%.*]] = inttoptr <4 x i128> [[TMP2]] to <4 x ptr addrspace(8)>
; CHECK-NEXT:    [[X_PTR_OFF:%.*]] = trunc <4 x i160> [[X]] to <4 x i32>
; CHECK-NEXT:    [[B1:%.*]] = getelementptr <4 x i160>, ptr [[B]], i64 2
; CHECK-NEXT:    store <4 x i160> [[X]], ptr [[B1]], align 128
; CHECK-NEXT:    ret void
;
  %x = load <4 x ptr addrspace(7)>, ptr %a
  %b1 = getelementptr <4 x ptr addrspace(7)>, ptr %b, i64 2
  store <4 x ptr addrspace(7)> %x, ptr %b1
  ret void
}

define void @alloca(ptr %a, ptr %b) {
; CHECK-LABEL: define void @alloca
; CHECK-SAME: (ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca [5 x i160], align 32, addrspace(5)
; CHECK-NEXT:    [[X:%.*]] = load i160, ptr [[A]], align 32
; CHECK-NEXT:    [[TMP1:%.*]] = lshr i160 [[X]], 32
; CHECK-NEXT:    [[TMP2:%.*]] = trunc i160 [[TMP1]] to i128
; CHECK-NEXT:    [[X_PTR_RSRC:%.*]] = inttoptr i128 [[TMP2]] to ptr addrspace(8)
; CHECK-NEXT:    [[X_PTR_OFF:%.*]] = trunc i160 [[X]] to i32
; CHECK-NEXT:    [[L:%.*]] = getelementptr i160, ptr addrspace(5) [[ALLOCA]], i32 1
; CHECK-NEXT:    store i160 [[X]], ptr addrspace(5) [[L]], align 32
; CHECK-NEXT:    [[Y:%.*]] = load i160, ptr addrspace(5) [[L]], align 32
; CHECK-NEXT:    [[TMP3:%.*]] = lshr i160 [[Y]], 32
; CHECK-NEXT:    [[TMP4:%.*]] = trunc i160 [[TMP3]] to i128
; CHECK-NEXT:    [[Y_PTR_RSRC:%.*]] = inttoptr i128 [[TMP4]] to ptr addrspace(8)
; CHECK-NEXT:    [[Y_PTR_OFF:%.*]] = trunc i160 [[Y]] to i32
; CHECK-NEXT:    store i160 [[Y]], ptr [[B]], align 32
; CHECK-NEXT:    ret void
;
  %alloca = alloca [5 x ptr addrspace(7)], addrspace(5)
  %x = load ptr addrspace(7), ptr %a
  %l = getelementptr ptr addrspace(7), ptr addrspace(5) %alloca, i32 1
  store ptr addrspace(7) %x, ptr addrspace(5) %l
  %y = load ptr addrspace(7), ptr addrspace(5) %l
  store ptr addrspace(7) %y, ptr %b
  ret void
}

define void @complex_copy(ptr %a, ptr %b) {
; CHECK-LABEL: define void @complex_copy
; CHECK-SAME: (ptr [[A:%.*]], ptr [[B:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[X:%.*]] = load { [2 x i160], i32, i160 }, ptr [[A]], align 32
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { [2 x i160], i32, i160 } [[X]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue [2 x i160] [[TMP1]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = lshr i160 [[TMP2]], 32
; CHECK-NEXT:    [[TMP4:%.*]] = trunc i160 [[TMP3]] to i128
; CHECK-NEXT:    [[X_0_0_PTR_RSRC:%.*]] = inttoptr i128 [[TMP4]] to ptr addrspace(8)
; CHECK-NEXT:    [[X_0_0_PTR_OFF:%.*]] = trunc i160 [[TMP2]] to i32
; CHECK-NEXT:    [[TMP5:%.*]] = insertvalue { ptr addrspace(8), i32 } poison, ptr addrspace(8) [[X_0_0_PTR_RSRC]], 0
; CHECK-NEXT:    [[X_0_0_PTR:%.*]] = insertvalue { ptr addrspace(8), i32 } [[TMP5]], i32 [[X_0_0_PTR_OFF]], 1
; CHECK-NEXT:    [[TMP6:%.*]] = insertvalue [2 x { ptr addrspace(8), i32 }] poison, { ptr addrspace(8), i32 } [[X_0_0_PTR]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractvalue [2 x i160] [[TMP1]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = lshr i160 [[TMP7]], 32
; CHECK-NEXT:    [[TMP9:%.*]] = trunc i160 [[TMP8]] to i128
; CHECK-NEXT:    [[X_0_1_PTR_RSRC:%.*]] = inttoptr i128 [[TMP9]] to ptr addrspace(8)
; CHECK-NEXT:    [[X_0_1_PTR_OFF:%.*]] = trunc i160 [[TMP7]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = insertvalue { ptr addrspace(8), i32 } poison, ptr addrspace(8) [[X_0_1_PTR_RSRC]], 0
; CHECK-NEXT:    [[X_0_1_PTR:%.*]] = insertvalue { ptr addrspace(8), i32 } [[TMP10]], i32 [[X_0_1_PTR_OFF]], 1
; CHECK-NEXT:    [[TMP11:%.*]] = insertvalue [2 x { ptr addrspace(8), i32 }] [[TMP6]], { ptr addrspace(8), i32 } [[X_0_1_PTR]], 1
; CHECK-NEXT:    [[TMP12:%.*]] = insertvalue { [2 x { ptr addrspace(8), i32 }], i32, { ptr addrspace(8), i32 } } poison, [2 x { ptr addrspace(8), i32 }] [[TMP11]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = extractvalue { [2 x i160], i32, i160 } [[X]], 1
; CHECK-NEXT:    [[TMP14:%.*]] = insertvalue { [2 x { ptr addrspace(8), i32 }], i32, { ptr addrspace(8), i32 } } [[TMP12]], i32 [[TMP13]], 1
; CHECK-NEXT:    [[TMP15:%.*]] = extractvalue { [2 x i160], i32, i160 } [[X]], 2
; CHECK-NEXT:    [[TMP16:%.*]] = lshr i160 [[TMP15]], 32
; CHECK-NEXT:    [[TMP17:%.*]] = trunc i160 [[TMP16]] to i128
; CHECK-NEXT:    [[X_2_PTR_RSRC:%.*]] = inttoptr i128 [[TMP17]] to ptr addrspace(8)
; CHECK-NEXT:    [[X_2_PTR_OFF:%.*]] = trunc i160 [[TMP15]] to i32
; CHECK-NEXT:    [[TMP18:%.*]] = insertvalue { ptr addrspace(8), i32 } poison, ptr addrspace(8) [[X_2_PTR_RSRC]], 0
; CHECK-NEXT:    [[X_2_PTR:%.*]] = insertvalue { ptr addrspace(8), i32 } [[TMP18]], i32 [[X_2_PTR_OFF]], 1
; CHECK-NEXT:    [[TMP19:%.*]] = insertvalue { [2 x { ptr addrspace(8), i32 }], i32, { ptr addrspace(8), i32 } } [[TMP14]], { ptr addrspace(8), i32 } [[X_2_PTR]], 2
; CHECK-NEXT:    store { [2 x i160], i32, i160 } [[X]], ptr [[B]], align 32
; CHECK-NEXT:    ret void
;
  %x = load {[2 x ptr addrspace(7)], i32, ptr addrspace(7)}, ptr %a
  store {[2 x ptr addrspace(7)], i32, ptr addrspace(7)} %x, ptr %b
  ret void
}
