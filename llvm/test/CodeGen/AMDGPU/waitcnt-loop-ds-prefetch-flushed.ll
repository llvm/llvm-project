; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1250 -o - %s | FileCheck %s
; Test for DS prefetch with flush points: SOME DS loads are used in the same
; iteration (creating flush points) but others remain unflushed at backedge
; (true prefetches via phi). Flush point tracking detects unflushed prefetches.
; Expected: s_wait_dscnt 0 in preheader before loop entry.

define amdgpu_kernel void @ds_prefetch_flushed(ptr addrspace(3) %lds, ptr addrspace(1) %out, i32 %n) {
; CHECK-LABEL: ds_prefetch_flushed:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    s_setreg_imm32_b32 hwreg(HW_REG_WAVE_MODE, 25, 1), 1
; CHECK-NEXT:    s_clause 0x1
; CHECK-NEXT:    s_load_b32 s1, s[4:5], 0x0
; CHECK-NEXT:    s_load_b32 s0, s[4:5], 0x10
; CHECK-NEXT:    v_and_b32_e32 v20, 0x3ff, v0
; CHECK-NEXT:    v_mov_b32_e32 v16, 0
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; CHECK-NEXT:    v_dual_mov_b32 v17, v16 :: v_dual_mov_b32 v18, v16
; CHECK-NEXT:    v_mov_b32_e32 v19, v16
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    v_lshl_add_u32 v21, v20, 8, s1
; CHECK-NEXT:    s_mov_b32 s1, 0
; CHECK-NEXT:    ds_load_b128 v[0:3], v21
; CHECK-NEXT:    ds_load_b128 v[4:7], v21 offset:16
; CHECK-NEXT:    s_wait_dscnt 0x1
; CHECK-NEXT:    v_mov_b64_e32 v[10:11], v[2:3]
; CHECK-NEXT:    s_wait_dscnt 0x0
; CHECK-NEXT:    v_mov_b64_e32 v[14:15], v[6:7]
; CHECK-NEXT:    v_mov_b64_e32 v[8:9], v[0:1]
; CHECK-NEXT:    v_mov_b64_e32 v[12:13], v[4:5]
; CHECK-NEXT:  .LBB0_1: ; %loop
; CHECK-NEXT:    ; =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    s_barrier_signal -1
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_2) | instskip(NEXT) | instid1(VALU_DEP_2)
; CHECK-NEXT:    v_pk_add_f32 v[18:19], v[18:19], v[2:3]
; CHECK-NEXT:    v_pk_add_f32 v[16:17], v[16:17], v[0:1]
; CHECK-NEXT:    s_add_co_i32 s1, s1, 1
; CHECK-NEXT:    s_delay_alu instid0(SALU_CYCLE_1) | instskip(NEXT) | instid1(VALU_DEP_2)
; CHECK-NEXT:    s_cmp_lt_i32 s1, s0
; CHECK-NEXT:    v_pk_add_f32 v[26:27], v[18:19], v[6:7]
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_2) | instskip(SKIP_1) | instid1(VALU_DEP_2)
; CHECK-NEXT:    v_pk_add_f32 v[28:29], v[16:17], v[4:5]
; CHECK-NEXT:    s_wait_dscnt 0x1
; CHECK-NEXT:    v_pk_add_f32 v[10:11], v[26:27], v[10:11]
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_2) | instskip(SKIP_1) | instid1(VALU_DEP_2)
; CHECK-NEXT:    v_pk_add_f32 v[8:9], v[28:29], v[8:9]
; CHECK-NEXT:    s_wait_dscnt 0x0
; CHECK-NEXT:    v_pk_add_f32 v[26:27], v[10:11], v[14:15]
; CHECK-NEXT:    s_barrier_wait -1
; CHECK-NEXT:    ds_load_b128 v[16:19], v21
; CHECK-NEXT:    ds_load_b128 v[22:25], v21 offset:16
; CHECK-NEXT:    v_pk_add_f32 v[28:29], v[8:9], v[12:13]
; CHECK-NEXT:    ds_load_b128 v[8:11], v21 offset:32
; CHECK-NEXT:    ds_load_b128 v[12:15], v21 offset:48
; CHECK-NEXT:    v_add_nc_u32_e32 v21, 16, v21
; CHECK-NEXT:    s_wait_dscnt 0x2
; CHECK-NEXT:    v_pk_add_f32 v[18:19], v[18:19], v[24:25]
; CHECK-NEXT:    v_pk_add_f32 v[16:17], v[16:17], v[22:23]
; CHECK-NEXT:    s_delay_alu instid0(VALU_DEP_2) | instskip(NEXT) | instid1(VALU_DEP_2)
; CHECK-NEXT:    v_pk_add_f32 v[18:19], v[26:27], v[18:19]
; CHECK-NEXT:    v_pk_add_f32 v[16:17], v[28:29], v[16:17]
; CHECK-NEXT:    s_cbranch_scc1 .LBB0_1
; CHECK-NEXT:  ; %bb.2: ; %exit
; CHECK-NEXT:    s_load_b64 s[0:1], s[4:5], 0x8
; CHECK-NEXT:    s_wait_kmcnt 0x0
; CHECK-NEXT:    global_store_b128 v20, v[16:19], s[0:1] scale_offset
; CHECK-NEXT:    s_endpgm
entry:
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %base = shl i32 %tid, 4

  ; Preheader DS loads - values used inside loop (triggers UsesVgprLoadedOutsideDS)
  %ptr.pre1 = getelementptr <4 x float>, ptr addrspace(3) %lds, i32 %base
  %init.v1 = load <4 x float>, ptr addrspace(3) %ptr.pre1, align 16
  %ptr.pre2 = getelementptr <4 x float>, ptr addrspace(3) %lds, i32 %base, i32 4
  %init.v2 = load <4 x float>, ptr addrspace(3) %ptr.pre2, align 16

  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %i.next, %loop ]
  %acc = phi <4 x float> [ zeroinitializer, %entry ], [ %acc.next, %loop ]
  ; Prefetch values from previous iteration (or preheader for first iter)
  %prefetch1 = phi <4 x float> [ %init.v1, %entry ], [ %load3, %loop ]
  %prefetch2 = phi <4 x float> [ %init.v2, %entry ], [ %load4, %loop ]

  ; Use preheader values directly (triggers UsesVgprLoadedOutsideDS)
  %use.pre1 = fadd <4 x float> %acc, %init.v1
  %use.pre2 = fadd <4 x float> %use.pre1, %init.v2
  ; Use prefetched values
  %use.pf1 = fadd <4 x float> %use.pre2, %prefetch1
  %use.pf2 = fadd <4 x float> %use.pf1, %prefetch2

  ; Barrier
  call void @llvm.amdgcn.s.barrier()

  ; Compute loop-variant addresses
  %off1 = add i32 %base, %i

  ; DS loads after barrier:
  ; load1 and load2 ARE used DIRECTLY in this iteration (sets DSInvalidated,
  ; creates flush points for Situation 5)
  %ptr1 = getelementptr <4 x float>, ptr addrspace(3) %lds, i32 %off1
  %load1 = load <4 x float>, ptr addrspace(3) %ptr1, align 16

  %off2 = add i32 %off1, 1
  %ptr2 = getelementptr <4 x float>, ptr addrspace(3) %lds, i32 %off2
  %load2 = load <4 x float>, ptr addrspace(3) %ptr2, align 16

  ; load3 and load4 flow to NEXT iteration via phi - true prefetches
  ; They are NOT used in this iteration, so they remain unflushed at backedge
  %off3 = add i32 %off1, 2
  %ptr3 = getelementptr <4 x float>, ptr addrspace(3) %lds, i32 %off3
  %load3 = load <4 x float>, ptr addrspace(3) %ptr3, align 16

  %off4 = add i32 %off1, 3
  %ptr4 = getelementptr <4 x float>, ptr addrspace(3) %lds, i32 %off4
  %load4 = load <4 x float>, ptr addrspace(3) %ptr4, align 16

  ; Use load1 and load2 DIRECTLY in THIS iteration (triggers DSInvalidated)
  %sum = fadd <4 x float> %load1, %load2
  %acc.next = fadd <4 x float> %use.pf2, %sum

  %i.next = add i32 %i, 1
  %cond = icmp slt i32 %i.next, %n
  br i1 %cond, label %loop, label %exit

exit:
  %out.ptr = getelementptr <4 x float>, ptr addrspace(1) %out, i32 %tid
  store <4 x float> %acc.next, ptr addrspace(1) %out.ptr, align 16
  ret void
}

declare i32 @llvm.amdgcn.workitem.id.x()
declare void @llvm.amdgcn.s.barrier()
