# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc  -mtriple=amdgcn -mcpu=gfx900 -run-pass=amdgpu-rebuild-ssa  -verify-machineinstrs %s -verify-machineinstrs -o - | FileCheck %s
--- |
  source_filename = "test3.ll"
  target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-p7:160:256:256:32-p8:128:128-p9:192:256:256:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7:8:9"
  target triple = "amdgcn"

  declare noundef i32 @llvm.amdgcn.workitem.id.x() #0

  define amdgpu_kernel void @test_subregs(ptr addrspace(1) %in, ptr addrspace(1) %out, i32 %arg) #1 {
  bb0:
    %test_subregs.kernarg.segment = call nonnull align 16 dereferenceable(276) ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr()
    %in.kernarg.offset = getelementptr inbounds i8, ptr addrspace(4) %test_subregs.kernarg.segment, i64 36, !amdgpu.uniform !0
    %0 = load <2 x i64>, ptr addrspace(4) %in.kernarg.offset, align 4, !invariant.load !0
    %in.load1 = extractelement <2 x i64> %0, i32 0
    %1 = inttoptr i64 %in.load1 to ptr addrspace(1)
    %arg.kernarg.offset = getelementptr inbounds i8, ptr addrspace(4) %test_subregs.kernarg.segment, i64 52, !amdgpu.uniform !0
    %arg.load = load i32, ptr addrspace(4) %arg.kernarg.offset, align 4, !invariant.load !0
    %tid = call i32 @llvm.amdgcn.workitem.id.x()
    %idxprom = sext i32 %tid to i64
    %gep = getelementptr i32, ptr addrspace(1) %1, i64 %idxprom
    %vec0 = load <4 x i32>, ptr addrspace(1) %gep, align 16
    %cmp0 = icmp sle i32 %arg.load, 10
    br i1 %cmp0, label %bb4, label %Flow, !amdgpu.uniform !0

  Flow:                                             ; preds = %bb4, %bb0
    %2 = phi <4 x i32> [ %vec5, %bb4 ], [ undef, %bb0 ]
    %3 = phi i1 [ false, %bb4 ], [ true, %bb0 ]
    br i1 %3, label %bb1, label %Flow3, !amdgpu.uniform !0

  bb1:                                              ; preds = %Flow
    br label %bb2, !amdgpu.uniform !0

  Flow3:                                            ; preds = %bb2, %Flow
    %4 = phi <4 x i32> [ %vec2, %bb2 ], [ %2, %Flow ]
    br label %bb3, !amdgpu.uniform !0

  bb2:                                              ; preds = %bb1
    %elt0 = extractelement <4 x i32> %vec0, i32 0
    %tmp = add i32 %elt0, %arg.load
    %vec1 = insertelement <4 x i32> %vec0, i32 %tmp, i32 0
    %elt1 = extractelement <4 x i32> %vec0, i32 1
    %tmp1 = add i32 %elt1, %elt0
    %vec2 = insertelement <4 x i32> %vec1, i32 %tmp1, i32 1
    br label %Flow3, !amdgpu.uniform !0

  bb3:                                              ; preds = %Flow3
    %out.load2 = extractelement <2 x i64> %0, i32 1
    %5 = inttoptr i64 %out.load2 to ptr addrspace(1)
    %vec3 = shufflevector <4 x i32> %4, <4 x i32> poison, <2 x i32> <i32 0, i32 1>
    %cast = bitcast <2 x i32> %vec3 to i64
    %vec4 = shufflevector <4 x i32> %4, <4 x i32> poison, <2 x i32> <i32 2, i32 3>
    %cast1 = bitcast <2 x i32> %vec4 to i64
    %res2 = mul i64 %cast, %cast1
    %gep2 = getelementptr i64, ptr addrspace(1) %5, i32 22
    store i64 %res2, ptr addrspace(1) %gep2, align 8
    ret void

  bb4:                                              ; preds = %bb0
    %elt2 = extractelement <4 x i32> %vec0, i32 1
    %tmp2 = add i32 %elt2, %arg.load
    %vec5 = insertelement <4 x i32> %vec0, i32 %tmp2, i32 2
    br label %Flow, !amdgpu.uniform !0
  }

  declare noundef align 4 ptr addrspace(4) @llvm.amdgcn.kernarg.segment.ptr() #2

  declare { i1, i64 } @llvm.amdgcn.if.i64(i1) #3

  declare { i1, i64 } @llvm.amdgcn.else.i64.i64(i64) #3

  declare i64 @llvm.amdgcn.if.break.i64(i1, i64) #4

  declare i1 @llvm.amdgcn.loop.i64(i64) #3

  declare void @llvm.amdgcn.end.cf.i64(i64) #3

  attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) "target-cpu"="gfx900" }
  attributes #1 = { "target-cpu"="gfx900" }
  attributes #2 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
  attributes #3 = { nocallback nofree nounwind willreturn }
  attributes #4 = { nocallback nofree nounwind willreturn memory(none) }

  !0 = !{}

...
---
name:            test_subregs
alignment:       1
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
callsEHReturn:   false
callsUnwindInit: false
hasEHCatchret:   false
hasEHScopes:     false
hasEHFunclets:   false
isOutlined:      false
debugInstrRef:   false
failsVerification: false
tracksDebugUserValues: false
registers:
  - { id: 0, class: sgpr_128, preferred-register: '' }
  - { id: 1, class: sreg_32, preferred-register: '' }
  - { id: 2, class: vreg_128, preferred-register: '' }
  - { id: 3, class: vreg_128, preferred-register: '' }
  - { id: 4, class: sreg_64_xexec, preferred-register: '' }
  - { id: 5, class: vreg_128, preferred-register: '' }
  - { id: 6, class: vreg_128, preferred-register: '' }
  - { id: 7, class: vreg_128, preferred-register: '' }
  - { id: 8, class: vgpr_32, preferred-register: '' }
  - { id: 9, class: vgpr_32, preferred-register: '' }
  - { id: 10, class: vgpr_32, preferred-register: '' }
  - { id: 11, class: sgpr_64, preferred-register: '' }
  - { id: 12, class: sgpr_64, preferred-register: '' }
  - { id: 13, class: sgpr_64, preferred-register: '' }
  - { id: 14, class: sgpr_32, preferred-register: '' }
  - { id: 15, class: sgpr_32, preferred-register: '' }
  - { id: 16, class: sgpr_32, preferred-register: '' }
  - { id: 17, class: sgpr_32, preferred-register: '' }
  - { id: 18, class: sgpr_128, preferred-register: '' }
  - { id: 19, class: sreg_64, preferred-register: '' }
  - { id: 20, class: sreg_32_xm0_xexec, preferred-register: '' }
  - { id: 21, class: sreg_32, preferred-register: '' }
  - { id: 22, class: sreg_32, preferred-register: '' }
  - { id: 23, class: sreg_64, preferred-register: '' }
  - { id: 24, class: sreg_32, preferred-register: '' }
  - { id: 25, class: vgpr_32, preferred-register: '' }
  - { id: 26, class: sreg_32, preferred-register: '' }
  - { id: 27, class: sreg_64, preferred-register: '' }
  - { id: 28, class: vgpr_32, preferred-register: '' }
  - { id: 29, class: vgpr_32, preferred-register: '' }
  - { id: 30, class: vgpr_32, preferred-register: '' }
  - { id: 31, class: sreg_32, preferred-register: '' }
  - { id: 32, class: sreg_32, preferred-register: '' }
  - { id: 33, class: vgpr_32, preferred-register: '' }
  - { id: 34, class: vgpr_32, preferred-register: '' }
  - { id: 35, class: vreg_128, preferred-register: '' }
  - { id: 36, class: vgpr_32, preferred-register: '' }
  - { id: 37, class: vgpr_32, preferred-register: '' }
  - { id: 38, class: sreg_32, preferred-register: '' }
  - { id: 39, class: sreg_32, preferred-register: '' }
  - { id: 40, class: sreg_64, preferred-register: '' }
  - { id: 41, class: vgpr_32, preferred-register: '' }
  - { id: 42, class: vgpr_32, preferred-register: '' }
  - { id: 43, class: vgpr_32, preferred-register: '' }
  - { id: 44, class: vgpr_32, preferred-register: '' }
  - { id: 45, class: vgpr_32, preferred-register: '' }
  - { id: 46, class: vgpr_32, preferred-register: '' }
  - { id: 47, class: vgpr_32, preferred-register: '' }
  - { id: 48, class: vreg_64, preferred-register: '' }
  - { id: 49, class: sreg_64, preferred-register: '' }
  - { id: 50, class: vgpr_32, preferred-register: '' }
  - { id: 51, class: vgpr_32, preferred-register: '' }
  - { id: 52, class: vgpr_32, preferred-register: '' }
  - { id: 53, class: sreg_64, preferred-register: '' }
  - { id: 54, class: vreg_64, preferred-register: '' }
  - { id: 55, class: sgpr_32, preferred-register: '' }
  - { id: 56, class: sgpr_32, preferred-register: '' }
  - { id: 57, class: vreg_64, preferred-register: '' }
  - { id: 58, class: sreg_64_xexec, preferred-register: '$vcc' }
  - { id: 59, class: vreg_128, preferred-register: '' }
  - { id: 60, class: vreg_128, preferred-register: '' }
  - { id: 61, class: sreg_64_xexec, preferred-register: '' }
  - { id: 62, class: vreg_128, preferred-register: '' }
liveins:
  - { reg: '$vgpr0', virtual-reg: '%8' }
  - { reg: '$sgpr2_sgpr3', virtual-reg: '%12' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  functionContext: ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  hasTailCall:     false
  isCalleeSavedInfoValid: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
entry_values:    []
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo:
  explicitKernArgSize: 20
  maxKernArgAlign: 8
  ldsSize:         0
  gdsSize:         0
  dynLDSAlign:     1
  isEntryFunction: true
  isChainFunction: false
  noSignedZerosFPMath: false
  memoryBound:     false
  waveLimiter:     false
  hasSpilledSGPRs: false
  hasSpilledVGPRs: false
  scratchRSrcReg:  '$sgpr96_sgpr97_sgpr98_sgpr99'
  frameOffsetReg:  '$fp_reg'
  stackPtrOffsetReg: '$sgpr32'
  bytesInStackArgArea: 0
  returnsVoid:     true
  argumentInfo:
    dispatchPtr:     { reg: '$sgpr0_sgpr1' }
    kernargSegmentPtr: { reg: '$sgpr2_sgpr3' }
    dispatchID:      { reg: '$sgpr4_sgpr5' }
    workGroupIDX:    { reg: '$sgpr6' }
    workGroupIDY:    { reg: '$sgpr7' }
    workGroupIDZ:    { reg: '$sgpr8' }
    privateSegmentWaveByteOffset: { reg: '$sgpr9' }
    workItemIDX:     { reg: '$vgpr0' }
    workItemIDY:     { reg: '$vgpr1' }
    workItemIDZ:     { reg: '$vgpr2' }
  psInputAddr:     0
  psInputEnable:   0
  mode:
    ieee:            true
    dx10-clamp:      true
    fp32-input-denormals: true
    fp32-output-denormals: true
    fp64-fp16-input-denormals: true
    fp64-fp16-output-denormals: true
  highBitsOf32BitAddress: 0
  occupancy:       8
  vgprForAGPRCopy: ''
  sgprForEXECCopy: '$sgpr100_sgpr101'
  longBranchReservedReg: ''
  hasInitWholeWave: false
body:             |
  ; CHECK-LABEL: name: test_subregs
  ; CHECK: bb.0.bb0:
  ; CHECK-NEXT:   successors: %bb.6(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $sgpr2_sgpr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:sgpr_64(p4) = COPY $sgpr2_sgpr3
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:vgpr_32(s32) = COPY $vgpr0
  ; CHECK-NEXT:   early-clobber %0:sgpr_128 = S_LOAD_DWORDX4_IMM_ec [[COPY]](p4), 36, 0 :: (dereferenceable invariant load (s128) from %ir.in.kernarg.offset, align 4, addrspace 4)
  ; CHECK-NEXT:   [[S_LOAD_DWORD_IMM:%[0-9]+]]:sreg_32_xm0_xexec = S_LOAD_DWORD_IMM [[COPY]](p4), 52, 0 :: (dereferenceable invariant load (s32) from %ir.arg.kernarg.offset, addrspace 4)
  ; CHECK-NEXT:   KILL [[COPY]](p4)
  ; CHECK-NEXT:   [[V_LSHLREV_B32_e32_:%[0-9]+]]:vgpr_32 = nuw nsw V_LSHLREV_B32_e32 2, [[COPY1]](s32), implicit $exec
  ; CHECK-NEXT:   [[GLOBAL_LOAD_DWORDX4_SADDR:%[0-9]+]]:vreg_128 = GLOBAL_LOAD_DWORDX4_SADDR %0.sub0_sub1, [[V_LSHLREV_B32_e32_]], 0, 0, implicit $exec :: (load (s128) from %ir.gep, addrspace 1)
  ; CHECK-NEXT:   S_CMP_LT_I32 [[S_LOAD_DWORD_IMM]], 11, implicit-def $scc
  ; CHECK-NEXT:   S_CBRANCH_SCC1 %bb.6, implicit killed $scc
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[S_MOV_B64_:%[0-9]+]]:sreg_64_xexec = S_MOV_B64 -1
  ; CHECK-NEXT:   [[DEF:%[0-9]+]]:vreg_128 = IMPLICIT_DEF
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.Flow:
  ; CHECK-NEXT:   successors: %bb.4(0x40000000), %bb.3(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI:%[0-9]+]]:vreg_128 = PHI [[DEF]], %bb.1, %71, %bb.6
  ; CHECK-NEXT:   [[PHI1:%[0-9]+]]:sreg_64_xexec = PHI [[S_MOV_B64_]], %bb.1, %61, %bb.6
  ; CHECK-NEXT:   $vcc = S_ANDN2_B64 $exec, [[PHI1]], implicit-def dead $scc
  ; CHECK-NEXT:   S_CBRANCH_VCCNZ %bb.3, implicit $vcc
  ; CHECK-NEXT:   S_BRANCH %bb.4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.Flow3:
  ; CHECK-NEXT:   successors: %bb.5(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[PHI2:%[0-9]+]]:vreg_128 = PHI [[PHI]], %bb.2, %72, %bb.4
  ; CHECK-NEXT:   S_BRANCH %bb.5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.bb2:
  ; CHECK-NEXT:   successors: %bb.3(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_ADD_U32_e32_:%[0-9]+]]:vgpr_32 = V_ADD_U32_e32 [[S_LOAD_DWORD_IMM]], [[GLOBAL_LOAD_DWORDX4_SADDR]].sub0, implicit $exec
  ; CHECK-NEXT:   [[V_ADD_U32_e32_1:%[0-9]+]]:vgpr_32 = V_ADD_U32_e32 [[GLOBAL_LOAD_DWORDX4_SADDR]].sub1, [[GLOBAL_LOAD_DWORDX4_SADDR]].sub0, implicit $exec
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:vgpr_32 = COPY [[V_ADD_U32_e32_]]
  ; CHECK-NEXT:   [[REG_SEQUENCE:%[0-9]+]]:vreg_128 = REG_SEQUENCE [[GLOBAL_LOAD_DWORDX4_SADDR]].sub2_sub3, %subreg.sub2_sub3, [[V_ADD_U32_e32_1]], %subreg.sub1, [[COPY2]], %subreg.sub0
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:vreg_128 = COPY [[REG_SEQUENCE]]
  ; CHECK-NEXT:   S_BRANCH %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.5.bb3:
  ; CHECK-NEXT:   [[V_MUL_LO_U32_e64_:%[0-9]+]]:vgpr_32 = V_MUL_LO_U32_e64 [[PHI2]].sub1, [[PHI2]].sub2, implicit $exec
  ; CHECK-NEXT:   [[V_MUL_LO_U32_e64_1:%[0-9]+]]:vgpr_32 = V_MUL_LO_U32_e64 [[PHI2]].sub0, [[PHI2]].sub3, implicit $exec
  ; CHECK-NEXT:   [[V_MAD_U64_U32_e64_:%[0-9]+]]:vreg_64, dead [[V_MAD_U64_U32_e64_1:%[0-9]+]]:sreg_64 = V_MAD_U64_U32_e64 [[PHI2]].sub0, [[PHI2]].sub2, 0, 0, implicit $exec
  ; CHECK-NEXT:   [[V_MOV_B32_e32_:%[0-9]+]]:vgpr_32 = V_MOV_B32_e32 0, implicit $exec
  ; CHECK-NEXT:   [[V_ADD3_U32_e64_:%[0-9]+]]:vgpr_32 = V_ADD3_U32_e64 [[V_MAD_U64_U32_e64_]].sub1, [[V_MUL_LO_U32_e64_1]], [[V_MUL_LO_U32_e64_]], implicit $exec
  ; CHECK-NEXT:   [[REG_SEQUENCE1:%[0-9]+]]:vreg_64 = REG_SEQUENCE [[V_MAD_U64_U32_e64_]].sub0, %subreg.sub0, [[V_ADD3_U32_e64_]], %subreg.sub1
  ; CHECK-NEXT:   GLOBAL_STORE_DWORDX2_SADDR [[V_MOV_B32_e32_]], [[REG_SEQUENCE1]], %0.sub2_sub3, 176, 0, implicit $exec :: (store (s64) into %ir.gep2, addrspace 1)
  ; CHECK-NEXT:   S_ENDPGM 0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.6.bb4:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[V_ADD_U32_e32_2:%[0-9]+]]:vgpr_32 = V_ADD_U32_e32 [[S_LOAD_DWORD_IMM]], [[GLOBAL_LOAD_DWORDX4_SADDR]].sub1, implicit $exec
  ; CHECK-NEXT:   [[COPY4:%[0-9]+]]:vreg_128 = COPY [[GLOBAL_LOAD_DWORDX4_SADDR]]
  ; CHECK-NEXT:   [[COPY5:%[0-9]+]]:vgpr_32 = COPY [[V_ADD_U32_e32_2]]
  ; CHECK-NEXT:   [[S_MOV_B64_1:%[0-9]+]]:sreg_64_xexec = S_MOV_B64 0
  ; CHECK-NEXT:   [[REG_SEQUENCE2:%[0-9]+]]:vreg_128 = REG_SEQUENCE [[COPY4]].sub0, %subreg.sub0, [[COPY4]].sub1, %subreg.sub1, [[COPY4]].sub3, %subreg.sub3, [[COPY5]], %subreg.sub2
  ; CHECK-NEXT:   S_BRANCH %bb.2
  bb.0.bb0:
    successors: %bb.6(0x40000000), %bb.1(0x40000000)
    liveins: $vgpr0, $sgpr2_sgpr3

    %12:sgpr_64(p4) = COPY $sgpr2_sgpr3
    %8:vgpr_32(s32) = COPY $vgpr0
    early-clobber %0:sgpr_128 = S_LOAD_DWORDX4_IMM_ec %12(p4), 36, 0 :: (dereferenceable invariant load (s128) from %ir.in.kernarg.offset, align 4, addrspace 4)
    %20:sreg_32_xm0_xexec = S_LOAD_DWORD_IMM %12(p4), 52, 0 :: (dereferenceable invariant load (s32) from %ir.arg.kernarg.offset, addrspace 4)
    KILL %12(p4)
    %25:vgpr_32 = nuw nsw V_LSHLREV_B32_e32 2, %8(s32), implicit $exec
    %2:vreg_128 = GLOBAL_LOAD_DWORDX4_SADDR %0.sub0_sub1, %25, 0, 0, implicit $exec :: (load (s128) from %ir.gep, addrspace 1)
    S_CMP_LT_I32 %20, 11, implicit-def $scc
    S_CBRANCH_SCC1 %bb.6, implicit killed $scc

  bb.1:
    successors: %bb.2(0x80000000)

    %61:sreg_64_xexec = S_MOV_B64 -1
    %62:vreg_128 = IMPLICIT_DEF

  bb.2.Flow:
    successors: %bb.4(0x40000000), %bb.3(0x40000000)

    $vcc = S_ANDN2_B64 $exec, %61, implicit-def dead $scc
    S_CBRANCH_VCCNZ %bb.3, implicit $vcc
    S_BRANCH %bb.4

  bb.3.Flow3:
    successors: %bb.5(0x80000000)

    S_BRANCH %bb.5

  bb.4.bb2:
    successors: %bb.3(0x80000000)

    %34:vgpr_32 = V_ADD_U32_e32 %20, %2.sub0, implicit $exec
    %2.sub1:vreg_128 = V_ADD_U32_e32 %2.sub1, %2.sub0, implicit $exec
    %2.sub0:vreg_128 = COPY %34
    %62:vreg_128 = COPY %2
    S_BRANCH %bb.3

  bb.5.bb3:
    %46:vgpr_32 = V_MUL_LO_U32_e64 %62.sub1, %62.sub2, implicit $exec
    %47:vgpr_32 = V_MUL_LO_U32_e64 %62.sub0, %62.sub3, implicit $exec
    %57:vreg_64, dead %49:sreg_64 = V_MAD_U64_U32_e64 %62.sub0, %62.sub2, 0, 0, implicit $exec
    %41:vgpr_32 = V_MOV_B32_e32 0, implicit $exec
    %57.sub1:vreg_64 = V_ADD3_U32_e64 %57.sub1, %47, %46, implicit $exec
    GLOBAL_STORE_DWORDX2_SADDR %41, %57, %0.sub2_sub3, 176, 0, implicit $exec :: (store (s64) into %ir.gep2, addrspace 1)
    S_ENDPGM 0

  bb.6.bb4:
    successors: %bb.2(0x80000000)

    %29:vgpr_32 = V_ADD_U32_e32 %20, %2.sub1, implicit $exec
    %62:vreg_128 = COPY %2
    %62.sub2:vreg_128 = COPY %29
    %61:sreg_64_xexec = S_MOV_B64 0
    S_BRANCH %bb.2

...
