; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=amdgcn-amd-amdpal -mcpu=gfx900 -global-isel -verify-machineinstrs < %s | FileCheck -check-prefix=SI %s
; https://github.com/llvm/llvm-project/issues/130245

define amdgpu_ps i32 @s_bitset1_b32(i32 inreg %src0, i32 inreg %bit.index) {
; SI-LABEL: s_bitset1_b32:
; SI:       ; %bb.0:
; SI-NEXT:    s_bitset1_b32 s0, s1
; SI-NEXT:    ; return to shader part epilog
  %set.bit.at.index = shl i32 1, %bit.index
  %or = or i32 %src0, %set.bit.at.index
  ret i32 %or
}

define amdgpu_ps i32 @s_bitset1_b32_no_opt(i32 inreg %src0, i32 inreg %bit.index) {
; SI-LABEL: s_bitset1_b32_no_opt:
; SI:       ; %bb.0:
; SI-NEXT:    s_lshl_b32 s1, 2, s1
; SI-NEXT:    s_or_b32 s0, s0, s1
; SI-NEXT:    ; return to shader part epilog
  %set.bit.at.index = shl i32 2, %bit.index
  %or = or i32 %src0, %set.bit.at.index
  ret i32 %or
}

define amdgpu_ps float @s_bitset1_b32_v(i32 %src0, i32 %bit.index) {
; SI-LABEL: s_bitset1_b32_v:
; SI:       ; %bb.0:
; SI-NEXT:    v_lshl_or_b32 v0, 1, v1, v0
; SI-NEXT:    ; return to shader part epilog
  %set.bit.at.index = shl i32 1, %bit.index
  %or = or i32 %src0, %set.bit.at.index
  %bc = bitcast i32 %or to float
  ret float %bc
}

define amdgpu_ps i32 @s_bitset0_b32(i32 inreg %src0, i32 inreg %bit.index) {
; SI-LABEL: s_bitset0_b32:
; SI:       ; %bb.0:
; SI-NEXT:    s_bitset0_b32 s0, s1
; SI-NEXT:    ; return to shader part epilog
  %set.bit.at.index = shl i32 1, %bit.index
  %other.bits = xor i32 %set.bit.at.index, -1
  %and = and i32 %src0, %other.bits
  ret i32 %and
}

define amdgpu_ps i32 @s_bitset0_b32_no_opt(i32 inreg %src0, i32 inreg %bit.index) {
; SI-LABEL: s_bitset0_b32_no_opt:
; SI:       ; %bb.0:
; SI-NEXT:    s_lshl_b32 s1, 10, s1
; SI-NEXT:    s_andn2_b32 s0, s0, s1
; SI-NEXT:    ; return to shader part epilog
  %set.bit.at.index = shl i32 10, %bit.index
  %other.bits = xor i32 %set.bit.at.index, -1
  %and = and i32 %src0, %other.bits
  ret i32 %and
}

define amdgpu_ps float @s_bitset0_b32_v(i32 %src0, i32 %bit.index) {
; SI-LABEL: s_bitset0_b32_v:
; SI:       ; %bb.0:
; SI-NEXT:    v_lshlrev_b32_e64 v1, v1, 1
; SI-NEXT:    v_not_b32_e32 v1, v1
; SI-NEXT:    v_and_b32_e32 v0, v0, v1
; SI-NEXT:    ; return to shader part epilog
  %set.bit.at.index = shl i32 1, %bit.index
  %other.bits = xor i32 %set.bit.at.index, -1
  %and = and i32 %src0, %other.bits
  %bc = bitcast i32 %and to float
  ret float %bc
}

define amdgpu_ps <4 x i32> @v_test(<4 x i32> %src0, <4 x i32> %bit.index) {
; SI-LABEL: v_test:
; SI:       ; %bb.0:
; SI-NEXT:    v_lshl_or_b32 v0, 1, v4, v0
; SI-NEXT:    v_lshl_or_b32 v1, 1, v5, v1
; SI-NEXT:    v_lshl_or_b32 v2, 1, v6, v2
; SI-NEXT:    v_lshl_or_b32 v3, 1, v7, v3
; SI-NEXT:    v_readfirstlane_b32 s0, v0
; SI-NEXT:    v_readfirstlane_b32 s1, v1
; SI-NEXT:    v_readfirstlane_b32 s2, v2
; SI-NEXT:    v_readfirstlane_b32 s3, v3
; SI-NEXT:    ; return to shader part epilog
  %set.bit.at.index = shl <4 x i32> <i32 1, i32 1, i32 1, i32 1>, %bit.index
  %or = or <4 x i32> %src0, %set.bit.at.index
  ret <4 x i32> %or
}
