; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=amdgcn-- -mcpu=gfx1300 -amdgpu-promote-private=false -stop-after=finalize-isel -verify-machineinstrs -o - %s | FileCheck -check-prefix=NOVIDX %s
; RUN: llc -mtriple=amdgcn-- -mcpu=gfx1300 -amdgpu-promote-private=true -stop-after=finalize-isel -verify-machineinstrs -o - %s | FileCheck -check-prefix=VIDX %s
; RUN: llc -mtriple=amdgcn-- -mcpu=gfx1300 -amdgpu-promote-private=true -stop-after=amdgpu-idx-reg-alloc -verify-machineinstrs -o - %s | FileCheck -check-prefix=SETIDX %s

define amdgpu_kernel void @private_load_store() {
  ; NOVIDX-LABEL: name: private_load_store
  ; NOVIDX: bb.0.entry:
  ; NOVIDX-NEXT:   [[SCRATCH_LOAD_DWORD_SADDR:%[0-9]+]]:vgpr_32 = SCRATCH_LOAD_DWORD_SADDR %stack.0.p, 4, 0, implicit $exec, implicit $flat_scr :: (dereferenceable load (s32) from %ir.p.1, addrspace 5)
  ; NOVIDX-NEXT:   SCRATCH_STORE_DWORD_SADDR killed [[SCRATCH_LOAD_DWORD_SADDR]], %stack.0.p, 8, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %ir.p.2, addrspace 5)
  ; NOVIDX-NEXT:   [[SCRATCH_LOAD_DWORD_SADDR1:%[0-9]+]]:vgpr_32 = SCRATCH_LOAD_DWORD_SADDR %stack.1.q, 4, 0, implicit $exec, implicit $flat_scr :: (dereferenceable load (s32) from %ir.q.1, addrspace 5)
  ; NOVIDX-NEXT:   SCRATCH_STORE_DWORD_SADDR killed [[SCRATCH_LOAD_DWORD_SADDR1]], %stack.1.q, 8, 0, implicit $exec, implicit $flat_scr :: (store (s32) into %ir.q.2, addrspace 5)
  ; NOVIDX-NEXT:   S_ENDPGM 0
  ;
  ; VIDX-LABEL: name: private_load_store
  ; VIDX: bb.0.entry:
  ; VIDX-NEXT:   [[S_MOV_B32_:%[0-9]+]]:sreg_32_xexec_hi = S_MOV_B32 124
  ; VIDX-NEXT:   [[S_LSHR_B32_:%[0-9]+]]:sreg_32_xexec_hi = S_LSHR_B32 [[S_MOV_B32_]], 2, implicit-def dead $scc
  ; VIDX-NEXT:   [[V_LOAD_IDX:%[0-9]+]]:vgpr_32 = V_LOAD_IDX [[S_LSHR_B32_]], 0, implicit $exec :: (dereferenceable load (s32) from %ir.p.1, addrspace 5)
  ; VIDX-NEXT:   [[S_MOV_B32_1:%[0-9]+]]:sreg_32_xexec_hi = S_MOV_B32 128
  ; VIDX-NEXT:   [[S_LSHR_B32_1:%[0-9]+]]:sreg_32_xexec_hi = S_LSHR_B32 [[S_MOV_B32_1]], 2, implicit-def dead $scc
  ; VIDX-NEXT:   V_STORE_IDX [[V_LOAD_IDX]], [[S_LSHR_B32_1]], 0, implicit $exec :: (store (s32) into %ir.p.2, addrspace 5)
  ; VIDX-NEXT:   [[S_MOV_B32_2:%[0-9]+]]:sreg_32_xexec_hi = S_MOV_B32 4
  ; VIDX-NEXT:   [[S_LSHR_B32_2:%[0-9]+]]:sreg_32_xexec_hi = S_LSHR_B32 [[S_MOV_B32_2]], 2, implicit-def dead $scc
  ; VIDX-NEXT:   [[V_LOAD_IDX1:%[0-9]+]]:vgpr_32 = V_LOAD_IDX [[S_LSHR_B32_2]], 0, implicit $exec :: (dereferenceable load (s32) from %ir.q.1, addrspace 5)
  ; VIDX-NEXT:   [[S_MOV_B32_3:%[0-9]+]]:sreg_32_xexec_hi = S_MOV_B32 8
  ; VIDX-NEXT:   [[S_LSHR_B32_3:%[0-9]+]]:sreg_32_xexec_hi = S_LSHR_B32 [[S_MOV_B32_3]], 2, implicit-def dead $scc
  ; VIDX-NEXT:   V_STORE_IDX [[V_LOAD_IDX1]], [[S_LSHR_B32_3]], 0, implicit $exec :: (store (s32) into %ir.q.2, addrspace 5)
  ; VIDX-NEXT:   S_ENDPGM 0
  ;
  ; SETIDX-LABEL: name: private_load_store
  ; SETIDX: bb.0.entry:
  ; SETIDX-NEXT:   $idx1 = S_SET_GPR_IDX_U32 0
  ; SETIDX-NEXT:   BUNDLE implicit-def $stg_dsta, implicit $idx1, implicit $exec {
  ; SETIDX-NEXT:     $stg_dsta = V_LOAD_IDX $idx1, 31, implicit $exec :: (dereferenceable load (s32) from %ir.p.1, addrspace 5)
  ; SETIDX-NEXT:     V_STORE_IDX internal $stg_dsta, $idx1, 32, implicit $exec :: (store (s32) into %ir.p.2, addrspace 5)
  ; SETIDX-NEXT:   }
  ; SETIDX-NEXT:   BUNDLE implicit-def $stg_dsta, implicit $idx1, implicit $exec {
  ; SETIDX-NEXT:     $stg_dsta = V_LOAD_IDX $idx1, 1, implicit $exec :: (dereferenceable load (s32) from %ir.q.1, addrspace 5)
  ; SETIDX-NEXT:     V_STORE_IDX internal $stg_dsta, $idx1, 2, implicit $exec :: (store (s32) into %ir.q.2, addrspace 5)
  ; SETIDX-NEXT:   }
  ; SETIDX-NEXT:   S_ENDPGM 0
entry:
  %p = alloca [30 x float], align 4, addrspace(5)
  %q = alloca [30 x float], align 4, addrspace(5)

  %p.1 = getelementptr [30 x float], ptr addrspace(5) %p, i64 0, i64 1
  %v = load float, ptr addrspace(5) %p.1, align 4

  %p.2 = getelementptr [30 x float], ptr addrspace(5) %p, i64 0, i64 2
  store float %v, ptr addrspace(5) %p.2, align 4

  %q.1 = getelementptr [30 x float], ptr addrspace(5) %q, i64 0, i64 1
  %w = load float, ptr addrspace(5) %q.1, align 4

  %q.2 = getelementptr [30 x float], ptr addrspace(5) %q, i64 0, i64 2
  store float %w, ptr addrspace(5) %q.2, align 4

  ret void
}
