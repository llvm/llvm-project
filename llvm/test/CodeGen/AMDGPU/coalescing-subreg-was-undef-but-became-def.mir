# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=amdgcn -mcpu=gfx803 -run-pass register-coalescer -verify-machineinstrs -o - %s | FileCheck %s
#
# This is another example of a test giving "Couldn't join subrange!"
#
# This shows a case where a whole reg use point of the whole register was
# undefined in one subreg, but after coalescing it became defined but the
# subrange was not updated to reflect that.
#

---
name: coalescing_makes_lane_defined
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: coalescing_makes_lane_defined
  ; CHECK: bb.0:
  ; CHECK-NEXT:   successors: %bb.1(0x40000000), %bb.2(0x40000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   undef [[S_MOV_B32_:%[0-9]+]].sub2:sgpr_128 = S_MOV_B32 0
  ; CHECK-NEXT:   dead undef [[S_MOV_B32_1:%[0-9]+]].sub0:sgpr_128 = S_MOV_B32 0
  ; CHECK-NEXT:   S_CBRANCH_SCC0 %bb.2, implicit undef $scc
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[S_MOV_B32_:%[0-9]+]].sub0:sgpr_128 = S_MOV_B32 -1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2:
  ; CHECK-NEXT:   S_NOP 0, implicit [[S_MOV_B32_]]
  bb.0:
    successors: %bb.1, %bb.2

    %0:sreg_32_xm0 = S_MOV_B32 0
    undef %1.sub2:sgpr_128 = COPY %0
    undef %2.sub0:sgpr_128 = S_MOV_B32 0
    undef %3.sub2:sgpr_128 = COPY %0
    S_CBRANCH_SCC0 %bb.2, implicit undef $scc

  bb.1:
    successors: %bb.2

    undef %4.sub0:sgpr_128 = S_MOV_B32 -1
    %4.sub2:sgpr_128 = COPY killed %0
    %5:sgpr_128 = COPY killed %4
    %6:sgpr_128 = COPY killed %1
    %3:sgpr_128 = COPY killed %6
    %2:sgpr_128 = COPY killed %5

  bb.2:
    S_NOP 0, implicit killed %3

...
