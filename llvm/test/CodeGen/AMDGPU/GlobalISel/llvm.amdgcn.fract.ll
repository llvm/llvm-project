; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -global-isel -new-reg-bank-select -mtriple=amdgcn -mcpu=gfx1200 < %s | FileCheck -check-prefix=GFX12 %s

declare half @llvm.amdgcn.fract.f16(half)
declare float @llvm.amdgcn.fract.f32(float)
declare double @llvm.amdgcn.fract.f64(double)

define amdgpu_ps half @s_fract_f16(half inreg %src) {
; GFX12-LABEL: s_fract_f16:
; GFX12:       ; %bb.0:
; GFX12-NEXT:    v_fract_f16_e32 v0, s0
; GFX12-NEXT:    s_delay_alu instid0(VALU_DEP_1) | instskip(SKIP_2) | instid1(SALU_CYCLE_2)
; GFX12-NEXT:    v_readfirstlane_b32 s0, v0
; GFX12-NEXT:    s_add_f16 s0, s0, s0
; GFX12-NEXT:    s_wait_alu depctr_sa_sdst(0)
; GFX12-NEXT:    v_mov_b32_e32 v0, s0
; GFX12-NEXT:    ; return to shader part epilog
  %fract = call half @llvm.amdgcn.fract.f16(half %src)
  %res = fadd half %fract, %fract
  ret half %res
}

define amdgpu_ps half @v_fract_f16(half %src) {
; GFX12-LABEL: v_fract_f16:
; GFX12:       ; %bb.0:
; GFX12-NEXT:    v_fract_f16_e32 v0, v0
; GFX12-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX12-NEXT:    v_add_f16_e32 v0, v0, v0
; GFX12-NEXT:    ; return to shader part epilog
  %fract = call half @llvm.amdgcn.fract.f16(half %src)
  %res = fadd half %fract, %fract
  ret half %res
}

define amdgpu_ps float @s_fract_f32(float inreg %src) {
; GFX12-LABEL: s_fract_f32:
; GFX12:       ; %bb.0:
; GFX12-NEXT:    v_fract_f32_e32 v0, s0
; GFX12-NEXT:    s_delay_alu instid0(VALU_DEP_1) | instskip(SKIP_2) | instid1(SALU_CYCLE_2)
; GFX12-NEXT:    v_readfirstlane_b32 s0, v0
; GFX12-NEXT:    s_add_f32 s0, s0, s0
; GFX12-NEXT:    s_wait_alu depctr_sa_sdst(0)
; GFX12-NEXT:    v_mov_b32_e32 v0, s0
; GFX12-NEXT:    ; return to shader part epilog
  %fract = call float @llvm.amdgcn.fract.f32(float %src)
  %res = fadd float %fract, %fract
  ret float %res
}

define amdgpu_ps float @v_fract_f32(float %src) {
; GFX12-LABEL: v_fract_f32:
; GFX12:       ; %bb.0:
; GFX12-NEXT:    v_fract_f32_e32 v0, v0
; GFX12-NEXT:    s_delay_alu instid0(VALU_DEP_1)
; GFX12-NEXT:    v_add_f32_e32 v0, v0, v0
; GFX12-NEXT:    ; return to shader part epilog
  %fract = call float @llvm.amdgcn.fract.f32(float %src)
  %res = fadd float %fract, %fract
  ret float %res
}

define amdgpu_ps void @s_fract_f64(double inreg %src, ptr addrspace(1) %out) {
; GFX12-LABEL: s_fract_f64:
; GFX12:       ; %bb.0:
; GFX12-NEXT:    v_fract_f64_e32 v[2:3], s[0:1]
; GFX12-NEXT:    s_mov_b32 s2, 0
; GFX12-NEXT:    s_brev_b32 s3, 1
; GFX12-NEXT:    s_delay_alu instid0(VALU_DEP_1) | instskip(NEXT) | instid1(VALU_DEP_2)
; GFX12-NEXT:    v_readfirstlane_b32 s0, v2
; GFX12-NEXT:    v_readfirstlane_b32 s1, v3
; GFX12-NEXT:    s_xor_b64 s[0:1], s[0:1], s[2:3]
; GFX12-NEXT:    s_wait_alu depctr_sa_sdst(0)
; GFX12-NEXT:    v_dual_mov_b32 v3, s1 :: v_dual_mov_b32 v2, s0
; GFX12-NEXT:    global_store_b64 v[0:1], v[2:3], off
; GFX12-NEXT:    s_endpgm
 %fract = call double @llvm.amdgcn.fract.f64(double %src)
 %fract.i64 = bitcast double %fract to i64
 %neg = xor i64 %fract.i64, u0x8000000000000000
 store i64 %neg, ptr addrspace(1) %out
 ret void
}

define amdgpu_ps double @v_fract_f64(double %src) {
; GFX12-LABEL: v_fract_f64:
; GFX12:       ; %bb.0:
; GFX12-NEXT:    v_fract_f64_e32 v[0:1], v[0:1]
; GFX12-NEXT:    s_delay_alu instid0(VALU_DEP_1) | instskip(NEXT) | instid1(VALU_DEP_1)
; GFX12-NEXT:    v_add_f64_e32 v[0:1], v[0:1], v[0:1]
; GFX12-NEXT:    v_readfirstlane_b32 s0, v0
; GFX12-NEXT:    s_delay_alu instid0(VALU_DEP_2)
; GFX12-NEXT:    v_readfirstlane_b32 s1, v1
; GFX12-NEXT:    ; return to shader part epilog
  %fract = call double @llvm.amdgcn.fract.f64(double %src)
  %res = fadd double %fract, %fract
  ret double %res
}
