# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=amdgcn-amd-amdhsa -mcpu=gfx908 -amdgpu-spill-sgpr-to-vgpr=false -verify-machineinstrs -run-pass=si-lower-sgpr-spills,prologepilog -o - %s | FileCheck %s

# Check that we allocate 2 emergency stack slots if we're spilling
# SGPRs to memory and potentially have an offset larger than fits in
# the addressing mode of the memory instructions.

---
name:            test
tracksRegLiveness: true
frameInfo:
  maxAlignment:    4
stack:
  - { id: 0, type: spill-slot, size: 4, alignment: 4, stack-id: sgpr-spill }
  - { id: 1, size: 4096, alignment: 4 }
machineFunctionInfo:
  isEntryFunction: false
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  stackPtrOffsetReg: '$sgpr32'
  frameOffsetReg: '$sgpr33'
  hasSpilledSGPRs: true
body:             |
  bb.0:
    liveins: $sgpr30_sgpr31, $sgpr10, $sgpr11
    ; CHECK-LABEL: name: test
    ; CHECK: liveins: $sgpr30_sgpr31, $sgpr10, $sgpr11
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: S_CMP_EQ_U32 0, 0, implicit-def $scc
    ; CHECK-NEXT: $sgpr6_sgpr7 = S_MOV_B64 $exec
    ; CHECK-NEXT: $exec = S_MOV_B64 1, implicit-def $vgpr2
    ; CHECK-NEXT: BUFFER_STORE_DWORD_OFFSET killed $vgpr2, $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 0, 0, 0, implicit $exec :: (store (s32) into %stack.2, addrspace 5)
    ; CHECK-NEXT: $vgpr2 = V_WRITELANE_B32 killed $sgpr10, 0, undef $vgpr2
    ; CHECK-NEXT: BUFFER_STORE_DWORD_OFFSET killed $vgpr2, $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 8, 0, 0, implicit $exec :: (store (s32) into %stack.0, addrspace 5)
    ; CHECK-NEXT: $vgpr2 = BUFFER_LOAD_DWORD_OFFSET $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 0, 0, 0, implicit $exec :: (load (s32) from %stack.2, addrspace 5)
    ; CHECK-NEXT: $exec = S_MOV_B64 killed $sgpr6_sgpr7, implicit killed $vgpr2
    ; CHECK-NEXT: $sgpr4_sgpr5 = S_MOV_B64 $exec
    ; CHECK-NEXT: $exec = S_MOV_B64 1, implicit-def $vgpr1
    ; CHECK-NEXT: BUFFER_STORE_DWORD_OFFSET killed $vgpr1, $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 0, 0, 0, implicit $exec :: (store (s32) into %stack.2, addrspace 5)
    ; CHECK-NEXT: $vgpr1 = BUFFER_LOAD_DWORD_OFFSET $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 8, 0, 0, implicit $exec :: (load (s32) from %stack.0, addrspace 5)
    ; CHECK-NEXT: $sgpr10 = V_READLANE_B32 killed $vgpr1, 0
    ; CHECK-NEXT: $vgpr1 = BUFFER_LOAD_DWORD_OFFSET $sgpr0_sgpr1_sgpr2_sgpr3, $sgpr32, 0, 0, 0, implicit $exec :: (load (s32) from %stack.2, addrspace 5)
    ; CHECK-NEXT: $exec = S_MOV_B64 killed $sgpr4_sgpr5, implicit killed $vgpr1
    ; CHECK-NEXT: S_SETPC_B64 $sgpr30_sgpr31, implicit $scc
    S_CMP_EQ_U32 0, 0, implicit-def $scc
    SI_SPILL_S32_SAVE killed $sgpr10, %stack.0, implicit $exec, implicit $sgpr0_sgpr1_sgpr2_sgpr3, implicit $sgpr32
    renamable $sgpr10 = SI_SPILL_S32_RESTORE %stack.0, implicit $exec, implicit $sgpr0_sgpr1_sgpr2_sgpr3, implicit $sgpr32
    S_SETPC_B64 $sgpr30_sgpr31, implicit $scc
...
