; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -passes=amdgpu-promote-alloca < %s | FileCheck %s

define amdgpu_kernel void @test_bitcast_gen_64i8_v16i8(ptr addrspace(1) %out, i32 %idx) #0 {
; CHECK-LABEL: define amdgpu_kernel void @test_bitcast_gen_64i8_v16i8(
; CHECK-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOCA:%.*]] = freeze <64 x i8> poison
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[ALLOCA]] to <4 x i128>
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 [[IDX]], 16
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i128> [[TMP0]], i32 [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i128 [[TMP2]] to <16 x i8>
; CHECK-NEXT:    store <16 x i8> [[TMP3]], ptr addrspace(1) [[OUT]], align 16
; CHECK-NEXT:    ret void
;
entry:
  %alloca = alloca [4 x [16 x i8]], align 16, addrspace(5)
  %gep = getelementptr <16 x i8>, ptr addrspace(5) %alloca, i32 0, i32 %idx
  %load = load <16 x i8>, ptr addrspace(5) %gep, align 16
  store <16 x i8> %load, ptr addrspace(1) %out, align 16
  ret void
}

define amdgpu_kernel void @test_bitcast_gen_32i16_v8i16(ptr addrspace(1) %out, i32 %idx) #0 {
; CHECK-LABEL: define amdgpu_kernel void @test_bitcast_gen_32i16_v8i16(
; CHECK-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOCA:%.*]] = freeze <32 x i16> poison
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <32 x i16> [[ALLOCA]] to <4 x i128>
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 [[IDX]], 8
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i128> [[TMP0]], i32 [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i128 [[TMP2]] to <8 x i16>
; CHECK-NEXT:    store <8 x i16> [[TMP3]], ptr addrspace(1) [[OUT]], align 16
; CHECK-NEXT:    ret void
;
entry:
  %alloca = alloca [32 x i16], align 16, addrspace(5)
  %gep = getelementptr <8 x i16>, ptr addrspace(5) %alloca, i32 0, i32 %idx
  %load = load <8 x i16>, ptr addrspace(5) %gep, align 16
  store <8 x i16> %load, ptr addrspace(1) %out, align 16
  ret void
}

define amdgpu_kernel void @test_bitcast_gen_64i8_v32i8(ptr addrspace(1) %out, i32 %idx) #0 {
; CHECK-LABEL: define amdgpu_kernel void @test_bitcast_gen_64i8_v32i8(
; CHECK-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOCA:%.*]] = freeze <64 x i8> poison
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <64 x i8> [[ALLOCA]] to <2 x i256>
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 [[IDX]], 32
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <2 x i256> [[TMP0]], i32 [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i256 [[TMP2]] to <32 x i8>
; CHECK-NEXT:    store <32 x i8> [[TMP3]], ptr addrspace(1) [[OUT]], align 16
; CHECK-NEXT:    ret void
;
entry:
  %alloca = alloca [2 x [32 x i8]], align 16, addrspace(5)
  %gep = getelementptr <32 x i8>, ptr addrspace(5) %alloca, i32 0, i32 %idx
  %load = load <32 x i8>, ptr addrspace(5) %gep, align 16
  store <32 x i8> %load, ptr addrspace(1) %out, align 16
  ret void
}

define amdgpu_kernel void @test_bitcast_gen_16i32_v4i32(ptr addrspace(1) %out, i32 %idx) #0 {
; CHECK-LABEL: define amdgpu_kernel void @test_bitcast_gen_16i32_v4i32(
; CHECK-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOCA:%.*]] = freeze <16 x i32> poison
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <16 x i32> [[ALLOCA]] to <4 x i128>
; CHECK-NEXT:    [[TMP1:%.*]] = udiv i32 [[IDX]], 4
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i128> [[TMP0]], i32 [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i128 [[TMP2]] to <4 x i32>
; CHECK-NEXT:    store <4 x i32> [[TMP3]], ptr addrspace(1) [[OUT]], align 16
; CHECK-NEXT:    ret void
;
entry:
  %alloca = alloca [16 x i32], align 16, addrspace(5)
  %gep = getelementptr <4 x i32>, ptr addrspace(5) %alloca, i32 0, i32 %idx
  %load = load <4 x i32>, ptr addrspace(5) %gep, align 16
  store <4 x i32> %load, ptr addrspace(1) %out, align 16
  ret void
}


define amdgpu_kernel void @test_bitcast_gen_unaligned_gep(ptr addrspace(1) %out, i32 %idx) #0 {
; CHECK-LABEL: define amdgpu_kernel void @test_bitcast_gen_unaligned_gep(
; CHECK-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[IDX:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOCA:%.*]] = freeze <32 x i16> poison
; CHECK-NEXT:    [[TMP0:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[IDX]]
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <8 x i16> poison, i16 [[TMP0]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 [[IDX]], 1
; CHECK-NEXT:    [[TMP22:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <8 x i16> [[TMP1]], i16 [[TMP22]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = add i32 [[IDX]], 2
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = insertelement <8 x i16> [[TMP4]], i16 [[TMP6]], i64 2
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[IDX]], 3
; CHECK-NEXT:    [[TMP9:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <8 x i16> [[TMP7]], i16 [[TMP9]], i64 3
; CHECK-NEXT:    [[TMP11:%.*]] = add i32 [[IDX]], 4
; CHECK-NEXT:    [[TMP12:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = insertelement <8 x i16> [[TMP10]], i16 [[TMP12]], i64 4
; CHECK-NEXT:    [[TMP14:%.*]] = add i32 [[IDX]], 5
; CHECK-NEXT:    [[TMP15:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[TMP14]]
; CHECK-NEXT:    [[TMP16:%.*]] = insertelement <8 x i16> [[TMP13]], i16 [[TMP15]], i64 5
; CHECK-NEXT:    [[TMP17:%.*]] = add i32 [[IDX]], 6
; CHECK-NEXT:    [[TMP18:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[TMP17]]
; CHECK-NEXT:    [[TMP19:%.*]] = insertelement <8 x i16> [[TMP16]], i16 [[TMP18]], i64 6
; CHECK-NEXT:    [[TMP20:%.*]] = add i32 [[IDX]], 7
; CHECK-NEXT:    [[TMP21:%.*]] = extractelement <32 x i16> [[ALLOCA]], i32 [[TMP20]]
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <8 x i16> [[TMP19]], i16 [[TMP21]], i64 7
; CHECK-NEXT:    store <8 x i16> [[TMP3]], ptr addrspace(1) [[OUT]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %alloca = alloca [32 x i16], align 1, addrspace(5)
  %gep = getelementptr i16, ptr addrspace(5) %alloca, i32 %idx
  %load = load <8 x i16>, ptr addrspace(5) %gep, align 1
  store <8 x i16> %load, ptr addrspace(1) %out, align 1
  ret void
}
