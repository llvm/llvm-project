; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -passes=amdgpu-attributor %s -o - | FileCheck %s

@g1 = protected addrspace(1) externally_initialized global i32 0, align 4
@g2 = protected addrspace(1) externally_initialized global i32 0, align 4
@g3 = protected addrspace(1) externally_initialized global i32 0, align 4

define internal void @callee_with_always_uniform_argument(ptr addrspace(1) %x, i32 %y) {
; CHECK-LABEL: define internal void @callee_with_always_uniform_argument(
; CHECK-SAME: ptr addrspace(1) inreg [[X:%.*]], i32 inreg [[Y:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[X_VAL:%.*]] = load i32, ptr addrspace(1) [[X]], align 4
; CHECK-NEXT:    store i32 [[X_VAL]], ptr addrspace(1) @g2, align 4
; CHECK-NEXT:    store i32 [[Y]], ptr addrspace(1) @g3, align 4
; CHECK-NEXT:    ret void
;
entry:
  %x.val = load i32, ptr addrspace(1) %x, align 4
  store i32 %x.val, ptr addrspace(1) @g2, align 4
  store i32 %y, ptr addrspace(1) @g3, align 4
  ret void
}

define amdgpu_kernel void @kernel_with_readfirstlane(ptr addrspace(1) %p, i32 %x) {
; CHECK-LABEL: define amdgpu_kernel void @kernel_with_readfirstlane(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]], i32 [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[P0:%.*]] = call ptr addrspace(1) @llvm.amdgcn.readfirstlane.p1(ptr addrspace(1) [[P]])
; CHECK-NEXT:    call void @callee_with_always_uniform_argument(ptr addrspace(1) [[P0]], i32 [[X]])
; CHECK-NEXT:    ret void
;
entry:
  %p0 = call ptr addrspace(1) @llvm.amdgcn.readfirstlane.p1(ptr addrspace(1) %p)
  call void @callee_with_always_uniform_argument(ptr addrspace(1) %p0, i32 %x)
  ret void
}

define amdgpu_kernel void @kernel_with_constant(i32 %x) {
; CHECK-LABEL: define amdgpu_kernel void @kernel_with_constant(
; CHECK-SAME: i32 [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @callee_with_always_uniform_argument(ptr addrspace(1) @g1, i32 [[X]])
; CHECK-NEXT:    ret void
;
entry:
  call void @callee_with_always_uniform_argument(ptr addrspace(1) @g1, i32 %x)
  ret void
}

define internal void @callee_without_always_uniform_argument(ptr addrspace(1) %x, i32 %y) {
; CHECK-LABEL: define internal void @callee_without_always_uniform_argument(
; CHECK-SAME: ptr addrspace(1) [[X:%.*]], i32 [[Y:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[X_VAL:%.*]] = load i32, ptr addrspace(1) [[X]], align 4
; CHECK-NEXT:    store i32 [[X_VAL]], ptr addrspace(1) @g2, align 4
; CHECK-NEXT:    store i32 [[Y]], ptr addrspace(1) @g3, align 4
; CHECK-NEXT:    ret void
;
entry:
  %x.val = load i32, ptr addrspace(1) %x, align 4
  store i32 %x.val, ptr addrspace(1) @g2, align 4
  store i32 %y, ptr addrspace(1) @g3, align 4
  ret void
}

define amdgpu_kernel void @kernel_with_divergent_callsite_argument(ptr addrspace(1) %p, i32 %x) {
; CHECK-LABEL: define amdgpu_kernel void @kernel_with_divergent_callsite_argument(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]], i32 [[X:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ID_X:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr addrspace(1) [[P]], i32 [[ID_X]]
; CHECK-NEXT:    [[D:%.*]] = load i32, ptr addrspace(1) [[GEP]], align 4
; CHECK-NEXT:    call void @callee_without_always_uniform_argument(ptr addrspace(1) [[GEP]], i32 [[D]])
; CHECK-NEXT:    ret void
;
entry:
  %id.x = call i32 @llvm.amdgcn.workitem.id.x()
  %gep = getelementptr i32, ptr addrspace(1) %p, i32 %id.x
  %d = load i32, ptr addrspace(1) %gep
  call void @callee_without_always_uniform_argument(ptr addrspace(1) %gep, i32 %d)
  ret void
}

declare ptr addrspace(1) @llvm.amdgcn.readfirstlane.p1(ptr addrspace(1))
declare noundef i32 @llvm.amdgcn.workitem.id.x()
