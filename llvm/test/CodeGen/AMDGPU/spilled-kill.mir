# RUN: llc -mtriple=amdgcn -mcpu=tahiti -verify-machineinstrs -start-before=prologepilog -stop-after=postrapseudos -o - %s | FileCheck -check-prefix=GCN %s

# This testcase shows the necessity of adding an undef flag to the $sgpr source when
# creating a V_WRITELANE_B32.
#
# The prologepilog pass will create a:
#
#   $exec = S_MOV_B64 killed $sgpr4_sgpr5
#
# but $sgpr5 will be spilled by a:
#
#   $vgpr1 = SI_SPILL_S32_TO_VGPR $sgpr5, 1, killed $vgpr1(tied-def 0), implicit $sgpr4_sgpr5
#
# The SI_SPILL_S32_TO_VGPR will be converted in postrapseudos to:
#
#   $vgpr1 = V_WRITELANE_B32 undef $sgpr5, 1, killed $vgpr1(tied-def 0)
#
# The undef flag is necessary to satisfy the MachineVerifier since $sgpr5 is used after a kill.
# This testcase was derived from function bitcast_v32i16_to_v64i8_scalar in amdgcn.bitcast.512bit.ll.

# GCN-LABEL: name: bitcast_v32i16_to_v64i8_scalar
---
name:            bitcast_v32i16_to_v64i8_scalar
tracksRegLiveness: true
machineFunctionInfo:
  scratchRSrcReg:  '$sgpr0_sgpr1_sgpr2_sgpr3'
  stackPtrOffsetReg: '$sgpr32'
  wwmReservedRegs:
    - '$vgpr62'
body:             |
  bb.0:
    successors: %bb.3(0x40000000), %bb.1(0x40000000)
  
    renamable $sgpr4 = IMPLICIT_DEF
    $vgpr62 = SI_SPILL_S32_TO_VGPR $sgpr5, 1, killed $vgpr62, implicit $sgpr4_sgpr5
    S_CBRANCH_EXECZ %bb.1, implicit $exec
    S_BRANCH %bb.3
  
  bb.1:
    successors: %bb.2(0x40000000), %bb.4(0x40000000)
  
    S_CBRANCH_EXECZ %bb.4, implicit $exec
    S_BRANCH %bb.2
  
  bb.2:
    successors: %bb.4(0x80000000)
  
    S_BRANCH %bb.4
  
  bb.3:
    successors: %bb.1(0x80000000)
  
    S_BRANCH %bb.1
  
  bb.4:
  
    SI_RETURN
...
