; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-globals
; RUN: opt -S -mtriple=amdgcn-- -passes=amdgpu-lower-module-lds < %s | FileCheck %s

; Regression test for issue 160181
; One variable is chosen to be assigned at zero. Here, that's @both
; Then other variables should be allocated at fixed offsets from that provided
; they are allocated by all the other kernels that presently allocate the
; variable at address zero.
; The failure mode was in that second check - variables could be added to
; the module scope zero address struct even when some of the kernels allocating
; that struct do not need the additional variable.

; With current llvm, all three of these integers are put in the module scope struct, when
; neither kern_one or kern_two access all three.

@both = addrspace(3) global i32 poison
@both_second = addrspace(3) global i16 poison ; a second field in the module struct
@one = addrspace(3) global i32 poison
@two = addrspace(3) global i32 poison


;.
; CHECK: @llvm.amdgcn.module.lds = internal addrspace(3) global %llvm.amdgcn.module.lds.t poison, align 4, !absolute_symbol [[META0:![0-9]+]]
; CHECK: @llvm.compiler.used = appending addrspace(1) global [1 x ptr] [ptr addrspacecast (ptr addrspace(3) @llvm.amdgcn.module.lds to ptr)], section "llvm.metadata"
; CHECK: @llvm.amdgcn.kernel.kern_one.lds = internal addrspace(3) global %llvm.amdgcn.kernel.kern_one.lds.t poison, align 4, !absolute_symbol [[META1:![0-9]+]]
; CHECK: @llvm.amdgcn.kernel.kern_two.lds = internal addrspace(3) global %llvm.amdgcn.kernel.kern_two.lds.t poison, align 4, !absolute_symbol [[META1]]
; CHECK: @llvm.amdgcn.kernel.kern_block_direct_allocation.lds = internal addrspace(3) global %llvm.amdgcn.kernel.kern_block_direct_allocation.lds.t poison, align 4, !absolute_symbol [[META1]]

;.
define void @func_one() {
; CHECK-LABEL: define {{[^@]+}}@func_one() {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.lds.kernel.id()
; CHECK-NEXT:    [[VAL0:%.*]] = load i32, ptr addrspace(3) @llvm.amdgcn.module.lds, align 4, !noalias [[META2:![0-9]+]]
; CHECK-NEXT:    [[ONE:%.*]] = getelementptr inbounds [3 x [2 x i32]], ptr addrspace(4) @llvm.amdgcn.lds.offset.table, i32 0, i32 [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(4) [[ONE]], align 4
; CHECK-NEXT:    [[ONE1:%.*]] = inttoptr i32 [[TMP2]] to ptr addrspace(3)
; CHECK-NEXT:    store i32 [[VAL0]], ptr addrspace(3) [[ONE1]], align 4
; CHECK-NEXT:    store i16 10, ptr addrspace(3) getelementptr inbounds ([[LLVM_AMDGCN_MODULE_LDS_T:%.*]], ptr addrspace(3) @llvm.amdgcn.module.lds, i32 0, i32 1), align 4, !noalias [[META11:![0-9]+]]
; CHECK-NEXT:    ret void
;
  %val0 = load i32, ptr addrspace(3) @both
  store i32 %val0, ptr addrspace(3) @one
  store i16 10, ptr addrspace(3) @both_second
  ret void
}

define amdgpu_kernel void @kern_one() {
; CHECK-LABEL: define {{[^@]+}}@kern_one
; CHECK-SAME: () #[[ATTR0:[0-9]+]] !llvm.amdgcn.lds.kernel.id [[META16:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @llvm.donothing() [ "ExplicitUse"(ptr addrspace(3) @llvm.amdgcn.kernel.kern_one.lds) ]
; CHECK-NEXT:    call void @llvm.donothing() [ "ExplicitUse"(ptr addrspace(3) @llvm.amdgcn.module.lds) ], !noalias [[META17:![0-9]+]]
; CHECK-NEXT:    call void @func_one()
; CHECK-NEXT:    ret void
;
entry:
  call void @func_one()
  ret void
}

define void @func_two() {
; CHECK-LABEL: define {{[^@]+}}@func_two() {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.lds.kernel.id()
; CHECK-NEXT:    [[VAL0:%.*]] = load i32, ptr addrspace(3) @llvm.amdgcn.module.lds, align 4, !noalias [[META2]]
; CHECK-NEXT:    [[TWO:%.*]] = getelementptr inbounds [3 x [2 x i32]], ptr addrspace(4) @llvm.amdgcn.lds.offset.table, i32 0, i32 [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(4) [[TWO]], align 4
; CHECK-NEXT:    [[TWO1:%.*]] = inttoptr i32 [[TMP2]] to ptr addrspace(3)
; CHECK-NEXT:    store i32 [[VAL0]], ptr addrspace(3) [[TWO1]], align 4
; CHECK-NEXT:    store i16 20, ptr addrspace(3) getelementptr inbounds ([[LLVM_AMDGCN_MODULE_LDS_T:%.*]], ptr addrspace(3) @llvm.amdgcn.module.lds, i32 0, i32 1), align 4, !noalias [[META11]]
; CHECK-NEXT:    ret void
;
  %val0 = load i32, ptr addrspace(3) @both
  store i32 %val0, ptr addrspace(3) @two
  store i16 20, ptr addrspace(3) @both_second
  ret void
}

define amdgpu_kernel void @kern_two() {
; CHECK-LABEL: define {{[^@]+}}@kern_two
; CHECK-SAME: () #[[ATTR0]] !llvm.amdgcn.lds.kernel.id [[META18:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call void @llvm.donothing() [ "ExplicitUse"(ptr addrspace(3) @llvm.amdgcn.kernel.kern_two.lds) ]
; CHECK-NEXT:    call void @llvm.donothing() [ "ExplicitUse"(ptr addrspace(3) @llvm.amdgcn.module.lds) ], !alias.scope [[META19:![0-9]+]], !noalias [[META20:![0-9]+]]
; CHECK-NEXT:    call void @func_two()
; CHECK-NEXT:    ret void
;
entry:
  call void @func_two()
  ret void
}

; Unrelated to the bug at hand, but if a variable is only
; reachable from a single kernel, it gets allocated to a fixed
; address independent of the module scope struct. This kernel
; means the key variables miss that optimisation while @both
; remains the best candidate for address zero allocation.
define void @func_block_direct_allocation() {
; CHECK-LABEL: define {{[^@]+}}@func_block_direct_allocation() {
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.lds.kernel.id()
; CHECK-NEXT:    [[ONE:%.*]] = getelementptr inbounds [3 x [2 x i32]], ptr addrspace(4) @llvm.amdgcn.lds.offset.table, i32 0, i32 [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(4) [[ONE]], align 4
; CHECK-NEXT:    [[ONE1:%.*]] = inttoptr i32 [[TMP2]] to ptr addrspace(3)
; CHECK-NEXT:    [[VAL1:%.*]] = load i32, ptr addrspace(3) [[ONE1]], align 4
; CHECK-NEXT:    [[TWO:%.*]] = getelementptr inbounds [3 x [2 x i32]], ptr addrspace(4) @llvm.amdgcn.lds.offset.table, i32 0, i32 [[TMP1]], i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(4) [[TWO]], align 4
; CHECK-NEXT:    [[TWO2:%.*]] = inttoptr i32 [[TMP3]] to ptr addrspace(3)
; CHECK-NEXT:    [[VAL2:%.*]] = load i32, ptr addrspace(3) [[TWO2]], align 4
; CHECK-NEXT:    [[SUM:%.*]] = add i32 [[VAL1]], [[VAL2]]
; CHECK-NEXT:    store i32 [[SUM]], ptr addrspace(3) @llvm.amdgcn.module.lds, align 4, !noalias [[META2]]
; CHECK-NEXT:    store i16 30, ptr addrspace(3) getelementptr inbounds ([[LLVM_AMDGCN_MODULE_LDS_T:%.*]], ptr addrspace(3) @llvm.amdgcn.module.lds, i32 0, i32 1), align 4, !noalias [[META11]]
; CHECK-NEXT:    ret void
;
  %val1 = load i32, ptr addrspace(3) @one
  %val2 = load i32, ptr addrspace(3) @two
  %sum = add i32 %val1, %val2
  store i32 %sum, ptr addrspace(3) @both
  store i16 30, ptr addrspace(3) @both_second
  ret void
}

define amdgpu_kernel void @kern_block_direct_allocation() {
; CHECK-LABEL: define {{[^@]+}}@kern_block_direct_allocation
; CHECK-SAME: () #[[ATTR1:[0-9]+]] !llvm.amdgcn.lds.kernel.id [[META21:![0-9]+]] {
; CHECK-NEXT:    call void @llvm.donothing() [ "ExplicitUse"(ptr addrspace(3) @llvm.amdgcn.kernel.kern_block_direct_allocation.lds) ], !alias.scope [[META22:![0-9]+]], !noalias [[META25:![0-9]+]]
; CHECK-NEXT:    call void @llvm.donothing() [ "ExplicitUse"(ptr addrspace(3) @llvm.amdgcn.module.lds) ]
; CHECK-NEXT:    call void @func_block_direct_allocation()
; CHECK-NEXT:    call void @func_one()
; CHECK-NEXT:    call void @func_two()
; CHECK-NEXT:    ret void
;
  call void @func_block_direct_allocation()
  call void @func_one()
  call void @func_two()
  ret void
}
;.
; CHECK: attributes #[[ATTR0]] = { "amdgpu-lds-size"="12" }
; CHECK: attributes #[[ATTR1]] = { "amdgpu-lds-size"="16" }
; CHECK: attributes #[[ATTR2:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(none) }
; CHECK: attributes #[[ATTR3:[0-9]+]] = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
;.
