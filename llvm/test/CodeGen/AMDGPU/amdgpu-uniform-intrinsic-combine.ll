; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -amdgpu-enable-uniform-intrinsic-combine=0 -O3 -S < %s | FileCheck %s -check-prefix=CURRENT-CHECK
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -passes=amdgpu-uniform-intrinsic-combine -S < %s | FileCheck %s -check-prefix=PASS-CHECK
; RUN: opt -mtriple=amdgcn-amd-amdhsa -mcpu=gfx1010 -passes=amdgpu-uniform-intrinsic-combine,dce -S < %s | FileCheck %s -check-prefix=DCE-CHECK

define amdgpu_kernel void @permlane64_constant(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @permlane64_constant(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0:[0-9]+]] {
; GFX-NEXT:    store i32 77, ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.permlane64(i32 77)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @permlane64_undef(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @permlane64_undef(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.permlane64(i32 undef)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @permlane64_uniform(ptr addrspace(1) %out, i32 %src) {
; GFX-LABEL: define amdgpu_kernel void @permlane64_uniform(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[SRC:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 [[SRC]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.permlane64(i32 %src)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @permlane64_nonuniform(i32 addrspace(1)* %out) {
; GFX-LABEL: define amdgpu_kernel void @permlane64_nonuniform(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TID:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.permlane64.i32(i32 [[TID]])
; GFX-NEXT:    [[TMP1:%.*]] = sext i32 [[TID]] to i64
; GFX-NEXT:    [[OUT_PTR:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 [[TMP1]]
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT_PTR]], align 4
; GFX-NEXT:    ret void
;
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %v = call i32 @llvm.amdgcn.permlane64(i32 %tid)
  %out_ptr = getelementptr i32, i32 addrspace(1)* %out, i32 %tid
  store i32 %v, i32 addrspace(1)* %out_ptr
  ret void
}

define amdgpu_kernel void @permlane64_nonuniform_expression(i32 addrspace(1)* %out) {
; GFX-LABEL: define amdgpu_kernel void @permlane64_nonuniform_expression(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TID:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[TID2:%.*]] = add i32 [[TID]], 1
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.permlane64.i32(i32 [[TID2]])
; GFX-NEXT:    [[TMP1:%.*]] = sext i32 [[TID]] to i64
; GFX-NEXT:    [[OUT_PTR:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 [[TMP1]]
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT_PTR]], align 4
; GFX-NEXT:    ret void
;
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %tid2 = add i32 %tid, 1
  %v = call i32 @llvm.amdgcn.permlane64(i32 %tid2)
  %out_ptr = getelementptr i32, i32 addrspace(1)* %out, i32 %tid
  store i32 %v, i32 addrspace(1)* %out_ptr
  ret void
}

define amdgpu_kernel void @readlane_constant(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_constant(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 7, ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.readlane(i32 7, i32 5)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readlane_undef(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_undef(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.readlane(i32 undef, i32 undef)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readlane_nonuniform_indices(ptr addrspace(1) %out, i32 %src0, i32 %src1) {
; GFX-LABEL: define amdgpu_kernel void @readlane_nonuniform_indices(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[SRC0:%.*]], i32 [[SRC1:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 [[SRC0]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.readlane(i32 %src0, i32 %src1)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readlane_nonuniform_workitem(i32 addrspace(1)* %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_nonuniform_workitem(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TIDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[TIDY:%.*]] = call i32 @llvm.amdgcn.workitem.id.y()
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readlane.i32(i32 [[TIDX]], i32 [[TIDY]])
; GFX-NEXT:    [[TMP1:%.*]] = sext i32 [[TIDX]] to i64
; GFX-NEXT:    [[OUT_PTR:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 [[TMP1]]
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT_PTR]], align 4
; GFX-NEXT:    ret void
;
  %tidx = call i32 @llvm.amdgcn.workitem.id.x()
  %tidy = call i32 @llvm.amdgcn.workitem.id.y()
  %v = call i32 @llvm.amdgcn.readlane(i32 %tidx, i32 %tidy)
  %out_ptr = getelementptr i32, i32 addrspace(1)* %out, i32 %tidx
  store i32 %v, i32 addrspace(1)* %out_ptr
  ret void
}

define amdgpu_kernel void @readlane_nonuniform_expression(i32 addrspace(1)* %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_nonuniform_expression(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TIDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[TIDY:%.*]] = call i32 @llvm.amdgcn.workitem.id.y()
; GFX-NEXT:    [[TIDX2:%.*]] = add i32 [[TIDX]], 1
; GFX-NEXT:    [[TIDY2:%.*]] = add i32 [[TIDY]], 2
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readlane.i32(i32 [[TIDX2]], i32 [[TIDY2]])
; GFX-NEXT:    [[TMP1:%.*]] = sext i32 [[TIDX]] to i64
; GFX-NEXT:    [[OUT_PTR:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 [[TMP1]]
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT_PTR]], align 4
; GFX-NEXT:    ret void
;
  %tidx = call i32 @llvm.amdgcn.workitem.id.x()
  %tidy = call i32 @llvm.amdgcn.workitem.id.y()
  %tidx2 = add i32 %tidx, 1
  %tidy2 = add i32 %tidy, 2
  %v = call i32 @llvm.amdgcn.readlane(i32 %tidx2, i32 %tidy2)
  %out_ptr = getelementptr i32, i32 addrspace(1)* %out, i32 %tidx
  store i32 %v, i32 addrspace(1)* %out_ptr
  ret void
}

define amdgpu_kernel void @readfirstlane_constant(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_constant(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 7, ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.readfirstlane(i32 7)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readfirstlane_undef(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_undef(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.readfirstlane(i32 undef)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readfirstlane_with_argument(ptr addrspace(1) %out, i32 %src0) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_with_argument(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[SRC0:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 [[SRC0]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %v = call i32 @llvm.amdgcn.readfirstlane(i32 %src0)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readfirstlane_with_workitem_id(i32 addrspace(1)* %out) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_with_workitem_id(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TID:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TID]])
; GFX-NEXT:    [[TMP1:%.*]] = sext i32 [[TID]] to i64
; GFX-NEXT:    [[OUT_PTR:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 [[TMP1]]
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT_PTR]], align 4
; GFX-NEXT:    ret void
;
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %v = call i32 @llvm.amdgcn.readfirstlane(i32 %tid)
  %out_ptr = getelementptr i32, i32 addrspace(1)* %out, i32 %tid
  store i32 %v, i32 addrspace(1)* %out_ptr
  ret void
}

define amdgpu_kernel void @readfirstlane_expression(i32 addrspace(1)* %out) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_expression(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TID:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[TID2:%.*]] = add i32 [[TID]], 1
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TID2]])
; GFX-NEXT:    [[TMP1:%.*]] = sext i32 [[TID2]] to i64
; GFX-NEXT:    [[OUT_PTR:%.*]] = getelementptr i32, ptr addrspace(1) [[OUT]], i64 [[TMP1]]
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT_PTR]], align 4
; GFX-NEXT:    ret void
;
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %tid2 = add i32 %tid, 1
  %v = call i32 @llvm.amdgcn.readfirstlane(i32 %tid2)
  %out_ptr = getelementptr i32, i32 addrspace(1)* %out, i32 %tid2
  store i32 %v, i32 addrspace(1)* %out_ptr
  ret void
}

define amdgpu_kernel void @readfirstlane_with_readfirstlane(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_with_readfirstlane(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 5, ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %v1 = call i32 @llvm.amdgcn.readfirstlane(i32 5)
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  store i32 %v2, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readfirstlane_with_readlane(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_with_readlane(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TIDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[TIDY:%.*]] = call i32 @llvm.amdgcn.workitem.id.y()
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readlane.i32(i32 [[TIDX]], i32 [[TIDY]])
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %tidx = call i32 @llvm.amdgcn.workitem.id.x()
  %tidy = call i32 @llvm.amdgcn.workitem.id.y()
  %v1 = call i32 @llvm.amdgcn.readlane(i32 %tidx, i32 %tidy)
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  store i32 %v2, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readlane_with_firstlane(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_with_firstlane(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TIDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[TIDX]])
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %tidx = call i32 @llvm.amdgcn.workitem.id.x()
  %v1 = call i32 @llvm.amdgcn.readfirstlane(i32 %tidx)
  %v2 = call i32 @llvm.amdgcn.readlane(i32 %v1, i32 3)
  store i32 %v2, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readlane_readlane(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_readlane(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TIDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[TIDY:%.*]] = call i32 @llvm.amdgcn.workitem.id.y()
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readlane.i32(i32 [[TIDX]], i32 [[TIDY]])
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %tidx = call i32 @llvm.amdgcn.workitem.id.x()
  %tidy = call i32 @llvm.amdgcn.workitem.id.y()
  %v1 = call i32 @llvm.amdgcn.readlane(i32 %tidx, i32 %tidy)
  %v2 = call i32 @llvm.amdgcn.readlane(i32 %v1, i32 2)
  store i32 %v2, ptr addrspace(1) %out
  ret void
}


define amdgpu_kernel void @permlane64_boundary(ptr addrspace(1) %out_min, ptr addrspace(1) %out_max) {
; GFX-LABEL: define amdgpu_kernel void @permlane64_boundary(
; GFX-SAME: ptr addrspace(1) [[OUT_MIN:%.*]], ptr addrspace(1) [[OUT_MAX:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 -2147483648, ptr addrspace(1) [[OUT_MIN]], align 4
; GFX-NEXT:    store i32 2147483647, ptr addrspace(1) [[OUT_MAX]], align 4
; GFX-NEXT:    ret void
;
  %min_v = call i32 @llvm.amdgcn.permlane64(i32 -2147483648)
  store i32 %min_v, ptr addrspace(1) %out_min
  %max_v = call i32 @llvm.amdgcn.permlane64(i32 2147483647)
  store i32 %max_v, ptr addrspace(1) %out_max
  ret void
}

define amdgpu_kernel void @readlane_cross_lane(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_cross_lane(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[TIDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[TIDY:%.*]] = add i32 [[TIDX]], 5
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readlane.i32(i32 [[TIDX]], i32 [[TIDY]])
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %tidx = call i32 @llvm.amdgcn.workitem.id.x()
  %tidy = add i32 %tidx, 5
  %v = call i32 @llvm.amdgcn.readlane(i32 %tidx, i32 %tidy)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readfirstlane_random(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readfirstlane_random(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    store i32 435, ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %random = xor i32 123, 456
  %v = call i32 @llvm.amdgcn.readfirstlane(i32 %random)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @permlane64_invalid(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @permlane64_invalid(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    ret void
;
  %undef_v = call i32 @llvm.amdgcn.permlane64(i32 undef)
  store i32 %undef_v, ptr addrspace(1) %out
  ret void
}

define amdgpu_kernel void @readlane_expression(ptr addrspace(1) %out) {
; GFX-LABEL: define amdgpu_kernel void @readlane_expression(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]]) #[[ATTR0]] {
; GFX-NEXT:    [[IDX1:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX-NEXT:    [[IDX2:%.*]] = shl i32 [[IDX1]], 1
; GFX-NEXT:    [[V:%.*]] = call i32 @llvm.amdgcn.readlane.i32(i32 [[IDX1]], i32 [[IDX2]])
; GFX-NEXT:    store i32 [[V]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
  %idx1 = call i32 @llvm.amdgcn.workitem.id.x()
  %idx2 = mul i32 %idx1, 2
  %v = call i32 @llvm.amdgcn.readlane(i32 %idx1, i32 %idx2)
  store i32 %v, ptr addrspace(1) %out
  ret void
}

; Test case: Ensure that a loop with a divergent exit and a uniform value
; used by an intrinsic outside the loop is not optimized due to temporal divergence.

define amdgpu_kernel void @test_divergent_exit(ptr addrspace(1) %out, i32 %max_iter, i32 %div_cond) {
; GFX-LABEL: define amdgpu_kernel void @test_divergent_exit(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[MAX_ITER:%.*]], i32 [[DIV_COND:%.*]]) #[[ATTR0]] {
; GFX-NEXT:  [[ENTRY:.*:]]
; GFX-NEXT:    [[ITER:%.*]] = alloca i32, align 4
; GFX-NEXT:    store i32 0, ptr [[ITER]], align 4
; GFX-NEXT:    br label %[[LOOP:.*]]
; GFX:       [[LOOP]]:
; GFX-NEXT:    [[ITER_VAL:%.*]] = load i32, ptr [[ITER]], align 4
; GFX-NEXT:    [[NEW_ITER:%.*]] = add i32 [[ITER_VAL]], 1
; GFX-NEXT:    store i32 [[NEW_ITER]], ptr [[ITER]], align 4
; GFX-NEXT:    [[COND1:%.*]] = icmp sgt i32 [[NEW_ITER]], [[MAX_ITER]]
; GFX-NEXT:    [[COND2:%.*]] = icmp eq i32 [[DIV_COND]], 0
; GFX-NEXT:    [[EXIT:%.*]] = or i1 [[COND1]], [[COND2]]
; GFX-NEXT:    br i1 [[EXIT]], label %[[EXIT_BLOCK:.*]], label %[[LOOP]]
; GFX:       [[EXIT_BLOCK]]:
; GFX-NEXT:    [[FINAL_VAL:%.*]] = load i32, ptr [[ITER]], align 4
; GFX-NEXT:    [[RESULT:%.*]] = call i32 @llvm.amdgcn.permlane64.i32(i32 [[FINAL_VAL]])
; GFX-NEXT:    store i32 [[RESULT]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
entry:
  %iter = alloca i32, align 4
  store i32 0, ptr %iter, align 4
  br label %loop

loop:
  ; Increment loop counter
  %iter_val = load i32, ptr %iter, align 4
  %new_iter = add i32 %iter_val, 1
  store i32 %new_iter, ptr %iter, align 4

  ; Check exit conditions
  %cond1 = icmp sgt i32 %new_iter, %max_iter
  %cond2 = icmp eq i32 %div_cond, 0
  %exit = or i1 %cond1, %cond2
  br i1 %exit, label %exit_block, label %loop

exit_block:
  ; Use the uniform value in an intrinsic outside the loop
  %final_val = load i32, ptr %iter, align 4
  %result = call i32 @llvm.amdgcn.permlane64(i32 %final_val)
  store i32 %result, ptr addrspace(1) %out, align 4
  ret void
}

; Define the kernel function
define amdgpu_kernel void @trivial_waterfall_loop(ptr addrspace(1) %out, i32 %src) {
; CHECK-LABEL: define amdgpu_kernel void @trivial_waterfall_loop(
; CHECK:       store i32 %src, ptr addrspace(1) %out, align 4
; CHECK-NOT:   br label %loop
; GFX-LABEL: define amdgpu_kernel void @trivial_waterfall_loop(
; GFX-SAME: ptr addrspace(1) [[OUT:%.*]], i32 [[SRC:%.*]]) #[[ATTR0]] {
; GFX-NEXT:  [[ENTRY:.*:]]
; GFX-NEXT:    [[RESULT:%.*]] = alloca i32, align 4
; GFX-NEXT:    store i32 0, ptr [[RESULT]], align 4
; GFX-NEXT:    br label %[[LOOP:.*]]
; GFX:       [[LOOP]]:
; GFX-NEXT:    [[CUR_RESULT:%.*]] = load i32, ptr [[RESULT]], align 4
; GFX-NEXT:    [[NEXT_VALUE:%.*]] = add i32 [[CUR_RESULT]], [[SRC]]
; GFX-NEXT:    [[UNIFORM_VALUE:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[NEXT_VALUE]])
; GFX-NEXT:    store i32 [[UNIFORM_VALUE]], ptr [[RESULT]], align 4
; GFX-NEXT:    br i1 true, label %[[EXIT:.*]], label %[[LOOP]]
; GFX:       [[EXIT]]:
; GFX-NEXT:    [[FINAL_RESULT:%.*]] = load i32, ptr [[RESULT]], align 4
; GFX-NEXT:    store i32 [[FINAL_RESULT]], ptr addrspace(1) [[OUT]], align 4
; GFX-NEXT:    ret void
;
entry:
  ; Initialize result to zero
  %result = alloca i32, align 4
  store i32 0, ptr %result, align 4
  br label %loop

loop:
  ; Load the current result
  %cur_result = load i32, ptr %result, align 4

  ; Compute the next value
  %next_value = add i32 %cur_result, %src

  ; Apply the readfirstlane intrinsic for uniformity
  %uniform_value = call i32 @llvm.amdgcn.readfirstlane(i32 %next_value)

  ; Store the uniform result back
  store i32 %uniform_value, ptr %result, align 4

  ; This is a trivial loop that always exits after one iteration
  br i1 true, label %exit, label %loop

exit:
  ; Store the result to the output pointer
  %final_result = load i32, ptr %result, align 4
  store i32 %final_result, ptr addrspace(1) %out, align 4
  ret void
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; GFX10: {{.*}}
; GFX11: {{.*}}
; GFX12: {{.*}}
