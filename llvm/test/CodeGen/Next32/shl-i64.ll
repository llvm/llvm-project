; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 -mattr=-lea < %s | FileCheck %s --check-prefix=CHECK
; RUN: llc -mtriple=next32 -mattr=+lea < %s | FileCheck %s --check-prefix=HAS-LEA

; Original C source:
; union union_u64_t {
;   struct {
;     uint32_t lo;
;     uint32_t hi;
;   };
;   uint64_t value;
; };
;
; uint64_t test1(uint32_t a, uint32_t b) {
;   union union_u64_t union_data = { .hi = a, .lo = b };
;   return union_data.value;
; }
;
; uint64_t test2(uint32_t a, uint32_t b) {
;   union union_u64_t union_data = { .hi = a, .lo = b };
;   return union_data.value + 4;
; }
;
; uint64_t test3(uint32_t a, uint32_t b) {
;   union union_u64_t union_data = { .hi = a, .lo = b };
;   return union_data.value << 3;
; }
;
; uint64_t test4(uint32_t a, uint32_t b) {
;   union union_u64_t union_data = { .hi = a, .lo = b };
;   return union_data.value << 6;
; }
;
; uint64_t test5(uint32_t a, uint32_t b) {
;   union union_u64_t union_data = { .hi = a, .lo = b };
;   return (union_data.value << 2) + 5;
; }
;
; uint64_t test6(uint32_t a, uint32_t b) {
;   union union_u64_t union_data = { .hi = a, .lo = b };
;   return (union_data.value + 5) << 2;
; }

define i64 @test1(i32 %a, i32 %b) {
; CHECK-LABEL: test1:
; CHECK:       LBB0_0:
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r2
; CHECK-NEXT:    writer.64 ret_fid, r1
;
; HAS-LEA-LABEL: test1:
; HAS-LEA:       LBB0_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.32 r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
entry:
  %union_data.sroa.4.0.insert.ext = zext i32 %a to i64
  %union_data.sroa.4.0.insert.shift = shl nuw i64 %union_data.sroa.4.0.insert.ext, 32
  %union_data.sroa.0.0.insert.ext = zext i32 %b to i64
  %union_data.sroa.0.0.insert.insert = or i64 %union_data.sroa.4.0.insert.shift, %union_data.sroa.0.0.insert.ext
  ret i64 %union_data.sroa.0.0.insert.insert
}

define i64 @test2(i32 %a, i32 %b) {
; CHECK-LABEL: test2:
; CHECK:       LBB1_0:
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl r3, 0x4
; CHECK-NEXT:    add r2, r3
; CHECK-NEXT:    dup r3, r2
; CHECK-NEXT:    flags r3
; CHECK-NEXT:    movl r4, 0x0
; CHECK-NEXT:    adc r1, r4 [r3]
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r2
; CHECK-NEXT:    writer.64 ret_fid, r1
;
; HAS-LEA-LABEL: test2:
; HAS-LEA:       LBB1_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.32 r2
; HAS-LEA-NEXT:    movl r3, 0x4
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    leadisp r4, r3
; HAS-LEA-NEXT:    leascale r4, r4
; HAS-LEA-NEXT:    leaindex r4, r4
; HAS-LEA-NEXT:    leabase r1, r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
entry:
  %union_data.sroa.4.0.insert.ext = zext i32 %a to i64
  %union_data.sroa.4.0.insert.shift = shl nuw i64 %union_data.sroa.4.0.insert.ext, 32
  %union_data.sroa.0.0.insert.ext = zext i32 %b to i64
  %union_data.sroa.0.0.insert.insert = add nuw nsw i64 %union_data.sroa.0.0.insert.ext, 4
  %add = add i64 %union_data.sroa.0.0.insert.insert, %union_data.sroa.4.0.insert.shift
  ret i64 %add
}

define i64 @test3(i32 %a, i32 %b) {
; CHECK-LABEL: test3:
; CHECK:       LBB2_0:
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl r3, 0x3
; CHECK-NEXT:    movl call_addr, __ashldi3
; CHECK-NEXT:    movl call_ret_fid, .Ltmp0
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r2
; CHECK-NEXT:    writer.64 call_addr, r1
; CHECK-NEXT:    writer.32 call_addr, r3
; CHECK-NEXT:    movl call_ret_bb, LBB2_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB2_1: # %entry
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r1
; CHECK-NEXT:    writer.64 ret_fid, r2
;
; HAS-LEA-LABEL: test3:
; HAS-LEA:       LBB2_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.32 r2
; HAS-LEA-NEXT:    movl r3, 0x8
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r3
; HAS-LEA-NEXT:    leaindex r1, r2
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
entry:
  %union_data.sroa.4.0.insert.ext = zext i32 %a to i64
  %union_data.sroa.0.0.insert.ext = zext i32 %b to i64
  %0 = shl i64 %union_data.sroa.4.0.insert.ext, 35
  %1 = shl nuw nsw i64 %union_data.sroa.0.0.insert.ext, 3
  %shl = or i64 %1, %0
  ret i64 %shl
}

define i64 @test4(i32 %a, i32 %b) {
; CHECK-LABEL: test4:
; CHECK:       LBB3_0:
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl r3, 0x6
; CHECK-NEXT:    movl call_addr, __ashldi3
; CHECK-NEXT:    movl call_ret_fid, .Ltmp1
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r2
; CHECK-NEXT:    writer.64 call_addr, r1
; CHECK-NEXT:    writer.32 call_addr, r3
; CHECK-NEXT:    movl call_ret_bb, LBB3_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB3_1: # %entry
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r1
; CHECK-NEXT:    writer.64 ret_fid, r2
;
; HAS-LEA-LABEL: test4:
; HAS-LEA:       LBB3_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.32 r2
; HAS-LEA-NEXT:    movl r3, 0x40
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r3
; HAS-LEA-NEXT:    leaindex r1, r2
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
entry:
  %union_data.sroa.4.0.insert.ext = zext i32 %a to i64
  %union_data.sroa.0.0.insert.ext = zext i32 %b to i64
  %0 = shl i64 %union_data.sroa.4.0.insert.ext, 38
  %1 = shl nuw nsw i64 %union_data.sroa.0.0.insert.ext, 6
  %shl = or i64 %1, %0
  ret i64 %shl
}

define i64 @test5(i32 %a, i32 %b) {
; CHECK-LABEL: test5:
; CHECK:       LBB4_0:
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl r3, 0x2
; CHECK-NEXT:    movl call_addr, __ashldi3
; CHECK-NEXT:    movl call_ret_fid, .Ltmp2
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r2
; CHECK-NEXT:    writer.64 call_addr, r1
; CHECK-NEXT:    writer.32 call_addr, r3
; CHECK-NEXT:    movl call_ret_bb, LBB4_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB4_1: # %entry
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    movl r3, 0x5
; CHECK-NEXT:    add r1, r3
; CHECK-NEXT:    dup r3, r1
; CHECK-NEXT:    flags r3
; CHECK-NEXT:    movl r4, 0x0
; CHECK-NEXT:    adc r2, r4 [r3]
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r1
; CHECK-NEXT:    writer.64 ret_fid, r2
;
; HAS-LEA-LABEL: test5:
; HAS-LEA:       LBB4_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.32 r2
; HAS-LEA-NEXT:    movl r3, 0x5
; HAS-LEA-NEXT:    movl r4, 0x4
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    leadisp r6, r3
; HAS-LEA-NEXT:    leascale r6, r4
; HAS-LEA-NEXT:    leaindex r1, r2
; HAS-LEA-NEXT:    leabase r5, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
entry:
  %union_data.sroa.4.0.insert.ext = zext i32 %a to i64
  %union_data.sroa.0.0.insert.ext = zext i32 %b to i64
  %0 = shl i64 %union_data.sroa.4.0.insert.ext, 34
  %1 = shl nuw nsw i64 %union_data.sroa.0.0.insert.ext, 2
  %shl = or i64 %0, 5
  %add = add i64 %shl, %1
  ret i64 %add
}

define i64 @test6(i32 %a, i32 %b) {
; CHECK-LABEL: test6:
; CHECK:       LBB5_0:
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl r3, 0x2
; CHECK-NEXT:    movl call_addr, __ashldi3
; CHECK-NEXT:    movl call_ret_fid, .Ltmp3
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r2
; CHECK-NEXT:    writer.64 call_addr, r1
; CHECK-NEXT:    writer.32 call_addr, r3
; CHECK-NEXT:    movl call_ret_bb, LBB5_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB5_1: # %entry
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp3:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    movl r3, 0x14
; CHECK-NEXT:    add r1, r3
; CHECK-NEXT:    dup r3, r1
; CHECK-NEXT:    flags r3
; CHECK-NEXT:    movl r4, 0x0
; CHECK-NEXT:    adc r2, r4 [r3]
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r1
; CHECK-NEXT:    writer.64 ret_fid, r2
;
; HAS-LEA-LABEL: test6:
; HAS-LEA:       LBB5_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.32 r2
; HAS-LEA-NEXT:    movl r3, 0x14
; HAS-LEA-NEXT:    movl r4, 0x4
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    leadisp r6, r3
; HAS-LEA-NEXT:    leascale r6, r4
; HAS-LEA-NEXT:    leaindex r1, r2
; HAS-LEA-NEXT:    leabase r5, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
entry:
  %union_data.sroa.4.0.insert.ext = zext i32 %a to i64
  %union_data.sroa.0.0.insert.ext = zext i32 %b to i64
  %0 = shl i64 %union_data.sroa.4.0.insert.ext, 34
  %1 = shl nuw nsw i64 %union_data.sroa.0.0.insert.ext, 2
  %add = or i64 %0, 20
  %shl = add i64 %add, %1
  ret i64 %shl
}
