; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 -mattr=+lea < %s | FileCheck %s --check-prefix=HAS-LEA
; RUN: llc -mtriple=next32 -mattr=-lea < %s | FileCheck %s --check-prefix=NO-LEA

; Original C source:
; uint64_t test1lea(uint64_t a, int64_t b) {
;     return (a >> 32) * (b >> 32);
; }
;
; uint64_t test2nolea(uint64_t a, uint32_t b) {
;     return (a >> 32) * (uint64_t)b;
; }
;
; uint64_t test3nolea(uint64_t a, uint32_t b) {
;     return (a & 0xffffffff) * (uint64_t)b;
; }
;
; uint64_t test4lea(uint64_t a, uint64_t b) {
;     return (a & 0xffffffff) * b;
; }

define i64 @test1lea(i64 %0, i64 %1) {
; HAS-LEA-LABEL: test1lea:
; HAS-LEA:       LBB0_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r1, 0x1F
; HAS-LEA-NEXT:    dup r3, r4
; HAS-LEA-NEXT:    shri r3, r1
; HAS-LEA-NEXT:    movl r1, 0x0
; HAS-LEA-NEXT:    dup r5, r1
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r2
; HAS-LEA-NEXT:    leaindex r3, r4
; HAS-LEA-NEXT:    leabase r1, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
;
; NO-LEA-LABEL: test1lea:
; NO-LEA:       LBB0_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r1, 0x1F
; NO-LEA-NEXT:    dup r3, r4
; NO-LEA-NEXT:    shri r3, r1
; NO-LEA-NEXT:    mul r3, r2
; NO-LEA-NEXT:    umul r4, r2
; NO-LEA-NEXT:    add r2, r3
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r4
; NO-LEA-NEXT:    writer.64 ret_fid, r2
  %3 = lshr i64 %0, 32
  %4 = ashr i64 %1, 32
  %5 = mul nsw i64 %4, %3
  ret i64 %5
}

define i64 @test2nolea(i64 %0, i32 %1) {
; HAS-LEA-LABEL: test2nolea:
; HAS-LEA:       LBB1_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    umul r2, r3
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
;
; NO-LEA-LABEL: test2nolea:
; NO-LEA:       LBB1_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    umul r2, r3
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r2
; NO-LEA-NEXT:    writer.64 ret_fid, r3
  %3 = lshr i64 %0, 32
  %4 = zext i32 %1 to i64
  %5 = mul nuw i64 %3, %4
  ret i64 %5
}

define i64 @test3nolea(i64 %0, i32 %1) {
; HAS-LEA-LABEL: test3nolea:
; HAS-LEA:       LBB2_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    umul r1, r3
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
;
; NO-LEA-LABEL: test3nolea:
; NO-LEA:       LBB2_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    umul r1, r3
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r3
  %3 = and i64 %0, 4294967295
  %4 = zext i32 %1 to i64
  %5 = mul nuw i64 %3, %4
  ret i64 %5
}

define i64 @test4lea(i64 %0, i64 %1) {
; HAS-LEA-LABEL: test4lea:
; HAS-LEA:       LBB3_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r2, 0x0
; HAS-LEA-NEXT:    dup r5, r2
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r4, r3
; HAS-LEA-NEXT:    leaindex r5, r1
; HAS-LEA-NEXT:    leabase r2, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
;
; NO-LEA-LABEL: test4lea:
; NO-LEA:       LBB3_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    dup r2, r1
; NO-LEA-NEXT:    mul r2, r4
; NO-LEA-NEXT:    umul r1, r3
; NO-LEA-NEXT:    add r3, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r3
  %3 = and i64 %0, 4294967295
  %4 = mul i64 %3, %1
  ret i64 %4
}
