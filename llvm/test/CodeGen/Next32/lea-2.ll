; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 -mattr=+lea < %s | FileCheck %s --check-prefix=HAS-LEA
; RUN: llc -mtriple=next32 -mattr=-lea < %s | FileCheck %s --check-prefix=NO-LEA

; Original C source:
; static int get_member_size_t(int *arr, size_t i0, size_t i1, size_t stride) {
;   return arr[i1 + stride * i0];
; }
;
; int test1(int *arr, int size) {
;   int res = 0;
;   for (int i = 0; i < 100; ++i) {
;     res += get_member_size_t(arr, i, 0, 3);
;     res += get_member_size_t(arr, i, 1, 3);
;     res += get_member_size_t(arr, i, 2, 3);
;   }
;   return res;
; }
;
; static int get_member_int(int *arr, int i0, int i1, int stride) {
;   return arr[i1 + stride * i0];
; }
;
; int test2(int *arr, int size) {
;   int res = 0;
;   for (int i = 0; i < 100; ++i) {
;     res += get_member_int(arr, i, 0, 3);
;     res += get_member_int(arr, i, 1, 3);
;     res += get_member_int(arr, i, 2, 3);
;   }
;   return res;
; }
;
; int test3(int *a, int i) {
;   return a[i * 3 + 1];
; }
;
; void test4(int *a, int size) {
;   for (int i = 0; i < size; i += 4) {
;     a[i] = a[i+1];
;     a[i+2] = a[i+3];
;   }
; }

define i32 @test1(i32* nocapture readonly %arr, i32 %size) {
; HAS-LEA-LABEL: test1:
; HAS-LEA:       LBB0_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    movl r3, 0x0
; HAS-LEA-NEXT:    dup r4, r3
; HAS-LEA-NEXT:    dup r5, r3
; HAS-LEA-NEXT:    movl mbb_addr, LBB0_2
; HAS-LEA-NEXT:    chain mbb_addr, 0x64
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r1
; HAS-LEA-NEXT:    writer.32 mbb_addr, r2
; HAS-LEA-NEXT:    writer.32 mbb_addr, r3
; HAS-LEA-NEXT:    writer.32 mbb_addr, r4
; HAS-LEA-NEXT:    writer.32 mbb_addr, r5
; HAS-LEA-NEXT:  LBB0_1: # %for.cond.cleanup
; HAS-LEA-NEXT:    feeder.p.32 tid
; HAS-LEA-NEXT:    feeder.p.32 ret_fid
; HAS-LEA-NEXT:    feeder.p.32 r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r6
; HAS-LEA-NEXT:  LBB0_2: # %for.body
; HAS-LEA-NEXT:    # =>This Inner Loop Header: Depth=1
; HAS-LEA-NEXT:    feeder.p.32 tid
; HAS-LEA-NEXT:    feeder.p.32 ret_fid
; HAS-LEA-NEXT:    feeder.p.32 r1
; HAS-LEA-NEXT:    feeder.p.32 r2
; HAS-LEA-NEXT:    feeder.p.32 r3
; HAS-LEA-NEXT:    feeder.p.32 r4
; HAS-LEA-NEXT:    feeder.p.32 r5
; HAS-LEA-NEXT:    movl r6, 0xC
; HAS-LEA-NEXT:    dup r7, r4
; HAS-LEA-NEXT:    umul r7, r6
; HAS-LEA-NEXT:    movl r8, 0x4
; HAS-LEA-NEXT:    movl r9, 0x1
; HAS-LEA-NEXT:    dup r10, r1
; HAS-LEA-NEXT:    dup r11, r2
; HAS-LEA-NEXT:    leadisp r3, r8
; HAS-LEA-NEXT:    leascale r3, r9
; HAS-LEA-NEXT:    leaindex r6, r7
; HAS-LEA-NEXT:    leabase r11, r10
; HAS-LEA-NEXT:    movl r8, 0x8
; HAS-LEA-NEXT:    dup r12, r1
; HAS-LEA-NEXT:    dup r13, r2
; HAS-LEA-NEXT:    leadisp r3, r8
; HAS-LEA-NEXT:    leascale r3, r9
; HAS-LEA-NEXT:    leaindex r6, r7
; HAS-LEA-NEXT:    leabase r13, r12
; HAS-LEA-NEXT:    dup r8, r1
; HAS-LEA-NEXT:    dup r14, r2
; HAS-LEA-NEXT:    leadisp r3, r3
; HAS-LEA-NEXT:    leascale r3, r9
; HAS-LEA-NEXT:    leaindex r6, r7
; HAS-LEA-NEXT:    leabase r14, r8
; HAS-LEA-NEXT:    memread.32.align[4] r13, r12, tid
; HAS-LEA-NEXT:    memdata r7
; HAS-LEA-NEXT:    memread.32.align[4] r11, r10, tid
; HAS-LEA-NEXT:    memdata r9
; HAS-LEA-NEXT:    memread.32.align[4] r14, r8, tid
; HAS-LEA-NEXT:    memdata r8
; HAS-LEA-NEXT:    inc r4
; HAS-LEA-NEXT:    movl r6, 0x64
; HAS-LEA-NEXT:    dup r10, r4
; HAS-LEA-NEXT:    sub r10, r6
; HAS-LEA-NEXT:    dup r11, r10
; HAS-LEA-NEXT:    flags r11
; HAS-LEA-NEXT:    dup r6, r8
; HAS-LEA-NEXT:    add r6, r5
; HAS-LEA-NEXT:    add r6, r9
; HAS-LEA-NEXT:    add r6, r7
; HAS-LEA-NEXT:    dup r5, tid
; HAS-LEA-NEXT:    barrier r5, r7
; HAS-LEA-NEXT:    barrier r5, r9
; HAS-LEA-NEXT:    barrier r5, r8
; HAS-LEA-NEXT:    dup tid, r5
; HAS-LEA-NEXT:    dup r5, r6
; HAS-LEA-NEXT:    movl mbb_addr, LBB0_1
; HAS-LEA-NEXT:    chain.e mbb_addr, 0x3 [r11]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r6
; HAS-LEA-NEXT:    movl mbb_addr, LBB0_2
; HAS-LEA-NEXT:    chain.p.ne mbb_addr, 0x60 [r11]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r1
; HAS-LEA-NEXT:    writer.32 mbb_addr, r2
; HAS-LEA-NEXT:    writer.32 mbb_addr, r3
; HAS-LEA-NEXT:    writer.32 mbb_addr, r4
; HAS-LEA-NEXT:    writer.32 mbb_addr, r5
;
; NO-LEA-LABEL: test1:
; NO-LEA:       LBB0_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    movl r3, 0x0
; NO-LEA-NEXT:    dup r4, r3
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    movl mbb_addr, LBB0_2
; NO-LEA-NEXT:    chain mbb_addr, 0x64
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r1
; NO-LEA-NEXT:    writer.32 mbb_addr, r2
; NO-LEA-NEXT:    writer.32 mbb_addr, r3
; NO-LEA-NEXT:    writer.32 mbb_addr, r4
; NO-LEA-NEXT:    writer.32 mbb_addr, r5
; NO-LEA-NEXT:  LBB0_1: # %for.cond.cleanup
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r6
; NO-LEA-NEXT:  LBB0_2: # %for.body
; NO-LEA-NEXT:    # =>This Inner Loop Header: Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    movl r6, 0xC
; NO-LEA-NEXT:    dup r7, r4
; NO-LEA-NEXT:    umul r7, r6
; NO-LEA-NEXT:    dup r8, r1
; NO-LEA-NEXT:    add r8, r7
; NO-LEA-NEXT:    dup r7, r8
; NO-LEA-NEXT:    flags r7
; NO-LEA-NEXT:    dup r9, r2
; NO-LEA-NEXT:    adc r9, r6 [r7]
; NO-LEA-NEXT:    movl r6, 0x4
; NO-LEA-NEXT:    dup r7, r8
; NO-LEA-NEXT:    add r7, r6
; NO-LEA-NEXT:    dup r6, r7
; NO-LEA-NEXT:    flags r6
; NO-LEA-NEXT:    dup r10, r9
; NO-LEA-NEXT:    adc r10, r3 [r6]
; NO-LEA-NEXT:    movl r6, 0x8
; NO-LEA-NEXT:    dup r11, r8
; NO-LEA-NEXT:    add r11, r6
; NO-LEA-NEXT:    dup r6, r11
; NO-LEA-NEXT:    flags r6
; NO-LEA-NEXT:    dup r12, r9
; NO-LEA-NEXT:    adc r12, r3 [r6]
; NO-LEA-NEXT:    memread.32.align[4] r12, r11, tid
; NO-LEA-NEXT:    memdata r11
; NO-LEA-NEXT:    memread.32.align[4] r10, r7, tid
; NO-LEA-NEXT:    memdata r7
; NO-LEA-NEXT:    memread.32.align[4] r9, r8, tid
; NO-LEA-NEXT:    memdata r8
; NO-LEA-NEXT:    inc r4
; NO-LEA-NEXT:    movl r6, 0x64
; NO-LEA-NEXT:    dup r9, r4
; NO-LEA-NEXT:    sub r9, r6
; NO-LEA-NEXT:    dup r10, r9
; NO-LEA-NEXT:    flags r10
; NO-LEA-NEXT:    dup r6, r8
; NO-LEA-NEXT:    add r6, r5
; NO-LEA-NEXT:    add r6, r7
; NO-LEA-NEXT:    add r6, r11
; NO-LEA-NEXT:    dup r5, tid
; NO-LEA-NEXT:    barrier r5, r8
; NO-LEA-NEXT:    barrier r5, r7
; NO-LEA-NEXT:    barrier r5, r11
; NO-LEA-NEXT:    dup tid, r5
; NO-LEA-NEXT:    dup r5, r6
; NO-LEA-NEXT:    movl mbb_addr, LBB0_1
; NO-LEA-NEXT:    chain.e mbb_addr, 0x3 [r10]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r6
; NO-LEA-NEXT:    movl mbb_addr, LBB0_2
; NO-LEA-NEXT:    chain.p.ne mbb_addr, 0x60 [r10]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r1
; NO-LEA-NEXT:    writer.32 mbb_addr, r2
; NO-LEA-NEXT:    writer.32 mbb_addr, r3
; NO-LEA-NEXT:    writer.32 mbb_addr, r4
; NO-LEA-NEXT:    writer.32 mbb_addr, r5
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret i32 %add6

for.body:                                         ; preds = %entry, %for.body
  %i.024 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %res.023 = phi i32 [ 0, %entry ], [ %add6, %for.body ]
  %conv = zext i32 %i.024 to i64
  %mul.i = mul nuw nsw i64 %conv, 3
  %arrayidx.i = getelementptr inbounds i32, i32* %arr, i64 %mul.i
  %0 = load i32, i32* %arrayidx.i, align 4, !tbaa !2
  %add = add nsw i32 %0, %res.023
  %add.i = add nuw nsw i64 %mul.i, 1
  %arrayidx.i19 = getelementptr inbounds i32, i32* %arr, i64 %add.i
  %1 = load i32, i32* %arrayidx.i19, align 4, !tbaa !2
  %add3 = add nsw i32 %add, %1
  %add.i21 = add nuw nsw i64 %mul.i, 2
  %arrayidx.i22 = getelementptr inbounds i32, i32* %arr, i64 %add.i21
  %2 = load i32, i32* %arrayidx.i22, align 4, !tbaa !2
  %add6 = add nsw i32 %add3, %2
  %inc = add nuw nsw i32 %i.024, 1
  %exitcond.not = icmp eq i32 %inc, 100
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !llvm.loop !6
}

define i32 @test2(i32* nocapture readonly %arr, i32 %size) {
; HAS-LEA-LABEL: test2:
; HAS-LEA:       LBB1_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    movl r3, 0x0
; HAS-LEA-NEXT:    dup r4, r3
; HAS-LEA-NEXT:    dup r5, r3
; HAS-LEA-NEXT:    movl mbb_addr, LBB1_2
; HAS-LEA-NEXT:    chain mbb_addr, 0x64
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r1
; HAS-LEA-NEXT:    writer.32 mbb_addr, r2
; HAS-LEA-NEXT:    writer.32 mbb_addr, r3
; HAS-LEA-NEXT:    writer.32 mbb_addr, r4
; HAS-LEA-NEXT:    writer.32 mbb_addr, r5
; HAS-LEA-NEXT:  LBB1_1: # %for.cond.cleanup
; HAS-LEA-NEXT:    feeder.p.32 tid
; HAS-LEA-NEXT:    feeder.p.32 ret_fid
; HAS-LEA-NEXT:    feeder.p.32 r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r6
; HAS-LEA-NEXT:  LBB1_2: # %for.body
; HAS-LEA-NEXT:    # =>This Inner Loop Header: Depth=1
; HAS-LEA-NEXT:    feeder.p.32 tid
; HAS-LEA-NEXT:    feeder.p.32 ret_fid
; HAS-LEA-NEXT:    feeder.p.32 r1
; HAS-LEA-NEXT:    feeder.p.32 r2
; HAS-LEA-NEXT:    feeder.p.32 r3
; HAS-LEA-NEXT:    feeder.p.32 r4
; HAS-LEA-NEXT:    feeder.p.32 r5
; HAS-LEA-NEXT:    movl r6, 0x3
; HAS-LEA-NEXT:    dup r7, r4
; HAS-LEA-NEXT:    mul r7, r6
; HAS-LEA-NEXT:    movl r6, 0x8
; HAS-LEA-NEXT:    movl r8, 0x4
; HAS-LEA-NEXT:    dup r9, r1
; HAS-LEA-NEXT:    dup r10, r2
; HAS-LEA-NEXT:    leadisp r3, r6
; HAS-LEA-NEXT:    leascale r3, r8
; HAS-LEA-NEXT:    leaindex r3, r7
; HAS-LEA-NEXT:    leabase r10, r9
; HAS-LEA-NEXT:    dup r6, r1
; HAS-LEA-NEXT:    dup r11, r2
; HAS-LEA-NEXT:    leadisp r3, r3
; HAS-LEA-NEXT:    leascale r3, r8
; HAS-LEA-NEXT:    leaindex r3, r7
; HAS-LEA-NEXT:    leabase r11, r6
; HAS-LEA-NEXT:    dup r12, r1
; HAS-LEA-NEXT:    dup r13, r2
; HAS-LEA-NEXT:    leadisp r3, r8
; HAS-LEA-NEXT:    leascale r3, r8
; HAS-LEA-NEXT:    leaindex r3, r7
; HAS-LEA-NEXT:    leabase r13, r12
; HAS-LEA-NEXT:    memread.32.align[4] r10, r9, tid
; HAS-LEA-NEXT:    memdata r7
; HAS-LEA-NEXT:    memread.32.align[4] r13, r12, tid
; HAS-LEA-NEXT:    memdata r8
; HAS-LEA-NEXT:    memread.32.align[4] r11, r6, tid
; HAS-LEA-NEXT:    memdata r9
; HAS-LEA-NEXT:    inc r4
; HAS-LEA-NEXT:    movl r6, 0x64
; HAS-LEA-NEXT:    dup r10, r4
; HAS-LEA-NEXT:    sub r10, r6
; HAS-LEA-NEXT:    dup r11, r10
; HAS-LEA-NEXT:    flags r11
; HAS-LEA-NEXT:    dup r6, r9
; HAS-LEA-NEXT:    add r6, r5
; HAS-LEA-NEXT:    add r6, r8
; HAS-LEA-NEXT:    add r6, r7
; HAS-LEA-NEXT:    dup r5, tid
; HAS-LEA-NEXT:    barrier r5, r9
; HAS-LEA-NEXT:    barrier r5, r8
; HAS-LEA-NEXT:    barrier r5, r7
; HAS-LEA-NEXT:    dup tid, r5
; HAS-LEA-NEXT:    dup r5, r6
; HAS-LEA-NEXT:    movl mbb_addr, LBB1_1
; HAS-LEA-NEXT:    chain.e mbb_addr, 0x3 [r11]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r6
; HAS-LEA-NEXT:    movl mbb_addr, LBB1_2
; HAS-LEA-NEXT:    chain.p.ne mbb_addr, 0x60 [r11]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r1
; HAS-LEA-NEXT:    writer.32 mbb_addr, r2
; HAS-LEA-NEXT:    writer.32 mbb_addr, r3
; HAS-LEA-NEXT:    writer.32 mbb_addr, r4
; HAS-LEA-NEXT:    writer.32 mbb_addr, r5
;
; NO-LEA-LABEL: test2:
; NO-LEA:       LBB1_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    movl r3, 0x0
; NO-LEA-NEXT:    dup r4, r3
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    movl mbb_addr, LBB1_2
; NO-LEA-NEXT:    chain mbb_addr, 0x64
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r1
; NO-LEA-NEXT:    writer.32 mbb_addr, r2
; NO-LEA-NEXT:    writer.32 mbb_addr, r3
; NO-LEA-NEXT:    writer.32 mbb_addr, r4
; NO-LEA-NEXT:    writer.32 mbb_addr, r5
; NO-LEA-NEXT:  LBB1_1: # %for.cond.cleanup
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r7
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r7
; NO-LEA-NEXT:  LBB1_2: # %for.body
; NO-LEA-NEXT:    # =>This Inner Loop Header: Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    movl r6, 0x3
; NO-LEA-NEXT:    dup r7, r4
; NO-LEA-NEXT:    mul r7, r6
; NO-LEA-NEXT:    inc r4
; NO-LEA-NEXT:    movl r9, 0x2
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp0
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r7
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.32 call_addr, r9
; NO-LEA-NEXT:    movl call_ret_bb, LBB1_3
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r5
; NO-LEA-NEXT:    writer.32 call_ret_bb, r7
; NO-LEA-NEXT:    writer.32 call_ret_bb, r9
; NO-LEA-NEXT:  LBB1_3: # %for.body
; NO-LEA-NEXT:    # in Loop: Header=BB1_2 Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    feeder.p.32 r7
; NO-LEA-NEXT:    feeder.p.32 r9
; NO-LEA-NEXT:  .Ltmp0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r6
; NO-LEA-NEXT:    feeder.64 r8
; NO-LEA-NEXT:    dup r10, r1
; NO-LEA-NEXT:    add r10, r6
; NO-LEA-NEXT:    dup r6, r10
; NO-LEA-NEXT:    flags r6
; NO-LEA-NEXT:    dup r11, r2
; NO-LEA-NEXT:    adc r11, r8 [r6]
; NO-LEA-NEXT:    memread.32.align[4] r11, r10, tid
; NO-LEA-NEXT:    memdata r6
; NO-LEA-NEXT:    dup r8, r7
; NO-LEA-NEXT:    inc r8
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp1
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r8
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.32 call_addr, r9
; NO-LEA-NEXT:    movl call_ret_bb, LBB1_4
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r5
; NO-LEA-NEXT:    writer.32 call_ret_bb, r6
; NO-LEA-NEXT:    writer.32 call_ret_bb, r7
; NO-LEA-NEXT:    writer.32 call_ret_bb, r9
; NO-LEA-NEXT:  LBB1_4: # %for.body
; NO-LEA-NEXT:    # in Loop: Header=BB1_2 Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    feeder.p.32 r7
; NO-LEA-NEXT:    feeder.p.32 r9
; NO-LEA-NEXT:  .Ltmp1:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r8
; NO-LEA-NEXT:    feeder.64 r10
; NO-LEA-NEXT:    dup r11, r1
; NO-LEA-NEXT:    add r11, r8
; NO-LEA-NEXT:    dup r8, r11
; NO-LEA-NEXT:    flags r8
; NO-LEA-NEXT:    dup r12, r2
; NO-LEA-NEXT:    adc r12, r10 [r8]
; NO-LEA-NEXT:    memread.32.align[4] r12, r11, tid
; NO-LEA-NEXT:    memdata r8
; NO-LEA-NEXT:    add r7, r9
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp2
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r7
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.32 call_addr, r9
; NO-LEA-NEXT:    movl call_ret_bb, LBB1_5
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r5
; NO-LEA-NEXT:    writer.32 call_ret_bb, r6
; NO-LEA-NEXT:    writer.32 call_ret_bb, r8
; NO-LEA-NEXT:  LBB1_5: # %for.body
; NO-LEA-NEXT:    # in Loop: Header=BB1_2 Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    feeder.p.32 r8
; NO-LEA-NEXT:  .Ltmp2:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r7
; NO-LEA-NEXT:    feeder.64 r9
; NO-LEA-NEXT:    dup r10, r1
; NO-LEA-NEXT:    add r10, r7
; NO-LEA-NEXT:    dup r7, r10
; NO-LEA-NEXT:    flags r7
; NO-LEA-NEXT:    dup r11, r2
; NO-LEA-NEXT:    adc r11, r9 [r7]
; NO-LEA-NEXT:    memread.32.align[4] r11, r10, tid
; NO-LEA-NEXT:    memdata r9
; NO-LEA-NEXT:    movl r7, 0x64
; NO-LEA-NEXT:    dup r10, r4
; NO-LEA-NEXT:    sub r10, r7
; NO-LEA-NEXT:    dup r11, r10
; NO-LEA-NEXT:    flags r11
; NO-LEA-NEXT:    dup r7, r6
; NO-LEA-NEXT:    add r7, r5
; NO-LEA-NEXT:    add r7, r8
; NO-LEA-NEXT:    add r7, r9
; NO-LEA-NEXT:    dup r5, tid
; NO-LEA-NEXT:    barrier r5, r6
; NO-LEA-NEXT:    barrier r5, r8
; NO-LEA-NEXT:    barrier r5, r9
; NO-LEA-NEXT:    dup tid, r5
; NO-LEA-NEXT:    dup r5, r7
; NO-LEA-NEXT:    movl mbb_addr, LBB1_1
; NO-LEA-NEXT:    chain.e mbb_addr, 0x3 [r11]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r7
; NO-LEA-NEXT:    movl mbb_addr, LBB1_2
; NO-LEA-NEXT:    chain.p.ne mbb_addr, 0x60 [r11]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r1
; NO-LEA-NEXT:    writer.32 mbb_addr, r2
; NO-LEA-NEXT:    writer.32 mbb_addr, r3
; NO-LEA-NEXT:    writer.32 mbb_addr, r4
; NO-LEA-NEXT:    writer.32 mbb_addr, r5
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret i32 %add4

for.body:                                         ; preds = %entry, %for.body
  %i.024 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %res.023 = phi i32 [ 0, %entry ], [ %add4, %for.body ]
  %mul.i = mul nuw nsw i32 %i.024, 3
  %idxprom.i = zext i32 %mul.i to i64
  %arrayidx.i = getelementptr inbounds i32, i32* %arr, i64 %idxprom.i
  %0 = load i32, i32* %arrayidx.i, align 4, !tbaa !2
  %add = add nsw i32 %0, %res.023
  %add.i = add nuw nsw i32 %mul.i, 1
  %idxprom.i17 = zext i32 %add.i to i64
  %arrayidx.i18 = getelementptr inbounds i32, i32* %arr, i64 %idxprom.i17
  %1 = load i32, i32* %arrayidx.i18, align 4, !tbaa !2
  %add2 = add nsw i32 %add, %1
  %add.i20 = add nuw nsw i32 %mul.i, 2
  %idxprom.i21 = zext i32 %add.i20 to i64
  %arrayidx.i22 = getelementptr inbounds i32, i32* %arr, i64 %idxprom.i21
  %2 = load i32, i32* %arrayidx.i22, align 4, !tbaa !2
  %add4 = add nsw i32 %add2, %2
  %inc = add nuw nsw i32 %i.024, 1
  %exitcond.not = icmp eq i32 %inc, 100
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !llvm.loop !8
}

define i32 @test3(i32* nocapture readonly %a, i32 %i) {
; HAS-LEA-LABEL: test3:
; HAS-LEA:       LBB2_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    movl r4, 0x3
; HAS-LEA-NEXT:    mul r3, r4
; HAS-LEA-NEXT:    movl r4, 0x1F
; HAS-LEA-NEXT:    dup r5, r3
; HAS-LEA-NEXT:    shri r5, r4
; HAS-LEA-NEXT:    movl r4, 0x4
; HAS-LEA-NEXT:    movl r6, 0x0
; HAS-LEA-NEXT:    leadisp r6, r4
; HAS-LEA-NEXT:    leascale r6, r4
; HAS-LEA-NEXT:    leaindex r5, r3
; HAS-LEA-NEXT:    leabase r2, r1
; HAS-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; HAS-LEA-NEXT:    memdata r1
; HAS-LEA-NEXT:    dup r2, tid
; HAS-LEA-NEXT:    barrier r2, r1
; HAS-LEA-NEXT:    dup tid, r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r1
;
; NO-LEA-LABEL: test3:
; NO-LEA:       LBB2_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    movl r4, 0x3
; NO-LEA-NEXT:    mul r3, r4
; NO-LEA-NEXT:    movl r4, 0x1F
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    shri r5, r4
; NO-LEA-NEXT:    movl r4, 0x2
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp3
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.64 call_addr, r5
; NO-LEA-NEXT:    writer.32 call_addr, r4
; NO-LEA-NEXT:    movl call_ret_bb, LBB2_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:  LBB2_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:  .Ltmp3:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    flags r1
; NO-LEA-NEXT:    adc r4, r2 [r1]
; NO-LEA-NEXT:    movl r1, 0x4
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    flags r1
; NO-LEA-NEXT:    movl r2, 0x0
; NO-LEA-NEXT:    adc r4, r2 [r1]
; NO-LEA-NEXT:    memread.32.align[4] r4, r3, tid
; NO-LEA-NEXT:    memdata r1
; NO-LEA-NEXT:    dup r2, tid
; NO-LEA-NEXT:    barrier r2, r1
; NO-LEA-NEXT:    dup tid, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r1
entry:
  %mul = mul nsw i32 %i, 3
  %add = add nsw i32 %mul, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds i32, i32* %a, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !2
  ret i32 %0
}

define void @test4(i32* nocapture %a, i32 %size) {
; HAS-LEA-LABEL: test4:
; HAS-LEA:       LBB3_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r3
; HAS-LEA-NEXT:    sub r5, r4
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    flags r6
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    movl mbb_addr, LBB3_2
; HAS-LEA-NEXT:    chain.g mbb_addr, 0x3E [r6]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r1
; HAS-LEA-NEXT:    writer.32 mbb_addr, r2
; HAS-LEA-NEXT:    writer.32 mbb_addr, r3
; HAS-LEA-NEXT:    writer.32 mbb_addr, r4
; HAS-LEA-NEXT:    writer.32 mbb_addr, r5
; HAS-LEA-NEXT:    movl mbb_addr, LBB3_1
; HAS-LEA-NEXT:    chain.le mbb_addr, 0x25 [r6]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:  LBB3_1: # %for.cond.cleanup
; HAS-LEA-NEXT:    feeder.p.32 tid
; HAS-LEA-NEXT:    feeder.p.32 ret_fid
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:  LBB3_2: # %for.body
; HAS-LEA-NEXT:    # =>This Inner Loop Header: Depth=1
; HAS-LEA-NEXT:    feeder.p.32 tid
; HAS-LEA-NEXT:    feeder.p.32 ret_fid
; HAS-LEA-NEXT:    feeder.p.32 r1
; HAS-LEA-NEXT:    feeder.p.32 r2
; HAS-LEA-NEXT:    feeder.p.32 r3
; HAS-LEA-NEXT:    feeder.p.32 r4
; HAS-LEA-NEXT:    feeder.p.32 r5
; HAS-LEA-NEXT:    movl r6, 0xC
; HAS-LEA-NEXT:    movl r7, 0x4
; HAS-LEA-NEXT:    dup r8, r1
; HAS-LEA-NEXT:    dup r9, r2
; HAS-LEA-NEXT:    leadisp r4, r6
; HAS-LEA-NEXT:    leascale r4, r7
; HAS-LEA-NEXT:    leaindex r4, r5
; HAS-LEA-NEXT:    leabase r9, r8
; HAS-LEA-NEXT:    memread.32.align[4] r9, r8, tid
; HAS-LEA-NEXT:    memdata r6
; HAS-LEA-NEXT:    movl r8, 0x8
; HAS-LEA-NEXT:    dup r9, r1
; HAS-LEA-NEXT:    dup r10, r2
; HAS-LEA-NEXT:    leadisp r4, r8
; HAS-LEA-NEXT:    leascale r4, r7
; HAS-LEA-NEXT:    leaindex r4, r5
; HAS-LEA-NEXT:    leabase r10, r9
; HAS-LEA-NEXT:    dup r8, r6
; HAS-LEA-NEXT:    memwrite.32.align[4] r10, r9, tid
; HAS-LEA-NEXT:    memdata r8
; HAS-LEA-NEXT:    dup r9, r1
; HAS-LEA-NEXT:    dup r10, r2
; HAS-LEA-NEXT:    leadisp r4, r4
; HAS-LEA-NEXT:    leascale r4, r7
; HAS-LEA-NEXT:    leaindex r4, r5
; HAS-LEA-NEXT:    leabase r10, r9
; HAS-LEA-NEXT:    dup r11, r1
; HAS-LEA-NEXT:    dup r12, r2
; HAS-LEA-NEXT:    leadisp r4, r7
; HAS-LEA-NEXT:    leascale r4, r7
; HAS-LEA-NEXT:    leaindex r4, r5
; HAS-LEA-NEXT:    leabase r12, r11
; HAS-LEA-NEXT:    memread.32.align[4] r12, r11, tid
; HAS-LEA-NEXT:    memdata r11
; HAS-LEA-NEXT:    dup r12, r11
; HAS-LEA-NEXT:    memwrite.32.align[4] r10, r9, tid
; HAS-LEA-NEXT:    memdata r12
; HAS-LEA-NEXT:    add r5, r7
; HAS-LEA-NEXT:    dup r7, tid
; HAS-LEA-NEXT:    barrier r7, r11
; HAS-LEA-NEXT:    barrier r7, r6
; HAS-LEA-NEXT:    barrier r7, r12
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    sub r6, r3
; HAS-LEA-NEXT:    dup r9, r6
; HAS-LEA-NEXT:    flags r9
; HAS-LEA-NEXT:    barrier r7, r8
; HAS-LEA-NEXT:    dup tid, r7
; HAS-LEA-NEXT:    movl mbb_addr, LBB3_2
; HAS-LEA-NEXT:    chain.p.l mbb_addr, 0x60 [r9]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; HAS-LEA-NEXT:    writer.32 mbb_addr, r1
; HAS-LEA-NEXT:    writer.32 mbb_addr, r2
; HAS-LEA-NEXT:    writer.32 mbb_addr, r3
; HAS-LEA-NEXT:    writer.32 mbb_addr, r4
; HAS-LEA-NEXT:    writer.32 mbb_addr, r5
; HAS-LEA-NEXT:    movl mbb_addr, LBB3_1
; HAS-LEA-NEXT:    chain.ge mbb_addr, 0x3 [r9]
; HAS-LEA-NEXT:    writer.32 mbb_addr, tid
; HAS-LEA-NEXT:    writer.32 mbb_addr, ret_fid
;
; NO-LEA-LABEL: test4:
; NO-LEA:       LBB3_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    movl r4, 0x0
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    sub r5, r4
; NO-LEA-NEXT:    dup r7, r5
; NO-LEA-NEXT:    flags r7
; NO-LEA-NEXT:    dup r6, r4
; NO-LEA-NEXT:    movl mbb_addr, LBB3_2
; NO-LEA-NEXT:    chain.g mbb_addr, 0x3E [r7]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r1
; NO-LEA-NEXT:    writer.32 mbb_addr, r2
; NO-LEA-NEXT:    writer.32 mbb_addr, r3
; NO-LEA-NEXT:    writer.32 mbb_addr, r4
; NO-LEA-NEXT:    writer.32 mbb_addr, r6
; NO-LEA-NEXT:    movl mbb_addr, LBB3_1
; NO-LEA-NEXT:    chain.le mbb_addr, 0x25 [r7]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:  LBB3_1: # %for.cond.cleanup
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:  LBB3_2: # %for.body
; NO-LEA-NEXT:    # =>This Inner Loop Header: Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    movl r7, 0x4
; NO-LEA-NEXT:    dup r5, r6
; NO-LEA-NEXT:    add r5, r7
; NO-LEA-NEXT:    movl r7, 0x2
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp5
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r6
; NO-LEA-NEXT:    writer.64 call_addr, r4
; NO-LEA-NEXT:    writer.32 call_addr, r7
; NO-LEA-NEXT:    movl call_ret_bb, LBB3_3
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r5
; NO-LEA-NEXT:    writer.32 call_ret_bb, r6
; NO-LEA-NEXT:    writer.32 call_ret_bb, r7
; NO-LEA-NEXT:  LBB3_3: # %for.body
; NO-LEA-NEXT:    # in Loop: Header=BB3_2 Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    feeder.p.32 r7
; NO-LEA-NEXT:  .Ltmp5:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.p.64 r9
; NO-LEA-NEXT:    feeder.p.64 r8
; NO-LEA-NEXT:    dup r10, r6
; NO-LEA-NEXT:    or r10, r7
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp7
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r10
; NO-LEA-NEXT:    writer.64 call_addr, r4
; NO-LEA-NEXT:    writer.32 call_addr, r7
; NO-LEA-NEXT:    movl call_ret_bb, LBB3_4
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r5
; NO-LEA-NEXT:    writer.32 call_ret_bb, r6
; NO-LEA-NEXT:    writer.32 call_ret_bb, r7
; NO-LEA-NEXT:    writer.32 call_ret_bb, r8
; NO-LEA-NEXT:    writer.32 call_ret_bb, r9
; NO-LEA-NEXT:  LBB3_4: # %for.body
; NO-LEA-NEXT:    # in Loop: Header=BB3_2 Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    feeder.p.32 r7
; NO-LEA-NEXT:    feeder.p.32 r8
; NO-LEA-NEXT:    feeder.p.32 r9
; NO-LEA-NEXT:  .Ltmp7:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r11
; NO-LEA-NEXT:    feeder.64 r13
; NO-LEA-NEXT:    dup r10, r1
; NO-LEA-NEXT:    add r10, r11
; NO-LEA-NEXT:    dup r11, r10
; NO-LEA-NEXT:    flags r11
; NO-LEA-NEXT:    dup r12, r2
; NO-LEA-NEXT:    adc r12, r13 [r11]
; NO-LEA-NEXT:    movl r11, 0x3
; NO-LEA-NEXT:    dup r13, r6
; NO-LEA-NEXT:    or r13, r11
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp6
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r13
; NO-LEA-NEXT:    writer.64 call_addr, r4
; NO-LEA-NEXT:    writer.32 call_addr, r7
; NO-LEA-NEXT:    movl call_ret_bb, LBB3_5
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r5
; NO-LEA-NEXT:    writer.32 call_ret_bb, r6
; NO-LEA-NEXT:    writer.32 call_ret_bb, r7
; NO-LEA-NEXT:    writer.32 call_ret_bb, r8
; NO-LEA-NEXT:    writer.32 call_ret_bb, r9
; NO-LEA-NEXT:    writer.32 call_ret_bb, r10
; NO-LEA-NEXT:    writer.32 call_ret_bb, r12
; NO-LEA-NEXT:  LBB3_5: # %for.body
; NO-LEA-NEXT:    # in Loop: Header=BB3_2 Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    feeder.p.32 r7
; NO-LEA-NEXT:    feeder.p.32 r8
; NO-LEA-NEXT:    feeder.p.32 r9
; NO-LEA-NEXT:    feeder.p.32 r10
; NO-LEA-NEXT:    feeder.p.32 r12
; NO-LEA-NEXT:  .Ltmp6:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r11
; NO-LEA-NEXT:    feeder.64 r13
; NO-LEA-NEXT:    dup r14, r1
; NO-LEA-NEXT:    add r14, r11
; NO-LEA-NEXT:    dup r11, r14
; NO-LEA-NEXT:    flags r11
; NO-LEA-NEXT:    dup r15, r2
; NO-LEA-NEXT:    adc r15, r13 [r11]
; NO-LEA-NEXT:    dup r11, r1
; NO-LEA-NEXT:    add r11, r9
; NO-LEA-NEXT:    dup r9, r11
; NO-LEA-NEXT:    flags r9
; NO-LEA-NEXT:    dup r13, r2
; NO-LEA-NEXT:    adc r13, r8 [r9]
; NO-LEA-NEXT:    memread.32.align[4] r15, r14, tid
; NO-LEA-NEXT:    memdata r9
; NO-LEA-NEXT:    dup r8, r9
; NO-LEA-NEXT:    memwrite.32.align[4] r12, r10, tid
; NO-LEA-NEXT:    memdata r8
; NO-LEA-NEXT:    movl r10, 0x1
; NO-LEA-NEXT:    or r6, r10
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp4
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r6
; NO-LEA-NEXT:    writer.64 call_addr, r4
; NO-LEA-NEXT:    writer.32 call_addr, r7
; NO-LEA-NEXT:    movl call_ret_bb, LBB3_6
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r5
; NO-LEA-NEXT:    writer.32 call_ret_bb, r8
; NO-LEA-NEXT:    writer.32 call_ret_bb, r9
; NO-LEA-NEXT:    writer.32 call_ret_bb, r11
; NO-LEA-NEXT:    writer.32 call_ret_bb, r13
; NO-LEA-NEXT:  LBB3_6: # %for.body
; NO-LEA-NEXT:    # in Loop: Header=BB3_2 Depth=1
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r5
; NO-LEA-NEXT:    feeder.p.32 r8
; NO-LEA-NEXT:    feeder.p.32 r9
; NO-LEA-NEXT:    feeder.p.32 r11
; NO-LEA-NEXT:    feeder.p.32 r13
; NO-LEA-NEXT:  .Ltmp4:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r6
; NO-LEA-NEXT:    feeder.64 r7
; NO-LEA-NEXT:    dup r10, r1
; NO-LEA-NEXT:    add r10, r6
; NO-LEA-NEXT:    dup r6, r10
; NO-LEA-NEXT:    flags r6
; NO-LEA-NEXT:    dup r12, r2
; NO-LEA-NEXT:    adc r12, r7 [r6]
; NO-LEA-NEXT:    memread.32.align[4] r12, r10, tid
; NO-LEA-NEXT:    memdata r6
; NO-LEA-NEXT:    dup r7, r6
; NO-LEA-NEXT:    memwrite.32.align[4] r13, r11, tid
; NO-LEA-NEXT:    memdata r7
; NO-LEA-NEXT:    dup r10, r5
; NO-LEA-NEXT:    sub r10, r3
; NO-LEA-NEXT:    dup r11, r10
; NO-LEA-NEXT:    flags r11
; NO-LEA-NEXT:    dup r10, tid
; NO-LEA-NEXT:    barrier r10, r9
; NO-LEA-NEXT:    barrier r10, r8
; NO-LEA-NEXT:    barrier r10, r6
; NO-LEA-NEXT:    barrier r10, r7
; NO-LEA-NEXT:    dup tid, r10
; NO-LEA-NEXT:    dup r6, r5
; NO-LEA-NEXT:    movl mbb_addr, LBB3_2
; NO-LEA-NEXT:    chain.p.l mbb_addr, 0x60 [r11]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
; NO-LEA-NEXT:    writer.32 mbb_addr, r1
; NO-LEA-NEXT:    writer.32 mbb_addr, r2
; NO-LEA-NEXT:    writer.32 mbb_addr, r3
; NO-LEA-NEXT:    writer.32 mbb_addr, r4
; NO-LEA-NEXT:    writer.32 mbb_addr, r6
; NO-LEA-NEXT:    movl mbb_addr, LBB3_1
; NO-LEA-NEXT:    chain.ge mbb_addr, 0x3 [r11]
; NO-LEA-NEXT:    writer.32 mbb_addr, tid
; NO-LEA-NEXT:    writer.32 mbb_addr, ret_fid
entry:
  %cmp19 = icmp sgt i32 %size, 0
  br i1 %cmp19, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.body, %entry
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.020 = phi i32 [ %add9, %for.body ], [ 0, %entry ]
  %add = or i32 %i.020, 1
  %idxprom = zext i32 %add to i64
  %arrayidx = getelementptr inbounds i32, i32* %a, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %idxprom1 = zext i32 %i.020 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %a, i64 %idxprom1
  store i32 %0, i32* %arrayidx2, align 4, !tbaa !2
  %add3 = or i32 %i.020, 3
  %idxprom4 = zext i32 %add3 to i64
  %arrayidx5 = getelementptr inbounds i32, i32* %a, i64 %idxprom4
  %1 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %add6 = or i32 %i.020, 2
  %idxprom7 = zext i32 %add6 to i64
  %arrayidx8 = getelementptr inbounds i32, i32* %a, i64 %idxprom7
  store i32 %1, i32* %arrayidx8, align 4, !tbaa !2
  %add9 = add nuw nsw i32 %i.020, 4
  %cmp = icmp slt i32 %add9, %size
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !llvm.loop !9
}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"NextSilicon clang version 12.0.1 (git@github.com:nextsilicon/next-llvm-project.git e98966a092fbaf28e9de08aea5233402b244d343)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = distinct !{!6, !7}
!7 = !{!"llvm.loop.mustprogress"}
!8 = distinct !{!8, !7}
!9 = distinct !{!9, !7}
