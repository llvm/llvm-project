; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 -mattr=+lea < %s | FileCheck %s --check-prefix=HAS-LEA
; RUN: llc -mtriple=next32 -mattr=-lea < %s | FileCheck %s --check-prefix=NO-LEA

; Original C source:
; #include <stdint.h>
;
; int64_t test(int64_t a) {
; 	return a << 58;
; }
;
; int64_t test1(int64_t a) {
; 	return (a << 58) + 4;
; }
;
; int64_t test2(int64_t a) {
; 	return a << 32;
; }
;
; int64_t test3(int64_t a) {
; 	return (a * 0x300000000);
; }
;
; // TODO: This should create LEA
; int64_t test4(int64_t a, int64_t b) {
; 	return (a << 32) + b + 4;
; }
;
; // TODO: This should create LEA
; uint64_t test5(uint32_t a, uint64_t b) {
; 	return ((uint64_t)a << 32) + b + 4;
; }
;
; // This create LEA
; int64_t test6(int64_t a, int64_t b) {
;   return (a * 0x300000000) + b * 123;
; }
;
; // TODO: This create incomplete LEA, add should be included
; int64_t test7(int64_t a, int64_t b) {
;   return (b * 0x300000000) + a * 123;
; }

define i64 @test(i64 %0) {
; HAS-LEA-LABEL: test:
; HAS-LEA:       LBB0_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r2, 0x1A
; HAS-LEA-NEXT:    shl r1, r2
; HAS-LEA-NEXT:    movl r2, 0x0
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
;
; NO-LEA-LABEL: test:
; NO-LEA:       LBB0_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r2, 0x1A
; NO-LEA-NEXT:    shl r1, r2
; NO-LEA-NEXT:    movl r2, 0x0
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r2
; NO-LEA-NEXT:    writer.64 ret_fid, r1
  %2 = shl i64 %0, 58
  ret i64 %2
}

define i64 @test1(i64 %0) {
; HAS-LEA-LABEL: test1:
; HAS-LEA:       LBB1_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r2, 0x1A
; HAS-LEA-NEXT:    shl r1, r2
; HAS-LEA-NEXT:    movl r2, 0x4
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
;
; NO-LEA-LABEL: test1:
; NO-LEA:       LBB1_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r2, 0x1A
; NO-LEA-NEXT:    shl r1, r2
; NO-LEA-NEXT:    movl r2, 0x4
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r2
; NO-LEA-NEXT:    writer.64 ret_fid, r1
  %2 = shl i64 %0, 58
  %3 = or i64 %2, 4
  ret i64 %3
}

define i64 @test2(i64 %0) {
; HAS-LEA-LABEL: test2:
; HAS-LEA:       LBB2_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r2, 0x0
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
;
; NO-LEA-LABEL: test2:
; NO-LEA:       LBB2_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r2, 0x0
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r2
; NO-LEA-NEXT:    writer.64 ret_fid, r1
  %2 = shl i64 %0, 32
  ret i64 %2
}

define i64 @test3(i64 %0) {
; HAS-LEA-LABEL: test3:
; HAS-LEA:       LBB3_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r2, 0x3
; HAS-LEA-NEXT:    mul r1, r2
; HAS-LEA-NEXT:    movl r2, 0x0
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
;
; NO-LEA-LABEL: test3:
; NO-LEA:       LBB3_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r2, 0x3
; NO-LEA-NEXT:    mul r1, r2
; NO-LEA-NEXT:    movl r2, 0x0
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r2
; NO-LEA-NEXT:    writer.64 ret_fid, r1
  %2 = mul nsw i64 %0, 12884901888
  ret i64 %2
}

define i64 @test4(i64 %0, i64 %1) {
; HAS-LEA-LABEL: test4:
; HAS-LEA:       LBB4_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r2, 0x4
; HAS-LEA-NEXT:    add r3, r2
; HAS-LEA-NEXT:    dup r2, r3
; HAS-LEA-NEXT:    flags r2
; HAS-LEA-NEXT:    adc r4, r1 [r2]
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test4:
; NO-LEA:       LBB4_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r2, 0x4
; NO-LEA-NEXT:    add r3, r2
; NO-LEA-NEXT:    dup r2, r3
; NO-LEA-NEXT:    flags r2
; NO-LEA-NEXT:    adc r4, r1 [r2]
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r4
  %3 = shl i64 %0, 32
  %4 = add i64 %1, 4
  %5 = add i64 %4, %3
  ret i64 %5
}

define i64 @test5(i32 %0, i64 %1) {
; HAS-LEA-LABEL: test5:
; HAS-LEA:       LBB5_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    movl r4, 0x4
; HAS-LEA-NEXT:    add r2, r4
; HAS-LEA-NEXT:    dup r4, r2
; HAS-LEA-NEXT:    flags r4
; HAS-LEA-NEXT:    adc r3, r1 [r4]
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
;
; NO-LEA-LABEL: test5:
; NO-LEA:       LBB5_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.32 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    movl r4, 0x4
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    dup r4, r2
; NO-LEA-NEXT:    flags r4
; NO-LEA-NEXT:    adc r3, r1 [r4]
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r2
; NO-LEA-NEXT:    writer.64 ret_fid, r3
  %3 = zext i32 %0 to i64
  %4 = shl nuw i64 %3, 32
  %5 = add i64 %1, 4
  %6 = add i64 %5, %4
  ret i64 %6
}

define i64 @test6(i64 %0, i64 %1) {
; HAS-LEA-LABEL: test6:
; HAS-LEA:       LBB6_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r2, 0x3
; HAS-LEA-NEXT:    mul r1, r2
; HAS-LEA-NEXT:    movl r2, 0x7B
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r2
; HAS-LEA-NEXT:    leaindex r4, r3
; HAS-LEA-NEXT:    leabase r1, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
;
; NO-LEA-LABEL: test6:
; NO-LEA:       LBB6_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r2, 0x7B
; NO-LEA-NEXT:    mul r4, r2
; NO-LEA-NEXT:    umul r3, r2
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    movl r4, 0x3
; NO-LEA-NEXT:    mul r1, r4
; NO-LEA-NEXT:    add r2, r1
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r2
  %3 = mul nsw i64 %0, 12884901888
  %4 = mul nsw i64 %1, 123
  %5 = add nsw i64 %4, %3
  ret i64 %5
}

define i64 @test7(i64 %0, i64 %1) {
; HAS-LEA-LABEL: test7:
; HAS-LEA:       LBB7_0:
; HAS-LEA-NEXT:  # %bb.0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r4, 0x7B
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r6, r4
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r5, r6
; HAS-LEA-NEXT:    movl r1, 0x3
; HAS-LEA-NEXT:    mul r3, r1
; HAS-LEA-NEXT:    add r3, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
;
; NO-LEA-LABEL: test7:
; NO-LEA:       LBB7_0:
; NO-LEA-NEXT:  # %bb.0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r4, 0x7B
; NO-LEA-NEXT:    mul r2, r4
; NO-LEA-NEXT:    umul r1, r4
; NO-LEA-NEXT:    add r4, r2
; NO-LEA-NEXT:    movl r2, 0x3
; NO-LEA-NEXT:    mul r3, r2
; NO-LEA-NEXT:    add r3, r4
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r3
  %3 = mul nsw i64 %1, 12884901888
  %4 = mul nsw i64 %0, 123
  %5 = add nsw i64 %3, %4
  ret i64 %5
}
