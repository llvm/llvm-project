; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 < %s | FileCheck %s

; Original C++ source:
; #include <stdio.h>
; #include <stdint.h>
;
; template<typename T>
; struct result {
; 	T div;
; 	T rem;
; };
;
; template<typename T>
; __attribute__((noinline)) result<T> divrem(T a, T b) {
; 	T div = a / b;
; 	T rem = a % b;
; 	return {div, rem};
; }
;
; template<typename T>
; __attribute__((noinline)) T div(T a, T b) {
; 	T div = a / b;
; 	return div;
; }
;
; template<typename T>
; __attribute__((noinline)) T rem(T a, T b) {
; 	T rem = a % b;
; 	return rem;
; }
;
; template result<int32_t> divrem(int32_t, int32_t);
; template result<uint32_t> divrem(uint32_t, uint32_t);
; template result<int64_t> divrem(int64_t, int64_t);
; template result<uint64_t> divrem(uint64_t, uint64_t);
;
; template int32_t div(int32_t, int32_t);
; template uint32_t div(uint32_t, uint32_t);
; template int64_t div(int64_t, int64_t);
; template uint64_t div(uint64_t, uint64_t);
;
; template int32_t rem(int32_t, int32_t);
; template uint32_t rem(uint32_t, uint32_t);
; template int64_t rem(int64_t, int64_t);
; template uint64_t rem(uint64_t, uint64_t);

%struct.result = type { i32, i32 }
%struct.result.0 = type { i32, i32 }
%struct.result.1 = type { i64, i64 }
%struct.result.2 = type { i64, i64 }

$_Z6divremIiE6resultIT_ES1_S1_ = comdat any

$_Z6divremIjE6resultIT_ES1_S1_ = comdat any

$_Z6divremIlE6resultIT_ES1_S1_ = comdat any

$_Z6divremImE6resultIT_ES1_S1_ = comdat any

$_Z3divIiET_S0_S0_ = comdat any

$_Z3divIjET_S0_S0_ = comdat any

$_Z3divIlET_S0_S0_ = comdat any

$_Z3divImET_S0_S0_ = comdat any

$_Z3remIiET_S0_S0_ = comdat any

$_Z3remIjET_S0_S0_ = comdat any

$_Z3remIlET_S0_S0_ = comdat any

$_Z3remImET_S0_S0_ = comdat any

define weak_odr dso_local void @_Z6divremIiE6resultIT_ES1_S1_(%struct.result* noalias sret(%struct.result) align 4 %0, i32 %1, i32 %2) #0 comdat {
; CHECK-LABEL: _Z6divremIiE6resultIT_ES1_S1_:
; CHECK:       LBB0_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.32 r3
; CHECK-NEXT:    feeder.32 r4
; CHECK-NEXT:    movl r7, 0x4
; CHECK-NEXT:    movl r8, 0x0
; CHECK-NEXT:    dup r5, r1
; CHECK-NEXT:    dup r6, r2
; CHECK-NEXT:    leadisp r8, r7
; CHECK-NEXT:    leascale r8, r8
; CHECK-NEXT:    leaindex r8, r8
; CHECK-NEXT:    leabase r6, r5
; CHECK-NEXT:    movl call_addr, __next32_sdivrem32
; CHECK-NEXT:    movl call_ret_fid, .Ltmp0
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.32 call_addr, r3
; CHECK-NEXT:    writer.32 call_addr, r4
; CHECK-NEXT:    movl call_ret_bb, LBB0_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:    writer.32 call_ret_bb, r1
; CHECK-NEXT:    writer.32 call_ret_bb, r2
; CHECK-NEXT:    writer.32 call_ret_bb, r5
; CHECK-NEXT:    writer.32 call_ret_bb, r6
; CHECK-NEXT:  LBB0_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:    feeder.p.32 r1
; CHECK-NEXT:    feeder.p.32 r2
; CHECK-NEXT:    feeder.p.32 r5
; CHECK-NEXT:    feeder.p.32 r6
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r3
; CHECK-NEXT:    feeder.64 r4
; CHECK-NEXT:    memwrite.32.align[4] r6, r5, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    memwrite.32.align[4] r2, r1, tid
; CHECK-NEXT:    memdata r4
; CHECK-NEXT:    dup r1, tid
; CHECK-NEXT:    barrier r1, r3
; CHECK-NEXT:    barrier r1, r4
; CHECK-NEXT:    dup tid, r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  store i32 %1, i32* %4, align 4
  store i32 %2, i32* %5, align 4
  %8 = load i32, i32* %4, align 4
  %9 = load i32, i32* %5, align 4
  %10 = sdiv i32 %8, %9
  store i32 %10, i32* %6, align 4
  %11 = load i32, i32* %4, align 4
  %12 = load i32, i32* %5, align 4
  %13 = srem i32 %11, %12
  store i32 %13, i32* %7, align 4
  %14 = getelementptr inbounds %struct.result, %struct.result* %0, i32 0, i32 0
  %15 = load i32, i32* %6, align 4
  store i32 %15, i32* %14, align 4
  %16 = getelementptr inbounds %struct.result, %struct.result* %0, i32 0, i32 1
  %17 = load i32, i32* %7, align 4
  store i32 %17, i32* %16, align 4
  ret void
}

define weak_odr dso_local void @_Z6divremIjE6resultIT_ES1_S1_(%struct.result.0* noalias sret(%struct.result.0) align 4 %0, i32 %1, i32 %2) #0 comdat {
; CHECK-LABEL: _Z6divremIjE6resultIT_ES1_S1_:
; CHECK:       LBB1_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.32 r3
; CHECK-NEXT:    feeder.32 r4
; CHECK-NEXT:    movl r7, 0x4
; CHECK-NEXT:    movl r8, 0x0
; CHECK-NEXT:    dup r5, r1
; CHECK-NEXT:    dup r6, r2
; CHECK-NEXT:    leadisp r8, r7
; CHECK-NEXT:    leascale r8, r8
; CHECK-NEXT:    leaindex r8, r8
; CHECK-NEXT:    leabase r6, r5
; CHECK-NEXT:    movl call_addr, __next32_udivrem32
; CHECK-NEXT:    movl call_ret_fid, .Ltmp1
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.32 call_addr, r3
; CHECK-NEXT:    writer.32 call_addr, r4
; CHECK-NEXT:    movl call_ret_bb, LBB1_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:    writer.32 call_ret_bb, r1
; CHECK-NEXT:    writer.32 call_ret_bb, r2
; CHECK-NEXT:    writer.32 call_ret_bb, r5
; CHECK-NEXT:    writer.32 call_ret_bb, r6
; CHECK-NEXT:  LBB1_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:    feeder.p.32 r1
; CHECK-NEXT:    feeder.p.32 r2
; CHECK-NEXT:    feeder.p.32 r5
; CHECK-NEXT:    feeder.p.32 r6
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r3
; CHECK-NEXT:    feeder.64 r4
; CHECK-NEXT:    memwrite.32.align[4] r6, r5, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    memwrite.32.align[4] r2, r1, tid
; CHECK-NEXT:    memdata r4
; CHECK-NEXT:    dup r1, tid
; CHECK-NEXT:    barrier r1, r3
; CHECK-NEXT:    barrier r1, r4
; CHECK-NEXT:    dup tid, r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  store i32 %1, i32* %4, align 4
  store i32 %2, i32* %5, align 4
  %8 = load i32, i32* %4, align 4
  %9 = load i32, i32* %5, align 4
  %10 = udiv i32 %8, %9
  store i32 %10, i32* %6, align 4
  %11 = load i32, i32* %4, align 4
  %12 = load i32, i32* %5, align 4
  %13 = urem i32 %11, %12
  store i32 %13, i32* %7, align 4
  %14 = getelementptr inbounds %struct.result.0, %struct.result.0* %0, i32 0, i32 0
  %15 = load i32, i32* %6, align 4
  store i32 %15, i32* %14, align 4
  %16 = getelementptr inbounds %struct.result.0, %struct.result.0* %0, i32 0, i32 1
  %17 = load i32, i32* %7, align 4
  store i32 %17, i32* %16, align 4
  ret void
}

define weak_odr dso_local void @_Z6divremIlE6resultIT_ES1_S1_(%struct.result.1* noalias sret(%struct.result.1) align 8 %0, i64 %1, i64 %2) #0 comdat {
; CHECK-LABEL: _Z6divremIlE6resultIT_ES1_S1_:
; CHECK:       LBB2_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r3
; CHECK-NEXT:    feeder.64 r4
; CHECK-NEXT:    feeder.64 r5
; CHECK-NEXT:    feeder.64 r6
; CHECK-NEXT:    movl r9, 0x8
; CHECK-NEXT:    movl r10, 0x0
; CHECK-NEXT:    dup r7, r1
; CHECK-NEXT:    dup r8, r2
; CHECK-NEXT:    leadisp r10, r9
; CHECK-NEXT:    leascale r10, r10
; CHECK-NEXT:    leaindex r10, r10
; CHECK-NEXT:    leabase r8, r7
; CHECK-NEXT:    movl call_addr, __next32_sdivrem64
; CHECK-NEXT:    movl call_ret_fid, .Ltmp2
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r3
; CHECK-NEXT:    writer.64 call_addr, r4
; CHECK-NEXT:    writer.64 call_addr, r5
; CHECK-NEXT:    writer.64 call_addr, r6
; CHECK-NEXT:    movl call_ret_bb, LBB2_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:    writer.32 call_ret_bb, r1
; CHECK-NEXT:    writer.32 call_ret_bb, r2
; CHECK-NEXT:    writer.32 call_ret_bb, r7
; CHECK-NEXT:    writer.32 call_ret_bb, r8
; CHECK-NEXT:  LBB2_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:    feeder.p.32 r1
; CHECK-NEXT:    feeder.p.32 r2
; CHECK-NEXT:    feeder.p.32 r7
; CHECK-NEXT:    feeder.p.32 r8
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.128 r3
; CHECK-NEXT:    feeder.128 r5
; CHECK-NEXT:    feeder.128 r4
; CHECK-NEXT:    feeder.128 r6
; CHECK-NEXT:    memwrite.64.align[8] r8, r7, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    memwrite.64.align[8] r2, r1, tid
; CHECK-NEXT:    memdata r6
; CHECK-NEXT:    memdata r4
; CHECK-NEXT:    dup r1, tid
; CHECK-NEXT:    barrier r1, r5
; CHECK-NEXT:    barrier r1, r6
; CHECK-NEXT:    dup tid, r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  store i64 %1, i64* %4, align 8
  store i64 %2, i64* %5, align 8
  %8 = load i64, i64* %4, align 8
  %9 = load i64, i64* %5, align 8
  %10 = sdiv i64 %8, %9
  store i64 %10, i64* %6, align 8
  %11 = load i64, i64* %4, align 8
  %12 = load i64, i64* %5, align 8
  %13 = srem i64 %11, %12
  store i64 %13, i64* %7, align 8
  %14 = getelementptr inbounds %struct.result.1, %struct.result.1* %0, i32 0, i32 0
  %15 = load i64, i64* %6, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %struct.result.1, %struct.result.1* %0, i32 0, i32 1
  %17 = load i64, i64* %7, align 8
  store i64 %17, i64* %16, align 8
  ret void
}

define weak_odr dso_local void @_Z6divremImE6resultIT_ES1_S1_(%struct.result.2* noalias sret(%struct.result.2) align 8 %0, i64 %1, i64 %2) #0 comdat {
; CHECK-LABEL: _Z6divremImE6resultIT_ES1_S1_:
; CHECK:       LBB3_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r3
; CHECK-NEXT:    feeder.64 r4
; CHECK-NEXT:    feeder.64 r5
; CHECK-NEXT:    feeder.64 r6
; CHECK-NEXT:    movl r9, 0x8
; CHECK-NEXT:    movl r10, 0x0
; CHECK-NEXT:    dup r7, r1
; CHECK-NEXT:    dup r8, r2
; CHECK-NEXT:    leadisp r10, r9
; CHECK-NEXT:    leascale r10, r10
; CHECK-NEXT:    leaindex r10, r10
; CHECK-NEXT:    leabase r8, r7
; CHECK-NEXT:    movl call_addr, __next32_udivrem64
; CHECK-NEXT:    movl call_ret_fid, .Ltmp3
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r3
; CHECK-NEXT:    writer.64 call_addr, r4
; CHECK-NEXT:    writer.64 call_addr, r5
; CHECK-NEXT:    writer.64 call_addr, r6
; CHECK-NEXT:    movl call_ret_bb, LBB3_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:    writer.32 call_ret_bb, r1
; CHECK-NEXT:    writer.32 call_ret_bb, r2
; CHECK-NEXT:    writer.32 call_ret_bb, r7
; CHECK-NEXT:    writer.32 call_ret_bb, r8
; CHECK-NEXT:  LBB3_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:    feeder.p.32 r1
; CHECK-NEXT:    feeder.p.32 r2
; CHECK-NEXT:    feeder.p.32 r7
; CHECK-NEXT:    feeder.p.32 r8
; CHECK-NEXT:  .Ltmp3:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.128 r3
; CHECK-NEXT:    feeder.128 r5
; CHECK-NEXT:    feeder.128 r4
; CHECK-NEXT:    feeder.128 r6
; CHECK-NEXT:    memwrite.64.align[8] r8, r7, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    memwrite.64.align[8] r2, r1, tid
; CHECK-NEXT:    memdata r6
; CHECK-NEXT:    memdata r4
; CHECK-NEXT:    dup r1, tid
; CHECK-NEXT:    barrier r1, r5
; CHECK-NEXT:    barrier r1, r6
; CHECK-NEXT:    dup tid, r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  store i64 %1, i64* %4, align 8
  store i64 %2, i64* %5, align 8
  %8 = load i64, i64* %4, align 8
  %9 = load i64, i64* %5, align 8
  %10 = udiv i64 %8, %9
  store i64 %10, i64* %6, align 8
  %11 = load i64, i64* %4, align 8
  %12 = load i64, i64* %5, align 8
  %13 = urem i64 %11, %12
  store i64 %13, i64* %7, align 8
  %14 = getelementptr inbounds %struct.result.2, %struct.result.2* %0, i32 0, i32 0
  %15 = load i64, i64* %6, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %struct.result.2, %struct.result.2* %0, i32 0, i32 1
  %17 = load i64, i64* %7, align 8
  store i64 %17, i64* %16, align 8
  ret void
}

define weak_odr dso_local i32 @_Z3divIiET_S0_S0_(i32 %0, i32 %1) #0 comdat {
; CHECK-LABEL: _Z3divIiET_S0_S0_:
; CHECK:       LBB4_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl call_addr, __divsi3
; CHECK-NEXT:    movl call_ret_fid, .Ltmp4
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.32 call_addr, r1
; CHECK-NEXT:    writer.32 call_addr, r2
; CHECK-NEXT:    movl call_ret_bb, LBB4_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB4_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp4:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  store i32 %1, i32* %4, align 4
  %6 = load i32, i32* %3, align 4
  %7 = load i32, i32* %4, align 4
  %8 = sdiv i32 %6, %7
  store i32 %8, i32* %5, align 4
  %9 = load i32, i32* %5, align 4
  ret i32 %9
}

define weak_odr dso_local i32 @_Z3divIjET_S0_S0_(i32 %0, i32 %1) #0 comdat {
; CHECK-LABEL: _Z3divIjET_S0_S0_:
; CHECK:       LBB5_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl call_addr, __udivsi3
; CHECK-NEXT:    movl call_ret_fid, .Ltmp5
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.32 call_addr, r1
; CHECK-NEXT:    writer.32 call_addr, r2
; CHECK-NEXT:    movl call_ret_bb, LBB5_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB5_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp5:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  store i32 %1, i32* %4, align 4
  %6 = load i32, i32* %3, align 4
  %7 = load i32, i32* %4, align 4
  %8 = udiv i32 %6, %7
  store i32 %8, i32* %5, align 4
  %9 = load i32, i32* %5, align 4
  ret i32 %9
}

define weak_odr dso_local i64 @_Z3divIlET_S0_S0_(i64 %0, i64 %1) #0 comdat {
; CHECK-LABEL: _Z3divIlET_S0_S0_:
; CHECK:       LBB6_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r3
; CHECK-NEXT:    feeder.64 r4
; CHECK-NEXT:    movl call_addr, __next32_sdivrem64
; CHECK-NEXT:    movl call_ret_fid, .Ltmp6
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r1
; CHECK-NEXT:    writer.64 call_addr, r2
; CHECK-NEXT:    writer.64 call_addr, r3
; CHECK-NEXT:    writer.64 call_addr, r4
; CHECK-NEXT:    movl call_ret_bb, LBB6_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB6_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp6:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.p.128 r1
; CHECK-NEXT:    feeder.p.128 r2
; CHECK-NEXT:    feeder.128 r3
; CHECK-NEXT:    feeder.128 r4
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r3
; CHECK-NEXT:    writer.64 ret_fid, r4
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  store i64 %0, i64* %3, align 8
  store i64 %1, i64* %4, align 8
  %6 = load i64, i64* %3, align 8
  %7 = load i64, i64* %4, align 8
  %8 = sdiv i64 %6, %7
  store i64 %8, i64* %5, align 8
  %9 = load i64, i64* %5, align 8
  ret i64 %9
}

define weak_odr dso_local i32 @_Z3remIiET_S0_S0_(i32 %0, i32 %1) #0 comdat {
; CHECK-LABEL: _Z3remIiET_S0_S0_:
; CHECK:       LBB7_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    feeder.32 r2
; CHECK-NEXT:    movl call_addr, __modsi3
; CHECK-NEXT:    movl call_ret_fid, .Ltmp7
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.32 call_addr, r1
; CHECK-NEXT:    writer.32 call_addr, r2
; CHECK-NEXT:    movl call_ret_bb, LBB7_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB7_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp7:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  store i32 %1, i32* %4, align 4
  %6 = load i32, i32* %3, align 4
  %7 = load i32, i32* %4, align 4
  %8 = srem i32 %6, %7
  store i32 %8, i32* %5, align 4
  %9 = load i32, i32* %5, align 4
  ret i32 %9
}

define weak_odr dso_local i64 @_Z3remIlET_S0_S0_(i64 %0, i64 %1) #0 comdat {
; CHECK-LABEL: _Z3remIlET_S0_S0_:
; CHECK:       LBB8_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r3
; CHECK-NEXT:    feeder.64 r4
; CHECK-NEXT:    movl call_addr, __next32_sdivrem64
; CHECK-NEXT:    movl call_ret_fid, .Ltmp8
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r1
; CHECK-NEXT:    writer.64 call_addr, r2
; CHECK-NEXT:    writer.64 call_addr, r3
; CHECK-NEXT:    writer.64 call_addr, r4
; CHECK-NEXT:    movl call_ret_bb, LBB8_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB8_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp8:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.128 r1
; CHECK-NEXT:    feeder.128 r2
; CHECK-NEXT:    feeder.p.128 r3
; CHECK-NEXT:    feeder.p.128 r4
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r1
; CHECK-NEXT:    writer.64 ret_fid, r2
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  store i64 %0, i64* %3, align 8
  store i64 %1, i64* %4, align 8
  %6 = load i64, i64* %3, align 8
  %7 = load i64, i64* %4, align 8
  %8 = srem i64 %6, %7
  store i64 %8, i64* %5, align 8
  %9 = load i64, i64* %5, align 8
  ret i64 %9
}

define weak_odr dso_local i64 @_Z3remImET_S0_S0_(i64 %0, i64 %1) #0 comdat {
; CHECK-LABEL: _Z3remImET_S0_S0_:
; CHECK:       LBB9_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r3
; CHECK-NEXT:    feeder.64 r4
; CHECK-NEXT:    movl call_addr, __next32_udivrem64
; CHECK-NEXT:    movl call_ret_fid, .Ltmp9
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    writer.64 call_addr, r1
; CHECK-NEXT:    writer.64 call_addr, r2
; CHECK-NEXT:    writer.64 call_addr, r3
; CHECK-NEXT:    writer.64 call_addr, r4
; CHECK-NEXT:    movl call_ret_bb, LBB9_1
; CHECK-NEXT:    chain.rn call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB9_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp9:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.128 r1
; CHECK-NEXT:    feeder.128 r2
; CHECK-NEXT:    feeder.p.128 r3
; CHECK-NEXT:    feeder.p.128 r4
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.64 ret_fid, r1
; CHECK-NEXT:    writer.64 ret_fid, r2
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  store i64 %0, i64* %3, align 8
  store i64 %1, i64* %4, align 8
  %6 = load i64, i64* %3, align 8
  %7 = load i64, i64* %4, align 8
  %8 = urem i64 %6, %7
  store i64 %8, i64* %5, align 8
  %9 = load i64, i64* %5, align 8
  ret i64 %9
}

