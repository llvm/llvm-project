; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 -mcpu=next32gen2 < %s | FileCheck %s

@arr0 = dso_local global [34 x i32] zeroinitializer, align 4
@arr1 = dso_local thread_local addrspace(273) global [34 x i32] zeroinitializer, align 4
@arr2 = dso_local addrspace(274) global [34 x i32] zeroinitializer, align 4
@arr3 = dso_local addrspace(275) global [34 x i32] zeroinitializer, align 4
@arr4 = dso_local addrspace(3) global [34 x i32] zeroinitializer, align 4

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_read_as0() #0 {
; CHECK-LABEL: test_read_as0:
; CHECK:       .Ltest_read_as0$local:
; CHECK:       .type .Ltest_read_as0$local,@function
; CHECK-NEXT:  LBB0_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, arr0 [mem_low]
; CHECK-NEXT:    movl r2, arr0 [mem_high]
; CHECK-NEXT:    memread.32.align[4] r2, r1, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %1 = load i32, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 0), align 4
  ret i32 %1
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_read_as1() #0 {
; CHECK-LABEL: test_read_as1:
; CHECK:       .Ltest_read_as1$local:
; CHECK:       .type .Ltest_read_as1$local,@function
; CHECK-NEXT:  LBB1_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl call_addr, __next32_tls_base
; CHECK-NEXT:    movl call_ret_fid, .Ltmp0
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    movl call_ret_bb, LBB1_1
; CHECK-NEXT:    chain call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB1_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    movl r3, 0x1
; CHECK-NEXT:    movl r4, arr1 [mem_low]
; CHECK-NEXT:    movl r5, 0x0
; CHECK-NEXT:    leadisp r5, r5
; CHECK-NEXT:    leascale r5, r3
; CHECK-NEXT:    leaindex r5, r4
; CHECK-NEXT:    leabase r1, r2
; CHECK-NEXT:    memread.32.align[4].tls r1, r2, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %1 = load i32, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 0), align 4
  ret i32 %1
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_read_as2() #0 {
; CHECK-LABEL: test_read_as2:
; CHECK:       .Ltest_read_as2$local:
; CHECK:       .type .Ltest_read_as2$local,@function
; CHECK-NEXT:  LBB2_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, arr2 [mem_low]
; CHECK-NEXT:    movl r2, arr2 [mem_high]
; CHECK-NEXT:    memread.32.align[4].global r2, r1, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %1 = load i32, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 0), align 4
  ret i32 %1
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_read_as3() #0 {
; CHECK-LABEL: test_read_as3:
; CHECK:       .Ltest_read_as3$local:
; CHECK:       .type .Ltest_read_as3$local,@function
; CHECK-NEXT:  LBB3_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, arr3 [mem_low]
; CHECK-NEXT:    movl r2, arr3 [mem_high]
; CHECK-NEXT:    memread.32.align[4].const r2, r1, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %1 = load i32, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 0), align 4
  ret i32 %1
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_write_as0() #1 {
; CHECK-LABEL: test_write_as0:
; CHECK:       .Ltest_write_as0$local:
; CHECK:       .type .Ltest_write_as0$local,@function
; CHECK-NEXT:  LBB4_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x1
; CHECK-NEXT:    movl r2, arr0 [mem_low]
; CHECK-NEXT:    movl r3, arr0 [mem_high]
; CHECK-NEXT:    memwrite.32.align[4] r3, r2, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 0), align 4
  ret void
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_write_as1() #1 {
; CHECK-LABEL: test_write_as1:
; CHECK:       .Ltest_write_as1$local:
; CHECK:       .type .Ltest_write_as1$local,@function
; CHECK-NEXT:  LBB5_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl call_addr, __next32_tls_base
; CHECK-NEXT:    movl call_ret_fid, .Ltmp1
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    movl call_ret_bb, LBB5_1
; CHECK-NEXT:    chain call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB5_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    movl r3, 0x1
; CHECK-NEXT:    movl r4, arr1 [mem_low]
; CHECK-NEXT:    movl r5, 0x0
; CHECK-NEXT:    leadisp r5, r5
; CHECK-NEXT:    leascale r5, r3
; CHECK-NEXT:    leaindex r5, r4
; CHECK-NEXT:    leabase r1, r2
; CHECK-NEXT:    memwrite.32.align[4].tls r1, r2, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    dup r1, tid
; CHECK-NEXT:    barrier r1, r3
; CHECK-NEXT:    dup tid, r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 0), align 4
  ret void
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_write_as2() #1 {
; CHECK-LABEL: test_write_as2:
; CHECK:       .Ltest_write_as2$local:
; CHECK:       .type .Ltest_write_as2$local,@function
; CHECK-NEXT:  LBB6_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x1
; CHECK-NEXT:    movl r2, arr2 [mem_low]
; CHECK-NEXT:    movl r3, arr2 [mem_high]
; CHECK-NEXT:    memwrite.32.align[4].global r3, r2, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 0), align 4
  ret void
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_write_as3() #1 {
; CHECK-LABEL: test_write_as3:
; CHECK:       .Ltest_write_as3$local:
; CHECK:       .type .Ltest_write_as3$local,@function
; CHECK-NEXT:  LBB7_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x1
; CHECK-NEXT:    movl r2, arr3 [mem_low]
; CHECK-NEXT:    movl r3, arr3 [mem_high]
; CHECK-NEXT:    memwrite.32.align[4].const r3, r2, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 0), align 4
  ret void
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_vread_as0() #0 {
; CHECK-LABEL: test_vread_as0:
; CHECK:       .Ltest_vread_as0$local:
; CHECK:       .type .Ltest_vread_as0$local,@function
; CHECK-NEXT:  LBB8_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x4
; CHECK-NEXT:    movl r2, 0x0
; CHECK-NEXT:    movl r3, arr0 [mem_low]
; CHECK-NEXT:    movl r4, arr0 [mem_high]
; CHECK-NEXT:    dup r5, r4
; CHECK-NEXT:    dup r6, r3
; CHECK-NEXT:    leadisp r2, r1
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r5, r6
; CHECK-NEXT:    memread.32.align[4] r5, r6, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    movl r5, 0x8
; CHECK-NEXT:    dup r6, r4
; CHECK-NEXT:    dup r7, r3
; CHECK-NEXT:    leadisp r2, r5
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r6, r7
; CHECK-NEXT:    memread.32.align[4] r6, r7, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    movl r6, 0xC
; CHECK-NEXT:    dup r7, r4
; CHECK-NEXT:    dup r8, r3
; CHECK-NEXT:    leadisp r2, r6
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r7, r8
; CHECK-NEXT:    memread.32.align[4] r7, r8, tid
; CHECK-NEXT:    memdata r2
; CHECK-NEXT:    memread.32.align[4] r4, r3, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    dup r4, tid
; CHECK-NEXT:    barrier r4, r3
; CHECK-NEXT:    barrier r4, r2
; CHECK-NEXT:    barrier r4, r5
; CHECK-NEXT:    barrier r4, r1
; CHECK-NEXT:    dup tid, r4
; CHECK-NEXT:    add r1, r3
; CHECK-NEXT:    add r1, r5
; CHECK-NEXT:    add r1, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %1 = load i32, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 0), align 4
  %2 = load i32, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 1), align 4
  %3 = add nsw i32 %2, %1
  %4 = load i32, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 2), align 4
  %5 = add nsw i32 %3, %4
  %6 = load i32, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 3), align 4
  %7 = add nsw i32 %5, %6
  ret i32 %7
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_vread_as1() #0 {
; CHECK-LABEL: test_vread_as1:
; CHECK:       .Ltest_vread_as1$local:
; CHECK:       .type .Ltest_vread_as1$local,@function
; CHECK-NEXT:  LBB9_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl call_addr, __next32_tls_base
; CHECK-NEXT:    movl call_ret_fid, .Ltmp2
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    movl call_ret_bb, LBB9_1
; CHECK-NEXT:    chain call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB9_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    movl r3, 0x1
; CHECK-NEXT:    movl r4, arr1 [mem_low]
; CHECK-NEXT:    movl r5, 0x0
; CHECK-NEXT:    leadisp r5, r5
; CHECK-NEXT:    leascale r5, r3
; CHECK-NEXT:    leaindex r5, r4
; CHECK-NEXT:    leabase r1, r2
; CHECK-NEXT:    movl r3, 0x4
; CHECK-NEXT:    dup r4, r1
; CHECK-NEXT:    dup r6, r2
; CHECK-NEXT:    leadisp r5, r3
; CHECK-NEXT:    leascale r5, r5
; CHECK-NEXT:    leaindex r5, r5
; CHECK-NEXT:    leabase r4, r6
; CHECK-NEXT:    memread.32.align[4].tls r4, r6, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    movl r4, 0x8
; CHECK-NEXT:    dup r6, r1
; CHECK-NEXT:    dup r7, r2
; CHECK-NEXT:    leadisp r5, r4
; CHECK-NEXT:    leascale r5, r5
; CHECK-NEXT:    leaindex r5, r5
; CHECK-NEXT:    leabase r6, r7
; CHECK-NEXT:    memread.32.align[4].tls r6, r7, tid
; CHECK-NEXT:    memdata r4
; CHECK-NEXT:    movl r6, 0xC
; CHECK-NEXT:    dup r7, r1
; CHECK-NEXT:    dup r8, r2
; CHECK-NEXT:    leadisp r5, r6
; CHECK-NEXT:    leascale r5, r5
; CHECK-NEXT:    leaindex r5, r5
; CHECK-NEXT:    leabase r7, r8
; CHECK-NEXT:    memread.32.align[4].tls r7, r8, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    memread.32.align[4].tls r1, r2, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r2, tid
; CHECK-NEXT:    barrier r2, r1
; CHECK-NEXT:    barrier r2, r5
; CHECK-NEXT:    barrier r2, r4
; CHECK-NEXT:    barrier r2, r3
; CHECK-NEXT:    dup tid, r2
; CHECK-NEXT:    add r3, r1
; CHECK-NEXT:    add r3, r4
; CHECK-NEXT:    add r3, r5
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r3
  %1 = load i32, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 0), align 4
  %2 = load i32, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 1), align 4
  %3 = add nsw i32 %2, %1
  %4 = load i32, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 2), align 4
  %5 = add nsw i32 %3, %4
  %6 = load i32, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 3), align 4
  %7 = add nsw i32 %5, %6
  ret i32 %7
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_vread_as2() #0 {
; CHECK-LABEL: test_vread_as2:
; CHECK:       .Ltest_vread_as2$local:
; CHECK:       .type .Ltest_vread_as2$local,@function
; CHECK-NEXT:  LBB10_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x4
; CHECK-NEXT:    movl r2, 0x0
; CHECK-NEXT:    movl r3, arr2 [mem_low]
; CHECK-NEXT:    movl r4, arr2 [mem_high]
; CHECK-NEXT:    dup r5, r4
; CHECK-NEXT:    dup r6, r3
; CHECK-NEXT:    leadisp r2, r1
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r5, r6
; CHECK-NEXT:    memread.32.align[4].global r5, r6, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    movl r5, 0x8
; CHECK-NEXT:    dup r6, r4
; CHECK-NEXT:    dup r7, r3
; CHECK-NEXT:    leadisp r2, r5
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r6, r7
; CHECK-NEXT:    memread.32.align[4].global r6, r7, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    movl r6, 0xC
; CHECK-NEXT:    dup r7, r4
; CHECK-NEXT:    dup r8, r3
; CHECK-NEXT:    leadisp r2, r6
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r7, r8
; CHECK-NEXT:    memread.32.align[4].global r7, r8, tid
; CHECK-NEXT:    memdata r2
; CHECK-NEXT:    memread.32.align[4].global r4, r3, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    dup r4, tid
; CHECK-NEXT:    barrier r4, r3
; CHECK-NEXT:    barrier r4, r2
; CHECK-NEXT:    barrier r4, r5
; CHECK-NEXT:    barrier r4, r1
; CHECK-NEXT:    dup tid, r4
; CHECK-NEXT:    add r1, r3
; CHECK-NEXT:    add r1, r5
; CHECK-NEXT:    add r1, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %1 = load i32, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 0), align 4
  %2 = load i32, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 1), align 4
  %3 = add nsw i32 %2, %1
  %4 = load i32, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 2), align 4
  %5 = add nsw i32 %3, %4
  %6 = load i32, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 3), align 4
  %7 = add nsw i32 %5, %6
  ret i32 %7
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_vread_as3() #0 {
; CHECK-LABEL: test_vread_as3:
; CHECK:       .Ltest_vread_as3$local:
; CHECK:       .type .Ltest_vread_as3$local,@function
; CHECK-NEXT:  LBB11_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x4
; CHECK-NEXT:    movl r2, 0x0
; CHECK-NEXT:    movl r3, arr3 [mem_low]
; CHECK-NEXT:    movl r4, arr3 [mem_high]
; CHECK-NEXT:    dup r5, r4
; CHECK-NEXT:    dup r6, r3
; CHECK-NEXT:    leadisp r2, r1
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r5, r6
; CHECK-NEXT:    memread.32.align[4].const r5, r6, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    movl r5, 0x8
; CHECK-NEXT:    dup r6, r4
; CHECK-NEXT:    dup r7, r3
; CHECK-NEXT:    leadisp r2, r5
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r6, r7
; CHECK-NEXT:    memread.32.align[4].const r6, r7, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    movl r6, 0xC
; CHECK-NEXT:    dup r7, r4
; CHECK-NEXT:    dup r8, r3
; CHECK-NEXT:    leadisp r2, r6
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r7, r8
; CHECK-NEXT:    memread.32.align[4].const r7, r8, tid
; CHECK-NEXT:    memdata r2
; CHECK-NEXT:    memread.32.align[4].const r4, r3, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    dup r4, tid
; CHECK-NEXT:    barrier r4, r3
; CHECK-NEXT:    barrier r4, r2
; CHECK-NEXT:    barrier r4, r5
; CHECK-NEXT:    barrier r4, r1
; CHECK-NEXT:    dup tid, r4
; CHECK-NEXT:    add r1, r3
; CHECK-NEXT:    add r1, r5
; CHECK-NEXT:    add r1, r2
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r1
  %1 = load i32, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 0), align 4
  %2 = load i32, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 1), align 4
  %3 = add nsw i32 %2, %1
  %4 = load i32, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 2), align 4
  %5 = add nsw i32 %3, %4
  %6 = load i32, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 3), align 4
  %7 = add nsw i32 %5, %6
  ret i32 %7
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_vwrite_as0() #1 {
; CHECK-LABEL: test_vwrite_as0:
; CHECK:       .Ltest_vwrite_as0$local:
; CHECK:       .type .Ltest_vwrite_as0$local,@function
; CHECK-NEXT:  LBB12_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x4
; CHECK-NEXT:    movl r2, 0x0
; CHECK-NEXT:    movl r3, arr0 [mem_low]
; CHECK-NEXT:    movl r4, arr0 [mem_high]
; CHECK-NEXT:    dup r5, r4
; CHECK-NEXT:    dup r6, r3
; CHECK-NEXT:    leadisp r2, r1
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r5, r6
; CHECK-NEXT:    movl r1, 0x1
; CHECK-NEXT:    dup r7, r1
; CHECK-NEXT:    memwrite.32.align[4] r5, r6, tid
; CHECK-NEXT:    memdata r7
; CHECK-NEXT:    movl r5, 0x8
; CHECK-NEXT:    dup r6, r4
; CHECK-NEXT:    dup r8, r3
; CHECK-NEXT:    leadisp r2, r5
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r6, r8
; CHECK-NEXT:    dup r5, r1
; CHECK-NEXT:    memwrite.32.align[4] r6, r8, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    movl r6, 0xC
; CHECK-NEXT:    dup r8, r4
; CHECK-NEXT:    dup r9, r3
; CHECK-NEXT:    leadisp r2, r6
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r8, r9
; CHECK-NEXT:    dup r2, r1
; CHECK-NEXT:    memwrite.32.align[4] r8, r9, tid
; CHECK-NEXT:    memdata r2
; CHECK-NEXT:    memwrite.32.align[4] r4, r3, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r3, tid
; CHECK-NEXT:    barrier r3, r1
; CHECK-NEXT:    barrier r3, r2
; CHECK-NEXT:    barrier r3, r5
; CHECK-NEXT:    barrier r3, r7
; CHECK-NEXT:    dup tid, r3
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 0), align 4
  store i32 1, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 1), align 4
  store i32 1, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 2), align 4
  store i32 1, i32* getelementptr inbounds ([34 x i32], [34 x i32]* @arr0, i64 0, i64 3), align 4
  ret void
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_vwrite_as1() #1 {
; CHECK-LABEL: test_vwrite_as1:
; CHECK:       .Ltest_vwrite_as1$local:
; CHECK:       .type .Ltest_vwrite_as1$local,@function
; CHECK-NEXT:  LBB13_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl call_addr, __next32_tls_base
; CHECK-NEXT:    movl call_ret_fid, .Ltmp3
; CHECK-NEXT:    chain call_addr, 0x64
; CHECK-NEXT:    writer.32 call_addr, tid
; CHECK-NEXT:    writer.32 call_addr, call_ret_fid
; CHECK-NEXT:    movl call_ret_bb, LBB13_1
; CHECK-NEXT:    chain call_ret_bb, 0x64
; CHECK-NEXT:    writer.32 call_ret_bb, tid
; CHECK-NEXT:    writer.32 call_ret_bb, ret_fid
; CHECK-NEXT:  LBB13_1:
; CHECK-NEXT:    feeder.p.32 tid
; CHECK-NEXT:    feeder.p.32 ret_fid
; CHECK-NEXT:  .Ltmp3:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    movl r3, 0x1
; CHECK-NEXT:    movl r4, arr1 [mem_low]
; CHECK-NEXT:    movl r5, 0x0
; CHECK-NEXT:    leadisp r5, r5
; CHECK-NEXT:    leascale r5, r3
; CHECK-NEXT:    leaindex r5, r4
; CHECK-NEXT:    leabase r1, r2
; CHECK-NEXT:    movl r4, 0x4
; CHECK-NEXT:    dup r6, r1
; CHECK-NEXT:    dup r7, r2
; CHECK-NEXT:    leadisp r5, r4
; CHECK-NEXT:    leascale r5, r5
; CHECK-NEXT:    leaindex r5, r5
; CHECK-NEXT:    leabase r6, r7
; CHECK-NEXT:    dup r4, r3
; CHECK-NEXT:    memwrite.32.align[4].tls r6, r7, tid
; CHECK-NEXT:    memdata r4
; CHECK-NEXT:    movl r6, 0x8
; CHECK-NEXT:    dup r7, r1
; CHECK-NEXT:    dup r8, r2
; CHECK-NEXT:    leadisp r5, r6
; CHECK-NEXT:    leascale r5, r5
; CHECK-NEXT:    leaindex r5, r5
; CHECK-NEXT:    leabase r7, r8
; CHECK-NEXT:    dup r6, r3
; CHECK-NEXT:    memwrite.32.align[4].tls r7, r8, tid
; CHECK-NEXT:    memdata r6
; CHECK-NEXT:    movl r7, 0xC
; CHECK-NEXT:    dup r8, r1
; CHECK-NEXT:    dup r9, r2
; CHECK-NEXT:    leadisp r5, r7
; CHECK-NEXT:    leascale r5, r5
; CHECK-NEXT:    leaindex r5, r5
; CHECK-NEXT:    leabase r8, r9
; CHECK-NEXT:    dup r5, r3
; CHECK-NEXT:    memwrite.32.align[4].tls r8, r9, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    memwrite.32.align[4].tls r1, r2, tid
; CHECK-NEXT:    memdata r3
; CHECK-NEXT:    dup r1, tid
; CHECK-NEXT:    barrier r1, r3
; CHECK-NEXT:    barrier r1, r5
; CHECK-NEXT:    barrier r1, r6
; CHECK-NEXT:    barrier r1, r4
; CHECK-NEXT:    dup tid, r1
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 0), align 4
  store i32 1, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 1), align 4
  store i32 1, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 2), align 4
  store i32 1, i32 addrspace(273)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(273)* @arr1, i64 0, i64 3), align 4
  ret void
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_vwrite_as2() #1 {
; CHECK-LABEL: test_vwrite_as2:
; CHECK:       .Ltest_vwrite_as2$local:
; CHECK:       .type .Ltest_vwrite_as2$local,@function
; CHECK-NEXT:  LBB14_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x4
; CHECK-NEXT:    movl r2, 0x0
; CHECK-NEXT:    movl r3, arr2 [mem_low]
; CHECK-NEXT:    movl r4, arr2 [mem_high]
; CHECK-NEXT:    dup r5, r4
; CHECK-NEXT:    dup r6, r3
; CHECK-NEXT:    leadisp r2, r1
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r5, r6
; CHECK-NEXT:    movl r1, 0x1
; CHECK-NEXT:    dup r7, r1
; CHECK-NEXT:    memwrite.32.align[4].global r5, r6, tid
; CHECK-NEXT:    memdata r7
; CHECK-NEXT:    movl r5, 0x8
; CHECK-NEXT:    dup r6, r4
; CHECK-NEXT:    dup r8, r3
; CHECK-NEXT:    leadisp r2, r5
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r6, r8
; CHECK-NEXT:    dup r5, r1
; CHECK-NEXT:    memwrite.32.align[4].global r6, r8, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    movl r6, 0xC
; CHECK-NEXT:    dup r8, r4
; CHECK-NEXT:    dup r9, r3
; CHECK-NEXT:    leadisp r2, r6
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r8, r9
; CHECK-NEXT:    dup r2, r1
; CHECK-NEXT:    memwrite.32.align[4].global r8, r9, tid
; CHECK-NEXT:    memdata r2
; CHECK-NEXT:    memwrite.32.align[4].global r4, r3, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r3, tid
; CHECK-NEXT:    barrier r3, r1
; CHECK-NEXT:    barrier r3, r2
; CHECK-NEXT:    barrier r3, r5
; CHECK-NEXT:    barrier r3, r7
; CHECK-NEXT:    dup tid, r3
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 0), align 4
  store i32 1, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 1), align 4
  store i32 1, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 2), align 4
  store i32 1, i32 addrspace(274)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(274)* @arr2, i64 0, i64 3), align 4
  ret void
}

; Function Attrs: nofree norecurse nounwind willreturn writeonly
define dso_local void @test_vwrite_as3() #1 {
; CHECK-LABEL: test_vwrite_as3:
; CHECK:       .Ltest_vwrite_as3$local:
; CHECK:       .type .Ltest_vwrite_as3$local,@function
; CHECK-NEXT:  LBB15_0:
; CHECK-NEXT:  # %bb.0:
; CHECK-NEXT:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    movl r1, 0x4
; CHECK-NEXT:    movl r2, 0x0
; CHECK-NEXT:    movl r3, arr3 [mem_low]
; CHECK-NEXT:    movl r4, arr3 [mem_high]
; CHECK-NEXT:    dup r5, r4
; CHECK-NEXT:    dup r6, r3
; CHECK-NEXT:    leadisp r2, r1
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r5, r6
; CHECK-NEXT:    movl r1, 0x1
; CHECK-NEXT:    dup r7, r1
; CHECK-NEXT:    memwrite.32.align[4].const r5, r6, tid
; CHECK-NEXT:    memdata r7
; CHECK-NEXT:    movl r5, 0x8
; CHECK-NEXT:    dup r6, r4
; CHECK-NEXT:    dup r8, r3
; CHECK-NEXT:    leadisp r2, r5
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r6, r8
; CHECK-NEXT:    dup r5, r1
; CHECK-NEXT:    memwrite.32.align[4].const r6, r8, tid
; CHECK-NEXT:    memdata r5
; CHECK-NEXT:    movl r6, 0xC
; CHECK-NEXT:    dup r8, r4
; CHECK-NEXT:    dup r9, r3
; CHECK-NEXT:    leadisp r2, r6
; CHECK-NEXT:    leascale r2, r2
; CHECK-NEXT:    leaindex r2, r2
; CHECK-NEXT:    leabase r8, r9
; CHECK-NEXT:    dup r2, r1
; CHECK-NEXT:    memwrite.32.align[4].const r8, r9, tid
; CHECK-NEXT:    memdata r2
; CHECK-NEXT:    memwrite.32.align[4].const r4, r3, tid
; CHECK-NEXT:    memdata r1
; CHECK-NEXT:    dup r3, tid
; CHECK-NEXT:    barrier r3, r1
; CHECK-NEXT:    barrier r3, r2
; CHECK-NEXT:    barrier r3, r5
; CHECK-NEXT:    barrier r3, r7
; CHECK-NEXT:    dup tid, r3
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
  store i32 1, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 0), align 4
  store i32 1, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 1), align 4
  store i32 1, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 2), align 4
  store i32 1, i32 addrspace(275)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(275)* @arr3, i64 0, i64 3), align 4
  ret void
}

; Function Attrs: norecurse nounwind readonly willreturn
define dso_local i32 @test_read_as4() #0 {
; CHECK-LABEL: test_read_as4:
; CHECK:       .Ltest_read_as4$local:
; CHECK:       .type .Ltest_read_as4$local,@function
; CHECK-NEXT:    LBB16_0:
; CHECK-NEXT:    # %bb.0:
; CHECK-NEXT:            feeder.32       tid
; CHECK-NEXT:            feeder.32       ret_fid
; CHECK-NEXT:            movl    r1, arr4 [mem_low]
; CHECK-NEXT:            movl    r2, arr4 [mem_high]
; CHECK-NEXT:            memread.32.align[4].local       r2, r1, tid
; CHECK-NEXT:            memdata r1
; CHECK-NEXT:            dup     r2, tid
; CHECK-NEXT:            barrier r2, r1
; CHECK-NEXT:            dup     tid, r2
; CHECK-NEXT:            chain   ret_fid, 0x64
; CHECK-NEXT:            writer.32       ret_fid, tid
; CHECK-NEXT:            writer.32       ret_fid, r1
; CHECK-NEXT:    .Lfunc_end16:
  %1 = load i32, i32 addrspace(3)* getelementptr inbounds ([34 x i32], [34 x i32] addrspace(3)* @arr4, i64 0, i64 0), align 4
  ret i32 %1
}
