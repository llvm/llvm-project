; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 -mattr=+lea < %s | FileCheck %s --check-prefix=HAS-LEA
; RUN: llc -mtriple=next32 -mattr=-lea < %s | FileCheck %s --check-prefix=NO-LEA

; Original C source:
; typedef struct {
;   int x;
;   int y;
; } Point;
;
; void foo(int *a, int *b);
;
; int test1(Point* p, int idx) {
;   return p[idx].x;
; }
;
; int test2(Point* p, int idx) {
;   return p[idx].y;
; }
;
; int test3(int* a) {
;   return a[1];
; }
;
; int test4(int *a, int *idx, int i) {
;   return a[idx[i]];
; }
;
; int test5() {
;   int a[100];
;   int b[100];
;   foo(a, b);
;   return b[4];
; }
;
; int64_t test6(int64_t a, int64_t b) {
;   return a + b;
; }
;
; int64_t test7(int64_t a, int64_t b, int64_t c) {
;   return a + b + c;
; }
;
; int64_t test8(int64_t a) {
;   return a << 3;
; }
;
; int64_t test9(int64_t a, int64_t b) {
;   return a + (b << 2);
; }
;
; int64_t test10(int64_t a, int64_t b) {
;   return (a << 1) + (b << 2);
; }
;
; int64_t test11(int64_t a) {
;   return a << 6;
; }
;
; int64_t test12(int64_t a) {
;   return 2 * a + 1;
; }
;
; int64_t test13(int64_t a, int64_t b) {
;   return (a << 1) | (b & 1);
; }
;
; int64_t test14(int64_t a, int64_t b) {
;   return (a << 3) | (b & 8);
; }
;
; int32_t test15(int64_t a, int64_t b) {
;   return a + b;
; }
;
; uint64_t test16(uint64_t a, uint64_t b) {
;   uint64_t hi = a & 0xffffffff00000000;
;   uint64_t lo = b & 0x00000000ffffffff;
;   return hi + lo;
; }
;
; uint64_t test17(uint32_t a) {
;   uint64_t ret = a + 4;
;   return ret << 3;
; }
;
; uint64_t test18(uint64_t a) {
;   return (a + 1) & 0xFFFFFFFF;
; }
;
; uint64_t test19(uint64_t a, uint64_t b) {
;   return (a + b) << 32;
; }
;
; int64_t test20(int64_t a, int64_t b) {
;   return ((a + b) << 32) >> 32;
; }
;
; int64_t test21(int64_t a) {
;     return a * 25;
; }
;
; uint64_t test22(uint64_t a) {
;     return a * 26;
; }
;
; int64_t test23(int64_t a, int64_t b) {
;     return a * b;
; }
;
; uint64_t test24(uint64_t a, uint64_t b) {
;     return a * b;
; }
;
; int64_t test25(int32_t a, int64_t b) {
;     return a * b;
; }
;
; uint64_t test26(uint32_t a, uint64_t b) {
;     return a * b;
; }
;
; int64_t test27(uint32_t a, int64_t b) {
;     return a * b;
; }
;
; uint64_t test28(uint64_t a, int32_t b) {
;     return a * b;
; }

%struct.Point = type { i32, i32 }

define i32 @test1(%struct.Point* nocapture readonly %p, i32 %idx) {
; HAS-LEA-LABEL: test1:
; HAS-LEA:       LBB0_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    movl r4, 0x1F
; HAS-LEA-NEXT:    dup r5, r3
; HAS-LEA-NEXT:    shri r5, r4
; HAS-LEA-NEXT:    movl r4, 0x8
; HAS-LEA-NEXT:    movl r6, 0x0
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r6, r4
; HAS-LEA-NEXT:    leaindex r5, r3
; HAS-LEA-NEXT:    leabase r2, r1
; HAS-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; HAS-LEA-NEXT:    memdata r1
; HAS-LEA-NEXT:    dup r2, tid
; HAS-LEA-NEXT:    barrier r2, r1
; HAS-LEA-NEXT:    dup tid, r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r1
;
; NO-LEA-LABEL: test1:
; NO-LEA:       LBB0_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    movl r4, 0x1F
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    shri r5, r4
; NO-LEA-NEXT:    movl r4, 0x3
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp0
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.64 call_addr, r5
; NO-LEA-NEXT:    writer.32 call_addr, r4
; NO-LEA-NEXT:    movl call_ret_bb, LBB0_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:  LBB0_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:  .Ltmp0:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    add r1, r3
; NO-LEA-NEXT:    dup r3, r1
; NO-LEA-NEXT:    flags r3
; NO-LEA-NEXT:    adc r2, r4 [r3]
; NO-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; NO-LEA-NEXT:    memdata r1
; NO-LEA-NEXT:    dup r2, tid
; NO-LEA-NEXT:    barrier r2, r1
; NO-LEA-NEXT:    dup tid, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r1
entry:
  %idxprom = sext i32 %idx to i64
  %x = getelementptr inbounds %struct.Point, %struct.Point* %p, i64 %idxprom, i32 0
  %0 = load i32, i32* %x, align 4
  ret i32 %0
}

define i32 @test2(%struct.Point* nocapture readonly %p, i32 %idx) {
; HAS-LEA-LABEL: test2:
; HAS-LEA:       LBB1_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    movl r4, 0x1F
; HAS-LEA-NEXT:    dup r5, r3
; HAS-LEA-NEXT:    shri r5, r4
; HAS-LEA-NEXT:    movl r4, 0x4
; HAS-LEA-NEXT:    movl r6, 0x8
; HAS-LEA-NEXT:    movl r7, 0x0
; HAS-LEA-NEXT:    leadisp r7, r4
; HAS-LEA-NEXT:    leascale r7, r6
; HAS-LEA-NEXT:    leaindex r5, r3
; HAS-LEA-NEXT:    leabase r2, r1
; HAS-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; HAS-LEA-NEXT:    memdata r1
; HAS-LEA-NEXT:    dup r2, tid
; HAS-LEA-NEXT:    barrier r2, r1
; HAS-LEA-NEXT:    dup tid, r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r1
;
; NO-LEA-LABEL: test2:
; NO-LEA:       LBB1_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    movl r4, 0x1F
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    shri r5, r4
; NO-LEA-NEXT:    movl r4, 0x3
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp1
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.64 call_addr, r5
; NO-LEA-NEXT:    writer.32 call_addr, r4
; NO-LEA-NEXT:    movl call_ret_bb, LBB1_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:  LBB1_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:  .Ltmp1:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    add r1, r3
; NO-LEA-NEXT:    dup r3, r1
; NO-LEA-NEXT:    flags r3
; NO-LEA-NEXT:    adc r2, r4 [r3]
; NO-LEA-NEXT:    movl r3, 0x4
; NO-LEA-NEXT:    add r1, r3
; NO-LEA-NEXT:    dup r3, r1
; NO-LEA-NEXT:    flags r3
; NO-LEA-NEXT:    movl r4, 0x0
; NO-LEA-NEXT:    adc r2, r4 [r3]
; NO-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; NO-LEA-NEXT:    memdata r1
; NO-LEA-NEXT:    dup r2, tid
; NO-LEA-NEXT:    barrier r2, r1
; NO-LEA-NEXT:    dup tid, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r1
entry:
  %idxprom = sext i32 %idx to i64
  %y = getelementptr inbounds %struct.Point, %struct.Point* %p, i64 %idxprom, i32 1
  %0 = load i32, i32* %y, align 4
  ret i32 %0
}

define i32 @test3(i32* nocapture readonly %a) {
; HAS-LEA-LABEL: test3:
; HAS-LEA:       LBB2_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r3, 0x4
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    leadisp r4, r3
; HAS-LEA-NEXT:    leascale r4, r4
; HAS-LEA-NEXT:    leaindex r4, r4
; HAS-LEA-NEXT:    leabase r2, r1
; HAS-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; HAS-LEA-NEXT:    memdata r1
; HAS-LEA-NEXT:    dup r2, tid
; HAS-LEA-NEXT:    barrier r2, r1
; HAS-LEA-NEXT:    dup tid, r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r1
;
; NO-LEA-LABEL: test3:
; NO-LEA:       LBB2_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r3, 0x4
; NO-LEA-NEXT:    add r1, r3
; NO-LEA-NEXT:    dup r3, r1
; NO-LEA-NEXT:    flags r3
; NO-LEA-NEXT:    movl r4, 0x0
; NO-LEA-NEXT:    adc r2, r4 [r3]
; NO-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; NO-LEA-NEXT:    memdata r1
; NO-LEA-NEXT:    dup r2, tid
; NO-LEA-NEXT:    barrier r2, r1
; NO-LEA-NEXT:    dup tid, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r1
entry:
  %arrayidx = getelementptr inbounds i32, i32* %a, i64 1
  %0 = load i32, i32* %arrayidx, align 4
  ret i32 %0
}

define i32 @test4(i32* nocapture readonly %a, i32* nocapture readonly %idx, i32 %i) {
; HAS-LEA-LABEL: test4:
; HAS-LEA:       LBB3_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    feeder.32 r5
; HAS-LEA-NEXT:    movl r6, 0x1F
; HAS-LEA-NEXT:    dup r7, r5
; HAS-LEA-NEXT:    shri r7, r6
; HAS-LEA-NEXT:    movl r8, 0x4
; HAS-LEA-NEXT:    movl r9, 0x0
; HAS-LEA-NEXT:    leadisp r9, r9
; HAS-LEA-NEXT:    leascale r9, r8
; HAS-LEA-NEXT:    leaindex r7, r5
; HAS-LEA-NEXT:    leabase r4, r3
; HAS-LEA-NEXT:    memread.32.align[4] r4, r3, tid
; HAS-LEA-NEXT:    memdata r3
; HAS-LEA-NEXT:    dup r4, r3
; HAS-LEA-NEXT:    shri r4, r6
; HAS-LEA-NEXT:    leadisp r9, r9
; HAS-LEA-NEXT:    leascale r9, r8
; HAS-LEA-NEXT:    leaindex r4, r3
; HAS-LEA-NEXT:    leabase r2, r1
; HAS-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; HAS-LEA-NEXT:    memdata r1
; HAS-LEA-NEXT:    dup r2, tid
; HAS-LEA-NEXT:    barrier r2, r3
; HAS-LEA-NEXT:    barrier r2, r1
; HAS-LEA-NEXT:    dup tid, r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r1
;
; NO-LEA-LABEL: test4:
; NO-LEA:       LBB3_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    feeder.32 r5
; NO-LEA-NEXT:    movl r6, 0x1F
; NO-LEA-NEXT:    dup r8, r5
; NO-LEA-NEXT:    shri r8, r6
; NO-LEA-NEXT:    movl r7, 0x2
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp2
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r5
; NO-LEA-NEXT:    writer.64 call_addr, r8
; NO-LEA-NEXT:    writer.32 call_addr, r7
; NO-LEA-NEXT:    movl call_ret_bb, LBB3_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:    writer.32 call_ret_bb, r6
; NO-LEA-NEXT:    writer.32 call_ret_bb, r7
; NO-LEA-NEXT:  LBB3_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:    feeder.p.32 r6
; NO-LEA-NEXT:    feeder.p.32 r7
; NO-LEA-NEXT:  .Ltmp2:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r5
; NO-LEA-NEXT:    feeder.64 r8
; NO-LEA-NEXT:    add r3, r5
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    flags r5
; NO-LEA-NEXT:    adc r4, r8 [r5]
; NO-LEA-NEXT:    memread.32.align[4] r4, r3, tid
; NO-LEA-NEXT:    memdata r3
; NO-LEA-NEXT:    dup r4, r3
; NO-LEA-NEXT:    shri r4, r6
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp3
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.64 call_addr, r4
; NO-LEA-NEXT:    writer.32 call_addr, r7
; NO-LEA-NEXT:    movl call_ret_bb, LBB3_2
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:  LBB3_2: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:  .Ltmp3:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    feeder.64 r5
; NO-LEA-NEXT:    add r1, r4
; NO-LEA-NEXT:    dup r4, r1
; NO-LEA-NEXT:    flags r4
; NO-LEA-NEXT:    adc r2, r5 [r4]
; NO-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; NO-LEA-NEXT:    memdata r1
; NO-LEA-NEXT:    dup r2, tid
; NO-LEA-NEXT:    barrier r2, r3
; NO-LEA-NEXT:    barrier r2, r1
; NO-LEA-NEXT:    dup tid, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r1
entry:
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds i32, i32* %idx, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %a, i64 %idxprom1
  %1 = load i32, i32* %arrayidx2, align 4
  ret i32 %1
}

define i32 @test5() {
; HAS-LEA-LABEL: test5:
; HAS-LEA:       LBB4_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    movl stack_size, 0x320
; HAS-LEA-NEXT:    setframe sp_high, sp_low, stack_size, tid
; HAS-LEA-NEXT:    barrier tid, stack_size
; HAS-LEA-NEXT:    dup r1, sp_low
; HAS-LEA-NEXT:    dup r2, sp_high
; HAS-LEA-NEXT:    movl r3, 0x0
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    movl r5, 0x190
; HAS-LEA-NEXT:    dup r6, r2
; HAS-LEA-NEXT:    dup r7, r1
; HAS-LEA-NEXT:    leadisp r4, r5
; HAS-LEA-NEXT:    leascale r3, r3
; HAS-LEA-NEXT:    leaindex r3, r3
; HAS-LEA-NEXT:    leabase r6, r7
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r8, r2
; HAS-LEA-NEXT:    dup r9, r1
; HAS-LEA-NEXT:    leadisp r4, r5
; HAS-LEA-NEXT:    leascale r3, r3
; HAS-LEA-NEXT:    leaindex r3, r3
; HAS-LEA-NEXT:    leabase r8, r9
; HAS-LEA-NEXT:    movl call_addr, foo
; HAS-LEA-NEXT:    movl call_ret_fid, .Ltmp0
; HAS-LEA-NEXT:    chain call_addr, 0x64
; HAS-LEA-NEXT:    writer.32 call_addr, tid
; HAS-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; HAS-LEA-NEXT:    writer.64 call_addr, r9
; HAS-LEA-NEXT:    writer.64 call_addr, r8
; HAS-LEA-NEXT:    writer.64 call_addr, r7
; HAS-LEA-NEXT:    writer.64 call_addr, r6
; HAS-LEA-NEXT:    movl call_ret_bb, LBB4_1
; HAS-LEA-NEXT:    chain call_ret_bb, 0x64
; HAS-LEA-NEXT:    writer.32 call_ret_bb, tid
; HAS-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; HAS-LEA-NEXT:    writer.32 call_ret_bb, r1
; HAS-LEA-NEXT:    writer.32 call_ret_bb, r2
; HAS-LEA-NEXT:    writer.32 call_ret_bb, r3
; HAS-LEA-NEXT:    writer.32 call_ret_bb, sp_high
; HAS-LEA-NEXT:    writer.32 call_ret_bb, sp_low
; HAS-LEA-NEXT:  LBB4_1: # %entry
; HAS-LEA-NEXT:    feeder.p.32 tid
; HAS-LEA-NEXT:    feeder.p.32 ret_fid
; HAS-LEA-NEXT:    feeder.p.32 r1
; HAS-LEA-NEXT:    feeder.p.32 r2
; HAS-LEA-NEXT:    feeder.p.32 r3
; HAS-LEA-NEXT:    feeder.p.32 sp_high
; HAS-LEA-NEXT:    feeder.p.32 sp_low
; HAS-LEA-NEXT:  .Ltmp0:
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    movl r5, 0x1A0
; HAS-LEA-NEXT:    leadisp r4, r5
; HAS-LEA-NEXT:    leascale r3, r3
; HAS-LEA-NEXT:    leaindex r3, r3
; HAS-LEA-NEXT:    leabase r2, r1
; HAS-LEA-NEXT:    memread.32.align[4] r2, r1, tid
; HAS-LEA-NEXT:    memdata r1
; HAS-LEA-NEXT:    dup r2, tid
; HAS-LEA-NEXT:    barrier r2, r1
; HAS-LEA-NEXT:    dup tid, r2
; HAS-LEA-NEXT:    resetframe sp_high, sp_low, tid
; HAS-LEA-NEXT:    barrier tid, sp_high
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r1
;
; NO-LEA-LABEL: test5:
; NO-LEA:       LBB4_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    movl stack_size, 0x320
; NO-LEA-NEXT:    setframe sp_high, sp_low, stack_size, tid
; NO-LEA-NEXT:    barrier tid, stack_size
; NO-LEA-NEXT:    dup r1, sp_high
; NO-LEA-NEXT:    dup r2, sp_low
; NO-LEA-NEXT:    movl r3, 0x0
; NO-LEA-NEXT:    movl r4, 0x190
; NO-LEA-NEXT:    dup r5, r2
; NO-LEA-NEXT:    add r5, r4
; NO-LEA-NEXT:    dup r4, r5
; NO-LEA-NEXT:    flags r4
; NO-LEA-NEXT:    dup r6, r1
; NO-LEA-NEXT:    adc r6, r3 [r4]
; NO-LEA-NEXT:    movl r3, 0x0
; NO-LEA-NEXT:    movl r4, 0x0
; NO-LEA-NEXT:    dup r7, r2
; NO-LEA-NEXT:    add r7, r4
; NO-LEA-NEXT:    dup r4, r7
; NO-LEA-NEXT:    flags r4
; NO-LEA-NEXT:    dup r8, r1
; NO-LEA-NEXT:    adc r8, r3 [r4]
; NO-LEA-NEXT:    movl call_addr, foo
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp4
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r7
; NO-LEA-NEXT:    writer.64 call_addr, r8
; NO-LEA-NEXT:    writer.64 call_addr, r5
; NO-LEA-NEXT:    writer.64 call_addr, r6
; NO-LEA-NEXT:    movl call_ret_bb, LBB4_1
; NO-LEA-NEXT:    chain call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:    writer.32 call_ret_bb, sp_high
; NO-LEA-NEXT:    writer.32 call_ret_bb, sp_low
; NO-LEA-NEXT:  LBB4_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:    feeder.p.32 sp_high
; NO-LEA-NEXT:    feeder.p.32 sp_low
; NO-LEA-NEXT:  .Ltmp4:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    movl r3, 0x0
; NO-LEA-NEXT:    movl r4, 0x1A0
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    dup r4, r2
; NO-LEA-NEXT:    flags r4
; NO-LEA-NEXT:    adc r1, r3 [r4]
; NO-LEA-NEXT:    memread.32.align[4] r1, r2, tid
; NO-LEA-NEXT:    memdata r1
; NO-LEA-NEXT:    dup r2, tid
; NO-LEA-NEXT:    barrier r2, r1
; NO-LEA-NEXT:    dup tid, r2
; NO-LEA-NEXT:    resetframe sp_high, sp_low, tid
; NO-LEA-NEXT:    barrier tid, sp_high
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r1
entry:
  %a = alloca [100 x i32], align 4
  %b = alloca [100 x i32], align 4
  %0 = bitcast [100 x i32]* %a to i8*
  call void @llvm.lifetime.start.p0i8(i64 400, i8* nonnull %0)
  %1 = bitcast [100 x i32]* %b to i8*
  call void @llvm.lifetime.start.p0i8(i64 400, i8* nonnull %1)
  %arraydecay = getelementptr inbounds [100 x i32], [100 x i32]* %a, i64 0, i64 0
  %arraydecay1 = getelementptr inbounds [100 x i32], [100 x i32]* %b, i64 0, i64 0
  call void @foo(i32* nonnull %arraydecay, i32* nonnull %arraydecay1)
  %arrayidx = getelementptr inbounds [100 x i32], [100 x i32]* %b, i64 0, i64 4
  %2 = load i32, i32* %arrayidx, align 4
  call void @llvm.lifetime.end.p0i8(i64 400, i8* nonnull %1)
  call void @llvm.lifetime.end.p0i8(i64 400, i8* nonnull %0)
  ret i32 %2
}

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)

declare void @foo(i32*, i32*)

declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

define i64 @test6(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test6:
; HAS-LEA:       LBB5_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r5, 0x1
; HAS-LEA-NEXT:    movl r6, 0x0
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r6, r5
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r4, r3
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test6:
; NO-LEA:       LBB5_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    flags r1
; NO-LEA-NEXT:    adc r4, r2 [r1]
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r4
entry:
  %add = add nsw i64 %b, %a
  ret i64 %add
}

define i64 @test7(i64 %a, i64 %b, i64 %c) {
; HAS-LEA-LABEL: test7:
; HAS-LEA:       LBB6_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    feeder.64 r5
; HAS-LEA-NEXT:    feeder.64 r6
; HAS-LEA-NEXT:    movl r7, 0x1
; HAS-LEA-NEXT:    movl r8, 0x0
; HAS-LEA-NEXT:    leadisp r8, r8
; HAS-LEA-NEXT:    leascale r8, r7
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r4, r3
; HAS-LEA-NEXT:    leadisp r8, r8
; HAS-LEA-NEXT:    leascale r8, r7
; HAS-LEA-NEXT:    leaindex r4, r3
; HAS-LEA-NEXT:    leabase r6, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
;
; NO-LEA-LABEL: test7:
; NO-LEA:       LBB6_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    feeder.64 r5
; NO-LEA-NEXT:    feeder.64 r6
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    flags r1
; NO-LEA-NEXT:    adc r4, r2 [r1]
; NO-LEA-NEXT:    add r3, r5
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    flags r1
; NO-LEA-NEXT:    adc r4, r6 [r1]
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r4
entry:
  %add = add nsw i64 %b, %a
  %add1 = add nsw i64 %add, %c
  ret i64 %add1
}

define i64 @test8(i64 %a) {
; HAS-LEA-LABEL: test8:
; HAS-LEA:       LBB7_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r3, 0x8
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r3
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test8:
; NO-LEA:       LBB7_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r3, 0x3
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp5
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r1
; NO-LEA-NEXT:    writer.64 call_addr, r2
; NO-LEA-NEXT:    writer.32 call_addr, r3
; NO-LEA-NEXT:    movl call_ret_bb, LBB7_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:  LBB7_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:  .Ltmp5:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %shl = shl i64 %a, 3
  ret i64 %shl
}

define i64 @test9(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test9:
; HAS-LEA:       LBB8_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r5, 0x4
; HAS-LEA-NEXT:    movl r6, 0x0
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r6, r5
; HAS-LEA-NEXT:    leaindex r4, r3
; HAS-LEA-NEXT:    leabase r2, r1
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
;
; NO-LEA-LABEL: test9:
; NO-LEA:       LBB8_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r5, 0x2
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp6
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.64 call_addr, r4
; NO-LEA-NEXT:    writer.32 call_addr, r5
; NO-LEA-NEXT:    movl call_ret_bb, LBB8_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:  LBB8_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:  .Ltmp6:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    flags r1
; NO-LEA-NEXT:    adc r4, r2 [r1]
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r4
entry:
  %shl = shl i64 %b, 2
  %add = add nsw i64 %shl, %a
  ret i64 %add
}

define i64 @test10(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test10:
; HAS-LEA:       LBB9_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r5, 0x2
; HAS-LEA-NEXT:    movl r6, 0x0
; HAS-LEA-NEXT:    dup r7, r6
; HAS-LEA-NEXT:    dup r8, r6
; HAS-LEA-NEXT:    leadisp r8, r8
; HAS-LEA-NEXT:    leascale r8, r5
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r7, r8
; HAS-LEA-NEXT:    movl r1, 0x4
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r6, r1
; HAS-LEA-NEXT:    leaindex r4, r3
; HAS-LEA-NEXT:    leabase r7, r8
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r8
; HAS-LEA-NEXT:    writer.64 ret_fid, r7
;
; NO-LEA-LABEL: test10:
; NO-LEA:       LBB9_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r5, 0x2
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp7
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.64 call_addr, r4
; NO-LEA-NEXT:    writer.32 call_addr, r5
; NO-LEA-NEXT:    movl call_ret_bb, LBB9_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r1
; NO-LEA-NEXT:    writer.32 call_ret_bb, r2
; NO-LEA-NEXT:  LBB9_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r1
; NO-LEA-NEXT:    feeder.p.32 r2
; NO-LEA-NEXT:  .Ltmp7:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.p.64 r3
; NO-LEA-NEXT:    feeder.p.64 r4
; NO-LEA-NEXT:    movl r5, 0x1
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp8
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r1
; NO-LEA-NEXT:    writer.64 call_addr, r2
; NO-LEA-NEXT:    writer.32 call_addr, r5
; NO-LEA-NEXT:    movl call_ret_bb, LBB9_2
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:  LBB9_2: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:  .Ltmp8:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    flags r1
; NO-LEA-NEXT:    adc r4, r2 [r1]
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r4
entry:
  %shl = shl i64 %a, 1
  %shl1 = shl i64 %b, 2
  %add = add nsw i64 %shl1, %shl
  ret i64 %add
}

; Shift amount is too big to fit in lea.
define i64 @test11(i64 %a) {
; HAS-LEA-LABEL: test11:
; HAS-LEA:       LBB10_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r3, 0x40
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r3
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test11:
; NO-LEA:       LBB10_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r3, 0x6
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp9
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r1
; NO-LEA-NEXT:    writer.64 call_addr, r2
; NO-LEA-NEXT:    writer.32 call_addr, r3
; NO-LEA-NEXT:    movl call_ret_bb, LBB10_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:  LBB10_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:  .Ltmp9:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %shl = shl i64 %a, 6
  ret i64 %shl
}

define i64 @test12(i64 %a) {
; HAS-LEA-LABEL: test12:
; HAS-LEA:       LBB11_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r3, 0x1
; HAS-LEA-NEXT:    movl r4, 0x2
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    leadisp r6, r3
; HAS-LEA-NEXT:    leascale r6, r4
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r5, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
;
; NO-LEA-LABEL: test12:
; NO-LEA:       LBB11_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r3, 0x1
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp10
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r1
; NO-LEA-NEXT:    writer.64 call_addr, r2
; NO-LEA-NEXT:    writer.32 call_addr, r3
; NO-LEA-NEXT:    movl call_ret_bb, LBB11_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:  LBB11_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:  .Ltmp10:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    or r2, r3
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r2
; NO-LEA-NEXT:    writer.64 ret_fid, r1
entry:
  %mul = shl nsw i64 %a, 1
  %add = or i64 %mul, 1
  ret i64 %add
}

define i64 @test13(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test13:
; HAS-LEA:       LBB12_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r4, 0x1
; HAS-LEA-NEXT:    and r3, r4
; HAS-LEA-NEXT:    movl r4, 0x2
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r4
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r5, r3
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
;
; NO-LEA-LABEL: test13:
; NO-LEA:       LBB12_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r4, 0x1
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp11
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r1
; NO-LEA-NEXT:    writer.64 call_addr, r2
; NO-LEA-NEXT:    writer.32 call_addr, r4
; NO-LEA-NEXT:    movl call_ret_bb, LBB12_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:    writer.32 call_ret_bb, r4
; NO-LEA-NEXT:  LBB12_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:    feeder.p.32 r4
; NO-LEA-NEXT:  .Ltmp11:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    and r3, r4
; NO-LEA-NEXT:    or r3, r1
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %shl = shl i64 %a, 1
  %and = and i64 %b, 1
  %or = or i64 %and, %shl
  ret i64 %or
}

; The mask is too big for the shift, so the 'or' isn't equivalent to an 'add'.
define i64 @test14(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test14:
; HAS-LEA:       LBB13_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r4, 0x8
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r6, r4
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r5, r6
; HAS-LEA-NEXT:    and r3, r4
; HAS-LEA-NEXT:    or r3, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
;
; NO-LEA-LABEL: test14:
; NO-LEA:       LBB13_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r4, 0x3
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp12
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r1
; NO-LEA-NEXT:    writer.64 call_addr, r2
; NO-LEA-NEXT:    writer.32 call_addr, r4
; NO-LEA-NEXT:    movl call_ret_bb, LBB13_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:    writer.32 call_ret_bb, r3
; NO-LEA-NEXT:  LBB13_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:    feeder.p.32 r3
; NO-LEA-NEXT:  .Ltmp12:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r4, 0x8
; NO-LEA-NEXT:    and r3, r4
; NO-LEA-NEXT:    or r3, r1
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %shl = shl i64 %a, 3
  %and = and i64 %b, 8
  %or = or i64 %and, %shl
  ret i64 %or
}

define i32 @test15(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test15:
; HAS-LEA:       LBB14_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    add r3, r1
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.32 ret_fid, r3
;
; NO-LEA-LABEL: test15:
; NO-LEA:       LBB14_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.32 ret_fid, r3
entry:
  %add = add nsw i64 %b, %a
  %conv = trunc i64 %add to i32
  ret i32 %conv
}

define i64 @test16(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test16:
; HAS-LEA:       LBB15_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
;
; NO-LEA-LABEL: test16:
; NO-LEA:       LBB15_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %and = and i64 %a, -4294967296
  %and1 = and i64 %b, 4294967295
  %add = or i64 %and1, %and
  ret i64 %add
}

; Make sure that for this case we are not folding 'add' to the disp field.
define i64 @test17(i32 %a) {
; HAS-LEA-LABEL: test17:
; HAS-LEA:       LBB16_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    movl r2, 0x4
; HAS-LEA-NEXT:    add r1, r2
; HAS-LEA-NEXT:    movl r2, 0x8
; HAS-LEA-NEXT:    movl r3, 0x0
; HAS-LEA-NEXT:    dup r4, r3
; HAS-LEA-NEXT:    leadisp r4, r4
; HAS-LEA-NEXT:    leascale r4, r2
; HAS-LEA-NEXT:    leaindex r4, r1
; HAS-LEA-NEXT:    leabase r3, r4
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
;
; NO-LEA-LABEL: test17:
; NO-LEA:       LBB16_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.32 r1
; NO-LEA-NEXT:    movl r2, 0x4
; NO-LEA-NEXT:    add r1, r2
; NO-LEA-NEXT:    movl r2, 0x3
; NO-LEA-NEXT:    movl r3, 0x0
; NO-LEA-NEXT:    movl call_addr, __ashldi3
; NO-LEA-NEXT:    movl call_ret_fid, .Ltmp13
; NO-LEA-NEXT:    chain call_addr, 0x64
; NO-LEA-NEXT:    writer.32 call_addr, tid
; NO-LEA-NEXT:    writer.32 call_addr, call_ret_fid
; NO-LEA-NEXT:    writer.64 call_addr, r1
; NO-LEA-NEXT:    writer.64 call_addr, r3
; NO-LEA-NEXT:    writer.32 call_addr, r2
; NO-LEA-NEXT:    movl call_ret_bb, LBB16_1
; NO-LEA-NEXT:    chain.rn call_ret_bb, 0x64
; NO-LEA-NEXT:    writer.32 call_ret_bb, tid
; NO-LEA-NEXT:    writer.32 call_ret_bb, ret_fid
; NO-LEA-NEXT:  LBB16_1: # %entry
; NO-LEA-NEXT:    feeder.p.32 tid
; NO-LEA-NEXT:    feeder.p.32 ret_fid
; NO-LEA-NEXT:  .Ltmp13:
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %add = add i32 %a, 4
  %conv = zext i32 %add to i64
  %shl = shl nuw nsw i64 %conv, 3
  ret i64 %shl
}

define i64 @test18(i64 %a) {
; HAS-LEA-LABEL: test18:
; HAS-LEA:       LBB17_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r2, 0x0
; HAS-LEA-NEXT:    inc r1
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
; HAS-LEA-NEXT:    writer.64 ret_fid, r2
;
; NO-LEA-LABEL: test18:
; NO-LEA:       LBB17_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r2, 0x0
; NO-LEA-NEXT:    inc r1
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %add = add i64 %a, 1
  %and = and i64 %add, 4294967295
  ret i64 %and
}

define i64 @test19(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test19:
; HAS-LEA:       LBB18_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    add r3, r1
; HAS-LEA-NEXT:    movl r1, 0x0
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
;
; NO-LEA-LABEL: test19:
; NO-LEA:       LBB18_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    movl r1, 0x0
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r3
entry:
  %add = add i64 %b, %a
  %shl = shl i64 %add, 32
  ret i64 %shl
}

define i64 @test20(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test20:
; HAS-LEA:       LBB19_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r2, 0x1F
; HAS-LEA-NEXT:    add r3, r1
; HAS-LEA-NEXT:    dup r1, r3
; HAS-LEA-NEXT:    shri r1, r2
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r3
; HAS-LEA-NEXT:    writer.64 ret_fid, r1
;
; NO-LEA-LABEL: test20:
; NO-LEA:       LBB19_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    movl r2, 0x1F
; NO-LEA-NEXT:    add r3, r1
; NO-LEA-NEXT:    dup r1, r3
; NO-LEA-NEXT:    shri r1, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r1
entry:
  %add = add nsw i64 %b, %a
  %shl = shl i64 %add, 32
  %shr = ashr exact i64 %shl, 32
  ret i64 %shr
}

define i64 @test21(i64 %a) {
; HAS-LEA-LABEL: test21:
; HAS-LEA:       LBB20_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r3, 0x19
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r3
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test21:
; NO-LEA:       LBB20_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r3, 0x19
; NO-LEA-NEXT:    mul r2, r3
; NO-LEA-NEXT:    umul r1, r3
; NO-LEA-NEXT:    add r3, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r3
entry:
  %mul = mul nsw i64 %a, 25
  ret i64 %mul
}

define i64 @test22(i64 %a) {
; HAS-LEA-LABEL: test22:
; HAS-LEA:       LBB21_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    movl r3, 0x1A
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r5, r3
; HAS-LEA-NEXT:    leaindex r2, r1
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test22:
; NO-LEA:       LBB21_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    movl r3, 0x1A
; NO-LEA-NEXT:    mul r2, r3
; NO-LEA-NEXT:    umul r1, r3
; NO-LEA-NEXT:    add r3, r2
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r3
entry:
  %mul = mul i64 %a, 26
  ret i64 %mul
}

define i64 @test23(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test23:
; HAS-LEA:       LBB22_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r2, r1
; HAS-LEA-NEXT:    leaindex r4, r3
; HAS-LEA-NEXT:    leabase r5, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
;
; NO-LEA-LABEL: test23:
; NO-LEA:       LBB22_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    mul r5, r2
; NO-LEA-NEXT:    dup r2, r1
; NO-LEA-NEXT:    umul r3, r2
; NO-LEA-NEXT:    add r2, r5
; NO-LEA-NEXT:    mul r4, r1
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %mul = mul nsw i64 %b, %a
  ret i64 %mul
}

define i64 @test24(i64 %a, i64 %b) {
; HAS-LEA-LABEL: test24:
; HAS-LEA:       LBB23_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    feeder.64 r4
; HAS-LEA-NEXT:    movl r5, 0x0
; HAS-LEA-NEXT:    dup r6, r5
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r2, r1
; HAS-LEA-NEXT:    leaindex r4, r3
; HAS-LEA-NEXT:    leabase r5, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
;
; NO-LEA-LABEL: test24:
; NO-LEA:       LBB23_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    feeder.64 r4
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    mul r5, r2
; NO-LEA-NEXT:    dup r2, r1
; NO-LEA-NEXT:    umul r3, r2
; NO-LEA-NEXT:    add r2, r5
; NO-LEA-NEXT:    mul r4, r1
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %mul = mul i64 %b, %a
  ret i64 %mul
}

define i64 @test25(i32 %a, i64 %b) {
; HAS-LEA-LABEL: test25:
; HAS-LEA:       LBB24_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    movl r4, 0x1F
; HAS-LEA-NEXT:    dup r5, r1
; HAS-LEA-NEXT:    shri r5, r4
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r6, r4
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r3, r2
; HAS-LEA-NEXT:    leaindex r5, r1
; HAS-LEA-NEXT:    leabase r4, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test25:
; NO-LEA:       LBB24_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.32 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    dup r4, r1
; NO-LEA-NEXT:    mul r4, r3
; NO-LEA-NEXT:    dup r3, r1
; NO-LEA-NEXT:    dup r5, r2
; NO-LEA-NEXT:    umul r3, r5
; NO-LEA-NEXT:    add r5, r4
; NO-LEA-NEXT:    movl r4, 0x1F
; NO-LEA-NEXT:    shri r1, r4
; NO-LEA-NEXT:    mul r1, r2
; NO-LEA-NEXT:    add r5, r1
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r3
; NO-LEA-NEXT:    writer.64 ret_fid, r5
entry:
  %conv = sext i32 %a to i64
  %mul = mul nsw i64 %conv, %b
  ret i64 %mul
}

define i64 @test26(i32 %a, i64 %b) {
; HAS-LEA-LABEL: test26:
; HAS-LEA:       LBB25_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r3, r2
; HAS-LEA-NEXT:    leaindex r5, r1
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test26:
; NO-LEA:       LBB25_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.32 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    dup r4, r1
; NO-LEA-NEXT:    mul r4, r3
; NO-LEA-NEXT:    umul r1, r2
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %conv = zext i32 %a to i64
  %mul = mul i64 %conv, %b
  ret i64 %mul
}

define i64 @test27(i32 %a, i64 %b) {
; HAS-LEA-LABEL: test27:
; HAS-LEA:       LBB26_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.32 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.64 r3
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r5, r4
; HAS-LEA-NEXT:    leadisp r5, r5
; HAS-LEA-NEXT:    leascale r3, r2
; HAS-LEA-NEXT:    leaindex r5, r1
; HAS-LEA-NEXT:    leabase r4, r5
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r5
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test27:
; NO-LEA:       LBB26_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.32 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.64 r3
; NO-LEA-NEXT:    dup r4, r1
; NO-LEA-NEXT:    mul r4, r3
; NO-LEA-NEXT:    umul r1, r2
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r1
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %conv = zext i32 %a to i64
  %mul = mul nsw i64 %conv, %b
  ret i64 %mul
}

define i64 @test28(i64 %a, i32 %b) {
; HAS-LEA-LABEL: test28:
; HAS-LEA:       LBB27_0:
; HAS-LEA-NEXT:  # %bb.0: # %entry
; HAS-LEA-NEXT:    feeder.32 tid
; HAS-LEA-NEXT:    feeder.32 ret_fid
; HAS-LEA-NEXT:    feeder.64 r1
; HAS-LEA-NEXT:    feeder.64 r2
; HAS-LEA-NEXT:    feeder.32 r3
; HAS-LEA-NEXT:    movl r4, 0x1F
; HAS-LEA-NEXT:    dup r5, r3
; HAS-LEA-NEXT:    shri r5, r4
; HAS-LEA-NEXT:    movl r4, 0x0
; HAS-LEA-NEXT:    dup r6, r4
; HAS-LEA-NEXT:    leadisp r6, r6
; HAS-LEA-NEXT:    leascale r2, r1
; HAS-LEA-NEXT:    leaindex r5, r3
; HAS-LEA-NEXT:    leabase r4, r6
; HAS-LEA-NEXT:    chain ret_fid, 0x64
; HAS-LEA-NEXT:    writer.32 ret_fid, tid
; HAS-LEA-NEXT:    writer.64 ret_fid, r6
; HAS-LEA-NEXT:    writer.64 ret_fid, r4
;
; NO-LEA-LABEL: test28:
; NO-LEA:       LBB27_0:
; NO-LEA-NEXT:  # %bb.0: # %entry
; NO-LEA-NEXT:    feeder.32 tid
; NO-LEA-NEXT:    feeder.32 ret_fid
; NO-LEA-NEXT:    feeder.64 r1
; NO-LEA-NEXT:    feeder.64 r2
; NO-LEA-NEXT:    feeder.32 r3
; NO-LEA-NEXT:    dup r4, r3
; NO-LEA-NEXT:    mul r4, r2
; NO-LEA-NEXT:    dup r2, r1
; NO-LEA-NEXT:    dup r5, r3
; NO-LEA-NEXT:    umul r5, r2
; NO-LEA-NEXT:    add r2, r4
; NO-LEA-NEXT:    movl r4, 0x1F
; NO-LEA-NEXT:    shri r3, r4
; NO-LEA-NEXT:    mul r3, r1
; NO-LEA-NEXT:    add r2, r3
; NO-LEA-NEXT:    chain ret_fid, 0x64
; NO-LEA-NEXT:    writer.32 ret_fid, tid
; NO-LEA-NEXT:    writer.64 ret_fid, r5
; NO-LEA-NEXT:    writer.64 ret_fid, r2
entry:
  %conv = sext i32 %b to i64
  %mul = mul i64 %conv, %a
  ret i64 %mul
}
