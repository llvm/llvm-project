; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=next32 < %s | FileCheck %s

define dso_local i32 @barrier1(i32* nocapture noundef writeonly %0, i32 noundef %1) {
; CHECK-LABEL: barrier1
; CHECK:    feeder.32 tid
; CHECK-NEXT:    feeder.32 ret_fid
; CHECK-NEXT:    feeder.64 r1
; CHECK-NEXT:    feeder.64 r2
; CHECK-NEXT:    feeder.32 r3
; CHECK-NEXT:    movl r4, 0x7B
; CHECK-NEXT:    dup r5, r3
; CHECK-NEXT:    add r5, r4
; CHECK-NEXT:    dup r4, r5
; CHECK-NEXT:    memwrite.32.align[4] r2, r1, tid
; CHECK-NEXT:    memdata r4
; CHECK-NEXT:    dup r1, tid
; CHECK-NEXT:    barrier r1, r4
; CHECK-NEXT:    dup tid, r1
; CHECK-NEXT:    add r5, r3
; CHECK-NEXT:    chain ret_fid, 0x64
; CHECK-NEXT:    writer.32 ret_fid, tid
; CHECK-NEXT:    writer.32 ret_fid, r5
  %3 = add i32 %1, 123
  store i32 %3, i32* %0, align 4
  %4 = add i32 %3, %1
  ret i32 %4
}

declare i32 @foo()

define dso_local i32 @barrier2(ptr %0, ptr %1, i32 %2) {
; CHECK-LABEL: barrier2:
; CHECK:       memwrite.32.align[4] {{.*}}, tid
; CHECK-NEXT:  memdata r[[A:[0-9]+]]
; CHECK:       barrier r[[B:[0-9]+]], r[[A]]
; CHECK:       memwrite.32.align[4] {{.*}}, r[[B]]
; CHECK-NEXT:  memdata r[[C:[0-9]+]]
; CHECK:       barrier r[[B]], r[[C]]
  store i32 %2, ptr %0, align 4
  store i32 %2, ptr %1, align 4
  %4 = call i32 @foo()
  ret i32 %4
}
