; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes='dxil-data-scalarization' -mtriple=dxil-pc-shadermodel6.3-library %s | FileCheck %s

define float @extract_float_vec_dynamic(<4 x float> %v, i32 %i) {
; CHECK-LABEL: define float @extract_float_vec_dynamic(
; CHECK-SAME: <4 x float> [[V:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = alloca [4 x float], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x float> [[V]], i64 0
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [4 x float], ptr [[TMP1]], i32 0, i32 0
; CHECK-NEXT:    store float [[TMP2]], ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x float> [[V]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [4 x float], ptr [[TMP1]], i32 0, i32 1
; CHECK-NEXT:    store float [[TMP4]], ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x float> [[V]], i64 2
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds [4 x float], ptr [[TMP1]], i32 0, i32 2
; CHECK-NEXT:    store float [[TMP6]], ptr [[TMP7]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <4 x float> [[V]], i64 3
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds [4 x float], ptr [[TMP1]], i32 0, i32 3
; CHECK-NEXT:    store float [[TMP8]], ptr [[TMP9]], align 4
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds [4 x float], ptr [[TMP1]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP11:%.*]] = load float, ptr [[TMP10]], align 4
; CHECK-NEXT:    ret float [[TMP11]]
;
  %ee = extractelement <4 x float> %v, i32 %i
  ret float %ee
}

define <3 x i32> @insert_i32_vec_dynamic(<3 x i32> %v, i32 %a, i32 %i) {
; CHECK-LABEL: define <3 x i32> @insert_i32_vec_dynamic(
; CHECK-SAME: <3 x i32> [[V:%.*]], i32 [[A:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = alloca [3 x i32], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <3 x i32> [[V]], i64 0
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [3 x i32], ptr [[TMP1]], i32 0, i32 0
; CHECK-NEXT:    store i32 [[TMP2]], ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <3 x i32> [[V]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [3 x i32], ptr [[TMP1]], i32 0, i32 1
; CHECK-NEXT:    store i32 [[TMP4]], ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <3 x i32> [[V]], i64 2
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds [3 x i32], ptr [[TMP1]], i32 0, i32 2
; CHECK-NEXT:    store i32 [[TMP6]], ptr [[TMP7]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds [3 x i32], ptr [[TMP1]], i32 0, i32 [[I]]
; CHECK-NEXT:    store i32 [[A]], ptr [[TMP8]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <3 x i32> poison, i32 [[TMP9]], i32 0
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <3 x i32> [[TMP10]], i32 [[TMP11]], i32 1
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[TMP7]], align 4
; CHECK-NEXT:    [[TMP14:%.*]] = insertelement <3 x i32> [[TMP12]], i32 [[TMP13]], i32 2
; CHECK-NEXT:    ret <3 x i32> [[TMP14]]
;
  %ie = insertelement <3 x i32> %v, i32 %a, i32 %i
  ret <3 x i32> %ie
}

; An extractelement with a constant index should not be converted to array form
define i16 @extract_i16_vec_constant(<4 x i16> %v) {
; CHECK-LABEL: define i16 @extract_i16_vec_constant(
; CHECK-SAME: <4 x i16> [[V:%.*]]) {
; CHECK-NEXT:    [[EE:%.*]] = extractelement <4 x i16> [[V]], i32 1
; CHECK-NEXT:    ret i16 [[EE]]
;
  %ee = extractelement <4 x i16> %v, i32 1
  ret i16 %ee
}

; An insertelement with a constant index should not be converted to array form
define <2 x half> @insert_half_vec_constant(<2 x half> %v, half %a) {
; CHECK-LABEL: define <2 x half> @insert_half_vec_constant(
; CHECK-SAME: <2 x half> [[V:%.*]], half [[A:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x half> [[V]], half [[A]], i32 1
; CHECK-NEXT:    ret <2 x half> [[TMP1]]
;
  %ie = insertelement <2 x half> %v, half %a, i32 1
  ret <2 x half> %ie
}

