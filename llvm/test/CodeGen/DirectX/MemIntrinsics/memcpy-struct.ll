; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -dxil-mem-intrinsics -mtriple=dxil-pc-shadermodel6.3-library %s | FileCheck %s

%struct.S = type { <4 x i32>, [2 x <4 x i32>] }

define void @test_struct_alloca() "hlsl.export" {
; CHECK-LABEL: define void @test_struct_alloca(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[OUT:%.*]] = alloca [[STRUCT_S:%.*]], align 16
; CHECK-NEXT:    [[IN:%.*]] = alloca [[STRUCT_S]], align 16
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr [[TMP0]], align 16
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 0
; CHECK-NEXT:    store <4 x i32> [[TMP1]], ptr [[TMP2]], align 16
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 16
; CHECK-NEXT:    [[TMP4:%.*]] = load <4 x i32>, ptr [[TMP3]], align 16
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 16
; CHECK-NEXT:    store <4 x i32> [[TMP4]], ptr [[TMP5]], align 16
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 32
; CHECK-NEXT:    [[TMP7:%.*]] = load <4 x i32>, ptr [[TMP6]], align 16
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 32
; CHECK-NEXT:    store <4 x i32> [[TMP7]], ptr [[TMP8]], align 16
; CHECK-NEXT:    ret void
;
entry:
  %out = alloca %struct.S
  %in = alloca %struct.S
  tail call void @llvm.memcpy(ptr %out, ptr %in, i32 48, i1 false)
  ret void
}

define void @test_array_of_array() "hlsl.export" {
; CHECK-LABEL: define void @test_array_of_array(
; CHECK-SAME: ) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[OUT:%.*]] = alloca [2 x [3 x float]], align 4
; CHECK-NEXT:    [[IN:%.*]] = alloca [2 x [3 x float]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[TMP0]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 0
; CHECK-NEXT:    store float [[TMP1]], ptr [[TMP2]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 4
; CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 4
; CHECK-NEXT:    store float [[TMP4]], ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 8
; CHECK-NEXT:    [[TMP7:%.*]] = load float, ptr [[TMP6]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 8
; CHECK-NEXT:    store float [[TMP7]], ptr [[TMP8]], align 4
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 12
; CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[TMP9]], align 4
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 12
; CHECK-NEXT:    store float [[TMP10]], ptr [[TMP11]], align 4
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 16
; CHECK-NEXT:    [[TMP13:%.*]] = load float, ptr [[TMP12]], align 4
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 16
; CHECK-NEXT:    store float [[TMP13]], ptr [[TMP14]], align 4
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i8, ptr [[IN]], i32 20
; CHECK-NEXT:    [[TMP16:%.*]] = load float, ptr [[TMP15]], align 4
; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr inbounds i8, ptr [[OUT]], i32 20
; CHECK-NEXT:    store float [[TMP16]], ptr [[TMP17]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %out = alloca [2 x [3 x float]]
  %in = alloca [2 x [3 x float]]
  tail call void @llvm.memcpy(ptr %out, ptr %in, i32 24, i1 false)
  ret void
}
