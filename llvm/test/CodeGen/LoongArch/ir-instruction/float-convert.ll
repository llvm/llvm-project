; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --mtriple=loongarch32 --mattr=+f,-d < %s | FileCheck %s --check-prefix=LA32
; RUN: llc --mtriple=loongarch64 --mattr=+f,-d < %s | FileCheck %s --check-prefix=LA64

define signext i8 @convert_float_to_i8(float %a) nounwind {
; LA32-LABEL: convert_float_to_i8:
; LA32:       # %bb.0:
; LA32-NEXT:    ftintrz.w.s $fa0, $fa0
; LA32-NEXT:    movfr2gr.s $a0, $fa0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_float_to_i8:
; LA64:       # %bb.0:
; LA64-NEXT:    ftintrz.w.s $fa0, $fa0
; LA64-NEXT:    movfr2gr.s $a0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = fptosi float %a to i8
  ret i8 %1
}

define signext i16 @convert_float_to_i16(float %a) nounwind {
; LA32-LABEL: convert_float_to_i16:
; LA32:       # %bb.0:
; LA32-NEXT:    ftintrz.w.s $fa0, $fa0
; LA32-NEXT:    movfr2gr.s $a0, $fa0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_float_to_i16:
; LA64:       # %bb.0:
; LA64-NEXT:    ftintrz.w.s $fa0, $fa0
; LA64-NEXT:    movfr2gr.s $a0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = fptosi float %a to i16
  ret i16 %1
}

define i32 @convert_float_to_i32(float %a) nounwind {
; LA32-LABEL: convert_float_to_i32:
; LA32:       # %bb.0:
; LA32-NEXT:    ftintrz.w.s $fa0, $fa0
; LA32-NEXT:    movfr2gr.s $a0, $fa0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_float_to_i32:
; LA64:       # %bb.0:
; LA64-NEXT:    ftintrz.w.s $fa0, $fa0
; LA64-NEXT:    movfr2gr.s $a0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = fptosi float %a to i32
  ret i32 %1
}

define i64 @convert_float_to_i64(float %a) nounwind {
; LA32-LABEL: convert_float_to_i64:
; LA32:       # %bb.0:
; LA32-NEXT:    addi.w $sp, $sp, -16
; LA32-NEXT:    st.w $ra, $sp, 12 # 4-byte Folded Spill
; LA32-NEXT:    bl __fixsfdi
; LA32-NEXT:    ld.w $ra, $sp, 12 # 4-byte Folded Reload
; LA32-NEXT:    addi.w $sp, $sp, 16
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_float_to_i64:
; LA64:       # %bb.0:
; LA64-NEXT:    ftintrz.w.s $fa0, $fa0
; LA64-NEXT:    movfr2gr.s $a0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = fptosi float %a to i64
  ret i64 %1
}

define float @convert_i8_to_float(i8 signext %a) nounwind {
; LA32-LABEL: convert_i8_to_float:
; LA32:       # %bb.0:
; LA32-NEXT:    movgr2fr.w $fa0, $a0
; LA32-NEXT:    ffint.s.w $fa0, $fa0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_i8_to_float:
; LA64:       # %bb.0:
; LA64-NEXT:    movgr2fr.w $fa0, $a0
; LA64-NEXT:    ffint.s.w $fa0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = sitofp i8 %a to float
  ret float %1
}

define float @convert_i16_to_float(i16 signext %a) nounwind {
; LA32-LABEL: convert_i16_to_float:
; LA32:       # %bb.0:
; LA32-NEXT:    movgr2fr.w $fa0, $a0
; LA32-NEXT:    ffint.s.w $fa0, $fa0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_i16_to_float:
; LA64:       # %bb.0:
; LA64-NEXT:    movgr2fr.w $fa0, $a0
; LA64-NEXT:    ffint.s.w $fa0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = sitofp i16 %a to float
  ret float %1
}

define float @convert_i32_to_float(i32 %a) nounwind {
; LA32-LABEL: convert_i32_to_float:
; LA32:       # %bb.0:
; LA32-NEXT:    movgr2fr.w $fa0, $a0
; LA32-NEXT:    ffint.s.w $fa0, $fa0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_i32_to_float:
; LA64:       # %bb.0:
; LA64-NEXT:    addi.w $a0, $a0, 0
; LA64-NEXT:    movgr2fr.w $fa0, $a0
; LA64-NEXT:    ffint.s.w $fa0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = sitofp i32 %a to float
  ret float %1
}

define float @convert_i64_to_float(i64 %a) nounwind {
; LA32-LABEL: convert_i64_to_float:
; LA32:       # %bb.0:
; LA32-NEXT:    addi.w $sp, $sp, -16
; LA32-NEXT:    st.w $ra, $sp, 12 # 4-byte Folded Spill
; LA32-NEXT:    bl __floatdisf
; LA32-NEXT:    ld.w $ra, $sp, 12 # 4-byte Folded Reload
; LA32-NEXT:    addi.w $sp, $sp, 16
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: convert_i64_to_float:
; LA64:       # %bb.0:
; LA64-NEXT:    movgr2fr.w $fa0, $a0
; LA64-NEXT:    ffint.s.w $fa0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = sitofp i64 %a to float
  ret float %1
}

define i32 @bitcast_float_to_i32(float %a) nounwind {
; LA32-LABEL: bitcast_float_to_i32:
; LA32:       # %bb.0:
; LA32-NEXT:    movfr2gr.s $a0, $fa0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: bitcast_float_to_i32:
; LA64:       # %bb.0:
; LA64-NEXT:    movfr2gr.s $a0, $fa0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = bitcast float %a to i32
  ret i32 %1
}

define float @bitcast_i32_to_float(i32 %a) nounwind {
; LA32-LABEL: bitcast_i32_to_float:
; LA32:       # %bb.0:
; LA32-NEXT:    movgr2fr.w $fa0, $a0
; LA32-NEXT:    jirl $zero, $ra, 0
;
; LA64-LABEL: bitcast_i32_to_float:
; LA64:       # %bb.0:
; LA64-NEXT:    movgr2fr.w $fa0, $a0
; LA64-NEXT:    jirl $zero, $ra, 0
  %1 = bitcast i32 %a to float
  ret float %1
}
