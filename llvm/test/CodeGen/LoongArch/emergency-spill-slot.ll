; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --mtriple=loongarch64 -mattr=+d -O0 < %s | FileCheck %s

@var = external global i32

define void @func() {
; CHECK-LABEL: func:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lu12i.w $a0, 1
; CHECK-NEXT:    ori $a0, $a0, 16
; CHECK-NEXT:    sub.d $sp, $sp, $a0
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    pcalau12i $a0, %got_pc_hi20(var)
; CHECK-NEXT:    ld.d $a1, $a0, %got_pc_lo12(var)
; CHECK-NEXT:    ld.w $t8, $a1, 0
; CHECK-NEXT:    ld.w $t7, $a1, 0
; CHECK-NEXT:    ld.w $t6, $a1, 0
; CHECK-NEXT:    ld.w $t5, $a1, 0
; CHECK-NEXT:    ld.w $t4, $a1, 0
; CHECK-NEXT:    ld.w $t3, $a1, 0
; CHECK-NEXT:    ld.w $t2, $a1, 0
; CHECK-NEXT:    ld.w $t1, $a1, 0
; CHECK-NEXT:    ld.w $t0, $a1, 0
; CHECK-NEXT:    ld.w $a7, $a1, 0
; CHECK-NEXT:    ld.w $a6, $a1, 0
; CHECK-NEXT:    ld.w $a5, $a1, 0
; CHECK-NEXT:    ld.w $a4, $a1, 0
; CHECK-NEXT:    ld.w $a3, $a1, 0
; CHECK-NEXT:    ld.w $a2, $a1, 0
; CHECK-NEXT:    ld.w $a0, $a1, 0
; CHECK-NEXT:    st.d $fp, $sp, 0
; CHECK-NEXT:    lu12i.w $fp, 1
; CHECK-NEXT:    ori $fp, $fp, 12
; CHECK-NEXT:    add.d $fp, $sp, $fp
; CHECK-NEXT:    st.w $t8, $fp, 0
; CHECK-NEXT:    ld.d $fp, $sp, 0
; CHECK-NEXT:    st.w $t8, $a1, 0
; CHECK-NEXT:    st.w $t7, $a1, 0
; CHECK-NEXT:    st.w $t6, $a1, 0
; CHECK-NEXT:    st.w $t5, $a1, 0
; CHECK-NEXT:    st.w $t4, $a1, 0
; CHECK-NEXT:    st.w $t3, $a1, 0
; CHECK-NEXT:    st.w $t2, $a1, 0
; CHECK-NEXT:    st.w $t1, $a1, 0
; CHECK-NEXT:    st.w $t0, $a1, 0
; CHECK-NEXT:    st.w $a7, $a1, 0
; CHECK-NEXT:    st.w $a6, $a1, 0
; CHECK-NEXT:    st.w $a5, $a1, 0
; CHECK-NEXT:    st.w $a4, $a1, 0
; CHECK-NEXT:    st.w $a3, $a1, 0
; CHECK-NEXT:    st.w $a2, $a1, 0
; CHECK-NEXT:    st.w $a0, $a1, 0
; CHECK-NEXT:    lu12i.w $a0, 1
; CHECK-NEXT:    ori $a0, $a0, 16
; CHECK-NEXT:    add.d $sp, $sp, $a0
; CHECK-NEXT:    ret
  %space = alloca i32, align 4
  %stackspace = alloca[1024 x i32], align 4

  ;; Load values to increase register pressure.
  %v0 = load volatile i32, ptr @var
  %v1 = load volatile i32, ptr @var
  %v2 = load volatile i32, ptr @var
  %v3 = load volatile i32, ptr @var
  %v4 = load volatile i32, ptr @var
  %v5 = load volatile i32, ptr @var
  %v6 = load volatile i32, ptr @var
  %v7 = load volatile i32, ptr @var
  %v8 = load volatile i32, ptr @var
  %v9 = load volatile i32, ptr @var
  %v10 = load volatile i32, ptr @var
  %v11 = load volatile i32, ptr @var
  %v12 = load volatile i32, ptr @var
  %v13 = load volatile i32, ptr @var
  %v14 = load volatile i32, ptr @var
  %v15 = load volatile i32, ptr @var

  ;; Computing a stack-relative values needs an additional register.
  ;; We should get an emergency spill/reload for this.
  store volatile i32 %v0, ptr %space

  ;; store values so they are used.
  store volatile i32 %v0, ptr @var
  store volatile i32 %v1, ptr @var
  store volatile i32 %v2, ptr @var
  store volatile i32 %v3, ptr @var
  store volatile i32 %v4, ptr @var
  store volatile i32 %v5, ptr @var
  store volatile i32 %v6, ptr @var
  store volatile i32 %v7, ptr @var
  store volatile i32 %v8, ptr @var
  store volatile i32 %v9, ptr @var
  store volatile i32 %v10, ptr @var
  store volatile i32 %v11, ptr @var
  store volatile i32 %v12, ptr @var
  store volatile i32 %v13, ptr @var
  store volatile i32 %v14, ptr @var
  store volatile i32 %v15, ptr @var

  ret void
}
