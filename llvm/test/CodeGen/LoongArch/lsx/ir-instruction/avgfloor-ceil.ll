; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc --mtriple=loongarch32 --mattr=+32s,+lsx < %s | FileCheck %s
; RUN: llc --mtriple=loongarch64 --mattr=+lsx < %s | FileCheck %s

define void @vavg_b(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.b $vr0, $vr0, 1
; CHECK-NEXT:    vadd.b $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <16 x i8>, ptr %a
  %vb = load <16 x i8>, ptr %b
  %ea = sext <16 x i8> %va to <16 x i16>
  %eb = sext <16 x i8> %vb to <16 x i16>
  %add = add <16 x i16> %ea, %eb
  %shr = lshr <16 x i16> %add, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %r = trunc <16 x i16> %shr to <16 x i8>
  store <16 x i8> %r, ptr %res
  ret void
}

define void @vavg_h(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_h:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.h $vr0, $vr0, 1
; CHECK-NEXT:    vadd.h $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <8 x i16>, ptr %a
  %vb = load <8 x i16>, ptr %b
  %ea = sext <8 x i16> %va to <8 x i32>
  %eb = sext <8 x i16> %vb to <8 x i32>
  %add = add <8 x i32> %ea, %eb
  %shr = lshr <8 x i32> %add, <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
  %r = trunc <8 x i32> %shr to <8 x i16>
  store <8 x i16> %r, ptr %res
  ret void
}

define void @vavg_w(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.w $vr0, $vr0, 1
; CHECK-NEXT:    vadd.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <4 x i32>, ptr %a
  %vb = load <4 x i32>, ptr %b
  %ea = sext <4 x i32> %va to <4 x i64>
  %eb = sext <4 x i32> %vb to <4 x i64>
  %add = add <4 x i64> %ea, %eb
  %shr = lshr <4 x i64> %add, <i64 1, i64 1, i64 1, i64 1>
  %r = trunc <4 x i64> %shr to <4 x i32>
  store <4 x i32> %r, ptr %res
  ret void
}

define void @vavg_d(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_d:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.d $vr0, $vr0, 1
; CHECK-NEXT:    vadd.d $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <2 x i64>, ptr %a
  %vb = load <2 x i64>, ptr %b
  %ea = sext <2 x i64> %va to <2 x i128>
  %eb = sext <2 x i64> %vb to <2 x i128>
  %add = add <2 x i128> %ea, %eb
  %shr = lshr <2 x i128> %add, <i128 1, i128 1>
  %r = trunc <2 x i128> %shr to <2 x i64>
  store <2 x i64> %r, ptr %res
  ret void
}

define void @vavg_bu(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_bu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.b $vr0, $vr0, 1
; CHECK-NEXT:    vadd.b $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <16 x i8>, ptr %a
  %vb = load <16 x i8>, ptr %b
  %ea = zext <16 x i8> %va to <16 x i16>
  %eb = zext <16 x i8> %vb to <16 x i16>
  %add = add <16 x i16> %ea, %eb
  %shr = lshr <16 x i16> %add, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %r = trunc <16 x i16> %shr to <16 x i8>
  store <16 x i8> %r, ptr %res
  ret void
}

define void @vavg_hu(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_hu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.h $vr0, $vr0, 1
; CHECK-NEXT:    vadd.h $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <8 x i16>, ptr %a
  %vb = load <8 x i16>, ptr %b
  %ea = zext <8 x i16> %va to <8 x i32>
  %eb = zext <8 x i16> %vb to <8 x i32>
  %add = add <8 x i32> %ea, %eb
  %shr = lshr <8 x i32> %add, <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
  %r = trunc <8 x i32> %shr to <8 x i16>
  store <8 x i16> %r, ptr %res
  ret void
}

define void @vavg_wu(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_wu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.w $vr0, $vr0, 1
; CHECK-NEXT:    vadd.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <4 x i32>, ptr %a
  %vb = load <4 x i32>, ptr %b
  %ea = zext <4 x i32> %va to <4 x i64>
  %eb = zext <4 x i32> %vb to <4 x i64>
  %add = add <4 x i64> %ea, %eb
  %shr = lshr <4 x i64> %add, <i64 1, i64 1, i64 1, i64 1>
  %r = trunc <4 x i64> %shr to <4 x i32>
  store <4 x i32> %r, ptr %res
  ret void
}

define void @vavg_du(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavg_du:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vand.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.d $vr0, $vr0, 1
; CHECK-NEXT:    vadd.d $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <2 x i64>, ptr %a
  %vb = load <2 x i64>, ptr %b
  %ea = zext <2 x i64> %va to <2 x i128>
  %eb = zext <2 x i64> %vb to <2 x i128>
  %add = add <2 x i128> %ea, %eb
  %shr = lshr <2 x i128> %add, <i128 1, i128 1>
  %r = trunc <2 x i128> %shr to <2 x i64>
  store <2 x i64> %r, ptr %res
  ret void
}

define void @vavgr_b(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.b $vr0, $vr0, 1
; CHECK-NEXT:    vsub.b $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <16 x i8>, ptr %a
  %vb = load <16 x i8>, ptr %b
  %ea = sext <16 x i8> %va to <16 x i16>
  %eb = sext <16 x i8> %vb to <16 x i16>
  %add = add <16 x i16> %ea, %eb
  %add1 = add <16 x i16> %add, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %shr = lshr <16 x i16> %add1, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %r = trunc <16 x i16> %shr to <16 x i8>
  store <16 x i8> %r, ptr %res
  ret void
}

define void @vavgr_h(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_h:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.h $vr0, $vr0, 1
; CHECK-NEXT:    vsub.h $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <8 x i16>, ptr %a
  %vb = load <8 x i16>, ptr %b
  %ea = sext <8 x i16> %va to <8 x i32>
  %eb = sext <8 x i16> %vb to <8 x i32>
  %add = add <8 x i32> %ea, %eb
  %add1 = add <8 x i32> %add, <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
  %shr = lshr <8 x i32> %add1, <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
  %r = trunc <8 x i32> %shr to <8 x i16>
  store <8 x i16> %r, ptr %res
  ret void
}

define void @vavgr_w(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.w $vr0, $vr0, 1
; CHECK-NEXT:    vsub.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <4 x i32>, ptr %a
  %vb = load <4 x i32>, ptr %b
  %ea = sext <4 x i32> %va to <4 x i64>
  %eb = sext <4 x i32> %vb to <4 x i64>
  %add = add <4 x i64> %ea, %eb
  %add1 = add <4 x i64> %add, <i64 1, i64 1, i64 1, i64 1>
  %shr = lshr <4 x i64> %add1, <i64 1, i64 1, i64 1, i64 1>
  %r = trunc <4 x i64> %shr to <4 x i32>
  store <4 x i32> %r, ptr %res
  ret void
}

define void @vavgr_d(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_d:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrai.d $vr0, $vr0, 1
; CHECK-NEXT:    vsub.d $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <2 x i64>, ptr %a
  %vb = load <2 x i64>, ptr %b
  %ea = sext <2 x i64> %va to <2 x i128>
  %eb = sext <2 x i64> %vb to <2 x i128>
  %add = add <2 x i128> %ea, %eb
  %add1 = add <2 x i128> %add, <i128 1, i128 1>
  %shr = lshr <2 x i128> %add1, <i128 1, i128 1>
  %r = trunc <2 x i128> %shr to <2 x i64>
  store <2 x i64> %r, ptr %res
  ret void
}

define void @vavgr_bu(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_bu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.b $vr0, $vr0, 1
; CHECK-NEXT:    vsub.b $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <16 x i8>, ptr %a
  %vb = load <16 x i8>, ptr %b
  %ea = zext <16 x i8> %va to <16 x i16>
  %eb = zext <16 x i8> %vb to <16 x i16>
  %add = add <16 x i16> %ea, %eb
  %add1 = add <16 x i16> %add, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %shr = lshr <16 x i16> %add1, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %r = trunc <16 x i16> %shr to <16 x i8>
  store <16 x i8> %r, ptr %res
  ret void
}

define void @vavgr_hu(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_hu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.h $vr0, $vr0, 1
; CHECK-NEXT:    vsub.h $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <8 x i16>, ptr %a
  %vb = load <8 x i16>, ptr %b
  %ea = zext <8 x i16> %va to <8 x i32>
  %eb = zext <8 x i16> %vb to <8 x i32>
  %add = add <8 x i32> %ea, %eb
  %add1 = add <8 x i32> %add, <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
  %shr = lshr <8 x i32> %add1, <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
  %r = trunc <8 x i32> %shr to <8 x i16>
  store <8 x i16> %r, ptr %res
  ret void
}

define void @vavgr_wu(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_wu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.w $vr0, $vr0, 1
; CHECK-NEXT:    vsub.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <4 x i32>, ptr %a
  %vb = load <4 x i32>, ptr %b
  %ea = zext <4 x i32> %va to <4 x i64>
  %eb = zext <4 x i32> %vb to <4 x i64>
  %add = add <4 x i64> %ea, %eb
  %add1 = add <4 x i64> %add, <i64 1, i64 1, i64 1, i64 1>
  %shr = lshr <4 x i64> %add1, <i64 1, i64 1, i64 1, i64 1>
  %r = trunc <4 x i64> %shr to <4 x i32>
  store <4 x i32> %r, ptr %res
  ret void
}

define void @vavgr_du(ptr %res, ptr %a, ptr %b) nounwind {
; CHECK-LABEL: vavgr_du:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vld $vr1, $a2, 0
; CHECK-NEXT:    vor.v $vr2, $vr0, $vr1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vsrli.d $vr0, $vr0, 1
; CHECK-NEXT:    vsub.d $vr0, $vr2, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %va = load <2 x i64>, ptr %a
  %vb = load <2 x i64>, ptr %b
  %ea = zext <2 x i64> %va to <2 x i128>
  %eb = zext <2 x i64> %vb to <2 x i128>
  %add = add <2 x i128> %ea, %eb
  %add1 = add <2 x i128> %add, <i128 1, i128 1>
  %shr = lshr <2 x i128> %add1, <i128 1, i128 1>
  %r = trunc <2 x i128> %shr to <2 x i64>
  store <2 x i64> %r, ptr %res
  ret void
}
