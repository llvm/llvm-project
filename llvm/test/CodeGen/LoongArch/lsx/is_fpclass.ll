; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc --mtriple=loongarch32 --mattr=+32s,+lsx --verify-machineinstrs < %s | FileCheck %s --check-prefixes=CHECK,LA32
; RUN: llc --mtriple=loongarch64 --mattr=+lsx --verify-machineinstrs < %s | FileCheck %s --check-prefixes=CHECK,LA64

define void @isnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vfcmp.cun.s $vr0, $vr0, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 3)  ; "nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isnot_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isnot_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vfcmp.cor.s $vr0, $vr0, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1020)  ; 0x3fc = "zero|subnormal|normal|inf"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @issignaling_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: issignaling_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr0, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vslt.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vand.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1)  ; "snan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_issignaling_v4f32(ptr %res, ptr %a0) {
; LA32-LABEL: not_issignaling_v4f32:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    lu12i.w $a1, 523264
; LA32-NEXT:    vreplgr2vr.w $vr1, $a1
; LA32-NEXT:    vbitclri.w $vr0, $vr0, 31
; LA32-NEXT:    vslt.w $vr1, $vr0, $vr1
; LA32-NEXT:    lu12i.w $a1, 522240
; LA32-NEXT:    vreplgr2vr.w $vr2, $a1
; LA32-NEXT:    vslt.w $vr0, $vr2, $vr0
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vrepli.b $vr1, -1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issignaling_v4f32:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu12i.w $a1, 523264
; LA64-NEXT:    vreplgr2vr.w $vr1, $a1
; LA64-NEXT:    vbitclri.w $vr0, $vr0, 31
; LA64-NEXT:    vslt.w $vr1, $vr0, $vr1
; LA64-NEXT:    lu12i.w $a1, 522240
; LA64-NEXT:    vreplgr2vr.w $vr2, $a1
; LA64-NEXT:    vslt.w $vr0, $vr2, $vr0
; LA64-NEXT:    vand.v $vr0, $vr0, $vr1
; LA64-NEXT:    vbitrevi.w $vr0, $vr0, 0
; LA64-NEXT:    vslli.w $vr0, $vr0, 31
; LA64-NEXT:    vsrai.w $vr0, $vr0, 31
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1022)  ; ~"snan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isquiet_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isquiet_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsle.w $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 2)  ; "qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_isquiet_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_isquiet_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1021)  ; ~"qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isinf_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isinf_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vfcmp.ceq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 516)  ; 0x204 = "inf"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_isinf_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_isinf_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vfcmp.cune.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 507)  ; ~0x204 = "~inf"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_inf_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_inf_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vfcmp.ceq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 512)  ; 0x200 = "+inf"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_minus_inf_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_minus_inf_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vfcmp.ceq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 4)  ; "-inf"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_minus_inf_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vfcmp.cune.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1019)  ; ~"-inf"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isfinite_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isfinite_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vfcmp.cne.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 504)  ; 0x1f8 = "finite"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_isfinite_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_isfinite_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsle.w $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 519)  ; ~0x1f8 = "~finite"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_finite_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_finite_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 448)  ; 0x1c0 = "+finite"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_plus_finite_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_plus_finite_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vsle.wu $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 575)  ; ~0x1c0 = ~"+finite"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_minus_finite_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_minus_finite_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr2, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr2, $vr1
; CHECK-NEXT:    vslti.w $vr0, $vr0, 0
; CHECK-NEXT:    vand.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 56)  ; 0x38 = "-finite"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_minus_finite_v4f32(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_finite_v4f32:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    lu12i.w $a1, 522240
; LA32-NEXT:    vreplgr2vr.w $vr1, $a1
; LA32-NEXT:    vbitclri.w $vr2, $vr0, 31
; LA32-NEXT:    vslt.w $vr1, $vr2, $vr1
; LA32-NEXT:    vslti.w $vr0, $vr0, 0
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vrepli.b $vr1, -1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_finite_v4f32:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu12i.w $a1, 522240
; LA64-NEXT:    vreplgr2vr.w $vr1, $a1
; LA64-NEXT:    vbitclri.w $vr2, $vr0, 31
; LA64-NEXT:    vslt.w $vr1, $vr2, $vr1
; LA64-NEXT:    vslti.w $vr0, $vr0, 0
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vbitrevi.w $vr0, $vr0, 0
; LA64-NEXT:    vslli.w $vr0, $vr0, 31
; LA64-NEXT:    vsrai.w $vr0, $vr0, 31
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 967)  ; ~0x38 = ~"-finite"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isnormal_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isnormal_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vldi $vr1, -3456
; CHECK-NEXT:    vsub.w $vr0, $vr0, $vr1
; CHECK-NEXT:    vldi $vr1, -3201
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 264)  ; 0x108 = "normal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_isnormal_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_isnormal_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vldi $vr1, -3456
; CHECK-NEXT:    vsub.w $vr0, $vr0, $vr1
; CHECK-NEXT:    vldi $vr1, -3201
; CHECK-NEXT:    vsle.wu $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 759)  ; ~0x108 = "~normal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_normal_v4f32(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_normal_v4f32:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    vbitclri.w $vr1, $vr0, 31
; LA32-NEXT:    vldi $vr2, -3456
; LA32-NEXT:    vsub.w $vr1, $vr1, $vr2
; LA32-NEXT:    vldi $vr2, -3201
; LA32-NEXT:    vslt.wu $vr1, $vr1, $vr2
; LA32-NEXT:    vslti.w $vr0, $vr0, 0
; LA32-NEXT:    vandn.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_normal_v4f32:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    vbitclri.w $vr1, $vr0, 31
; LA64-NEXT:    vldi $vr2, -3456
; LA64-NEXT:    vsub.w $vr1, $vr1, $vr2
; LA64-NEXT:    vldi $vr2, -3201
; LA64-NEXT:    vslt.wu $vr1, $vr1, $vr2
; LA64-NEXT:    vslti.w $vr0, $vr0, 0
; LA64-NEXT:    vbitrevi.w $vr0, $vr0, 0
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vslli.w $vr0, $vr0, 31
; LA64-NEXT:    vsrai.w $vr0, $vr0, 31
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 256)  ; 0x100 = "+normal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @issubnormal_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: issubnormal_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsubi.wu $vr0, $vr0, 1
; CHECK-NEXT:    vldi $vr1, -2177
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 144)  ; 0x90 = "subnormal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_issubnormal_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_issubnormal_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsubi.wu $vr0, $vr0, 1
; CHECK-NEXT:    vldi $vr1, -2177
; CHECK-NEXT:    vsle.wu $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 879)  ; ~0x90 = "~subnormal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_subnormal_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_subnormal_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vsubi.wu $vr0, $vr0, 1
; CHECK-NEXT:    vldi $vr1, -2177
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 128)  ; 0x80 = "+subnormal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_plus_subnormal_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_plus_subnormal_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vsubi.wu $vr0, $vr0, 1
; CHECK-NEXT:    vldi $vr1, -2177
; CHECK-NEXT:    vsle.wu $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 895)  ; ~0x80 = ~"+subnormal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_minus_subnormal_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_minus_subnormal_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vbitclri.w $vr1, $vr0, 31
; CHECK-NEXT:    vsubi.wu $vr1, $vr1, 1
; CHECK-NEXT:    vldi $vr2, -2177
; CHECK-NEXT:    vslt.wu $vr1, $vr1, $vr2
; CHECK-NEXT:    vslti.w $vr0, $vr0, 0
; CHECK-NEXT:    vand.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 16)  ; 0x10 = "-subnormal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_minus_subnormal_v4f32(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_subnormal_v4f32:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    vbitclri.w $vr1, $vr0, 31
; LA32-NEXT:    vsubi.wu $vr1, $vr1, 1
; LA32-NEXT:    vldi $vr2, -2177
; LA32-NEXT:    vslt.wu $vr1, $vr1, $vr2
; LA32-NEXT:    vslti.w $vr0, $vr0, 0
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vrepli.b $vr1, -1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_subnormal_v4f32:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    vbitclri.w $vr1, $vr0, 31
; LA64-NEXT:    vsubi.wu $vr1, $vr1, 1
; LA64-NEXT:    vldi $vr2, -2177
; LA64-NEXT:    vslt.wu $vr1, $vr1, $vr2
; LA64-NEXT:    vslti.w $vr0, $vr0, 0
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vbitrevi.w $vr0, $vr0, 0
; LA64-NEXT:    vslli.w $vr0, $vr0, 31
; LA64-NEXT:    vsrai.w $vr0, $vr0, 31
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1007)  ; ~0x10 = ~"-subnormal"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @iszero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: iszero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.ceq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 96)  ; 0x60 = "zero"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_iszero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_iszero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.cune.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 927)  ; ~0x60 = "~zero"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: issubnormal_or_zero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vand.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 240)  ; 0xf0 = "subnormal|zero"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_issubnormal_or_zero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vand.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vrepli.b $vr1, -1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 783)  ; ~0xf0 = "~(subnormal|zero)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_zero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_zero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 64)  ; 0x40 = "+zero"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_plus_zero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_plus_zero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vrepli.b $vr1, -1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 959)  ; ~0x40 = ~"+zero"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_minus_zero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_minus_zero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vldi $vr1, -3200
; CHECK-NEXT:    vseq.w $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 32)  ; 0x20 = "-zero"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_minus_zero_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_minus_zero_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vldi $vr1, -3200
; CHECK-NEXT:    vseq.w $vr0, $vr0, $vr1
; CHECK-NEXT:    vrepli.b $vr1, -1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 991)  ; ~0x20 = ~"-zero"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isnone_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isnone_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vrepli.b $vr0, 0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 0)
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isany_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isany_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vrepli.b $vr0, -1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1023)
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @iszero_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: iszero_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.cueq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 99)  ; 0x60|0x3 = "zero|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_iszero_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_iszero_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.cne.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 924)  ; ~0x60 = "~(zero|nan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @iszero_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: iszero_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsle.w $vr1, $vr1, $vr0
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 98)  ; 0x60|0x2 = "zero|qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @iszero_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: iszero_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr0, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vslt.w $vr2, $vr2, $vr0
; CHECK-NEXT:    vand.v $vr1, $vr2, $vr1
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 97)  ; 0x60|0x1 = "zero|snan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_iszero_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_iszero_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr0, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vslt.w $vr3, $vr2, $vr0
; CHECK-NEXT:    vand.v $vr1, $vr3, $vr1
; CHECK-NEXT:    vseq.w $vr2, $vr0, $vr2
; CHECK-NEXT:    vsubi.wu $vr3, $vr0, 1
; CHECK-NEXT:    vldi $vr4, -2177
; CHECK-NEXT:    vslt.wu $vr3, $vr3, $vr4
; CHECK-NEXT:    vor.v $vr2, $vr3, $vr2
; CHECK-NEXT:    vor.v $vr1, $vr2, $vr1
; CHECK-NEXT:    vldi $vr2, -3456
; CHECK-NEXT:    vsub.w $vr0, $vr0, $vr2
; CHECK-NEXT:    vldi $vr2, -3201
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 925)  ; ~(0x60|0x2) = "~(zero|qnan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_iszero_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_iszero_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vseq.w $vr1, $vr0, $vr1
; CHECK-NEXT:    vsubi.wu $vr2, $vr0, 1
; CHECK-NEXT:    vldi $vr3, -2177
; CHECK-NEXT:    vslt.wu $vr2, $vr2, $vr3
; CHECK-NEXT:    vor.v $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vsle.w $vr2, $vr2, $vr0
; CHECK-NEXT:    vor.v $vr1, $vr1, $vr2
; CHECK-NEXT:    vldi $vr2, -3456
; CHECK-NEXT:    vsub.w $vr0, $vr0, $vr2
; CHECK-NEXT:    vldi $vr2, -3201
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 926)  ; ~(0x60|0x1) = "~(zero|snan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isinf_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isinf_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsle.w $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 519)  ; 0x204|0x3 = "inf|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_isinf_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_isinf_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vfcmp.cne.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 504)  ; ~(0x204|0x3) = "~(inf|nan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isfinite_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: isfinite_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vfcmp.cune.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 507)  ; 0x1f8|0x3 = "finite|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_isfinite_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_isfinite_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vfcmp.ceq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 516)  ; ~(0x1f8|0x3) = "~(finite|nan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_inf_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_inf_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vfcmp.cueq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 515)  ; 0x200|0x3 = "+inf|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_minus_inf_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_minus_inf_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vfcmp.cueq.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 7)  ; "-inf|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_plus_inf_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_plus_inf_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vfcmp.cne.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 508)  ; ~(0x200|0x3) = "~(+inf|nan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_minus_inf_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vfcmp.cne.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1016)  ; "~(-inf|nan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_inf_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_inf_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr2, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr3, $a1
; CHECK-NEXT:    vslt.w $vr2, $vr3, $vr2
; CHECK-NEXT:    vand.v $vr1, $vr2, $vr1
; CHECK-NEXT:    vseq.w $vr0, $vr0, $vr3
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 513)  ; 0x200|0x1 = "+inf|snan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_plus_inf_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_inf_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vseq.w $vr1, $vr0, $vr1
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsle.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 514)  ; 0x200|0x1 = "+inf|qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_plus_inf_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_plus_inf_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vseq.w $vr1, $vr0, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr2, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vsle.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 510)  ; ~(+inf|snan)
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_plus_inf_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_plus_inf_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr2, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr3, $a1
; CHECK-NEXT:    vslt.w $vr4, $vr3, $vr2
; CHECK-NEXT:    vand.v $vr1, $vr4, $vr1
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr4, $a1
; CHECK-NEXT:    vseq.w $vr0, $vr0, $vr4
; CHECK-NEXT:    vslt.w $vr2, $vr2, $vr3
; CHECK-NEXT:    vor.v $vr0, $vr2, $vr0
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 509)  ; ~(+inf|qnan)
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_minus_inf_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_minus_inf_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr2, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr3, $a1
; CHECK-NEXT:    vslt.w $vr2, $vr3, $vr2
; CHECK-NEXT:    vand.v $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vseq.w $vr0, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 5)  ; "-inf|snan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @is_minus_inf_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: is_minus_inf_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, -2048
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vseq.w $vr1, $vr0, $vr1
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsle.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 6)  ; "-inf|qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_minus_inf_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vseq.w $vr2, $vr0, $vr1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr0, $vr1
; CHECK-NEXT:    vor.v $vr1, $vr1, $vr2
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vsle.w $vr0, $vr2, $vr0
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1018)  ; "~(-inf|snan)"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_minus_inf_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr2, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr3, $a1
; CHECK-NEXT:    vslt.w $vr4, $vr3, $vr2
; CHECK-NEXT:    vand.v $vr1, $vr4, $vr1
; CHECK-NEXT:    vseq.w $vr0, $vr0, $vr3
; CHECK-NEXT:    vslt.w $vr2, $vr2, $vr3
; CHECK-NEXT:    vor.v $vr0, $vr2, $vr0
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 1017)  ; "-inf|qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @issubnormal_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: issubnormal_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr1, $vr0
; CHECK-NEXT:    vsubi.wu $vr0, $vr0, 1
; CHECK-NEXT:    vldi $vr2, -2177
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 147)  ; 0x90|0x3 = "subnormal|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: issubnormal_or_zero_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vldi $vr1, -3456
; CHECK-NEXT:    vfcmp.cult.s $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 243)  ; 0xf0|0x3 = "subnormal|zero|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: issubnormal_or_zero_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr2, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr2, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr3, $a1
; CHECK-NEXT:    vslt.w $vr2, $vr3, $vr2
; CHECK-NEXT:    vand.v $vr1, $vr2, $vr1
; CHECK-NEXT:    vand.v $vr0, $vr0, $vr3
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 241)  ; 0x90|0x1 = "subnormal|snan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: issubnormal_or_zero_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr2, $vr0, 31
; CHECK-NEXT:    vsle.w $vr1, $vr1, $vr2
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vand.v $vr0, $vr0, $vr2
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 242)  ; 0x90|0x2 = "subnormal|qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_nan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_issubnormal_or_nan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vldi $vr1, -3456
; CHECK-NEXT:    vsub.w $vr1, $vr0, $vr1
; CHECK-NEXT:    vldi $vr2, -3201
; CHECK-NEXT:    vslt.wu $vr1, $vr1, $vr2
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vseq.w $vr2, $vr0, $vr2
; CHECK-NEXT:    vseqi.w $vr0, $vr0, 0
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 876)  ; ~(0x90|0x3) = ~"subnormal|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_or_nan_v4f32(ptr %res, ptr %a0) {
; LA32-LABEL: not_issubnormal_or_zero_or_nan_v4f32:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    lu12i.w $a1, 522240
; LA32-NEXT:    vreplgr2vr.w $vr1, $a1
; LA32-NEXT:    vbitclri.w $vr2, $vr0, 31
; LA32-NEXT:    vslt.w $vr2, $vr1, $vr2
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vseqi.w $vr0, $vr0, 0
; LA32-NEXT:    vnor.v $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issubnormal_or_zero_or_nan_v4f32:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu12i.w $a1, 522240
; LA64-NEXT:    vreplgr2vr.w $vr1, $a1
; LA64-NEXT:    vbitclri.w $vr2, $vr0, 31
; LA64-NEXT:    vslt.w $vr2, $vr1, $vr2
; LA64-NEXT:    vand.v $vr0, $vr0, $vr1
; LA64-NEXT:    vseqi.w $vr0, $vr0, 0
; LA64-NEXT:    vor.v $vr0, $vr0, $vr2
; LA64-NEXT:    vbitrevi.w $vr0, $vr0, 0
; LA64-NEXT:    vslli.w $vr0, $vr0, 31
; LA64-NEXT:    vsrai.w $vr0, $vr0, 31
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 780)  ; ~(0xf0|0x3) = ~"subnormal|zero|nan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_or_snan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_issubnormal_or_zero_or_snan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vsle.w $vr1, $vr1, $vr0
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vseq.w $vr2, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr1, $vr2, $vr1
; CHECK-NEXT:    vldi $vr2, -3456
; CHECK-NEXT:    vsub.w $vr0, $vr0, $vr2
; CHECK-NEXT:    vldi $vr2, -3201
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 782)  ; ~(0x90|0x1) = ~"subnormal|snan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_or_qnan_v4f32(ptr %res, ptr %a0) {
; CHECK-LABEL: not_issubnormal_or_zero_or_qnan_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    lu12i.w $a1, 523264
; CHECK-NEXT:    vreplgr2vr.w $vr1, $a1
; CHECK-NEXT:    vbitclri.w $vr0, $vr0, 31
; CHECK-NEXT:    vslt.w $vr1, $vr0, $vr1
; CHECK-NEXT:    lu12i.w $a1, 522240
; CHECK-NEXT:    vreplgr2vr.w $vr2, $a1
; CHECK-NEXT:    vslt.w $vr3, $vr2, $vr0
; CHECK-NEXT:    vand.v $vr1, $vr3, $vr1
; CHECK-NEXT:    vseq.w $vr2, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr1, $vr2, $vr1
; CHECK-NEXT:    vldi $vr2, -3456
; CHECK-NEXT:    vsub.w $vr0, $vr0, $vr2
; CHECK-NEXT:    vldi $vr2, -3201
; CHECK-NEXT:    vslt.wu $vr0, $vr0, $vr2
; CHECK-NEXT:    vor.v $vr0, $vr1, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <4 x float>, ptr %a0
  %class = tail call <4 x i1> @llvm.is.fpclass.v4f32(<4 x float> %x, i32 781)  ; ~(0x90|0x2) = ~"subnormal|qnan"
  %ext = sext <4 x i1> %class to <4 x i32>
  store <4 x i32> %ext, ptr %res
  ret void
}

define void @isnan_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: isnan_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vfcmp.cun.d $vr0, $vr0, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 3)  ; "nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isnot_nan_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: isnot_nan_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vfcmp.cor.d $vr0, $vr0, $vr0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1020)  ; 0x3fc = "zero|subnormal|normal|inf"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @issignaling_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: issignaling_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI68_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI68_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI68_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI68_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI68_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI68_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr0, $vr2
; LA32-NEXT:    vslt.d $vr0, $vr3, $vr0
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: issignaling_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr1, $vr0
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.d $vr0, $vr0, $vr2
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1)  ; "snan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_issignaling_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_issignaling_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI69_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI69_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI69_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI69_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI69_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI69_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr0, $vr2
; LA32-NEXT:    vslt.d $vr0, $vr3, $vr0
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vrepli.w $vr1, 1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslli.d $vr0, $vr0, 63
; LA32-NEXT:    vsrai.d $vr0, $vr0, 63
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issignaling_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr1, $vr0
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.d $vr0, $vr0, $vr2
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vrepli.b $vr1, -1
; LA64-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1022)  ; ~"snan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isquiet_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: isquiet_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI70_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI70_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI70_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI70_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsle.d $vr0, $vr2, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: isquiet_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vsle.d $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 2)  ; "qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_isquiet_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_isquiet_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI71_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI71_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI71_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI71_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_isquiet_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vslt.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1021)  ; ~"qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isinf_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: isinf_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    pcalau12i $a2, %pc_hi20(.LCPI72_0)
; LA32-NEXT:    vld $vr0, $a2, %pc_lo12(.LCPI72_0)
; LA32-NEXT:    vld $vr1, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI72_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI72_1)
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: isinf_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 516)  ; 0x204 = "inf"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_isinf_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_isinf_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    pcalau12i $a2, %pc_hi20(.LCPI73_0)
; LA32-NEXT:    vld $vr0, $a2, %pc_lo12(.LCPI73_0)
; LA32-NEXT:    vld $vr1, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI73_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI73_1)
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vfcmp.cune.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_isinf_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vfcmp.cune.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 507)  ; ~0x204 = "~inf"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_inf_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_inf_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI74_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI74_0)
; LA32-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_inf_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 512)  ; 0x200 = "+inf"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_minus_inf_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_minus_inf_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI75_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI75_0)
; LA32-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_minus_inf_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 4)  ; "-inf"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_inf_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI76_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI76_0)
; LA32-NEXT:    vfcmp.cune.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_inf_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vfcmp.cune.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1019)  ; ~"-inf"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isfinite_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: isfinite_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    pcalau12i $a2, %pc_hi20(.LCPI77_0)
; LA32-NEXT:    vld $vr0, $a2, %pc_lo12(.LCPI77_0)
; LA32-NEXT:    vld $vr1, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI77_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI77_1)
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: isfinite_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 504)  ; 0x1f8 = "finite"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_isfinite_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_isfinite_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI78_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI78_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI78_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI78_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsle.d $vr0, $vr2, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_isfinite_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vsle.d $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 519)  ; ~0x1f8 = "~finite"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_finite_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_finite_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI79_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI79_0)
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_finite_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 448)  ; 0x1c0 = "+finite"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_plus_finite_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_plus_finite_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI80_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI80_0)
; LA32-NEXT:    vsle.du $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_plus_finite_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vsle.du $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 575)  ; ~0x1c0 = ~"+finite"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_minus_finite_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_minus_finite_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI81_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI81_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI81_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI81_1)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr1, $vr2
; LA32-NEXT:    vslti.d $vr0, $vr0, 0
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_minus_finite_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr2, $vr1
; LA64-NEXT:    vslti.d $vr0, $vr0, 0
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 56)  ; 0x38 = "-finite"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_minus_finite_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_finite_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI82_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI82_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI82_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI82_1)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr1, $vr2
; LA32-NEXT:    vslti.d $vr0, $vr0, 0
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vrepli.w $vr1, 1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslli.d $vr0, $vr0, 63
; LA32-NEXT:    vsrai.d $vr0, $vr0, 63
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_finite_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr2, $vr1
; LA64-NEXT:    vslti.d $vr0, $vr0, 0
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vrepli.b $vr1, -1
; LA64-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 967)  ; ~0x38 = ~"-finite"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: isnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI83_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI83_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI83_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI83_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI83_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI83_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr3
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: isnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vsub.d $vr0, $vr0, $vr1
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 264)  ; 0x108 = "normal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_isnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_isnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI84_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI84_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI84_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI84_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI84_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI84_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA32-NEXT:    vsle.du $vr0, $vr3, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_isnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vsub.d $vr0, $vr0, $vr1
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vsle.du $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 759)  ; ~0x108 = "~normal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_normal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_normal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    vslti.d $vr1, $vr0, 0
; LA32-NEXT:    vrepli.w $vr2, 1
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI85_0)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI85_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI85_1)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI85_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI85_2)
; LA32-NEXT:    vld $vr5, $a1, %pc_lo12(.LCPI85_2)
; LA32-NEXT:    vxor.v $vr1, $vr1, $vr2
; LA32-NEXT:    vand.v $vr0, $vr0, $vr3
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr4
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr5
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslli.d $vr0, $vr0, 63
; LA32-NEXT:    vsrai.d $vr0, $vr0, 63
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_normal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vsub.d $vr1, $vr2, $vr1
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.du $vr1, $vr1, $vr2
; LA64-NEXT:    vslti.d $vr0, $vr0, 0
; LA64-NEXT:    vandn.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 256)  ; 0x100 = "+normal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @issubnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: issubnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI86_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI86_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI86_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI86_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsubi.du $vr0, $vr0, 1
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: issubnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vsubi.du $vr0, $vr0, 1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 144)  ; 0x90 = "subnormal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_issubnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_issubnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI87_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI87_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI87_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI87_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsubi.du $vr0, $vr0, 1
; LA32-NEXT:    vsle.du $vr0, $vr2, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issubnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vsubi.du $vr0, $vr0, 1
; LA64-NEXT:    vsle.du $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 879)  ; ~0x90 = "~subnormal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_subnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_subnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI88_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI88_0)
; LA32-NEXT:    vsubi.du $vr0, $vr0, 1
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_subnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vsubi.du $vr0, $vr0, 1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 128)  ; 0x80 = "+subnormal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_plus_subnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_plus_subnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI89_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI89_0)
; LA32-NEXT:    vsubi.du $vr0, $vr0, 1
; LA32-NEXT:    vsle.du $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_plus_subnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    vsubi.du $vr0, $vr0, 1
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vsle.du $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 895)  ; ~0x80 = ~"+subnormal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_minus_subnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_minus_subnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI90_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI90_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI90_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI90_1)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vsubi.du $vr1, $vr1, 1
; LA32-NEXT:    vslt.du $vr1, $vr1, $vr2
; LA32-NEXT:    vslti.d $vr0, $vr0, 0
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_minus_subnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vsubi.du $vr2, $vr2, 1
; LA64-NEXT:    vslt.du $vr1, $vr2, $vr1
; LA64-NEXT:    vslti.d $vr0, $vr0, 0
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 16)  ; 0x10 = "-subnormal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_minus_subnormal_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_subnormal_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI91_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI91_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI91_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI91_1)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vsubi.du $vr1, $vr1, 1
; LA32-NEXT:    vslt.du $vr1, $vr1, $vr2
; LA32-NEXT:    vslti.d $vr0, $vr0, 0
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vbitrevi.d $vr0, $vr0, 0
; LA32-NEXT:    vslli.d $vr0, $vr0, 63
; LA32-NEXT:    vsrai.d $vr0, $vr0, 63
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_subnormal_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vsubi.du $vr2, $vr2, 1
; LA64-NEXT:    vslt.du $vr1, $vr2, $vr1
; LA64-NEXT:    vslti.d $vr0, $vr0, 0
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vrepli.b $vr1, -1
; LA64-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1007)  ; ~0x10 = ~"-subnormal"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @iszero_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: iszero_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 96)  ; 0x60 = "zero"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_iszero_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: not_iszero_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.cune.d $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 927)  ; ~0x60 = "~zero"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: issubnormal_or_zero_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI94_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI94_0)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vseqi.d $vr0, $vr0, 0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: issubnormal_or_zero_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vand.v $vr0, $vr0, $vr1
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 240)  ; 0xf0 = "subnormal|zero"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_issubnormal_or_zero_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI95_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI95_0)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vseqi.d $vr0, $vr0, 0
; LA32-NEXT:    vrepli.b $vr1, -1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issubnormal_or_zero_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vand.v $vr0, $vr0, $vr1
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vrepli.b $vr1, -1
; LA64-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 783)  ; ~0xf0 = "~(subnormal|zero)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_zero_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: is_plus_zero_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vseqi.d $vr0, $vr0, 0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 64)  ; 0x40 = "+zero"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_plus_zero_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: not_is_plus_zero_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vseqi.d $vr0, $vr0, 0
; CHECK-NEXT:    vrepli.b $vr1, -1
; CHECK-NEXT:    vxor.v $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 959)  ; ~0x40 = ~"+zero"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_minus_zero_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_minus_zero_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI98_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI98_0)
; LA32-NEXT:    vseq.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_minus_zero_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -2048
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 32)  ; 0x20 = "-zero"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_minus_zero_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_zero_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI99_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI99_0)
; LA32-NEXT:    vseq.d $vr0, $vr0, $vr1
; LA32-NEXT:    vrepli.b $vr1, -1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_zero_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -2048
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vrepli.b $vr1, -1
; LA64-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 991)  ; ~0x20 = ~"-zero"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isnone_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: isnone_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vrepli.b $vr0, 0
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 0)
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isany_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: isany_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vrepli.b $vr0, -1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1023)
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @iszero_or_nan_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: iszero_or_nan_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.cueq.d $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 99)  ; 0x60|0x3 = "zero|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_iszero_or_nan_v2f64(ptr %res, ptr %a0) {
; CHECK-LABEL: not_iszero_or_nan_v2f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vld $vr0, $a1, 0
; CHECK-NEXT:    vrepli.b $vr1, 0
; CHECK-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr1
; CHECK-NEXT:    vst $vr0, $a0, 0
; CHECK-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 924)  ; ~0x60 = "~(zero|nan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @iszero_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: iszero_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI104_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI104_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI104_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI104_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsle.d $vr1, $vr2, $vr0
; LA32-NEXT:    vseqi.d $vr0, $vr0, 0
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: iszero_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vsle.d $vr1, $vr1, $vr0
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 98)  ; 0x60|0x2 = "zero|qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @iszero_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: iszero_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI105_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI105_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI105_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI105_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI105_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI105_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr0, $vr2
; LA32-NEXT:    vslt.d $vr2, $vr3, $vr0
; LA32-NEXT:    vand.v $vr1, $vr2, $vr1
; LA32-NEXT:    vseqi.d $vr0, $vr0, 0
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: iszero_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr1, $vr0
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.d $vr2, $vr0, $vr2
; LA64-NEXT:    vand.v $vr1, $vr1, $vr2
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 97)  ; 0x60|0x1 = "zero|snan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_iszero_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_iszero_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI106_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI106_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI106_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI106_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI106_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI106_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr0, $vr2
; LA32-NEXT:    vslt.d $vr2, $vr3, $vr0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI106_3)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI106_3)
; LA32-NEXT:    vand.v $vr1, $vr2, $vr1
; LA32-NEXT:    vseq.d $vr2, $vr0, $vr3
; LA32-NEXT:    vsubi.du $vr3, $vr0, 1
; LA32-NEXT:    vslt.du $vr3, $vr3, $vr4
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI106_4)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI106_4)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI106_5)
; LA32-NEXT:    vld $vr5, $a1, %pc_lo12(.LCPI106_5)
; LA32-NEXT:    vor.v $vr2, $vr3, $vr2
; LA32-NEXT:    vor.v $vr1, $vr2, $vr1
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr4
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr5
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_iszero_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr2, $vr1, $vr0
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr3, $a1
; LA64-NEXT:    vslt.d $vr3, $vr0, $vr3
; LA64-NEXT:    vand.v $vr2, $vr2, $vr3
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr3, $a1
; LA64-NEXT:    vsubi.du $vr4, $vr0, 1
; LA64-NEXT:    vslt.du $vr3, $vr4, $vr3
; LA64-NEXT:    vor.v $vr1, $vr3, $vr1
; LA64-NEXT:    vor.v $vr1, $vr1, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr2
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 925)  ; ~(0x60|0x2) = "~(zero|qnan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_iszero_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_iszero_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI107_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI107_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI107_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI107_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI107_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI107_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vseq.d $vr1, $vr0, $vr2
; LA32-NEXT:    vsubi.du $vr2, $vr0, 1
; LA32-NEXT:    vslt.du $vr2, $vr2, $vr3
; LA32-NEXT:    vor.v $vr1, $vr2, $vr1
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI107_3)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI107_3)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI107_4)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI107_4)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI107_5)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI107_5)
; LA32-NEXT:    vsle.d $vr2, $vr2, $vr0
; LA32-NEXT:    vor.v $vr1, $vr1, $vr2
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr3
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr4
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_iszero_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsubi.du $vr3, $vr0, 1
; LA64-NEXT:    vslt.du $vr2, $vr3, $vr2
; LA64-NEXT:    vor.v $vr1, $vr2, $vr1
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsle.d $vr2, $vr2, $vr0
; LA64-NEXT:    vor.v $vr1, $vr1, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr2
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 926)  ; ~(0x60|0x1) = "~(zero|snan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isinf_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: isinf_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI108_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI108_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI108_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI108_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsle.d $vr0, $vr2, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: isinf_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vsle.d $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 519)  ; 0x204|0x3 = "inf|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_isinf_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_isinf_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    pcalau12i $a2, %pc_hi20(.LCPI109_0)
; LA32-NEXT:    vld $vr0, $a2, %pc_lo12(.LCPI109_0)
; LA32-NEXT:    vld $vr1, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI109_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI109_1)
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_isinf_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 504)  ; ~(0x204|0x3) = "~(inf|nan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @isfinite_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: isfinite_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    pcalau12i $a2, %pc_hi20(.LCPI110_0)
; LA32-NEXT:    vld $vr0, $a2, %pc_lo12(.LCPI110_0)
; LA32-NEXT:    vld $vr1, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI110_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI110_1)
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vfcmp.cune.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: isfinite_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vfcmp.cune.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 507)  ; 0x1f8|0x3 = "finite|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_isfinite_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_isfinite_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    pcalau12i $a2, %pc_hi20(.LCPI111_0)
; LA32-NEXT:    vld $vr0, $a2, %pc_lo12(.LCPI111_0)
; LA32-NEXT:    vld $vr1, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI111_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI111_1)
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_isfinite_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vfcmp.ceq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 516)  ; ~(0x1f8|0x3) = "~(finite|nan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_inf_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_inf_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI112_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI112_0)
; LA32-NEXT:    vfcmp.cueq.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_inf_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vfcmp.cueq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 515)  ; 0x200|0x3 = "+inf|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_minus_inf_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_minus_inf_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI113_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI113_0)
; LA32-NEXT:    vfcmp.cueq.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_minus_inf_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vfcmp.cueq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 7)  ; "-inf|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_plus_inf_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_plus_inf_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI114_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI114_0)
; LA32-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_plus_inf_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 508)  ; ~(0x200|0x3) = "~(+inf|nan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_inf_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI115_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI115_0)
; LA32-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_inf_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vfcmp.cne.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1016)  ; "~(-inf|nan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_inf_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_inf_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI116_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI116_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI116_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI116_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI116_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI116_2)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr2, $vr1, $vr2
; LA32-NEXT:    vslt.d $vr1, $vr3, $vr1
; LA32-NEXT:    vand.v $vr1, $vr1, $vr2
; LA32-NEXT:    vseq.d $vr0, $vr0, $vr3
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_inf_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vslt.d $vr3, $vr1, $vr2
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr4, $a1
; LA64-NEXT:    vslt.d $vr2, $vr2, $vr4
; LA64-NEXT:    vand.v $vr2, $vr3, $vr2
; LA64-NEXT:    vseq.d $vr0, $vr0, $vr1
; LA64-NEXT:    vor.v $vr0, $vr0, $vr2
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 513)  ; 0x200|0x1 = "+inf|snan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_plus_inf_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_plus_inf_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI117_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI117_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI117_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI117_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI117_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI117_2)
; LA32-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA32-NEXT:    vand.v $vr0, $vr0, $vr2
; LA32-NEXT:    vsle.d $vr0, $vr3, $vr0
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_plus_inf_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsle.d $vr0, $vr2, $vr0
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 514)  ; 0x200|0x1 = "+inf|qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_plus_inf_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_plus_inf_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI118_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI118_0)
; LA32-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI118_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI118_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI118_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI118_2)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI118_3)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI118_3)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr2
; LA32-NEXT:    vslt.d $vr2, $vr0, $vr3
; LA32-NEXT:    vor.v $vr1, $vr2, $vr1
; LA32-NEXT:    vsle.d $vr0, $vr4, $vr0
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_plus_inf_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr2, $vr0, $vr2
; LA64-NEXT:    vor.v $vr1, $vr2, $vr1
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsle.d $vr0, $vr2, $vr0
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 510)  ; ~(+inf|snan)
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_plus_inf_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_plus_inf_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI119_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI119_0)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI119_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI119_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI119_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI119_2)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI119_3)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI119_3)
; LA32-NEXT:    vslt.d $vr2, $vr1, $vr2
; LA32-NEXT:    vslt.d $vr5, $vr3, $vr1
; LA32-NEXT:    vand.v $vr2, $vr5, $vr2
; LA32-NEXT:    vseq.d $vr0, $vr0, $vr4
; LA32-NEXT:    vslt.d $vr1, $vr1, $vr3
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vor.v $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_plus_inf_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr3, $vr0, $vr2
; LA64-NEXT:    vor.v $vr1, $vr3, $vr1
; LA64-NEXT:    vslt.d $vr2, $vr2, $vr0
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr3, $a1
; LA64-NEXT:    vslt.d $vr0, $vr0, $vr3
; LA64-NEXT:    vand.v $vr0, $vr2, $vr0
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 509)  ; ~(+inf|qnan)
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_minus_inf_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_minus_inf_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI120_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI120_0)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI120_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI120_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI120_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI120_2)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI120_3)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI120_3)
; LA32-NEXT:    vslt.d $vr2, $vr1, $vr2
; LA32-NEXT:    vslt.d $vr1, $vr3, $vr1
; LA32-NEXT:    vand.v $vr1, $vr1, $vr2
; LA32-NEXT:    vseq.d $vr0, $vr0, $vr4
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_minus_inf_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr1, $vr2
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr3, $a1
; LA64-NEXT:    vslt.d $vr2, $vr2, $vr3
; LA64-NEXT:    vand.v $vr1, $vr1, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vseq.d $vr0, $vr0, $vr2
; LA64-NEXT:    vor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 5)  ; "-inf|snan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @is_minus_inf_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: is_minus_inf_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI121_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI121_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI121_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI121_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI121_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI121_2)
; LA32-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA32-NEXT:    vand.v $vr0, $vr0, $vr2
; LA32-NEXT:    vsle.d $vr0, $vr3, $vr0
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: is_minus_inf_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, -1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsle.d $vr0, $vr2, $vr0
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 6)  ; "-inf|qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_inf_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI122_1)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI122_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI122_0)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI122_0)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI122_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI122_2)
; LA32-NEXT:    vseq.d $vr0, $vr0, $vr2
; LA32-NEXT:    vslt.d $vr2, $vr1, $vr2
; LA32-NEXT:    vor.v $vr0, $vr2, $vr0
; LA32-NEXT:    vsle.d $vr1, $vr3, $vr1
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_inf_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr2, $vr0, $vr1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr0, $vr1
; LA64-NEXT:    vor.v $vr1, $vr1, $vr2
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsle.d $vr0, $vr2, $vr0
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1018)  ; "~(-inf|snan)"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_is_minus_inf_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_is_minus_inf_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI123_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI123_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI123_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI123_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI123_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI123_2)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr2, $vr1, $vr2
; LA32-NEXT:    vslt.d $vr4, $vr3, $vr1
; LA32-NEXT:    vand.v $vr2, $vr4, $vr2
; LA32-NEXT:    vseq.d $vr0, $vr0, $vr3
; LA32-NEXT:    vslt.d $vr1, $vr1, $vr3
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vor.v $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_is_minus_inf_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vseq.d $vr2, $vr0, $vr1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr3, $vr0, $vr1
; LA64-NEXT:    vor.v $vr2, $vr3, $vr2
; LA64-NEXT:    vslt.d $vr1, $vr1, $vr0
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr3, $a1
; LA64-NEXT:    vslt.d $vr0, $vr0, $vr3
; LA64-NEXT:    vand.v $vr0, $vr1, $vr0
; LA64-NEXT:    vor.v $vr0, $vr2, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 1017)  ; "-inf|qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @issubnormal_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: issubnormal_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI124_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI124_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI124_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI124_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI124_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI124_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr2, $vr0
; LA32-NEXT:    vsubi.du $vr0, $vr0, 1
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr3
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: issubnormal_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr1, $vr1, $vr0
; LA64-NEXT:    addi.w $a1, $zero, -1
; LA64-NEXT:    lu52i.d $a1, $a1, 0
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsubi.du $vr0, $vr0, 1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr2
; LA64-NEXT:    vor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 147)  ; 0x90|0x3 = "subnormal|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: issubnormal_or_zero_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    pcalau12i $a2, %pc_hi20(.LCPI125_0)
; LA32-NEXT:    vld $vr0, $a2, %pc_lo12(.LCPI125_0)
; LA32-NEXT:    vld $vr1, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI125_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI125_1)
; LA32-NEXT:    vand.v $vr0, $vr1, $vr0
; LA32-NEXT:    vfcmp.cult.d $vr0, $vr0, $vr2
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: issubnormal_or_zero_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vfcmp.cult.d $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 243)  ; 0xf0|0x3 = "subnormal|zero|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: issubnormal_or_zero_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI126_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI126_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI126_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI126_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI126_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI126_2)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr2, $vr1, $vr2
; LA32-NEXT:    vslt.d $vr1, $vr3, $vr1
; LA32-NEXT:    vand.v $vr1, $vr1, $vr2
; LA32-NEXT:    vand.v $vr0, $vr0, $vr3
; LA32-NEXT:    vseqi.d $vr0, $vr0, 0
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: issubnormal_or_zero_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vslt.d $vr3, $vr1, $vr2
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr4, $a1
; LA64-NEXT:    vslt.d $vr2, $vr2, $vr4
; LA64-NEXT:    vand.v $vr2, $vr3, $vr2
; LA64-NEXT:    vand.v $vr0, $vr0, $vr1
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vor.v $vr0, $vr0, $vr2
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 241)  ; 0x90|0x1 = "subnormal|snan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @issubnormal_or_zero_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: issubnormal_or_zero_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI127_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI127_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI127_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI127_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI127_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI127_2)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vsle.d $vr1, $vr2, $vr1
; LA32-NEXT:    vand.v $vr0, $vr0, $vr3
; LA32-NEXT:    vseqi.d $vr0, $vr0, 0
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: issubnormal_or_zero_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    vbitclri.d $vr1, $vr0, 63
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsle.d $vr1, $vr2, $vr1
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vand.v $vr0, $vr0, $vr2
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 242)  ; 0x90|0x2 = "subnormal|qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_issubnormal_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI128_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI128_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI128_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI128_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vseq.d $vr1, $vr0, $vr2
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI128_2)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI128_2)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI128_3)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI128_3)
; LA32-NEXT:    vseqi.d $vr4, $vr0, 0
; LA32-NEXT:    vor.v $vr1, $vr4, $vr1
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr3
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issubnormal_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vsub.d $vr1, $vr0, $vr1
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.du $vr1, $vr1, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vseq.d $vr2, $vr0, $vr2
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vor.v $vr0, $vr0, $vr2
; LA64-NEXT:    vor.v $vr0, $vr0, $vr1
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 876)  ; ~(0x90|0x3) = ~"subnormal|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_or_nan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_issubnormal_or_zero_or_nan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI129_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI129_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI129_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI129_1)
; LA32-NEXT:    vand.v $vr1, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr2, $vr1
; LA32-NEXT:    vand.v $vr0, $vr0, $vr2
; LA32-NEXT:    vseqi.d $vr0, $vr0, 0
; LA32-NEXT:    vor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vrepli.w $vr1, 1
; LA32-NEXT:    vxor.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslli.d $vr0, $vr0, 63
; LA32-NEXT:    vsrai.d $vr0, $vr0, 63
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issubnormal_or_zero_or_nan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr2, $vr0, 63
; LA64-NEXT:    vslt.d $vr2, $vr1, $vr2
; LA64-NEXT:    vand.v $vr0, $vr0, $vr1
; LA64-NEXT:    vseqi.d $vr0, $vr0, 0
; LA64-NEXT:    vnor.v $vr0, $vr0, $vr2
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 780)  ; ~(0xf0|0x3) = ~"subnormal|zero|nan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_or_snan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_issubnormal_or_zero_or_snan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI130_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI130_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI130_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI130_1)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vsle.d $vr1, $vr2, $vr0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI130_2)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI130_2)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI130_3)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI130_3)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI130_4)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI130_4)
; LA32-NEXT:    vseq.d $vr2, $vr0, $vr2
; LA32-NEXT:    vor.v $vr1, $vr2, $vr1
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr3
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr4
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issubnormal_or_zero_or_snan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsle.d $vr2, $vr2, $vr0
; LA64-NEXT:    vor.v $vr1, $vr1, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr2
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 782)  ; ~(0x90|0x1) = ~"subnormal|snan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

define void @not_issubnormal_or_zero_or_qnan_v2f64(ptr %res, ptr %a0) {
; LA32-LABEL: not_issubnormal_or_zero_or_qnan_v2f64:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    vld $vr0, $a1, 0
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI131_0)
; LA32-NEXT:    vld $vr1, $a1, %pc_lo12(.LCPI131_0)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI131_1)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI131_1)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI131_2)
; LA32-NEXT:    vld $vr3, $a1, %pc_lo12(.LCPI131_2)
; LA32-NEXT:    vand.v $vr0, $vr0, $vr1
; LA32-NEXT:    vslt.d $vr1, $vr0, $vr2
; LA32-NEXT:    vslt.d $vr2, $vr3, $vr0
; LA32-NEXT:    vand.v $vr1, $vr2, $vr1
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI131_3)
; LA32-NEXT:    vld $vr2, $a1, %pc_lo12(.LCPI131_3)
; LA32-NEXT:    pcalau12i $a1, %pc_hi20(.LCPI131_4)
; LA32-NEXT:    vld $vr4, $a1, %pc_lo12(.LCPI131_4)
; LA32-NEXT:    vseq.d $vr3, $vr0, $vr3
; LA32-NEXT:    vor.v $vr1, $vr3, $vr1
; LA32-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA32-NEXT:    vslt.du $vr0, $vr0, $vr4
; LA32-NEXT:    vor.v $vr0, $vr1, $vr0
; LA32-NEXT:    vst $vr0, $a0, 0
; LA32-NEXT:    ret
;
; LA64-LABEL: not_issubnormal_or_zero_or_qnan_v2f64:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    vld $vr0, $a1, 0
; LA64-NEXT:    lu52i.d $a1, $zero, 2047
; LA64-NEXT:    vreplgr2vr.d $vr1, $a1
; LA64-NEXT:    vbitclri.d $vr0, $vr0, 63
; LA64-NEXT:    vslt.d $vr2, $vr1, $vr0
; LA64-NEXT:    ori $a1, $zero, 0
; LA64-NEXT:    lu32i.d $a1, -524288
; LA64-NEXT:    lu52i.d $a1, $a1, 2047
; LA64-NEXT:    vreplgr2vr.d $vr3, $a1
; LA64-NEXT:    vslt.d $vr3, $vr0, $vr3
; LA64-NEXT:    vand.v $vr2, $vr2, $vr3
; LA64-NEXT:    vseq.d $vr1, $vr0, $vr1
; LA64-NEXT:    vor.v $vr1, $vr1, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 1
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vsub.d $vr0, $vr0, $vr2
; LA64-NEXT:    lu52i.d $a1, $zero, 2046
; LA64-NEXT:    vreplgr2vr.d $vr2, $a1
; LA64-NEXT:    vslt.du $vr0, $vr0, $vr2
; LA64-NEXT:    vor.v $vr0, $vr1, $vr0
; LA64-NEXT:    vst $vr0, $a0, 0
; LA64-NEXT:    ret
entry:
  %x = load <2 x double>, ptr %a0
  %class = tail call <2 x i1> @llvm.is.fpclass.v2f64(<2 x double> %x, i32 781)  ; ~(0x90|0x2) = ~"subnormal|qnan"
  %ext = sext <2 x i1> %class to <2 x i64>
  store <2 x i64> %ext, ptr %res
  ret void
}

declare <4 x i1> @llvm.is.fpclass.v4f32(<4 x float>, i32)
declare <2 x i1> @llvm.is.fpclass.v2f64(<2 x double>, i32)
