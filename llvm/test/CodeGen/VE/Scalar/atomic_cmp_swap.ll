; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=ve | FileCheck %s

;;; Test atomic compare and exchange weak for all types and all memory order
;;;
;;; Note:
;;;   - We test i1/i8/i16/i32/i64/i128/u8/u16/u32/u64/u128.
;;;   - We test relaxed, acquire, and seq_cst.
;;;   - We test only exchange with variables since VE doesn't have exchange
;;;     instructions with immediate values.
;;;   - We test against an object, a stack object, and a global variable.

%"struct.std::__1::atomic" = type { %"struct.std::__1::__atomic_base" }
%"struct.std::__1::__atomic_base" = type { %"struct.std::__1::__cxx_atomic_impl" }
%"struct.std::__1::__cxx_atomic_impl" = type { %"struct.std::__1::__cxx_atomic_base_impl" }
%"struct.std::__1::__cxx_atomic_base_impl" = type { i8 }
%"struct.std::__1::atomic.0" = type { %"struct.std::__1::__atomic_base.1" }
%"struct.std::__1::__atomic_base.1" = type { %"struct.std::__1::__atomic_base.2" }
%"struct.std::__1::__atomic_base.2" = type { %"struct.std::__1::__cxx_atomic_impl.3" }
%"struct.std::__1::__cxx_atomic_impl.3" = type { %"struct.std::__1::__cxx_atomic_base_impl.4" }
%"struct.std::__1::__cxx_atomic_base_impl.4" = type { i8 }
%"struct.std::__1::atomic.5" = type { %"struct.std::__1::__atomic_base.6" }
%"struct.std::__1::__atomic_base.6" = type { %"struct.std::__1::__atomic_base.7" }
%"struct.std::__1::__atomic_base.7" = type { %"struct.std::__1::__cxx_atomic_impl.8" }
%"struct.std::__1::__cxx_atomic_impl.8" = type { %"struct.std::__1::__cxx_atomic_base_impl.9" }
%"struct.std::__1::__cxx_atomic_base_impl.9" = type { i8 }
%"struct.std::__1::atomic.10" = type { %"struct.std::__1::__atomic_base.11" }
%"struct.std::__1::__atomic_base.11" = type { %"struct.std::__1::__atomic_base.12" }
%"struct.std::__1::__atomic_base.12" = type { %"struct.std::__1::__cxx_atomic_impl.13" }
%"struct.std::__1::__cxx_atomic_impl.13" = type { %"struct.std::__1::__cxx_atomic_base_impl.14" }
%"struct.std::__1::__cxx_atomic_base_impl.14" = type { i16 }
%"struct.std::__1::atomic.15" = type { %"struct.std::__1::__atomic_base.16" }
%"struct.std::__1::__atomic_base.16" = type { %"struct.std::__1::__atomic_base.17" }
%"struct.std::__1::__atomic_base.17" = type { %"struct.std::__1::__cxx_atomic_impl.18" }
%"struct.std::__1::__cxx_atomic_impl.18" = type { %"struct.std::__1::__cxx_atomic_base_impl.19" }
%"struct.std::__1::__cxx_atomic_base_impl.19" = type { i16 }
%"struct.std::__1::atomic.20" = type { %"struct.std::__1::__atomic_base.21" }
%"struct.std::__1::__atomic_base.21" = type { %"struct.std::__1::__atomic_base.22" }
%"struct.std::__1::__atomic_base.22" = type { %"struct.std::__1::__cxx_atomic_impl.23" }
%"struct.std::__1::__cxx_atomic_impl.23" = type { %"struct.std::__1::__cxx_atomic_base_impl.24" }
%"struct.std::__1::__cxx_atomic_base_impl.24" = type { i32 }
%"struct.std::__1::atomic.25" = type { %"struct.std::__1::__atomic_base.26" }
%"struct.std::__1::__atomic_base.26" = type { %"struct.std::__1::__atomic_base.27" }
%"struct.std::__1::__atomic_base.27" = type { %"struct.std::__1::__cxx_atomic_impl.28" }
%"struct.std::__1::__cxx_atomic_impl.28" = type { %"struct.std::__1::__cxx_atomic_base_impl.29" }
%"struct.std::__1::__cxx_atomic_base_impl.29" = type { i32 }
%"struct.std::__1::atomic.30" = type { %"struct.std::__1::__atomic_base.31" }
%"struct.std::__1::__atomic_base.31" = type { %"struct.std::__1::__atomic_base.32" }
%"struct.std::__1::__atomic_base.32" = type { %"struct.std::__1::__cxx_atomic_impl.33" }
%"struct.std::__1::__cxx_atomic_impl.33" = type { %"struct.std::__1::__cxx_atomic_base_impl.34" }
%"struct.std::__1::__cxx_atomic_base_impl.34" = type { i64 }
%"struct.std::__1::atomic.35" = type { %"struct.std::__1::__atomic_base.36" }
%"struct.std::__1::__atomic_base.36" = type { %"struct.std::__1::__atomic_base.37" }
%"struct.std::__1::__atomic_base.37" = type { %"struct.std::__1::__cxx_atomic_impl.38" }
%"struct.std::__1::__cxx_atomic_impl.38" = type { %"struct.std::__1::__cxx_atomic_base_impl.39" }
%"struct.std::__1::__cxx_atomic_base_impl.39" = type { i64 }
%"struct.std::__1::atomic.40" = type { %"struct.std::__1::__atomic_base.41" }
%"struct.std::__1::__atomic_base.41" = type { %"struct.std::__1::__atomic_base.42" }
%"struct.std::__1::__atomic_base.42" = type { %"struct.std::__1::__cxx_atomic_impl.43" }
%"struct.std::__1::__cxx_atomic_impl.43" = type { %"struct.std::__1::__cxx_atomic_base_impl.44" }
%"struct.std::__1::__cxx_atomic_base_impl.44" = type { i128 }
%"struct.std::__1::atomic.45" = type { %"struct.std::__1::__atomic_base.46" }
%"struct.std::__1::__atomic_base.46" = type { %"struct.std::__1::__atomic_base.47" }
%"struct.std::__1::__atomic_base.47" = type { %"struct.std::__1::__cxx_atomic_impl.48" }
%"struct.std::__1::__cxx_atomic_impl.48" = type { %"struct.std::__1::__cxx_atomic_base_impl.49" }
%"struct.std::__1::__cxx_atomic_base_impl.49" = type { i128 }

@gv_i1 = global %"struct.std::__1::atomic" zeroinitializer, align 4
@gv_i8 = global %"struct.std::__1::atomic.0" zeroinitializer, align 4
@gv_u8 = global %"struct.std::__1::atomic.5" zeroinitializer, align 4
@gv_i16 = global %"struct.std::__1::atomic.10" zeroinitializer, align 4
@gv_u16 = global %"struct.std::__1::atomic.15" zeroinitializer, align 4
@gv_i32 = global %"struct.std::__1::atomic.20" zeroinitializer, align 4
@gv_u32 = global %"struct.std::__1::atomic.25" zeroinitializer, align 4
@gv_i64 = global %"struct.std::__1::atomic.30" zeroinitializer, align 8
@gv_u64 = global %"struct.std::__1::atomic.35" zeroinitializer, align 8
@gv_i128 = global %"struct.std::__1::atomic.40" zeroinitializer, align 16
@gv_u128 = global %"struct.std::__1::atomic.45" zeroinitializer, align 16

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i1 @_Z26atomic_cmp_swap_relaxed_i1RNSt3__16atomicIbEERbb(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i1 zeroext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_relaxed_i1RNSt3__16atomicIbEERbb:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (56)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB0_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB0_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = zext i1 %arg2 to i8
  %i4 = load i8, ptr %arg1, align 1
  %i5 = cmpxchg weak ptr %arg, i8 %i4, i8 %i monotonic monotonic, align 1
  %i6 = extractvalue { i8, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i8, i1 } %i5, 0
  store i8 %i8, ptr %arg1, align 1
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  ret i1 %i6
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i8 @_Z26atomic_cmp_swap_relaxed_i8RNSt3__16atomicIcEERcc(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i8 signext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_relaxed_i8RNSt3__16atomicIcEERcc:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    sla.w.sx %s6, (56)0, %s0
; CHECK-NEXT:    ldl.sx %s7, (, %s3)
; CHECK-NEXT:    and %s2, %s2, (56)0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s6, %s7
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB1_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB1_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i8, ptr %arg1, align 1
  %i4 = cmpxchg weak ptr %arg, i8 %i3, i8 %arg2 monotonic monotonic, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg1, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  ret i8 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i8 @_Z26atomic_cmp_swap_relaxed_u8RNSt3__16atomicIhEERhh(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i8 zeroext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_relaxed_u8RNSt3__16atomicIhEERhh:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (56)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB2_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB2_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i8, ptr %arg1, align 1
  %i4 = cmpxchg weak ptr %arg, i8 %i3, i8 %arg2 monotonic monotonic, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg1, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  ret i8 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i16 @_Z27atomic_cmp_swap_relaxed_i16RNSt3__16atomicIsEERss(ptr nocapture nonnull align 2 dereferenceable(2) %arg, ptr nocapture nonnull align 2 dereferenceable(2) %arg1, i16 signext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_relaxed_i16RNSt3__16atomicIsEERss:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld2b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    sla.w.sx %s6, (48)0, %s0
; CHECK-NEXT:    ldl.sx %s7, (, %s3)
; CHECK-NEXT:    and %s2, %s2, (48)0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s6, %s7
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB3_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st2b %s0, (, %s1)
; CHECK-NEXT:  .LBB3_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i16, ptr %arg1, align 2
  %i4 = cmpxchg weak ptr %arg, i16 %i3, i16 %arg2 monotonic monotonic, align 2
  %i5 = extractvalue { i16, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i16, i1 } %i4, 0
  store i16 %i7, ptr %arg1, align 2
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i16
  ret i16 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i16 @_Z27atomic_cmp_swap_relaxed_u16RNSt3__16atomicItEERtt(ptr nocapture nonnull align 2 dereferenceable(2) %arg, ptr nocapture nonnull align 2 dereferenceable(2) %arg1, i16 zeroext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_relaxed_u16RNSt3__16atomicItEERtt:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld2b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (48)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB4_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st2b %s0, (, %s1)
; CHECK-NEXT:  .LBB4_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i16, ptr %arg1, align 2
  %i4 = cmpxchg weak ptr %arg, i16 %i3, i16 %arg2 monotonic monotonic, align 2
  %i5 = extractvalue { i16, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i16, i1 } %i4, 0
  store i16 %i7, ptr %arg1, align 2
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i16
  ret i16 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i32 @_Z27atomic_cmp_swap_relaxed_i32RNSt3__16atomicIiEERii(ptr nocapture nonnull align 4 dereferenceable(4) %arg, ptr nocapture nonnull align 4 dereferenceable(4) %arg1, i32 signext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_relaxed_i32RNSt3__16atomicIiEERii:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s1)
; CHECK-NEXT:    cas.w %s2, (%s0), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s0, (63)0, %s4
; CHECK-NEXT:    breq.w %s2, %s3, .LBB5_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    stl %s2, (, %s1)
; CHECK-NEXT:  .LBB5_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i32, ptr %arg1, align 4
  %i4 = cmpxchg weak ptr %arg, i32 %i3, i32 %arg2 monotonic monotonic, align 4
  %i5 = extractvalue { i32, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i32, i1 } %i4, 0
  store i32 %i7, ptr %arg1, align 4
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i32
  ret i32 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i32 @_Z27atomic_cmp_swap_relaxed_u32RNSt3__16atomicIjEERjj(ptr nocapture nonnull align 4 dereferenceable(4) %arg, ptr nocapture nonnull align 4 dereferenceable(4) %arg1, i32 zeroext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_relaxed_u32RNSt3__16atomicIjEERjj:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s1)
; CHECK-NEXT:    cas.w %s2, (%s0), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s0, (63)0, %s4
; CHECK-NEXT:    breq.w %s2, %s3, .LBB6_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    stl %s2, (, %s1)
; CHECK-NEXT:  .LBB6_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i32, ptr %arg1, align 4
  %i4 = cmpxchg weak ptr %arg, i32 %i3, i32 %arg2 monotonic monotonic, align 4
  %i5 = extractvalue { i32, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i32, i1 } %i4, 0
  store i32 %i7, ptr %arg1, align 4
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i32
  ret i32 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z27atomic_cmp_swap_relaxed_i64RNSt3__16atomicIlEERll(ptr nocapture nonnull align 8 dereferenceable(8) %arg, ptr nocapture nonnull align 8 dereferenceable(8) %arg1, i64 %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_relaxed_i64RNSt3__16atomicIlEERll:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s1)
; CHECK-NEXT:    cas.l %s2, (%s0), %s3
; CHECK-NEXT:    cmps.l %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s0, (63)0, %s4
; CHECK-NEXT:    breq.l %s2, %s3, .LBB7_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st %s2, (, %s1)
; CHECK-NEXT:  .LBB7_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i64, ptr %arg1, align 8
  %i4 = cmpxchg weak ptr %arg, i64 %i3, i64 %arg2 monotonic monotonic, align 8
  %i5 = extractvalue { i64, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i64, i1 } %i4, 0
  store i64 %i7, ptr %arg1, align 8
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i64
  ret i64 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z27atomic_cmp_swap_relaxed_u64RNSt3__16atomicImEERmm(ptr nocapture nonnull align 8 dereferenceable(8) %arg, ptr nocapture nonnull align 8 dereferenceable(8) %arg1, i64 %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_relaxed_u64RNSt3__16atomicImEERmm:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s1)
; CHECK-NEXT:    cas.l %s2, (%s0), %s3
; CHECK-NEXT:    cmps.l %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s0, (63)0, %s4
; CHECK-NEXT:    breq.l %s2, %s3, .LBB8_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st %s2, (, %s1)
; CHECK-NEXT:  .LBB8_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i64, ptr %arg1, align 8
  %i4 = cmpxchg weak ptr %arg, i64 %i3, i64 %arg2 monotonic monotonic, align 8
  %i5 = extractvalue { i64, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i64, i1 } %i4, 0
  store i64 %i7, ptr %arg1, align 8
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i64
  ret i64 %i9
}

; Function Attrs: nounwind mustprogress
define i128 @_Z28atomic_cmp_swap_relaxed_i128RNSt3__16atomicInEERnn(ptr nonnull align 16 dereferenceable(16) %arg, ptr nonnull align 16 dereferenceable(16) %arg1, i128 %arg2) {
; CHECK-LABEL: _Z28atomic_cmp_swap_relaxed_i128RNSt3__16atomicInEERnn:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB9_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB9_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s1
; CHECK-NEXT:    or %s1, 0, %s0
; CHECK-NEXT:    st %s3, 248(, %s11)
; CHECK-NEXT:    st %s2, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 0, (0)1
; CHECK-NEXT:    or %s5, 0, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg2, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %arg, ptr nonnull %arg1, ptr nonnull %i, i32 signext 0, i32 signext 0)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  ret i128 %i7
}

; Function Attrs: nounwind mustprogress
define i128 @_Z28atomic_cmp_swap_relaxed_u128RNSt3__16atomicIoEERoo(ptr nonnull align 16 dereferenceable(16) %arg, ptr nonnull align 16 dereferenceable(16) %arg1, i128 %arg2) {
; CHECK-LABEL: _Z28atomic_cmp_swap_relaxed_u128RNSt3__16atomicIoEERoo:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB10_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB10_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s1
; CHECK-NEXT:    or %s1, 0, %s0
; CHECK-NEXT:    st %s3, 248(, %s11)
; CHECK-NEXT:    st %s2, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 0, (0)1
; CHECK-NEXT:    or %s5, 0, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg2, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %arg, ptr nonnull %arg1, ptr nonnull %i, i32 signext 0, i32 signext 0)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  ret i128 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i1 @_Z26atomic_cmp_swap_acquire_i1RNSt3__16atomicIbEERbb(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i1 zeroext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_acquire_i1RNSt3__16atomicIbEERbb:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (56)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    brne.w 0, %s2, .LBB11_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB11_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = zext i1 %arg2 to i8
  %i4 = load i8, ptr %arg1, align 1
  %i5 = cmpxchg weak ptr %arg, i8 %i4, i8 %i acquire acquire, align 1
  %i6 = extractvalue { i8, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i8, i1 } %i5, 0
  store i8 %i8, ptr %arg1, align 1
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  ret i1 %i6
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i8 @_Z26atomic_cmp_swap_acquire_i8RNSt3__16atomicIcEERcc(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i8 signext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_acquire_i8RNSt3__16atomicIcEERcc:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    sla.w.sx %s6, (56)0, %s0
; CHECK-NEXT:    ldl.sx %s7, (, %s3)
; CHECK-NEXT:    and %s2, %s2, (56)0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s6, %s7
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    brne.w 0, %s2, .LBB12_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB12_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i8, ptr %arg1, align 1
  %i4 = cmpxchg weak ptr %arg, i8 %i3, i8 %arg2 acquire acquire, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg1, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  ret i8 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i8 @_Z26atomic_cmp_swap_acquire_u8RNSt3__16atomicIhEERhh(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i8 zeroext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_acquire_u8RNSt3__16atomicIhEERhh:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (56)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    brne.w 0, %s2, .LBB13_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB13_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i8, ptr %arg1, align 1
  %i4 = cmpxchg weak ptr %arg, i8 %i3, i8 %arg2 acquire acquire, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg1, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  ret i8 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i16 @_Z27atomic_cmp_swap_acquire_i16RNSt3__16atomicIsEERss(ptr nocapture nonnull align 2 dereferenceable(2) %arg, ptr nocapture nonnull align 2 dereferenceable(2) %arg1, i16 signext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_acquire_i16RNSt3__16atomicIsEERss:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld2b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    sla.w.sx %s6, (48)0, %s0
; CHECK-NEXT:    ldl.sx %s7, (, %s3)
; CHECK-NEXT:    and %s2, %s2, (48)0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s6, %s7
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    brne.w 0, %s2, .LBB14_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st2b %s0, (, %s1)
; CHECK-NEXT:  .LBB14_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i16, ptr %arg1, align 2
  %i4 = cmpxchg weak ptr %arg, i16 %i3, i16 %arg2 acquire acquire, align 2
  %i5 = extractvalue { i16, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i16, i1 } %i4, 0
  store i16 %i7, ptr %arg1, align 2
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i16
  ret i16 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i16 @_Z27atomic_cmp_swap_acquire_u16RNSt3__16atomicItEERtt(ptr nocapture nonnull align 2 dereferenceable(2) %arg, ptr nocapture nonnull align 2 dereferenceable(2) %arg1, i16 zeroext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_acquire_u16RNSt3__16atomicItEERtt:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld2b.zx %s4, (, %s1)
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (48)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    brne.w 0, %s2, .LBB15_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st2b %s0, (, %s1)
; CHECK-NEXT:  .LBB15_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i16, ptr %arg1, align 2
  %i4 = cmpxchg weak ptr %arg, i16 %i3, i16 %arg2 acquire acquire, align 2
  %i5 = extractvalue { i16, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i16, i1 } %i4, 0
  store i16 %i7, ptr %arg1, align 2
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i16
  ret i16 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i32 @_Z27atomic_cmp_swap_acquire_i32RNSt3__16atomicIiEERii(ptr nocapture nonnull align 4 dereferenceable(4) %arg, ptr nocapture nonnull align 4 dereferenceable(4) %arg1, i32 signext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_acquire_i32RNSt3__16atomicIiEERii:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s1)
; CHECK-NEXT:    cas.w %s2, (%s0), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    breq.w %s2, %s3, .LBB16_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    stl %s2, (, %s1)
; CHECK-NEXT:  .LBB16_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i32, ptr %arg1, align 4
  %i4 = cmpxchg weak ptr %arg, i32 %i3, i32 %arg2 acquire acquire, align 4
  %i5 = extractvalue { i32, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i32, i1 } %i4, 0
  store i32 %i7, ptr %arg1, align 4
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i32
  ret i32 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i32 @_Z27atomic_cmp_swap_acquire_u32RNSt3__16atomicIjEERjj(ptr nocapture nonnull align 4 dereferenceable(4) %arg, ptr nocapture nonnull align 4 dereferenceable(4) %arg1, i32 zeroext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_acquire_u32RNSt3__16atomicIjEERjj:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s1)
; CHECK-NEXT:    cas.w %s2, (%s0), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    breq.w %s2, %s3, .LBB17_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    stl %s2, (, %s1)
; CHECK-NEXT:  .LBB17_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i32, ptr %arg1, align 4
  %i4 = cmpxchg weak ptr %arg, i32 %i3, i32 %arg2 acquire acquire, align 4
  %i5 = extractvalue { i32, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i32, i1 } %i4, 0
  store i32 %i7, ptr %arg1, align 4
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i32
  ret i32 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z27atomic_cmp_swap_acquire_i64RNSt3__16atomicIlEERll(ptr nocapture nonnull align 8 dereferenceable(8) %arg, ptr nocapture nonnull align 8 dereferenceable(8) %arg1, i64 %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_acquire_i64RNSt3__16atomicIlEERll:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s1)
; CHECK-NEXT:    cas.l %s2, (%s0), %s3
; CHECK-NEXT:    cmps.l %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    breq.l %s2, %s3, .LBB18_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st %s2, (, %s1)
; CHECK-NEXT:  .LBB18_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i64, ptr %arg1, align 8
  %i4 = cmpxchg weak ptr %arg, i64 %i3, i64 %arg2 acquire acquire, align 8
  %i5 = extractvalue { i64, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i64, i1 } %i4, 0
  store i64 %i7, ptr %arg1, align 8
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i64
  ret i64 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z27atomic_cmp_swap_acquire_u64RNSt3__16atomicImEERmm(ptr nocapture nonnull align 8 dereferenceable(8) %arg, ptr nocapture nonnull align 8 dereferenceable(8) %arg1, i64 %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_acquire_u64RNSt3__16atomicImEERmm:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s1)
; CHECK-NEXT:    cas.l %s2, (%s0), %s3
; CHECK-NEXT:    cmps.l %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 2
; CHECK-NEXT:    breq.l %s2, %s3, .LBB19_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st %s2, (, %s1)
; CHECK-NEXT:  .LBB19_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i64, ptr %arg1, align 8
  %i4 = cmpxchg weak ptr %arg, i64 %i3, i64 %arg2 acquire acquire, align 8
  %i5 = extractvalue { i64, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i64, i1 } %i4, 0
  store i64 %i7, ptr %arg1, align 8
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i64
  ret i64 %i9
}

; Function Attrs: nounwind mustprogress
define i128 @_Z28atomic_cmp_swap_acquire_i128RNSt3__16atomicInEERnn(ptr nonnull align 16 dereferenceable(16) %arg, ptr nonnull align 16 dereferenceable(16) %arg1, i128 %arg2) {
; CHECK-LABEL: _Z28atomic_cmp_swap_acquire_i128RNSt3__16atomicInEERnn:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB20_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB20_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s1
; CHECK-NEXT:    or %s1, 0, %s0
; CHECK-NEXT:    st %s3, 248(, %s11)
; CHECK-NEXT:    st %s2, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 2, (0)1
; CHECK-NEXT:    or %s5, 2, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg2, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %arg, ptr nonnull %arg1, ptr nonnull %i, i32 signext 2, i32 signext 2)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  ret i128 %i7
}

; Function Attrs: nounwind mustprogress
define i128 @_Z28atomic_cmp_swap_acquire_u128RNSt3__16atomicIoEERoo(ptr nonnull align 16 dereferenceable(16) %arg, ptr nonnull align 16 dereferenceable(16) %arg1, i128 %arg2) {
; CHECK-LABEL: _Z28atomic_cmp_swap_acquire_u128RNSt3__16atomicIoEERoo:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB21_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB21_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s1
; CHECK-NEXT:    or %s1, 0, %s0
; CHECK-NEXT:    st %s3, 248(, %s11)
; CHECK-NEXT:    st %s2, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 2, (0)1
; CHECK-NEXT:    or %s5, 2, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg2, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %arg, ptr nonnull %arg1, ptr nonnull %i, i32 signext 2, i32 signext 2)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  ret i128 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i1 @_Z26atomic_cmp_swap_seq_cst_i1RNSt3__16atomicIbEERbb(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i1 zeroext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_seq_cst_i1RNSt3__16atomicIbEERbb:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (56)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    brne.w 0, %s2, .LBB22_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB22_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = zext i1 %arg2 to i8
  %i4 = load i8, ptr %arg1, align 1
  %i5 = cmpxchg weak ptr %arg, i8 %i4, i8 %i seq_cst seq_cst, align 1
  %i6 = extractvalue { i8, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i8, i1 } %i5, 0
  store i8 %i8, ptr %arg1, align 1
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  ret i1 %i6
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i8 @_Z26atomic_cmp_swap_seq_cst_i8RNSt3__16atomicIcEERcc(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i8 signext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_seq_cst_i8RNSt3__16atomicIcEERcc:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    sla.w.sx %s6, (56)0, %s0
; CHECK-NEXT:    ldl.sx %s7, (, %s3)
; CHECK-NEXT:    and %s2, %s2, (56)0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s6, %s7
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    brne.w 0, %s2, .LBB23_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB23_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i8, ptr %arg1, align 1
  %i4 = cmpxchg weak ptr %arg, i8 %i3, i8 %arg2 seq_cst seq_cst, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg1, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  ret i8 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i8 @_Z26atomic_cmp_swap_seq_cst_u8RNSt3__16atomicIhEERhh(ptr nocapture nonnull align 1 dereferenceable(1) %arg, ptr nocapture nonnull align 1 dereferenceable(1) %arg1, i8 zeroext %arg2) {
; CHECK-LABEL: _Z26atomic_cmp_swap_seq_cst_u8RNSt3__16atomicIhEERhh:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s4, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (56)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    brne.w 0, %s2, .LBB24_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st1b %s0, (, %s1)
; CHECK-NEXT:  .LBB24_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i8, ptr %arg1, align 1
  %i4 = cmpxchg weak ptr %arg, i8 %i3, i8 %arg2 seq_cst seq_cst, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg1, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  ret i8 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i16 @_Z27atomic_cmp_swap_seq_cst_i16RNSt3__16atomicIsEERss(ptr nocapture nonnull align 2 dereferenceable(2) %arg, ptr nocapture nonnull align 2 dereferenceable(2) %arg1, i16 signext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_seq_cst_i16RNSt3__16atomicIsEERss:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld2b.zx %s4, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    sla.w.sx %s6, (48)0, %s0
; CHECK-NEXT:    ldl.sx %s7, (, %s3)
; CHECK-NEXT:    and %s2, %s2, (48)0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s6, %s7
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    brne.w 0, %s2, .LBB25_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st2b %s0, (, %s1)
; CHECK-NEXT:  .LBB25_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i16, ptr %arg1, align 2
  %i4 = cmpxchg weak ptr %arg, i16 %i3, i16 %arg2 seq_cst seq_cst, align 2
  %i5 = extractvalue { i16, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i16, i1 } %i4, 0
  store i16 %i7, ptr %arg1, align 2
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i16
  ret i16 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i16 @_Z27atomic_cmp_swap_seq_cst_u16RNSt3__16atomicItEERtt(ptr nocapture nonnull align 2 dereferenceable(2) %arg, ptr nocapture nonnull align 2 dereferenceable(2) %arg1, i16 zeroext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_seq_cst_u16RNSt3__16atomicItEERtt:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld2b.zx %s4, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    and %s3, -4, %s0
; CHECK-NEXT:    and %s0, 3, %s0
; CHECK-NEXT:    sla.w.sx %s0, %s0, 3
; CHECK-NEXT:    ldl.sx %s6, (, %s3)
; CHECK-NEXT:    sla.w.sx %s7, (48)0, %s0
; CHECK-NEXT:    sla.w.sx %s2, %s2, %s0
; CHECK-NEXT:    sla.w.sx %s5, %s4, %s0
; CHECK-NEXT:    nnd %s4, %s7, %s6
; CHECK-NEXT:    and %s6, %s4, (32)0
; CHECK-NEXT:    or %s4, %s6, %s2
; CHECK-NEXT:    or %s2, %s6, %s5
; CHECK-NEXT:    cas.w %s4, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s4, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    brne.w 0, %s2, .LBB26_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    and %s3, %s4, (32)0
; CHECK-NEXT:    srl %s0, %s3, %s0
; CHECK-NEXT:    st2b %s0, (, %s1)
; CHECK-NEXT:  .LBB26_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i16, ptr %arg1, align 2
  %i4 = cmpxchg weak ptr %arg, i16 %i3, i16 %arg2 seq_cst seq_cst, align 2
  %i5 = extractvalue { i16, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i16, i1 } %i4, 0
  store i16 %i7, ptr %arg1, align 2
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i16
  ret i16 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i32 @_Z27atomic_cmp_swap_seq_cst_i32RNSt3__16atomicIiEERii(ptr nocapture nonnull align 4 dereferenceable(4) %arg, ptr nocapture nonnull align 4 dereferenceable(4) %arg1, i32 signext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_seq_cst_i32RNSt3__16atomicIiEERii:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    cas.w %s2, (%s0), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    breq.w %s2, %s3, .LBB27_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    stl %s2, (, %s1)
; CHECK-NEXT:  .LBB27_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i32, ptr %arg1, align 4
  %i4 = cmpxchg weak ptr %arg, i32 %i3, i32 %arg2 seq_cst seq_cst, align 4
  %i5 = extractvalue { i32, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i32, i1 } %i4, 0
  store i32 %i7, ptr %arg1, align 4
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i32
  ret i32 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i32 @_Z27atomic_cmp_swap_seq_cst_u32RNSt3__16atomicIjEERjj(ptr nocapture nonnull align 4 dereferenceable(4) %arg, ptr nocapture nonnull align 4 dereferenceable(4) %arg1, i32 zeroext %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_seq_cst_u32RNSt3__16atomicIjEERjj:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    cas.w %s2, (%s0), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    breq.w %s2, %s3, .LBB28_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    stl %s2, (, %s1)
; CHECK-NEXT:  .LBB28_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i32, ptr %arg1, align 4
  %i4 = cmpxchg weak ptr %arg, i32 %i3, i32 %arg2 seq_cst seq_cst, align 4
  %i5 = extractvalue { i32, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i32, i1 } %i4, 0
  store i32 %i7, ptr %arg1, align 4
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i32
  ret i32 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z27atomic_cmp_swap_seq_cst_i64RNSt3__16atomicIlEERll(ptr nocapture nonnull align 8 dereferenceable(8) %arg, ptr nocapture nonnull align 8 dereferenceable(8) %arg1, i64 %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_seq_cst_i64RNSt3__16atomicIlEERll:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    cas.l %s2, (%s0), %s3
; CHECK-NEXT:    cmps.l %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    breq.l %s2, %s3, .LBB29_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st %s2, (, %s1)
; CHECK-NEXT:  .LBB29_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i64, ptr %arg1, align 8
  %i4 = cmpxchg weak ptr %arg, i64 %i3, i64 %arg2 seq_cst seq_cst, align 8
  %i5 = extractvalue { i64, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i64, i1 } %i4, 0
  store i64 %i7, ptr %arg1, align 8
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i64
  ret i64 %i9
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z27atomic_cmp_swap_seq_cst_u64RNSt3__16atomicImEERmm(ptr nocapture nonnull align 8 dereferenceable(8) %arg, ptr nocapture nonnull align 8 dereferenceable(8) %arg1, i64 %arg2) {
; CHECK-LABEL: _Z27atomic_cmp_swap_seq_cst_u64RNSt3__16atomicImEERmm:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s1)
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    cas.l %s2, (%s0), %s3
; CHECK-NEXT:    cmps.l %s4, %s2, %s3
; CHECK-NEXT:    or %s0, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s0, (63)0, %s4
; CHECK-NEXT:    fencem 3
; CHECK-NEXT:    breq.l %s2, %s3, .LBB30_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st %s2, (, %s1)
; CHECK-NEXT:  .LBB30_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s0, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i3 = load i64, ptr %arg1, align 8
  %i4 = cmpxchg weak ptr %arg, i64 %i3, i64 %arg2 seq_cst seq_cst, align 8
  %i5 = extractvalue { i64, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i64, i1 } %i4, 0
  store i64 %i7, ptr %arg1, align 8
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i64
  ret i64 %i9
}

; Function Attrs: nounwind mustprogress
define i128 @_Z28atomic_cmp_swap_seq_cst_i128RNSt3__16atomicInEERnn(ptr nonnull align 16 dereferenceable(16) %arg, ptr nonnull align 16 dereferenceable(16) %arg1, i128 %arg2) {
; CHECK-LABEL: _Z28atomic_cmp_swap_seq_cst_i128RNSt3__16atomicInEERnn:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB31_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB31_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s1
; CHECK-NEXT:    or %s1, 0, %s0
; CHECK-NEXT:    st %s3, 248(, %s11)
; CHECK-NEXT:    st %s2, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 5, (0)1
; CHECK-NEXT:    or %s5, 5, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg2, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %arg, ptr nonnull %arg1, ptr nonnull %i, i32 signext 5, i32 signext 5)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  ret i128 %i7
}

; Function Attrs: nounwind mustprogress
define i128 @_Z28atomic_cmp_swap_seq_cst_u128RNSt3__16atomicIoEERoo(ptr nonnull align 16 dereferenceable(16) %arg, ptr nonnull align 16 dereferenceable(16) %arg1, i128 %arg2) {
; CHECK-LABEL: _Z28atomic_cmp_swap_seq_cst_u128RNSt3__16atomicIoEERoo:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB32_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB32_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s1
; CHECK-NEXT:    or %s1, 0, %s0
; CHECK-NEXT:    st %s3, 248(, %s11)
; CHECK-NEXT:    st %s2, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 5, (0)1
; CHECK-NEXT:    or %s5, 5, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg2, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %arg, ptr nonnull %arg1, ptr nonnull %i, i32 signext 5, i32 signext 5)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  ret i128 %i7
}

; Function Attrs: nofree nounwind mustprogress
define zeroext i1 @_Z30atomic_cmp_swap_relaxed_stk_i1Rbb(ptr nocapture nonnull align 1 dereferenceable(1) %arg, i1 zeroext %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_stk_i1Rbb:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB33_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB33_4: # %bb
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    ld1b.zx %s2, (, %s0)
; CHECK-NEXT:    ldl.zx %s4, 8(, %s11)
; CHECK-NEXT:    lea %s3, 8(, %s11)
; CHECK-NEXT:    lea %s5, -256
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s2, %s4, %s2
; CHECK-NEXT:    cas.w %s1, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB33_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    st1b %s1, (, %s0)
; CHECK-NEXT:  .LBB33_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic", align 8
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %i)
  %i3 = zext i1 %arg1 to i8
  %i4 = load i8, ptr %arg, align 1
  %i5 = cmpxchg weak volatile ptr %i, i8 %i4, i8 %i3 monotonic monotonic, align 1
  %i6 = extractvalue { i8, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i8, i1 } %i5, 0
  store i8 %i8, ptr %arg, align 1
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %i)
  ret i1 %i6
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)

; Function Attrs: nofree nounwind mustprogress
define signext i8 @_Z30atomic_cmp_swap_relaxed_stk_i8Rcc(ptr nocapture nonnull align 1 dereferenceable(1) %arg, i8 signext %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_stk_i8Rcc:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB34_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB34_4: # %bb
; CHECK-NEXT:    ld1b.zx %s3, (, %s0)
; CHECK-NEXT:    lea %s2, 8(, %s11)
; CHECK-NEXT:    and %s1, %s1, (56)0
; CHECK-NEXT:    ldl.zx %s4, 8(, %s11)
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    lea %s5, -256
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s3, %s4, %s3
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB34_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st1b %s1, (, %s0)
; CHECK-NEXT:  .LBB34_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.0", align 8
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %i)
  %i3 = load i8, ptr %arg, align 1
  %i4 = cmpxchg weak volatile ptr %i, i8 %i3, i8 %arg1 monotonic monotonic, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %i)
  ret i8 %i9
}

; Function Attrs: nofree nounwind mustprogress
define zeroext i8 @_Z30atomic_cmp_swap_relaxed_stk_u8Rhh(ptr nocapture nonnull align 1 dereferenceable(1) %arg, i8 zeroext %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_stk_u8Rhh:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB35_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB35_4: # %bb
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    ld1b.zx %s2, (, %s0)
; CHECK-NEXT:    ldl.zx %s4, 8(, %s11)
; CHECK-NEXT:    lea %s3, 8(, %s11)
; CHECK-NEXT:    lea %s5, -256
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s2, %s4, %s2
; CHECK-NEXT:    cas.w %s1, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB35_2
; CHECK-NEXT:  # %bb.1: # %bb6
; CHECK-NEXT:    st1b %s1, (, %s0)
; CHECK-NEXT:  .LBB35_2: # %bb8
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.5", align 8
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %i)
  %i3 = load i8, ptr %arg, align 1
  %i4 = cmpxchg weak volatile ptr %i, i8 %i3, i8 %arg1 monotonic monotonic, align 1
  %i5 = extractvalue { i8, i1 } %i4, 1
  br i1 %i5, label %bb8, label %bb6

bb6:                                              ; preds = %bb
  %i7 = extractvalue { i8, i1 } %i4, 0
  store i8 %i7, ptr %arg, align 1
  br label %bb8

bb8:                                              ; preds = %bb6, %bb
  %i9 = zext i1 %i5 to i8
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %i)
  ret i8 %i9
}

; Function Attrs: nofree nounwind mustprogress
define signext i16 @_Z31atomic_cmp_swap_relaxed_stk_i16Rss(ptr nocapture nonnull align 2 dereferenceable(2) %arg, i16 signext %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_stk_i16Rss:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB36_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB36_4: # %bb
; CHECK-NEXT:    ld2b.zx %s3, (, %s0)
; CHECK-NEXT:    lea %s2, 8(, %s11)
; CHECK-NEXT:    and %s1, %s1, (48)0
; CHECK-NEXT:    ldl.zx %s4, 8(, %s11)
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    lea %s5, -65536
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s3, %s4, %s3
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB36_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    st2b %s1, (, %s0)
; CHECK-NEXT:  .LBB36_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.10", align 8
  call void @llvm.lifetime.start.p0(i64 2, ptr nonnull %i)
  %i4 = load i16, ptr %arg, align 2
  %i5 = cmpxchg weak volatile ptr %i, i16 %i4, i16 %arg1 monotonic monotonic, align 2
  %i6 = extractvalue { i16, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i16, i1 } %i5, 0
  store i16 %i8, ptr %arg, align 2
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  %i10 = zext i1 %i6 to i16
  call void @llvm.lifetime.end.p0(i64 2, ptr nonnull %i)
  ret i16 %i10
}

; Function Attrs: nofree nounwind mustprogress
define zeroext i16 @_Z31atomic_cmp_swap_relaxed_stk_u16Rtt(ptr nocapture nonnull align 2 dereferenceable(2) %arg, i16 zeroext %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_stk_u16Rtt:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB37_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB37_4: # %bb
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    ld2b.zx %s2, (, %s0)
; CHECK-NEXT:    ldl.zx %s4, 8(, %s11)
; CHECK-NEXT:    lea %s3, 8(, %s11)
; CHECK-NEXT:    lea %s5, -65536
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s2, %s4, %s2
; CHECK-NEXT:    cas.w %s1, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB37_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    st2b %s1, (, %s0)
; CHECK-NEXT:  .LBB37_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.15", align 8
  call void @llvm.lifetime.start.p0(i64 2, ptr nonnull %i)
  %i4 = load i16, ptr %arg, align 2
  %i5 = cmpxchg weak volatile ptr %i, i16 %i4, i16 %arg1 monotonic monotonic, align 2
  %i6 = extractvalue { i16, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i16, i1 } %i5, 0
  store i16 %i8, ptr %arg, align 2
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  %i10 = zext i1 %i6 to i16
  call void @llvm.lifetime.end.p0(i64 2, ptr nonnull %i)
  ret i16 %i10
}

; Function Attrs: nofree nounwind mustprogress
define signext i32 @_Z31atomic_cmp_swap_relaxed_stk_i32Rii(ptr nocapture nonnull align 4 dereferenceable(4) %arg, i32 signext %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_stk_i32Rii:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB38_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB38_4: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s0)
; CHECK-NEXT:    cas.w %s1, 8(%s11), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.w %s1, %s3, .LBB38_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    stl %s1, (, %s0)
; CHECK-NEXT:  .LBB38_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.20", align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %i)
  %i4 = load i32, ptr %arg, align 4
  %i5 = cmpxchg weak volatile ptr %i, i32 %i4, i32 %arg1 monotonic monotonic, align 4
  %i6 = extractvalue { i32, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i32, i1 } %i5, 0
  store i32 %i8, ptr %arg, align 4
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  %i10 = zext i1 %i6 to i32
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %i)
  ret i32 %i10
}

; Function Attrs: nofree nounwind mustprogress
define zeroext i32 @_Z31atomic_cmp_swap_relaxed_stk_u32Rjj(ptr nocapture nonnull align 4 dereferenceable(4) %arg, i32 zeroext %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_stk_u32Rjj:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB39_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB39_4: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s0)
; CHECK-NEXT:    cas.w %s1, 8(%s11), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.w %s1, %s3, .LBB39_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    stl %s1, (, %s0)
; CHECK-NEXT:  .LBB39_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.25", align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %i)
  %i4 = load i32, ptr %arg, align 4
  %i5 = cmpxchg weak volatile ptr %i, i32 %i4, i32 %arg1 monotonic monotonic, align 4
  %i6 = extractvalue { i32, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i32, i1 } %i5, 0
  store i32 %i8, ptr %arg, align 4
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  %i10 = zext i1 %i6 to i32
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %i)
  ret i32 %i10
}

; Function Attrs: nofree nounwind mustprogress
define i64 @_Z31atomic_cmp_swap_relaxed_stk_i64Rll(ptr nocapture nonnull align 8 dereferenceable(8) %arg, i64 %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_stk_i64Rll:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB40_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB40_4: # %bb
; CHECK-NEXT:    ld %s3, (, %s0)
; CHECK-NEXT:    cas.l %s1, 8(%s11), %s3
; CHECK-NEXT:    cmps.l %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.l %s1, %s3, .LBB40_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    st %s1, (, %s0)
; CHECK-NEXT:  .LBB40_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.30", align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %i)
  %i4 = load i64, ptr %arg, align 8
  %i5 = cmpxchg weak volatile ptr %i, i64 %i4, i64 %arg1 monotonic monotonic, align 8
  %i6 = extractvalue { i64, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i64, i1 } %i5, 0
  store i64 %i8, ptr %arg, align 8
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  %i10 = zext i1 %i6 to i64
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %i)
  ret i64 %i10
}

; Function Attrs: nofree nounwind mustprogress
define i64 @_Z31atomic_cmp_swap_relaxed_stk_u64Rmm(ptr nocapture nonnull align 8 dereferenceable(8) %arg, i64 %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_stk_u64Rmm:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    adds.l %s11, -16, %s11
; CHECK-NEXT:    brge.l %s11, %s8, .LBB41_4
; CHECK-NEXT:  # %bb.3: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB41_4: # %bb
; CHECK-NEXT:    ld %s3, (, %s0)
; CHECK-NEXT:    cas.l %s1, 8(%s11), %s3
; CHECK-NEXT:    cmps.l %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.l %s1, %s3, .LBB41_2
; CHECK-NEXT:  # %bb.1: # %bb7
; CHECK-NEXT:    st %s1, (, %s0)
; CHECK-NEXT:  .LBB41_2: # %bb9
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    adds.l %s11, 16, %s11
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca %"struct.std::__1::atomic.35", align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %i)
  %i4 = load i64, ptr %arg, align 8
  %i5 = cmpxchg weak volatile ptr %i, i64 %i4, i64 %arg1 monotonic monotonic, align 8
  %i6 = extractvalue { i64, i1 } %i5, 1
  br i1 %i6, label %bb9, label %bb7

bb7:                                              ; preds = %bb
  %i8 = extractvalue { i64, i1 } %i5, 0
  store i64 %i8, ptr %arg, align 8
  br label %bb9

bb9:                                              ; preds = %bb7, %bb
  %i10 = zext i1 %i6 to i64
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %i)
  ret i64 %i10
}

; Function Attrs: nounwind mustprogress
define i128 @_Z32atomic_cmp_swap_relaxed_stk_i128Rnn(ptr nonnull align 16 dereferenceable(16) %arg, i128 %arg1) {
; CHECK-LABEL: _Z32atomic_cmp_swap_relaxed_stk_i128Rnn:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -272(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB42_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB42_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s0
; CHECK-NEXT:    st %s2, 264(, %s11)
; CHECK-NEXT:    st %s1, 256(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s1, 240(, %s11)
; CHECK-NEXT:    lea %s3, 256(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 0, (0)1
; CHECK-NEXT:    or %s5, 0, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  %i2 = alloca %"struct.std::__1::atomic.40", align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i2)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg1, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %i2, ptr nonnull %arg, ptr nonnull %i, i32 signext 0, i32 signext 0)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i2)
  ret i128 %i7
}

; Function Attrs: nounwind mustprogress
define i128 @_Z32atomic_cmp_swap_relaxed_stk_u128Roo(ptr nonnull align 16 dereferenceable(16) %arg, i128 %arg1) {
; CHECK-LABEL: _Z32atomic_cmp_swap_relaxed_stk_u128Roo:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -272(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB43_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB43_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s0
; CHECK-NEXT:    st %s2, 264(, %s11)
; CHECK-NEXT:    st %s1, 256(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s1, 240(, %s11)
; CHECK-NEXT:    lea %s3, 256(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 0, (0)1
; CHECK-NEXT:    or %s5, 0, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  %i2 = alloca %"struct.std::__1::atomic.45", align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i2)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg1, ptr %i, align 16, !tbaa !0
  %i6 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull %i2, ptr nonnull %arg, ptr nonnull %i, i32 signext 0, i32 signext 0)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i7 = zext i1 %i6 to i128
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i2)
  ret i128 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i1 @_Z29atomic_cmp_swap_relaxed_gv_i1Rbb(ptr nocapture nonnull align 1 dereferenceable(1) %arg, i1 zeroext %arg1) {
; CHECK-LABEL: _Z29atomic_cmp_swap_relaxed_gv_i1Rbb:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    lea %s2, gv_i1@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_i1@hi(, %s2)
; CHECK-NEXT:    and %s2, -4, %s2
; CHECK-NEXT:    ldl.zx %s4, (, %s2)
; CHECK-NEXT:    ld1b.zx %s3, (, %s0)
; CHECK-NEXT:    lea %s5, -256
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s3, %s4, %s3
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB44_2
; CHECK-NEXT:  # %bb.1: # %bb5
; CHECK-NEXT:    st1b %s1, (, %s0)
; CHECK-NEXT:  .LBB44_2: # %bb7
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = zext i1 %arg1 to i8
  %i2 = load i8, ptr %arg, align 1
  %i3 = cmpxchg weak ptr @gv_i1, i8 %i2, i8 %i monotonic monotonic, align 1
  %i4 = extractvalue { i8, i1 } %i3, 1
  br i1 %i4, label %bb7, label %bb5

bb5:                                              ; preds = %bb
  %i6 = extractvalue { i8, i1 } %i3, 0
  store i8 %i6, ptr %arg, align 1
  br label %bb7

bb7:                                              ; preds = %bb5, %bb
  ret i1 %i4
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i8 @_Z29atomic_cmp_swap_relaxed_gv_i8Rcc(ptr nocapture nonnull align 1 dereferenceable(1) %arg, i8 signext %arg1) {
; CHECK-LABEL: _Z29atomic_cmp_swap_relaxed_gv_i8Rcc:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld1b.zx %s2, (, %s0)
; CHECK-NEXT:    lea %s3, gv_i8@lo
; CHECK-NEXT:    and %s3, %s3, (32)0
; CHECK-NEXT:    lea.sl %s3, gv_i8@hi(, %s3)
; CHECK-NEXT:    and %s3, -4, %s3
; CHECK-NEXT:    and %s1, %s1, (56)0
; CHECK-NEXT:    ldl.zx %s4, (, %s3)
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    lea %s5, -256
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s2, %s4, %s2
; CHECK-NEXT:    cas.w %s1, (%s3), %s2
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s2
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB45_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    st1b %s1, (, %s0)
; CHECK-NEXT:  .LBB45_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i8, ptr %arg, align 1
  %i2 = cmpxchg weak ptr @gv_i8, i8 %i, i8 %arg1 monotonic monotonic, align 1
  %i3 = extractvalue { i8, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i8, i1 } %i2, 0
  store i8 %i5, ptr %arg, align 1
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i8
  ret i8 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i8 @_Z29atomic_cmp_swap_relaxed_gv_u8Rhh(ptr nocapture nonnull align 1 dereferenceable(1) %arg, i8 zeroext %arg1) {
; CHECK-LABEL: _Z29atomic_cmp_swap_relaxed_gv_u8Rhh:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    lea %s2, gv_u8@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_u8@hi(, %s2)
; CHECK-NEXT:    and %s2, -4, %s2
; CHECK-NEXT:    ldl.zx %s4, (, %s2)
; CHECK-NEXT:    ld1b.zx %s3, (, %s0)
; CHECK-NEXT:    lea %s5, -256
; CHECK-NEXT:    and %s5, %s5, (32)0
; CHECK-NEXT:    and %s4, %s4, %s5
; CHECK-NEXT:    and %s4, %s4, (32)0
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s3, %s4, %s3
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB46_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    st1b %s1, (, %s0)
; CHECK-NEXT:  .LBB46_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i8, ptr %arg, align 1
  %i2 = cmpxchg weak ptr @gv_u8, i8 %i, i8 %arg1 monotonic monotonic, align 1
  %i3 = extractvalue { i8, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i8, i1 } %i2, 0
  store i8 %i5, ptr %arg, align 1
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i8
  ret i8 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i16 @_Z30atomic_cmp_swap_relaxed_gv_i16Rss(ptr nocapture nonnull align 2 dereferenceable(2) %arg, i16 signext %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_gv_i16Rss:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    lea %s2, gv_i16@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_i16@hi(, %s2)
; CHECK-NEXT:    and %s2, -4, %s2
; CHECK-NEXT:    ld2b.zx %s4, 2(, %s2)
; CHECK-NEXT:    ld2b.zx %s3, (, %s0)
; CHECK-NEXT:    and %s1, %s1, (48)0
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    sla.w.sx %s4, %s4, 16
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s3, %s4, %s3
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB47_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    st2b %s1, (, %s0)
; CHECK-NEXT:  .LBB47_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i16, ptr %arg, align 2
  %i2 = cmpxchg weak ptr @gv_i16, i16 %i, i16 %arg1 monotonic monotonic, align 2
  %i3 = extractvalue { i16, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i16, i1 } %i2, 0
  store i16 %i5, ptr %arg, align 2
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i16
  ret i16 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i16 @_Z30atomic_cmp_swap_relaxed_gv_u16Rtt(ptr nocapture nonnull align 2 dereferenceable(2) %arg, i16 zeroext %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_gv_u16Rtt:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    lea %s2, gv_u16@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_u16@hi(, %s2)
; CHECK-NEXT:    and %s2, -4, %s2
; CHECK-NEXT:    ld2b.zx %s4, 2(, %s2)
; CHECK-NEXT:    ld2b.zx %s3, (, %s0)
; CHECK-NEXT:    and %s1, %s1, (32)0
; CHECK-NEXT:    sla.w.sx %s4, %s4, 16
; CHECK-NEXT:    or %s1, %s4, %s1
; CHECK-NEXT:    or %s3, %s4, %s3
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s3, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s3
; CHECK-NEXT:    brne.w 0, %s2, .LBB48_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    st2b %s1, (, %s0)
; CHECK-NEXT:  .LBB48_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i16, ptr %arg, align 2
  %i2 = cmpxchg weak ptr @gv_u16, i16 %i, i16 %arg1 monotonic monotonic, align 2
  %i3 = extractvalue { i16, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i16, i1 } %i2, 0
  store i16 %i5, ptr %arg, align 2
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i16
  ret i16 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define signext i32 @_Z30atomic_cmp_swap_relaxed_gv_i32Rii(ptr nocapture nonnull align 4 dereferenceable(4) %arg, i32 signext %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_gv_i32Rii:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s0)
; CHECK-NEXT:    lea %s2, gv_i32@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_i32@hi(, %s2)
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.w %s1, %s3, .LBB49_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    stl %s1, (, %s0)
; CHECK-NEXT:  .LBB49_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i32, ptr %arg, align 4
  %i2 = cmpxchg weak ptr @gv_i32, i32 %i, i32 %arg1 monotonic monotonic, align 4
  %i3 = extractvalue { i32, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i32, i1 } %i2, 0
  store i32 %i5, ptr %arg, align 4
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i32
  ret i32 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define zeroext i32 @_Z30atomic_cmp_swap_relaxed_gv_u32Rjj(ptr nocapture nonnull align 4 dereferenceable(4) %arg, i32 zeroext %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_gv_u32Rjj:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ldl.sx %s3, (, %s0)
; CHECK-NEXT:    lea %s2, gv_u32@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_u32@hi(, %s2)
; CHECK-NEXT:    cas.w %s1, (%s2), %s3
; CHECK-NEXT:    cmps.w.sx %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.w.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.w %s1, %s3, .LBB50_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    stl %s1, (, %s0)
; CHECK-NEXT:  .LBB50_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i32, ptr %arg, align 4
  %i2 = cmpxchg weak ptr @gv_u32, i32 %i, i32 %arg1 monotonic monotonic, align 4
  %i3 = extractvalue { i32, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i32, i1 } %i2, 0
  store i32 %i5, ptr %arg, align 4
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i32
  ret i32 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z30atomic_cmp_swap_relaxed_gv_i64Rll(ptr nocapture nonnull align 8 dereferenceable(8) %arg, i64 %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_gv_i64Rll:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s0)
; CHECK-NEXT:    lea %s2, gv_i64@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_i64@hi(, %s2)
; CHECK-NEXT:    cas.l %s1, (%s2), %s3
; CHECK-NEXT:    cmps.l %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.l %s1, %s3, .LBB51_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    st %s1, (, %s0)
; CHECK-NEXT:  .LBB51_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i64, ptr %arg, align 8
  %i2 = cmpxchg weak ptr @gv_i64, i64 %i, i64 %arg1 monotonic monotonic, align 8
  %i3 = extractvalue { i64, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i64, i1 } %i2, 0
  store i64 %i5, ptr %arg, align 8
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i64
  ret i64 %i7
}

; Function Attrs: nofree norecurse nounwind mustprogress
define i64 @_Z30atomic_cmp_swap_relaxed_gv_u64Rmm(ptr nocapture nonnull align 8 dereferenceable(8) %arg, i64 %arg1) {
; CHECK-LABEL: _Z30atomic_cmp_swap_relaxed_gv_u64Rmm:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    ld %s3, (, %s0)
; CHECK-NEXT:    lea %s2, gv_u64@lo
; CHECK-NEXT:    and %s2, %s2, (32)0
; CHECK-NEXT:    lea.sl %s2, gv_u64@hi(, %s2)
; CHECK-NEXT:    cas.l %s1, (%s2), %s3
; CHECK-NEXT:    cmps.l %s4, %s1, %s3
; CHECK-NEXT:    or %s2, 0, (0)1
; CHECK-NEXT:    cmov.l.eq %s2, (63)0, %s4
; CHECK-NEXT:    breq.l %s1, %s3, .LBB52_2
; CHECK-NEXT:  # %bb.1: # %bb4
; CHECK-NEXT:    st %s1, (, %s0)
; CHECK-NEXT:  .LBB52_2: # %bb6
; CHECK-NEXT:    adds.w.zx %s0, %s2, (0)1
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = load i64, ptr %arg, align 8
  %i2 = cmpxchg weak ptr @gv_u64, i64 %i, i64 %arg1 monotonic monotonic, align 8
  %i3 = extractvalue { i64, i1 } %i2, 1
  br i1 %i3, label %bb6, label %bb4

bb4:                                              ; preds = %bb
  %i5 = extractvalue { i64, i1 } %i2, 0
  store i64 %i5, ptr %arg, align 8
  br label %bb6

bb6:                                              ; preds = %bb4, %bb
  %i7 = zext i1 %i3 to i64
  ret i64 %i7
}

; Function Attrs: nounwind mustprogress
define i128 @_Z31atomic_cmp_swap_relaxed_gv_i128Rnn(ptr nonnull align 16 dereferenceable(16) %arg, i128 %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_gv_i128Rnn:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB53_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB53_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s0
; CHECK-NEXT:    st %s2, 248(, %s11)
; CHECK-NEXT:    st %s1, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s0, gv_i128@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s1, gv_i128@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 0, (0)1
; CHECK-NEXT:    or %s5, 0, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg1, ptr %i, align 16, !tbaa !0
  %i4 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull @gv_i128, ptr nonnull %arg, ptr nonnull %i, i32 signext 0, i32 signext 0)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i5 = zext i1 %i4 to i128
  ret i128 %i5
}

; Function Attrs: nounwind mustprogress
define i128 @_Z31atomic_cmp_swap_relaxed_gv_u128Roo(ptr nonnull align 16 dereferenceable(16) %arg, i128 %arg1) {
; CHECK-LABEL: _Z31atomic_cmp_swap_relaxed_gv_u128Roo:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    st %s9, (, %s11)
; CHECK-NEXT:    st %s10, 8(, %s11)
; CHECK-NEXT:    or %s9, 0, %s11
; CHECK-NEXT:    lea %s11, -256(, %s11)
; CHECK-NEXT:    brge.l.t %s11, %s8, .LBB54_2
; CHECK-NEXT:  # %bb.1: # %bb
; CHECK-NEXT:    ld %s61, 24(, %s14)
; CHECK-NEXT:    or %s62, 0, %s0
; CHECK-NEXT:    lea %s63, 315
; CHECK-NEXT:    shm.l %s63, (%s61)
; CHECK-NEXT:    shm.l %s8, 8(%s61)
; CHECK-NEXT:    shm.l %s11, 16(%s61)
; CHECK-NEXT:    monc
; CHECK-NEXT:    or %s0, 0, %s62
; CHECK-NEXT:  .LBB54_2: # %bb
; CHECK-NEXT:    or %s6, 0, %s0
; CHECK-NEXT:    st %s2, 248(, %s11)
; CHECK-NEXT:    st %s1, 240(, %s11)
; CHECK-NEXT:    lea %s0, __atomic_compare_exchange@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s12, __atomic_compare_exchange@hi(, %s0)
; CHECK-NEXT:    lea %s0, gv_u128@lo
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lea.sl %s1, gv_u128@hi(, %s0)
; CHECK-NEXT:    lea %s3, 240(, %s11)
; CHECK-NEXT:    or %s0, 16, (0)1
; CHECK-NEXT:    or %s4, 0, (0)1
; CHECK-NEXT:    or %s5, 0, (0)1
; CHECK-NEXT:    or %s2, 0, %s6
; CHECK-NEXT:    bsic %s10, (, %s12)
; CHECK-NEXT:    or %s1, 0, (0)1
; CHECK-NEXT:    or %s11, 0, %s9
; CHECK-NEXT:    ld %s10, 8(, %s11)
; CHECK-NEXT:    ld %s9, (, %s11)
; CHECK-NEXT:    b.l.t (, %s10)
bb:
  %i = alloca i128, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %i)
  store i128 %arg1, ptr %i, align 16, !tbaa !0
  %i4 = call zeroext i1 @__atomic_compare_exchange(i64 16, ptr nonnull @gv_u128, ptr nonnull %arg, ptr nonnull %i, i32 signext 0, i32 signext 0)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %i)
  %i5 = zext i1 %i4 to i128
  ret i128 %i5
}

; Function Attrs: nounwind willreturn
declare i1 @__atomic_compare_exchange(i64, ptr, ptr, ptr, i32, i32)

!0 = !{!1, !1, i64 0}
!1 = !{!"__int128", !2, i64 0}
!2 = !{!"omnipotent char", !3, i64 0}
!3 = !{!"Simple C++ TBAA"}
