; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 6
; RUN: llc -march=bpfel < %s | FileCheck %s
;
; C code for this test case:
;
; long func(long a, long b) {
;     long x;
;     return __builtin_mul_overflow(a, b, &x);
; }


declare { i64, i1 } @llvm.smul.with.overflow.i64(i64, i64)

define i64 @func(i64 %a, i64 %b) {
; CHECK-LABEL: func:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    r3 = r1
; CHECK-NEXT:    r3 <<= 32
; CHECK-NEXT:    r3 >>= 32
; CHECK-NEXT:    r1 s>>= 32
; CHECK-NEXT:    r5 = r2
; CHECK-NEXT:    r5 <<= 32
; CHECK-NEXT:    r5 >>= 32
; CHECK-NEXT:    r4 = r1
; CHECK-NEXT:    r4 *= r5
; CHECK-NEXT:    r0 = r3
; CHECK-NEXT:    r0 *= r5
; CHECK-NEXT:    r0 >>= 32
; CHECK-NEXT:    r4 += r0
; CHECK-NEXT:    r5 = r4
; CHECK-NEXT:    r5 <<= 32
; CHECK-NEXT:    r5 >>= 32
; CHECK-NEXT:    r2 s>>= 32
; CHECK-NEXT:    r3 *= r2
; CHECK-NEXT:    r3 += r5
; CHECK-NEXT:    r1 *= r2
; CHECK-NEXT:    r4 s>>= 32
; CHECK-NEXT:    r2 = r3
; CHECK-NEXT:    r2 s>>= 32
; CHECK-NEXT:    r4 += r2
; CHECK-NEXT:    r1 += r4
; CHECK-NEXT:    r3 <<= 32
; CHECK-NEXT:    r3 s>>= 63
; CHECK-NEXT:    w0 = 1
; CHECK-NEXT:    if r1 != r3 goto LBB0_2
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    w0 = 0
; CHECK-NEXT:  LBB0_2: # %entry
; CHECK-NEXT:    exit
entry:
  %0 = tail call { i64, i1 } @llvm.smul.with.overflow.i64(i64 %a, i64 %b)
  %1 = extractvalue { i64, i1 } %0, 1
  %conv = zext i1 %1 to i64
  ret i64 %conv
}

