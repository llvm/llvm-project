; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=bpfel-- | FileCheck %s

@foo_printf.fmt = private unnamed_addr constant [9 x i8] c"hello  \0A\00", align 1

; Function Attrs: nounwind readnone uwtable
define i32 @foo_int(i32 %a, i32 %b) #0 {
; CHECK-LABEL: foo_int:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r0 = r2
; CHECK-NEXT:    r0 += r1
; CHECK-NEXT:    exit
  %1 = add nsw i32 %b, %a
  ret i32 %1
}

; Function Attrs: nounwind readnone uwtable
define signext i8 @foo_char(i8 signext %a, i8 signext %b) #0 {
; CHECK-LABEL: foo_char:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r0 = r2
; CHECK-NEXT:    r0 += r1
; CHECK-NEXT:    r0 <<= 56
; CHECK-NEXT:    r0 s>>= 56
; CHECK-NEXT:    exit
  %1 = add i8 %b, %a
  ret i8 %1
}

; Function Attrs: nounwind readnone uwtable
define i64 @foo_ll(i64 %a, i64 %b, i64 %c) #0 {
; CHECK-LABEL: foo_ll:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r0 = r2
; CHECK-NEXT:    r0 += r1
; CHECK-NEXT:    r0 -= r3
; CHECK-NEXT:    exit
  %1 = add nsw i64 %b, %a
  %2 = sub i64 %1, %c
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define void @foo_call2(i32 %a, i32 %b) #1 {
; CHECK-LABEL: foo_call2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r3 = r1
; CHECK-NEXT:    r2 <<= 56
; CHECK-NEXT:    r2 s>>= 56
; CHECK-NEXT:    r1 = r2
; CHECK-NEXT:    r2 = r3
; CHECK-NEXT:    call foo_2arg
; CHECK-NEXT:    exit
  %1 = trunc i32 %b to i8
  tail call void @foo_2arg(i8 signext %1, i32 %a) #3
  ret void
}

declare void @foo_2arg(i8 signext, i32) #2

; Function Attrs: nounwind uwtable
define i32 @foo_call5(i8 signext %a, i16 signext %b, i32 %c, i64 %d) #1 {
; CHECK-LABEL: foo_call5:
; CHECK:       # %bb.0:
; CHECK-NEXT:    call bar
; CHECK-NEXT:    r0 = 0
; CHECK-NEXT:    exit
  %1 = tail call i32 @bar(i8 signext %a, i16 signext %b, i32 %c, i64 %d) #3
  ret i32 0
}

declare i32 @bar(i8 signext, i16 signext, i32, i64) #2

; Function Attrs: nounwind readnone uwtable
define signext i8 @foo_cmp(i8 signext %a, i8 signext %b) #0 {
; CHECK-LABEL: foo_cmp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r0 = r1
; CHECK-NEXT:    if r2 s> r0 goto LBB5_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    r0 = r2
; CHECK-NEXT:  LBB5_2:
; CHECK-NEXT:    exit
  %1 = icmp slt i8 %a, %b
  %a.b = select i1 %1, i8 %a, i8 %b
  ret i8 %a.b
}

; Function Attrs: nounwind readnone uwtable
define i32 @foo_muldiv(i8 signext %a, i16 signext %b, i32 %c, i64 %d) #0 {
; CHECK-LABEL: foo_muldiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r0 = r2
; CHECK-NEXT:    if r1 == 0 goto LBB6_2
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    r0 *= r3
; CHECK-NEXT:    goto LBB6_3
; CHECK-NEXT:  LBB6_2:
; CHECK-NEXT:    r3 <<= 32
; CHECK-NEXT:    r3 >>= 32
; CHECK-NEXT:    r4 <<= 32
; CHECK-NEXT:    r4 >>= 32
; CHECK-NEXT:    r4 /= r3
; CHECK-NEXT:    r0 = r4
; CHECK-NEXT:  LBB6_3:
; CHECK-NEXT:    exit
  %1 = icmp eq i8 %a, 0
  br i1 %1, label %5, label %2

; <label>:2                                       ; preds = %0
  %3 = sext i16 %b to i32
  %4 = mul nsw i32 %3, %c
  br label %8

; <label>:5                                       ; preds = %0
  %6 = trunc i64 %d to i32
  %7 = udiv i32 %6, %c
  br label %8

; <label>:8                                       ; preds = %5, %2
  %.0 = phi i32 [ %4, %2 ], [ %7, %5 ]
  ret i32 %.0
}

; Function Attrs: nounwind uwtable
define i32 @foo_optimized() #1 {
; CHECK-LABEL: foo_optimized:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r1 = 1
; CHECK-NEXT:    r2 = 2
; CHECK-NEXT:    r3 = 3
; CHECK-NEXT:    r4 = 4
; CHECK-NEXT:    r5 = 5
; CHECK-NEXT:    call manyarg
; CHECK-NEXT:    exit
  %1 = tail call i32 @manyarg(i32 1, i32 2, i32 3, i32 4, i32 5) #3
  ret i32 %1
}

declare i32 @manyarg(i32, i32, i32, i32, i32) #2

; Function Attrs: nounwind uwtable
define void @foo_printf() #1 {
; CHECK-LABEL: foo_printf:
; CHECK:       # %bb.0:
; CHECK-NEXT:    r1 = 0
; CHECK-NEXT:    *(u8 *)(r10 - 8) = r1
; CHECK-NEXT:    r1 = 729618802566522216 ll
; CHECK-NEXT:    *(u64 *)(r10 - 16) = r1
; CHECK-NEXT:    r1 = r10
; CHECK-NEXT:    r1 += -16
; CHECK-NEXT:    call printf
; CHECK-NEXT:    exit
  %fmt = alloca [9 x i8], align 1
  call void @llvm.memcpy.p0.p0.i64(ptr %fmt, ptr @foo_printf.fmt, i64 9, i1 false)
  %1 = call i32 (ptr, ...) @printf(ptr %fmt) #3
  ret void
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0.p0.i64(ptr nocapture, ptr nocapture, i64, i1) #3

; Function Attrs: nounwind
declare i32 @printf(ptr nocapture, ...) #4
