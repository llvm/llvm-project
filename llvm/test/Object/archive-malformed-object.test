## Show that the archive library emits error messages when adding malformed
## object files and skips symbol tables for "malformed" bitcode files, which
## are assumed to be bitcode files generated by compilers from the future.

# RUN: rm -rf %t.dir
# RUN: split-file %s %t.dir
# RUN: cd %t.dir

## Create a malformed bitcode object.
# RUN: llvm-as input.ll -o input.bc
# RUN: cp input.bc good.bc
# RUN: %python -c "with open('input.bc', 'a') as f: f.truncate(10)"

## Malformed bitcode objects either warn or error depending on the archive format
## (see switch in getSymbolicFile). If the archive was created with a warning,
## we want to check that the archive map is empty. llvm-nm will fail when it
## tries to read the malformed bitcode file, but it's supposed to print the
## archive map first, which in this case it won't because there won't be one.
# RUN: rm -rf bad.a
# RUN: llvm-ar --format=bsd rc bad.a input.bc 2>&1 | FileCheck %s --check-prefix=WARN1
# RUN: not llvm-nm --print-armap bad.a | count 0
# RUN: rm -rf bad.a
# RUN: llvm-ar --format=gnu rc bad.a input.bc 2>&1 | FileCheck %s --check-prefix=WARN1
# RUN: not llvm-nm --print-armap bad.a | count 0
# RUN: rm -rf bad.a
# RUN: not llvm-ar --format=bigarchive rc bad.a input.bc 2>&1 | FileCheck %s --check-prefix=ERR1
# RUN: rm -rf bad.a
# RUN: not llvm-ar --format=coff rc bad.a input.bc 2>&1 | FileCheck %s --check-prefix=ERR1
# RUN: rm -rf bad.a
# RUN: not llvm-ar --format=darwin rc bad.a input.bc 2>&1 | FileCheck %s --check-prefix=ERR1

## Malformed bitcode object is the last file member of archive and
## the symbol table is required. In this case we check that the
## symbol table contains entries for the good object only.
# RUN: rm -rf bad.a
# RUN: llvm-ar rc bad.a good.bc input.bc 2>&1 | FileCheck %s --check-prefix=WARN1
# RUN: not llvm-nm --print-armap bad.a | FileCheck %s --check-prefix=ARMAP

## Malformed bitcode object if the symbol table is not required for big archive.
## For big archives we print an error instead of a warning because the AIX linker
## presumably requires the index.
# RUN: rm -rf bad.a
# RUN: not llvm-ar --format=bigarchive rcS bad.a input.bc 2>&1 | FileCheck %s --check-prefix=ERR1
# RUN: rm -rf bad.a
# RUN: not llvm-ar --format=bigarchive rcS bad.a good.bc input.bc 2>&1 | FileCheck %s --check-prefix=ERR1

# ERR1: error: bad.a: 'input.bc': Invalid bitcode signature
# WARN1: warning: 'input.bc': Invalid bitcode signature

## Non-bitcode malformed file.
# RUN: yaml2obj input.yaml -o input.o
# RUN: not llvm-ar rc bad.a input.o 2>&1 | FileCheck %s --check-prefix=ERR2

# ERR2: error: bad.a: 'input.o': section header table goes past the end of the file: e_shoff = 0x9999

## Don't emit an error or warning if the symbol table is not required for formats other than the big archive format.
# RUN: llvm-ar --format=gnu rcS good.a input.o input.bc 2>&1 | count 0
# RUN: llvm-ar t good.a | FileCheck %s --check-prefix=CONTENTS

# CONTENTS:      input.o
# CONTENTS-NEXT: input.bc

# ARMAP: Archive map
# ARMAP-NEXT: foo in good.bc
# ARMAP-EMPTY:

#--- input.ll
target datalayout = "e-m:w-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

@foo = global i32 1

#--- input.yaml
--- !ELF
FileHeader:
  Class:   ELFCLASS64
  Data:    ELFDATA2LSB
  Type:    ET_REL
  EShOff:  0x9999
