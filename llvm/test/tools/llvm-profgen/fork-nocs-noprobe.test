; Check that we can handle a process forking and collect samples from both
; Forking is only visible in the perf script output when the PID/task events are
; included, which requires the multi process flag to interpret, meaning we don't
; need a test when the flag is off

; RUN: llvm-profgen --format=text --perfscript=%S/Inputs/fork-nocs-noprobe.perfscript --binary=%S/Inputs/fork-nocs-noprobe.perfbin --output=%t --profile-summary-cold-count=0 --multi-process-profile
; RUN: FileCheck %s --input-file %t

; Check that we get samples from both processes
CHECK:      loop1:242:0
CHECK-NEXT:  0: 0
CHECK-NEXT:  1: 8
CHECK-NEXT:  2: 0
CHECK-NEXT: loop2:238:0
CHECK-NEXT:  0: 0
CHECK-NEXT:  1: 8
CHECK-NEXT:  2: 0

; original code:
; clang -g test.c -o fork.perfbin
#include <unistd.h>
#include <sys/wait.h>
#include <stdint.h>

// Loop for a while so we see samples in the function (compiled at -O0)
void loop1() {
  for (uint64_t i = 0; i < 10000000000; i++) {}
}

// Slightly modified to make sure there isn't any kind of linker merging
void loop2() {
  for (uint64_t i = 1; i < 10000000001; i++) {}
}

int main(void) {
  pid_t pid = fork();

  if (pid == -1) {
    // Fork failed
  } else if (pid == 0) {
    // Forked process: Samples in loop2
    loop2();
  } else {
    // Main process: Samples in loop1
    loop1();
    int status;
    waitpid(pid, &status, 0);
  }
}