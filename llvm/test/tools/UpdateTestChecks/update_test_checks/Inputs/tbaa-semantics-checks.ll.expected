; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -S | FileCheck %s

define void @store_unsignedptr(ptr %ptr) {
; CHECK-LABEL: define void @store_unsignedptr(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    store ptr null, ptr [[PTR]], align 8, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    ret void
;
entry:
  store ptr null, ptr %ptr, align 8, !tbaa !0
  ret void
}

define void @store_char(ptr %ptr) {
; CHECK-LABEL: define void @store_char(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    store i8 0, ptr [[PTR]], align 1, !tbaa [[TBAA5:![0-9]+]]
; CHECK-NEXT:    ret void
;
entry:
  store i8 0, ptr %ptr, align 1, !tbaa !5
  ret void
}

define float @ptr_to_float(ptr %ptr) {
; CHECK-LABEL: define float @ptr_to_float(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    store float 0.000000e+00, ptr [[PTR]], align 4, !tbaa [[TBAA6:![0-9]+]]
; CHECK-NEXT:    call void @opaque(ptr [[PTR]])
; CHECK-NEXT:    [[VAL:%.*]] = load float, ptr [[PTR]], align 4, !tbaa [[TBAA6]]
; CHECK-NEXT:    ret float [[VAL]]
;
entry:
  store float 0.000000e+00, ptr %ptr, align 4, !tbaa !6
  call void @opaque(ptr %ptr)
  %val = load float, ptr %ptr, align 4, !tbaa !6
  ret float %val
}

define i64 @ptr_to_longlong(ptr %ptr) {
; CHECK-LABEL: define i64 @ptr_to_longlong(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[VAL:%.*]] = load i64, ptr [[PTR]], align 8, !tbaa [[TBAA8:![0-9]+]]
; CHECK-NEXT:    store i64 0, ptr [[PTR]], align 8, !tbaa [[TBAA8]]
; CHECK-NEXT:    ret i64 [[VAL]]
;
entry:
  %val = load i64, ptr %ptr, align 8, !tbaa !8
  store i64 0, ptr %ptr, align 8, !tbaa !8
  ret i64 %val
}

; struct STRUCT1 {
;   int x;
;   int y;
; };

define void @store_struct1ptr(ptr %ptr) {
; CHECK-LABEL: define void @store_struct1ptr(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    store ptr null, ptr [[PTR]], align 8, !tbaa [[TBAA10:![0-9]+]]
; CHECK-NEXT:    ret void
;
entry:
  ; *(struct STRUCT1 **)ptr = 0;
  store ptr null, ptr %ptr, align 8, !tbaa !10
  ret void
}

; struct STRUCT2 {
;   struct STRUCT1 *s;
; };

define void @store_struct2(ptr %ptr) {
; CHECK-LABEL: define void @store_struct2(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    store ptr null, ptr [[PTR]], align 8, !tbaa [[TBAA12:![0-9]+]]
; CHECK-NEXT:    ret void
;
entry:
  ; ptr->s = 0;
  store ptr null, ptr %ptr, align 8, !tbaa !12
  ret void
}

define double @access_matrix(ptr %ptr) {
; CHECK-LABEL: define double @access_matrix(
; CHECK-SAME: ptr [[PTR:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ALLOCA_PTR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[PTR]], ptr [[ALLOCA_PTR]], align 8, !tbaa [[TBAA14:![0-9]+]]
; CHECK-NEXT:    [[PTR_IDX:%.*]] = load ptr, ptr [[ALLOCA_PTR]], align 8, !tbaa [[TBAA14]]
; CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds ptr, ptr [[PTR_IDX]], i64 4
; CHECK-NEXT:    [[PTR_IDX_1:%.*]] = load ptr, ptr [[ADD_PTR]], align 8, !tbaa [[TBAA16:![0-9]+]]
; CHECK-NEXT:    [[ADD_PTR1:%.*]] = getelementptr inbounds [6 x double], ptr [[PTR_IDX_1]], i64 6
; CHECK-NEXT:    [[PTR_IDX_2:%.*]] = load <6 x double>, ptr [[ADD_PTR1]], align 8, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[MATRIXEXT:%.*]] = extractelement <6 x double> [[PTR_IDX_2]], i64 5
; CHECK-NEXT:    ret double [[MATRIXEXT]]
;
entry:
  %alloca.ptr = alloca ptr, align 8
  store ptr %ptr, ptr %alloca.ptr, align 8, !tbaa !14
  %ptr.idx = load ptr, ptr %alloca.ptr, align 8, !tbaa !14
  %add.ptr = getelementptr inbounds ptr, ptr %ptr.idx, i64 4
  %ptr.idx.1 = load ptr, ptr %add.ptr, align 8, !tbaa !16
  %add.ptr1 = getelementptr inbounds [6 x double], ptr %ptr.idx.1, i64 6
  %ptr.idx.2 = load <6 x double>, ptr %add.ptr1, align 8, !tbaa !5
  %matrixext = extractelement <6 x double> %ptr.idx.2, i64 5
  ret double %matrixext
}

declare void @opaque(ptr)

!0 = !{!1, !1, i64 0}
!1 = !{!"p1 int", !2, i64 0}
!2 = !{!"any pointer", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!3, !3, i64 0}
!6 = !{!7, !7, i64 0}
!7 = !{!"float", !3, i64 0}
!8 = !{!9, !9, i64 0}
!9 = !{!"long long", !3, i64 0}
!10 = !{!11, !11, i64 0}
!11 = !{!"p1 _ZTS7STRUCT1", !2, i64 0}
!12 = !{!13, !11, i64 0}
!13 = !{!"STRUCT2", !11, i64 0}
!14 = !{!15, !15, i64 0}
!15 = !{!"any p2 pointer", !2, i64 0}
!16 = !{!2, !2, i64 0}
;.
; CHECK: [[TBAA0]] = !{[[META1:![0-9]+]], [[META1]], i64 0}
; CHECK: [[META1]] = !{!"p1 int", [[META2:![0-9]+]], i64 0}
; CHECK: [[META2]] = !{!"any pointer", [[META3:![0-9]+]], i64 0}
; CHECK: [[META3]] = !{!"omnipotent char", [[META4:![0-9]+]], i64 0}
; CHECK: [[META4]] = !{!"Simple C/C++ TBAA"}
; CHECK: [[TBAA5]] = !{[[META3]], [[META3]], i64 0}
; CHECK: [[TBAA6]] = !{[[META7:![0-9]+]], [[META7]], i64 0}
; CHECK: [[META7]] = !{!"float", [[META3]], i64 0}
; CHECK: [[TBAA8]] = !{[[META9:![0-9]+]], [[META9]], i64 0}
; CHECK: [[META9]] = !{!"long long", [[META3]], i64 0}
; CHECK: [[TBAA10]] = !{[[META11:![0-9]+]], [[META11]], i64 0}
; CHECK: [[META11]] = !{!"p1 _ZTS7STRUCT1", [[META2]], i64 0}
; CHECK: [[TBAA12]] = !{[[META13:![0-9]+]], [[META11]], i64 0}
; CHECK: [[META13]] = !{!"STRUCT2", [[META11]], i64 0}
; CHECK: [[TBAA14]] = !{[[META15:![0-9]+]], [[META15]], i64 0}
; CHECK: [[META15]] = !{!"any p2 pointer", [[META2]], i64 0}
; CHECK: [[TBAA16]] = !{[[META2]], [[META2]], i64 0}
;.
