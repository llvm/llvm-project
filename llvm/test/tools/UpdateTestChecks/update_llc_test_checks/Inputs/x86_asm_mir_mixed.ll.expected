; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64 < %s | FileCheck %s --check-prefix=ASM
; RUN: llc -mtriple=x86_64 -stop-after=finalize-isel < %s | FileCheck %s --check-prefix=MIR

define i64 @test1(i64 %i) nounwind readnone {
; ASM-LABEL: test1:
; ASM:       # %bb.0:
; ASM-NEXT:    movq %rdi, %rax
; ASM-NEXT:    addq -{{[0-9]+}}(%rsp), %rax
; ASM-NEXT:    retq
; MIR-LABEL: name: test1
; MIR: bb.0 (%ir-block.0):
; MIR-NEXT:   liveins: $rdi
; MIR-NEXT: {{  $}}
; MIR-NEXT:   [[COPY:%[0-9]+]]:gr64 = COPY $rdi
; MIR-NEXT:   [[ADD64rm:%[0-9]+]]:gr64 = ADD64rm [[COPY]], %stack.0.loc, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (dereferenceable load (s64) from %ir.loc)
; MIR-NEXT:   $rax = COPY [[ADD64rm]]
; MIR-NEXT:   RET 0, $rax
  %loc = alloca i64
  %j = load i64, i64 * %loc
  %r = add i64 %i, %j
  ret i64 %r
}

define i64 @test2(i32 %i) nounwind readnone {
; ASM-LABEL: test2:
; ASM:       # %bb.0:
; ASM-NEXT:    movl %edi, %eax
; ASM-NEXT:    addl -{{[0-9]+}}(%rsp), %eax
; ASM-NEXT:    retq
; MIR-LABEL: name: test2
; MIR: bb.0 (%ir-block.0):
; MIR-NEXT:   liveins: $edi
; MIR-NEXT: {{  $}}
; MIR-NEXT:   [[COPY:%[0-9]+]]:gr32 = COPY $edi
; MIR-NEXT:   [[ADD32rm:%[0-9]+]]:gr32 = ADD32rm [[COPY]], %stack.0.loc, 1, $noreg, 0, $noreg, implicit-def dead $eflags :: (dereferenceable load (s32) from %ir.loc)
; MIR-NEXT:   [[SUBREG_TO_REG:%[0-9]+]]:gr64 = SUBREG_TO_REG 0, killed [[ADD32rm]], %subreg.sub_32bit
; MIR-NEXT:   $rax = COPY [[SUBREG_TO_REG]]
; MIR-NEXT:   RET 0, $rax
  %loc = alloca i32
  %j = load i32, i32 * %loc
  %r = add i32 %i, %j
  %ext = zext i32 %r to i64
  ret i64 %ext
}
