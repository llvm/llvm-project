# This is an example of a downstream module, which in this case is for i686.
# The goal is to test the updater's downstream-target-module-path option.
#
# This target module implements a simple scrubber that returns a fixed string,
# a regex that matches the fixed strings generated by the scrubber.
#
# This module needs to define:
# 2. The `downstream_scrub(asm, arg)` scrubber function
# 3. The `downstream_asm_fn_re` regex for matching func, body, etc.

import re
import sys
import os
from pathlib import Path

common_dir = Path(__file__).parent / "../../../../../utils/"
sys.path.append(common_dir)
from UpdateTestChecks import common


# The asm scrubber returns the scrubbed asm.
# In this test we return a fixed string.
def scrub(asm, args):
    return "Test\n" "Downstream\n" "Target\n"


# The regular expression for matching func, body, etc.
regex = re.compile(
    r'^_?(?P<func>[^:]+):[ \t]*#+[ \t]*(@"?(?P=func)"?| -- Begin function (?P=func))\n(?:\s*\.?Lfunc_begin[^:\n]*:\n)?'
    r"(?:\.L(?P=func)\$local:\n)?"  # drop .L<func>$local:
    r"(?:\s*\.type\s+\.L(?P=func)\$local,@function\n)?"  # drop .type .L<func>$local
    r"(?:[ \t]*(?:\.cfi_startproc|\.cfi_personality|\.cfi_lsda|\.seh_proc|\.seh_handler)\b[^\n]*\n)*"  # drop optional cfi
    r"(?P<body>^##?[ \t]+[^:]+:.*?)\s*"
    r"^\s*(?:[^:\n]+?:\s*\n\s*\.size|\.cfi_endproc|\.globl|\.comm|\.(?:sub)?section|#+ -- End function)",
    flags=(re.M | re.S),
)


def get_run_handler(triple):
    return (scrub, regex)


def add_checks(
    output_lines,
    comment_marker,
    prefix_list,
    func_dict,
    func_name,
    ginfo: common.GeneralizerInfo,
    global_vars_seen_dict,
    is_filtered,
):
    # Label format is based on ASM string.
    check_label_format = "{} %s-LABEL: %s%s%s%s".format(comment_marker)
    return common.add_checks(
        output_lines,
        comment_marker,
        prefix_list,
        func_dict,
        func_name,
        check_label_format,
        ginfo,
        global_vars_seen_dict,
        is_filtered=is_filtered,
    )
