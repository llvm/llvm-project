## Show that llvm-readelf can handle an input file with many segments.
# RUN: yaml2obj %s -o %t
# RUN: llvm-readobj --file-headers --sections --segments %t | FileCheck %s
# RUN: llvm-readelf --segments %t | FileCheck --check-prefix=SYMS %s


--- !ELF
FileHeader:
  Class:   ELFCLASS64
  Data:    ELFDATA2LSB
  Type:    ET_EXEC
  Machine: EM_X86_64
  EPhNum:  65535
Sections:
  - Type: SHT_NULL
    Info: 2
ProgramHeaders:
  - Type:     PT_LOAD
    VAddr:    0x0001
  - Type:     PT_LOAD
    VAddr:    0x0002

## The ELF header should have e_phnum == PN_XNUM
# CHECK:        ProgramHeaderCount: 65535 (2)
## The first section header should store the real program header count in its fields.
# CHECK:      Section {
# CHECK-NEXT:   Index: 0
# CHECK-NEXT:   Name:
# CHECK-NEXT:   Type: SHT_NULL
# CHECK-NEXT:   Flags [
# CHECK-NEXT:   ]
# CHECK-NEXT:   Address:
# CHECK-NEXT:   Offset:
# CHECK-NEXT:   Size:
# CHECK-NEXT:   Link:
# CHECK-NEXT:   Info: 2
# CHECK: ProgramHeader {
# CHECK-NEXT:   Type: PT_LOAD (0x1)
# CHECK-NEXT:   Offset: 0x0
# CHECK-NEXT:   VirtualAddress: 0x1
# CHECK-NEXT:   PhysicalAddress: 0x1
# CHECK-NEXT:   FileSize: 0
# CHECK-NEXT:   MemSize: 0
# CHECK-NEXT:   Flags [ (0x0)
# CHECK-NEXT:   ]
# CHECK-NEXT:   Alignment: 1
# CHECK-NEXT: }
# CHECK-NEXT: ProgramHeader {
# CHECK-NEXT:   Type: PT_LOAD (0x1)
# CHECK-NEXT:   Offset: 0x0
# CHECK-NEXT:   VirtualAddress: 0x2
# CHECK-NEXT:   PhysicalAddress: 0x2
# CHECK-NEXT:   FileSize: 0
# CHECK-NEXT:   MemSize: 0
# CHECK-NEXT:   Flags [ (0x0)
# CHECK-NEXT:   ]
# CHECK-NEXT:   Alignment: 1
# CHECK-NEXT: }

## Show that the symbols with segments indexes around the reserved range still
## have the right segment indexes afterwards.

# SYMS: There are 2 program headers, starting at offset 64

