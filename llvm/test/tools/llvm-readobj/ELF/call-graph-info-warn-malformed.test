## Tests that --call-graph-info produces useful warnings 
## if SHT_LLVM_CALL_GRAPH type section processing idenitifies
## malformed content.

## Check format version number.
# RUN: yaml2obj --docnum=1 %s -o %t1
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t1 2>&1 | FileCheck %s -DFILE=%t1 --check-prefix=WARN_FMT_VERSION
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t1 2>&1 | FileCheck %s -DFILE=%t1 --check-prefix=WARN_FMT_VERSION

# WARN_FMT_VERSION: warning: '[[FILE]]': unknown format version value [1] in SHT_LLVM_CALL_GRAPH type section

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x01, # Format Version - only supported value is 0x00
    ]
Symbols:
  - Name:  foo
...

## Check Flags.
# RUN: yaml2obj --docnum=2 %s -o %t2
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t2 2>&1 | FileCheck %s -DFILE=%t2 --check-prefix=WARN_FLAG
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t2 2>&1 | FileCheck %s -DFILE=%t2 --check-prefix=WARN_FLAG

# WARN_FLAG: warning: '[[FILE]]': unexpected Flags value [8]

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x08, # Flags - only valid values are 0x00 to 0x07
    ]
Symbols:
  - Name:  foo
...

## Check missing direct call info.
# RUN: yaml2obj --docnum=3 %s -o %t3
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t3 2>&1 | FileCheck %s -DFILE=%t3 --check-prefix=WARN_MISSING_DIRECT
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t3 2>&1 | FileCheck %s -DFILE=%t3 --check-prefix=WARN_MISSING_DIRECT

# WARN_MISSING_DIRECT: warning: '[[FILE]]': failed while reading number of direct callees unable to decode LEB128 at offset 0x00000012: malformed uleb128, extends past end

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x03, # Flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # Function entry address
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # TypeID unknown

        #< Missing direct callees info here
    ]
Symbols:
  - Name:  foo
...

## Check missing indirect target type IDs.
# RUN: yaml2obj --docnum=4 %s -o %t4
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t4 2>&1 | FileCheck %s -DFILE=%t4 --check-prefix=WARN_MISSING_INDIRECT
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t4 2>&1 | FileCheck %s -DFILE=%t4 --check-prefix=WARN_MISSING_INDIRECT

# WARN_MISSING_INDIRECT: warning: '[[FILE]]': failed while reading indirect target type ID unexpected end of data at offset 0x13 while reading [0x13, 0x1b)

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_REL
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x04, # Flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # Function entry address
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # TypeID unknown

      # Indirect Callees List
      0x01, # NumIndirectTargetTypeIDs (1)
        #< Missing indirect call entries here.
    ]
Symbols:
  - Name:  foo
...

## Check missing relocation information.
# RUN: yaml2obj --docnum=5 %s -o %t5
# RUN: llvm-readelf --call-graph-info %t5 2>&1 | count 0
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t5 2>&1 | FileCheck %s -DFILE=%t5 --check-prefix=WARN_NO_RELOC
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t5 2>&1 | FileCheck %s -DFILE=%t5 --check-prefix=WARN_NO_RELOC

# WARN_NO_RELOC: warning: '[[FILE]]': SHT_LLVM_CALL_GRAPH type section has unknown type id for 2 indirect targets
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 2
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 19
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 29
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 56

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_REL
  Machine:  EM_X86_64
Sections:
  - Name: .text
    Type: SHT_PROGBITS
    Size: 12 # or whatever size is needed for all the data
  - Name: .llvm.callgraph
    Type: SHT_LLVM_CALL_GRAPH
    # Possible other fields, as needed for the code - I haven't inspected.
    ContentArray: [
        '0', # Format version number
        '3', # Flag IsIndirectTarget true, HasDirectCallees true
        '0', '0', '0', '0', '0', '0', '0', '0', # foo()'s address
        '0', '0', '0', '0', '0', '0', '0', '0', # foo()'s TypeID Unknown
        '1', # NumDirectCallees
        '0', '0', '0', '0', '0', '0', '0', '0', # Direct callee foo()'s address
        '0', # Format version number
        '5', # Flag IsIndirectTarget true, HasIndirectTargetTypeIDs true
        '6', '0', '0', '0', '0', '0', '0', '0', # bar()'s address
        '0', '0', '0', '0', '0', '0', '0', '0', # bar()'s TypeID Unknown
        '1', # NumIndirectTargetTypeIDs
        '16', '0', '0', '0', '0', '0', '0', '0', # Indirect callee type ID
        '0', # Format version number
        '1', # Flag IsIndirectTarget true
        '10', '0', '0', '0', '0', '0', '0', '0', # baz()'s address
        '32', '0', '0', '0', '0', '0', '0', '0', # baz()'s TypeID Unknown
      ]
  - Name:   .rela.llvm.callgraph
    Type:   SHT_RELA
    Flags:  [ SHF_INFO_LINK ]
    Link:   .symtab
    Relocations:
      # 1. Pointer to foo() definition
      - Offset: 0x2
        Symbol: foo
        Type:   R_X86_64_64

      # 2. Pointer to the call site "callq foo" (offset 5 inside foo)
      #    We relocate against 'foo' and add 5 to get the address of the instruction.
      - Offset: 0x13
        Symbol: foo
        Type:   R_X86_64_64
        Addend: 5

      # 3. Pointer to bar() definition
      - Offset: 0x1D
        Symbol: bar
        Type:   R_X86_64_64

      # 4. Pointer to baz() definition
      - Offset: 0x38
        Symbol: baz
        Type:   R_X86_64_64
Symbols:
  - Name:  foo
  - Name:  bar
  - Name:  baz
...

## Tests that --call-graph-info warns if there is no section of type SHT_LLVM_CALL_GRAPH.

# RUN: yaml2obj --docnum=6 %s -o %t
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t 2>&1 | FileCheck %s -DFILE=%t  --check-prefix=WARN_NO_SECTION
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t 2>&1 | FileCheck %s -DFILE=%t  --check-prefix=WARN_NO_SECTION

# WARN_NO_SECTION: warning: '[[FILE]]': no SHT_LLVM_CALL_GRAPH section found

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
Symbols:
  - Name:  foo
...
