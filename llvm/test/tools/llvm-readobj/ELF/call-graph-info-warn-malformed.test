## Tests that --call-graph-info produces useful warnings
## if SHT_LLVM_CALL_GRAPH type section processing idenitifies
## malformed content.

## Tests that --call-graph-info warns if there is no section of type SHT_LLVM_CALL_GRAPH.
# RUN: yaml2obj --docnum=1 %s -o %t1
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t1 2>&1 | FileCheck %s -DFILE=%t1 --check-prefix=WARN_NO_SECTION
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t1 2>&1 | FileCheck %s -DFILE=%t1 --check-prefix=WARN_NO_SECTION

# WARN_NO_SECTION: warning: '[[FILE]]': no SHT_LLVM_CALL_GRAPH section found

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
Symbols:
  - Name:  foo
...

## Check format version number.
# RUN: yaml2obj --docnum=2 %s -o %t2
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t2 2>&1 | FileCheck %s -DFILE=%t2 --check-prefix=WARN_FMT_VERSION
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t2 2>&1 | FileCheck %s -DFILE=%t2 --check-prefix=WARN_FMT_VERSION

# WARN_FMT_VERSION: warning: '[[FILE]]': unknown format version value [1] in SHT_LLVM_CALL_GRAPH type section

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x01, # Format Version - only supported value is 0x00
    ]
Symbols:
  - Name:  foo
...

## Check missing flags.
# RUN: yaml2obj --docnum=3 %s -o %t3
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t3 2>&1 | FileCheck %s -DFILE=%t3 --check-prefix=WARN_MISSING_FLAG
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t3 2>&1 | FileCheck %s -DFILE=%t3 --check-prefix=WARN_MISSING_FLAG

# WARN_MISSING_FLAG: warning: '[[FILE]]': failed while reading call graph info's Flags unexpected end of data at offset 0x1 while reading [0x1, 0x2)

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      #< Missing flags
    ]
Symbols:
  - Name:  foo
...

## Check Flags.
# RUN: yaml2obj --docnum=4 %s -o %t4
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t4 2>&1 | FileCheck %s -DFILE=%t4 --check-prefix=WARN_FLAG
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t4 2>&1 | FileCheck %s -DFILE=%t4 --check-prefix=WARN_FLAG

# WARN_FLAG: warning: '[[FILE]]': unexpected Flags value [8]

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x08, # Flags - only valid values are 0x00 to 0x07
    ]
Symbols:
  - Name:  foo
...

## Check missing function entry PC.
# RUN: yaml2obj --docnum=5 %s -o %t5
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t5 2>&1 | FileCheck %s -DFILE=%t5 --check-prefix=WARN_MISSING_PC
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t5 2>&1 | FileCheck %s -DFILE=%t5 --check-prefix=WARN_MISSING_PC

# WARN_MISSING_PC: warning: '[[FILE]]': failed while reading call graph info function entry PC unexpected end of data at offset 0x2 while reading [0x2, 0xa)

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x00, # Flags
      #< Missing function entry PC
    ]
Symbols:
  - Name:  foo
...

## Check missing function Type ID.
# RUN: yaml2obj --docnum=6 %s -o %t6
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t6 2>&1 | FileCheck %s -DFILE=%t6 --check-prefix=WARN_MISSING_TYPEID
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t6 2>&1 | FileCheck %s -DFILE=%t6 --check-prefix=WARN_MISSING_TYPEID

# WARN_MISSING_TYPEID: warning: '[[FILE]]': failed while reading function type ID unexpected end of data at offset 0xa while reading [0xa, 0x12)

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x00, # Flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # Function entry address
      #< Missing Type ID
    ]
Symbols:
  - Name:  foo
...

## Check missing number of direct callees.
# RUN: yaml2obj --docnum=7 %s -o %t7
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t7 2>&1 | FileCheck %s -DFILE=%t7 --check-prefix=WARN_MISSING_DIRECT
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t7 2>&1 | FileCheck %s -DFILE=%t7 --check-prefix=WARN_MISSING_DIRECT

# WARN_MISSING_DIRECT: warning: '[[FILE]]': failed while reading number of direct callees unable to decode LEB128 at offset 0x00000012: malformed uleb128, extends past end

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x02, # Flags (HasDirectCallees)
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # Function entry address
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # TypeID unknown
      #< Missing NumDirectCallees (ULEB128)
    ]
Symbols:
  - Name:  foo
...

## Check missing direct callee.
# RUN: yaml2obj --docnum=8 %s -o %t8
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t8 2>&1 | FileCheck %s -DFILE=%t8 --check-prefix=WARN_MISSING_CALLEE
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t8 2>&1 | FileCheck %s -DFILE=%t8 --check-prefix=WARN_MISSING_CALLEE

# WARN_MISSING_CALLEE: warning: '[[FILE]]': failed while reading direct callee unexpected end of data at offset 0x13 while reading [0x13, 0x1b)

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x02, # Flags (HasDirectCallees)
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # Function entry address
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # TypeID unknown
      0x01, # NumDirectCallees
      #< Missing direct callee address
    ]
Symbols:
  - Name:  foo
...

## Check missing number of indirect target type IDs.
# RUN: yaml2obj --docnum=9 %s -o %t9
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t9 2>&1 | FileCheck %s -DFILE=%t9 --check-prefix=WARN_MISSING_NUM_INDIRECT
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t9 2>&1 | FileCheck %s -DFILE=%t9 --check-prefix=WARN_MISSING_NUM_INDIRECT

# WARN_MISSING_NUM_INDIRECT: warning: '[[FILE]]': failed while reading number of indirect target type IDs unable to decode LEB128 at offset 0x00000012: malformed uleb128, extends past end

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_DYN
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x04, # Flags (HasIndirectCallees)
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # Function entry address
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # TypeID unknown
      #< Missing NumIndirectTargetTypeIDs (ULEB128)
    ]
Symbols:
  - Name:  foo
...

## Check missing indirect target type ID.
# RUN: yaml2obj --docnum=10 %s -o %t10
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t10 2>&1 | FileCheck %s -DFILE=%t10 --check-prefix=WARN_MISSING_INDIRECT_TARGET_TYPE_ID
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t10 2>&1 | FileCheck %s -DFILE=%t10 --check-prefix=WARN_MISSING_INDIRECT_TARGET_TYPE_ID

# WARN_MISSING_INDIRECT_TARGET_TYPE_ID: warning: '[[FILE]]': failed while reading indirect target type ID unexpected end of data at offset 0x13 while reading [0x13, 0x1b)

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_REL
  Machine:  EM_X86_64
Sections:
  - Name:  .text
    Type:  SHT_PROGBITS
    Size:  5
  - Name:  .llvm.callgraph
    Type:  SHT_LLVM_CALL_GRAPH
    ContentArray: [
      # --- Entry 1: foo (foo) ---
      0x00, # Format Version
      0x04, # Flags (HasIndirectCallees)
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # Function entry address
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # TypeID unknown
      0x01, # NumIndirectTargetTypeIDs (1)
      #< Missing indirect call entries here.
    ]
Symbols:
  - Name:  foo
...

## Check missing relocation information.
# RUN: yaml2obj --docnum=11 %s -o %t11
# RUN: llvm-readelf --call-graph-info %t11 2>&1 | count 0
# RUN: llvm-readelf --elf-output-style=LLVM --call-graph-info %t11 2>&1 | FileCheck %s -DFILE=%t11 --check-prefix=WARN_NO_RELOC
# RUN: llvm-readelf --elf-output-style=JSON --pretty-print --call-graph-info %t11 2>&1 | FileCheck %s -DFILE=%t11 --check-prefix=WARN_NO_RELOC

# WARN_NO_RELOC: warning: '[[FILE]]': SHT_LLVM_CALL_GRAPH type section has unknown type id for 2 indirect targets
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 2
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 19
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 29
# WARN_NO_RELOC: warning: '[[FILE]]': unknown relocation at offset 56

--- !ELF
FileHeader:
  Class:    ELFCLASS64
  Data:     ELFDATA2LSB
  Type:     ET_REL
  Machine:  EM_X86_64
Sections:
  - Name: .text
    Type: SHT_PROGBITS
    Size: 12 # or whatever size is needed for all the data
  - Name: .llvm.callgraph
    Type: SHT_LLVM_CALL_GRAPH
    ContentArray: [
        '0', # Format version number
        '3', # Flag IsIndirectTarget true, HasDirectCallees true
        '0', '0', '0', '0', '0', '0', '0', '0', # foo()'s address
        '0', '0', '0', '0', '0', '0', '0', '0', # foo()'s TypeID Unknown
        '1', # NumDirectCallees
        '0', '0', '0', '0', '0', '0', '0', '0', # Direct callee foo()'s address
        '0', # Format version number
        '5', # Flag IsIndirectTarget true, HasIndirectTargetTypeIDs true
        '6', '0', '0', '0', '0', '0', '0', '0', # bar()'s address
        '0', '0', '0', '0', '0', '0', '0', '0', # bar()'s TypeID Unknown
        '1', # NumIndirectTargetTypeIDs
        '16', '0', '0', '0', '0', '0', '0', '0', # Indirect callee type ID
        '0', # Format version number
        '1', # Flag IsIndirectTarget true
        '10', '0', '0', '0', '0', '0', '0', '0', # baz()'s address
        '32', '0', '0', '0', '0', '0', '0', '0', # baz()'s TypeID Unknown
      ]
  - Name:   .rela.llvm.callgraph
    Type:   SHT_RELA
    Flags:  [ SHF_INFO_LINK ]
    Link:   .symtab
    Relocations:
      # 1. Pointer to foo() definition
      - Offset: 0x2
        Symbol: foo
        Type:   R_X86_64_64

      # 2. Pointer to the call site "callq foo" (offset 5 inside foo)
      #    We relocate against 'foo' and add 5 to get the address of the instruction.
      - Offset: 0x13
        Symbol: foo
        Type:   R_X86_64_64
        Addend: 5

      # 3. Pointer to bar() definition
      - Offset: 0x1D
        Symbol: bar
        Type:   R_X86_64_64

      # 4. Pointer to baz() definition
      - Offset: 0x38
        Symbol: baz
        Type:   R_X86_64_64
Symbols:
  - Name:  foo
  - Name:  bar
  - Name:  baz
...
