DEFINE: %{local} = 0x3000
DEFINE: %{addr1l} = E8
DEFINE: %{addr3l} = D8
RUN: yaml2obj  -o %t.exe-x86_64 %p/Inputs/pseudoreloc.x86_64.yaml
RUN: llvm-readobj %t.exe-x86_64 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefixes=CHECK,CHECK-X64 --match-full-lines --implicit-check-not=warning \
RUN:     -D#WORD=8 -D#SYM1=0x20%{addr1l} -D#SYM3=0x20%{addr3l} -D#LOCAL1A=%{local} -DPREFIX=

REDEFINE: %{addr1l} = B0
REDEFINE: %{addr3l} = BC
RUN: yaml2obj   -o %t.exe-i386  %p/Inputs/pseudoreloc.i386.yaml
RUN: llvm-readobj  %t.exe-i386  --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefixes=CHECK,CHECK-386 --match-full-lines --implicit-check-not=warning \
RUN:     -D#WORD=4 -D#SYM1=0x20%{addr1l} -D#SYM3=0x20%{addr3l} -D#LOCAL1A=%{local} -DPREFIX=_

CHECK-X64:      Format: COFF-x86-64
CHECK-X64-NEXT: Arch: x86_64
CHECK-386:      Format: COFF-i386
CHECK-386-NEXT: Arch: i386
CHECK-NEXT: AddressSize: [[#%u,BW:mul(WORD,8)]]bit
CHECK-NEXT: PseudoReloc [
CHECK-NEXT:  Entry {
CHECK-NEXT:   Symbol: 0x[[#%X,SYM1]]
CHECK-NEXT:   SymbolName: sym1
CHECK-NEXT:   Target: 0x[[#%X,LOCAL1A]]
CHECK-NEXT:   TargetSymbol: .data+0x0
CHECK-NEXT:   BitWidth: [[#BW]]
CHECK-NEXT:  }
CHECK-NEXT:  Entry {
CHECK-NEXT:   Symbol: 0x[[#%X,SYM1+mul(1,WORD)]]
CHECK-NEXT:   SymbolName: sym2
CHECK-NEXT:   Target: 0x[[#%X,LOCAL1A+mul(1,WORD)]]
CHECK-NEXT:   TargetSymbol: [[PREFIX]]local2a
CHECK-NEXT:   BitWidth: [[#BW]]
CHECK-NEXT:  }
CHECK-NEXT:  Entry {
CHECK-NEXT:   Symbol: 0x[[#%X,SYM3]]
CHECK-NEXT:   SymbolName: sym3
CHECK-NEXT:   Target: 0x[[#%X,LOCAL1A+mul(2,WORD)]]
CHECK-NEXT:   TargetSymbol: [[PREFIX]]local3a
CHECK-NEXT:   BitWidth: [[#BW]]
CHECK-NEXT:  }
CHECK-NEXT:  Entry {
CHECK-NEXT:   Symbol: 0x[[#%X,SYM3]]
CHECK-NEXT:   SymbolName: sym3
CHECK-NEXT:   Target: 0x[[#%X,LOCAL1A+mul(3,WORD)]]
CHECK-NEXT:   TargetSymbol: [[PREFIX]]local3a+0x[[#%X,mul(1,WORD)]]
CHECK-NEXT:   BitWidth: [[#BW]]
CHECK-NEXT:  }
CHECK-NEXT:  Entry {
CHECK-NEXT:   Symbol: 0x[[#%X,SYM1]]
CHECK-NEXT:   SymbolName: sym1
CHECK-NEXT:   Target: 0x[[#%X,LOCAL1A+mul(4,WORD)]]
CHECK-NEXT:   TargetSymbol: [[PREFIX]]local3a+0x[[#%X,mul(2,WORD)]]
CHECK-NEXT:   BitWidth: [[#BW]]
CHECK-NEXT:  }
CHECK-NEXT: ]

; Test that llvm-readobj silently ignores missing imported symbol names.
RUN: sed -E -e '/Name: *\.rdata/,/Name:/{/SectionData:/{s/%{addr1l}200000/30000000/;s/%{addr3l}200000/00FFFF00/}}' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.corrupted-iat.exe-i386
RUN: llvm-readobj  %t.corrupted-iat.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefix=INVALIDSYMBOL --match-full-lines -D#LOCAL1A=%{local} --implicit-check-not=warning

INVALIDSYMBOL:      Symbol: 0x30
INVALIDSYMBOL-NEXT: Target: 0x[[#%X,LOCAL1A]]
INVALIDSYMBOL:      Symbol: 0xFFFF00
INVALIDSYMBOL-NEXT: Target: 0x[[#%X,LOCAL1A+8]]

; Assume the position of the relocation list for further tests.
RUN: yaml2obj %p/Inputs/pseudoreloc.i386.yaml | llvm-readobj --syms - | \
RUN:   FileCheck %s --check-prefix=RELOCPOS --match-full-lines

RELOCPOS: Name: ___RUNTIME_PSEUDO_RELOC_LIST_END__
RELOCPOS-NEXT: Value: 80
RELOCPOS: Name: ___RUNTIME_PSEUDO_RELOC_LIST__
RELOCPOS-NEXT: Value: 8

; Test that llvm-readobj shows an empty list if the relocation list has no contents.
RUN: sed -E -e '/__RUNTIME_PSEUDO_RELOC_LIST_END__/,/Name:/{/Value:/s/[0-9]+/20/}' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.empty-list.exe-i386
RUN: llvm-readobj  %t.empty-list.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefix=EMPTY --implicit-check-not=warning

RUN: sed -E -e '/__RUNTIME_PSEUDO_RELOC_LIST_END__/,/Name:/{/Value:/s/[0-9]+/8/}' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.noheader.exe-i386
RUN: llvm-readobj  %t.noheader.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefix=EMPTY --implicit-check-not=warning

; Test that llvm-readobj shows an empty list if the image is stripped.
RUN: llvm-readobj --coff-pseudoreloc %p/Inputs/imports.exe.coff-i386 2>&1 | \
RUN:   FileCheck %s --check-prefix=EMPTY --implicit-check-not=warning

; Test that llvm-readobj warns if the marker symbol of the relocation list is absent from the symbol table.
RUN: sed -e 's/__RUNTIME//' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.nosymbol.exe-i386
RUN: llvm-readobj  %t.nosymbol.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefixes=EMPTY,WARN-MISSINGMARKER

; Test that llvm-readobj shows an empty list if a .obj is specified.
RUN: llvm-readobj --coff-pseudoreloc %p/Inputs/trivial.obj.coff-i386 2>&1 | \
RUN:   FileCheck %s --check-prefix=EMPTY --implicit-check-not=warning

; Test that llvm-readobj warns if the header of the relocation list is broken.
RUN: sed -E -e '/__RUNTIME_PSEUDO_RELOC_LIST__/,/Name:/{/Value:/s/[0-9]+/20/}' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.corrupted-header.exe-i386
RUN: llvm-readobj  %t.corrupted-header.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefixes=EMPTY,WARN-INVALIDHEADER

; Test that llvm-readobj warns if end < start.
RUN: sed -E -e '/__RUNTIME_PSEUDO_RELOC_LIST_END__/,/Name:/{/Value:/s/[0-9]+/8/}' \
RUN:        -e '/__RUNTIME_PSEUDO_RELOC_LIST__/,/Name:/{/Value:/s/[0-9]+/20/}' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.negative-size.exe-i386
RUN: llvm-readobj  %t.negative-size.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefixes=EMPTY,WARN-LOWEREND

; Test that llvm-readobj warns if the marker symbol points out of the section space.
RUN: sed -E -e '/__RUNTIME_PSEUDO_RELOC_LIST_END__/,/Name:/{/Value:/s/[0-9]+/9999/}' \
RUN:        -e '/__RUNTIME_PSEUDO_RELOC_LIST__/,/Name:/{/Value:/s/[0-9]+/8888/}' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.outofrange-both.exe-i386
RUN: llvm-readobj  %t.outofrange-both.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefixes=EMPTY,WARN-OUTOFRANGE

RUN: sed -E -e '/__RUNTIME_PSEUDO_RELOC_LIST_END__/,/Name:/{/Value:/s/[0-9]+/9999/}' %p/Inputs/pseudoreloc.i386.yaml | \
RUN:   yaml2obj -o %t.outofrange-end.exe-i386
RUN: llvm-readobj  %t.outofrange-end.exe-i386 --coff-pseudoreloc 2>&1 | \
RUN:   FileCheck %s --check-prefixes=EMPTY,WARN-OUTOFRANGE

EMPTY:      Format: COFF-i386
EMPTY-NEXT: Arch: i386
EMPTY-NEXT: AddressSize: 32bit
EMPTY-NEXT: PseudoReloc [
WARN-MISSINGMARKER-NEXT: the marker symbols for runtime pseudo-relocation were not found
WARN-INVALIDHEADER-NEXT: invalid runtime pseudo-relocation records
WARN-LOWEREND-NEXT: the begin marker symbol for runtime pseudo-relocation must point lower address than where the end marker points
WARN-OUTOFRANGE-NEXT: the marker symbol of runtime pseudo-relocation points to out of the valid address space
EMPTY-NEXT: ]

To regenerate Inputs/pseudoreloc.*.yaml, run following one-liner and review actual address map:

$ split-file pseudoreloc.test /tmp/pseudoreloc && bash /tmp/pseudoreloc/generate.sh && cp /tmp/pseudoreloc/*.yaml Inputs/

#--- generate.sh
cd "$(dirname $0)"
set -e

llc -mtriple i386-mingw32 -filetype obj export1.ll -o export1.i386.o
ld.lld -m i386pe --dll export1.i386.o -o export1.i386.dll -entry=
llc -mtriple i386-mingw32 -filetype obj export2.ll -o export2.i386.o
ld.lld -m i386pe --dll export2.i386.o -o export2.i386.dll -entry=
llc -mtriple i386-mingw32 -filetype obj import.ll -o import.i386.o
ld.lld -m i386pe -S import.i386.o export1.i386.dll export2.i386.dll -o pseudoreloc.i386.exe -entry=start \
  --disable-dynamicbase --disable-reloc-section
obj2yaml pseudoreloc.i386.exe -o pseudoreloc.i386.yaml

llc -mtriple x86_64-mingw32 -filetype obj export1.ll -o export1.x86_64.o
ld.lld -m i386pep --dll export1.x86_64.o -o export1.x86_64.dll -entry=
llc -mtriple x86_64-mingw32 -filetype obj export2.ll -o export2.x86_64.o
ld.lld -m i386pep --dll export2.x86_64.o -o export2.x86_64.dll -entry=
llc -mtriple x86_64-mingw32 -filetype obj import.ll -o import.x86_64.o
ld.lld -m i386pep -S import.x86_64.o export1.x86_64.dll export2.x86_64.dll -o pseudoreloc.x86_64.exe -entry=start \
  --disable-dynamicbase --disable-reloc-section
obj2yaml pseudoreloc.x86_64.exe -o pseudoreloc.x86_64.yaml

#--- export1.ll
@sym1 = dso_local dllexport global [4 x i8] c"\11\22\33\44"
@sym2 = dso_local dllexport global [4 x i8] c"\55\66\77\88"

#--- export2.ll
@sym3 = dso_local dllexport global [4 x i8] c"\AA\BB\CC\DD"

#--- import.ll
@__RUNTIME_PSEUDO_RELOC_LIST__ = external dso_local constant ptr
@__RUNTIME_PSEUDO_RELOC_LIST_END__ = external dso_local constant ptr
@sym1 = external dso_local global [4 x i8]
@sym2 = external dso_local global [4 x i8]
@sym3 = external dso_local global [4 x i8]
@dummy_to_bump_address = private constant i64 u0x4488226655117733
@local1a = private global ptr getelementptr (i8, ptr @sym1, i32 1)
@local2a = dso_local global ptr getelementptr (i8, ptr @sym2, i32 2)
@local3a = dso_local global [2 x ptr] [ptr getelementptr (i8, ptr @sym3, i32 1), ptr getelementptr (i8, ptr @sym3, i32 1)]
@local1b = private global ptr getelementptr (i8, ptr @sym1, i32 2)

define dso_local i32 @start() noinline nounwind {
  %p1a = load ptr, ptr @local1a
  %v1a = load i8, ptr %p1a
  %x1a = sext i8 %v1a to i32
  %p2a = load ptr, ptr @local2a
  %v2a = load i8, ptr %p2a
  %x2a = sext i8 %v2a to i32
  %p3a = load ptr, ptr @local3a
  %v3a = load i8, ptr %p3a
  %x3a = sext i8 %v3a to i32
  %p1b = load ptr, ptr @local1b
  %v1b = load i8, ptr %p1b
  %x1b = sext i8 %v1b to i32
  %1 = add nsw i32 %x1a, %x2a
  %2 = add nsw i32 %x3a, %x1b
  %3 = add nsw i32 %1, %2
  ret i32 %3
}

define dso_local i32 @_pei386_runtime_relocator() noinline nounwind {
  %1 = load ptr, ptr @__RUNTIME_PSEUDO_RELOC_LIST_END__
  %2 = load ptr, ptr @__RUNTIME_PSEUDO_RELOC_LIST__
  %3 = ptrtoint ptr %1 to i64
  %4 = ptrtoint ptr %2 to i64
  %5 = sub i64 %3, %4
  %6 = trunc i64 %5 to i32
  ret i32 %6
}
