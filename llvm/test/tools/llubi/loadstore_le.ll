; NOTE: Assertions have been autogenerated by utils/update_llubi_test_checks.py UTC_ARGS: --version 6
; RUN: llubi --verbose < %s 2>&1 | FileCheck %s

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64"

%struct = type { [2 x i16], i64 }
%struct.packed = type <{ [2 x i16], i64 }>
%struct.vscale = type { <vscale x 1 x i32>, <vscale x 1 x i32> }

define void @main() {
  %alloc = alloca i32
  store i32 u0x00010203, ptr %alloc
  %val1 = load i32, ptr %alloc
  %val2 = load i32, ptr %alloc, align 2
  %gep = getelementptr i8, ptr %alloc, i64 1
  %val3 = load i8, ptr %gep
  %val4 = load <4 x i8>, ptr %alloc

  store i16 u0x0405, ptr %gep, align 1
  %val5 = load <4 x i8>, ptr %alloc
  store <2 x i16> <i16 u0x0607, i16 u0x0809>, ptr %alloc
  %val6 = load <4 x i8>, ptr %alloc
  %val7 = load <8 x i4>, ptr %alloc
  store <3 x i3> <i3 1, i3 2, i3 3>, ptr %alloc
  ; padding bits are undefined.
  %val8 = load <16 x i1>, ptr %alloc
  %val9 = load <16 x i1>, ptr %alloc
  store <8 x i3> <i3 0, i3 1, i3 2, i3 3, i3 4, i3 5, i3 6, i3 7>, ptr %alloc
  %val_bitcast = load <3 x i8>, ptr %alloc

  ; For non-byte-sized types, the padding bits must be zero.
  store i25 -1, ptr %alloc
  %val10 = load <4 x i8>, ptr %alloc
  %gep2 = getelementptr i8, ptr %alloc, i64 3
  store i8 -1, ptr %gep2
  ; If the padding bits were not zero, load yields poison value.
  %val11 = load i25, ptr %alloc

  call void @llvm.lifetime.start.p0(ptr poison)
  call void @llvm.lifetime.end.p0(ptr poison)
  %alloc_lifetime = alloca i32
  ; Load of an dead object yields poison value.
  %val12 = load i32, ptr %alloc_lifetime
  call void @llvm.lifetime.start.p0(ptr %alloc_lifetime)
  ; After lifetime.start, the object is alive but uninitialized.
  %val13 = load i32, ptr %alloc_lifetime
  %val14 = load i32, ptr %alloc_lifetime
  store i32 77, ptr %alloc_lifetime
  %val15 = load i32, ptr %alloc_lifetime
  call void @llvm.lifetime.end.p0(ptr %alloc_lifetime)
  ; Load of an dead object yields poison value.
  %val16 = load i32, ptr %alloc_lifetime

  store i32 u0xFFF80000, ptr %alloc
  %val17 = load float, ptr %alloc

  %alloc_vscale = alloca <vscale x 2 x i32>
  %insert = insertelement <vscale x 1 x i32> poison, i32 1, i32 0
  %ones = shufflevector <vscale x 1 x i32> %insert, <vscale x 1 x i32> poison, <vscale x 1 x i32> zeroinitializer
  %twos = add <vscale x 1 x i32> %ones, %ones
  store <vscale x 1 x i32> %ones, ptr %alloc_vscale
  %gep3 = getelementptr <vscale x 1 x i32>, ptr %alloc_vscale, i64 1
  store <vscale x 1 x i32> %twos, ptr %gep3
  %val18 = load <vscale x 2 x i32>, ptr %alloc_vscale

  %alloc_struct = alloca %struct
  store %struct { [2 x i16] [i16 1, i16 2], i64 3 }, ptr %alloc_struct
  %val19 = load %struct, ptr %alloc_struct
  ; Padding bytes of struct are undefined.
  %val20 = load i64, ptr %alloc_struct
  %val21 = load i64, ptr %alloc_struct

  %alloc_struct_packed = alloca %struct.packed
  store %struct.packed <{ [2 x i16] [i16 1, i16 2], i64 3 }>, ptr %alloc_struct_packed
  %val22 = load %struct.packed, ptr %alloc_struct_packed
  ; No padding bytes.
  %val23 = load i64, ptr %alloc_struct_packed
  %val24 = load i64, ptr %alloc_struct_packed

  %alloc_struct_vscale = alloca %struct.vscale
  store %struct.vscale zeroinitializer, ptr %alloc_struct_vscale
  %gep4 = getelementptr <vscale x 1 x i32>, ptr %alloc_struct_vscale, i32 1
  store <vscale x 1 x i32> %ones, ptr %gep4
  %val25 = load %struct.vscale, ptr %alloc_struct_vscale

  %alloc_array = alloca [2 x i32]
  store [2 x i32] [i32 1, i32 2], ptr %alloc_array
  %val26 = load [2 x i32], ptr %alloc_array

  ret void
}
; CHECK: Entering function: main
; CHECK-NEXT:   %alloc = alloca i32, align 4 => ptr 0x8 [alloc]
; CHECK-NEXT:   store i32 66051, ptr %alloc, align 4
; CHECK-NEXT:   %val1 = load i32, ptr %alloc, align 4 => i32 66051
; CHECK-NEXT:   %val2 = load i32, ptr %alloc, align 2 => i32 66051
; CHECK-NEXT:   %gep = getelementptr i8, ptr %alloc, i64 1 => ptr 0x9 [alloc + 1]
; CHECK-NEXT:   %val3 = load i8, ptr %gep, align 1 => i8 2
; CHECK-NEXT:   %val4 = load <4 x i8>, ptr %alloc, align 4 => { i8 3, i8 2, i8 1, i8 0 }
; CHECK-NEXT:   store i16 1029, ptr %gep, align 1
; CHECK-NEXT:   %val5 = load <4 x i8>, ptr %alloc, align 4 => { i8 3, i8 5, i8 4, i8 0 }
; CHECK-NEXT:   store <2 x i16> <i16 1543, i16 2057>, ptr %alloc, align 4
; CHECK-NEXT:   %val6 = load <4 x i8>, ptr %alloc, align 4 => { i8 7, i8 6, i8 9, i8 8 }
; CHECK-NEXT:   %val7 = load <8 x i4>, ptr %alloc, align 4 => { i4 7, i4 0, i4 6, i4 0, i4 -7, i4 0, i4 -8, i4 0 }
; CHECK-NEXT:   store <3 x i3> <i3 1, i3 2, i3 3>, ptr %alloc, align 2
; CHECK-NEXT:   %val8 = load <16 x i1>, ptr %alloc, align 2 => { T, F, F, F, T, F, T, T, F, F, T, F, F, F, F, T }
; CHECK-NEXT:   %val9 = load <16 x i1>, ptr %alloc, align 2 => { T, F, F, F, T, F, T, T, F, F, T, F, F, T, F, F }
; CHECK-NEXT:   store <8 x i3> <i3 0, i3 1, i3 2, i3 3, i3 -4, i3 -3, i3 -2, i3 -1>, ptr %alloc, align 4
; CHECK-NEXT:   %val_bitcast = load <3 x i8>, ptr %alloc, align 4 => { i8 -120, i8 -58, i8 -6 }
; CHECK-NEXT:   store i25 -1, ptr %alloc, align 4
; CHECK-NEXT:   %val10 = load <4 x i8>, ptr %alloc, align 4 => { i8 -1, i8 -1, i8 -1, i8 1 }
; CHECK-NEXT:   %gep2 = getelementptr i8, ptr %alloc, i64 3 => ptr 0xB [alloc + 3]
; CHECK-NEXT:   store i8 -1, ptr %gep2, align 1
; CHECK-NEXT:   %val11 = load i25, ptr %alloc, align 4 => poison
; CHECK-NEXT:   call void @llvm.lifetime.start.p0(ptr poison)
; CHECK-NEXT:   call void @llvm.lifetime.end.p0(ptr poison)
; CHECK-NEXT:   %alloc_lifetime = alloca i32, align 4 => ptr 0xC [alloc_lifetime]
; CHECK-NEXT:   %val12 = load i32, ptr %alloc_lifetime, align 4 => poison
; CHECK-NEXT:   call void @llvm.lifetime.start.p0(ptr %alloc_lifetime)
; CHECK-NEXT:   %val13 = load i32, ptr %alloc_lifetime, align 4 => i32 -1295355583
; CHECK-NEXT:   %val14 = load i32, ptr %alloc_lifetime, align 4 => i32 -1809495666
; CHECK-NEXT:   store i32 77, ptr %alloc_lifetime, align 4
; CHECK-NEXT:   %val15 = load i32, ptr %alloc_lifetime, align 4 => i32 77
; CHECK-NEXT:   call void @llvm.lifetime.end.p0(ptr %alloc_lifetime)
; CHECK-NEXT:   %val16 = load i32, ptr %alloc_lifetime, align 4 => poison
; CHECK-NEXT:   store i32 -524288, ptr %alloc, align 4
; CHECK-NEXT:   %val17 = load float, ptr %alloc, align 4 => NaN
; CHECK-NEXT:   %alloc_vscale = alloca <vscale x 2 x i32>, align 8 => ptr 0x10 [alloc_vscale]
; CHECK-NEXT:   %insert = insertelement <vscale x 1 x i32> poison, i32 1, i32 0 => { i32 1, poison, poison, poison }
; CHECK-NEXT:   %ones = shufflevector <vscale x 1 x i32> %insert, <vscale x 1 x i32> poison, <vscale x 1 x i32> zeroinitializer => { i32 1, i32 1, i32 1, i32 1 }
; CHECK-NEXT:   %twos = add <vscale x 1 x i32> %ones, %ones => { i32 2, i32 2, i32 2, i32 2 }
; CHECK-NEXT:   store <vscale x 1 x i32> %ones, ptr %alloc_vscale, align 4
; CHECK-NEXT:   %gep3 = getelementptr <vscale x 1 x i32>, ptr %alloc_vscale, i64 1 => ptr 0x20 [alloc_vscale + 16]
; CHECK-NEXT:   store <vscale x 1 x i32> %twos, ptr %gep3, align 4
; CHECK-NEXT:   %val18 = load <vscale x 2 x i32>, ptr %alloc_vscale, align 8 => { i32 1, i32 1, i32 1, i32 1, i32 2, i32 2, i32 2, i32 2 }
; CHECK-NEXT:   %alloc_struct = alloca %struct, align 8 => ptr 0x30 [alloc_struct]
; CHECK-NEXT:   store %struct { [2 x i16] [i16 1, i16 2], i64 3 }, ptr %alloc_struct, align 8
; CHECK-NEXT:   %val19 = load %struct, ptr %alloc_struct, align 8 => { { i16 1, i16 2 }, i64 3 }
; CHECK-NEXT:   %val20 = load i64, ptr %alloc_struct, align 8 => i64 371025319710294017
; CHECK-NEXT:   %val21 = load i64, ptr %alloc_struct, align 8 => i64 -1341035243900895231
; CHECK-NEXT:   %alloc_struct_packed = alloca %struct.packed, align 8 => ptr 0x40 [alloc_struct_packed]
; CHECK-NEXT:   store %struct.packed <{ [2 x i16] [i16 1, i16 2], i64 3 }>, ptr %alloc_struct_packed, align 1
; CHECK-NEXT:   %val22 = load %struct.packed, ptr %alloc_struct_packed, align 1 => { { i16 1, i16 2 }, i64 3 }
; CHECK-NEXT:   %val23 = load i64, ptr %alloc_struct_packed, align 8 => i64 12885032961
; CHECK-NEXT:   %val24 = load i64, ptr %alloc_struct_packed, align 8 => i64 12885032961
; CHECK-NEXT:   %alloc_struct_vscale = alloca %struct.vscale, align 8 => ptr 0x50 [alloc_struct_vscale]
; CHECK-NEXT:   store %struct.vscale zeroinitializer, ptr %alloc_struct_vscale, align 4
; CHECK-NEXT:   %gep4 = getelementptr <vscale x 1 x i32>, ptr %alloc_struct_vscale, i32 1 => ptr 0x60 [alloc_struct_vscale + 16]
; CHECK-NEXT:   store <vscale x 1 x i32> %ones, ptr %gep4, align 4
; CHECK-NEXT:   %val25 = load %struct.vscale, ptr %alloc_struct_vscale, align 4 => { { i32 0, i32 0, i32 0, i32 0 }, { i32 1, i32 1, i32 1, i32 1 } }
; CHECK-NEXT:   %alloc_array = alloca [2 x i32], align 4 => ptr 0x70 [alloc_array]
; CHECK-NEXT:   store [2 x i32] [i32 1, i32 2], ptr %alloc_array, align 4
; CHECK-NEXT:   %val26 = load [2 x i32], ptr %alloc_array, align 4 => { i32 1, i32 2 }
; CHECK-NEXT:   ret void
; CHECK-NEXT: Exiting function: main
