; NOTE: Assertions have been autogenerated by utils/update_llubi_test_checks.py UTC_ARGS: --version 6
; RUN: llubi --verbose < %s 2>&1 | FileCheck %s

define i32 @factorial_iterative(i32 %n) {
entry:
  br label %loop.body

loop.body:
  %i = phi i32 [ 1, %entry ], [ %i.next, %loop.body ]
  %acc = phi i32 [ 1, %entry ], [ %acc.next, %loop.body ]
  %acc.next = mul i32 %acc, %i
  %i.next = add i32 %i, 1
  %cond = icmp eq i32 %i, %n
  br i1 %cond, label %loop.end, label %loop.body

loop.end:
  ret i32 %acc.next
}

define i32 @factorial_recursive(i32 %x) {
entry:
  %cond = icmp eq i32 %x, 0
  br i1 %cond, label %base.case, label %recursive.case

base.case:
  ret i32 1

recursive.case:
  %x.prev = add i32 %x, -1
  %recursive.result = call i32 @factorial_recursive(i32 %x.prev)
  %result = mul i32 %x, %recursive.result
  ret i32 %result
}

define i32 @get_n(i32 %x) {
  %x.next = add i32 %x, 1
  ret i32 %x.next
}

define i32 @fib(ptr %self, i32 %n) {
  %cond = icmp ugt i32 %n, 1
  br i1 %cond, label %if.then, label %if.else

if.then:
  %sub1 = sub i32 %n, 1
  %sub2 = sub i32 %n, 2
  %res1 = call i32 @fib(ptr %self, i32 %sub1)
  %res2 = call i32 @fib(ptr %self, i32 %sub2)
  %result = add i32 %res1, %res2
  ret i32 %result

if.else:
  ret i32 1
}

define i32 @fib_iterative(i32 %n) {
entry:
  br label %loop.body

loop.body:
  %phi = phi i32 [ %n, %entry ], [ %sub1, %loop.body ]
  ; Make sure %fib2 is not updated before %fib1.
  %fib2 = phi i32 [ 1, %entry ], [ %add, %loop.body ]
  %fib1 = phi i32 [ 1, %entry ], [ %fib2, %loop.body ]
  %sub1 = sub i32 %phi, 1
  %add = add i32 %fib1, %fib2
  %loop.cond = icmp ugt i32 %phi, 1
  br i1 %loop.cond, label %loop.body, label %exit

exit:
  ret i32 %fib2
}

define i32 @main() {
  ; params & retval
  %n = call i32 @get_n(i32 4)
  ; loops
  %result_iterative = call i32 @factorial_iterative(i32 %n)
  ; recursion
  %result_recursive = call i32 @factorial_recursive(i32 %n)
  ; intrinsics
  %cmp = icmp eq i32 %result_iterative, %result_recursive
  call void @llvm.assume(i1 %cmp)
  ; switch -> case destination
  switch i32 %result_iterative, label %exit [
    i32 120, label %next1
  ]

next1:
  ; switch -> default destination
  switch i32 %result_recursive, label %next2 [
    i32 0, label %exit
  ]

next2:
  ; call blackbox
  call void asm sideeffect "", ""()
  ; invoke blackbox
  invoke void asm sideeffect "", ""() to label %next3 unwind label %cleanup

next3:
  ; callbr blackbox
  callbr void asm sideeffect "", ""() to label %next4 []

next4:
  ; invoke
  %res = invoke i32 @get_n(i32 0) to label %next5 unwind label %cleanup

next5:
  ; indirectbr
  indirectbr ptr blockaddress(@main, %exit), [ label %exit ]

cleanup:
  landingpad {} cleanup
  ret i32 1

exit:
  ; indirect call
  %fib5_v1 = call i32 @fib(ptr @fib, i32 5)
  %fib5_v2 = call i32 @fib_iterative(i32 5)
  %test = icmp ne i32 %fib5_v1, %fib5_v2
  %ret = zext i1 %test to i32
  ret i32 %ret
}
; CHECK: Entering function: main
; CHECK-NEXT: Entering function: get_n
; CHECK-NEXT:   i32 %x = i32 4
; CHECK-NEXT:   %x.next = add i32 %x, 1 => i32 5
; CHECK-NEXT:   ret i32 %x.next
; CHECK-NEXT: Exiting function: get_n
; CHECK-NEXT:   %n = call i32 @get_n(i32 4) => i32 5
; CHECK-NEXT: Entering function: factorial_iterative
; CHECK-NEXT:   i32 %n = i32 5
; CHECK-NEXT:   br label %loop.body jump to %loop.body
; CHECK-NEXT:   %i = phi i32 [ 1, %entry ], [ %i.next, %loop.body ] => i32 1
; CHECK-NEXT:   %acc = phi i32 [ 1, %entry ], [ %acc.next, %loop.body ] => i32 1
; CHECK-NEXT:   %acc.next = mul i32 %acc, %i => i32 1
; CHECK-NEXT:   %i.next = add i32 %i, 1 => i32 2
; CHECK-NEXT:   %cond = icmp eq i32 %i, %n => F
; CHECK-NEXT:   br i1 %cond, label %loop.end, label %loop.body jump to %loop.body
; CHECK-NEXT:   %i = phi i32 [ 1, %entry ], [ %i.next, %loop.body ] => i32 2
; CHECK-NEXT:   %acc = phi i32 [ 1, %entry ], [ %acc.next, %loop.body ] => i32 1
; CHECK-NEXT:   %acc.next = mul i32 %acc, %i => i32 2
; CHECK-NEXT:   %i.next = add i32 %i, 1 => i32 3
; CHECK-NEXT:   %cond = icmp eq i32 %i, %n => F
; CHECK-NEXT:   br i1 %cond, label %loop.end, label %loop.body jump to %loop.body
; CHECK-NEXT:   %i = phi i32 [ 1, %entry ], [ %i.next, %loop.body ] => i32 3
; CHECK-NEXT:   %acc = phi i32 [ 1, %entry ], [ %acc.next, %loop.body ] => i32 2
; CHECK-NEXT:   %acc.next = mul i32 %acc, %i => i32 6
; CHECK-NEXT:   %i.next = add i32 %i, 1 => i32 4
; CHECK-NEXT:   %cond = icmp eq i32 %i, %n => F
; CHECK-NEXT:   br i1 %cond, label %loop.end, label %loop.body jump to %loop.body
; CHECK-NEXT:   %i = phi i32 [ 1, %entry ], [ %i.next, %loop.body ] => i32 4
; CHECK-NEXT:   %acc = phi i32 [ 1, %entry ], [ %acc.next, %loop.body ] => i32 6
; CHECK-NEXT:   %acc.next = mul i32 %acc, %i => i32 24
; CHECK-NEXT:   %i.next = add i32 %i, 1 => i32 5
; CHECK-NEXT:   %cond = icmp eq i32 %i, %n => F
; CHECK-NEXT:   br i1 %cond, label %loop.end, label %loop.body jump to %loop.body
; CHECK-NEXT:   %i = phi i32 [ 1, %entry ], [ %i.next, %loop.body ] => i32 5
; CHECK-NEXT:   %acc = phi i32 [ 1, %entry ], [ %acc.next, %loop.body ] => i32 24
; CHECK-NEXT:   %acc.next = mul i32 %acc, %i => i32 120
; CHECK-NEXT:   %i.next = add i32 %i, 1 => i32 6
; CHECK-NEXT:   %cond = icmp eq i32 %i, %n => T
; CHECK-NEXT:   br i1 %cond, label %loop.end, label %loop.body jump to %loop.end
; CHECK-NEXT:   ret i32 %acc.next
; CHECK-NEXT: Exiting function: factorial_iterative
; CHECK-NEXT:   %result_iterative = call i32 @factorial_iterative(i32 %n) => i32 120
; CHECK-NEXT: Entering function: factorial_recursive
; CHECK-NEXT:   i32 %x = i32 5
; CHECK-NEXT:   %cond = icmp eq i32 %x, 0 => F
; CHECK-NEXT:   br i1 %cond, label %base.case, label %recursive.case jump to %recursive.case
; CHECK-NEXT:   %x.prev = add i32 %x, -1 => i32 4
; CHECK-NEXT: Entering function: factorial_recursive
; CHECK-NEXT:   i32 %x = i32 4
; CHECK-NEXT:   %cond = icmp eq i32 %x, 0 => F
; CHECK-NEXT:   br i1 %cond, label %base.case, label %recursive.case jump to %recursive.case
; CHECK-NEXT:   %x.prev = add i32 %x, -1 => i32 3
; CHECK-NEXT: Entering function: factorial_recursive
; CHECK-NEXT:   i32 %x = i32 3
; CHECK-NEXT:   %cond = icmp eq i32 %x, 0 => F
; CHECK-NEXT:   br i1 %cond, label %base.case, label %recursive.case jump to %recursive.case
; CHECK-NEXT:   %x.prev = add i32 %x, -1 => i32 2
; CHECK-NEXT: Entering function: factorial_recursive
; CHECK-NEXT:   i32 %x = i32 2
; CHECK-NEXT:   %cond = icmp eq i32 %x, 0 => F
; CHECK-NEXT:   br i1 %cond, label %base.case, label %recursive.case jump to %recursive.case
; CHECK-NEXT:   %x.prev = add i32 %x, -1 => i32 1
; CHECK-NEXT: Entering function: factorial_recursive
; CHECK-NEXT:   i32 %x = i32 1
; CHECK-NEXT:   %cond = icmp eq i32 %x, 0 => F
; CHECK-NEXT:   br i1 %cond, label %base.case, label %recursive.case jump to %recursive.case
; CHECK-NEXT:   %x.prev = add i32 %x, -1 => i32 0
; CHECK-NEXT: Entering function: factorial_recursive
; CHECK-NEXT:   i32 %x = i32 0
; CHECK-NEXT:   %cond = icmp eq i32 %x, 0 => T
; CHECK-NEXT:   br i1 %cond, label %base.case, label %recursive.case jump to %base.case
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: factorial_recursive
; CHECK-NEXT:   %recursive.result = call i32 @factorial_recursive(i32 %x.prev) => i32 1
; CHECK-NEXT:   %result = mul i32 %x, %recursive.result => i32 1
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: factorial_recursive
; CHECK-NEXT:   %recursive.result = call i32 @factorial_recursive(i32 %x.prev) => i32 1
; CHECK-NEXT:   %result = mul i32 %x, %recursive.result => i32 2
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: factorial_recursive
; CHECK-NEXT:   %recursive.result = call i32 @factorial_recursive(i32 %x.prev) => i32 2
; CHECK-NEXT:   %result = mul i32 %x, %recursive.result => i32 6
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: factorial_recursive
; CHECK-NEXT:   %recursive.result = call i32 @factorial_recursive(i32 %x.prev) => i32 6
; CHECK-NEXT:   %result = mul i32 %x, %recursive.result => i32 24
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: factorial_recursive
; CHECK-NEXT:   %recursive.result = call i32 @factorial_recursive(i32 %x.prev) => i32 24
; CHECK-NEXT:   %result = mul i32 %x, %recursive.result => i32 120
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: factorial_recursive
; CHECK-NEXT:   %result_recursive = call i32 @factorial_recursive(i32 %n) => i32 120
; CHECK-NEXT:   %cmp = icmp eq i32 %result_iterative, %result_recursive => T
; CHECK-NEXT:   call void @llvm.assume(i1 %cmp)
; CHECK-NEXT:   switch i32 %result_iterative, label %exit [
; CHECK-NEXT:     i32 120, label %next1
; CHECK-NEXT:   ] jump to %next1
; CHECK-NEXT:   switch i32 %result_recursive, label %next2 [
; CHECK-NEXT:     i32 0, label %exit
; CHECK-NEXT:   ] jump to %next2
; CHECK-NEXT:   call void asm sideeffect "", ""()
; CHECK-NEXT:   invoke void asm sideeffect "", ""()
; CHECK-NEXT:           to label %next3 unwind label %cleanup
; CHECK-NEXT:   invoke void asm sideeffect "", ""()
; CHECK-NEXT:           to label %next3 unwind label %cleanup jump to %next3
; CHECK-NEXT:   callbr void asm sideeffect "", ""()
; CHECK-NEXT:           to label %next4 [] jump to %next4
; CHECK-NEXT: Entering function: get_n
; CHECK-NEXT:   i32 %x = i32 0
; CHECK-NEXT:   %x.next = add i32 %x, 1 => i32 1
; CHECK-NEXT:   ret i32 %x.next
; CHECK-NEXT: Exiting function: get_n
; CHECK-NEXT:   %res = invoke i32 @get_n(i32 0)
; CHECK-NEXT:           to label %next5 unwind label %cleanup => i32 1
; CHECK-NEXT:   %res = invoke i32 @get_n(i32 0)
; CHECK-NEXT:           to label %next5 unwind label %cleanup jump to %next5
; CHECK-NEXT:   indirectbr ptr blockaddress(@main, %exit), [label %exit] jump to %exit
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 5
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => T
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.then
; CHECK-NEXT:   %sub1 = sub i32 %n, 1 => i32 4
; CHECK-NEXT:   %sub2 = sub i32 %n, 2 => i32 3
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 4
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => T
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.then
; CHECK-NEXT:   %sub1 = sub i32 %n, 1 => i32 3
; CHECK-NEXT:   %sub2 = sub i32 %n, 2 => i32 2
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 3
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => T
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.then
; CHECK-NEXT:   %sub1 = sub i32 %n, 1 => i32 2
; CHECK-NEXT:   %sub2 = sub i32 %n, 2 => i32 1
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 2
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => T
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.then
; CHECK-NEXT:   %sub1 = sub i32 %n, 1 => i32 1
; CHECK-NEXT:   %sub2 = sub i32 %n, 2 => i32 0
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 1
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res1 = call i32 @fib(ptr %self, i32 %sub1) => i32 1
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 0
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res2 = call i32 @fib(ptr %self, i32 %sub2) => i32 1
; CHECK-NEXT:   %result = add i32 %res1, %res2 => i32 2
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res1 = call i32 @fib(ptr %self, i32 %sub1) => i32 2
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 1
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res2 = call i32 @fib(ptr %self, i32 %sub2) => i32 1
; CHECK-NEXT:   %result = add i32 %res1, %res2 => i32 3
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res1 = call i32 @fib(ptr %self, i32 %sub1) => i32 3
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 2
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => T
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.then
; CHECK-NEXT:   %sub1 = sub i32 %n, 1 => i32 1
; CHECK-NEXT:   %sub2 = sub i32 %n, 2 => i32 0
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 1
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res1 = call i32 @fib(ptr %self, i32 %sub1) => i32 1
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 0
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res2 = call i32 @fib(ptr %self, i32 %sub2) => i32 1
; CHECK-NEXT:   %result = add i32 %res1, %res2 => i32 2
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res2 = call i32 @fib(ptr %self, i32 %sub2) => i32 2
; CHECK-NEXT:   %result = add i32 %res1, %res2 => i32 5
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res1 = call i32 @fib(ptr %self, i32 %sub1) => i32 5
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 3
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => T
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.then
; CHECK-NEXT:   %sub1 = sub i32 %n, 1 => i32 2
; CHECK-NEXT:   %sub2 = sub i32 %n, 2 => i32 1
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 2
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => T
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.then
; CHECK-NEXT:   %sub1 = sub i32 %n, 1 => i32 1
; CHECK-NEXT:   %sub2 = sub i32 %n, 2 => i32 0
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 1
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res1 = call i32 @fib(ptr %self, i32 %sub1) => i32 1
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 0
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res2 = call i32 @fib(ptr %self, i32 %sub2) => i32 1
; CHECK-NEXT:   %result = add i32 %res1, %res2 => i32 2
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res1 = call i32 @fib(ptr %self, i32 %sub1) => i32 2
; CHECK-NEXT: Entering function: fib
; CHECK-NEXT:   ptr %self = ptr 0x8 [fib]
; CHECK-NEXT:   i32 %n = i32 1
; CHECK-NEXT:   %cond = icmp ugt i32 %n, 1 => F
; CHECK-NEXT:   br i1 %cond, label %if.then, label %if.else jump to %if.else
; CHECK-NEXT:   ret i32 1
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res2 = call i32 @fib(ptr %self, i32 %sub2) => i32 1
; CHECK-NEXT:   %result = add i32 %res1, %res2 => i32 3
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %res2 = call i32 @fib(ptr %self, i32 %sub2) => i32 3
; CHECK-NEXT:   %result = add i32 %res1, %res2 => i32 8
; CHECK-NEXT:   ret i32 %result
; CHECK-NEXT: Exiting function: fib
; CHECK-NEXT:   %fib5_v1 = call i32 @fib(ptr @fib, i32 5) => i32 8
; CHECK-NEXT: Entering function: fib_iterative
; CHECK-NEXT:   i32 %n = i32 5
; CHECK-NEXT:   br label %loop.body jump to %loop.body
; CHECK-NEXT:   %phi = phi i32 [ %n, %entry ], [ %sub1, %loop.body ] => i32 5
; CHECK-NEXT:   %fib2 = phi i32 [ 1, %entry ], [ %add, %loop.body ] => i32 1
; CHECK-NEXT:   %fib1 = phi i32 [ 1, %entry ], [ %fib2, %loop.body ] => i32 1
; CHECK-NEXT:   %sub1 = sub i32 %phi, 1 => i32 4
; CHECK-NEXT:   %add = add i32 %fib1, %fib2 => i32 2
; CHECK-NEXT:   %loop.cond = icmp ugt i32 %phi, 1 => T
; CHECK-NEXT:   br i1 %loop.cond, label %loop.body, label %exit jump to %loop.body
; CHECK-NEXT:   %phi = phi i32 [ %n, %entry ], [ %sub1, %loop.body ] => i32 4
; CHECK-NEXT:   %fib2 = phi i32 [ 1, %entry ], [ %add, %loop.body ] => i32 2
; CHECK-NEXT:   %fib1 = phi i32 [ 1, %entry ], [ %fib2, %loop.body ] => i32 1
; CHECK-NEXT:   %sub1 = sub i32 %phi, 1 => i32 3
; CHECK-NEXT:   %add = add i32 %fib1, %fib2 => i32 3
; CHECK-NEXT:   %loop.cond = icmp ugt i32 %phi, 1 => T
; CHECK-NEXT:   br i1 %loop.cond, label %loop.body, label %exit jump to %loop.body
; CHECK-NEXT:   %phi = phi i32 [ %n, %entry ], [ %sub1, %loop.body ] => i32 3
; CHECK-NEXT:   %fib2 = phi i32 [ 1, %entry ], [ %add, %loop.body ] => i32 3
; CHECK-NEXT:   %fib1 = phi i32 [ 1, %entry ], [ %fib2, %loop.body ] => i32 2
; CHECK-NEXT:   %sub1 = sub i32 %phi, 1 => i32 2
; CHECK-NEXT:   %add = add i32 %fib1, %fib2 => i32 5
; CHECK-NEXT:   %loop.cond = icmp ugt i32 %phi, 1 => T
; CHECK-NEXT:   br i1 %loop.cond, label %loop.body, label %exit jump to %loop.body
; CHECK-NEXT:   %phi = phi i32 [ %n, %entry ], [ %sub1, %loop.body ] => i32 2
; CHECK-NEXT:   %fib2 = phi i32 [ 1, %entry ], [ %add, %loop.body ] => i32 5
; CHECK-NEXT:   %fib1 = phi i32 [ 1, %entry ], [ %fib2, %loop.body ] => i32 3
; CHECK-NEXT:   %sub1 = sub i32 %phi, 1 => i32 1
; CHECK-NEXT:   %add = add i32 %fib1, %fib2 => i32 8
; CHECK-NEXT:   %loop.cond = icmp ugt i32 %phi, 1 => T
; CHECK-NEXT:   br i1 %loop.cond, label %loop.body, label %exit jump to %loop.body
; CHECK-NEXT:   %phi = phi i32 [ %n, %entry ], [ %sub1, %loop.body ] => i32 1
; CHECK-NEXT:   %fib2 = phi i32 [ 1, %entry ], [ %add, %loop.body ] => i32 8
; CHECK-NEXT:   %fib1 = phi i32 [ 1, %entry ], [ %fib2, %loop.body ] => i32 5
; CHECK-NEXT:   %sub1 = sub i32 %phi, 1 => i32 0
; CHECK-NEXT:   %add = add i32 %fib1, %fib2 => i32 13
; CHECK-NEXT:   %loop.cond = icmp ugt i32 %phi, 1 => F
; CHECK-NEXT:   br i1 %loop.cond, label %loop.body, label %exit jump to %exit
; CHECK-NEXT:   ret i32 %fib2
; CHECK-NEXT: Exiting function: fib_iterative
; CHECK-NEXT:   %fib5_v2 = call i32 @fib_iterative(i32 5) => i32 8
; CHECK-NEXT:   %test = icmp ne i32 %fib5_v1, %fib5_v2 => F
; CHECK-NEXT:   %ret = zext i1 %test to i32 => i32 0
; CHECK-NEXT:   ret i32 %ret
; CHECK-NEXT: Exiting function: main
