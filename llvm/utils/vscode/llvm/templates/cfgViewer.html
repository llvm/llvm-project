<!-- Most of the code in this file was created using Gemini 2.5 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive View of ${fileName}</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* Darker background, common in IDEs */
            background-color: #1e1e1e;
            display: flex;
            flex-direction: column;
            /* A more common IDE font */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* Lighter default text color for dark theme */
            color: #d4d4d4;
        }

        h2 {
            padding: 10px 15px;
            margin: 0;
            /* Slightly lighter than body for header */
            background-color: #252526;
            border-bottom: 1px solid #333;
            font-size: 1.1em;
            font-weight: normal;
            color: #d4d4d4;
            flex-shrink: 0;
        }

        #search-controls {
            padding: 8px 15px;
            /* Distinct from header and body */
            background-color: #2c2c2c;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
            border-bottom: 1px solid #3c3c3c;
        }

        #search-input {
            flex-grow: 1;
            padding: 6px 10px;
            border: 1px solid #444;
            background-color: #333;
            color: #d4d4d4;
            border-radius: 4px;
            outline: none;
            transition: border-color 0.2s ease-in-out;
        }

        #search-input:focus {
            /* VS Code blue highlight on focus */
            border-color: #007acc;
        }

        #search-controls button {
            padding: 6px 12px;
            /* VS Code primary button color */
            background-color: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
            font-size: 0.9em;
        }

        #search-controls button:hover {
            background-color: #005f99;
            transform: translateY(-1px);
        }

        #search-controls button:active {
            transform: translateY(0);
        }

        #search-status {
            color: #a0a0a0;
            font-size: 0.85em;
            /* Prevent text jumping */
            min-width: 80px;
            text-align: right;
        }

        #clear-search {
            margin-left: auto;
            /* Different color for clear button */
            background-color: #5a5a5a;
        }

        #clear-search:hover {
            background-color: #7a7a7a;
        }

        #svg-container {
            width: 100%;
            flex-grow: 1;
            cursor: default;
            overflow: hidden;
            user-select: none;
            position: relative;
            /* Match body background */
            background-color: #1e1e1e;
        }

        #svg-container.pannable-ctrl {
            cursor: grab;
        }

        #svg-container.panning {
            cursor: grabbing;
        }

        svg {
            transform-origin: 0 0;
            user-select: none;
            width: 100%;
            height: 100%;
        }

        /* Highlighting for search results */
        /* Using a more subtle green/blue for highlights that fits a dark theme */
        .search-highlight {
            /* Greenish */
            fill: #4CAF50 !important;
            font-weight: bold;
            transition: fill 0.2s ease-in-out;
        }

        .current-search-highlight {
            /* Sky Blue */
            fill: #00BFFF !important;
            font-weight: bold;
            transition: fill 0.2s ease-in-out;
            /* A thin border for the current match */
            outline: 1px solid #00BFFF;
            outline-offset: 2px;
        }

        svg *[id].node:hover,
        svg *[id].edge:hover {
            opacity: 0.9;
            cursor: pointer;
            /* Subtle hover outline */
            outline: 1px dashed #66b3ff;
            outline-offset: 2px;
            transition: opacity 0.2s ease-in-out, outline-color 0.2s ease-in-out;
        }

        svg *[id].node text,
        svg *[id].edge text,
        svg *[id].node tspan,
        svg *[id].edge tspan {
            cursor: text;
            user-select: text;
        }
    </style>
</head>

<body>
    <h2>Interactive view of ${fileName}</h2>
    <div id="search-controls">
        <input type="text" id="search-input" placeholder="Search text in SVG...">
        <button id="prev-match">Previous</button>
        <button id="next-match">Next</button>
        <span id="search-status"></span>
        <button id="clear-search" style="margin-left: auto;">Clear</button>
    </div>
    <div id="svg-container">
        ${svgContent}
    </div>

    <script>
            // --- VS Code API Communication ---
            const vscode = typeof acquireVsCodeApi === 'function' ? acquireVsCodeApi() : null;

            function postVsCodeMessage(command, data = {}) {
                if (vscode) {
                    vscode.postMessage({ command, ...data });
                } else {
                    console.warn('VS Code API not available. Cannot post message:', command, data);
                }
        }

            function debugLog(msg) {
                postVsCodeMessage('cfgViewerDebug', { msg: `[InteractiveView script DEBUG] ${msg}` });
            }

            // --- DOM Elements ---
            const svgContainer = document.getElementById('svg-container');
        const searchInput = document.getElementById('search-input');
        const prevMatchButton = document.getElementById('prev-match');
        const nextMatchButton = document.getElementById('next-match');
        const searchStatus = document.getElementById('search-status');
        const clearSearchButton = document.getElementById('clear-search');

            let svgElement = null; // Will be set after SVG content is loaded

            // --- State Variables ---
            const P_Z_STATE = { // Pan/Zoom State
                scale: 1,
                panOffset: { x: 0, y: 0 },
                isPanning: false,
                ctrlPressed: false,
                startPoint: { x: 0, y: 0 }, // Mouse position at mousedown
                dragThreshold: 3, // Pixels before a mousemove becomes a drag
                hasDragged: false,
                panInitiatorButton: -1 // 0 for left, 1 for middle
            };

            const SEARCH_STATE = {
                results: [],
                currentIndex: -1
            };

            // --- Utility Functions ---

            /**
             * Applies the current pan and zoom transform to the SVG element.
             */
            function updateSvgTransform() {
                if (svgElement) {
                    const { panOffset, scale } = P_Z_STATE;
                    svgElement.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${scale})`;
            }
        }

            /**
             * Centers the view on a given SVG element.
             * @param {SVGElement} element - The SVG element to center on.
             */
            function centerOnElement(element) {
                debugLog('centerOnElement()');
                if (!element || !svgContainer || !svgElement) return;

            // Ensure element has correct layout properties
            element.getBoundingClientRect();

            const elementRect = element.getBoundingClientRect(); // Relative to viewport
            const containerRect = svgContainer.getBoundingClientRect(); // Relative to viewport

            if (elementRect.width === 0 && elementRect.height === 0) {
                console.warn("Cannot center on an element with zero dimensions:", element);
                return;
            }

            const currentSvgScale = P_Z_STATE.scale;

            // Calculate centers in viewport coordinates
            const elementCenterX = elementRect.left + elementRect.width / 2;
            const elementCenterY = elementRect.top + elementRect.height / 2;
            const containerCenterX = containerRect.left + containerRect.width / 2;
            const containerCenterY = containerRect.top + containerRect.height / 2;

            // Desired shift in viewport pixels
            const dxViewport = containerCenterX - elementCenterX;
            const dyViewport = containerCenterY - elementCenterY;

            // Convert viewport shift to SVG pan units
            P_Z_STATE.panOffset.x += dxViewport;
            P_Z_STATE.panOffset.y += dyViewport;

            updateSvgTransform();
        }

            // --- SVG Content Initialization ---
            function initializeSvgContent() {
                svgElement = svgContainer.querySelector('svg');
                if (svgElement) {
                    svgElement.style.transformOrigin = '0 0';
                    updateSvgTransform();
                    debugLog('SVG element initialized.');
                } else {
                    console.error("SVG element not found inside #svg-container.");
                }
            }

            // Call on initial load
            initializeSvgContent();

            // --- Event Handlers ---

            // Panning and Zooming
            const handleWheel = (event) => {
                // Only zoom with Ctrl or if search input is not focused
                if (!P_Z_STATE.ctrlPressed && document.activeElement !== searchInput) return;
                if (document.activeElement === searchInput && !P_Z_STATE.ctrlPressed) return;

            event.preventDefault(); // Prevent page scrolling

            const zoomIntensity = 0.1;
            const direction = event.deltaY < 0 ? 1 : -1; // -1 for wheel down (zoom out), 1 for wheel up (zoom in)
            const oldScale = P_Z_STATE.scale;

            P_Z_STATE.scale += direction * zoomIntensity * P_Z_STATE.scale;
            P_Z_STATE.scale = Math.max(0.05, Math.min(P_Z_STATE.scale, 20)); // Clamp scale

            const rect = svgContainer.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            P_Z_STATE.panOffset.x = mouseX - (mouseX - P_Z_STATE.panOffset.x) * (P_Z_STATE.scale / oldScale);
            P_Z_STATE.panOffset.y = mouseY - (mouseY - P_Z_STATE.panOffset.y) * (P_Z_STATE.scale / oldScale);

            updateSvgTransform();
        };

            const handleMouseDown = (event) => {
                if (event.target.closest('#search-controls')) return;

            // Check if clicking directly on text within a node/edge
            let target = event.target;
            let isTextElement = false;
            while (target && target !== svgElement) {
                if ((target.tagName === 'text' || target.tagName === 'tspan') &&
                    target.closest && target.closest('.node, .edge')) {
                    isTextElement = true;
                    break;
                }
                target = target.parentElement;
            }
            if (isTextElement && !P_Z_STATE.ctrlPressed && event.button === 0) {
                // Allow default text selection for left-click on text without Ctrl
                return;
            }

            // Initiate pan with Ctrl+Left or Middle Mouse Button
            if ((P_Z_STATE.ctrlPressed && event.button === 0) || event.button === 1) {
                P_Z_STATE.isPanning = true;
                P_Z_STATE.panInitiatorButton = event.button;
                P_Z_STATE.hasDragged = false;
                svgContainer.classList.remove('pannable-ctrl');
                svgContainer.classList.add('panning');
                P_Z_STATE.dragStartPos = { x: event.clientX, y: event.clientY };
                P_Z_STATE.startPoint = { x: event.clientX - P_Z_STATE.panOffset.x, y: event.clientY - P_Z_STATE.panOffset.y };
                event.preventDefault(); // Prevent default browser drag behaviors
            } else if (event.button === 0) {
                // Left click without Ctrl for potential click event (not drag)
                P_Z_STATE.hasDragged = false;
                P_Z_STATE.dragStartPos = { x: event.clientX, y: event.clientY };
            }
        };

            const handleMouseMove = (event) => {
                if (!P_Z_STATE.isPanning) return;

            if (!P_Z_STATE.hasDragged) {
                const dx = event.clientX - P_Z_STATE.dragStartPos.x;
                const dy = event.clientY - P_Z_STATE.dragStartPos.y;
                if (Math.abs(dx) > P_Z_STATE.dragThreshold || Math.abs(dy) > P_Z_STATE.dragThreshold) {
                    P_Z_STATE.hasDragged = true;
                }
            }

            if (P_Z_STATE.hasDragged) {
                event.preventDefault();
                P_Z_STATE.panOffset.x = event.clientX - P_Z_STATE.startPoint.x;
                P_Z_STATE.panOffset.y = event.clientY - P_Z_STATE.startPoint.y;
                updateSvgTransform();
            }
        };

            const handleMouseUp = (event) => {
                const clickedOnSearchControls = event.target.closest('#search-controls');

            if (P_Z_STATE.isPanning && (event.button === P_Z_STATE.panInitiatorButton || P_Z_STATE.panInitiatorButton === -1)) {
                P_Z_STATE.isPanning = false;
                P_Z_STATE.panInitiatorButton = -1;
                svgContainer.classList.remove('panning');
                if (P_Z_STATE.ctrlPressed) {
                    svgContainer.classList.add('pannable-ctrl');
                } else {
                    svgContainer.classList.remove('pannable-ctrl');
                }
            }

            // Handle non-dragged left clicks on SVG elements
            if (!P_Z_STATE.hasDragged && event.button === 0 && !P_Z_STATE.ctrlPressed && !clickedOnSearchControls) {
                let clickedElement = event.target;
                let actionableElement = null;
                while (clickedElement && clickedElement !== svgElement) {
                    if (clickedElement.id && (clickedElement.classList.contains('node') || clickedElement.classList.contains('edge'))) {
                        actionableElement = clickedElement;
                        break;
                    }
                    clickedElement = clickedElement.parentElement;
                }

                if (actionableElement) {
                    let actualClickTarget = event.target;
                    let isTextClick = false;
                    while (actualClickTarget && actualClickTarget !== actionableElement.parentElement) {
                        if ((actualClickTarget.tagName === 'text' || actualClickTarget.tagName === 'tspan') && actualClickTarget.closest('#' + actionableElement.id)) {
                            isTextClick = true;
                            break;
                        }
                        if (actualClickTarget === actionableElement) break;
                        actualClickTarget = actualClickTarget.parentElement;
                    }

                    if (!isTextClick) {
                        postVsCodeMessage('svgElementClicked', { elementId: actionableElement.id });
                        debugLog(`SVG element clicked: ${actionableElement.id}`);
                    }
                }
            }
            P_Z_STATE.hasDragged = false;
        };

            const handleKeyDown = (event) => {
                if (event.key === 'Control' && !P_Z_STATE.ctrlPressed) {
                    P_Z_STATE.ctrlPressed = true;
                    if (!P_Z_STATE.isPanning) svgContainer.classList.add('pannable-ctrl');
                }
                if (document.activeElement === searchInput) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        SEARCH_MODULE.navigateNextMatch(true); // Navigate and refocus input
                    } else if (event.key === 'Escape') {
                        SEARCH_MODULE.clearSearchAndResults();
                    }
                }
            };

            const handleKeyUp = (event) => {
                if (event.key === 'Control') {
                    P_Z_STATE.ctrlPressed = false;
                    if (!P_Z_STATE.isPanning) {
                        svgContainer.classList.remove('pannable-ctrl');
                        svgContainer.classList.remove('panning');
                    }
                }
            };

            const handleWindowBlur = () => {
                // Reset Ctrl state and panning when window loses focus
                if (P_Z_STATE.ctrlPressed) {
                    P_Z_STATE.ctrlPressed = false;
                    svgContainer.classList.remove('pannable-ctrl');
            }
            if (P_Z_STATE.isPanning) {
                P_Z_STATE.isPanning = false;
                svgContainer.classList.remove('panning');
                P_Z_STATE.panInitiatorButton = -1;
            }
        };

            // --- Search Module ---
            const SEARCH_MODULE = (() => {
            function clearHighlights() {
                if (!svgElement) return;
                svgElement.querySelectorAll('.search-highlight, .current-search-highlight').forEach(el => {
                    el.classList.remove('search-highlight', 'current-search-highlight');
                    // Potentially remove outline as well
                    el.style.outline = '';
                    el.style.outlineOffset = '';
                });
            }

            function performSearch() {
                clearHighlights();
                SEARCH_STATE.results = [];
                SEARCH_STATE.currentIndex = -1;
                const searchTerm = searchInput.value.trim().toLowerCase();

                if (!searchTerm) {
                    searchStatus.textContent = "";
                    return;
                }
                if (!svgElement) {
                    searchStatus.textContent = "SVG not loaded.";
                    return;
                }

                const textElements = svgElement.querySelectorAll('text, tspan');
                textElements.forEach(el => {
                    if (el.textContent.toLowerCase().includes(searchTerm)) {
                        SEARCH_STATE.results.push(el);
                        el.classList.add('search-highlight');
                    }
                });

                if (SEARCH_STATE.results.length > 0) {
                    SEARCH_STATE.currentIndex = 0;
                    navigateToMatch(SEARCH_STATE.currentIndex);
                } else {
                    searchStatus.textContent = "No matches";
                }
            }

            function navigateToMatch(index, refocusInput = false) {
                if (SEARCH_STATE.results.length === 0 || index < 0 || index >= SEARCH_STATE.results.length) {
                    searchStatus.textContent = SEARCH_STATE.results.length > 0 ?
                        `${SEARCH_STATE.currentIndex + 1} of ${SEARCH_STATE.results.length}` : "No matches";
                    return;
                }

                // Remove 'current' highlight from previous match
                if (SEARCH_STATE.currentIndex !== -1 && SEARCH_STATE.results[SEARCH_STATE.currentIndex]) {
                    SEARCH_STATE.results[SEARCH_STATE.currentIndex].classList.remove('current-search-highlight');
                    SEARCH_STATE.results[SEARCH_STATE.currentIndex].classList.add('search-highlight');
                }

                SEARCH_STATE.currentIndex = index;
                const currentElement = SEARCH_STATE.results[SEARCH_STATE.currentIndex];
                currentElement.classList.add('current-search-highlight');
                currentElement.classList.remove('search-highlight');

                searchStatus.textContent = `${SEARCH_STATE.currentIndex + 1} of ${SEARCH_STATE.results.length}`;
                centerOnElement(currentElement);

                if (refocusInput) {
                    searchInput.focus();
                    searchInput.select();
                }
            }

            function navigateNextMatch(refocus = false) {
                if (SEARCH_STATE.results.length > 0) {
                    const nextIndex = (SEARCH_STATE.currentIndex + 1) % SEARCH_STATE.results.length;
                    navigateToMatch(nextIndex, refocus);
                } else {
                    performSearch(); // If no results, try to search again
                }
            }

            function navigatePrevMatch() {
                if (SEARCH_STATE.results.length > 0) {
                    const prevIndex = (SEARCH_STATE.currentIndex - 1 + SEARCH_STATE.results.length) % SEARCH_STATE.results.length;
                    navigateToMatch(prevIndex);
                } else {
                    performSearch(); // If no results, try to search again
                }
            }

            function clearSearchAndResults() {
                searchInput.value = "";
                clearHighlights();
                SEARCH_STATE.results = [];
                SEARCH_STATE.currentIndex = -1;
                searchStatus.textContent = "";
            }

            // Public API for the search module
            return {
                performSearch,
                navigateNextMatch,
                navigatePrevMatch,
                clearSearchAndResults,
                clearHighlights // Expose for external use if needed (e.g., SVG content update)
            };
        })();

            // --- Event Listener Registrations ---
            svgContainer.addEventListener('wheel', handleWheel, { passive: false });
            svgContainer.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove); // Listen on document for continuous drag
            document.addEventListener('mouseup', handleMouseUp);   // Listen on document to capture release outside container

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('blur', handleWindowBlur);

            searchInput.addEventListener('input', SEARCH_MODULE.performSearch);
            nextMatchButton.addEventListener('click', () => SEARCH_MODULE.navigateNextMatch());
            prevMatchButton.addEventListener('click', SEARCH_MODULE.navigatePrevMatch);
            clearSearchButton.addEventListener('click', SEARCH_MODULE.clearSearchAndResults);

            // --- VS Code Message Handling ---
            window.addEventListener("message", event => {
                const message = event.data;
                switch (message.command) {
                    case 'centerOn':
                        // Re-query svgElement in case it was updated dynamically
                        if (!svgElement) initializeSvgContent();
                        const elementToCenter = svgElement ? svgElement.querySelector(`#${message.node}`) : null;
                        if (elementToCenter) centerOnElement(elementToCenter);
                        else console.warn(`Element with ID ${message.node} not found for centering.`);
                        break;
                    case 'updateSvgContent':
                        if (message.content) {
                            svgContainer.innerHTML = message.content;
                            initializeSvgContent(); // Re-initialize SVG element and transform
                            SEARCH_MODULE.clearSearchAndResults(); // Clear search on new SVG content
                            debugLog('SVG content updated.');
                    }
                    break;
                case 'resetView': // Added command to reset pan and zoom
                    P_Z_STATE.scale = 1;
                    P_Z_STATE.panOffset = { x: 0, y: 0 };
                    updateSvgTransform();
                    debugLog('View reset.');
                    break;
            }
        });
    </script>
</body>

</html>
