#!/usr/bin/env python3
"""Generate test body using split-file and a custom script.
Currently, only assembly files are supported by placing generation instructions
surrounded by .ifdef GEN/.endif directives.

    .ifdef GEN
    #--- a.cc
    int va;
    #--- gen
    clang --target=aarch64-linux -S -g a.cc -o -
    .endif
    # content generated by the script 'gen'

The script will prepare extra files with `split-file`, invoke `gen`, and then
rewrite the part after `.endif` with its stdout.

Example:
PATH=/path/to/clang_build/bin:$PATH llvm/utils/update_test_body.py path/to/test.s
"""
import contextlib, os, subprocess, sys, tempfile


@contextlib.contextmanager
def cd(dir):
    cwd = os.getcwd()
    os.chdir(dir)
    try:
        yield
    finally:
        os.chdir(cwd)


def process(path):
    split_file_input = []
    prolog = []
    is_split_file_input = False
    is_prolog = True
    with open(path) as f:
        for line in f.readlines():
            line = line.rstrip()
            if is_prolog:
                prolog.append(line)
            if line.startswith(".endif"):
                is_split_file_input = is_prolog = False
            if is_split_file_input:
                split_file_input.append(line)
            if line.startswith(".ifdef GEN"):
                is_split_file_input = True

    if not split_file_input:
        print("no .ifdef GEN", file=sys.stderr)
        return
    if is_split_file_input:
        print("no .endif", file=sys.stderr)
        return
    with tempfile.TemporaryDirectory() as dir:
        sub = subprocess.run(
            ["split-file", "-", dir],
            input="\n".join(split_file_input).encode(),
            capture_output=True,
        )
        if sub.returncode != 0:
            sys.stderr.write(f"split-file failed\n{sub.stderr.decode()}")
            return
        with cd(dir):
            if not os.path.exists("gen"):
                print("'gen' does not exist", file=sys.stderr)
                return

            # Don't encode the directory information to the Clang output.
            # Remove unneeded details (.ident) as well.
            env = dict(
                os.environ, CCC_OVERRIDE_OPTIONS="+-fno-ident", PWD="/proc/self/cwd"
            )
            sub = subprocess.run(["sh", "gen"], capture_output=True, env=env)
            if sub.returncode != 0:
                sys.stderr.write(f"'gen' failed\n{sub.stderr.decode()}")
                return
            if not sub.stdout:
                print("stdout is empty; forgot -o - ?", file=sys.stderr)
                return
            content = sub.stdout.decode()

    with open(path, "w") as f:
        # Print lines up to '.endif'.
        print("\n".join(prolog), file=f)
        # Then print the stdout of 'gen'.
        f.write(content)


for path in sys.argv[1:]:
    process(path)
