# Generate a canonical index at %/t. A second client at %/t2 loads the shards,
# mapping its local paths to the canonical paths. The on-disk shards always
# contain canonical paths.

# RUN: rm -rf %/t
# RUN: cp -r %/S/Inputs/background-index %/t
# RUN: sed -e "s|DIRECTORY|%/t|" %/t/definition.jsonrpc.tmpl > %/t/definition.jsonrpc.1
# RUN: sed -e "s|DIRECTORY|%/t|" %/t/compile_commands.json.tmpl > %/t/compile_commands.json
# On Windows, we need the URI in didOpen to look like "uri":"file:///C:/..."
# RUN: sed -E -e 's|"file://([A-Z]):/|"file:///\1:/|g' %/t/definition.jsonrpc.1 > %/t/definition.jsonrpc

# Generate the canonical background index with no path mapping
# RUN: clangd -background-index -lit-test < %/t/definition.jsonrpc | FileCheck %/t/definition.jsonrpc

###############################################################################
# 1. Validate shard contents contain canonical paths
###############################################################################

# RUN: cp %/t/.cache/clangd/index/foo.cpp.*.idx %/t/foo.cpp.idx
# RUN: dexp %/t/foo.cpp.idx -c "export %/t/foo.yaml -format=yaml"
# RUN: FileCheck --check-prefix=SHARD-CONTENT %s -DDIR=%/t < %/t/foo.yaml

# SHARD-CONTENT: --- !Symbol
# SHARD-CONTENT: Name:{{.*}}foo
# SHARD-CONTENT: CanonicalDeclaration:
# SHARD-CONTENT:   FileURI:{{.*}}[[DIR]]/sub_dir/foo.h
# SHARD-CONTENT: Definition:
# SHARD-CONTENT:   FileURI:{{.*}}[[DIR]]/foo.cpp

# SHARD-CONTENT: IncludeHeaders:
# SHARD-CONTENT:   - Header:{{.*}}[[DIR]]/sub_dir/foo.h

# SHARD-CONTENT: --- !Refs
# SHARD-CONTENT: References:
# SHARD-CONTENT:   FileURI:{{.*}}[[DIR]]/foo.cpp

# SHARD-CONTENT: --- !Source
# SHARD-CONTENT: URI:{{.*}}[[DIR]]/

###############################################################################
# 2. Validate the second client loads and remaps the shards
###############################################################################

# Set up the second client's workspace with the same source content.
# RUN: rm -rf %/t2
# RUN: mkdir -p %/t2
# RUN: cp -r %/S/Inputs/background-index/* %/t2/

# Copy the canonical index data to the second client's cache directory.
# RUN: mkdir -p %/t2/.cache/clangd/index
# RUN: cp %/t/.cache/clangd/index/*.idx %/t2/.cache/clangd/index/
# RUN: mkdir -p %/t2/sub_dir/.cache/clangd/index
# RUN: cp %/t/sub_dir/.cache/clangd/index/*.idx %/t2/sub_dir/.cache/clangd/index/

# Set up the second client's compile_commands.json and request file.
# RUN: sed -e "s|DIRECTORY|%/t2|" %/S/Inputs/background-index/compile_commands.json.tmpl > %/t2/compile_commands.json
# RUN: sed -e "s|DIRECTORY|%/t2|" %/S/Inputs/background-index/definition.jsonrpc.tmpl > %/t2/definition.jsonrpc.1
# RUN: sed -E -e 's|"file://([A-Z]):/|"file:///\1:/|g' %/t2/definition.jsonrpc.1 > %/t2/definition.jsonrpc

# The mapping %/t2=%/t tells clangd that the local path %/t2 corresponds to
# the canonical path %/t stored in the shards. clangd should load the shards
# and translate canonical paths to local paths in memory. Go-to-definition
# should work and return the local path.
# RUN: clangd -background-index --background-index-path-mappings=%/t2=%/t -lit-test < %/t2/definition.jsonrpc > %/t2/clangd-output.json
# RUN: FileCheck %/t2/definition.jsonrpc < %/t2/clangd-output.json
# RUN: FileCheck --check-prefix=LOCAL-RESULT %s -DDIR=%/t2 < %/t2/clangd-output.json
# Handle the extra slash needed on Windows
# LOCAL-RESULT: "uri": "file://{{/?}}[[DIR]]/foo.cpp"

# Verify the shard filenames are unchanged, proving that the canonical path
# mapping was used for hashing rather than re-indexing with local paths.
# RUN: ls %/t/.cache/clangd/index/ | sort > %/t/shards-canonical.txt
# RUN: ls %/t2/.cache/clangd/index/ | sort > %/t2/shards-local.txt
# RUN: diff %/t/shards-canonical.txt %/t2/shards-local.txt
