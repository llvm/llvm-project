.. title:: clang-tidy - bugprone-easily-swappable-parameters

bugprone-easily-swappable-parameters
====================================

Finds function definitions where parameters of convertible types follow each
other directly, making call sites prone to calling the function with
swapped (or badly ordered) arguments.

.. code-block:: c++

    void drawPoint(int X, int Y) { /* ... */ }
    FILE *open(const char *Dir, const char *Name, Flags Mode) { /* ... */ }

A potential call like ``drawPoint(-2, 5)`` or ``openPath("a.txt", "tmp", Read)``
is perfectly legal from the language's perspective, but might not be what the
developer of the function intended.

More elaborate and type-safe constructs, such as opaque typedefs or strong
types should be used instead, to prevent a mistaken order of arguments.

.. code-block:: c++

    struct Coord2D { int X; int Y; };
    void drawPoint(const Coord2D Pos) { /* ... */ }

    FILE *open(const Path &Dir, const Filename &Name, Flags Mode) { /* ... */ }

Due to the potentially elaborate refactoring and API-breaking that is necessary
to strengthen the type safety of a project, no automatic fix-its are offered.

Options
-------

Filtering options
^^^^^^^^^^^^^^^^^

Filtering options can be used to lessen the size of the diagnostics emitted by
the checker, whether the aim is to ignore certain constructs or dampen the
noisiness.

.. option:: MinimumLength

    The minimum length required from an adjacent parameter sequence to be
    diagnosed.
    Defaults to `2`.
    Might be any positive integer greater or equal to `2`.
    If `0` or `1` is given, the default value `2` will be used instead.

    For example, if `3` is specified, the examples above will not be matched.

.. option:: IgnoredParameterNames

    The list of parameter **names** that should never be considered part of a
    swappable adjacent parameter sequence.
    The value is a `;`-separated list of names.
    To ignore unnamed parameters, add `""` to the list verbatim (not the
    empty string, but the two quotes, potentially escaped!).
    **This options is case-sensitive!**

    By default, the following parameter names, and their Uppercase-initial
    variants are ignored:
    `""` (unnamed parameters), `iterator`, `begin`, `end`, `first`, `last`,
    `lhs`, `rhs`.

.. option:: IgnoredParameterTypeSuffixes

    The list of parameter **type name suffixes** that should never be
    considered part of a swappable adjacent parameter sequence.
    Parameters which type, as written in the source code, end with an element
    of this option will be ignored.
    The value is a `;`-separated list of names.
    **This option is case-sensitive!**

    By default, the following, and their lowercase-initial variants are ignored:
    `bool`, `It`, `Iterator`, `InputIt`, `ForwardIt`, `BidirIt`, `RandomIt`,
    `random_iterator`, `ReverseIt`, `reverse_iterator`,
    `reverse_const_iterator`, `RandomIt`, `random_iterator`, `ReverseIt`,
    `reverse_iterator`, `reverse_const_iterator`, `Const_Iterator`,
    `ConstIterator`, `const_reverse_iterator`, `ConstReverseIterator`.
    In addition, `_Bool` (but not `_bool`) is also part of the default value.


Limitations
-----------

**This check is designed to check function signatures!**

The check does not investigate functions that are generated by the compiler
in a context that is only determined from a call site.
These cases include variadic functions, functions in C code that do not have
an argument list, and C++ template instantiations.
Most of these cases, which are otherwise swappable from a caller's standpoint,
have no way of getting "fixed" at the definition point.
In the case of C++ templates, only primary template definitions and explicit
specialisations are matched and analysed.

None of the following cases produce a diagnostic:

.. code-block:: c++

    int printf(const char *Format, ...) { /* ... */ }
    int someOldCFunction() { /* ... */ }

    template <typename T, typename U>
    int add(T X, U Y) { return X + Y };

    void TheseAreNotWarnedAbout() {
        printf("%d %d\n", 1, 2);   // Two ints passed, they could be swapped.
        someOldCFunction(1, 2, 3); // Similarly, multiple ints passed.

        add(1, 2); // Instantiates 'add<int, int>', but that's not a user-defined function.
    }

Due to the limitation above, parameters which type are further dependent upon
template instantiations to *prove* that they mix with another parameter's is
not diagnosed.

.. code-block:: c++

    template <typename T>
    struct Vector {
      typedef T element_type;
    };

    // Diagnosed: Explicit instantiation was done by the user, we can prove it
    // is the same type.
    void Explicit(int A, Vector<int>::element_type B) { /* ... */ }

    // Diagnosed: The two parameter types are exactly the same.
    template <typename T>
    void Exact(typename Vector<T>::element_type A,
               typename Vector<T>::element_type B) { /* ... */ }

    // Skipped: The two parameters are both 'T' but we can not prove this
    // without actually instantiating.
    template <typename T>
    void FalseNegative(T A, typename Vector<T>::element_type B) { /* ... */ }
