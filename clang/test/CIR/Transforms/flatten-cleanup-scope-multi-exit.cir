// RUN: cir-opt %s -cir-flatten-cfg -verify-diagnostics -split-input-file -o -

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that we detect multiple exits in a loop with a break that branches
// through a cleanup region.
cir.func @test_multi_exit_with_break() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c", init] {alignment = 4 : i64}
  cir.while {
    %true = cir.const #cir.bool<true> : !cir.bool
    cir.condition(%true)
  } do {
    cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      %cond = cir.call @shouldBreak() : () -> !cir.bool
      cir.brcond %cond ^bb_break, ^bb_normal
    ^bb_break:
      cir.break  // Break through cleanup - exits loop
    ^bb_normal:
      cir.yield  // Normal exit through cleanup
    } cleanup normal {
      cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldBreak() -> !cir.bool

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that we detect multiple exits in a loop with a continue that branches
// through a cleanup region.
cir.func @test_multi_exit_with_continue() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c", init] {alignment = 4 : i64}
  cir.while {
    %true = cir.const #cir.bool<true> : !cir.bool
    cir.condition(%true)
  } do {
    cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      %cond = cir.call @shouldContinue() : () -> !cir.bool
      cir.brcond %cond ^bb_continue, ^bb_normal
    ^bb_continue:
      cir.continue  // Continue through cleanup - exits the region
    ^bb_normal:
      cir.yield  // Normal exit through cleanup
    } cleanup normal {
      cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldContinue() -> !cir.bool

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that we detect multiple exits in a switch statatement nested within a
// loop with a continue statement inside the switch that branches through a
// cleanup region.
cir.func @test_continue_in_switch() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c", init] {alignment = 4 : i64}
  cir.while {
    %true = cir.const #cir.bool<true> : !cir.bool
    cir.condition(%true)
  } do {
    cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      %x = cir.const #cir.int<1> : !s32i
      // expected-error @below {{Cannot lower switch: cleanup with multiple exits}}
      cir.switch (%x : !s32i) {
        cir.case (equal, [#cir.int<1> : !s32i]) {
          cir.break     // Break from switch -- no cleanup exit
        }
        cir.case (equal, [#cir.int<2> : !s32i]) {
          cir.continue  // Continue to outer loop - exits through cleanup!
        }
        cir.yield
      }
      cir.yield  // Normal exit through cleanup
    } cleanup normal {
      cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that we detect return inside a loop inside a switch inside a cleanup
// scope. The return must be found even though it's nested inside the loop.
cir.func @test_return_in_loop_in_switch() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c", init] {alignment = 4 : i64}
  cir.while {
    %true = cir.const #cir.bool<true> : !cir.bool
    cir.condition(%true)
  } do {
    cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      %x = cir.const #cir.int<1> : !s32i
      // expected-error @below {{Cannot lower switch: cleanup with multiple exits}}
      cir.switch (%x : !s32i) {
        cir.case (equal, [#cir.int<1> : !s32i]) {
          // Nested loop inside switch
          // expected-error @below {{Cannot lower loop: cleanup with multiple exits}}
          cir.while {
            %cond = cir.call @shouldContinue() : () -> !cir.bool
            cir.condition(%cond)
          } do {
            %ret = cir.call @shouldReturn() : () -> !cir.bool
            cir.brcond %ret ^bb_return, ^bb_continue
          ^bb_return:
            cir.return  // Return inside loop inside switch - exits through cleanup!
          ^bb_continue:
            cir.yield
          }
          cir.break  // Break from switch - handled by switch
        }
        cir.yield
      }
      cir.yield  // Normal exit through cleanup
    } cleanup normal {
      cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldContinue() -> !cir.bool
cir.func private @shouldReturn() -> !cir.bool

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that a return inside nested cleanup scopes causes both to be detected
// as having multiple exits. The return must go through both cleanup regions.
cir.func @test_return_in_nested_cleanup() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c1", init] {alignment = 4 : i64}
  %1 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c2", init] {alignment = 4 : i64}
  cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
  // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
  cir.cleanup.scope {
    cir.call @ctor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      %cond = cir.call @shouldReturn() : () -> !cir.bool
      cir.brcond %cond ^bb_return, ^bb_normal
    ^bb_return:
      cir.return  // Return exits through BOTH cleanup scopes
    ^bb_normal:
      cir.yield
    } cleanup normal {
      cir.call @dtor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  } cleanup normal {
    cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldReturn() -> !cir.bool

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that a goto inside nested cleanup scopes causes both to be detected
// as having multiple exits. The goto must go through both cleanup regions.
cir.func @test_goto_in_nested_cleanup() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c1", init] {alignment = 4 : i64}
  %1 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c2", init] {alignment = 4 : i64}
  cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
  // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
  cir.cleanup.scope {
    cir.call @ctor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      %cond = cir.call @shouldGoto() : () -> !cir.bool
      cir.brcond %cond ^bb_goto, ^bb_normal
    ^bb_goto:
      cir.goto "target"  // Goto exits through BOTH cleanup scopes
    ^bb_normal:
      cir.yield
    } cleanup normal {
      cir.call @dtor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  } cleanup normal {
    cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    cir.yield
  }
  cir.br ^bb_end
^bb_goto_target:
  cir.label "target"
  cir.br ^bb_end
^bb_end:
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldGoto() -> !cir.bool

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that a break inside nested cleanup scopes (within a loop) causes both
// to be detected as having multiple exits. The break exits through both cleanups.
cir.func @test_break_in_nested_cleanup() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c1", init] {alignment = 4 : i64}
  %1 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c2", init] {alignment = 4 : i64}
  cir.while {
    %true = cir.const #cir.bool<true> : !cir.bool
    cir.condition(%true)
  } do {
    cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      cir.call @ctor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
      // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
      cir.cleanup.scope {
        %cond = cir.call @shouldBreak() : () -> !cir.bool
        cir.brcond %cond ^bb_break, ^bb_normal
      ^bb_break:
        cir.break  // Break exits through BOTH cleanup scopes, then exits loop
      ^bb_normal:
        cir.yield
      } cleanup normal {
        cir.call @dtor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
        cir.yield
      }
      cir.yield
    } cleanup normal {
      cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldBreak() -> !cir.bool

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test that a continue inside nested cleanup scopes (within a loop) causes both
// to be detected as having multiple exits. The continue exits through both cleanups.
cir.func @test_continue_in_nested_cleanup() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c1", init] {alignment = 4 : i64}
  %1 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c2", init] {alignment = 4 : i64}
  cir.while {
    %true = cir.const #cir.bool<true> : !cir.bool
    cir.condition(%true)
  } do {
    cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      cir.call @ctor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
      // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
      cir.cleanup.scope {
        %cond = cir.call @shouldContinue() : () -> !cir.bool
        cir.brcond %cond ^bb_continue, ^bb_normal
      ^bb_continue:
        cir.continue  // Continue exits through BOTH cleanup scopes, then continues loop
      ^bb_normal:
        cir.yield
      } cleanup normal {
        cir.call @dtor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
        cir.yield
      }
      cir.yield
    } cleanup normal {
      cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldContinue() -> !cir.bool

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test a cleanup scope containing a switch which contains a nested cleanup
// scope with a continue. The continue must branch through both cleanup scopes.
cir.func @test_continue_in_nested_cleanup_in_switch() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c1", init] {alignment = 4 : i64}
  %1 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c2", init] {alignment = 4 : i64}
  %2 = cir.alloca !s32i, !cir.ptr<!s32i>, ["x", init] {alignment = 4 : i64}
  cir.while {
    %true = cir.const #cir.bool<true> : !cir.bool
    cir.condition(%true)
  } do {
    cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
    cir.cleanup.scope {
      %x = cir.load %2 : !cir.ptr<!s32i>, !s32i
      // expected-error @below {{Cannot lower switch: cleanup with multiple exits}}
      cir.switch (%x : !s32i) {
        cir.case (equal, [#cir.int<1> : !s32i]) {
          cir.call @ctor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
          cir.cleanup.scope {
            cir.continue  // Branches through both cleanups
          } cleanup normal {
            cir.call @dtor(%1) : (!cir.ptr<!rec_SomeClass>) -> ()
            cir.yield
          }
          cir.break
        }
        cir.yield
      }
      cir.yield
    } cleanup normal {
      cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
      cir.yield
    }
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)

// -----

!s32i = !cir.int<s, 32>
!rec_SomeClass = !cir.record<struct "SomeClass" {!s32i}>

// Test a cleanup scope containing a loop with a conditional return.
// The return must branch through the cleanup scope.
cir.func @test_return_in_loop_in_cleanup() {
  %0 = cir.alloca !rec_SomeClass, !cir.ptr<!rec_SomeClass>, ["c", init] {alignment = 4 : i64}
  cir.call @ctor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
  // expected-error @below {{cleanup scope with multiple exits is not yet implemented}}
  cir.cleanup.scope {
    // expected-error @below {{Cannot lower loop: cleanup with multiple exits}}
    cir.while {
      %true = cir.const #cir.bool<true> : !cir.bool
      cir.condition(%true)
    } do {
      %cond = cir.call @shouldReturn() : () -> !cir.bool
      cir.brcond %cond ^bb_return, ^bb_continue
    ^bb_return:
      cir.return  // Return branches through cleanup
    ^bb_continue:
      cir.yield
    }
    cir.yield
  } cleanup normal {
    cir.call @dtor(%0) : (!cir.ptr<!rec_SomeClass>) -> ()
    cir.yield
  }
  cir.return
}

cir.func private @ctor(!cir.ptr<!rec_SomeClass>)
cir.func private @dtor(!cir.ptr<!rec_SomeClass>)
cir.func private @shouldReturn() -> !cir.bool
