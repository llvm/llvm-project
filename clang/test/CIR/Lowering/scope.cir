// RUN: cir-tool %s -cir-to-llvm -o - | FileCheck %s -check-prefix=MLIR
// RUN: cir-tool %s -cir-to-llvm -o - | mlir-translate -mlir-to-llvmir | FileCheck %s -check-prefix=LLVM
!u32i = !cir.int<u, 32>

module {
  cir.func @foo() {
    cir.scope {
      %0 = cir.alloca !u32i, cir.ptr <!u32i>, ["a", init] {alignment = 4 : i64}
      %1 = cir.const(#cir.int<4> : !u32i) : !u32i
      cir.store %1, %0 : !u32i, cir.ptr <!u32i>
    }
    cir.return
  }

//      MLIR: llvm.func @foo() {
// MLIR-NEXT:   llvm.br ^bb1
// MLIR-NEXT: ^bb1:
//  MLIR-DAG:   [[v1:%[0-9]]] = llvm.mlir.constant(4 : i32) : i32
//  MLIR-DAG:   [[v2:%[0-9]]] = llvm.mlir.constant(1 : index) : i64
//  MLIR-DAG:   [[v3:%[0-9]]] = llvm.alloca [[v2]] x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr
// MLIR-NEXT:   llvm.store [[v1]], [[v3]] : i32, !llvm.ptr
// MLIR-NEXT:   llvm.br ^bb2
// MLIR-NEXT: ^bb2:
// MLIR-NEXT:   llvm.return


//      LLVM: define void @foo() {
//  LLVM-NEXT:   br label %1
// LLVM-EMPTY:
//  LLVM-NEXT: 1:
//  LLVM-NEXT:   %2 = alloca i32, i64 1, align 4
//  LLVM-NEXT:   store i32 4, ptr %2, align 4
//  LLVM-NEXT:   br label %3
// LLVM-EMPTY:
//  LLVM-NEXT: 3:
//  LLVM-NEXT:   ret void
//  LLVM-NEXT: }


  // Should drop empty scopes.
  cir.func @empty_scope() {
    cir.scope {
    }
    cir.return
  }
  //      MLIR: llvm.func @empty_scope() {
  // MLIR-NEXT:   llvm.return
  // MLIR-NEXT: }

}
