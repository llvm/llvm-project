// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 3
// RUN: %clang_cc1 -triple x86_64-pc-linux-gnu -emit-llvm -o - %s | \
// RUN:   FileCheck %s --check-prefix=CHECK-X86
// RUN: %clang_cc1 -triple ppc64le-linux-gnu -emit-llvm -o - %s | FileCheck %s \
// RUN:   --check-prefix=CHECK-PPC
// RUN: %clang_cc1 -triple riscv32-linux-gnu -emit-llvm -o - %s | FileCheck %s \
// RUN:   --check-prefix=CHECK-RV32
// RUN: %clang_cc1 -triple riscv64-linux-gnu -emit-llvm -o - %s | FileCheck %s \
// RUN:   --check-prefix=CHECK-RV64
#ifdef __x86_64__

// Test that we have the structure definition, the gep offsets, the name of the
// global, the bit grab, and the icmp correct.
extern void a(const char *);


// CHECK-X86-LABEL: define dso_local i32 @main(
// CHECK-X86-SAME: ) #[[ATTR0:[0-9]+]] {
// CHECK-X86-NEXT:  entry:
// CHECK-X86-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-X86-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-X86-NEXT:    call void @__cpu_indicator_init()
// CHECK-X86-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ({ i32, i32, i32, [1 x i32] }, ptr @__cpu_model, i32 0, i32 3, i32 0), align 4
// CHECK-X86-NEXT:    [[TMP1:%.*]] = and i32 [[TMP0]], 256
// CHECK-X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP1]], 256
// CHECK-X86-NEXT:    [[TMP3:%.*]] = and i1 true, [[TMP2]]
// CHECK-X86-NEXT:    br i1 [[TMP3]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK-X86:       if.then:
// CHECK-X86-NEXT:    call void @a(ptr noundef @.str)
// CHECK-X86-NEXT:    br label [[IF_END]]
// CHECK-X86:       if.end:
// CHECK-X86-NEXT:    [[TMP4:%.*]] = load i32, ptr @__cpu_features2, align 4
// CHECK-X86-NEXT:    [[TMP5:%.*]] = and i32 [[TMP4]], 1
// CHECK-X86-NEXT:    [[TMP6:%.*]] = icmp eq i32 [[TMP5]], 1
// CHECK-X86-NEXT:    [[TMP7:%.*]] = and i1 true, [[TMP6]]
// CHECK-X86-NEXT:    br i1 [[TMP7]], label [[IF_THEN1:%.*]], label [[IF_END2:%.*]]
// CHECK-X86:       if.then1:
// CHECK-X86-NEXT:    call void @a(ptr noundef @.str.1)
// CHECK-X86-NEXT:    br label [[IF_END2]]
// CHECK-X86:       if.end2:
// CHECK-X86-NEXT:    ret i32 0
//
int main(void) {
  __builtin_cpu_init();

  // CHECK: call void @__cpu_indicator_init

  if (__builtin_cpu_supports("sse4.2"))
    a("sse4.2");


  if (__builtin_cpu_supports("gfni"))
    a("gfni");


  return 0;
}


// CHECK-X86-LABEL: define dso_local i32 @baseline(
// CHECK-X86-SAME: ) #[[ATTR0]] {
// CHECK-X86-NEXT:  entry:
// CHECK-X86-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([3 x i32], ptr @__cpu_features2, i32 0, i32 1), align 4
// CHECK-X86-NEXT:    [[TMP1:%.*]] = and i32 [[TMP0]], -2147483648
// CHECK-X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP1]], -2147483648
// CHECK-X86-NEXT:    [[TMP3:%.*]] = and i1 true, [[TMP2]]
// CHECK-X86-NEXT:    [[CONV:%.*]] = zext i1 [[TMP3]] to i32
// CHECK-X86-NEXT:    ret i32 [[CONV]]
//
int baseline() { return __builtin_cpu_supports("x86-64"); }

// CHECK-X86-LABEL: define dso_local i32 @v2(
// CHECK-X86-SAME: ) #[[ATTR0]] {
// CHECK-X86-NEXT:  entry:
// CHECK-X86-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([3 x i32], ptr @__cpu_features2, i32 0, i32 2), align 4
// CHECK-X86-NEXT:    [[TMP1:%.*]] = and i32 [[TMP0]], 1
// CHECK-X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP1]], 1
// CHECK-X86-NEXT:    [[TMP3:%.*]] = and i1 true, [[TMP2]]
// CHECK-X86-NEXT:    [[CONV:%.*]] = zext i1 [[TMP3]] to i32
// CHECK-X86-NEXT:    ret i32 [[CONV]]
//
int v2() { return __builtin_cpu_supports("x86-64-v2"); }

// CHECK-X86-LABEL: define dso_local i32 @v3(
// CHECK-X86-SAME: ) #[[ATTR0]] {
// CHECK-X86-NEXT:  entry:
// CHECK-X86-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([3 x i32], ptr @__cpu_features2, i32 0, i32 2), align 4
// CHECK-X86-NEXT:    [[TMP1:%.*]] = and i32 [[TMP0]], 2
// CHECK-X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP1]], 2
// CHECK-X86-NEXT:    [[TMP3:%.*]] = and i1 true, [[TMP2]]
// CHECK-X86-NEXT:    [[CONV:%.*]] = zext i1 [[TMP3]] to i32
// CHECK-X86-NEXT:    ret i32 [[CONV]]
//
int v3() { return __builtin_cpu_supports("x86-64-v3"); }

// CHECK-X86-LABEL: define dso_local i32 @v4(
// CHECK-X86-SAME: ) #[[ATTR0]] {
// CHECK-X86-NEXT:  entry:
// CHECK-X86-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([3 x i32], ptr @__cpu_features2, i32 0, i32 2), align 4
// CHECK-X86-NEXT:    [[TMP1:%.*]] = and i32 [[TMP0]], 4
// CHECK-X86-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP1]], 4
// CHECK-X86-NEXT:    [[TMP3:%.*]] = and i1 true, [[TMP2]]
// CHECK-X86-NEXT:    [[CONV:%.*]] = zext i1 [[TMP3]] to i32
// CHECK-X86-NEXT:    ret i32 [[CONV]]
//
int v4() { return __builtin_cpu_supports("x86-64-v4"); }
#endif

#ifdef __PPC__
// CHECK-PPC-LABEL: define dso_local signext i32 @test_ppc(
// CHECK-PPC-SAME: i32 noundef signext [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-PPC-NEXT:  entry:
// CHECK-PPC-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-PPC-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-PPC-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[CPU_SUPPORTS:%.*]] = call i32 @llvm.ppc.fixed.addr.ld(i32 2)
// CHECK-PPC-NEXT:    [[TMP0:%.*]] = and i32 [[CPU_SUPPORTS]], 8388608
// CHECK-PPC-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[TMP0]], 0
// CHECK-PPC-NEXT:    br i1 [[TMP1]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
// CHECK-PPC:       if.then:
// CHECK-PPC-NEXT:    [[TMP2:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    store i32 [[TMP2]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN:%.*]]
// CHECK-PPC:       if.else:
// CHECK-PPC-NEXT:    [[CPU_SUPPORTS1:%.*]] = call i32 @llvm.ppc.fixed.addr.ld(i32 1)
// CHECK-PPC-NEXT:    [[TMP3:%.*]] = and i32 [[CPU_SUPPORTS1]], 67108864
// CHECK-PPC-NEXT:    [[TMP4:%.*]] = icmp ne i32 [[TMP3]], 0
// CHECK-PPC-NEXT:    br i1 [[TMP4]], label [[IF_THEN2:%.*]], label [[IF_ELSE3:%.*]]
// CHECK-PPC:       if.then2:
// CHECK-PPC-NEXT:    [[TMP5:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP5]], 5
// CHECK-PPC-NEXT:    store i32 [[SUB]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN]]
// CHECK-PPC:       if.else3:
// CHECK-PPC-NEXT:    [[CPU_IS:%.*]] = call i32 @llvm.ppc.fixed.addr.ld(i32 3)
// CHECK-PPC-NEXT:    [[TMP6:%.*]] = icmp eq i32 [[CPU_IS]], 39
// CHECK-PPC-NEXT:    br i1 [[TMP6]], label [[IF_THEN4:%.*]], label [[IF_ELSE5:%.*]]
// CHECK-PPC:       if.then4:
// CHECK-PPC-NEXT:    [[TMP7:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[TMP8:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP7]], [[TMP8]]
// CHECK-PPC-NEXT:    store i32 [[ADD]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN]]
// CHECK-PPC:       if.else5:
// CHECK-PPC-NEXT:    [[CPU_IS6:%.*]] = call i32 @llvm.ppc.fixed.addr.ld(i32 3)
// CHECK-PPC-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[CPU_IS6]], 45
// CHECK-PPC-NEXT:    br i1 [[TMP9]], label [[IF_THEN7:%.*]], label [[IF_ELSE9:%.*]]
// CHECK-PPC:       if.then7:
// CHECK-PPC-NEXT:    [[TMP10:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[ADD8:%.*]] = add nsw i32 [[TMP10]], 3
// CHECK-PPC-NEXT:    store i32 [[ADD8]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN]]
// CHECK-PPC:       if.else9:
// CHECK-PPC-NEXT:    [[CPU_IS10:%.*]] = call i32 @llvm.ppc.fixed.addr.ld(i32 3)
// CHECK-PPC-NEXT:    [[TMP11:%.*]] = icmp eq i32 [[CPU_IS10]], 46
// CHECK-PPC-NEXT:    br i1 [[TMP11]], label [[IF_THEN11:%.*]], label [[IF_ELSE13:%.*]]
// CHECK-PPC:       if.then11:
// CHECK-PPC-NEXT:    [[TMP12:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[SUB12:%.*]] = sub nsw i32 [[TMP12]], 3
// CHECK-PPC-NEXT:    store i32 [[SUB12]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN]]
// CHECK-PPC:       if.else13:
// CHECK-PPC-NEXT:    [[CPU_IS14:%.*]] = call i32 @llvm.ppc.fixed.addr.ld(i32 3)
// CHECK-PPC-NEXT:    [[TMP13:%.*]] = icmp eq i32 [[CPU_IS14]], 47
// CHECK-PPC-NEXT:    br i1 [[TMP13]], label [[IF_THEN15:%.*]], label [[IF_ELSE17:%.*]]
// CHECK-PPC:       if.then15:
// CHECK-PPC-NEXT:    [[TMP14:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[ADD16:%.*]] = add nsw i32 [[TMP14]], 7
// CHECK-PPC-NEXT:    store i32 [[ADD16]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN]]
// CHECK-PPC:       if.else17:
// CHECK-PPC-NEXT:    [[CPU_IS18:%.*]] = call i32 @llvm.ppc.fixed.addr.ld(i32 3)
// CHECK-PPC-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[CPU_IS18]], 48
// CHECK-PPC-NEXT:    br i1 [[TMP15]], label [[IF_THEN19:%.*]], label [[IF_END:%.*]]
// CHECK-PPC:       if.then19:
// CHECK-PPC-NEXT:    [[TMP16:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[SUB20:%.*]] = sub nsw i32 [[TMP16]], 7
// CHECK-PPC-NEXT:    store i32 [[SUB20]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN]]
// CHECK-PPC:       if.end:
// CHECK-PPC-NEXT:    br label [[IF_END21:%.*]]
// CHECK-PPC:       if.end21:
// CHECK-PPC-NEXT:    br label [[IF_END22:%.*]]
// CHECK-PPC:       if.end22:
// CHECK-PPC-NEXT:    br label [[IF_END23:%.*]]
// CHECK-PPC:       if.end23:
// CHECK-PPC-NEXT:    br label [[IF_END24:%.*]]
// CHECK-PPC:       if.end24:
// CHECK-PPC-NEXT:    br label [[IF_END25:%.*]]
// CHECK-PPC:       if.end25:
// CHECK-PPC-NEXT:    br label [[IF_END26:%.*]]
// CHECK-PPC:       if.end26:
// CHECK-PPC-NEXT:    [[TMP17:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-PPC-NEXT:    [[ADD27:%.*]] = add nsw i32 [[TMP17]], 5
// CHECK-PPC-NEXT:    store i32 [[ADD27]], ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    br label [[RETURN]]
// CHECK-PPC:       return:
// CHECK-PPC-NEXT:    [[TMP18:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-PPC-NEXT:    ret i32 [[TMP18]]
//
int test_ppc(int a) {
  if (__builtin_cpu_supports("arch_3_00")) // HWCAP2
    return a;
  else if (__builtin_cpu_supports("mmu"))  // HWCAP
    return a - 5;
  else if (__builtin_cpu_is("power7"))     // CPUID
    return a + a;
  else if (__builtin_cpu_is("power8"))
    return a + 3;
  else if (__builtin_cpu_is("power9"))
    return a - 3;
  else if (__builtin_cpu_is("power10"))
    return a + 7;
  else if (__builtin_cpu_is("power11"))
    return a - 7;
  return a + 5;
}
#endif

#ifdef __riscv
// CHECK-RV32-LABEL: define dso_local i32 @test_riscv(
// CHECK-RV32-SAME: i32 noundef [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-RV32-NEXT:  entry:
// CHECK-RV32-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-RV32-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-RV32-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-RV32-NEXT:    call void @__init_riscv_feature_bits()
// CHECK-RV32-NEXT:    [[TMP0:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-RV32-NEXT:    [[TMP1:%.*]] = and i64 [[TMP0]], 1
// CHECK-RV32-NEXT:    [[TMP2:%.*]] = icmp eq i64 [[TMP1]], 1
// CHECK-RV32-NEXT:    br i1 [[TMP2]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
// CHECK-RV32:       if.then:
// CHECK-RV32-NEXT:    store i32 3, ptr [[RETVAL]], align 4
// CHECK-RV32-NEXT:    br label [[RETURN:%.*]]
// CHECK-RV32:       if.else:
// CHECK-RV32-NEXT:    [[TMP3:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-RV32-NEXT:    [[TMP4:%.*]] = and i64 [[TMP3]], 4
// CHECK-RV32-NEXT:    [[TMP5:%.*]] = icmp eq i64 [[TMP4]], 4
// CHECK-RV32-NEXT:    br i1 [[TMP5]], label [[IF_THEN1:%.*]], label [[IF_ELSE2:%.*]]
// CHECK-RV32:       if.then1:
// CHECK-RV32-NEXT:    store i32 7, ptr [[RETVAL]], align 4
// CHECK-RV32-NEXT:    br label [[RETURN]]
// CHECK-RV32:       if.else2:
// CHECK-RV32-NEXT:    [[TMP6:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-RV32-NEXT:    [[TMP7:%.*]] = and i64 [[TMP6]], 2097152
// CHECK-RV32-NEXT:    [[TMP8:%.*]] = icmp eq i64 [[TMP7]], 2097152
// CHECK-RV32-NEXT:    br i1 [[TMP8]], label [[IF_THEN3:%.*]], label [[IF_END:%.*]]
// CHECK-RV32:       if.then3:
// CHECK-RV32-NEXT:    store i32 11, ptr [[RETVAL]], align 4
// CHECK-RV32-NEXT:    br label [[RETURN]]
// CHECK-RV32:       if.end:
// CHECK-RV32-NEXT:    br label [[IF_END4:%.*]]
// CHECK-RV32:       if.end4:
// CHECK-RV32-NEXT:    br label [[IF_END5:%.*]]
// CHECK-RV32:       if.end5:
// CHECK-RV32-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-RV32-NEXT:    br label [[RETURN]]
// CHECK-RV32:       return:
// CHECK-RV32-NEXT:    [[TMP9:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-RV32-NEXT:    ret i32 [[TMP9]]
//
// CHECK-RV64-LABEL: define dso_local signext i32 @test_riscv(
// CHECK-RV64-SAME: i32 noundef signext [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-RV64-NEXT:  entry:
// CHECK-RV64-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-RV64-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-RV64-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-RV64-NEXT:    call void @__init_riscv_feature_bits()
// CHECK-RV64-NEXT:    [[TMP0:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-RV64-NEXT:    [[TMP1:%.*]] = and i64 [[TMP0]], 1
// CHECK-RV64-NEXT:    [[TMP2:%.*]] = icmp eq i64 [[TMP1]], 1
// CHECK-RV64-NEXT:    br i1 [[TMP2]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]
// CHECK-RV64:       if.then:
// CHECK-RV64-NEXT:    store i32 3, ptr [[RETVAL]], align 4
// CHECK-RV64-NEXT:    br label [[RETURN:%.*]]
// CHECK-RV64:       if.else:
// CHECK-RV64-NEXT:    [[TMP3:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-RV64-NEXT:    [[TMP4:%.*]] = and i64 [[TMP3]], 4
// CHECK-RV64-NEXT:    [[TMP5:%.*]] = icmp eq i64 [[TMP4]], 4
// CHECK-RV64-NEXT:    br i1 [[TMP5]], label [[IF_THEN1:%.*]], label [[IF_ELSE2:%.*]]
// CHECK-RV64:       if.then1:
// CHECK-RV64-NEXT:    store i32 7, ptr [[RETVAL]], align 4
// CHECK-RV64-NEXT:    br label [[RETURN]]
// CHECK-RV64:       if.else2:
// CHECK-RV64-NEXT:    [[TMP6:%.*]] = load i64, ptr getelementptr inbounds ({ i32, [1 x i64] }, ptr @__riscv_feature_bits, i32 0, i32 1, i32 0), align 8
// CHECK-RV64-NEXT:    [[TMP7:%.*]] = and i64 [[TMP6]], 2097152
// CHECK-RV64-NEXT:    [[TMP8:%.*]] = icmp eq i64 [[TMP7]], 2097152
// CHECK-RV64-NEXT:    br i1 [[TMP8]], label [[IF_THEN3:%.*]], label [[IF_END:%.*]]
// CHECK-RV64:       if.then3:
// CHECK-RV64-NEXT:    store i32 11, ptr [[RETVAL]], align 4
// CHECK-RV64-NEXT:    br label [[RETURN]]
// CHECK-RV64:       if.end:
// CHECK-RV64-NEXT:    br label [[IF_END4:%.*]]
// CHECK-RV64:       if.end4:
// CHECK-RV64-NEXT:    br label [[IF_END5:%.*]]
// CHECK-RV64:       if.end5:
// CHECK-RV64-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-RV64-NEXT:    br label [[RETURN]]
// CHECK-RV64:       return:
// CHECK-RV64-NEXT:    [[TMP9:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-RV64-NEXT:    ret i32 [[TMP9]]
//
int test_riscv(int a) {
  __builtin_cpu_init();
  if (__builtin_cpu_supports("a"))
    return 3;
  else if (__builtin_cpu_supports("c"))
    return 7;
  else if (__builtin_cpu_supports("v"))
    return 11;
  return 0;
}
#endif
