// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2
// RUN: %clang_cc1 -emit-llvm %s -o - -triple x86_64-linux-gnu | FileCheck %s
// RUN: %clang_cc1 -fsanitize=alignment -fno-sanitize-recover=alignment -emit-llvm %s -o - -triple x86_64-linux-gnu | FileCheck %s -implicit-check-not="call void @__ubsan_handle_alignment_assumption" --check-prefixes=CHECK,CHECK-SANITIZE-NORECOVER
// RUN: %clang_cc1 -fsanitize=alignment -fsanitize-recover=alignment -emit-llvm %s -o - -triple x86_64-linux-gnu | FileCheck %s -implicit-check-not="call void @__ubsan_handle_alignment_assumption" --check-prefixes=CHECK,CHECK-SANITIZE-RECOVER
// RUN: %clang_cc1 -fsanitize=alignment -fsanitize-trap=alignment -emit-llvm %s -o - -triple x86_64-linux-gnu | FileCheck %s -implicit-check-not="call void @__ubsan_handle_alignment_assumption" --check-prefixes=CHECK,CHECK-SANITIZE-TRAP


char **__attribute__((alloc_align(2)))
// CHECK-LABEL: define dso_local noundef ptr @_Z11passthroughPPcm
// CHECK-SAME: (ptr noundef [[X:%.*]], i64 noundef [[ALIGNMENT:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ALIGNMENT_ADDR:%.*]] = alloca i64, align 8
// CHECK-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-NEXT:    store i64 [[ALIGNMENT]], ptr [[ALIGNMENT_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-NEXT:    ret ptr [[TMP0]]
//
passthrough(char **x, unsigned long alignment) {
  return x;
}

// CHECK-SANITIZE-NORECOVER-LABEL: define dso_local noundef ptr @_Z6callerPPcm
// CHECK-SANITIZE-NORECOVER-SAME: (ptr noundef [[X:%.*]], i64 noundef [[ALIGNMENT:%.*]]) #[[ATTR0]] {
// CHECK-SANITIZE-NORECOVER-NEXT:  entry:
// CHECK-SANITIZE-NORECOVER-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-SANITIZE-NORECOVER-NEXT:    [[ALIGNMENT_ADDR:%.*]] = alloca i64, align 8
// CHECK-SANITIZE-NORECOVER-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-SANITIZE-NORECOVER-NEXT:    store i64 [[ALIGNMENT]], ptr [[ALIGNMENT_ADDR]], align 8
// CHECK-SANITIZE-NORECOVER-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-SANITIZE-NORECOVER-NEXT:    [[TMP1:%.*]] = load i64, ptr [[ALIGNMENT_ADDR]], align 8
// CHECK-SANITIZE-NORECOVER-NEXT:    [[CALL:%.*]] = call noundef ptr @_Z11passthroughPPcm(ptr noundef [[TMP0]], i64 noundef [[TMP1]])
// CHECK-SANITIZE-NORECOVER-NEXT:    [[PTRINT:%.*]] = ptrtoint ptr [[CALL]] to i64
// CHECK-SANITIZE-NORECOVER-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP1]], 1
// CHECK-SANITIZE-NORECOVER-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[PTRINT]], [[TMP2]]
// CHECK-SANITIZE-NORECOVER-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-SANITIZE-NORECOVER-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[CALL]] to i64, !nosanitize !2
// CHECK-SANITIZE-NORECOVER-NEXT:    br i1 [[MASKCOND]], label [[CONT:%.*]], label [[HANDLER_ALIGNMENT_ASSUMPTION:%.*]], !prof [[PROF3:![0-9]+]], !nosanitize !2
// CHECK-SANITIZE-NORECOVER:       handler.alignment_assumption:
// CHECK-SANITIZE-NORECOVER-NEXT:    call void @__ubsan_handle_alignment_assumption_abort(ptr @[[GLOB1:[0-9]+]], i64 [[TMP3]], i64 [[TMP1]], i64 0) #[[ATTR3:[0-9]+]], !nosanitize !2
// CHECK-SANITIZE-NORECOVER-NEXT:    unreachable, !nosanitize !2
// CHECK-SANITIZE-NORECOVER:       cont:
// CHECK-SANITIZE-NORECOVER-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[CALL]], i64 [[TMP1]]) ]
// CHECK-SANITIZE-NORECOVER-NEXT:    ret ptr [[CALL]]
//
// CHECK-SANITIZE-RECOVER-LABEL: define dso_local noundef ptr @_Z6callerPPcm
// CHECK-SANITIZE-RECOVER-SAME: (ptr noundef [[X:%.*]], i64 noundef [[ALIGNMENT:%.*]]) #[[ATTR0]] {
// CHECK-SANITIZE-RECOVER-NEXT:  entry:
// CHECK-SANITIZE-RECOVER-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-SANITIZE-RECOVER-NEXT:    [[ALIGNMENT_ADDR:%.*]] = alloca i64, align 8
// CHECK-SANITIZE-RECOVER-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-SANITIZE-RECOVER-NEXT:    store i64 [[ALIGNMENT]], ptr [[ALIGNMENT_ADDR]], align 8
// CHECK-SANITIZE-RECOVER-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-SANITIZE-RECOVER-NEXT:    [[TMP1:%.*]] = load i64, ptr [[ALIGNMENT_ADDR]], align 8
// CHECK-SANITIZE-RECOVER-NEXT:    [[CALL:%.*]] = call noundef ptr @_Z11passthroughPPcm(ptr noundef [[TMP0]], i64 noundef [[TMP1]])
// CHECK-SANITIZE-RECOVER-NEXT:    [[PTRINT:%.*]] = ptrtoint ptr [[CALL]] to i64
// CHECK-SANITIZE-RECOVER-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP1]], 1
// CHECK-SANITIZE-RECOVER-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[PTRINT]], [[TMP2]]
// CHECK-SANITIZE-RECOVER-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-SANITIZE-RECOVER-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[CALL]] to i64, !nosanitize !2
// CHECK-SANITIZE-RECOVER-NEXT:    br i1 [[MASKCOND]], label [[CONT:%.*]], label [[HANDLER_ALIGNMENT_ASSUMPTION:%.*]], !prof [[PROF3:![0-9]+]], !nosanitize !2
// CHECK-SANITIZE-RECOVER:       handler.alignment_assumption:
// CHECK-SANITIZE-RECOVER-NEXT:    call void @__ubsan_handle_alignment_assumption(ptr @[[GLOB1:[0-9]+]], i64 [[TMP3]], i64 [[TMP1]], i64 0) #[[ATTR3:[0-9]+]], !nosanitize !2
// CHECK-SANITIZE-RECOVER-NEXT:    br label [[CONT]], !nosanitize !2
// CHECK-SANITIZE-RECOVER:       cont:
// CHECK-SANITIZE-RECOVER-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[CALL]], i64 [[TMP1]]) ]
// CHECK-SANITIZE-RECOVER-NEXT:    ret ptr [[CALL]]
//
// CHECK-SANITIZE-TRAP-LABEL: define dso_local noundef ptr @_Z6callerPPcm
// CHECK-SANITIZE-TRAP-SAME: (ptr noundef [[X:%.*]], i64 noundef [[ALIGNMENT:%.*]]) #[[ATTR0]] {
// CHECK-SANITIZE-TRAP-NEXT:  entry:
// CHECK-SANITIZE-TRAP-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-SANITIZE-TRAP-NEXT:    [[ALIGNMENT_ADDR:%.*]] = alloca i64, align 8
// CHECK-SANITIZE-TRAP-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-SANITIZE-TRAP-NEXT:    store i64 [[ALIGNMENT]], ptr [[ALIGNMENT_ADDR]], align 8
// CHECK-SANITIZE-TRAP-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-SANITIZE-TRAP-NEXT:    [[TMP1:%.*]] = load i64, ptr [[ALIGNMENT_ADDR]], align 8
// CHECK-SANITIZE-TRAP-NEXT:    [[CALL:%.*]] = call noundef ptr @_Z11passthroughPPcm(ptr noundef [[TMP0]], i64 noundef [[TMP1]])
// CHECK-SANITIZE-TRAP-NEXT:    [[PTRINT:%.*]] = ptrtoint ptr [[CALL]] to i64
// CHECK-SANITIZE-TRAP-NEXT:    [[TMP2:%.*]] = sub i64 [[TMP1]], 1
// CHECK-SANITIZE-TRAP-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[PTRINT]], [[TMP2]]
// CHECK-SANITIZE-TRAP-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-SANITIZE-TRAP-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[CALL]] to i64, !nosanitize !2
// CHECK-SANITIZE-TRAP-NEXT:    br i1 [[MASKCOND]], label [[CONT:%.*]], label [[TRAP:%.*]], !nosanitize !2
// CHECK-SANITIZE-TRAP:       trap:
// CHECK-SANITIZE-TRAP-NEXT:    call void @llvm.ubsantrap(i8 23) #[[ATTR3:[0-9]+]], !nosanitize !2
// CHECK-SANITIZE-TRAP-NEXT:    unreachable, !nosanitize !2
// CHECK-SANITIZE-TRAP:       cont:
// CHECK-SANITIZE-TRAP-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr [[CALL]], i64 [[TMP1]]) ]
// CHECK-SANITIZE-TRAP-NEXT:    ret ptr [[CALL]]
//
char **caller(char **x, unsigned long alignment) {
#line 100
  return passthrough(x, alignment);
}
