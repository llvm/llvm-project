// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// REQUIRES: avr-registered-target
// RUN: %clang_cc1 -triple avr-- -Wno-strict-prototypes -Wno-deprecated-non-prototype -emit-llvm -o - -verify %s | FileCheck %s
// expected-no-diagnostics

// Make sure redeclarations of functions as a different type work when functions
// use non-0 address spaces.

int g();

// CHECK-LABEL: define {{[^@]+}}@bar
// CHECK-SAME: (i16 noundef [[I:%.*]], i16 noundef [[J:%.*]]) addrspace(1) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca i16, align 1
// CHECK-NEXT:    [[J_ADDR:%.*]] = alloca i16, align 1
// CHECK-NEXT:    store i16 [[I]], ptr [[I_ADDR]], align 1
// CHECK-NEXT:    store i16 [[J]], ptr [[J_ADDR]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr [[I_ADDR]], align 1
// CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[J_ADDR]], align 1
// CHECK-NEXT:    [[CALL:%.*]] = call addrspace(1) i16 @g(i16 noundef [[TMP0]], i16 noundef [[TMP1]])
// CHECK-NEXT:    ret i16 [[CALL]]
//
int bar(int i, int j) {
  return g(i, j);
}

// CHECK-LABEL: define {{[^@]+}}@foo
// CHECK-SAME: (i16 noundef [[I:%.*]]) addrspace(1) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca i16, align 1
// CHECK-NEXT:    store i16 [[I]], ptr [[I_ADDR]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr [[I_ADDR]], align 1
// CHECK-NEXT:    [[CALL:%.*]] = call addrspace(1) i16 @g(i16 noundef [[TMP0]])
// CHECK-NEXT:    ret i16 [[CALL]]
//
int foo(int i) {
  return g(i);
}

// CHECK-LABEL: define {{[^@]+}}@g
// CHECK-SAME: (i16 noundef [[X:%.*]], i16 noundef [[Y:%.*]]) addrspace(1) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i16, align 1
// CHECK-NEXT:    [[Y_ADDR:%.*]] = alloca i16, align 1
// CHECK-NEXT:    store i16 [[X]], ptr [[X_ADDR]], align 1
// CHECK-NEXT:    store i16 [[Y]], ptr [[Y_ADDR]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr [[X_ADDR]], align 1
// CHECK-NEXT:    [[TMP1:%.*]] = load i16, ptr [[Y_ADDR]], align 1
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i16 [[TMP0]], [[TMP1]]
// CHECK-NEXT:    ret i16 [[ADD]]
//
int g(int x, int y) {
  return x + y;
}
