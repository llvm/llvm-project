// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// REQUIRES: avr-registered-target
// RUN: %clang_cc1 -triple avr-- -emit-llvm -o - %s | FileCheck %s

// Copy of incomplete-function-type-2.c run with AVR.

// Make sure the address space of the function is respected for incomplete
// functions.

struct test10_B;
typedef struct test10_B test10_F3(double);
void test10_foo(test10_F3 p1);
struct test10_B test10_b(double);
// CHECK-LABEL: define {{[^@]+}}@test10_bar
// CHECK-SAME: () addrspace(1) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call addrspace(1) void @test10_foo(ptr addrspace(1) noundef @test10_b)
// CHECK-NEXT:    ret void
//
void test10_bar(void) {
  test10_foo(test10_b);
}
struct test10_B {};
// CHECK-LABEL: define {{[^@]+}}@test10_foo
// CHECK-SAME: (ptr addrspace(1) noundef [[P1:%.*]]) addrspace(1) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P1_ADDR:%.*]] = alloca ptr addrspace(1), align 1
// CHECK-NEXT:    [[AGG_TMP:%.*]] = alloca [[STRUCT_TEST10_B:%.*]], align 1
// CHECK-NEXT:    store ptr addrspace(1) [[P1]], ptr [[P1_ADDR]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(1), ptr [[P1_ADDR]], align 1
// CHECK-NEXT:    [[CALL:%.*]] = call addrspace(1) [[STRUCT_TEST10_B]] [[TMP0]](float noundef 0.000000e+00)
// CHECK-NEXT:    ret void
//
void test10_foo(test10_F3 p1)
{
  p1(0.0);
}
