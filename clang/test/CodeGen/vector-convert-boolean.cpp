// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 6
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu %s -emit-llvm -o - | FileCheck %s

using v1i = int [[clang::ext_vector_type(1)]];
using v1b = bool [[clang::ext_vector_type(1)]];
using v8i = int [[clang::ext_vector_type(8)]];
using v8b = bool [[clang::ext_vector_type(8)]];
using v16i = short [[clang::ext_vector_type(16)]];
using v16b = bool [[clang::ext_vector_type(16)]];
using v32i = char [[clang::ext_vector_type(32)]];
using v32b = bool [[clang::ext_vector_type(32)]];

// CHECK-LABEL: define dso_local noundef i8 @_Z3fooDv1_i(
// CHECK-SAME: i32 noundef [[V_COERCE:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <1 x i1>, align 1
// CHECK-NEXT:    [[V:%.*]] = alloca <1 x i32>, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <1 x i32>, align 4
// CHECK-NEXT:    store i32 [[V_COERCE]], ptr [[V]], align 4
// CHECK-NEXT:    [[V1:%.*]] = load <1 x i32>, ptr [[V]], align 4
// CHECK-NEXT:    store <1 x i32> [[V1]], ptr [[V_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load <1 x i32>, ptr [[V_ADDR]], align 4
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne <1 x i32> [[TMP0]], zeroinitializer
// CHECK-NEXT:    store <1 x i1> [[TOBOOL]], ptr [[RETVAL]], align 1
// CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr [[RETVAL]], align 1
// CHECK-NEXT:    ret i8 [[TMP1]]
//
v1b foo(v1i v) { return v; }
// CHECK-LABEL: define dso_local noundef i8 @_Z3fooDv8_i(
// CHECK-SAME: ptr noundef byval(<8 x i32>) align 32 [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <8 x i1>, align 1
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <8 x i32>, align 32
// CHECK-NEXT:    [[V:%.*]] = load <8 x i32>, ptr [[TMP0]], align 32
// CHECK-NEXT:    store <8 x i32> [[V]], ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = load <8 x i32>, ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne <8 x i32> [[TMP1]], zeroinitializer
// CHECK-NEXT:    store <8 x i1> [[TOBOOL]], ptr [[RETVAL]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[RETVAL]], align 1
// CHECK-NEXT:    ret i8 [[TMP2]]
//
v8b foo(v8i v) { return v; }
// CHECK-LABEL: define dso_local noundef i16 @_Z3fooDv16_s(
// CHECK-SAME: ptr noundef byval(<16 x i16>) align 32 [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <16 x i1>, align 2
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <16 x i16>, align 32
// CHECK-NEXT:    [[V:%.*]] = load <16 x i16>, ptr [[TMP0]], align 32
// CHECK-NEXT:    store <16 x i16> [[V]], ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = load <16 x i16>, ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne <16 x i16> [[TMP1]], zeroinitializer
// CHECK-NEXT:    store <16 x i1> [[TOBOOL]], ptr [[RETVAL]], align 2
// CHECK-NEXT:    [[TMP2:%.*]] = load i16, ptr [[RETVAL]], align 2
// CHECK-NEXT:    ret i16 [[TMP2]]
//
v16b foo(v16i v) { return v; }
// CHECK-LABEL: define dso_local noundef i32 @_Z3fooDv32_c(
// CHECK-SAME: ptr noundef byval(<32 x i8>) align 32 [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <32 x i1>, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <32 x i8>, align 32
// CHECK-NEXT:    [[V:%.*]] = load <32 x i8>, ptr [[TMP0]], align 32
// CHECK-NEXT:    store <32 x i8> [[V]], ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = load <32 x i8>, ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne <32 x i8> [[TMP1]], zeroinitializer
// CHECK-NEXT:    store <32 x i1> [[TOBOOL]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
v32b foo(v32i v) { return v; }
