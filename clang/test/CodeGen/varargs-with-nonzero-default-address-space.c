// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 6
// RUN: %clang_cc1 -triple spirv64-unknown-unknown -fcuda-is-device -emit-llvm -o - %s | FileCheck %s

struct x {
  double b;
  long a;
};

// CHECK-LABEL: define spir_func void @testva(
// CHECK-SAME: i32 noundef [[N:%.*]], ...) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[AP:%.*]] = alloca ptr addrspace(4), align 8
// CHECK-NEXT:    [[T:%.*]] = alloca [[STRUCT_X:%.*]], align 8
// CHECK-NEXT:    [[AP2:%.*]] = alloca ptr addrspace(4), align 8
// CHECK-NEXT:    [[V:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[N_ADDR_ASCAST:%.*]] = addrspacecast ptr [[N_ADDR]] to ptr addrspace(4)
// CHECK-NEXT:    [[AP_ASCAST:%.*]] = addrspacecast ptr [[AP]] to ptr addrspace(4)
// CHECK-NEXT:    [[T_ASCAST:%.*]] = addrspacecast ptr [[T]] to ptr addrspace(4)
// CHECK-NEXT:    [[AP2_ASCAST:%.*]] = addrspacecast ptr [[AP2]] to ptr addrspace(4)
// CHECK-NEXT:    [[V_ASCAST:%.*]] = addrspacecast ptr [[V]] to ptr addrspace(4)
// CHECK-NEXT:    store i32 [[N]], ptr addrspace(4) [[N_ADDR_ASCAST]], align 4
// CHECK-NEXT:    call void @llvm.va_start.p4(ptr addrspace(4) [[AP_ASCAST]])
// CHECK-NEXT:    [[ARGP_CUR:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[AP_ASCAST]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[ARGP_CUR]], i32 7
// CHECK-NEXT:    [[ARGP_CUR_ALIGNED:%.*]] = call ptr addrspace(4) @llvm.ptrmask.p4.i64(ptr addrspace(4) [[TMP0]], i64 -8)
// CHECK-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[ARGP_CUR_ALIGNED]], i64 16
// CHECK-NEXT:    store ptr addrspace(4) [[ARGP_NEXT]], ptr addrspace(4) [[AP_ASCAST]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p4.p4.i64(ptr addrspace(4) align 8 [[T_ASCAST]], ptr addrspace(4) align 8 [[ARGP_CUR_ALIGNED]], i64 16, i1 false)
// CHECK-NEXT:    call void @llvm.va_copy.p4(ptr addrspace(4) [[AP2_ASCAST]], ptr addrspace(4) [[AP_ASCAST]])
// CHECK-NEXT:    [[ARGP_CUR1:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[AP2_ASCAST]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[ARGP_CUR1]], i32 3
// CHECK-NEXT:    [[ARGP_CUR1_ALIGNED:%.*]] = call ptr addrspace(4) @llvm.ptrmask.p4.i64(ptr addrspace(4) [[TMP1]], i64 -4)
// CHECK-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[ARGP_CUR1_ALIGNED]], i64 4
// CHECK-NEXT:    store ptr addrspace(4) [[ARGP_NEXT2]], ptr addrspace(4) [[AP2_ASCAST]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(4) [[ARGP_CUR1_ALIGNED]], align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr addrspace(4) [[V_ASCAST]], align 4
// CHECK-NEXT:    call void @llvm.va_end.p4(ptr addrspace(4) [[AP2_ASCAST]])
// CHECK-NEXT:    call void @llvm.va_end.p4(ptr addrspace(4) [[AP_ASCAST]])
// CHECK-NEXT:    ret void
//
void testva(int n, ...) {
  __builtin_va_list ap;
  __builtin_va_start(ap, n);
  struct x t = __builtin_va_arg(ap, struct x);
  __builtin_va_list ap2;
  __builtin_va_copy(ap2, ap);
  int v = __builtin_va_arg(ap2, int);
  __builtin_va_end(ap2);
  __builtin_va_end(ap);
}
