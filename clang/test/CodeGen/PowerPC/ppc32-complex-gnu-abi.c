// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2

// RUN: %clang_cc1 -triple powerpc-unknown-linux-unknown \
// RUN:   -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK-DEF
// RUN: %clang_cc1 -triple powerpc-unknown-linux-unknown -fcomplex-ppc-gnu-abi \
// RUN:   -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK-GNU

// CHECK-DEF-LABEL: define dso_local void @_cfloat
// CHECK-DEF-SAME: (ptr dead_on_unwind noalias writable sret({ float, float }) align 4 [[AGG_RESULT:%.*]], ptr noundef byval({ float, float }) align 4 [[X:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-DEF-NEXT:  entry:
// CHECK-DEF-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[X]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[X_REAL:%.*]] = load float, ptr [[X_REALP]], align 4
// CHECK-DEF-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[X]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[X_IMAG:%.*]] = load float, ptr [[X_IMAGP]], align 4
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store float [[X_REAL]], ptr [[AGG_RESULT_REALP]], align 4
// CHECK-DEF-NEXT:    store float [[X_IMAG]], ptr [[AGG_RESULT_IMAGP]], align 4
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP1:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_REAL:%.*]] = load float, ptr [[AGG_RESULT_REALP1]], align 4
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP2:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAG:%.*]] = load float, ptr [[AGG_RESULT_IMAGP2]], align 4
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP3:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP4:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store float [[AGG_RESULT_REAL]], ptr [[AGG_RESULT_REALP3]], align 4
// CHECK-DEF-NEXT:    store float [[AGG_RESULT_IMAG]], ptr [[AGG_RESULT_IMAGP4]], align 4
// CHECK-DEF-NEXT:    ret void
//
// CHECK-GNU-LABEL: define dso_local [1 x i64] @_cfloat
// CHECK-GNU-SAME: ([1 x i64] noundef [[X_COERCE:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-GNU-NEXT:  entry:
// CHECK-GNU-NEXT:    [[RETVAL:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-NEXT:    [[X:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-NEXT:    store [1 x i64] [[X_COERCE]], ptr [[X]], align 4
// CHECK-GNU-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[X]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[X_REAL:%.*]] = load float, ptr [[X_REALP]], align 4
// CHECK-GNU-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[X]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[X_IMAG:%.*]] = load float, ptr [[X_IMAGP]], align 4
// CHECK-GNU-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-NEXT:    store float [[X_REAL]], ptr [[RETVAL_REALP]], align 4
// CHECK-GNU-NEXT:    store float [[X_IMAG]], ptr [[RETVAL_IMAGP]], align 4
// CHECK-GNU-NEXT:    [[TMP0:%.*]] = load [1 x i64], ptr [[RETVAL]], align 4
// CHECK-GNU-NEXT:    ret [1 x i64] [[TMP0]]
//
_Complex float _cfloat(_Complex float x) {
  return x;
}


// CHECK-DEF-LABEL: define dso_local void @_cdouble
// CHECK-DEF-SAME: (ptr dead_on_unwind noalias writable sret({ double, double }) align 8 [[AGG_RESULT:%.*]], ptr noundef byval({ double, double }) align 8 [[X:%.*]]) #[[ATTR0]] {
// CHECK-DEF-NEXT:  entry:
// CHECK-DEF-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[X]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[X_REAL:%.*]] = load double, ptr [[X_REALP]], align 8
// CHECK-DEF-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[X]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[X_IMAG:%.*]] = load double, ptr [[X_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[X_REAL]], ptr [[AGG_RESULT_REALP]], align 8
// CHECK-DEF-NEXT:    store double [[X_IMAG]], ptr [[AGG_RESULT_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP1:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_REAL:%.*]] = load double, ptr [[AGG_RESULT_REALP1]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP2:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAG:%.*]] = load double, ptr [[AGG_RESULT_IMAGP2]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP3:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP4:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_REAL]], ptr [[AGG_RESULT_REALP3]], align 8
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_IMAG]], ptr [[AGG_RESULT_IMAGP4]], align 8
// CHECK-DEF-NEXT:    ret void
//
// CHECK-GNU-LABEL: define dso_local [4 x i32] @_cdouble
// CHECK-GNU-SAME: ([4 x i32] noundef [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-GNU-NEXT:  entry:
// CHECK-GNU-NEXT:    [[RETVAL:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[X:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    store [4 x i32] [[X_COERCE]], ptr [[X]], align 8
// CHECK-GNU-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[X]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[X_REAL:%.*]] = load double, ptr [[X_REALP]], align 8
// CHECK-GNU-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[X]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[X_IMAG:%.*]] = load double, ptr [[X_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-NEXT:    store double [[X_REAL]], ptr [[RETVAL_REALP]], align 8
// CHECK-GNU-NEXT:    store double [[X_IMAG]], ptr [[RETVAL_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[TMP0:%.*]] = load [4 x i32], ptr [[RETVAL]], align 8
// CHECK-GNU-NEXT:    ret [4 x i32] [[TMP0]]
//
_Complex double _cdouble(_Complex double x) {
  return x;
}



// CHECK-DEF-LABEL: define dso_local void @_cldouble
// CHECK-DEF-SAME: (ptr dead_on_unwind noalias writable sret({ ppc_fp128, ppc_fp128 }) align 16 [[AGG_RESULT:%.*]], ptr noundef byval({ ppc_fp128, ppc_fp128 }) align 16 [[X:%.*]]) #[[ATTR0]] {
// CHECK-DEF-NEXT:  entry:
// CHECK-DEF-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[X_REAL:%.*]] = load ppc_fp128, ptr [[X_REALP]], align 16
// CHECK-DEF-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[X_IMAG:%.*]] = load ppc_fp128, ptr [[X_IMAGP]], align 16
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store ppc_fp128 [[X_REAL]], ptr [[AGG_RESULT_REALP]], align 16
// CHECK-DEF-NEXT:    store ppc_fp128 [[X_IMAG]], ptr [[AGG_RESULT_IMAGP]], align 16
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP1:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_REAL:%.*]] = load ppc_fp128, ptr [[AGG_RESULT_REALP1]], align 16
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP2:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAG:%.*]] = load ppc_fp128, ptr [[AGG_RESULT_IMAGP2]], align 16
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP3:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP4:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store ppc_fp128 [[AGG_RESULT_REAL]], ptr [[AGG_RESULT_REALP3]], align 16
// CHECK-DEF-NEXT:    store ppc_fp128 [[AGG_RESULT_IMAG]], ptr [[AGG_RESULT_IMAGP4]], align 16
// CHECK-DEF-NEXT:    ret void
//
// CHECK-GNU-LABEL: define dso_local [8 x i32] @_cldouble
// CHECK-GNU-SAME: ([8 x i32] noundef [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-GNU-NEXT:  entry:
// CHECK-GNU-NEXT:    [[RETVAL:%.*]] = alloca { ppc_fp128, ppc_fp128 }, align 16
// CHECK-GNU-NEXT:    [[X:%.*]] = alloca { ppc_fp128, ppc_fp128 }, align 16
// CHECK-GNU-NEXT:    store [8 x i32] [[X_COERCE]], ptr [[X]], align 16
// CHECK-GNU-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[X_REAL:%.*]] = load ppc_fp128, ptr [[X_REALP]], align 16
// CHECK-GNU-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[X_IMAG:%.*]] = load ppc_fp128, ptr [[X_IMAGP]], align 16
// CHECK-GNU-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-NEXT:    store ppc_fp128 [[X_REAL]], ptr [[RETVAL_REALP]], align 16
// CHECK-GNU-NEXT:    store ppc_fp128 [[X_IMAG]], ptr [[RETVAL_IMAGP]], align 16
// CHECK-GNU-NEXT:    [[TMP0:%.*]] = load [8 x i32], ptr [[RETVAL]], align 16
// CHECK-GNU-NEXT:    ret [8 x i32] [[TMP0]]
//
_Complex long double _cldouble(_Complex long double x) {
  return x;
}



// CHECK-DEF-LABEL: define dso_local void @testComplexDouble
// CHECK-DEF-SAME: (ptr dead_on_unwind noalias writable sret({ double, double }) align 8 [[AGG_RESULT:%.*]], i32 noundef [[W:%.*]], ptr noundef byval({ float, float }) align 4 [[X:%.*]], ptr noundef byval({ double, double }) align 8 [[Z:%.*]]) #[[ATTR0]] {
// CHECK-DEF-NEXT:  entry:
// CHECK-DEF-NEXT:    [[W_ADDR:%.*]] = alloca i32, align 4
// CHECK-DEF-NEXT:    [[TMP:%.*]] = alloca { double, double }, align 8
// CHECK-DEF-NEXT:    [[BYVAL_TEMP:%.*]] = alloca { double, double }, align 8
// CHECK-DEF-NEXT:    store i32 [[W]], ptr [[W_ADDR]], align 4
// CHECK-DEF-NEXT:    [[Z_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[Z_REAL:%.*]] = load double, ptr [[Z_REALP]], align 8
// CHECK-DEF-NEXT:    [[Z_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[Z_IMAG:%.*]] = load double, ptr [[Z_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[BYVAL_TEMP_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[BYVAL_TEMP_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[Z_REAL]], ptr [[BYVAL_TEMP_REALP]], align 8
// CHECK-DEF-NEXT:    store double [[Z_IMAG]], ptr [[BYVAL_TEMP_IMAGP]], align 8
// CHECK-DEF-NEXT:    call void @_cdouble(ptr dead_on_unwind writable sret({ double, double }) align 8 [[TMP]], ptr noundef byval({ double, double }) align 8 [[BYVAL_TEMP]])
// CHECK-DEF-NEXT:    [[TMP_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[TMP]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[TMP_REAL:%.*]] = load double, ptr [[TMP_REALP]], align 8
// CHECK-DEF-NEXT:    [[TMP_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[TMP]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[TMP_IMAG:%.*]] = load double, ptr [[TMP_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[TMP_REAL]], ptr [[AGG_RESULT_REALP]], align 8
// CHECK-DEF-NEXT:    store double [[TMP_IMAG]], ptr [[AGG_RESULT_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP1:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_REAL:%.*]] = load double, ptr [[AGG_RESULT_REALP1]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP2:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAG:%.*]] = load double, ptr [[AGG_RESULT_IMAGP2]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP3:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP4:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_REAL]], ptr [[AGG_RESULT_REALP3]], align 8
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_IMAG]], ptr [[AGG_RESULT_IMAGP4]], align 8
// CHECK-DEF-NEXT:    ret void
//
// CHECK-GNU-LABEL: define dso_local [4 x i32] @testComplexDouble
// CHECK-GNU-SAME: (i32 noundef [[W:%.*]], [1 x i64] noundef [[X_COERCE:%.*]], [4 x i32] noundef [[Z_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-GNU-NEXT:  entry:
// CHECK-GNU-NEXT:    [[RETVAL:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[X:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-NEXT:    [[Z:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[W_ADDR:%.*]] = alloca i32, align 4
// CHECK-GNU-NEXT:    [[COERCE:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[COERCE1:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    store [1 x i64] [[X_COERCE]], ptr [[X]], align 4
// CHECK-GNU-NEXT:    store [4 x i32] [[Z_COERCE]], ptr [[Z]], align 8
// CHECK-GNU-NEXT:    store i32 [[W]], ptr [[W_ADDR]], align 4
// CHECK-GNU-NEXT:    [[Z_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[Z_REAL:%.*]] = load double, ptr [[Z_REALP]], align 8
// CHECK-GNU-NEXT:    [[Z_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[Z_IMAG:%.*]] = load double, ptr [[Z_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[COERCE_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[COERCE_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE]], i32 0, i32 1
// CHECK-GNU-NEXT:    store double [[Z_REAL]], ptr [[COERCE_REALP]], align 8
// CHECK-GNU-NEXT:    store double [[Z_IMAG]], ptr [[COERCE_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[TMP0:%.*]] = load [4 x i32], ptr [[COERCE]], align 8
// CHECK-GNU-NEXT:    [[CALL:%.*]] = call [4 x i32] @_cdouble([4 x i32] noundef [[TMP0]])
// CHECK-GNU-NEXT:    store [4 x i32] [[CALL]], ptr [[COERCE1]], align 8
// CHECK-GNU-NEXT:    [[COERCE1_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE1]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[COERCE1_REAL:%.*]] = load double, ptr [[COERCE1_REALP]], align 8
// CHECK-GNU-NEXT:    [[COERCE1_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE1]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[COERCE1_IMAG:%.*]] = load double, ptr [[COERCE1_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-NEXT:    store double [[COERCE1_REAL]], ptr [[RETVAL_REALP]], align 8
// CHECK-GNU-NEXT:    store double [[COERCE1_IMAG]], ptr [[RETVAL_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[TMP1:%.*]] = load [4 x i32], ptr [[RETVAL]], align 8
// CHECK-GNU-NEXT:    ret [4 x i32] [[TMP1]]
//
_Complex double testComplexDouble(int w, _Complex float x, _Complex double z)
{
  return _cdouble(z);
}



// CHECK-DEF-LABEL: define dso_local void @checkComplexDoubleOnStack
// CHECK-DEF-SAME: (ptr dead_on_unwind noalias writable sret({ double, double }) align 8 [[AGG_RESULT:%.*]], i32 noundef [[X1:%.*]], ptr noundef byval({ float, float }) align 4 [[CF:%.*]], i32 noundef [[X2:%.*]], ptr noundef byval({ double, double }) align 8 [[CD:%.*]]) #[[ATTR0]] {
// CHECK-DEF-NEXT:  entry:
// CHECK-DEF-NEXT:    [[X1_ADDR:%.*]] = alloca i32, align 4
// CHECK-DEF-NEXT:    [[X2_ADDR:%.*]] = alloca i32, align 4
// CHECK-DEF-NEXT:    [[TMP:%.*]] = alloca { double, double }, align 8
// CHECK-DEF-NEXT:    [[BYVAL_TEMP:%.*]] = alloca { float, float }, align 4
// CHECK-DEF-NEXT:    [[BYVAL_TEMP1:%.*]] = alloca { double, double }, align 8
// CHECK-DEF-NEXT:    store i32 [[X1]], ptr [[X1_ADDR]], align 4
// CHECK-DEF-NEXT:    store i32 [[X2]], ptr [[X2_ADDR]], align 4
// CHECK-DEF-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X2_ADDR]], align 4
// CHECK-DEF-NEXT:    [[CF_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[CF]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[CF_REAL:%.*]] = load float, ptr [[CF_REALP]], align 4
// CHECK-DEF-NEXT:    [[CF_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[CF]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[CF_IMAG:%.*]] = load float, ptr [[CF_IMAGP]], align 4
// CHECK-DEF-NEXT:    [[CD_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[CD]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[CD_REAL:%.*]] = load double, ptr [[CD_REALP]], align 8
// CHECK-DEF-NEXT:    [[CD_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[CD]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[CD_IMAG:%.*]] = load double, ptr [[CD_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[BYVAL_TEMP_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[BYVAL_TEMP]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[BYVAL_TEMP_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[BYVAL_TEMP]], i32 0, i32 1
// CHECK-DEF-NEXT:    store float [[CF_REAL]], ptr [[BYVAL_TEMP_REALP]], align 4
// CHECK-DEF-NEXT:    store float [[CF_IMAG]], ptr [[BYVAL_TEMP_IMAGP]], align 4
// CHECK-DEF-NEXT:    [[BYVAL_TEMP1_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP1]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[BYVAL_TEMP1_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP1]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[CD_REAL]], ptr [[BYVAL_TEMP1_REALP]], align 8
// CHECK-DEF-NEXT:    store double [[CD_IMAG]], ptr [[BYVAL_TEMP1_IMAGP]], align 8
// CHECK-DEF-NEXT:    call void @testComplexDouble(ptr dead_on_unwind writable sret({ double, double }) align 8 [[TMP]], i32 noundef [[TMP0]], ptr noundef byval({ float, float }) align 4 [[BYVAL_TEMP]], ptr noundef byval({ double, double }) align 8 [[BYVAL_TEMP1]])
// CHECK-DEF-NEXT:    [[TMP_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[TMP]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[TMP_REAL:%.*]] = load double, ptr [[TMP_REALP]], align 8
// CHECK-DEF-NEXT:    [[TMP_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[TMP]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[TMP_IMAG:%.*]] = load double, ptr [[TMP_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[TMP_REAL]], ptr [[AGG_RESULT_REALP]], align 8
// CHECK-DEF-NEXT:    store double [[TMP_IMAG]], ptr [[AGG_RESULT_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP2:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_REAL:%.*]] = load double, ptr [[AGG_RESULT_REALP2]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP3:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAG:%.*]] = load double, ptr [[AGG_RESULT_IMAGP3]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP4:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP5:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_REAL]], ptr [[AGG_RESULT_REALP4]], align 8
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_IMAG]], ptr [[AGG_RESULT_IMAGP5]], align 8
// CHECK-DEF-NEXT:    ret void
//
// CHECK-GNU-LABEL: define dso_local [4 x i32] @checkComplexDoubleOnStack
// CHECK-GNU-SAME: (i32 noundef [[X1:%.*]], [1 x i64] noundef [[CF_COERCE:%.*]], i32 noundef [[X2:%.*]], ptr noundef byval({ double, double }) align 8 [[CD:%.*]]) #[[ATTR0]] {
// CHECK-GNU-NEXT:  entry:
// CHECK-GNU-NEXT:    [[RETVAL:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[CF:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-NEXT:    [[X1_ADDR:%.*]] = alloca i32, align 4
// CHECK-GNU-NEXT:    [[X2_ADDR:%.*]] = alloca i32, align 4
// CHECK-GNU-NEXT:    [[COERCE:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-NEXT:    [[COERCE1:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[COERCE2:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    store [1 x i64] [[CF_COERCE]], ptr [[CF]], align 4
// CHECK-GNU-NEXT:    store i32 [[X1]], ptr [[X1_ADDR]], align 4
// CHECK-GNU-NEXT:    store i32 [[X2]], ptr [[X2_ADDR]], align 4
// CHECK-GNU-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X2_ADDR]], align 4
// CHECK-GNU-NEXT:    [[CF_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[CF]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[CF_REAL:%.*]] = load float, ptr [[CF_REALP]], align 4
// CHECK-GNU-NEXT:    [[CF_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[CF]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[CF_IMAG:%.*]] = load float, ptr [[CF_IMAGP]], align 4
// CHECK-GNU-NEXT:    [[CD_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[CD]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[CD_REAL:%.*]] = load double, ptr [[CD_REALP]], align 8
// CHECK-GNU-NEXT:    [[CD_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[CD]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[CD_IMAG:%.*]] = load double, ptr [[CD_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[COERCE_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[COERCE]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[COERCE_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[COERCE]], i32 0, i32 1
// CHECK-GNU-NEXT:    store float [[CF_REAL]], ptr [[COERCE_REALP]], align 4
// CHECK-GNU-NEXT:    store float [[CF_IMAG]], ptr [[COERCE_IMAGP]], align 4
// CHECK-GNU-NEXT:    [[TMP1:%.*]] = load [1 x i64], ptr [[COERCE]], align 4
// CHECK-GNU-NEXT:    [[COERCE1_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE1]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[COERCE1_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE1]], i32 0, i32 1
// CHECK-GNU-NEXT:    store double [[CD_REAL]], ptr [[COERCE1_REALP]], align 8
// CHECK-GNU-NEXT:    store double [[CD_IMAG]], ptr [[COERCE1_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[TMP2:%.*]] = load [4 x i32], ptr [[COERCE1]], align 8
// CHECK-GNU-NEXT:    [[CALL:%.*]] = call [4 x i32] @testComplexDouble(i32 noundef [[TMP0]], [1 x i64] noundef [[TMP1]], [4 x i32] noundef [[TMP2]])
// CHECK-GNU-NEXT:    store [4 x i32] [[CALL]], ptr [[COERCE2]], align 8
// CHECK-GNU-NEXT:    [[COERCE2_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE2]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[COERCE2_REAL:%.*]] = load double, ptr [[COERCE2_REALP]], align 8
// CHECK-GNU-NEXT:    [[COERCE2_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE2]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[COERCE2_IMAG:%.*]] = load double, ptr [[COERCE2_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-NEXT:    store double [[COERCE2_REAL]], ptr [[RETVAL_REALP]], align 8
// CHECK-GNU-NEXT:    store double [[COERCE2_IMAG]], ptr [[RETVAL_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[TMP3:%.*]] = load [4 x i32], ptr [[RETVAL]], align 8
// CHECK-GNU-NEXT:    ret [4 x i32] [[TMP3]]
//
_Complex double checkComplexDoubleOnStack(int x1, _Complex float cf, int x2, _Complex double cd)
{
  return testComplexDouble(x2, cf, cd);
}



// CHECK-DEF-LABEL: define dso_local void @checkComplexFloatOnStack
// CHECK-DEF-SAME: (ptr dead_on_unwind noalias writable sret({ double, double }) align 8 [[AGG_RESULT:%.*]], ptr noundef byval({ double, double }) align 8 [[_CD1:%.*]], ptr noundef byval({ float, float }) align 4 [[_CF1:%.*]], i32 noundef [[Y:%.*]], ptr noundef byval({ float, float }) align 4 [[_CF2:%.*]]) #[[ATTR0]] {
// CHECK-DEF-NEXT:  entry:
// CHECK-DEF-NEXT:    [[Y_ADDR:%.*]] = alloca i32, align 4
// CHECK-DEF-NEXT:    [[TMP:%.*]] = alloca { double, double }, align 8
// CHECK-DEF-NEXT:    [[BYVAL_TEMP:%.*]] = alloca { float, float }, align 4
// CHECK-DEF-NEXT:    [[BYVAL_TEMP1:%.*]] = alloca { double, double }, align 8
// CHECK-DEF-NEXT:    store i32 [[Y]], ptr [[Y_ADDR]], align 4
// CHECK-DEF-NEXT:    [[TMP0:%.*]] = load i32, ptr [[Y_ADDR]], align 4
// CHECK-DEF-NEXT:    [[_CF2_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[_CF2]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[_CF2_REAL:%.*]] = load float, ptr [[_CF2_REALP]], align 4
// CHECK-DEF-NEXT:    [[_CF2_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[_CF2]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[_CF2_IMAG:%.*]] = load float, ptr [[_CF2_IMAGP]], align 4
// CHECK-DEF-NEXT:    [[_CD1_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[_CD1]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[_CD1_REAL:%.*]] = load double, ptr [[_CD1_REALP]], align 8
// CHECK-DEF-NEXT:    [[_CD1_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[_CD1]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[_CD1_IMAG:%.*]] = load double, ptr [[_CD1_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[BYVAL_TEMP_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[BYVAL_TEMP]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[BYVAL_TEMP_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[BYVAL_TEMP]], i32 0, i32 1
// CHECK-DEF-NEXT:    store float [[_CF2_REAL]], ptr [[BYVAL_TEMP_REALP]], align 4
// CHECK-DEF-NEXT:    store float [[_CF2_IMAG]], ptr [[BYVAL_TEMP_IMAGP]], align 4
// CHECK-DEF-NEXT:    [[BYVAL_TEMP1_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP1]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[BYVAL_TEMP1_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP1]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[_CD1_REAL]], ptr [[BYVAL_TEMP1_REALP]], align 8
// CHECK-DEF-NEXT:    store double [[_CD1_IMAG]], ptr [[BYVAL_TEMP1_IMAGP]], align 8
// CHECK-DEF-NEXT:    call void @checkComplexDoubleOnStack(ptr dead_on_unwind writable sret({ double, double }) align 8 [[TMP]], i32 noundef [[TMP0]], ptr noundef byval({ float, float }) align 4 [[BYVAL_TEMP]], i32 noundef 0, ptr noundef byval({ double, double }) align 8 [[BYVAL_TEMP1]])
// CHECK-DEF-NEXT:    [[TMP_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[TMP]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[TMP_REAL:%.*]] = load double, ptr [[TMP_REALP]], align 8
// CHECK-DEF-NEXT:    [[TMP_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[TMP]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[TMP_IMAG:%.*]] = load double, ptr [[TMP_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[TMP_REAL]], ptr [[AGG_RESULT_REALP]], align 8
// CHECK-DEF-NEXT:    store double [[TMP_IMAG]], ptr [[AGG_RESULT_IMAGP]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP2:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_REAL:%.*]] = load double, ptr [[AGG_RESULT_REALP2]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP3:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAG:%.*]] = load double, ptr [[AGG_RESULT_IMAGP3]], align 8
// CHECK-DEF-NEXT:    [[AGG_RESULT_REALP4:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-DEF-NEXT:    [[AGG_RESULT_IMAGP5:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_REAL]], ptr [[AGG_RESULT_REALP4]], align 8
// CHECK-DEF-NEXT:    store double [[AGG_RESULT_IMAG]], ptr [[AGG_RESULT_IMAGP5]], align 8
// CHECK-DEF-NEXT:    ret void
//
// CHECK-GNU-LABEL: define dso_local [4 x i32] @checkComplexFloatOnStack
// CHECK-GNU-SAME: ([4 x i32] noundef [[_CD1_COERCE:%.*]], [1 x i64] noundef [[_CF1_COERCE:%.*]], i32 noundef [[Y:%.*]], ptr noundef byval({ float, float }) align 4 [[_CF2:%.*]]) #[[ATTR0]] {
// CHECK-GNU-NEXT:  entry:
// CHECK-GNU-NEXT:    [[RETVAL:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[_CD1:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[_CF1:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-NEXT:    [[Y_ADDR:%.*]] = alloca i32, align 4
// CHECK-GNU-NEXT:    [[COERCE:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-NEXT:    [[BYVAL_TEMP:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    [[COERCE1:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-NEXT:    store [4 x i32] [[_CD1_COERCE]], ptr [[_CD1]], align 8
// CHECK-GNU-NEXT:    store [1 x i64] [[_CF1_COERCE]], ptr [[_CF1]], align 4
// CHECK-GNU-NEXT:    store i32 [[Y]], ptr [[Y_ADDR]], align 4
// CHECK-GNU-NEXT:    [[TMP0:%.*]] = load i32, ptr [[Y_ADDR]], align 4
// CHECK-GNU-NEXT:    [[_CF2_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[_CF2]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[_CF2_REAL:%.*]] = load float, ptr [[_CF2_REALP]], align 4
// CHECK-GNU-NEXT:    [[_CF2_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[_CF2]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[_CF2_IMAG:%.*]] = load float, ptr [[_CF2_IMAGP]], align 4
// CHECK-GNU-NEXT:    [[_CD1_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[_CD1]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[_CD1_REAL:%.*]] = load double, ptr [[_CD1_REALP]], align 8
// CHECK-GNU-NEXT:    [[_CD1_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[_CD1]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[_CD1_IMAG:%.*]] = load double, ptr [[_CD1_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[COERCE_REALP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[COERCE]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[COERCE_IMAGP:%.*]] = getelementptr inbounds nuw { float, float }, ptr [[COERCE]], i32 0, i32 1
// CHECK-GNU-NEXT:    store float [[_CF2_REAL]], ptr [[COERCE_REALP]], align 4
// CHECK-GNU-NEXT:    store float [[_CF2_IMAG]], ptr [[COERCE_IMAGP]], align 4
// CHECK-GNU-NEXT:    [[TMP1:%.*]] = load [1 x i64], ptr [[COERCE]], align 4
// CHECK-GNU-NEXT:    [[BYVAL_TEMP_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[BYVAL_TEMP_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[BYVAL_TEMP]], i32 0, i32 1
// CHECK-GNU-NEXT:    store double [[_CD1_REAL]], ptr [[BYVAL_TEMP_REALP]], align 8
// CHECK-GNU-NEXT:    store double [[_CD1_IMAG]], ptr [[BYVAL_TEMP_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[CALL:%.*]] = call [4 x i32] @checkComplexDoubleOnStack(i32 noundef [[TMP0]], [1 x i64] noundef [[TMP1]], i32 noundef 0, ptr noundef byval({ double, double }) align 8 [[BYVAL_TEMP]])
// CHECK-GNU-NEXT:    store [4 x i32] [[CALL]], ptr [[COERCE1]], align 8
// CHECK-GNU-NEXT:    [[COERCE1_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE1]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[COERCE1_REAL:%.*]] = load double, ptr [[COERCE1_REALP]], align 8
// CHECK-GNU-NEXT:    [[COERCE1_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[COERCE1]], i32 0, i32 1
// CHECK-GNU-NEXT:    [[COERCE1_IMAG:%.*]] = load double, ptr [[COERCE1_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-NEXT:    store double [[COERCE1_REAL]], ptr [[RETVAL_REALP]], align 8
// CHECK-GNU-NEXT:    store double [[COERCE1_IMAG]], ptr [[RETVAL_IMAGP]], align 8
// CHECK-GNU-NEXT:    [[TMP2:%.*]] = load [4 x i32], ptr [[RETVAL]], align 8
// CHECK-GNU-NEXT:    ret [4 x i32] [[TMP2]]
//
_Complex double checkComplexFloatOnStack(_Complex double _cd1, _Complex float _cf1, int y, _Complex float _cf2)
{
  return checkComplexDoubleOnStack(y, _cf2, 0, _cd1);
}
