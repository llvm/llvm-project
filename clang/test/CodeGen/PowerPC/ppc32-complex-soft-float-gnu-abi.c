// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2

// RUN: %clang_cc1 -triple powerpc-unknown-linux-unknown -fcomplex-ppc-gnu-abi \
// RUN:   -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK-GNU-DEF
// RUN: %clang_cc1 -msoft-float  -mfloat-abi soft -triple powerpc-unknown-linux-unknown -fcomplex-ppc-gnu-abi \
// RUN:   -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK-GNU-SOFT-FLOAT


// CHECK-GNU-DEF-LABEL: define dso_local [8 x i32] @_cldouble
// CHECK-GNU-DEF-SAME: (float noundef [[F:%.*]], [8 x i32] noundef [[X_COERCE:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-GNU-DEF-NEXT:  entry:
// CHECK-GNU-DEF-NEXT:    [[RETVAL:%.*]] = alloca { ppc_fp128, ppc_fp128 }, align 16
// CHECK-GNU-DEF-NEXT:    [[X:%.*]] = alloca { ppc_fp128, ppc_fp128 }, align 16
// CHECK-GNU-DEF-NEXT:    [[F_ADDR:%.*]] = alloca float, align 4
// CHECK-GNU-DEF-NEXT:    store [8 x i32] [[X_COERCE]], ptr [[X]], align 16
// CHECK-GNU-DEF-NEXT:    store float [[F]], ptr [[F_ADDR]], align 4
// CHECK-GNU-DEF-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 0
// CHECK-GNU-DEF-NEXT:    [[X_REAL:%.*]] = load ppc_fp128, ptr [[X_REALP]], align 16
// CHECK-GNU-DEF-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 1
// CHECK-GNU-DEF-NEXT:    [[X_IMAG:%.*]] = load ppc_fp128, ptr [[X_IMAGP]], align 16
// CHECK-GNU-DEF-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-DEF-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-DEF-NEXT:    store ppc_fp128 [[X_REAL]], ptr [[RETVAL_REALP]], align 16
// CHECK-GNU-DEF-NEXT:    store ppc_fp128 [[X_IMAG]], ptr [[RETVAL_IMAGP]], align 16
// CHECK-GNU-DEF-NEXT:    [[TMP0:%.*]] = load [8 x i32], ptr [[RETVAL]], align 16
// CHECK-GNU-DEF-NEXT:    ret [8 x i32] [[TMP0]]
//
// CHECK-GNU-SOFT-FLOAT-LABEL: define dso_local [8 x i32] @_cldouble
// CHECK-GNU-SOFT-FLOAT-SAME: (float noundef [[F:%.*]], ptr noundef byval({ ppc_fp128, ppc_fp128 }) align 16 [[X:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-GNU-SOFT-FLOAT-NEXT:  entry:
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[RETVAL:%.*]] = alloca { ppc_fp128, ppc_fp128 }, align 16
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[F_ADDR:%.*]] = alloca float, align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    store float [[F]], ptr [[F_ADDR]], align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[X_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 0
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[X_REAL:%.*]] = load ppc_fp128, ptr [[X_REALP]], align 16
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[X_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[X]], i32 0, i32 1
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[X_IMAG:%.*]] = load ppc_fp128, ptr [[X_IMAGP]], align 16
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { ppc_fp128, ppc_fp128 }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-SOFT-FLOAT-NEXT:    store ppc_fp128 [[X_REAL]], ptr [[RETVAL_REALP]], align 16
// CHECK-GNU-SOFT-FLOAT-NEXT:    store ppc_fp128 [[X_IMAG]], ptr [[RETVAL_IMAGP]], align 16
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[TMP0:%.*]] = load [8 x i32], ptr [[RETVAL]], align 16
// CHECK-GNU-SOFT-FLOAT-NEXT:    ret [8 x i32] [[TMP0]]
//
_Complex long double _cldouble(float f, _Complex long double x) {
  return x;
}



// CHECK-GNU-DEF-LABEL: define dso_local [4 x i32] @testComplexDouble
// CHECK-GNU-DEF-SAME: (float noundef [[W:%.*]], [1 x i64] noundef [[X_COERCE:%.*]], float noundef [[Y:%.*]], [4 x i32] noundef [[Z_COERCE:%.*]]) #[[ATTR0]] {
// CHECK-GNU-DEF-NEXT:  entry:
// CHECK-GNU-DEF-NEXT:    [[RETVAL:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-DEF-NEXT:    [[X:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-DEF-NEXT:    [[Z:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-DEF-NEXT:    [[W_ADDR:%.*]] = alloca float, align 4
// CHECK-GNU-DEF-NEXT:    [[Y_ADDR:%.*]] = alloca float, align 4
// CHECK-GNU-DEF-NEXT:    store [1 x i64] [[X_COERCE]], ptr [[X]], align 4
// CHECK-GNU-DEF-NEXT:    store [4 x i32] [[Z_COERCE]], ptr [[Z]], align 8
// CHECK-GNU-DEF-NEXT:    store float [[W]], ptr [[W_ADDR]], align 4
// CHECK-GNU-DEF-NEXT:    store float [[Y]], ptr [[Y_ADDR]], align 4
// CHECK-GNU-DEF-NEXT:    [[Z_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 0
// CHECK-GNU-DEF-NEXT:    [[Z_REAL:%.*]] = load double, ptr [[Z_REALP]], align 8
// CHECK-GNU-DEF-NEXT:    [[Z_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 1
// CHECK-GNU-DEF-NEXT:    [[Z_IMAG:%.*]] = load double, ptr [[Z_IMAGP]], align 8
// CHECK-GNU-DEF-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-DEF-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-DEF-NEXT:    store double [[Z_REAL]], ptr [[RETVAL_REALP]], align 8
// CHECK-GNU-DEF-NEXT:    store double [[Z_IMAG]], ptr [[RETVAL_IMAGP]], align 8
// CHECK-GNU-DEF-NEXT:    [[TMP0:%.*]] = load [4 x i32], ptr [[RETVAL]], align 8
// CHECK-GNU-DEF-NEXT:    ret [4 x i32] [[TMP0]]
//
// CHECK-GNU-SOFT-FLOAT-LABEL: define dso_local [4 x i32] @testComplexDouble
// CHECK-GNU-SOFT-FLOAT-SAME: (float noundef [[W:%.*]], [1 x i64] noundef [[X_COERCE:%.*]], float noundef [[Y:%.*]], ptr noundef byval({ double, double }) align 8 [[Z:%.*]]) #[[ATTR0]] {
// CHECK-GNU-SOFT-FLOAT-NEXT:  entry:
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[RETVAL:%.*]] = alloca { double, double }, align 8
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[X:%.*]] = alloca { float, float }, align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[W_ADDR:%.*]] = alloca float, align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[Y_ADDR:%.*]] = alloca float, align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    store [1 x i64] [[X_COERCE]], ptr [[X]], align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    store float [[W]], ptr [[W_ADDR]], align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    store float [[Y]], ptr [[Y_ADDR]], align 4
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[Z_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 0
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[Z_REAL:%.*]] = load double, ptr [[Z_REALP]], align 8
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[Z_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[Z]], i32 0, i32 1
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[Z_IMAG:%.*]] = load double, ptr [[Z_IMAGP]], align 8
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[RETVAL_REALP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 0
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[RETVAL_IMAGP:%.*]] = getelementptr inbounds nuw { double, double }, ptr [[RETVAL]], i32 0, i32 1
// CHECK-GNU-SOFT-FLOAT-NEXT:    store double [[Z_REAL]], ptr [[RETVAL_REALP]], align 8
// CHECK-GNU-SOFT-FLOAT-NEXT:    store double [[Z_IMAG]], ptr [[RETVAL_IMAGP]], align 8
// CHECK-GNU-SOFT-FLOAT-NEXT:    [[TMP0:%.*]] = load [4 x i32], ptr [[RETVAL]], align 8
// CHECK-GNU-SOFT-FLOAT-NEXT:    ret [4 x i32] [[TMP0]]
//
_Complex double testComplexDouble(float w, _Complex float x, float y, _Complex double z)
{
  return z;
}
