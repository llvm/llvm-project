// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --filter "^define |^entry:" --version 2
// RUN: %clang_cc1 -x c++ -triple riscv32 -target-feature +f -target-abi ilp32f -emit-llvm %s -o - \
// RUN:   | FileCheck -check-prefixes=CHECK32 %s
// RUN: %clang_cc1 -x c++ -triple riscv32 -target-feature +f -target-feature +d -target-abi ilp32d -emit-llvm %s -o - \
// RUN:   | FileCheck -check-prefixes=CHECK32 %s
// RUN: %clang_cc1 -x c++ -triple riscv64 -target-feature +f -target-abi lp64f -emit-llvm %s -o - \
// RUN:   | FileCheck -check-prefixes=CHECK64 %s
// RUN: %clang_cc1 -x c++ -triple riscv64 -target-feature +f -target-feature +d -target-abi lp64d -emit-llvm %s -o - \
// RUN:   | FileCheck -check-prefixes=CHECK64 %s

#include <stdint.h>

// Structs containing C99 flexible array members should always be passed and returned on the stack.

struct s1 {
    int a;
    int b[];
};

// CHECK32-LABEL: define dso_local void @_Z7test_012s1
// CHECK32-SAME: (ptr dead_on_unwind noalias writable sret([[STRUCT_S1:%.*]]) align 4 [[AGG_RESULT:%.*]], ptr noundef byval([[STRUCT_S1]]) align 4 [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK32:  entry:
//
// CHECK64-LABEL: define dso_local void @_Z7test_012s1
// CHECK64-SAME: (ptr dead_on_unwind noalias writable sret([[STRUCT_S1:%.*]]) align 4 [[AGG_RESULT:%.*]], ptr noundef byval([[STRUCT_S1]]) align 4 [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK64:  entry:
//
struct s1 test_01(struct s1 a) {
  return a;
}


// CHECK32-LABEL: define dso_local void @_Z7test_02v
// CHECK32-SAME: (ptr dead_on_unwind noalias writable sret([[STRUCT_S1:%.*]]) align 4 [[AGG_RESULT:%.*]]) #[[ATTR0]] {
// CHECK32:  entry:
//
// CHECK64-LABEL: define dso_local void @_Z7test_02v
// CHECK64-SAME: (ptr dead_on_unwind noalias writable sret([[STRUCT_S1:%.*]]) align 4 [[AGG_RESULT:%.*]]) #[[ATTR0]] {
// CHECK64:  entry:
//
struct s1 test_02() {
    struct s1 r;
    r.a = 0;
    r.b[0] = 1;
    return r;
}
