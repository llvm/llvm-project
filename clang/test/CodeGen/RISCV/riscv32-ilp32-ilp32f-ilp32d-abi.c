// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --filter "^define |^entry:" --version 2
// RUN: %clang_cc1 -triple riscv32 -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -triple riscv32 -emit-llvm -fforce-enable-int128 %s -o - \
// RUN:   | FileCheck %s -check-prefixes=CHECK,CHECK-FORCEINT128
// RUN: %clang_cc1 -triple riscv32 -target-feature +f -target-abi ilp32f -emit-llvm %s -o - \
// RUN:     | FileCheck %s
// RUN: %clang_cc1 -triple riscv32 -target-feature +d -target-feature +f -target-abi ilp32d -emit-llvm %s -o - \
// RUN:     | FileCheck %s

// This file contains test cases that will have the same output for the ilp32,
// ilp32f, and ilp32d ABIs.

#include <stddef.h>
#include <stdint.h>

// CHECK-LABEL: define dso_local void @f_void
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK:  entry:
//
void f_void(void) {}

// Scalar arguments and return values smaller than the word size are extended
// according to the sign of their type, up to 32 bits

// CHECK-LABEL: define dso_local zeroext i1 @f_scalar_0
// CHECK-SAME: (i1 noundef zeroext [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
_Bool f_scalar_0(_Bool x) { return x; }

// CHECK-LABEL: define dso_local signext i8 @f_scalar_1
// CHECK-SAME: (i8 noundef signext [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
int8_t f_scalar_1(int8_t x) { return x; }

// CHECK-LABEL: define dso_local zeroext i8 @f_scalar_2
// CHECK-SAME: (i8 noundef zeroext [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
uint8_t f_scalar_2(uint8_t x) { return x; }

// CHECK-LABEL: define dso_local i32 @f_scalar_3
// CHECK-SAME: (i32 noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
int32_t f_scalar_3(int32_t x) { return x; }

// CHECK-LABEL: define dso_local i64 @f_scalar_4
// CHECK-SAME: (i64 noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
int64_t f_scalar_4(int64_t x) { return x; }

#ifdef __SIZEOF_INT128__
// CHECK-FORCEINT128-LABEL: define dso_local i128 @f_scalar_5
// CHECK-FORCEINT128-SAME: (i128 noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-FORCEINT128:  entry:
//
__int128_t f_scalar_5(__int128_t x) { return x; }
#endif

// CHECK-LABEL: define dso_local float @f_fp_scalar_1
// CHECK-SAME: (float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
float f_fp_scalar_1(float x) { return x; }

// CHECK-LABEL: define dso_local double @f_fp_scalar_2
// CHECK-SAME: (double noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
double f_fp_scalar_2(double x) { return x; }

// Scalars larger than 2*xlen are passed/returned indirect. However, the
// RISC-V LLVM backend can handle this fine, so the function doesn't need to
// be modified.

// CHECK-LABEL: define dso_local fp128 @f_fp_scalar_3
// CHECK-SAME: (fp128 noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
long double f_fp_scalar_3(long double x) { return x; }

// Empty structs or unions are ignored.

struct empty_s {};

// CHECK-LABEL: define dso_local void @f_agg_empty_struct
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct empty_s f_agg_empty_struct(struct empty_s x) {
  return x;
}

union empty_u {};

// CHECK-LABEL: define dso_local void @f_agg_empty_union
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
union empty_u f_agg_empty_union(union empty_u x) {
  return x;
}

// Aggregates <= 2*xlen may be passed in registers, so will be coerced to
// integer arguments. The rules for return are the same.

struct tiny {
  uint8_t a, b, c, d;
};

// CHECK-LABEL: define dso_local void @f_agg_tiny
// CHECK-SAME: (i32 [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_agg_tiny(struct tiny x) {
  x.a += x.b;
  x.c += x.d;
}

// CHECK-LABEL: define dso_local i32 @f_agg_tiny_ret
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct tiny f_agg_tiny_ret(void) {
  return (struct tiny){1, 2, 3, 4};
}

typedef uint8_t v4i8 __attribute__((vector_size(4)));
typedef int32_t v1i32 __attribute__((vector_size(4)));

// CHECK-LABEL: define dso_local void @f_vec_tiny_v4i8
// CHECK-SAME: (i32 noundef [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_vec_tiny_v4i8(v4i8 x) {
  x[0] = x[1];
  x[2] = x[3];
}

// CHECK-LABEL: define dso_local i32 @f_vec_tiny_v4i8_ret
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
v4i8 f_vec_tiny_v4i8_ret(void) {
  return (v4i8){1, 2, 3, 4};
}

// CHECK-LABEL: define dso_local void @f_vec_tiny_v1i32
// CHECK-SAME: (i32 noundef [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_vec_tiny_v1i32(v1i32 x) {
  x[0] = 114;
}

// CHECK-LABEL: define dso_local i32 @f_vec_tiny_v1i32_ret
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
v1i32 f_vec_tiny_v1i32_ret(void) {
  return (v1i32){1};
}

struct small {
  int32_t a, *b;
};

// CHECK-LABEL: define dso_local void @f_agg_small
// CHECK-SAME: ([2 x i32] [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_agg_small(struct small x) {
  x.a += *x.b;
  x.b = &x.a;
}

// CHECK-LABEL: define dso_local [2 x i32] @f_agg_small_ret
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct small f_agg_small_ret(void) {
  return (struct small){1, 0};
}

typedef uint8_t v8i8 __attribute__((vector_size(8)));
typedef int64_t v1i64 __attribute__((vector_size(8)));

// CHECK-LABEL: define dso_local void @f_vec_small_v8i8
// CHECK-SAME: (i64 noundef [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_vec_small_v8i8(v8i8 x) {
  x[0] = x[7];
}

// CHECK-LABEL: define dso_local i64 @f_vec_small_v8i8_ret
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
v8i8 f_vec_small_v8i8_ret(void) {
  return (v8i8){1, 2, 3, 4, 5, 6, 7, 8};
}

// CHECK-LABEL: define dso_local void @f_vec_small_v1i64
// CHECK-SAME: (i64 noundef [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_vec_small_v1i64(v1i64 x) {
  x[0] = 114;
}

// CHECK-LABEL: define dso_local i64 @f_vec_small_v1i64_ret
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
v1i64 f_vec_small_v1i64_ret(void) {
  return (v1i64){1};
}

// Aggregates of 2*xlen size and 2*xlen alignment should be coerced to a
// single 2*xlen-sized argument, to ensure that alignment can be maintained if
// passed on the stack.

struct small_aligned {
  int64_t a;
};

// CHECK-LABEL: define dso_local void @f_agg_small_aligned
// CHECK-SAME: (i64 [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_agg_small_aligned(struct small_aligned x) {
  x.a += x.a;
}

// CHECK-LABEL: define dso_local i64 @f_agg_small_aligned_ret
// CHECK-SAME: (i64 [[X_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
struct small_aligned f_agg_small_aligned_ret(struct small_aligned x) {
  return (struct small_aligned){10};
}

// Aggregates greater > 2*xlen will be passed and returned indirectly
struct large {
  int32_t a, b, c, d;
};

// CHECK-LABEL: define dso_local void @f_agg_large
// CHECK-SAME: (ptr noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_agg_large(struct large x) {
  x.a = x.b + x.c + x.d;
}

// The address where the struct should be written to will be the first
// argument
// CHECK-LABEL: define dso_local void @f_agg_large_ret
// CHECK-SAME: (ptr noalias sret([[STRUCT_LARGE:%.*]]) align 4 [[AGG_RESULT:%.*]], i32 noundef [[I:%.*]], i8 noundef signext [[J:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
struct large f_agg_large_ret(int32_t i, int8_t j) {
  return (struct large){1, 2, 3, 4};
}

typedef unsigned char v16i8 __attribute__((vector_size(16)));

// CHECK-LABEL: define dso_local void @f_vec_large_v16i8
// CHECK-SAME: (ptr noundef [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_vec_large_v16i8(v16i8 x) {
  x[0] = x[7];
}

// CHECK-LABEL: define dso_local void @f_vec_large_v16i8_ret
// CHECK-SAME: (ptr noalias sret(<16 x i8>) align 16 [[AGG_RESULT:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
v16i8 f_vec_large_v16i8_ret(void) {
  return (v16i8){1, 2, 3, 4, 5, 6, 7, 8};
}

// Scalars passed on the stack should have signext/zeroext attributes, just as
// if they were passed in registers

// CHECK-LABEL: define dso_local i32 @f_scalar_stack_1
// CHECK-SAME: (i32 [[A_COERCE:%.*]], [2 x i32] [[B_COERCE:%.*]], i64 [[C_COERCE:%.*]], ptr noundef [[D:%.*]], i8 noundef zeroext [[E:%.*]], i8 noundef signext [[F:%.*]], i8 noundef zeroext [[G:%.*]], i8 noundef signext [[H:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
int f_scalar_stack_1(struct tiny a, struct small b, struct small_aligned c,
                     struct large d, uint8_t e, int8_t f, uint8_t g, int8_t h) {
  return g + h;
}

// Ensure that scalars passed on the stack are still determined correctly in
// the presence of large return values that consume a register due to the need
// to pass a pointer.

// CHECK-LABEL: define dso_local void @f_scalar_stack_2
// CHECK-SAME: (ptr noalias sret([[STRUCT_LARGE:%.*]]) align 4 [[AGG_RESULT:%.*]], i32 noundef [[A:%.*]], i64 noundef [[B:%.*]], i64 noundef [[C:%.*]], fp128 noundef [[D:%.*]], i8 noundef zeroext [[E:%.*]], i8 noundef signext [[F:%.*]], i8 noundef zeroext [[G:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
struct large f_scalar_stack_2(int32_t a, int64_t b, int64_t c, long double d,
                              uint8_t e, int8_t f, uint8_t g) {
  return (struct large){a, e, f, g};
}

// CHECK-LABEL: define dso_local fp128 @f_scalar_stack_4
// CHECK-SAME: (i32 noundef [[A:%.*]], i64 noundef [[B:%.*]], i64 noundef [[C:%.*]], fp128 noundef [[D:%.*]], i8 noundef zeroext [[E:%.*]], i8 noundef signext [[F:%.*]], i8 noundef zeroext [[G:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
long double f_scalar_stack_4(int32_t a, int64_t b, int64_t c, long double d,
                             uint8_t e, int8_t f, uint8_t g) {
  return d;
}

// Aggregates and >=XLen scalars passed on the stack should be lowered just as
// they would be if passed via registers.

// CHECK-LABEL: define dso_local void @f_scalar_stack_5
// CHECK-SAME: (double noundef [[A:%.*]], i64 noundef [[B:%.*]], double noundef [[C:%.*]], i64 noundef [[D:%.*]], i32 noundef [[E:%.*]], i64 noundef [[F:%.*]], float noundef [[G:%.*]], double noundef [[H:%.*]], fp128 noundef [[I:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_scalar_stack_5(double a, int64_t b, double c, int64_t d, int e,
                      int64_t f, float g, double h, long double i) {}

// CHECK-LABEL: define dso_local void @f_agg_stack
// CHECK-SAME: (double noundef [[A:%.*]], i64 noundef [[B:%.*]], double noundef [[C:%.*]], i64 noundef [[D:%.*]], i32 [[E_COERCE:%.*]], [2 x i32] [[F_COERCE:%.*]], i64 [[G_COERCE:%.*]], ptr noundef [[H:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_agg_stack(double a, int64_t b, double c, int64_t d, struct tiny e,
                 struct small f, struct small_aligned g, struct large h) {}
