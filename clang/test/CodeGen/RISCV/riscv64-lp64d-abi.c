// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --filter "^define |^entry:" --version 2
// RUN: %clang_cc1 -triple riscv64 -target-feature +d -target-feature +f -target-abi lp64d -emit-llvm %s -o - \
// RUN:     | FileCheck %s

#include <stdint.h>

// Verify that the tracking of used GPRs and FPRs works correctly by checking
// that small integers are sign/zero extended when passed in registers.

// Doubles are passed in FPRs, so argument 'i' will be passed zero-extended
// because it will be passed in a GPR.

// CHECK-LABEL: define dso_local void @f_fpr_tracking
// CHECK-SAME: (double noundef [[A:%.*]], double noundef [[B:%.*]], double noundef [[C:%.*]], double noundef [[D:%.*]], double noundef [[E:%.*]], double noundef [[F:%.*]], double noundef [[G:%.*]], double noundef [[H:%.*]], i8 noundef zeroext [[I:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK:  entry:
//
void f_fpr_tracking(double a, double b, double c, double d, double e, double f,
                    double g, double h, uint8_t i) {}

// Check that fp, fp+fp, and int+fp structs are lowered correctly. These will
// be passed in FPR, FPR+FPR, or GPR+FPR regs if sufficient registers are
// available the widths are <= XLEN and FLEN, and should be expanded to
// separate arguments in IR. They are passed by the same rules for returns,
// but will be lowered to simple two-element structs if necessary (as LLVM IR
// functions cannot return multiple values).

// A struct containing just one floating-point real is passed as though it
// were a standalone floating-point real.

struct double_s { double f; };

// CHECK-LABEL: define dso_local void @f_double_s_arg
// CHECK-SAME: (double [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_s_arg(struct double_s a) {}

// CHECK-LABEL: define dso_local double @f_ret_double_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_s f_ret_double_s(void) {
  return (struct double_s){1.0};
}

// A struct containing a double and any number of zero-width bitfields is
// passed as though it were a standalone floating-point real.

struct zbf_double_s { int : 0; double f; };
struct zbf_double_zbf_s { int : 0; double f; int : 0; };

// CHECK-LABEL: define dso_local void @f_zbf_double_s_arg
// CHECK-SAME: (double [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_zbf_double_s_arg(struct zbf_double_s a) {}

// CHECK-LABEL: define dso_local double @f_ret_zbf_double_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct zbf_double_s f_ret_zbf_double_s(void) {
  return (struct zbf_double_s){1.0};
}

// CHECK-LABEL: define dso_local void @f_zbf_double_zbf_s_arg
// CHECK-SAME: (double [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_zbf_double_zbf_s_arg(struct zbf_double_zbf_s a) {}

// CHECK-LABEL: define dso_local double @f_ret_zbf_double_zbf_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct zbf_double_zbf_s f_ret_zbf_double_zbf_s(void) {
  return (struct zbf_double_zbf_s){1.0};
}

// Check that structs containing two floating point values (FLEN <= width) are
// expanded provided sufficient FPRs are available.

struct double_double_s { double f; double g; };
struct double_float_s { double f; float g; };

// CHECK-LABEL: define dso_local void @f_double_double_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], double [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_double_s_arg(struct double_double_s a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_double_double_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_double_s f_ret_double_double_s(void) {
  return (struct double_double_s){1.0, 2.0};
}

// CHECK-LABEL: define dso_local void @f_double_float_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], float [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_float_s_arg(struct double_float_s a) {}

// CHECK-LABEL: define dso_local { double, float } @f_ret_double_float_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_float_s f_ret_double_float_s(void) {
  return (struct double_float_s){1.0, 2.0};
}

// CHECK-LABEL: define dso_local void @f_double_double_s_arg_insufficient_fprs
// CHECK-SAME: (float noundef [[A:%.*]], double noundef [[B:%.*]], double noundef [[C:%.*]], double noundef [[D:%.*]], double noundef [[E:%.*]], double noundef [[F:%.*]], double noundef [[G:%.*]], [2 x i64] [[H_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_double_s_arg_insufficient_fprs(float a, double b, double c, double d,
    double e, double f, double g, struct double_double_s h) {}

// Check that structs containing int+double values are expanded, provided
// sufficient FPRs and GPRs are available. The integer components are neither
// sign or zero-extended.

struct double_int8_s { double f; int8_t i; };
struct double_uint8_s { double f; uint8_t i; };
struct double_int32_s { double f; int32_t i; };
struct double_int64_s { double f; int64_t i; };
struct double_int128bf_s { double f; __int128_t i : 64; };
struct double_int8_zbf_s { double f; int8_t i; int : 0; };

// CHECK-LABEL: define dso_local void @f_double_int8_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], i8 [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_int8_s_arg(struct double_int8_s a) {}

// CHECK-LABEL: define dso_local { double, i8 } @f_ret_double_int8_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_int8_s f_ret_double_int8_s(void) {
  return (struct double_int8_s){1.0, 2};
}

// CHECK-LABEL: define dso_local void @f_double_uint8_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], i8 [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_uint8_s_arg(struct double_uint8_s a) {}

// CHECK-LABEL: define dso_local { double, i8 } @f_ret_double_uint8_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_uint8_s f_ret_double_uint8_s(void) {
  return (struct double_uint8_s){1.0, 2};
}

// CHECK-LABEL: define dso_local void @f_double_int32_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], i32 [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_int32_s_arg(struct double_int32_s a) {}

// CHECK-LABEL: define dso_local { double, i32 } @f_ret_double_int32_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_int32_s f_ret_double_int32_s(void) {
  return (struct double_int32_s){1.0, 2};
}

// CHECK-LABEL: define dso_local void @f_double_int64_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], i64 [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_int64_s_arg(struct double_int64_s a) {}

// CHECK-LABEL: define dso_local { double, i64 } @f_ret_double_int64_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_int64_s f_ret_double_int64_s(void) {
  return (struct double_int64_s){1.0, 2};
}

// CHECK-LABEL: define dso_local void @f_double_int128bf_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], i64 [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_int128bf_s_arg(struct double_int128bf_s a) {}

// CHECK-LABEL: define dso_local { double, i64 } @f_ret_double_int128bf_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_int128bf_s f_ret_double_int128bf_s(void) {
  return (struct double_int128bf_s){1.0, 2};
}

// The zero-width bitfield means the struct can't be passed according to the
// floating point calling convention.

// CHECK-LABEL: define dso_local void @f_double_int8_zbf_s
// CHECK-SAME: (double [[TMP0:%.*]], i8 [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_int8_zbf_s(struct double_int8_zbf_s a) {}

// CHECK-LABEL: define dso_local { double, i8 } @f_ret_double_int8_zbf_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct double_int8_zbf_s f_ret_double_int8_zbf_s(void) {
  return (struct double_int8_zbf_s){1.0, 2};
}

// CHECK-LABEL: define dso_local void @f_double_int8_s_arg_insufficient_gprs
// CHECK-SAME: (i32 noundef signext [[A:%.*]], i32 noundef signext [[B:%.*]], i32 noundef signext [[C:%.*]], i32 noundef signext [[D:%.*]], i32 noundef signext [[E:%.*]], i32 noundef signext [[F:%.*]], i32 noundef signext [[G:%.*]], i32 noundef signext [[H:%.*]], [2 x i64] [[I_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_int8_s_arg_insufficient_gprs(int a, int b, int c, int d, int e,
                                          int f, int g, int h, struct double_int8_s i) {}

// CHECK-LABEL: define dso_local void @f_struct_double_int8_insufficient_fprs
// CHECK-SAME: (float noundef [[A:%.*]], double noundef [[B:%.*]], double noundef [[C:%.*]], double noundef [[D:%.*]], double noundef [[E:%.*]], double noundef [[F:%.*]], double noundef [[G:%.*]], double noundef [[H:%.*]], [2 x i64] [[I_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_struct_double_int8_insufficient_fprs(float a, double b, double c, double d,
                                           double e, double f, double g, double h, struct double_int8_s i) {}

// Complex floating-point values or structs containing a single complex
// floating-point value should be passed as if it were an fp+fp struct.

// CHECK-LABEL: define dso_local void @f_doublecomplex
// CHECK-SAME: (double noundef [[A_COERCE0:%.*]], double noundef [[A_COERCE1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublecomplex(double __complex__ a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_doublecomplex
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
double __complex__ f_ret_doublecomplex(void) {
  return 1.0;
}

struct doublecomplex_s { double __complex__ c; };

// CHECK-LABEL: define dso_local void @f_doublecomplex_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], double [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublecomplex_s_arg(struct doublecomplex_s a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_doublecomplex_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct doublecomplex_s f_ret_doublecomplex_s(void) {
  return (struct doublecomplex_s){1.0};
}

// Test single or two-element structs that need flattening. e.g. those
// containing nested structs, doubles in small arrays, zero-length structs etc.

struct doublearr1_s { double a[1]; };

// CHECK-LABEL: define dso_local void @f_doublearr1_s_arg
// CHECK-SAME: (double [[TMP0:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublearr1_s_arg(struct doublearr1_s a) {}

// CHECK-LABEL: define dso_local double @f_ret_doublearr1_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct doublearr1_s f_ret_doublearr1_s(void) {
  return (struct doublearr1_s){{1.0}};
}

struct doublearr2_s { double a[2]; };

// CHECK-LABEL: define dso_local void @f_doublearr2_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], double [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublearr2_s_arg(struct doublearr2_s a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_doublearr2_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct doublearr2_s f_ret_doublearr2_s(void) {
  return (struct doublearr2_s){{1.0, 2.0}};
}

struct doublearr2_tricky1_s { struct { double f[1]; } g[2]; };

// CHECK-LABEL: define dso_local void @f_doublearr2_tricky1_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], double [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublearr2_tricky1_s_arg(struct doublearr2_tricky1_s a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_doublearr2_tricky1_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct doublearr2_tricky1_s f_ret_doublearr2_tricky1_s(void) {
  return (struct doublearr2_tricky1_s){{{{1.0}}, {{2.0}}}};
}

struct doublearr2_tricky2_s { struct {}; struct { double f[1]; } g[2]; };

// CHECK-LABEL: define dso_local void @f_doublearr2_tricky2_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], double [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublearr2_tricky2_s_arg(struct doublearr2_tricky2_s a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_doublearr2_tricky2_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct doublearr2_tricky2_s f_ret_doublearr2_tricky2_s(void) {
  return (struct doublearr2_tricky2_s){{}, {{{1.0}}, {{2.0}}}};
}

struct doublearr2_tricky3_s { union {}; struct { double f[1]; } g[2]; };

// CHECK-LABEL: define dso_local void @f_doublearr2_tricky3_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], double [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublearr2_tricky3_s_arg(struct doublearr2_tricky3_s a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_doublearr2_tricky3_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct doublearr2_tricky3_s f_ret_doublearr2_tricky3_s(void) {
  return (struct doublearr2_tricky3_s){{}, {{{1.0}}, {{2.0}}}};
}

struct doublearr2_tricky4_s { union {}; struct { struct {}; double f[1]; } g[2]; };

// CHECK-LABEL: define dso_local void @f_doublearr2_tricky4_s_arg
// CHECK-SAME: (double [[TMP0:%.*]], double [[TMP1:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_doublearr2_tricky4_s_arg(struct doublearr2_tricky4_s a) {}

// CHECK-LABEL: define dso_local { double, double } @f_ret_doublearr2_tricky4_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct doublearr2_tricky4_s f_ret_doublearr2_tricky4_s(void) {
  return (struct doublearr2_tricky4_s){{}, {{{}, {1.0}}, {{}, {2.0}}}};
}

// Test structs that should be passed according to the normal integer calling
// convention.

struct int_double_int_s { int a; double b; int c; };

// CHECK-LABEL: define dso_local void @f_int_double_int_s_arg
// CHECK-SAME: (ptr noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_int_double_int_s_arg(struct int_double_int_s a) {}

// CHECK-LABEL: define dso_local void @f_ret_int_double_int_s
// CHECK-SAME: (ptr noalias sret([[STRUCT_INT_DOUBLE_INT_S:%.*]]) align 8 [[AGG_RESULT:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
struct int_double_int_s f_ret_int_double_int_s(void) {
  return (struct int_double_int_s){1, 2.0, 3};
}

struct char_char_double_s { char a; char b; double c; };

// CHECK-LABEL: define dso_local void @f_char_char_double_s_arg
// CHECK-SAME: ([2 x i64] [[A_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_char_char_double_s_arg(struct char_char_double_s a) {}

// CHECK-LABEL: define dso_local [2 x i64] @f_ret_char_char_double_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct char_char_double_s f_ret_char_char_double_s(void) {
  return (struct char_char_double_s){1, 2, 3.0};
}

// Unions are always passed according to the integer calling convention, even
// if they can only contain a double.

union double_u { double a; };

// CHECK-LABEL: define dso_local void @f_double_u_arg
// CHECK-SAME: (i64 [[A_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_double_u_arg(union double_u a) {}

// CHECK-LABEL: define dso_local i64 @f_ret_double_u
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
union double_u f_ret_double_u(void) {
  return (union double_u){1.0};
}
