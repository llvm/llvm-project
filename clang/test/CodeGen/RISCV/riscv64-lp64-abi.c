// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --filter "^define |^entry:" --version 2
// RUN: %clang_cc1 -triple riscv64 -emit-llvm %s -o - | FileCheck %s

// This file contains test cases that will have different output for lp64 vs
// the other 64-bit ABIs.

#include <stddef.h>
#include <stdint.h>

struct large {
  int64_t a, b, c, d;
};

typedef unsigned char v32i8 __attribute__((vector_size(32)));

// Scalars passed on the stack should have signext/zeroext attributes, just as
// if they were passed in registers.

// CHECK-LABEL: define dso_local signext i32 @f_scalar_stack_1
// CHECK-SAME: (i32 noundef signext [[A:%.*]], i128 noundef [[B:%.*]], float noundef [[C:%.*]], fp128 noundef [[D:%.*]], ptr noundef [[TMP0:%.*]], i8 noundef zeroext [[F:%.*]], i8 noundef signext [[G:%.*]], i8 noundef zeroext [[H:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK:  entry:
//
int f_scalar_stack_1(int32_t a, __int128_t b, float c, long double d, v32i8 e,
                     uint8_t f, int8_t g, uint8_t h) {
  return g + h;
}

// CHECK-LABEL: define dso_local void @f_scalar_stack_2
// CHECK-SAME: (ptr noalias sret([[STRUCT_LARGE:%.*]]) align 8 [[AGG_RESULT:%.*]], double noundef [[A:%.*]], i128 noundef [[B:%.*]], fp128 noundef [[C:%.*]], ptr noundef [[TMP0:%.*]], i8 noundef zeroext [[E:%.*]], i8 noundef signext [[F:%.*]], i8 noundef zeroext [[G:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
struct large f_scalar_stack_2(double a, __int128_t b, long double c, v32i8 d,
                              uint8_t e, int8_t f, uint8_t g) {
  return (struct large){a, e, f, g};
}

// Complex floating-point values or structs containing a single complex
// floating-point value should be passed in a GPR.

// CHECK-LABEL: define dso_local void @f_floatcomplex
// CHECK-SAME: (i64 noundef [[A_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_floatcomplex(float __complex__ a) {}

// CHECK-LABEL: define dso_local i64 @f_ret_floatcomplex
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
float __complex__ f_ret_floatcomplex(void) {
  return 1.0;
}

struct floatcomplex_s { float __complex__ c; };

// CHECK-LABEL: define dso_local void @f_floatcomplex_s_arg
// CHECK-SAME: (i64 [[A_COERCE:%.*]]) #[[ATTR0]] {
// CHECK:  entry:
//
void f_floatcomplex_s_arg(struct floatcomplex_s a) {}

// CHECK-LABEL: define dso_local i64 @f_ret_floatcomplex_s
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:  entry:
//
struct floatcomplex_s f_ret_floatcomplex_s(void) {
  return (struct floatcomplex_s){1.0};
}
