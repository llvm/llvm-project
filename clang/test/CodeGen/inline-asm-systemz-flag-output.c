// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -triple s390x-linux -emit-llvm -o - %s | FileCheck %s
// CHECK-LABEL: define dso_local signext i32 @foo_012(
// CHECK-SAME: i32 noundef signext [[X:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CC:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 [[TMP0]]) #[[ATTR2:[0-9]+]], !srcloc [[META2:![0-9]+]]
// CHECK-NEXT:    [[ASMRESULT:%.*]] = extractvalue { i32, i32 } [[TMP1]], 0
// CHECK-NEXT:    [[ASMRESULT1:%.*]] = extractvalue { i32, i32 } [[TMP1]], 1
// CHECK-NEXT:    store i32 [[ASMRESULT]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[ASMRESULT1]], 4
// CHECK-NEXT:    call void @llvm.assume(i1 [[TMP2]])
// CHECK-NEXT:    store i32 [[ASMRESULT1]], ptr [[CC]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP3]], 0
// CHECK-NEXT:    br i1 [[CMP]], label %[[LOR_END:.*]], label %[[LOR_LHS_FALSE:.*]]
// CHECK:       [[LOR_LHS_FALSE]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[TMP4]], 1
// CHECK-NEXT:    br i1 [[CMP2]], label %[[LOR_END]], label %[[LOR_RHS:.*]]
// CHECK:       [[LOR_RHS]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i32 [[TMP5]], 2
// CHECK-NEXT:    br label %[[LOR_END]]
// CHECK:       [[LOR_END]]:
// CHECK-NEXT:    [[TMP6:%.*]] = phi i1 [ true, %[[LOR_LHS_FALSE]] ], [ true, %[[ENTRY]] ], [ [[CMP3]], %[[LOR_RHS]] ]
// CHECK-NEXT:    [[TMP7:%.*]] = zext i1 [[TMP6]] to i64
// CHECK-NEXT:    [[COND:%.*]] = select i1 [[TMP6]], i32 42, i32 0
// CHECK-NEXT:    ret i32 [[COND]]
//
int foo_012(int x) {
  int cc;
  asm volatile ("ahi %[x],42\n" : [x] "+d"(x), "=@cc" (cc));
  return cc == 0 || cc == 1 || cc == 2 ? 42 : 0;
}

// CHECK-LABEL: define dso_local signext i32 @foo_013(
// CHECK-SAME: i32 noundef signext [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CC:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 [[TMP0]]) #[[ATTR2]], !srcloc [[META3:![0-9]+]]
// CHECK-NEXT:    [[ASMRESULT:%.*]] = extractvalue { i32, i32 } [[TMP1]], 0
// CHECK-NEXT:    [[ASMRESULT1:%.*]] = extractvalue { i32, i32 } [[TMP1]], 1
// CHECK-NEXT:    store i32 [[ASMRESULT]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[ASMRESULT1]], 4
// CHECK-NEXT:    call void @llvm.assume(i1 [[TMP2]])
// CHECK-NEXT:    store i32 [[ASMRESULT1]], ptr [[CC]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP3]], 0
// CHECK-NEXT:    br i1 [[CMP]], label %[[LOR_END:.*]], label %[[LOR_LHS_FALSE:.*]]
// CHECK:       [[LOR_LHS_FALSE]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[TMP4]], 1
// CHECK-NEXT:    br i1 [[CMP2]], label %[[LOR_END]], label %[[LOR_RHS:.*]]
// CHECK:       [[LOR_RHS]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i32 [[TMP5]], 3
// CHECK-NEXT:    br label %[[LOR_END]]
// CHECK:       [[LOR_END]]:
// CHECK-NEXT:    [[TMP6:%.*]] = phi i1 [ true, %[[LOR_LHS_FALSE]] ], [ true, %[[ENTRY]] ], [ [[CMP3]], %[[LOR_RHS]] ]
// CHECK-NEXT:    [[TMP7:%.*]] = zext i1 [[TMP6]] to i64
// CHECK-NEXT:    [[COND:%.*]] = select i1 [[TMP6]], i32 42, i32 0
// CHECK-NEXT:    ret i32 [[COND]]
//
int foo_013(int x) {
  int cc;
  asm volatile ("ahi %[x],42\n" : [x] "+d"(x), "=@cc" (cc));
  return cc == 0 || cc == 1 || cc == 3 ? 42 : 0;
}

// CHECK-LABEL: define dso_local signext i32 @foo_023(
// CHECK-SAME: i32 noundef signext [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CC:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 [[TMP0]]) #[[ATTR2]], !srcloc [[META4:![0-9]+]]
// CHECK-NEXT:    [[ASMRESULT:%.*]] = extractvalue { i32, i32 } [[TMP1]], 0
// CHECK-NEXT:    [[ASMRESULT1:%.*]] = extractvalue { i32, i32 } [[TMP1]], 1
// CHECK-NEXT:    store i32 [[ASMRESULT]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[ASMRESULT1]], 4
// CHECK-NEXT:    call void @llvm.assume(i1 [[TMP2]])
// CHECK-NEXT:    store i32 [[ASMRESULT1]], ptr [[CC]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP3]], 0
// CHECK-NEXT:    br i1 [[CMP]], label %[[LOR_END:.*]], label %[[LOR_LHS_FALSE:.*]]
// CHECK:       [[LOR_LHS_FALSE]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[TMP4]], 2
// CHECK-NEXT:    br i1 [[CMP2]], label %[[LOR_END]], label %[[LOR_RHS:.*]]
// CHECK:       [[LOR_RHS]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i32 [[TMP5]], 3
// CHECK-NEXT:    br label %[[LOR_END]]
// CHECK:       [[LOR_END]]:
// CHECK-NEXT:    [[TMP6:%.*]] = phi i1 [ true, %[[LOR_LHS_FALSE]] ], [ true, %[[ENTRY]] ], [ [[CMP3]], %[[LOR_RHS]] ]
// CHECK-NEXT:    [[TMP7:%.*]] = zext i1 [[TMP6]] to i64
// CHECK-NEXT:    [[COND:%.*]] = select i1 [[TMP6]], i32 42, i32 0
// CHECK-NEXT:    ret i32 [[COND]]
//
int foo_023(int x) {
  int cc;
  asm volatile ("ahi %[x],42\n" : [x] "+d"(x), "=@cc" (cc));
  return cc == 0 || cc == 2 || cc == 3 ? 42 : 0;
}

// CHECK-LABEL: define dso_local signext i32 @foo_123(
// CHECK-SAME: i32 noundef signext [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*]]:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CC:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = call { i32, i32 } asm sideeffect "ahi $0,42\0A", "=d,={@cc},0"(i32 [[TMP0]]) #[[ATTR2]], !srcloc [[META5:![0-9]+]]
// CHECK-NEXT:    [[ASMRESULT:%.*]] = extractvalue { i32, i32 } [[TMP1]], 0
// CHECK-NEXT:    [[ASMRESULT1:%.*]] = extractvalue { i32, i32 } [[TMP1]], 1
// CHECK-NEXT:    store i32 [[ASMRESULT]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i32 [[ASMRESULT1]], 4
// CHECK-NEXT:    call void @llvm.assume(i1 [[TMP2]])
// CHECK-NEXT:    store i32 [[ASMRESULT1]], ptr [[CC]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP3]], 1
// CHECK-NEXT:    br i1 [[CMP]], label %[[LOR_END:.*]], label %[[LOR_LHS_FALSE:.*]]
// CHECK:       [[LOR_LHS_FALSE]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[TMP4]], 2
// CHECK-NEXT:    br i1 [[CMP2]], label %[[LOR_END]], label %[[LOR_RHS:.*]]
// CHECK:       [[LOR_RHS]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[CC]], align 4
// CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i32 [[TMP5]], 3
// CHECK-NEXT:    br label %[[LOR_END]]
// CHECK:       [[LOR_END]]:
// CHECK-NEXT:    [[TMP6:%.*]] = phi i1 [ true, %[[LOR_LHS_FALSE]] ], [ true, %[[ENTRY]] ], [ [[CMP3]], %[[LOR_RHS]] ]
// CHECK-NEXT:    [[TMP7:%.*]] = zext i1 [[TMP6]] to i64
// CHECK-NEXT:    [[COND:%.*]] = select i1 [[TMP6]], i32 42, i32 0
// CHECK-NEXT:    ret i32 [[COND]]
//
int foo_123(int x) {
  int cc;
  asm volatile ("ahi %[x],42\n" : [x] "+d"(x), "=@cc" (cc));
  return cc == 1 || cc == 2 || cc == 3 ? 42 : 0;
}
