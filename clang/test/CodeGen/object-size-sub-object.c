// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 4
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -fstrict-flex-arrays=3 -emit-llvm %s -o - | FileCheck %s

typedef __SIZE_TYPE__ size_t;

#define __bdos(a) __builtin_dynamic_object_size(a, 1)

struct U {
  double d;
  int i;
};

struct test_struct {
  struct test_struct *vptr;
  char buf1[5];
  struct i {
    char a;
    int b[2][13];
    int c, d;
  } z;
  struct U *u_ptr;
  unsigned _a : 1;
  unsigned _b : 2;
  struct {
    struct {
      char x_1;
      char x_2[37];
    };
  };
  union {
    struct { char _z[20]; } m;
    struct { char _y[13]; } n;
  } u;
  char buf2[7];
};

size_t ret;

// CHECK-LABEL: define dso_local i64 @test1(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.objectsize.i64.p0(ptr [[TMP0]], i1 false, i1 true, i1 true)
// CHECK-NEXT:    ret i64 [[TMP1]]
//
size_t test1(struct test_struct *p, int idx) {
  return __bdos(p); // -1
}

// CHECK-LABEL: define dso_local i64 @test2(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 5, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test2(struct test_struct *p, int idx) {
  return __bdos(&p->buf1[idx]); // 5 - idx
}

// CHECK-LABEL: define dso_local i64 @test3(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 116, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test3(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->z)[idx]); // 116 - idx
}

// CHECK-LABEL: define dso_local i64 @test4(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 1, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test4(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->z.a)[idx]); // 1 - idx
}

// CHECK-LABEL: define dso_local i64 @test5(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 104, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test5(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->z.b)[idx]); // 104 - idx
}

// CHECK-LABEL: define dso_local i64 @test6(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 4, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test6(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->z.c)[idx]); // 4 - idx
}

// CHECK-LABEL: define dso_local i64 @test7(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 4, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test7(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->z.d)[idx]); // 4 - idx
}

// CHECK-LABEL: define dso_local i64 @test8(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 8, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test8(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->u_ptr->d)[idx]); // 8 - idx
}

// CHECK-LABEL: define dso_local i64 @test9(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 1, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test9(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->x_1)[idx]); // 1 - idx
}

// CHECK-LABEL: define dso_local i64 @test10(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 37, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test10(struct test_struct *p, int idx) {
  return __bdos(&((char *)&p->x_2)[idx]); // 37 - idx
}

// CHECK-LABEL: define dso_local i64 @test11(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 20, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test11(struct test_struct *p, int idx) {
  return __bdos(&p->u.m._z[idx]); // 20 - idx
}

// CHECK-LABEL: define dso_local i64 @test12(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 13, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test12(struct test_struct *p, int idx) {
  return __bdos(&p->u.n._y[idx]); // 13 - idx
}

// CHECK-LABEL: define dso_local i64 @test13(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 7, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test13(struct test_struct *p, int idx) {
  return __bdos(&p->buf2[idx]); // 7 - idx
}

// Referencing a flexible array member through a pointer.
struct stest14 {
  unsigned long flags;
  int count;
  struct {
    char a;
    int array[];
  } *z;
};

// CHECK-LABEL: define dso_local i64 @test14(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    ret i64 -1
//
size_t test14(struct stest14 *p, int idx) {
  return __bdos(&p->z->array[idx]); // -1
}

struct stest15 {
  int array[10];
  int dummy;
};

// CHECK-LABEL: define dso_local i64 @test15(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[IDX:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[IDX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[IDX]], ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[IDX_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP2:%.*]] = mul i64 1, [[TMP1]]
// CHECK-NEXT:    [[TMP3:%.*]] = sub i64 40, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = icmp sgt i64 [[TMP3]], -1
// CHECK-NEXT:    [[TMP5:%.*]] = select i1 [[TMP4]], i64 [[TMP3]], i64 0
// CHECK-NEXT:    ret i64 [[TMP5]]
//
size_t test15(struct stest15 *p, int idx) {
  return __bdos(&((char *)p->array)[idx]);
}
