// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple riscv64-none-linux-gnu -target-feature +f -target-feature +d -target-feature +zve64d -mvscale-min=4 -mvscale-max=4 -S -O1 -emit-llvm -o - %s | FileCheck %s

// REQUIRES: riscv-registered-target

#include <riscv_vector.h>

typedef vint32m1_t fixed_int32m1_t __attribute__((riscv_rvv_vector_bits(__riscv_v_fixed_vlen)));
typedef vfloat64m1_t fixed_float64m1_t __attribute__((riscv_rvv_vector_bits(__riscv_v_fixed_vlen)));

//===----------------------------------------------------------------------===//
// Test caller/callee with VLST <-> VLAT
//===----------------------------------------------------------------------===//

// CHECK-LABEL: @sizeless_callee(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret <vscale x 2 x i32> [[X:%.*]]
//
vint32m1_t sizeless_callee(vint32m1_t x) {
  return x;
}

// CHECK-LABEL: @fixed_caller(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret <vscale x 2 x i32> [[X_COERCE:%.*]]
//
fixed_int32m1_t fixed_caller(fixed_int32m1_t x) {
  return sizeless_callee(x);
}

// CHECK-LABEL: @fixed_callee(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret <vscale x 2 x i32> [[X_COERCE:%.*]]
//
fixed_int32m1_t fixed_callee(fixed_int32m1_t x) {
  return x;
}

// CHECK-LABEL: @sizeless_caller(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[COERCE1:%.*]] = alloca <8 x i32>, align 8
// CHECK-NEXT:    store <vscale x 2 x i32> [[X:%.*]], ptr [[COERCE1]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load <8 x i32>, ptr [[COERCE1]], align 8, !tbaa [[TBAA4:![0-9]+]]
// CHECK-NEXT:    [[CASTSCALABLESVE2:%.*]] = tail call <vscale x 2 x i32> @llvm.vector.insert.nxv2i32.v8i32(<vscale x 2 x i32> undef, <8 x i32> [[TMP0]], i64 0)
// CHECK-NEXT:    ret <vscale x 2 x i32> [[CASTSCALABLESVE2]]
//
vint32m1_t sizeless_caller(vint32m1_t x) {
  return fixed_callee(x);
}

//===----------------------------------------------------------------------===//
// fixed, fixed
//===----------------------------------------------------------------------===//

// CHECK-LABEL: @call_int32_ff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <vscale x 2 x i32> @llvm.riscv.vadd.nxv2i32.nxv2i32.i64(<vscale x 2 x i32> poison, <vscale x 2 x i32> noundef [[OP1_COERCE:%.*]], <vscale x 2 x i32> noundef [[OP2_COERCE:%.*]], i64 8)
// CHECK-NEXT:    ret <vscale x 2 x i32> [[TMP0]]
//
fixed_int32m1_t call_int32_ff(fixed_int32m1_t op1, fixed_int32m1_t op2) {
  return __riscv_vadd(op1, op2, __riscv_v_fixed_vlen/32);
}

// CHECK-LABEL: @call_float64_ff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <vscale x 1 x double> @llvm.riscv.vfadd.nxv1f64.nxv1f64.i64(<vscale x 1 x double> poison, <vscale x 1 x double> noundef [[OP1_COERCE:%.*]], <vscale x 1 x double> noundef [[OP2_COERCE:%.*]], i64 4)
// CHECK-NEXT:    ret <vscale x 1 x double> [[TMP0]]
//
fixed_float64m1_t call_float64_ff(fixed_float64m1_t op1, fixed_float64m1_t op2) {
  return __riscv_vfadd(op1, op2, __riscv_v_fixed_vlen/64);
}

//===----------------------------------------------------------------------===//
// fixed, scalable
//===----------------------------------------------------------------------===//

// CHECK-LABEL: @call_int32_fs(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <vscale x 2 x i32> @llvm.riscv.vadd.nxv2i32.nxv2i32.i64(<vscale x 2 x i32> poison, <vscale x 2 x i32> noundef [[OP1_COERCE:%.*]], <vscale x 2 x i32> [[OP2:%.*]], i64 8)
// CHECK-NEXT:    ret <vscale x 2 x i32> [[TMP0]]
//
fixed_int32m1_t call_int32_fs(fixed_int32m1_t op1, vint32m1_t op2) {
  return __riscv_vadd(op1, op2, __riscv_v_fixed_vlen/32);
}

// CHECK-LABEL: @call_float64_fs(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <vscale x 1 x double> @llvm.riscv.vfadd.nxv1f64.nxv1f64.i64(<vscale x 1 x double> poison, <vscale x 1 x double> noundef [[OP1_COERCE:%.*]], <vscale x 1 x double> [[OP2:%.*]], i64 4)
// CHECK-NEXT:    ret <vscale x 1 x double> [[TMP0]]
//
fixed_float64m1_t call_float64_fs(fixed_float64m1_t op1, vfloat64m1_t op2) {
  return __riscv_vfadd(op1, op2, __riscv_v_fixed_vlen/64);
}

//===----------------------------------------------------------------------===//
// scalable, scalable
//===----------------------------------------------------------------------===//

// CHECK-LABEL: @call_int32_ss(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <vscale x 2 x i32> @llvm.riscv.vadd.nxv2i32.nxv2i32.i64(<vscale x 2 x i32> poison, <vscale x 2 x i32> [[OP1:%.*]], <vscale x 2 x i32> [[OP2:%.*]], i64 8)
// CHECK-NEXT:    ret <vscale x 2 x i32> [[TMP0]]
//
fixed_int32m1_t call_int32_ss(vint32m1_t op1, vint32m1_t op2) {
  return __riscv_vadd(op1, op2, __riscv_v_fixed_vlen/32);
}

// CHECK-LABEL: @call_float64_ss(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <vscale x 1 x double> @llvm.riscv.vfadd.nxv1f64.nxv1f64.i64(<vscale x 1 x double> poison, <vscale x 1 x double> [[OP1:%.*]], <vscale x 1 x double> [[OP2:%.*]], i64 4)
// CHECK-NEXT:    ret <vscale x 1 x double> [[TMP0]]
//
fixed_float64m1_t call_float64_ss(vfloat64m1_t op1, vfloat64m1_t op2) {
  return __riscv_vfadd(op1, op2, __riscv_v_fixed_vlen/64);
}
