// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --check-globals --include-generated-funcs --global-value-regex "f"
// RUN: %clang_cc1 -opaque-pointers -triple arm64ec-windows-msvc -emit-llvm -o - %s | FileCheck %s

typedef struct { float x[2]; } A;
typedef struct { char x[6]; } B;
typedef struct { float x[4]; } C;
void f(A a, ...) {
  __builtin_va_list args;
  __builtin_va_start(args, a);
  float x = __builtin_va_arg(args, A).x[0];
  float y = __builtin_va_arg(args, B).x[0];
  float z = __builtin_va_arg(args, C).x[0];
}
void g(A a, B b, C c) { f(a, b, c); }

// CHECK-LABEL: @f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca [[STRUCT_A:%.*]], align 4
// CHECK-NEXT:    [[ARGS:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_A]], align 4
// CHECK-NEXT:    [[Y:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[REF_TMP2:%.*]] = alloca [[STRUCT_B:%.*]], align 1
// CHECK-NEXT:    [[Z:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[REF_TMP7:%.*]] = alloca [[STRUCT_C:%.*]], align 4
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[A]], i32 0, i32 0
// CHECK-NEXT:    store i64 [[A_COERCE:%.*]], ptr [[COERCE_DIVE]], align 4
// CHECK-NEXT:    call void @llvm.va_start.p0(ptr [[ARGS]])
// CHECK-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[ARGS]], align 8
// CHECK-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i64 8
// CHECK-NEXT:    store ptr [[ARGP_NEXT]], ptr [[ARGS]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[REF_TMP]], ptr align 8 [[ARGP_CUR]], i64 8, i1 false)
// CHECK-NEXT:    [[X1:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[REF_TMP]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x float], ptr [[X1]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    store float [[TMP0]], ptr [[X]], align 4
// CHECK-NEXT:    [[ARGP_CUR3:%.*]] = load ptr, ptr [[ARGS]], align 8
// CHECK-NEXT:    [[ARGP_NEXT4:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR3]], i64 8
// CHECK-NEXT:    store ptr [[ARGP_NEXT4]], ptr [[ARGS]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARGP_CUR3]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[REF_TMP2]], ptr align 1 [[TMP1]], i64 6, i1 false)
// CHECK-NEXT:    [[X5:%.*]] = getelementptr inbounds nuw [[STRUCT_B]], ptr [[REF_TMP2]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [6 x i8], ptr [[X5]], i64 0, i64 0
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX6]], align 1
// CHECK-NEXT:    [[CONV:%.*]] = sitofp i8 [[TMP2]] to float
// CHECK-NEXT:    store float [[CONV]], ptr [[Y]], align 4
// CHECK-NEXT:    [[ARGP_CUR8:%.*]] = load ptr, ptr [[ARGS]], align 8
// CHECK-NEXT:    [[ARGP_NEXT9:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR8]], i64 8
// CHECK-NEXT:    store ptr [[ARGP_NEXT9]], ptr [[ARGS]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[ARGP_CUR8]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[REF_TMP7]], ptr align 4 [[TMP3]], i64 16, i1 false)
// CHECK-NEXT:    [[X10:%.*]] = getelementptr inbounds nuw [[STRUCT_C]], ptr [[REF_TMP7]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds [4 x float], ptr [[X10]], i64 0, i64 0
// CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[ARRAYIDX11]], align 4
// CHECK-NEXT:    store float [[TMP4]], ptr [[Z]], align 4
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: @g(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca [[STRUCT_A:%.*]], align 4
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_B:%.*]], align 1
// CHECK-NEXT:    [[C:%.*]] = alloca [[STRUCT_C:%.*]], align 4
// CHECK-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_B]], align 1
// CHECK-NEXT:    [[BYVAL_TEMP4:%.*]] = alloca [[STRUCT_C]], align 4
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[A]], i32 0, i32 0
// CHECK-NEXT:    store [2 x float] [[A_COERCE:%.*]], ptr [[COERCE_DIVE]], align 4
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds nuw [[STRUCT_B]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_VAL_II:%.*]] = trunc i64 [[B_COERCE:%.*]] to i48
// CHECK-NEXT:    store i48 [[COERCE_VAL_II]], ptr [[COERCE_DIVE1]], align 1
// CHECK-NEXT:    [[COERCE_DIVE2:%.*]] = getelementptr inbounds nuw [[STRUCT_C]], ptr [[C]], i32 0, i32 0
// CHECK-NEXT:    store [4 x float] [[C_COERCE:%.*]], ptr [[COERCE_DIVE2]], align 4
// CHECK-NEXT:    [[COERCE_DIVE3:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[A]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[COERCE_DIVE3]], align 4
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[BYVAL_TEMP]], ptr align 1 [[B]], i64 6, i1 false)
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[BYVAL_TEMP4]], ptr align 4 [[C]], i64 16, i1 false)
// CHECK-NEXT:    call void (i64, ...) @f(i64 [[TMP0]], ptr noundef dead_on_return [[BYVAL_TEMP]], ptr noundef dead_on_return [[BYVAL_TEMP4]])
// CHECK-NEXT:    ret void
//
