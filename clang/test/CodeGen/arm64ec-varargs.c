// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --check-globals --include-generated-funcs --global-value-regex "f"
// RUN: %clang_cc1 -opaque-pointers -triple arm64ec-windows-msvc -emit-llvm -o - %s | FileCheck %s

typedef struct { float x[2]; } A;
typedef struct { float x[4]; } B;
void f(A a, ...) {
  __builtin_va_list b;
  __builtin_va_start(b, a);
  float x = __builtin_va_arg(b, A).x[0];
  float y = __builtin_va_arg(b, B).x[0];
}
void g(A a, B b) { f(a, b); }

// CHECK-LABEL: @f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca [[STRUCT_A:%.*]], align 4
// CHECK-NEXT:    [[B:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_A]], align 4
// CHECK-NEXT:    [[Y:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[REF_TMP2:%.*]] = alloca [[STRUCT_B:%.*]], align 4
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[A]], i32 0, i32 0
// CHECK-NEXT:    store i64 [[A_COERCE:%.*]], ptr [[COERCE_DIVE]], align 4
// CHECK-NEXT:    call void @llvm.va_start.p0(ptr [[B]])
// CHECK-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i64 8
// CHECK-NEXT:    store ptr [[ARGP_NEXT]], ptr [[B]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[REF_TMP]], ptr align 8 [[ARGP_CUR]], i64 8, i1 false)
// CHECK-NEXT:    [[X1:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[REF_TMP]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x float], ptr [[X1]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    store float [[TMP0]], ptr [[X]], align 4
// CHECK-NEXT:    [[ARGP_CUR3:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[ARGP_NEXT4:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR3]], i64 8
// CHECK-NEXT:    store ptr [[ARGP_NEXT4]], ptr [[B]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARGP_CUR3]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[REF_TMP2]], ptr align 4 [[TMP1]], i64 16, i1 false)
// CHECK-NEXT:    [[X5:%.*]] = getelementptr inbounds nuw [[STRUCT_B]], ptr [[REF_TMP2]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [4 x float], ptr [[X5]], i64 0, i64 0
// CHECK-NEXT:    [[TMP2:%.*]] = load float, ptr [[ARRAYIDX6]], align 4
// CHECK-NEXT:    store float [[TMP2]], ptr [[Y]], align 4
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: @g(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca [[STRUCT_A:%.*]], align 4
// CHECK-NEXT:    [[B:%.*]] = alloca [[STRUCT_B:%.*]], align 4
// CHECK-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_B]], align 4
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[A]], i32 0, i32 0
// CHECK-NEXT:    store [2 x float] [[A_COERCE:%.*]], ptr [[COERCE_DIVE]], align 4
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds nuw [[STRUCT_B]], ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    store [4 x float] [[B_COERCE:%.*]], ptr [[COERCE_DIVE1]], align 4
// CHECK-NEXT:    [[COERCE_DIVE2:%.*]] = getelementptr inbounds nuw [[STRUCT_A]], ptr [[A]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[COERCE_DIVE2]], align 4
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[BYVAL_TEMP]], ptr align 4 [[B]], i64 16, i1 false)
// CHECK-NEXT:    call void (i64, ...) @f(i64 [[TMP0]], ptr dead_on_return noundef [[BYVAL_TEMP]])
// CHECK-NEXT:    ret void
//
