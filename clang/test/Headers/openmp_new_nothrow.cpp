// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2
// RUN: %clang_cc1 -std=c++03 -internal-isystem %S/../../lib/Headers/openmp_wrappers -include __clang_openmp_device_functions.h -internal-isystem %S/Inputs/include -verify -fopenmp -x c++ -triple nvptx64-nvidia-cuda -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm -fopenmp-is-device -o - %s | FileCheck -check-prefixes=CHECK,CXX03 %s
// RUN: %clang_cc1 -std=c++11 -internal-isystem %S/../../lib/Headers/openmp_wrappers -include __clang_openmp_device_functions.h -internal-isystem %S/Inputs/include -verify -fopenmp -x c++ -triple nvptx64-nvidia-cuda -fopenmp-targets=nvptx64-nvidia-cuda -emit-llvm -fopenmp-is-device -o - %s | FileCheck -check-prefixes=CHECK,CXX11 %s


// expected-no-diagnostics

#include <new>

#pragma omp begin declare target
extern const std::nothrow_t nothrow;

// CHECK-LABEL: define hidden noundef ptr @_Z17new_stuff_nothrowv
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = call noalias noundef ptr @_ZnwmRKSt9nothrow_t(i64 noundef 4, ptr noundef nonnull align 1 dereferenceable(1) @nothrow) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    ret ptr [[CALL]]
//
int* new_stuff_nothrow() {
  return new (nothrow) int;
}

// CXX03-LABEL: define hidden noundef ptr @_Z23new_array_stuff_nothrowv
// CXX03-SAME: () #[[ATTR0]] {
// CXX03-NEXT:  entry:
// CXX03-NEXT:    [[CALL:%.*]] = call noalias noundef ptr @_ZnamRKSt9nothrow_t(i64 noundef 136, ptr noundef nonnull align 1 dereferenceable(1) @nothrow) #[[ATTR4]]
// CXX03-NEXT:    ret ptr [[CALL]]
//
// CXX11-LABEL: define hidden noundef ptr @_Z23new_array_stuff_nothrowv
// CXX11-SAME: () #[[ATTR0]] {
// CXX11-NEXT:  entry:
// CXX11-NEXT:    [[CALL:%.*]] = call noalias noundef ptr @_ZnamRKSt9nothrow_t(i64 noundef 136, ptr noundef nonnull align 1 dereferenceable(1) @nothrow) #[[ATTR7:[0-9]+]]
// CXX11-NEXT:    ret ptr [[CALL]]
//
int* new_array_stuff_nothrow() {
  return new (nothrow) int[34];
}

// CXX03-LABEL: define hidden void @_Z20delete_stuff_nothrowPi
// CXX03-SAME: (ptr noundef [[PTR:%.*]]) #[[ATTR0]] {
// CXX03-NEXT:  entry:
// CXX03-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 8
// CXX03-NEXT:    store ptr [[PTR]], ptr [[PTR_ADDR]], align 8
// CXX03-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PTR_ADDR]], align 8
// CXX03-NEXT:    call void @_ZdlPvRKSt9nothrow_t(ptr noundef [[TMP0]], ptr noundef nonnull align 1 dereferenceable(1) @nothrow) #[[ATTR6:[0-9]+]]
// CXX03-NEXT:    ret void
//
// CXX11-LABEL: define hidden void @_Z20delete_stuff_nothrowPi
// CXX11-SAME: (ptr noundef [[PTR:%.*]]) #[[ATTR0]] {
// CXX11-NEXT:  entry:
// CXX11-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 8
// CXX11-NEXT:    store ptr [[PTR]], ptr [[PTR_ADDR]], align 8
// CXX11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PTR_ADDR]], align 8
// CXX11-NEXT:    call void @_ZdlPvRKSt9nothrow_t(ptr noundef [[TMP0]], ptr noundef nonnull align 1 dereferenceable(1) @nothrow) #[[ATTR8:[0-9]+]]
// CXX11-NEXT:    ret void
//
void delete_stuff_nothrow(int* ptr) {
  operator delete(ptr, nothrow);
}

// CXX03-LABEL: define hidden void @_Z26delete_array_stuff_nothrowPi
// CXX03-SAME: (ptr noundef [[PTR:%.*]]) #[[ATTR0]] {
// CXX03-NEXT:  entry:
// CXX03-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 8
// CXX03-NEXT:    store ptr [[PTR]], ptr [[PTR_ADDR]], align 8
// CXX03-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PTR_ADDR]], align 8
// CXX03-NEXT:    call void @_ZdaPvRKSt9nothrow_t(ptr noundef [[TMP0]], ptr noundef nonnull align 1 dereferenceable(1) @nothrow) #[[ATTR6]]
// CXX03-NEXT:    ret void
//
// CXX11-LABEL: define hidden void @_Z26delete_array_stuff_nothrowPi
// CXX11-SAME: (ptr noundef [[PTR:%.*]]) #[[ATTR0]] {
// CXX11-NEXT:  entry:
// CXX11-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 8
// CXX11-NEXT:    store ptr [[PTR]], ptr [[PTR_ADDR]], align 8
// CXX11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PTR_ADDR]], align 8
// CXX11-NEXT:    call void @_ZdaPvRKSt9nothrow_t(ptr noundef [[TMP0]], ptr noundef nonnull align 1 dereferenceable(1) @nothrow) #[[ATTR8]]
// CXX11-NEXT:    ret void
//
void delete_array_stuff_nothrow(int* ptr) {
  operator delete[](ptr, nothrow);
}

#pragma omp end declare target
