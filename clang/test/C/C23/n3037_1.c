// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -std=c23 -emit-llvm -o - %s | FileCheck %s

// This tests the codegen behavior of redefined tag types to ensure the
// generated code looks reasonable.

enum E {
  One = 1,
  Zero = 0,
  Two = 2
};

struct S {
  int x;
  int y;
};

struct S func(struct S s, enum E e);

struct S {
  int x, y;
} what();

// CHECK-LABEL: define dso_local i64 @func(
// CHECK-SAME: i64 [[S_COERCE:%.*]], i32 noundef [[E:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_S:%.*]], align 4
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S]], align 4
// CHECK-NEXT:    [[E_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i64 [[S_COERCE]], ptr [[S]], align 4
// CHECK-NEXT:    store i32 [[E]], ptr [[E_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[E_ADDR]], align 4
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds nuw [[STRUCT_S]], ptr [[S]], i32 0, i32 0
// CHECK-NEXT:    store i32 [[TMP0]], ptr [[X]], align 4
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[RETVAL]], ptr align 4 [[S]], i64 8, i1 false)
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i64 [[TMP1]]
//
struct S func(struct S s, enum E e) {
  s.x = (int)e;
  return s;
}

enum E {
  Zero,
  One,
  Two
};
