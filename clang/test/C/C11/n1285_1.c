// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -std=c99 -Wno-dangling -emit-llvm -o - %s | FileCheck %s --check-prefix=C99
// RUN: %clang_cc1 -std=c11 -Wno-dangling -emit-llvm -o - %s | FileCheck %s --check-prefix=C11

// Ensure that codegen for temporary lifetimes makes sense.

struct X { int a[5]; };
struct X f(void);

// C99-LABEL: define dso_local i32 @func_return(
// C99-SAME: ) #[[ATTR0:[0-9]+]] {
// C99-NEXT:  [[ENTRY:.*:]]
// C99-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C99-NEXT:    [[TMP:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C99-NEXT:    call void @f(ptr dead_on_unwind writable sret([[STRUCT_X]]) align 4 [[TMP]])
// C99-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[TMP]], i32 0, i32 0
// C99-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C99-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C99-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C99-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C99-NEXT:    ret i32 [[TMP1]]
//
// C11-LABEL: define dso_local i32 @func_return(
// C11-SAME: ) #[[ATTR0:[0-9]+]] {
// C11-NEXT:  [[ENTRY:.*:]]
// C11-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C11-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C11-NEXT:    call void @f(ptr dead_on_unwind writable sret([[STRUCT_X]]) align 4 [[REF_TMP]])
// C11-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[REF_TMP]], i32 0, i32 0
// C11-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C11-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C11-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C11-NEXT:    ret i32 [[TMP1]]
//
int func_return(void) {
  int *p = f().a;
  return *p;
}

// C99-LABEL: define dso_local i32 @ternary(
// C99-SAME: ) #[[ATTR0]] {
// C99-NEXT:  [[ENTRY:.*:]]
// C99-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C99-NEXT:    [[TMP:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C99-NEXT:    [[Q:%.*]] = alloca ptr, align 8
// C99-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[STRUCT_X]], align 4
// C99-NEXT:    br i1 true, label %[[COND_TRUE:.*]], label %[[COND_FALSE:.*]]
// C99:       [[COND_TRUE]]:
// C99-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[TMP]], i8 0, i64 20, i1 false)
// C99-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[TMP]], i32 0, i32 0
// C99-NEXT:    br label %[[COND_END:.*]]
// C99:       [[COND_FALSE]]:
// C99-NEXT:    call void @f(ptr dead_on_unwind writable sret([[STRUCT_X]]) align 4 [[TMP]])
// C99-NEXT:    br label %[[COND_END]]
// C99:       [[COND_END]]:
// C99-NEXT:    [[A1:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[TMP]], i32 0, i32 0
// C99-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A1]], i64 0, i64 0
// C99-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C99-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[DOTCOMPOUNDLITERAL]], i8 0, i64 20, i1 false)
// C99-NEXT:    [[A2:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// C99-NEXT:    [[A3:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// C99-NEXT:    [[ARRAYDECAY4:%.*]] = getelementptr inbounds [5 x i32], ptr [[A3]], i64 0, i64 0
// C99-NEXT:    store ptr [[ARRAYDECAY4]], ptr [[Q]], align 8
// C99-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C99-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C99-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[Q]], align 8
// C99-NEXT:    [[TMP3:%.*]] = load i32, ptr [[TMP2]], align 4
// C99-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], [[TMP3]]
// C99-NEXT:    ret i32 [[ADD]]
//
// C11-LABEL: define dso_local i32 @ternary(
// C11-SAME: ) #[[ATTR0]] {
// C11-NEXT:  [[ENTRY:.*:]]
// C11-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C11-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C11-NEXT:    [[Q:%.*]] = alloca ptr, align 8
// C11-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[STRUCT_X]], align 4
// C11-NEXT:    br i1 true, label %[[COND_TRUE:.*]], label %[[COND_FALSE:.*]]
// C11:       [[COND_TRUE]]:
// C11-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[REF_TMP]], i8 0, i64 20, i1 false)
// C11-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[REF_TMP]], i32 0, i32 0
// C11-NEXT:    br label %[[COND_END:.*]]
// C11:       [[COND_FALSE]]:
// C11-NEXT:    call void @f(ptr dead_on_unwind writable sret([[STRUCT_X]]) align 4 [[REF_TMP]])
// C11-NEXT:    br label %[[COND_END]]
// C11:       [[COND_END]]:
// C11-NEXT:    [[A1:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[REF_TMP]], i32 0, i32 0
// C11-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A1]], i64 0, i64 0
// C11-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C11-NEXT:    call void @llvm.memset.p0.i64(ptr align 4 [[DOTCOMPOUNDLITERAL]], i8 0, i64 20, i1 false)
// C11-NEXT:    [[A2:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// C11-NEXT:    [[A3:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// C11-NEXT:    [[ARRAYDECAY4:%.*]] = getelementptr inbounds [5 x i32], ptr [[A3]], i64 0, i64 0
// C11-NEXT:    store ptr [[ARRAYDECAY4]], ptr [[Q]], align 8
// C11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C11-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C11-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[Q]], align 8
// C11-NEXT:    [[TMP3:%.*]] = load i32, ptr [[TMP2]], align 4
// C11-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], [[TMP3]]
// C11-NEXT:    ret i32 [[ADD]]
//
int ternary(void) {
  int *p;
  p = (1 ? (struct X){ 0 } : f()).a;
  int *q = 1 ? (struct X){ 0 }.a : f().a;

  return *p + *q;
}

// C99-LABEL: define dso_local i32 @comma(
// C99-SAME: ) #[[ATTR0]] {
// C99-NEXT:  [[ENTRY:.*:]]
// C99-NEXT:    [[X:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C99-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C99-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[X]], i32 0, i32 0
// C99-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C99-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C99-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C99-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C99-NEXT:    ret i32 [[TMP1]]
//
// C11-LABEL: define dso_local i32 @comma(
// C11-SAME: ) #[[ATTR0]] {
// C11-NEXT:  [[ENTRY:.*:]]
// C11-NEXT:    [[X:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C11-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C11-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_X]], align 4
// C11-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[REF_TMP]], ptr align 4 [[X]], i64 20, i1 false)
// C11-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[REF_TMP]], i32 0, i32 0
// C11-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C11-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C11-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C11-NEXT:    ret i32 [[TMP1]]
//
int comma(void) {
  struct X x;
  int *p = ((void)0, x).a;
  return *p;
}

// C99-LABEL: define dso_local i32 @cast(
// C99-SAME: ) #[[ATTR0]] {
// C99-NEXT:  [[ENTRY:.*:]]
// C99-NEXT:    [[X:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C99-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C99-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[X]], i32 0, i32 0
// C99-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C99-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C99-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C99-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C99-NEXT:    ret i32 [[TMP1]]
//
// C11-LABEL: define dso_local i32 @cast(
// C11-SAME: ) #[[ATTR0]] {
// C11-NEXT:  [[ENTRY:.*:]]
// C11-NEXT:    [[X:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C11-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C11-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_X]], align 4
// C11-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[REF_TMP]], ptr align 4 [[X]], i64 20, i1 false)
// C11-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[REF_TMP]], i32 0, i32 0
// C11-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C11-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C11-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C11-NEXT:    ret i32 [[TMP1]]
//
int cast(void) {
  struct X x;
  int *p;
  p = ((struct X)x).a;
  return *p;
}

// C99-LABEL: define dso_local i32 @assign(
// C99-SAME: ) #[[ATTR0]] {
// C99-NEXT:  [[ENTRY:.*:]]
// C99-NEXT:    [[X:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C99-NEXT:    [[S:%.*]] = alloca [[STRUCT_X]], align 4
// C99-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C99-NEXT:    [[TMP:%.*]] = alloca [[STRUCT_X]], align 4
// C99-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[X]], ptr align 4 [[S]], i64 20, i1 false)
// C99-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[TMP]], ptr align 4 [[X]], i64 20, i1 false)
// C99-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[TMP]], i32 0, i32 0
// C99-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C99-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C99-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C99-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C99-NEXT:    ret i32 [[TMP1]]
//
// C11-LABEL: define dso_local i32 @assign(
// C11-SAME: ) #[[ATTR0]] {
// C11-NEXT:  [[ENTRY:.*:]]
// C11-NEXT:    [[X:%.*]] = alloca [[STRUCT_X:%.*]], align 4
// C11-NEXT:    [[S:%.*]] = alloca [[STRUCT_X]], align 4
// C11-NEXT:    [[P:%.*]] = alloca ptr, align 8
// C11-NEXT:    [[REF_TMP:%.*]] = alloca [[STRUCT_X]], align 4
// C11-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[X]], ptr align 4 [[S]], i64 20, i1 false)
// C11-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[REF_TMP]], ptr align 4 [[X]], i64 20, i1 false)
// C11-NEXT:    [[A:%.*]] = getelementptr inbounds nuw [[STRUCT_X]], ptr [[REF_TMP]], i32 0, i32 0
// C11-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [5 x i32], ptr [[A]], i64 0, i64 0
// C11-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// C11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// C11-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// C11-NEXT:    ret i32 [[TMP1]]
//
int assign(void) {
  struct X x, s;
  int *p = (x = s).a;
  return *p;
}
