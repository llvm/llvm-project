// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -I%S -triple x86_64-unknown-linux -flto -fwhole-program-vtables -fvisibility=hidden -emit-llvm -o - %s | FileCheck %s

#include <typeinfo>

namespace Test1 {
struct A { virtual void f(); };

// CHECK-LABEL: define hidden noundef nonnull align 8 dereferenceable(16) ptr @_ZN5Test19gettypeidEPNS_1AE(
// CHECK-SAME: ptr noundef [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[TMP0]], null
// CHECK-NEXT:    br i1 [[TMP1]], label %[[TYPEID_BAD_TYPEID:.*]], label %[[TYPEID_END:.*]]
// CHECK:       [[TYPEID_BAD_TYPEID]]:
// CHECK-NEXT:    call void @__cxa_bad_typeid() #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    unreachable
// CHECK:       [[TYPEID_END]]:
// CHECK-NEXT:    [[VTABLE:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = call i1 @llvm.type.test(ptr [[VTABLE]], metadata !"_ZTSN5Test11AE")
// CHECK-NEXT:    call void @llvm.assume(i1 [[TMP2]])
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds ptr, ptr [[VTABLE]], i64 -1
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[TMP3]], align 8
// CHECK-NEXT:    ret ptr [[TMP4]]
//
const std::type_info &gettypeid(A *a) {
  return typeid(*a);
}

}
