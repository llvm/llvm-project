// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -std=c++20 -triple=x86_64-linux-gnu -emit-llvm -o - %s | FileCheck %s


struct Empty {};

// CHECK-LABEL: define dso_local void @_Z9testEmptyP5Empty(
// CHECK-SAME: ptr noundef [[E:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[E_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[E]], ptr [[E_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[E_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 0
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    ret void
//
void testEmpty(Empty *e) {
  // This should clear the one byte that Emtpy occupies.
  __builtin_clear_padding(e);
}


// CHECK-LABEL: define dso_local void @_Z22testPrimitiveNoPaddingPi(
// CHECK-SAME: ptr noundef [[I:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[I]], ptr [[I_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[I_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void testPrimitiveNoPadding(int *i) {
  // This should not clear any padding, since int has no padding.
  __builtin_clear_padding(i);
}


// CHECK-LABEL: define dso_local void @_Z23testPrimitiveLongDoublePe(
// CHECK-SAME: ptr noundef [[LD:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[LD_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[LD]], ptr [[LD_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[LD_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 10
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 11
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 12
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 13
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    ret void
//
void testPrimitiveLongDouble(long double *ld) {
  // padding [10, 15] on x86
  __builtin_clear_padding(ld);
}


// CHECK-LABEL: define dso_local void @_Z30testPrimitiveComplexLongDoublePCe(
// CHECK-SAME: ptr noundef [[C:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[C_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 10
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 11
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 12
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 13
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[TMP0]], i32 26
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[TMP0]], i32 27
// CHECK-NEXT:    store i8 0, ptr [[TMP8]], align 1
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[TMP0]], i32 28
// CHECK-NEXT:    store i8 0, ptr [[TMP9]], align 1
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[TMP0]], i32 29
// CHECK-NEXT:    store i8 0, ptr [[TMP10]], align 1
// CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr [[TMP0]], i32 30
// CHECK-NEXT:    store i8 0, ptr [[TMP11]], align 1
// CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[TMP0]], i32 31
// CHECK-NEXT:    store i8 0, ptr [[TMP12]], align 1
// CHECK-NEXT:    ret void
//
void testPrimitiveComplexLongDouble(_Complex long double *c) {
  // padding [10, 15] and [26, 31] on x86
  __builtin_clear_padding(c);
}

union U1 {
  int i;
  char c;
};

// CHECK-LABEL: define dso_local void @_Z24testUnionDifferentLengthP2U1(
// CHECK-SAME: ptr noundef [[U:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[U_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[U]], ptr [[U_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[U_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void testUnionDifferentLength(U1 *u) {
  // This should not clear the object representation bits of the non-active member.
  __builtin_clear_padding(u);
}


struct S {
  alignas(8) char c1;
};

union U2 {
  S s1;
  char c2;
};

// CHECK-LABEL: define dso_local void @_Z35testUnionTailPaddingOfLongestMemberP2U2(
// CHECK-SAME: ptr noundef [[U:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[U_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[U]], ptr [[U_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[U_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 1
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 2
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 3
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 4
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    ret void
//
void testUnionTailPaddingOfLongestMember(U2 *u) {
  // This should clear the tail padding of the longest member.
  // [1 - 7]
  __builtin_clear_padding(u);
}


struct alignas(4) Foo {
  char a;
  alignas(2) char b;
};

struct alignas(4) Bar {
  char c;
  alignas(2) char d;
};

struct alignas(4) Baz : Foo {
  char e;
  Bar f;
};

// Baz structure:
// "a", PAD_1, "b", PAD_2, "c", PAD_3, PAD_4, PAD_5, "c", PAD_6, "d", PAD_7
// %struct.Baz = type { %struct.Foo, i8, [3 x i8], %struct.Bar }
// %struct.Foo = type { i8, i8, i8, i8 }
// %struct.Bar = type { i8, i8, i8, i8 }

// CHECK-LABEL: define dso_local void @_Z33testStructPaddingInBetweenMembersP3Baz(
// CHECK-SAME: ptr noundef [[BAZ:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[BAZ_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[BAZ]], ptr [[BAZ_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[BAZ_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 1
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 3
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 9
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[TMP0]], i32 11
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    ret void
//
void testStructPaddingInBetweenMembers(Baz *baz) {
  // this should clear all the padding in between various members
  __builtin_clear_padding(baz);
}

// CHECK-LABEL: define dso_local void @_Z18testStructVolatilePV3Baz(
// CHECK-SAME: ptr noundef [[BAZ:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[BAZ_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[BAZ]], ptr [[BAZ_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[BAZ_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 1
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 3
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 9
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[TMP0]], i32 11
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    ret void
//
void testStructVolatile(volatile Baz *baz) {
  // this should clear all the padding in between various members
  __builtin_clear_padding(baz);
}

struct UnsizedTail {
  int size;
  alignas(8) char buf[];

  UnsizedTail(int size) : size(size) {}
};

// UnsizedTail structure:
// "size", PAD_1, PAD_2, PAD_3, PAD_4
// %struct.UnsizedTail = type { i32, [4 x i8], [0 x i8] }

// CHECK-LABEL: define dso_local void @_Z21testStructUnsizedTailP11UnsizedTail(
// CHECK-SAME: ptr noundef [[U:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[U_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[U]], ptr [[U_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[U_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 4
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    ret void
//
void testStructUnsizedTail(UnsizedTail *u) {
  __builtin_clear_padding(u);
}

class S1 {
  int x;
  char c;
};

class S2 {
  [[no_unique_address]] S1 s1;
  bool b;
};

// CHECK-LABEL: define dso_local void @_Z19testNoUniqueAddressP2S2(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    ret void
//
void testNoUniqueAddress(S2 *s) {
  // "x [0-3]",  "c" , "b", PAD [6-7]
  __builtin_clear_padding(s);
}

struct S3 {
  long double l;
  bool b;
};

// CHECK-LABEL: define dso_local void @_Z24testStructWithLongDoubleP2S3(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 10
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 11
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 12
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 13
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[TMP0]], i32 17
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[TMP0]], i32 18
// CHECK-NEXT:    store i8 0, ptr [[TMP8]], align 1
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[TMP0]], i32 19
// CHECK-NEXT:    store i8 0, ptr [[TMP9]], align 1
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[TMP0]], i32 20
// CHECK-NEXT:    store i8 0, ptr [[TMP10]], align 1
// CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr [[TMP0]], i32 21
// CHECK-NEXT:    store i8 0, ptr [[TMP11]], align 1
// CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[TMP0]], i32 22
// CHECK-NEXT:    store i8 0, ptr [[TMP12]], align 1
// CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, ptr [[TMP0]], i32 23
// CHECK-NEXT:    store i8 0, ptr [[TMP13]], align 1
// CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i8, ptr [[TMP0]], i32 24
// CHECK-NEXT:    store i8 0, ptr [[TMP14]], align 1
// CHECK-NEXT:    [[TMP15:%.*]] = getelementptr i8, ptr [[TMP0]], i32 25
// CHECK-NEXT:    store i8 0, ptr [[TMP15]], align 1
// CHECK-NEXT:    [[TMP16:%.*]] = getelementptr i8, ptr [[TMP0]], i32 26
// CHECK-NEXT:    store i8 0, ptr [[TMP16]], align 1
// CHECK-NEXT:    [[TMP17:%.*]] = getelementptr i8, ptr [[TMP0]], i32 27
// CHECK-NEXT:    store i8 0, ptr [[TMP17]], align 1
// CHECK-NEXT:    [[TMP18:%.*]] = getelementptr i8, ptr [[TMP0]], i32 28
// CHECK-NEXT:    store i8 0, ptr [[TMP18]], align 1
// CHECK-NEXT:    [[TMP19:%.*]] = getelementptr i8, ptr [[TMP0]], i32 29
// CHECK-NEXT:    store i8 0, ptr [[TMP19]], align 1
// CHECK-NEXT:    [[TMP20:%.*]] = getelementptr i8, ptr [[TMP0]], i32 30
// CHECK-NEXT:    store i8 0, ptr [[TMP20]], align 1
// CHECK-NEXT:    [[TMP21:%.*]] = getelementptr i8, ptr [[TMP0]], i32 31
// CHECK-NEXT:    store i8 0, ptr [[TMP21]], align 1
// CHECK-NEXT:    ret void
//
void testStructWithLongDouble(S3 *s) {
  // "long double data[0-9]", PAD [10-15], "b", PAD [17-31]
  __builtin_clear_padding(s);
}

struct B {
  int i;
};
struct S4 : Empty, B {
  bool b;
};

// CHECK-LABEL: define dso_local void @_Z23testStructWithEmptyBaseP2S4(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    ret void
//
void testStructWithEmptyBase(S4 *s) {
  // "i" [0-3], "b" [4], PAD [5-7]
  __builtin_clear_padding(s);
}

struct B1 {
  char c1;
};
struct B2 {
  alignas(4) char c2;
};
struct S5 : B1, B2 {
};

// CHECK-LABEL: define dso_local void @_Z23testPaddingBetweenBasesP2S5(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 1
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 2
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 3
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    ret void
//
void testPaddingBetweenBases(S5 *s) {
  // "c1" [0], PAD [1-3] , "c2" [4], PAD [5-7]
  __builtin_clear_padding(s);
}

struct B3 {
  char c1;
};

struct B4 {
  char c2;
};

struct S6 : B3, B4 {
  alignas(4) char c3;
};

// CHECK-LABEL: define dso_local void @_Z24testPaddingAfterLastBaseP2S6(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 2
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 3
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    ret void
//
void testPaddingAfterLastBase(S6 *s) {
  // "c1"[0], "c2"[1], PAD [2-3], "c3" [4], PAD [5-7]
  __builtin_clear_padding(s);
}


struct VirtualBase {
  unsigned int x;
  virtual int call() { return x; };
  virtual ~VirtualBase() = default;
};

struct NonVirtualBase {
  char y;
};

struct S7 : VirtualBase, NonVirtualBase {
  virtual int call() override { return 5; }
  bool z;
};

// CHECK-LABEL: define dso_local void @_Z10testVtableP2S7(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    ret void
//
void testVtable(S7 *s) {
  // "vtable ptr" [0-7], "x" [8-11], "y" [12], "z" [13], PAD [14-15]
  __builtin_clear_padding(s);
}

struct VirtualBase1 {
  unsigned int x1;
  virtual int call1() { return x1; };
  virtual ~VirtualBase1() = default;
};

struct VirtualBase2 {
  unsigned int x2;
  virtual int call2() { return x2; };
  virtual ~VirtualBase2() = default;
};

struct VirtualBase3 {
  unsigned int x3;
  virtual int call3() { return x3; };
  virtual ~VirtualBase3() = default;
};

struct NonVirtualBase1 {
  char y;
};
struct S8 : VirtualBase1, VirtualBase2, NonVirtualBase1, VirtualBase3 {
  virtual int call1() override { return 5; }
  bool z;
};

// CHECK-LABEL: define dso_local void @_Z23testMultipleBasesVtableP2S8(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 12
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 13
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 29
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 30
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[TMP0]], i32 31
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[TMP0]], i32 45
// CHECK-NEXT:    store i8 0, ptr [[TMP8]], align 1
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[TMP0]], i32 46
// CHECK-NEXT:    store i8 0, ptr [[TMP9]], align 1
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[TMP0]], i32 47
// CHECK-NEXT:    store i8 0, ptr [[TMP10]], align 1
// CHECK-NEXT:    ret void
//
void testMultipleBasesVtable(S8 *s) {
  // "vtable ptr" [0-7], "x1" [8-11], PAD "[12-15]",
  // "vtable ptr" [16-23], "x2" [24-27], "y" [28], PAD "[29-31]",
  // "vtable_ptr" [32-39], "x3" [40-43], "z" [44], PAD [45-47]
  __builtin_clear_padding(s);
}

struct VirtualChain1 {
  unsigned int x1;
  virtual int call1() { return x1; };
  virtual ~VirtualChain1() = default;
};

struct VirtualChain2 : VirtualChain1 {
  unsigned int x2;
  virtual int call2() { return x2; };
  virtual ~VirtualChain2() = default;
};

struct VirtualChain3 : VirtualChain2 {
  unsigned int x3;
  virtual int call3() { return x3; };
  virtual ~VirtualChain3() = default;
};

struct NonVirtualBase2 {
  char y;
};

struct S9 : NonVirtualBase2, VirtualChain3 {
  bool z;
};

// CHECK-LABEL: define dso_local void @_Z16testVirtualChainP2S9(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 22
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 23
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    ret void
//
void testVirtualChain(S9 *s) {
  // This should clear the padding after the bool z.
  // base reordered
  // "vtable ptr" [0-7],  "x1" [8-11], x2 [12-15], x3 [16-19],
  // y [20], z [21], PAD [22-23]
  __builtin_clear_padding(s);
}


struct Base {
  int x;
};

struct D1 : virtual Base {
  int d1;
  bool b1;
};
struct D2 : virtual Base {
  int d2;
  bool b2;
};

struct S10 : D1, D2 {
  bool s;
};

// CHECK-LABEL: define dso_local void @_Z22testVirtualInheritanceP3S10(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 13
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 30
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[TMP0]], i32 31
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[TMP0]], i32 36
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[TMP0]], i32 37
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[TMP0]], i32 38
// CHECK-NEXT:    store i8 0, ptr [[TMP8]], align 1
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[TMP0]], i32 39
// CHECK-NEXT:    store i8 0, ptr [[TMP9]], align 1
// CHECK-NEXT:    ret void
//
void testVirtualInheritance(S10 *s) {
  // note derived member placed before the virtual base
  // "vtable ptr" [0-7],  "d1" [8-11], "b1" [12], PAD [13-15],
  // "vtable ptr" [16-23],  "d2" [24-27], "b2" [28], s [29],  PAD [30-31],
  // "x" [32-35], PAD [36-39]
  __builtin_clear_padding(s);
}

struct S11 {
  // will usually occupy 2 bytes:
  unsigned char b1 : 3; // 1st 3 bits (in 1st byte) are b1
  unsigned char b2 : 2; // next 2 bits (in 1st byte). The rest bits in byte 1 are unused
  unsigned char b3 : 6; // 6 bits for b3 - doesn't fit into the 1st byte => starts a 2nd
  unsigned char b4 : 2; // 2 bits for b4 - next (and final) bits in the 2nd byte
};

// CHECK-LABEL: define dso_local void @_Z13testBitFieldsP3S11(
// CHECK-SAME: ptr noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[S_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 0
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = and i8 [[TMP2]], 31
// CHECK-NEXT:    store i8 [[TMP3]], ptr [[TMP1]], align 1
// CHECK-NEXT:    ret void
//
void testBitFields(S11 *s) {
  // "b1" [0-2], "b2" [3-4], PAD [5-7], "b3" [8-13], "b4" [14-15]
  // to clear 5-7, we should AND 0b00011111 (31)
  __builtin_clear_padding(s);
}


// CHECK-LABEL: define dso_local void @_Z18testArrayNoPaddingv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[I:%.*]] = alloca [4 x i32], align 16
// CHECK-NEXT:    ret void
//
void testArrayNoPadding() {
  int i[4];
  // there is no padding in the array.
  __builtin_clear_padding(&i);
}

// CHECK-LABEL: define dso_local void @_Z19testArrayLongDoubleRA2_e(
// CHECK-SAME: ptr noundef nonnull align 16 dereferenceable(32) [[ARR:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARR_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[LD:%.*]] = alloca [2 x x86_fp80], align 16
// CHECK-NEXT:    store ptr [[ARR]], ptr [[ARR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[LD]], i32 10
// CHECK-NEXT:    store i8 0, ptr [[TMP0]], align 1
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[LD]], i32 11
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[LD]], i32 12
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[LD]], i32 13
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[LD]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[LD]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[LD]], i32 26
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[LD]], i32 27
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[LD]], i32 28
// CHECK-NEXT:    store i8 0, ptr [[TMP8]], align 1
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[LD]], i32 29
// CHECK-NEXT:    store i8 0, ptr [[TMP9]], align 1
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[LD]], i32 30
// CHECK-NEXT:    store i8 0, ptr [[TMP10]], align 1
// CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr [[LD]], i32 31
// CHECK-NEXT:    store i8 0, ptr [[TMP11]], align 1
// CHECK-NEXT:    ret void
//
void testArrayLongDouble(long double (&arr)[2]) {
  // long double 0, [0-9] PAD [10-15]
  // long double 1, [16-25] PAD [26-31]
  long double ld[2];
  __builtin_clear_padding(&ld);
}

// CHECK-LABEL: define dso_local void @_Z17testArrayOfStructv(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[S:%.*]] = alloca [2 x %struct.S.0], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[S]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP0]], align 1
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[S]], i32 6
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[S]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[S]], i32 13
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[S]], i32 14
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[S]], i32 15
// CHECK-NEXT:    store i8 0, ptr [[TMP5]], align 1
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[S]], i32 21
// CHECK-NEXT:    store i8 0, ptr [[TMP6]], align 1
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr [[S]], i32 22
// CHECK-NEXT:    store i8 0, ptr [[TMP7]], align 1
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr [[S]], i32 23
// CHECK-NEXT:    store i8 0, ptr [[TMP8]], align 1
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[S]], i32 29
// CHECK-NEXT:    store i8 0, ptr [[TMP9]], align 1
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, ptr [[S]], i32 30
// CHECK-NEXT:    store i8 0, ptr [[TMP10]], align 1
// CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr [[S]], i32 31
// CHECK-NEXT:    store i8 0, ptr [[TMP11]], align 1
// CHECK-NEXT:    ret void
//
void testArrayOfStruct() {
  struct S {
    int i1;
    char c1;
    int i2;
    char c2;
  };

  // S[0].i1 [0-3], S[0].c1 [4], PAD [5-7],
  // S[0].i2 [8-11], S[0].c2 [12], PAD [13-15],
  // S[1].i1 [16-19], S[1].c1 [20], PAD [21-23],
  // S[1].i2 [24-27], S[1].c2 [28], PAD [29-31]

  S s[2];
  __builtin_clear_padding(&s);
}

struct ArrOfStructsWithPadding {
  Bar bars[2];
};

// ArrOfStructsWithPadding structure:
// "c" (1), PAD_1, "d" (1), PAD_2, "c" (2), PAD_3, "d" (2), PAD_4
// %struct.ArrOfStructsWithPadding = type { [2 x %struct.Bar] }

// CHECK-LABEL: define dso_local void @_Z27testArrOfStructsWithPaddingP23ArrOfStructsWithPadding(
// CHECK-SAME: ptr noundef [[ARR:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARR_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[ARR]], ptr [[ARR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[TMP0]], i32 1
// CHECK-NEXT:    store i8 0, ptr [[TMP1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP0]], i32 3
// CHECK-NEXT:    store i8 0, ptr [[TMP2]], align 1
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[TMP0]], i32 5
// CHECK-NEXT:    store i8 0, ptr [[TMP3]], align 1
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[TMP0]], i32 7
// CHECK-NEXT:    store i8 0, ptr [[TMP4]], align 1
// CHECK-NEXT:    ret void
//
void testArrOfStructsWithPadding(ArrOfStructsWithPadding *arr) {
  __builtin_clear_padding(arr);
}
