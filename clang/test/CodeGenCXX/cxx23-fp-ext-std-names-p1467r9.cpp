// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %clang_cc1 -std=c++23 -triple x86_64-unknown-unknown -target-feature +fullbf16 -emit-llvm %s -o - | FileCheck %s  --check-prefix=CHECK

// CHECK-LABEL: define {{[^@]+}}@_Z1fDF16b
// CHECK-SAME: (bfloat noundef [[V:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK:         [[V_ADDR:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    store bfloat [[V]], ptr [[V_ADDR]], align 2
// CHECK-NEXT:    ret i32 1
//
int f(decltype(0.BF16) v) { return 1; }
// CHECK-LABEL: define {{[^@]+}}@_Z1fDF16_
// CHECK-SAME: (half noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK:         [[V_ADDR:%.*]] = alloca half, align 2
// CHECK-NEXT:    store half [[V]], ptr [[V_ADDR]], align 2
// CHECK-NEXT:    ret i32 1
//
int f(_Float16 v) { return 1; }
// CHECK-LABEL: define {{[^@]+}}@_Z1ff
// CHECK-SAME: (float noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK:         [[V_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[V]], ptr [[V_ADDR]], align 4
// CHECK-NEXT:    ret i32 1
//
int f(float v) { return 1; }
// CHECK-LABEL: define {{[^@]+}}@_Z1fd
// CHECK-SAME: (double noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK:         [[V_ADDR:%.*]] = alloca double, align 8
// CHECK-NEXT:    store double [[V]], ptr [[V_ADDR]], align 8
// CHECK-NEXT:    ret i32 1
//
int f(double v) { return 1; }
// CHECK-LABEL: define {{[^@]+}}@_Z1fe
// CHECK-SAME: (x86_fp80 noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK:         [[V_ADDR:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    store x86_fp80 [[V]], ptr [[V_ADDR]], align 16
// CHECK-NEXT:    ret i32 1
//
int f(long double v) { return 1; }
// CHECK-LABEL: define {{[^@]+}}@_Z1fi
// CHECK-SAME: (i32 noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK:         [[V_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[V]], ptr [[V_ADDR]], align 4
// CHECK-NEXT:    ret i32 1
//
int f(int v) { return 1; }

// CHECK-LABEL: define {{[^@]+}}@_Z3f_2e
// CHECK-SAME: (x86_fp80 noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK:         [[V_ADDR:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    store x86_fp80 [[V]], ptr [[V_ADDR]], align 16
// CHECK-NEXT:    ret i32 1
//
int f_2(long double v) { return 1; }

struct S {

    operator decltype(0.BF16)() const {
        return 0.0bf16;
    }

    operator _Float16() const {
        return 0.0f16;
    }

    operator float() const {
        return 0.0f;
    }

    operator double() const {
        return 0.0;
    }

    operator long double() const {
        return 0.0L;
    }

    operator int() const {
        return 0;
    }
};

struct S1 {
    operator _Float16() const {
        return 0.0f16;
    }
    operator float() const {
        return 0.0f;
    }
    operator double() const {
        return 0.0;
    }
    operator long double() const {
        return 0.0L;
    }

    operator int() const {
        return 0;
    }
};

// CHECK-LABEL: define {{[^@]+}}@_Z5test1v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[F16_VAL_6:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_VAL_8:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_VAL_9:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_VAL_10:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_VAL_11:%.*]] = alloca half, align 2
// CHECK-NEXT:    store half 0xH3C00, ptr [[F16_VAL_6]], align 2
// CHECK-NEXT:    store half 0xH3C00, ptr [[F16_VAL_8]], align 2
// CHECK-NEXT:    store half 0xH3C00, ptr [[F16_VAL_9]], align 2
// CHECK-NEXT:    store half 0xH3C00, ptr [[F16_VAL_10]], align 2
// CHECK-NEXT:    store half 0xH3C00, ptr [[F16_VAL_11]], align 2
// CHECK-NEXT:    ret void
//
void test1() {
    _Float16 f16_val_6 = 1.0f16;
    _Float16 f16_val_8 = static_cast<_Float16>(1.0f);
    _Float16 f16_val_9 = static_cast<_Float16>(1.0);
    _Float16 f16_val_10 = static_cast<_Float16>(1.0l);
    _Float16 f16_val_11 = static_cast<_Float16>(1.0f16);
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test2v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[BF16_VAL_5:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_VAL_7:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_VAL_8:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_VAL_9:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_VAL_10:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    store bfloat 0xR3F80, ptr [[BF16_VAL_5]], align 2
// CHECK-NEXT:    store bfloat 0xR3F80, ptr [[BF16_VAL_7]], align 2
// CHECK-NEXT:    store bfloat 0xR3F80, ptr [[BF16_VAL_8]], align 2
// CHECK-NEXT:    store bfloat 0xR3F80, ptr [[BF16_VAL_9]], align 2
// CHECK-NEXT:    store bfloat 0xR3F80, ptr [[BF16_VAL_10]], align 2
// CHECK-NEXT:    ret void
//
void test2() {
    decltype(0.BF16) bf16_val_5 = 1.0bf16;
    decltype(0.BF16) bf16_val_7 = static_cast<decltype(0.BF16)>(1.0f);
    decltype(0.BF16) bf16_val_8 = static_cast<decltype(0.BF16)>(1.0);
    decltype(0.BF16) bf16_val_9 = static_cast<decltype(0.BF16)>(1.0l);
    decltype(0.BF16) bf16_val_10 = static_cast<decltype(0.BF16)>(1.0bf16);
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test3v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[F_VAL_1:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[F_VAL_2:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[F_VAL_3:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[F_VAL_4:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[F_VAL_5:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float 1.000000e+00, ptr [[F_VAL_1]], align 4
// CHECK-NEXT:    store float 1.000000e+00, ptr [[F_VAL_2]], align 4
// CHECK-NEXT:    store float 1.000000e+00, ptr [[F_VAL_3]], align 4
// CHECK-NEXT:    store float 1.000000e+00, ptr [[F_VAL_4]], align 4
// CHECK-NEXT:    store float 1.000000e+00, ptr [[F_VAL_5]], align 4
// CHECK-NEXT:    ret void
//
void test3() {
    float f_val_1 = 1.0f16;
    float f_val_2 = 1.0bf16;
    float f_val_3 = 1.0;
    float f_val_4 = 1.0l;
    float f_val_5 = 1.0f;
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test4v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[D_VAL_1:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[D_VAL_2:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[D_VAL_3:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[D_VAL_4:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[D_VAL_5:%.*]] = alloca double, align 8
// CHECK-NEXT:    store double 1.000000e+00, ptr [[D_VAL_1]], align 8
// CHECK-NEXT:    store double 1.000000e+00, ptr [[D_VAL_2]], align 8
// CHECK-NEXT:    store double 1.000000e+00, ptr [[D_VAL_3]], align 8
// CHECK-NEXT:    store double 1.000000e+00, ptr [[D_VAL_4]], align 8
// CHECK-NEXT:    store double 1.000000e+00, ptr [[D_VAL_5]], align 8
// CHECK-NEXT:    ret void
//
void test4() {
    double d_val_1 = 1.0f16;
    double d_val_2 = 1.0bf16;
    double d_val_3 = 1.0f;
    double d_val_4 = 1.0l;
    double d_val_5 = 1.0;
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test5v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[LD_VAL_1:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[LD_VAL_2:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[LD_VAL_3:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[LD_VAL_4:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[LD_VAL_5:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    store x86_fp80 0xK3FFF8000000000000000, ptr [[LD_VAL_1]], align 16
// CHECK-NEXT:    store x86_fp80 0xK3FFF8000000000000000, ptr [[LD_VAL_2]], align 16
// CHECK-NEXT:    store x86_fp80 0xK3FFF8000000000000000, ptr [[LD_VAL_3]], align 16
// CHECK-NEXT:    store x86_fp80 0xK3FFF8000000000000000, ptr [[LD_VAL_4]], align 16
// CHECK-NEXT:    store x86_fp80 0xK3FFF8000000000000000, ptr [[LD_VAL_5]], align 16
// CHECK-NEXT:    ret void
//
void test5() {
    long double ld_val_1 = 1.0f16;
    long double ld_val_2 = 1.0bf16;
    long double ld_val_3 = 1.0f;
    long double ld_val_4 = 1.0;
    long double ld_val_5 = 1.0l;
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test6v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[F16_FLOAT:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[F16_DOUBLE:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[F16_LDOUBLE:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[F16_INT:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_UINT:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_LONG:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_ULONG:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_LLONG:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_ULLONG:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[F16_BOOL:%.*]] = alloca half, align 2
// CHECK-NEXT:    store float 2.000000e+00, ptr [[F16_FLOAT]], align 4
// CHECK-NEXT:    store double 2.000000e+00, ptr [[F16_DOUBLE]], align 8
// CHECK-NEXT:    store x86_fp80 0xK40008000000000000000, ptr [[F16_LDOUBLE]], align 16
// CHECK-NEXT:    store half 0xH4000, ptr [[F16_INT]], align 2
// CHECK-NEXT:    store half 0xH4000, ptr [[F16_UINT]], align 2
// CHECK-NEXT:    store half 0xH4000, ptr [[F16_LONG]], align 2
// CHECK-NEXT:    store half 0xH4000, ptr [[F16_ULONG]], align 2
// CHECK-NEXT:    store half 0xH4000, ptr [[F16_LLONG]], align 2
// CHECK-NEXT:    store half 0xH4000, ptr [[F16_ULLONG]], align 2
// CHECK-NEXT:    store half 0xH4000, ptr [[F16_BOOL]], align 2
// CHECK-NEXT:    ret void
//
void test6() {
    auto f16_float = 1.0f16 + 1.0f;
    auto f16_double = 1.0f16 + 1.0;
    auto f16_ldouble = 1.0f16 + 1.0l;
    auto f16_int = 1.0f16 + 1;
    auto f16_uint = 1.0f16 + 1u;
    auto f16_long = 1.0f16 + 1l;
    auto f16_ulong = 1.0f16 + 1ul;
    auto f16_llong = 1.0f16 + 1ll;
    auto f16_ullong = 1.0f16 + 1ull;
    auto f16_bool = 1.0f16 + true;
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test7v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[BF16_FLOAT:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[BF16_DOUBLE:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[BF16_LDOUBLE:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[BF16_INT:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_UINT:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_LONG:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_ULONG:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_LLONG:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_ULLONG:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[BF16_BOOL:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    store float 2.000000e+00, ptr [[BF16_FLOAT]], align 4
// CHECK-NEXT:    store double 2.000000e+00, ptr [[BF16_DOUBLE]], align 8
// CHECK-NEXT:    store x86_fp80 0xK40008000000000000000, ptr [[BF16_LDOUBLE]], align 16
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF16_INT]], align 2
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF16_UINT]], align 2
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF16_LONG]], align 2
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF16_ULONG]], align 2
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF16_LLONG]], align 2
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF16_ULLONG]], align 2
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF16_BOOL]], align 2
// CHECK-NEXT:    ret void
//
void test7() {
    auto bf16_float = 1.0bf16 + 1.0f;
    //
    auto bf16_double = 1.0bf16 + 1.0;
    auto bf16_ldouble = 1.0bf16 + 1.0l;
    auto bf16_int = 1.0bf16 + 1;
    auto bf16_uint = 1.0bf16 + 1u;
    auto bf16_long = 1.0bf16 + 1l;
    auto bf16_ulong = 1.0bf16 + 1ul;
    auto bf16_llong = 1.0bf16 + 1ll;
    auto bf16_ullong = 1.0bf16 + 1ull;
    auto bf16_bool = 1.0bf16 + true;
}

//

// CHECK-LABEL: define {{[^@]+}}@_Z7test8_1v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[BF16_VAL:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[TEST1:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TEST_9:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store bfloat 0xR3F80, ptr [[BF16_VAL]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load bfloat, ptr [[BF16_VAL]], align 2
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z1fDF16b(bfloat noundef [[TMP0]])
// CHECK-NEXT:    store i32 [[CALL]], ptr [[TEST1]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load bfloat, ptr [[BF16_VAL]], align 2
// CHECK-NEXT:    [[CONV:%.*]] = fpext bfloat [[TMP1]] to x86_fp80
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef i32 @_Z3f_2e(x86_fp80 noundef [[CONV]])
// CHECK-NEXT:    store i32 [[CALL1]], ptr [[TEST_9]], align 4
// CHECK-NEXT:    ret void
//
void test8_1() {
    decltype(0.BF16) bf16_val = 1.0bf16;
    int test1 = f(bf16_val); // calls f(decltype(0.BF16))
    int test_9 = f_2(bf16_val);
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test8_2v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[FLOAT16_VAL:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[TEST2:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TEST_10:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store half 0xH3C00, ptr [[FLOAT16_VAL]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load half, ptr [[FLOAT16_VAL]], align 2
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z1fDF16_(half noundef [[TMP0]])
// CHECK-NEXT:    store i32 [[CALL]], ptr [[TEST2]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load half, ptr [[FLOAT16_VAL]], align 2
// CHECK-NEXT:    [[CONV:%.*]] = fpext half [[TMP1]] to x86_fp80
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef i32 @_Z3f_2e(x86_fp80 noundef [[CONV]])
// CHECK-NEXT:    store i32 [[CALL1]], ptr [[TEST_10]], align 4
// CHECK-NEXT:    ret void
//
void test8_2() {
    _Float16 float16_val = 1.0f16;
    int test2 = f(float16_val); // calls f(_Float16)
    int test_10 = f_2(float16_val);
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test8_3v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[FLOAT_VAL:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[TEST3:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TEST_7:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store float 1.000000e+00, ptr [[FLOAT_VAL]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[FLOAT_VAL]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z1ff(float noundef [[TMP0]])
// CHECK-NEXT:    store i32 [[CALL]], ptr [[TEST3]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[FLOAT_VAL]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fpext float [[TMP1]] to x86_fp80
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef i32 @_Z3f_2e(x86_fp80 noundef [[CONV]])
// CHECK-NEXT:    store i32 [[CALL1]], ptr [[TEST_7]], align 4
// CHECK-NEXT:    ret void
//
void test8_3() {
    float float_val = 1.0f;
    int test3 = f(float_val); // calls f(float)
    int test_7 = f_2(float_val);
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test8_4v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[DOUBLE_VAL:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[TEST4:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TEST_8:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store double 1.000000e+00, ptr [[DOUBLE_VAL]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double, ptr [[DOUBLE_VAL]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z1fd(double noundef [[TMP0]])
// CHECK-NEXT:    store i32 [[CALL]], ptr [[TEST4]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr [[DOUBLE_VAL]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = fpext double [[TMP1]] to x86_fp80
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef i32 @_Z3f_2e(x86_fp80 noundef [[CONV]])
// CHECK-NEXT:    store i32 [[CALL1]], ptr [[TEST_8]], align 4
// CHECK-NEXT:    ret void
//
void test8_4() {
    double double_val = 1.0;
    int test4 = f(double_val); // calls f(double)
    int test_8 = f_2(double_val);
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test8_5v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[LONG_DOUBLE_VAL:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[TEST5:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store x86_fp80 0xK3FFF8000000000000000, ptr [[LONG_DOUBLE_VAL]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load x86_fp80, ptr [[LONG_DOUBLE_VAL]], align 16
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z1fe(x86_fp80 noundef [[TMP0]])
// CHECK-NEXT:    store i32 [[CALL]], ptr [[TEST5]], align 4
// CHECK-NEXT:    ret void
//
void test8_5() {
    long double long_double_val = 1.0l;
    int test5 = f(long_double_val); // calls f(long double)
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test8_6v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[INT_VAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[TEST6:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 1, ptr [[INT_VAL]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[INT_VAL]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z1fi(i32 noundef [[TMP0]])
// CHECK-NEXT:    store i32 [[CALL]], ptr [[TEST6]], align 4
// CHECK-NEXT:    ret void
//
void test8_6() {
    int int_val = 1;
    int test6 = f(int_val); // calls f(int)
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test9_1v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[USER_DEFINED_VAL:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    [[BFLOAT16_VAL:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[CALL:%.*]] = call noundef bfloat @_ZNK1ScvDF16bEv(ptr noundef nonnull align 1 dereferenceable(1) [[USER_DEFINED_VAL]])
// CHECK-NEXT:    store bfloat [[CALL]], ptr [[BFLOAT16_VAL]], align 2
// CHECK-NEXT:    ret void
//
void test9_1() {
    S user_defined_val;
    // User-defined overload cases
    decltype(0.BF16) bfloat16_val(user_defined_val); // calls operator decltype(0.BF16)()
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test9_2v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[USER_DEFINED_VAL:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    [[F16_VAL:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[CALL:%.*]] = call noundef half @_ZNK1ScvDF16_Ev(ptr noundef nonnull align 1 dereferenceable(1) [[USER_DEFINED_VAL]])
// CHECK-NEXT:    store half [[CALL]], ptr [[F16_VAL]], align 2
// CHECK-NEXT:    ret void
//
void test9_2() {
    S user_defined_val;
    // User-defined overload cases
    _Float16 f16_val(user_defined_val); // calls operator _Float16()
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test9_3v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[USER_DEFINED_VAL:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    [[F_VAL:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef float @_ZNK1ScvfEv(ptr noundef nonnull align 1 dereferenceable(1) [[USER_DEFINED_VAL]])
// CHECK-NEXT:    store float [[CALL]], ptr [[F_VAL]], align 4
// CHECK-NEXT:    ret void
//
void test9_3() {
    S user_defined_val;
    // User-defined overload cases
    float f_val(user_defined_val); // calls operator float()
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test9_4v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[USER_DEFINED_VAL:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    [[D_VAL:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef double @_ZNK1ScvdEv(ptr noundef nonnull align 1 dereferenceable(1) [[USER_DEFINED_VAL]])
// CHECK-NEXT:    store double [[CALL]], ptr [[D_VAL]], align 8
// CHECK-NEXT:    ret void
//
void test9_4() {
    S user_defined_val;
    // User-defined overload cases
    double d_val(user_defined_val); // calls operator double()
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test9_5v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[USER_DEFINED_VAL:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    [[LD_VAL:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[CALL:%.*]] = call noundef x86_fp80 @_ZNK1ScveEv(ptr noundef nonnull align 1 dereferenceable(1) [[USER_DEFINED_VAL]])
// CHECK-NEXT:    store x86_fp80 [[CALL]], ptr [[LD_VAL]], align 16
// CHECK-NEXT:    ret void
//
void test9_5() {
    S user_defined_val;
    // User-defined overload cases
    long double ld_val(user_defined_val); // calls operator long double()
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test9_6v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[USER_DEFINED_VAL:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    [[I_VAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_ZNK1ScviEv(ptr noundef nonnull align 1 dereferenceable(1) [[USER_DEFINED_VAL]])
// CHECK-NEXT:    store i32 [[CALL]], ptr [[I_VAL]], align 4
// CHECK-NEXT:    ret void
//
void test9_6() {
    S user_defined_val;
    // User-defined overload cases
    int i_val(user_defined_val); // calls operator int()
}

// CHECK-LABEL: define {{[^@]+}}@_Z7test9_7v
// CHECK-SAME: () #[[ATTR0]] {
// CHECK:         [[USER_DEFINED_VAL_2:%.*]] = alloca [[STRUCT_S1:%.*]], align 1
// CHECK-NEXT:    [[BFLOAT16_VAL_2:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_ZNK2S1cviEv(ptr noundef nonnull align 1 dereferenceable(1) [[USER_DEFINED_VAL_2]])
// CHECK-NEXT:    [[CONV:%.*]] = sitofp i32 [[CALL]] to bfloat
// CHECK-NEXT:    store bfloat [[CONV]], ptr [[BFLOAT16_VAL_2]], align 2
// CHECK-NEXT:    ret void
//
void test9_7() {
    S1 user_defined_val_2;
    // User-defined overload cases
    decltype(0.BF16) bfloat16_val_2(user_defined_val_2); // calls operator int()
}

template <typename T>
T passThrough(T x) { return x; }

template <typename T>
void acceptSameType(T, T) {}

// CHECK-LABEL: define {{[^@]+}}@_Z8test10_1v
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[HF:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[BF:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[RES1:%.*]] = alloca half, align 2
// CHECK-NEXT:    [[RES2:%.*]] = alloca bfloat, align 2
// CHECK-NEXT:    [[F:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[D:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[LD:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    [[R3:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[R4:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[R5:%.*]] = alloca x86_fp80, align 16
// CHECK-NEXT:    store half 0xH3C00, ptr [[HF]], align 2
// CHECK-NEXT:    store bfloat 0xR4000, ptr [[BF]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load half, ptr [[HF]], align 2
// CHECK-NEXT:    [[CALL:%.*]] = call noundef half @_Z11passThroughIDF16_ET_S0_(half noundef [[TMP0]])
// CHECK-NEXT:    store half [[CALL]], ptr [[RES1]], align 2
// CHECK-NEXT:    [[TMP1:%.*]] = load bfloat, ptr [[BF]], align 2
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef bfloat @_Z11passThroughIDF16bET_S0_(bfloat noundef [[TMP1]])
// CHECK-NEXT:    store bfloat [[CALL1]], ptr [[RES2]], align 2
// CHECK-NEXT:    store float 3.000000e+00, ptr [[F]], align 4
// CHECK-NEXT:    store double 4.000000e+00, ptr [[D]], align 8
// CHECK-NEXT:    store x86_fp80 0xK4001A000000000000000, ptr [[LD]], align 16
// CHECK-NEXT:    [[TMP2:%.*]] = load half, ptr [[HF]], align 2
// CHECK-NEXT:    call void @_Z14acceptSameTypeIDF16_EvT_S0_(half noundef [[TMP2]], half noundef 0xH4600)
// CHECK-NEXT:    [[TMP3:%.*]] = load bfloat, ptr [[BF]], align 2
// CHECK-NEXT:    call void @_Z14acceptSameTypeIDF16bEvT_S0_(bfloat noundef [[TMP3]], bfloat noundef 0xR40E0)
// CHECK-NEXT:    [[TMP4:%.*]] = load float, ptr [[F]], align 4
// CHECK-NEXT:    [[CALL2:%.*]] = call noundef float @_Z11passThroughIfET_S0_(float noundef [[TMP4]])
// CHECK-NEXT:    store float [[CALL2]], ptr [[R3]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = load double, ptr [[D]], align 8
// CHECK-NEXT:    [[CALL3:%.*]] = call noundef double @_Z11passThroughIdET_S0_(double noundef [[TMP5]])
// CHECK-NEXT:    store double [[CALL3]], ptr [[R4]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = load x86_fp80, ptr [[LD]], align 16
// CHECK-NEXT:    [[CALL4:%.*]] = call noundef x86_fp80 @_Z11passThroughIeET_S0_(x86_fp80 noundef [[TMP6]])
// CHECK-NEXT:    store x86_fp80 [[CALL4]], ptr [[R5]], align 16
// CHECK-NEXT:    ret void
//
void test10_1() {
  _Float16 hf = 1.0f16;
  decltype(0.BF16) bf = 2.0bf16;

  auto res1 = passThrough(hf);
  auto res2 = passThrough(bf);

  float f = 3.0f;
  double d = 4.0;
  long double ld = 5.0L;

  acceptSameType(hf, _Float16(6.0f16));
  acceptSameType(bf, decltype(0.BF16)(7.0bf16));

  auto r3 = passThrough(f);
  auto r4 = passThrough(d);
  auto r5 = passThrough(ld);
}