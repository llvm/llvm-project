// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -std=c++1z -Werror -triple i386-unknown-unknown -emit-llvm -O1 -disable-llvm-passes -o - %s | FileCheck %s

// std::byte should be considered equivalent to char for aliasing.

namespace std {
enum byte : unsigned char {};
}

// CHECK-LABEL: define{{.*}} void @test0(
extern "C" void test0(std::byte *sb, int *i) {
  // CHECK: store i8 0, ptr %{{.*}}, align 1, !tbaa [[TBAA11:![0-9]+]]
  *sb = std::byte{0};

  // CHECK: store i32 1, ptr %{{.*}}, align 4, !tbaa [[TBAA3:![0-9]+]]
  *i = 1;
}

enum byte : unsigned char {};
namespace my {
enum byte : unsigned char {};
namespace std {
enum byte : unsigned char {};
} // namespace std
} // namespace my

// Make sure we don't get confused with other enums named 'byte'.

// CHECK-LABEL: define{{.*}} void @test1(
extern "C" void test1(::byte *b, ::my::byte *mb, ::my::std::byte *msb) {
  // CHECK: store i8 0, ptr %{{.*}}, align 1, !tbaa [[TBAA12:![0-9]+]]
  *b = ::byte{0};
  // CHECK: store i8 0, ptr %{{.*}}, align 1, !tbaa [[TBAA14:![0-9]+]]
  *mb = ::my::byte{0};
  // CHECK: store i8 0, ptr %{{.*}}, align 1, !tbaa [[TBAA16:![0-9]+]]
  *msb = ::my::std::byte{0};
}

//.
// CHECK: [[TBAA3]] = !{[[META4:![0-9]+]], [[META4]], i64 0}
// CHECK: [[META4]] = !{!"int", [[META5:![0-9]+]], i64 0}
// CHECK: [[META5]] = !{!"omnipotent char", [[META6:![0-9]+]], i64 0}
// CHECK: [[META6]] = !{!"Simple C++ TBAA"}
// CHECK: [[TBAA11]] = !{[[META5]], [[META5]], i64 0}
// CHECK: [[TBAA12]] = !{[[META13:![0-9]+]], [[META13]], i64 0}
// CHECK: [[META13]] = !{!"_ZTS4byte", [[META5]], i64 0}
// CHECK: [[TBAA14]] = !{[[META15:![0-9]+]], [[META15]], i64 0}
// CHECK: [[META15]] = !{!"_ZTSN2my4byteE", [[META5]], i64 0}
// CHECK: [[TBAA16]] = !{[[META17:![0-9]+]], [[META17]], i64 0}
// CHECK: [[META17]] = !{!"_ZTSN2my3std4byteE", [[META5]], i64 0}
//.
