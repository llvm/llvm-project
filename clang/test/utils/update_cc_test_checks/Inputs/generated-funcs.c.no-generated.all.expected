// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --check-globals
// Check that the CHECK lines are generated for clang-generated functions
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -fopenmp %s -emit-llvm -o - | FileCheck --check-prefix=OMP %s
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu %s -emit-llvm -o - | FileCheck --check-prefix=NOOMP %s

const int size = 1024 * 1024 * 32;

double A[size];

void foo(void);

//.
// OMP: @A = global [33554432 x double] zeroinitializer, align 16
// OMP: @size = constant i32 33554432, align 4
// OMP: @[[GLOB0:[0-9]+]] = private unnamed_addr constant [23 x i8] c"
// OMP: @[[GLOB1:[0-9]+]] = private unnamed_addr constant %struct.ident_t { i32 0, i32 514, i32 0, i32 22, ptr @[[GLOB0]] }, align 8
// OMP: @[[GLOB2:[0-9]+]] = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @[[GLOB0]] }, align 8
//.
// NOOMP: @size = constant i32 33554432, align 4
// NOOMP: @A = global [33554432 x double] zeroinitializer, align 16
//.
// OMP-LABEL: @main(
// OMP-NEXT:  entry:
// OMP-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// OMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// OMP-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// OMP-NEXT:    store i32 0, ptr [[I]], align 4
// OMP-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 0, ptr @main.omp_outlined)
// OMP-NEXT:    call void @foo()
// OMP-NEXT:    ret i32 0
//
// NOOMP-LABEL: @main(
// NOOMP-NEXT:  entry:
// NOOMP-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// NOOMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// NOOMP-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// NOOMP-NEXT:    store i32 0, ptr [[I]], align 4
// NOOMP-NEXT:    store i32 0, ptr [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND:%.*]]
// NOOMP:       for.cond:
// NOOMP-NEXT:    [[TMP0:%.*]] = load i32, ptr [[I]], align 4
// NOOMP-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 33554432
// NOOMP-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// NOOMP:       for.body:
// NOOMP-NEXT:    [[TMP1:%.*]] = load i32, ptr [[I]], align 4
// NOOMP-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP1]] to i64
// NOOMP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [33554432 x double], ptr @A, i64 0, i64 [[IDXPROM]]
// NOOMP-NEXT:    store double 0.000000e+00, ptr [[ARRAYIDX]], align 8
// NOOMP-NEXT:    br label [[FOR_INC:%.*]]
// NOOMP:       for.inc:
// NOOMP-NEXT:    [[TMP2:%.*]] = load i32, ptr [[I]], align 4
// NOOMP-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP2]], 1
// NOOMP-NEXT:    store i32 [[INC]], ptr [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP2:![0-9]+]]
// NOOMP:       for.end:
// NOOMP-NEXT:    call void @foo()
// NOOMP-NEXT:    ret i32 0
//
int main(void) {
  int i = 0;

#pragma omp parallel for
  for (i = 0; i < size; ++i) {
    A[i] = 0.0;
  }

  foo();

  return 0;
}

// OMP-LABEL: @foo(
// OMP-NEXT:  entry:
// OMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// OMP-NEXT:    store i32 0, ptr [[I]], align 4
// OMP-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 0, ptr @foo.omp_outlined)
// OMP-NEXT:    ret void
//
// NOOMP-LABEL: @foo(
// NOOMP-NEXT:  entry:
// NOOMP-NEXT:    [[I:%.*]] = alloca i32, align 4
// NOOMP-NEXT:    store i32 0, ptr [[I]], align 4
// NOOMP-NEXT:    store i32 0, ptr [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND:%.*]]
// NOOMP:       for.cond:
// NOOMP-NEXT:    [[TMP0:%.*]] = load i32, ptr [[I]], align 4
// NOOMP-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 33554432
// NOOMP-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// NOOMP:       for.body:
// NOOMP-NEXT:    [[TMP1:%.*]] = load i32, ptr [[I]], align 4
// NOOMP-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP1]] to i64
// NOOMP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [33554432 x double], ptr @A, i64 0, i64 [[IDXPROM]]
// NOOMP-NEXT:    store double 1.000000e+00, ptr [[ARRAYIDX]], align 8
// NOOMP-NEXT:    br label [[FOR_INC:%.*]]
// NOOMP:       for.inc:
// NOOMP-NEXT:    [[TMP2:%.*]] = load i32, ptr [[I]], align 4
// NOOMP-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP2]], 1
// NOOMP-NEXT:    store i32 [[INC]], ptr [[I]], align 4
// NOOMP-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4:![0-9]+]]
// NOOMP:       for.end:
// NOOMP-NEXT:    ret void
//
void foo(void) {
  int i = 0;

#pragma omp parallel for
  for (i = 0; i < size; ++i) {
    A[i] = 1.0;
  }
}
//.
// OMP: attributes #[[ATTR0:[0-9]+]] = { noinline nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// OMP: attributes #[[ATTR1:[0-9]+]] = { noinline norecurse nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// OMP: attributes #[[ATTR2:[0-9]+]] = { nounwind }
//.
// NOOMP: attributes #[[ATTR0:[0-9]+]] = { noinline nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
//.
// OMP: [[META0:![0-9]+]] = !{i32 1, !"wchar_size", i32 4}
// OMP: [[META1:![0-9]+]] = !{i32 7, !"openmp", i32 51}
// OMP: [[META2:![0-9]+]] = !{!"{{.*}}clang version {{.*}}"}
// OMP: [[META3:![0-9]+]] = !{[[META4:![0-9]+]]}
// OMP: [[META4]] = !{i64 2, i64 -1, i64 -1, i1 true}
//.
// NOOMP: [[META0:![0-9]+]] = !{i32 1, !"wchar_size", i32 4}
// NOOMP: [[META1:![0-9]+]] = !{!"{{.*}}clang version {{.*}}"}
// NOOMP: [[LOOP2]] = distinct !{[[LOOP2]], [[META3:![0-9]+]]}
// NOOMP: [[META3]] = !{!"llvm.loop.mustprogress"}
// NOOMP: [[LOOP4]] = distinct !{[[LOOP4]], [[META3]]}
//.
