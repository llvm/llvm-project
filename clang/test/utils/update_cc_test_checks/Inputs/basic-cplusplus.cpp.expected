// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --include-generated-funcs --version 5
// Basic C++ test for update_cc_test_checks
// RUN: %clang_cc1 -triple=x86_64-unknown-linux-gnu -emit-llvm -o - %s | FileCheck %s
// RUN: %clang_cc1 -triple=x86_64-apple-macho -emit-llvm -o - %s | FileCheck %s --check-prefix=MACHO
// RUN: %clang_cc1 -triple=x86_64-windows-msvc -emit-llvm -o - %s | FileCheck %s --check-prefix=MSVC
// RUN: %clang_cc1 -triple=x86_64-windows-gnu -emit-llvm -o - %s | FileCheck %s --check-prefix=MINGW

class Foo {
  int x;

public:
  explicit Foo(int x);
  ~Foo();
  inline int function_defined_inline(int arg) const {
    return arg + x;
  }
  inline int function_defined_out_of_line(int arg) const;
};

[[clang::noinline]] static int static_noinline_fn(int arg) { return arg; }

Foo::Foo(int x) : x(x) {}
Foo::~Foo() {}
int Foo::function_defined_out_of_line(int arg) const { return x - arg; }

// Call the inline methods to ensure the LLVM IR is generated:
int main() {
  Foo f(1);
  f.function_defined_inline(2);
  f.function_defined_out_of_line(3);
  return static_noinline_fn(0);
}
// CHECK-LABEL: define dso_local void @_ZN3FooC2Ei(
// CHECK-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[X:%.*]]) unnamed_addr #[[ATTR0:[0-9]+]] align 2 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[X2:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    store i32 [[TMP0]], ptr [[X2]], align 4
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define dso_local void @_ZN3FooC1Ei(
// CHECK-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[X:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    call void @_ZN3FooC2Ei(ptr noundef nonnull align 4 dereferenceable(4) [[THIS1]], i32 noundef [[TMP0]])
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define dso_local void @_ZN3FooD2Ev(
// CHECK-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define dso_local void @_ZN3FooD1Ev(
// CHECK-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN3FooD2Ev(ptr noundef nonnull align 4 dereferenceable(4) [[THIS1]]) #[[ATTR2:[0-9]+]]
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define dso_local noundef i32 @main(
// CHECK-SAME: ) #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[F:%.*]] = alloca [[CLASS_FOO:%.*]], align 4
// CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-NEXT:    call void @_ZN3FooC1Ei(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 1)
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_ZNK3Foo23function_defined_inlineEi(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 2)
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef i32 @_ZNK3Foo28function_defined_out_of_lineEi(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 3)
// CHECK-NEXT:    [[CALL2:%.*]] = call noundef i32 @_ZL18static_noinline_fni(i32 noundef 0)
// CHECK-NEXT:    store i32 [[CALL2]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    call void @_ZN3FooD1Ev(ptr noundef nonnull align 4 dereferenceable(4) [[F]]) #[[ATTR2]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP0]]
//
//
// CHECK-LABEL: define linkonce_odr noundef i32 @_ZNK3Foo23function_defined_inlineEi(
// CHECK-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[ARG:%.*]]) #[[ATTR0]] comdat align 2 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[X]], align 4
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
// CHECK-NEXT:    ret i32 [[ADD]]
//
//
// CHECK-LABEL: define linkonce_odr noundef i32 @_ZNK3Foo28function_defined_out_of_lineEi(
// CHECK-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[ARG:%.*]]) #[[ATTR0]] comdat align 2 {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP0]], [[TMP1]]
// CHECK-NEXT:    ret i32 [[SUB]]
//
//
// CHECK-LABEL: define internal noundef i32 @_ZL18static_noinline_fni(
// CHECK-SAME: i32 noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// CHECK-NEXT:    ret i32 [[TMP0]]
//
//
// MACHO-LABEL: define void @_ZN3FooC2Ei(
// MACHO-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[X:%.*]]) unnamed_addr #[[ATTR0:[0-9]+]] align 2 {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MACHO-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// MACHO-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    [[X2:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// MACHO-NEXT:    store i32 [[TMP0]], ptr [[X2]], align 4
// MACHO-NEXT:    ret void
//
//
// MACHO-LABEL: define void @_ZN3FooC1Ei(
// MACHO-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[X:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MACHO-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// MACHO-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// MACHO-NEXT:    call void @_ZN3FooC2Ei(ptr noundef nonnull align 4 dereferenceable(4) [[THIS1]], i32 noundef [[TMP0]])
// MACHO-NEXT:    ret void
//
//
// MACHO-LABEL: define void @_ZN3FooD2Ev(
// MACHO-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MACHO-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    ret void
//
//
// MACHO-LABEL: define void @_ZN3FooD1Ev(
// MACHO-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MACHO-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    call void @_ZN3FooD2Ev(ptr noundef nonnull align 4 dereferenceable(4) [[THIS1]]) #[[ATTR2:[0-9]+]]
// MACHO-NEXT:    ret void
//
//
// MACHO-LABEL: define noundef i32 @main(
// MACHO-SAME: ) #[[ATTR1:[0-9]+]] {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// MACHO-NEXT:    [[F:%.*]] = alloca [[CLASS_FOO:%.*]], align 4
// MACHO-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// MACHO-NEXT:    call void @_ZN3FooC1Ei(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 1)
// MACHO-NEXT:    [[CALL:%.*]] = call noundef i32 @_ZNK3Foo23function_defined_inlineEi(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 2)
// MACHO-NEXT:    [[CALL1:%.*]] = call noundef i32 @_ZNK3Foo28function_defined_out_of_lineEi(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 3)
// MACHO-NEXT:    [[CALL2:%.*]] = call noundef i32 @_ZL18static_noinline_fni(i32 noundef 0)
// MACHO-NEXT:    store i32 [[CALL2]], ptr [[RETVAL]], align 4
// MACHO-NEXT:    call void @_ZN3FooD1Ev(ptr noundef nonnull align 4 dereferenceable(4) [[F]]) #[[ATTR2]]
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[RETVAL]], align 4
// MACHO-NEXT:    ret i32 [[TMP0]]
//
//
// MACHO-LABEL: define linkonce_odr noundef i32 @_ZNK3Foo23function_defined_inlineEi(
// MACHO-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[ARG:%.*]]) #[[ATTR0]] align 2 {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MACHO-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[X:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// MACHO-NEXT:    [[TMP1:%.*]] = load i32, ptr [[X]], align 4
// MACHO-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
// MACHO-NEXT:    ret i32 [[ADD]]
//
//
// MACHO-LABEL: define linkonce_odr noundef i32 @_ZNK3Foo28function_defined_out_of_lineEi(
// MACHO-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[ARG:%.*]]) #[[ATTR0]] align 2 {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MACHO-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MACHO-NEXT:    [[X:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X]], align 4
// MACHO-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP0]], [[TMP1]]
// MACHO-NEXT:    ret i32 [[SUB]]
//
//
// MACHO-LABEL: define internal noundef i32 @_ZL18static_noinline_fni(
// MACHO-SAME: i32 noundef [[ARG:%.*]]) #[[ATTR0]] {
// MACHO-NEXT:  [[ENTRY:.*:]]
// MACHO-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    ret i32 [[TMP0]]
//
//
// MSVC-LABEL: define dso_local noundef i32 @main(
// MSVC-SAME: ) #[[ATTR1:[0-9]+]] {
// MSVC-NEXT:  [[ENTRY:.*:]]
// MSVC-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// MSVC-NEXT:    [[F:%.*]] = alloca [[CLASS_FOO:%.*]], align 4
// MSVC-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// MSVC-NEXT:    [[CALL:%.*]] = call noundef ptr @"??0Foo@@QEAA@H@Z"(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 1)
// MSVC-NEXT:    [[CALL1:%.*]] = call noundef i32 @"?function_defined_inline@Foo@@QEBAHH@Z"(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 2)
// MSVC-NEXT:    [[CALL2:%.*]] = call noundef i32 @"?function_defined_out_of_line@Foo@@QEBAHH@Z"(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 3)
// MSVC-NEXT:    [[CALL3:%.*]] = call noundef i32 @"?static_noinline_fn@@YAHH@Z"(i32 noundef 0)
// MSVC-NEXT:    store i32 [[CALL3]], ptr [[RETVAL]], align 4
// MSVC-NEXT:    call void @"??1Foo@@QEAA@XZ"(ptr noundef nonnull align 4 dereferenceable(4) [[F]]) #[[ATTR2:[0-9]+]]
// MSVC-NEXT:    [[TMP0:%.*]] = load i32, ptr [[RETVAL]], align 4
// MSVC-NEXT:    ret i32 [[TMP0]]
//
//
// MINGW-LABEL: define dso_local void @_ZN3FooC2Ei(
// MINGW-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[X:%.*]]) unnamed_addr #[[ATTR0:[0-9]+]] align 2 {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MINGW-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// MINGW-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    [[X2:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// MINGW-NEXT:    store i32 [[TMP0]], ptr [[X2]], align 4
// MINGW-NEXT:    ret void
//
//
// MINGW-LABEL: define dso_local void @_ZN3FooC1Ei(
// MINGW-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[X:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MINGW-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// MINGW-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// MINGW-NEXT:    call void @_ZN3FooC2Ei(ptr noundef nonnull align 4 dereferenceable(4) [[THIS1]], i32 noundef [[TMP0]])
// MINGW-NEXT:    ret void
//
//
// MINGW-LABEL: define dso_local void @_ZN3FooD2Ev(
// MINGW-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MINGW-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    ret void
//
//
// MINGW-LABEL: define dso_local void @_ZN3FooD1Ev(
// MINGW-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) unnamed_addr #[[ATTR0]] align 2 {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MINGW-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    call void @_ZN3FooD2Ev(ptr noundef nonnull align 4 dereferenceable(4) [[THIS1]]) #[[ATTR2:[0-9]+]]
// MINGW-NEXT:    ret void
//
//
// MINGW-LABEL: define dso_local noundef i32 @main(
// MINGW-SAME: ) #[[ATTR1:[0-9]+]] {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// MINGW-NEXT:    [[F:%.*]] = alloca [[CLASS_FOO:%.*]], align 4
// MINGW-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// MINGW-NEXT:    call void @_ZN3FooC1Ei(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 1)
// MINGW-NEXT:    [[CALL:%.*]] = call noundef i32 @_ZNK3Foo23function_defined_inlineEi(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 2)
// MINGW-NEXT:    [[CALL1:%.*]] = call noundef i32 @_ZNK3Foo28function_defined_out_of_lineEi(ptr noundef nonnull align 4 dereferenceable(4) [[F]], i32 noundef 3)
// MINGW-NEXT:    [[CALL2:%.*]] = call noundef i32 @_ZL18static_noinline_fni(i32 noundef 0)
// MINGW-NEXT:    store i32 [[CALL2]], ptr [[RETVAL]], align 4
// MINGW-NEXT:    call void @_ZN3FooD1Ev(ptr noundef nonnull align 4 dereferenceable(4) [[F]]) #[[ATTR2]]
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[RETVAL]], align 4
// MINGW-NEXT:    ret i32 [[TMP0]]
//
//
// MINGW-LABEL: define linkonce_odr dso_local noundef i32 @_ZNK3Foo23function_defined_inlineEi(
// MINGW-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[ARG:%.*]]) #[[ATTR0]] comdat align 2 {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[X:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// MINGW-NEXT:    [[TMP1:%.*]] = load i32, ptr [[X]], align 4
// MINGW-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
// MINGW-NEXT:    ret i32 [[ADD]]
//
//
// MINGW-LABEL: define linkonce_odr dso_local noundef i32 @_ZNK3Foo28function_defined_out_of_lineEi(
// MINGW-SAME: ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]], i32 noundef [[ARG:%.*]]) #[[ATTR0]] comdat align 2 {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// MINGW-NEXT:    [[X:%.*]] = getelementptr inbounds nuw [[CLASS_FOO:%.*]], ptr [[THIS1]], i32 0, i32 0
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X]], align 4
// MINGW-NEXT:    [[TMP1:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP0]], [[TMP1]]
// MINGW-NEXT:    ret i32 [[SUB]]
//
//
// MINGW-LABEL: define internal noundef i32 @_ZL18static_noinline_fni(
// MINGW-SAME: i32 noundef [[ARG:%.*]]) #[[ATTR0]] {
// MINGW-NEXT:  [[ENTRY:.*:]]
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store i32 [[ARG]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    ret i32 [[TMP0]]
//
