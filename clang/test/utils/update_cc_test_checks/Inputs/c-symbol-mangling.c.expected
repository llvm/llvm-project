// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
/// Check that we generate checks for functions even though the mangledName
/// property in the AST dump JSON does not match the LLVM IR name.
// RUN: %clang_cc1 -triple=x86_64-unknown-linux-gnu -emit-llvm -o - %s | FileCheck %s --check-prefix=ELF
// RUN: %clang_cc1 -triple=x86_64-apple-macho -emit-llvm -o - %s | FileCheck %s --check-prefix=MACHO
// RUN: %clang_cc1 -triple=x86_64-windows-msvc -emit-llvm -o - %s | FileCheck %s --check-prefix=MSVC
// RUN: %clang_cc1 -triple=x86_64-windows-gnu -emit-llvm -o - %s | FileCheck %s --check-prefix=MINGW
// RUN: %clang_cc1 -triple=i686-unknown-win32 -emit-llvm -o - %s | FileCheck %s --check-prefix=WIN32
// RUN: %clang_cc1 -triple thumbv7s-apple-darwin -target-abi apcs-gnu -emit-llvm -o - %s | FileCheck %s --check-prefix=THUMB-DARWIN

// UTC_ARGS: --disable
// ELF: target datalayout = "e-m:e-
// MACHO: target datalayout = "e-m:o-
// MSVC: target datalayout = "e-m:w-
// MINGW: target datalayout = "e-m:w-
// WIN32: target datalayout = "e-m:x-
// THUMB-DARWIN: target datalayout = "e-m:o-
// UTC_ARGS: --enable

#ifdef __arm__
typedef __attribute__((neon_vector_type(8))) __INT8_TYPE__ int8x8_t;
// THUMB-DARWIN-LABEL: @test_vaba_s8(
// THUMB-DARWIN-NEXT:  entry:
// THUMB-DARWIN-NEXT:    [[A_ADDR:%.*]] = alloca <8 x i8>, align 8
// THUMB-DARWIN-NEXT:    [[B_ADDR:%.*]] = alloca <8 x i8>, align 8
// THUMB-DARWIN-NEXT:    [[C_ADDR:%.*]] = alloca <8 x i8>, align 8
// THUMB-DARWIN-NEXT:    store <8 x i8> [[A:%.*]], ptr [[A_ADDR]], align 8
// THUMB-DARWIN-NEXT:    store <8 x i8> [[B:%.*]], ptr [[B_ADDR]], align 8
// THUMB-DARWIN-NEXT:    store <8 x i8> [[C:%.*]], ptr [[C_ADDR]], align 8
// THUMB-DARWIN-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[A_ADDR]], align 8
// THUMB-DARWIN-NEXT:    [[TMP1:%.*]] = load <8 x i8>, ptr [[B_ADDR]], align 8
// THUMB-DARWIN-NEXT:    [[ADD:%.*]] = add <8 x i8> [[TMP0]], [[TMP1]]
// THUMB-DARWIN-NEXT:    [[TMP2:%.*]] = load <8 x i8>, ptr [[C_ADDR]], align 8
// THUMB-DARWIN-NEXT:    [[ADD1:%.*]] = add <8 x i8> [[ADD]], [[TMP2]]
// THUMB-DARWIN-NEXT:    ret <8 x i8> [[ADD1]]
//
int8x8_t test_vaba_s8(int8x8_t a, int8x8_t b, int8x8_t c) {
  return a + b + c;
}
#endif

/// Check global variable mangling
[[gnu::used]] static int i1 = 1;
int i2 = 2;

// ELF-LABEL: @static_noinline_fn(
// ELF-NEXT:  entry:
// ELF-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// ELF-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    ret i32 [[TMP0]]
//
// MACHO-LABEL: @static_noinline_fn(
// MACHO-NEXT:  entry:
// MACHO-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    ret i32 [[TMP0]]
//
// MSVC-LABEL: @static_noinline_fn(
// MSVC-NEXT:  entry:
// MSVC-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MSVC-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    ret i32 [[TMP0]]
//
// MINGW-LABEL: @static_noinline_fn(
// MINGW-NEXT:  entry:
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    ret i32 [[TMP0]]
//
// WIN32-LABEL: @static_noinline_fn(
// WIN32-NEXT:  entry:
// WIN32-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// WIN32-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    ret i32 [[TMP0]]
//
// THUMB-DARWIN-LABEL: @static_noinline_fn(
// THUMB-DARWIN-NEXT:  entry:
// THUMB-DARWIN-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// THUMB-DARWIN-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    ret i32 [[TMP0]]
//
[[clang::noinline,gnu::used]] static int static_noinline_fn(int arg) { return arg; }

// ELF-LABEL: @hidden_visibility(
// ELF-NEXT:  entry:
// ELF-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// ELF-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    ret i32 [[TMP0]]
//
// MACHO-LABEL: @hidden_visibility(
// MACHO-NEXT:  entry:
// MACHO-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    ret i32 [[TMP0]]
//
// MSVC-LABEL: @hidden_visibility(
// MSVC-NEXT:  entry:
// MSVC-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MSVC-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    ret i32 [[TMP0]]
//
// MINGW-LABEL: @hidden_visibility(
// MINGW-NEXT:  entry:
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    ret i32 [[TMP0]]
//
// WIN32-LABEL: @hidden_visibility(
// WIN32-NEXT:  entry:
// WIN32-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// WIN32-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    ret i32 [[TMP0]]
//
// THUMB-DARWIN-LABEL: @hidden_visibility(
// THUMB-DARWIN-NEXT:  entry:
// THUMB-DARWIN-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// THUMB-DARWIN-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    ret i32 [[TMP0]]
//
[[gnu::visibility("hidden")]] int hidden_visibility(int arg) { return arg; }

#ifdef __ELF__
// ELF-LABEL: @protected_visibility(
// ELF-NEXT:  entry:
// ELF-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// ELF-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    ret i32 [[TMP0]]
//
[[gnu::visibility("protected")]] int protected_visibility(int arg) { return arg; }
#endif

// ELF-LABEL: @default_visibility(
// ELF-NEXT:  entry:
// ELF-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// ELF-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    ret i32 [[TMP0]]
//
// MACHO-LABEL: @default_visibility(
// MACHO-NEXT:  entry:
// MACHO-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    ret i32 [[TMP0]]
//
// MSVC-LABEL: @default_visibility(
// MSVC-NEXT:  entry:
// MSVC-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MSVC-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    ret i32 [[TMP0]]
//
// MINGW-LABEL: @default_visibility(
// MINGW-NEXT:  entry:
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    ret i32 [[TMP0]]
//
// WIN32-LABEL: @default_visibility(
// WIN32-NEXT:  entry:
// WIN32-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// WIN32-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    ret i32 [[TMP0]]
//
// THUMB-DARWIN-LABEL: @default_visibility(
// THUMB-DARWIN-NEXT:  entry:
// THUMB-DARWIN-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// THUMB-DARWIN-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    ret i32 [[TMP0]]
//
[[gnu::visibility("default")]] int default_visibility(int arg) { return arg; }

// ELF-LABEL: @no_visibility(
// ELF-NEXT:  entry:
// ELF-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// ELF-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// ELF-NEXT:    ret i32 [[TMP0]]
//
// MACHO-LABEL: @no_visibility(
// MACHO-NEXT:  entry:
// MACHO-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MACHO-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MACHO-NEXT:    ret i32 [[TMP0]]
//
// MSVC-LABEL: @no_visibility(
// MSVC-NEXT:  entry:
// MSVC-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MSVC-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    ret i32 [[TMP0]]
//
// MINGW-LABEL: @no_visibility(
// MINGW-NEXT:  entry:
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    ret i32 [[TMP0]]
//
// WIN32-LABEL: @no_visibility(
// WIN32-NEXT:  entry:
// WIN32-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// WIN32-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// WIN32-NEXT:    ret i32 [[TMP0]]
//
// THUMB-DARWIN-LABEL: @no_visibility(
// THUMB-DARWIN-NEXT:  entry:
// THUMB-DARWIN-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// THUMB-DARWIN-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// THUMB-DARWIN-NEXT:    ret i32 [[TMP0]]
//
int no_visibility(int arg) { return arg; }


/// FIXME: the i386 @fastcall@12 is not being checked here
#ifdef _WIN32
// MSVC-LABEL: @fastcall(
// MSVC-NEXT:  entry:
// MSVC-NEXT:    [[ARG3_ADDR:%.*]] = alloca i32, align 4
// MSVC-NEXT:    [[ARG2_ADDR:%.*]] = alloca i32, align 4
// MSVC-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MSVC-NEXT:    store i32 [[ARG3:%.*]], ptr [[ARG3_ADDR]], align 4
// MSVC-NEXT:    store i32 [[ARG2:%.*]], ptr [[ARG2_ADDR]], align 4
// MSVC-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MSVC-NEXT:    ret i32 [[TMP0]]
//
// MINGW-LABEL: @fastcall(
// MINGW-NEXT:  entry:
// MINGW-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    [[ARG2_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    [[ARG3_ADDR:%.*]] = alloca i32, align 4
// MINGW-NEXT:    store i32 [[ARG:%.*]], ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    store i32 [[ARG2:%.*]], ptr [[ARG2_ADDR]], align 4
// MINGW-NEXT:    store i32 [[ARG3:%.*]], ptr [[ARG3_ADDR]], align 4
// MINGW-NEXT:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// MINGW-NEXT:    ret i32 [[TMP0]]
//
int __fastcall fastcall(int arg, long arg2, long arg3) { return arg; }
#endif

