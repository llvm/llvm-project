// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs --replace-value-regex "__omp_offloading_[0-9a-z]+_[0-9a-z]+" "reduction_size[.].+[.]" "pl_cond[.].+[.|,]" --prefix-filecheck-ir-name _
// RUN: %clang_cc1 -fopenmp -x c++ %s -verify -debug-info-kind=limited -triple x86_64-unknown-unknown -emit-llvm -o - | FileCheck %s --check-prefix=CHECK1

// RUN: %clang_cc1 -fopenmp-simd -x c++ %s -verify -debug-info-kind=limited -triple x86_64-unknown-unknown -emit-llvm -o - | FileCheck %s --implicit-check-not="{{__kmpc|__tgt}}"
// expected-no-diagnostics

void a() {
  float _Complex b;
#pragma omp parallel firstprivate(b)
  ;
}


// CHECK1-LABEL: define {{[^@]+}}@_Z1av
// CHECK1-SAME: () #[[ATTR0:[0-9]+]] !dbg [[DBG6:![0-9]+]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[B:%.*]] = alloca { float, float }, align 4
// CHECK1-NEXT:    [[OMP_OUTLINED_ARG_AGG_:%.*]] = alloca [[STRUCT_ANON:%.*]], align 4
// CHECK1-NEXT:    call void @llvm.dbg.declare(metadata { float, float }* [[B]], metadata [[META10:![0-9]+]], metadata !DIExpression()), !dbg [[DBG12:![0-9]+]]
// CHECK1-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [[STRUCT_ANON]], %struct.anon* [[OMP_OUTLINED_ARG_AGG_]], i32 0, i32 0, !dbg [[DBG13:![0-9]+]]
// CHECK1-NEXT:    [[B_REALP:%.*]] = getelementptr inbounds { float, float }, { float, float }* [[B]], i32 0, i32 0, !dbg [[DBG14:![0-9]+]]
// CHECK1-NEXT:    [[B_REAL:%.*]] = load float, float* [[B_REALP]], align 4, !dbg [[DBG14]]
// CHECK1-NEXT:    [[B_IMAGP:%.*]] = getelementptr inbounds { float, float }, { float, float }* [[B]], i32 0, i32 1, !dbg [[DBG14]]
// CHECK1-NEXT:    [[B_IMAG:%.*]] = load float, float* [[B_IMAGP]], align 4, !dbg [[DBG14]]
// CHECK1-NEXT:    [[DOTREALP:%.*]] = getelementptr inbounds { float, float }, { float, float }* [[TMP0]], i32 0, i32 0, !dbg [[DBG13]]
// CHECK1-NEXT:    [[DOTIMAGP:%.*]] = getelementptr inbounds { float, float }, { float, float }* [[TMP0]], i32 0, i32 1, !dbg [[DBG13]]
// CHECK1-NEXT:    store float [[B_REAL]], float* [[DOTREALP]], align 4, !dbg [[DBG13]]
// CHECK1-NEXT:    store float [[B_IMAG]], float* [[DOTIMAGP]], align 4, !dbg [[DBG13]]
// CHECK1-NEXT:    call void (%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...) @__kmpc_fork_call(%struct.ident_t* @[[GLOB1:[0-9]+]], i32 1, void (i32*, i32*, ...)* bitcast (void (i32*, i32*, %struct.anon*)* @.omp_outlined. to void (i32*, i32*, ...)*), %struct.anon* [[OMP_OUTLINED_ARG_AGG_]]), !dbg [[DBG13]]
// CHECK1-NEXT:    ret void, !dbg [[DBG16:![0-9]+]]
//
//
// CHECK1-LABEL: define {{[^@]+}}@.omp_outlined.
// CHECK1-SAME: (i32* noalias [[DOTGLOBAL_TID_:%.*]], i32* noalias [[DOTBOUND_TID_:%.*]], %struct.anon* noalias [[__CONTEXT:%.*]]) #[[ATTR2:[0-9]+]] !dbg [[DBG17:![0-9]+]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca i32*, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca i32*, align 8
// CHECK1-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca %struct.anon*, align 8
// CHECK1-NEXT:    [[B:%.*]] = alloca { float, float }, align 4
// CHECK1-NEXT:    store i32* [[DOTGLOBAL_TID_]], i32** [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    call void @llvm.dbg.declare(metadata i32** [[DOTGLOBAL_TID__ADDR]], metadata [[META29:![0-9]+]], metadata !DIExpression()), !dbg [[DBG30:![0-9]+]]
// CHECK1-NEXT:    store i32* [[DOTBOUND_TID_]], i32** [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    call void @llvm.dbg.declare(metadata i32** [[DOTBOUND_TID__ADDR]], metadata [[META31:![0-9]+]], metadata !DIExpression()), !dbg [[DBG30]]
// CHECK1-NEXT:    store %struct.anon* [[__CONTEXT]], %struct.anon** [[__CONTEXT_ADDR]], align 8
// CHECK1-NEXT:    call void @llvm.dbg.declare(metadata %struct.anon** [[__CONTEXT_ADDR]], metadata [[META32:![0-9]+]], metadata !DIExpression()), !dbg [[DBG30]]
// CHECK1-NEXT:    [[TMP0:%.*]] = load %struct.anon*, %struct.anon** [[__CONTEXT_ADDR]], align 8, !dbg [[DBG33:![0-9]+]]
// CHECK1-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], %struct.anon* [[TMP0]], i32 0, i32 0, !dbg [[DBG33]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load { float, float }, { float, float }* [[TMP1]], align 4, !dbg [[DBG33]]
// CHECK1-NEXT:    store { float, float } [[TMP2]], { float, float }* [[B]], align 4, !dbg [[DBG33]]
// CHECK1-NEXT:    ret void, !dbg [[DBG34:![0-9]+]]
//
