// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 6
// RUN: %clang_cc1 -finclude-default-header -triple dxil-pc-shadermodel6.3-library -emit-llvm -disable-llvm-passes -o - %s | FileCheck %s


struct S {
    bool2x2 bM;
    float f;
};

// CHECK-LABEL: define hidden noundef i1 @_Z3fn1v(
// CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i1, align 4
// CHECK-NEXT:    [[B:%.*]] = alloca [4 x i32], align 4
// CHECK-NEXT:    store <4 x i1> splat (i1 true), ptr [[B]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[B]], align 4
// CHECK-NEXT:    [[MATRIXEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 0
// CHECK-NEXT:    store i32 [[MATRIXEXT]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i1, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i1 [[TMP1]]
//
bool fn1() {
  bool2x2 B = {true,true,true,true};
  return B[0][0];
}

// CHECK-LABEL: define hidden noundef <4 x i1> @_Z3fn2b(
// CHECK-SAME: i1 noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca <4 x i1>, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[A:%.*]] = alloca [4 x i32], align 4
// CHECK-NEXT:    [[STOREDV:%.*]] = zext i1 [[V]] to i32
// CHECK-NEXT:    store i32 [[STOREDV]], ptr [[V_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[V_ADDR]], align 4
// CHECK-NEXT:    [[LOADEDV:%.*]] = trunc i32 [[TMP0]] to i1
// CHECK-NEXT:    [[VECINIT:%.*]] = insertelement <4 x i1> poison, i1 [[LOADEDV]], i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[V_ADDR]], align 4
// CHECK-NEXT:    [[LOADEDV1:%.*]] = trunc i32 [[TMP1]] to i1
// CHECK-NEXT:    [[VECINIT2:%.*]] = insertelement <4 x i1> [[VECINIT]], i1 [[LOADEDV1]], i32 1
// CHECK-NEXT:    [[VECINIT3:%.*]] = insertelement <4 x i1> [[VECINIT2]], i1 true, i32 2
// CHECK-NEXT:    [[VECINIT4:%.*]] = insertelement <4 x i1> [[VECINIT3]], i1 false, i32 3
// CHECK-NEXT:    store <4 x i1> [[VECINIT4]], ptr [[A]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load <4 x i32>, ptr [[A]], align 4
// CHECK-NEXT:    store <4 x i32> [[TMP2]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load <4 x i1>, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret <4 x i1> [[TMP3]]
//
bool2x2 fn2(bool V) {
  bool2x2 A = {V, true, V, false};
  return A;
}

// CHECK-LABEL: define hidden noundef i1 @_Z3fn3v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i1, align 4
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    [[BM:%.*]] = getelementptr inbounds nuw [[STRUCT_S]], ptr [[S]], i32 0, i32 0
// CHECK-NEXT:    store <4 x i1> <i1 true, i1 false, i1 true, i1 false>, ptr [[BM]], align 1
// CHECK-NEXT:    [[F:%.*]] = getelementptr inbounds nuw [[STRUCT_S]], ptr [[S]], i32 0, i32 1
// CHECK-NEXT:    store float 1.000000e+00, ptr [[F]], align 1
// CHECK-NEXT:    [[BM1:%.*]] = getelementptr inbounds nuw [[STRUCT_S]], ptr [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[BM1]], align 1
// CHECK-NEXT:    [[MATRIXEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 0
// CHECK-NEXT:    store i32 [[MATRIXEXT]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i1, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i1 [[TMP1]]
//
bool fn3() {
  S s = {{true,true,false,false}, 1.0};
  return s.bM[0][0];
}

// CHECK-LABEL: define hidden noundef i1 @_Z3fn4v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i1, align 4
// CHECK-NEXT:    [[ARR:%.*]] = alloca [2 x [4 x i32]], align 4
// CHECK-NEXT:    store <4 x i1> splat (i1 true), ptr [[ARR]], align 4
// CHECK-NEXT:    [[ARRAYINIT_ELEMENT:%.*]] = getelementptr inbounds [4 x i32], ptr [[ARR]], i32 1
// CHECK-NEXT:    store <4 x i1> zeroinitializer, ptr [[ARRAYINIT_ELEMENT]], align 4
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x [4 x i32]], ptr [[ARR]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    [[MATRIXEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 1
// CHECK-NEXT:    store i32 [[MATRIXEXT]], ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i1, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i1 [[TMP1]]
//
bool fn4() {
  bool2x2 Arr[2] = {{true,true,true,true}, {false,false,false,false}};
  return Arr[0][1][0];
}

// CHECK-LABEL: define hidden void @_Z3fn5v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M:%.*]] = alloca [4 x i32], align 4
// CHECK-NEXT:    store <4 x i1> splat (i1 true), ptr [[M]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[M]], align 4
// CHECK-NEXT:    [[MATINS:%.*]] = insertelement <4 x i32> [[TMP0]], i32 0, i32 3
// CHECK-NEXT:    store <4 x i32> [[MATINS]], ptr [[M]], align 4
// CHECK-NEXT:    ret void
//
void fn5() {
  bool2x2 M = {true,true,true,true};
  M[1][1] = false;
}

// CHECK-LABEL: define hidden void @_Z3fn6v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[V:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    store i32 0, ptr [[V]], align 4
// CHECK-NEXT:    [[BM:%.*]] = getelementptr inbounds nuw [[STRUCT_S]], ptr [[S]], i32 0, i32 0
// CHECK-NEXT:    store <4 x i1> <i1 true, i1 false, i1 true, i1 false>, ptr [[BM]], align 1
// CHECK-NEXT:    [[F:%.*]] = getelementptr inbounds nuw [[STRUCT_S]], ptr [[S]], i32 0, i32 1
// CHECK-NEXT:    store float 1.000000e+00, ptr [[F]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[V]], align 4
// CHECK-NEXT:    [[LOADEDV:%.*]] = trunc i32 [[TMP0]] to i1
// CHECK-NEXT:    [[BM1:%.*]] = getelementptr inbounds nuw [[STRUCT_S]], ptr [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr [[BM1]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = zext i1 [[LOADEDV]] to i32
// CHECK-NEXT:    [[MATINS:%.*]] = insertelement <4 x i32> [[TMP1]], i32 [[TMP2]], i32 1
// CHECK-NEXT:    store <4 x i32> [[MATINS]], ptr [[BM1]], align 1
// CHECK-NEXT:    ret void
//
void fn6() {
  bool V = false;
  S s = {{true,true,false,false}, 1.0};
  s.bM[1][0] = V;
}

// CHECK-LABEL: define hidden void @_Z3fn7v(
// CHECK-SAME: ) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[ARR:%.*]] = alloca [2 x [4 x i32]], align 4
// CHECK-NEXT:    store <4 x i1> splat (i1 true), ptr [[ARR]], align 4
// CHECK-NEXT:    [[ARRAYINIT_ELEMENT:%.*]] = getelementptr inbounds [4 x i32], ptr [[ARR]], i32 1
// CHECK-NEXT:    store <4 x i1> zeroinitializer, ptr [[ARRAYINIT_ELEMENT]], align 4
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x [4 x i32]], ptr [[ARR]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    [[MATINS:%.*]] = insertelement <4 x i32> [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    store <4 x i32> [[MATINS]], ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret void
//
void fn7() {
  bool2x2 Arr[2] = {{true,true,true,true}, {false,false,false,false}};
  Arr[0][1][0] = false;
}
