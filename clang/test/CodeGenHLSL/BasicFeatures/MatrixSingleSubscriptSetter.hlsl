// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 6
// RUN: %clang_cc1 -triple dxil-pc-shadermodel6.7-library -disable-llvm-passes -emit-llvm -finclude-default-header -o - %s | FileCheck %s

// CHECK-LABEL: define hidden void @_Z9setMatrixRu11matrix_typeILm4ELm4EfEiDv4_f(
// CHECK-SAME: ptr noalias noundef nonnull align 4 dereferenceable(64) [[M:%.*]], i32 noundef [[INDEX:%.*]], <4 x float> noundef nofpclass(nan inf) [[V:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M_ADDR:%.*]] = alloca ptr, align 4
// CHECK-NEXT:    [[INDEX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <4 x float>, align 16
// CHECK-NEXT:    store ptr [[M]], ptr [[M_ADDR]], align 4
// CHECK-NEXT:    store i32 [[INDEX]], ptr [[INDEX_ADDR]], align 4
// CHECK-NEXT:    store <4 x float> [[V]], ptr [[V_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x float>, ptr [[V_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3:![0-9]+]], !align [[META4:![0-9]+]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[INDEX_ADDR]], align 4
// CHECK-NEXT:    [[MATRIX_LOAD:%.*]] = load <16 x float>, ptr [[TMP1]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = add i32 0, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x float> [[TMP0]], i32 0
// CHECK-NEXT:    [[TMP5:%.*]] = insertelement <16 x float> [[MATRIX_LOAD]], float [[TMP4]], i32 [[TMP3]]
// CHECK-NEXT:    [[TMP6:%.*]] = add i32 4, [[TMP2]]
// CHECK-NEXT:    [[TMP7:%.*]] = extractelement <4 x float> [[TMP0]], i32 1
// CHECK-NEXT:    [[TMP8:%.*]] = insertelement <16 x float> [[TMP5]], float [[TMP7]], i32 [[TMP6]]
// CHECK-NEXT:    [[TMP9:%.*]] = add i32 8, [[TMP2]]
// CHECK-NEXT:    [[TMP10:%.*]] = extractelement <4 x float> [[TMP0]], i32 2
// CHECK-NEXT:    [[TMP11:%.*]] = insertelement <16 x float> [[TMP8]], float [[TMP10]], i32 [[TMP9]]
// CHECK-NEXT:    [[TMP12:%.*]] = add i32 12, [[TMP2]]
// CHECK-NEXT:    [[TMP13:%.*]] = extractelement <4 x float> [[TMP0]], i32 3
// CHECK-NEXT:    [[TMP14:%.*]] = insertelement <16 x float> [[TMP11]], float [[TMP13]], i32 [[TMP12]]
// CHECK-NEXT:    store <16 x float> [[TMP14]], ptr [[TMP1]], align 4
// CHECK-NEXT:    ret void
//
void setMatrix(out float4x4 M, int index, float4 V) {
    M[index] = V;
}

// CHECK-LABEL: define hidden void @_Z15setMatrixScalarRu11matrix_typeILm2ELm1EfEif(
// CHECK-SAME: ptr noalias noundef nonnull align 4 dereferenceable(8) [[M:%.*]], i32 noundef [[INDEX:%.*]], float noundef nofpclass(nan inf) [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M_ADDR:%.*]] = alloca ptr, align 4
// CHECK-NEXT:    [[INDEX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store ptr [[M]], ptr [[M_ADDR]], align 4
// CHECK-NEXT:    store i32 [[INDEX]], ptr [[INDEX_ADDR]], align 4
// CHECK-NEXT:    store float [[S]], ptr [[S_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[S_ADDR]], align 4
// CHECK-NEXT:    [[SPLAT_SPLATINSERT:%.*]] = insertelement <1 x float> poison, float [[TMP0]], i64 0
// CHECK-NEXT:    [[SPLAT_SPLAT:%.*]] = shufflevector <1 x float> [[SPLAT_SPLATINSERT]], <1 x float> poison, <1 x i32> zeroinitializer
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META4]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[INDEX_ADDR]], align 4
// CHECK-NEXT:    [[MATRIX_LOAD:%.*]] = load <2 x float>, ptr [[TMP1]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = add i32 0, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = extractelement <1 x float> [[SPLAT_SPLAT]], i32 0
// CHECK-NEXT:    [[TMP5:%.*]] = insertelement <2 x float> [[MATRIX_LOAD]], float [[TMP4]], i32 [[TMP3]]
// CHECK-NEXT:    store <2 x float> [[TMP5]], ptr [[TMP1]], align 4
// CHECK-NEXT:    ret void
//
void setMatrixScalar(out float2x1 M, int index, float S) {
    M[index] = S;
}

// CHECK-LABEL: define hidden void @_Z19setMatrixConstIndexRu11matrix_typeILm4ELm4EiES_(
// CHECK-SAME: ptr noalias noundef nonnull align 4 dereferenceable(64) [[M:%.*]], <16 x i32> noundef [[N:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M_ADDR:%.*]] = alloca ptr, align 4
// CHECK-NEXT:    [[N_ADDR:%.*]] = alloca [16 x i32], align 4
// CHECK-NEXT:    store ptr [[M]], ptr [[M_ADDR]], align 4
// CHECK-NEXT:    store <16 x i32> [[N]], ptr [[N_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load <16 x i32>, ptr [[N_ADDR]], align 4
// CHECK-NEXT:    [[MATRIX_ELEM:%.*]] = extractelement <16 x i32> [[TMP0]], i32 3
// CHECK-NEXT:    [[MATRIX_ROW_INS:%.*]] = insertelement <4 x i32> poison, i32 [[MATRIX_ELEM]], i32 0
// CHECK-NEXT:    [[MATRIX_ELEM1:%.*]] = extractelement <16 x i32> [[TMP0]], i32 7
// CHECK-NEXT:    [[MATRIX_ROW_INS2:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS]], i32 [[MATRIX_ELEM1]], i32 1
// CHECK-NEXT:    [[MATRIX_ELEM3:%.*]] = extractelement <16 x i32> [[TMP0]], i32 11
// CHECK-NEXT:    [[MATRIX_ROW_INS4:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS2]], i32 [[MATRIX_ELEM3]], i32 2
// CHECK-NEXT:    [[MATRIX_ELEM5:%.*]] = extractelement <16 x i32> [[TMP0]], i32 15
// CHECK-NEXT:    [[MATRIX_ROW_INS6:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS4]], i32 [[MATRIX_ELEM5]], i32 3
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META4]]
// CHECK-NEXT:    store <4 x i32> [[MATRIX_ROW_INS6]], ptr [[TMP1]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load <16 x i32>, ptr [[N_ADDR]], align 4
// CHECK-NEXT:    [[MATRIX_ELEM7:%.*]] = extractelement <16 x i32> [[TMP2]], i32 2
// CHECK-NEXT:    [[MATRIX_ROW_INS8:%.*]] = insertelement <4 x i32> poison, i32 [[MATRIX_ELEM7]], i32 0
// CHECK-NEXT:    [[MATRIX_ELEM9:%.*]] = extractelement <16 x i32> [[TMP2]], i32 6
// CHECK-NEXT:    [[MATRIX_ROW_INS10:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS8]], i32 [[MATRIX_ELEM9]], i32 1
// CHECK-NEXT:    [[MATRIX_ELEM11:%.*]] = extractelement <16 x i32> [[TMP2]], i32 10
// CHECK-NEXT:    [[MATRIX_ROW_INS12:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS10]], i32 [[MATRIX_ELEM11]], i32 2
// CHECK-NEXT:    [[MATRIX_ELEM13:%.*]] = extractelement <16 x i32> [[TMP2]], i32 14
// CHECK-NEXT:    [[MATRIX_ROW_INS14:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS12]], i32 [[MATRIX_ELEM13]], i32 3
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META4]]
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr <16 x i32>, ptr [[TMP3]], i32 0, i32 4
// CHECK-NEXT:    store <4 x i32> [[MATRIX_ROW_INS14]], ptr [[TMP4]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = load <16 x i32>, ptr [[N_ADDR]], align 4
// CHECK-NEXT:    [[MATRIX_ELEM15:%.*]] = extractelement <16 x i32> [[TMP5]], i32 1
// CHECK-NEXT:    [[MATRIX_ROW_INS16:%.*]] = insertelement <4 x i32> poison, i32 [[MATRIX_ELEM15]], i32 0
// CHECK-NEXT:    [[MATRIX_ELEM17:%.*]] = extractelement <16 x i32> [[TMP5]], i32 5
// CHECK-NEXT:    [[MATRIX_ROW_INS18:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS16]], i32 [[MATRIX_ELEM17]], i32 1
// CHECK-NEXT:    [[MATRIX_ELEM19:%.*]] = extractelement <16 x i32> [[TMP5]], i32 9
// CHECK-NEXT:    [[MATRIX_ROW_INS20:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS18]], i32 [[MATRIX_ELEM19]], i32 2
// CHECK-NEXT:    [[MATRIX_ELEM21:%.*]] = extractelement <16 x i32> [[TMP5]], i32 13
// CHECK-NEXT:    [[MATRIX_ROW_INS22:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS20]], i32 [[MATRIX_ELEM21]], i32 3
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META4]]
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <16 x i32>, ptr [[TMP6]], i32 0, i32 8
// CHECK-NEXT:    store <4 x i32> [[MATRIX_ROW_INS22]], ptr [[TMP7]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = load <16 x i32>, ptr [[N_ADDR]], align 4
// CHECK-NEXT:    [[MATRIX_ELEM23:%.*]] = extractelement <16 x i32> [[TMP8]], i32 0
// CHECK-NEXT:    [[MATRIX_ROW_INS24:%.*]] = insertelement <4 x i32> poison, i32 [[MATRIX_ELEM23]], i32 0
// CHECK-NEXT:    [[MATRIX_ELEM25:%.*]] = extractelement <16 x i32> [[TMP8]], i32 4
// CHECK-NEXT:    [[MATRIX_ROW_INS26:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS24]], i32 [[MATRIX_ELEM25]], i32 1
// CHECK-NEXT:    [[MATRIX_ELEM27:%.*]] = extractelement <16 x i32> [[TMP8]], i32 8
// CHECK-NEXT:    [[MATRIX_ROW_INS28:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS26]], i32 [[MATRIX_ELEM27]], i32 2
// CHECK-NEXT:    [[MATRIX_ELEM29:%.*]] = extractelement <16 x i32> [[TMP8]], i32 12
// CHECK-NEXT:    [[MATRIX_ROW_INS30:%.*]] = insertelement <4 x i32> [[MATRIX_ROW_INS28]], i32 [[MATRIX_ELEM29]], i32 3
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META4]]
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr <16 x i32>, ptr [[TMP9]], i32 0, i32 12
// CHECK-NEXT:    store <4 x i32> [[MATRIX_ROW_INS30]], ptr [[TMP10]], align 4
// CHECK-NEXT:    ret void
//
void setMatrixConstIndex(out int4x4 M, int4x4 N ) {
    M[0] = N[3];
    M[1] = N[2];
    M[2] = N[1];
    M[3] = N[0];
}

// CHECK-LABEL: define hidden void @_Z27getDoubleVecFromTemplateMatRu11matrix_typeILm2ELm3EdEiDv3_d(
// CHECK-SAME: ptr noalias noundef nonnull align 8 dereferenceable(48) [[M:%.*]], i32 noundef [[INDEX:%.*]], <3 x double> noundef nofpclass(nan inf) [[V:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M_ADDR:%.*]] = alloca ptr, align 4
// CHECK-NEXT:    [[INDEX_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <3 x double>, align 32
// CHECK-NEXT:    store ptr [[M]], ptr [[M_ADDR]], align 4
// CHECK-NEXT:    store i32 [[INDEX]], ptr [[INDEX_ADDR]], align 4
// CHECK-NEXT:    store <3 x double> [[V]], ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TMP0:%.*]] = load <3 x double>, ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META5:![0-9]+]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[INDEX_ADDR]], align 4
// CHECK-NEXT:    [[MATRIX_LOAD:%.*]] = load <6 x double>, ptr [[TMP1]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = add i32 0, [[TMP2]]
// CHECK-NEXT:    [[TMP4:%.*]] = extractelement <3 x double> [[TMP0]], i32 0
// CHECK-NEXT:    [[TMP5:%.*]] = insertelement <6 x double> [[MATRIX_LOAD]], double [[TMP4]], i32 [[TMP3]]
// CHECK-NEXT:    [[TMP6:%.*]] = add i32 2, [[TMP2]]
// CHECK-NEXT:    [[TMP7:%.*]] = extractelement <3 x double> [[TMP0]], i32 1
// CHECK-NEXT:    [[TMP8:%.*]] = insertelement <6 x double> [[TMP5]], double [[TMP7]], i32 [[TMP6]]
// CHECK-NEXT:    [[TMP9:%.*]] = add i32 4, [[TMP2]]
// CHECK-NEXT:    [[TMP10:%.*]] = extractelement <3 x double> [[TMP0]], i32 2
// CHECK-NEXT:    [[TMP11:%.*]] = insertelement <6 x double> [[TMP8]], double [[TMP10]], i32 [[TMP9]]
// CHECK-NEXT:    store <6 x double> [[TMP11]], ptr [[TMP1]], align 8
// CHECK-NEXT:    ret void
//
void getDoubleVecFromTemplateMat(out matrix<double, 2, 3> M, int index, double3 V) {
    M[index] = V;
}

// CHECK-LABEL: define hidden void @_Z27getDoubleVecFromTemplateMatRu11matrix_typeILm2ELm3EdEDv3_d(
// CHECK-SAME: ptr noalias noundef nonnull align 8 dereferenceable(48) [[M:%.*]], <3 x double> noundef nofpclass(nan inf) [[V:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M_ADDR:%.*]] = alloca ptr, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <3 x double>, align 32
// CHECK-NEXT:    store ptr [[M]], ptr [[M_ADDR]], align 4
// CHECK-NEXT:    store <3 x double> [[V]], ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TMP0:%.*]] = load <3 x double>, ptr [[V_ADDR]], align 32
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META5]]
// CHECK-NEXT:    store <3 x double> [[TMP0]], ptr [[TMP1]], align 8
// CHECK-NEXT:    ret void
//
void getDoubleVecFromTemplateMat(out matrix<double, 2, 3> M, double3 V) {
    M[0] = V;
}

//.
// CHECK: [[META3]] = !{}
// CHECK: [[META4]] = !{i64 4}
// CHECK: [[META5]] = !{i64 8}
//.
