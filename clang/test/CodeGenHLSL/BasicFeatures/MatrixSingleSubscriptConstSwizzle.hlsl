// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 6
// RUN: %clang_cc1 -triple dxil-pc-shadermodel6.7-library -disable-llvm-passes -emit-llvm -finclude-default-header -o - %s | FileCheck %s

// BUG: https://github.com/llvm/llvm-project/issues/172805
// XFAIL: *

// CHECK-LABEL: define hidden void @_Z10setMatrix1Ru11matrix_typeILm4ELm4EfEDv4_f(
// CHECK-SAME: ptr noalias noundef nonnull align 4 dereferenceable(64) [[M:%.*]], <4 x float> noundef nofpclass(nan inf) [[V:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M_ADDR:%.*]] = alloca ptr, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <4 x float>, align 16
// CHECK-NEXT:    store ptr [[M]], ptr [[M_ADDR]], align 4
// CHECK-NEXT:    store <4 x float> [[V]], ptr [[V_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x float>, ptr [[V_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3:![0-9]+]], !align [[META4:![0-9]+]]
// CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x float> [[TMP0]], i32 0
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr <16 x float>, ptr [[TMP1]], i32 0, i32 15
// CHECK-NEXT:    store float [[TMP2]], ptr [[TMP3]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x float> [[TMP0]], i32 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr <16 x float>, ptr [[TMP1]], i32 0, i32 11
// CHECK-NEXT:    store float [[TMP4]], ptr [[TMP5]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x float> [[TMP0]], i32 2
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <16 x float>, ptr [[TMP1]], i32 0, i32 7
// CHECK-NEXT:    store float [[TMP6]], ptr [[TMP7]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = extractelement <4 x float> [[TMP0]], i32 3
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <16 x float>, ptr [[TMP1]], i32 0, i32 3
// CHECK-NEXT:    store float [[TMP8]], ptr [[TMP9]], align 4
// CHECK-NEXT:    ret void
//
void setMatrix1(out float4x4 M, float4 V) {
    M[3].abgr = V;
}

// CHECK-LABEL: define hidden void @_Z10setMatrix2Ru11matrix_typeILm4ELm4EiEDv4_i(
// CHECK-SAME: ptr noalias noundef nonnull align 4 dereferenceable(64) [[M:%.*]], <4 x i32> noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[M_ADDR:%.*]] = alloca ptr, align 4
// CHECK-NEXT:    [[V_ADDR:%.*]] = alloca <4 x i32>, align 16
// CHECK-NEXT:    store ptr [[M]], ptr [[M_ADDR]], align 4
// CHECK-NEXT:    store <4 x i32> [[V]], ptr [[V_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[V_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[M_ADDR]], align 4, !nonnull [[META3]], !align [[META4]]
// CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i32> [[TMP0]], i32 0
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr <16 x i32>, ptr [[TMP1]], i32 0, i32 2
// CHECK-NEXT:    store i32 [[TMP2]], ptr [[TMP3]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x i32> [[TMP0]], i32 1
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr <16 x i32>, ptr [[TMP1]], i32 0, i32 6
// CHECK-NEXT:    store i32 [[TMP4]], ptr [[TMP5]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x i32> [[TMP0]], i32 2
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <16 x i32>, ptr [[TMP1]], i32 0, i32 10
// CHECK-NEXT:    store i32 [[TMP6]], ptr [[TMP7]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = extractelement <4 x i32> [[TMP0]], i32 3
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <16 x i32>, ptr [[TMP1]], i32 0, i32 14
// CHECK-NEXT:    store i32 [[TMP8]], ptr [[TMP9]], align 4
// CHECK-NEXT:    ret void
//
void setMatrix2(out int4x4 M, int4 V) {
    M[2].rgba = V;
}
//.
// CHECK: [[META3]] = !{}
// CHECK: [[META4]] = !{i64 4}
//.
