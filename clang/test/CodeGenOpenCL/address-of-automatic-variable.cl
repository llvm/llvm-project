// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -O0 -cl-std=CL2.0 -finclude-default-header -fdeclare-opencl-builtins -triple x86_64-unknown-linux-gnu -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -cl-std=CL2.0 -finclude-default-header -fdeclare-opencl-builtins -triple amdgcn-amd-amdhsa -emit-llvm %s -o - | FileCheck -check-prefixes=AMDGCN %s

// CHECK-LABEL: define dso_local zeroext i1 @helperFunction(
// CHECK-SAME: ptr noundef [[PPPP:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i1, align 1
// CHECK-NEXT:    [[PPPP_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[PPPP]], ptr [[PPPP_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PPPP_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr @__to_private(ptr [[TMP0]])
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq ptr [[TMP1]], null
// CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
// CHECK:       [[IF_THEN]]:
// CHECK-NEXT:    store i1 false, ptr [[RETVAL]], align 1
// CHECK-NEXT:    br label %[[RETURN:.*]]
// CHECK:       [[IF_END]]:
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[PPPP_ADDR]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[TMP2]], align 8
// CHECK-NEXT:    [[CMP1:%.*]] = icmp ne i64 [[TMP3]], 5
// CHECK-NEXT:    br i1 [[CMP1]], label %[[IF_THEN2:.*]], label %[[IF_END3:.*]]
// CHECK:       [[IF_THEN2]]:
// CHECK-NEXT:    store i1 false, ptr [[RETVAL]], align 1
// CHECK-NEXT:    br label %[[RETURN]]
// CHECK:       [[IF_END3]]:
// CHECK-NEXT:    store i1 true, ptr [[RETVAL]], align 1
// CHECK-NEXT:    br label %[[RETURN]]
// CHECK:       [[RETURN]]:
// CHECK-NEXT:    [[TMP4:%.*]] = load i1, ptr [[RETVAL]], align 1
// CHECK-NEXT:    ret i1 [[TMP4]]
//
// AMDGCN-LABEL: define dso_local zeroext i1 @helperFunction(
// AMDGCN-SAME: ptr noundef [[PPPP:%.*]]) #[[ATTR0:[0-9]+]] {
// AMDGCN-NEXT:  [[ENTRY:.*:]]
// AMDGCN-NEXT:    [[RETVAL:%.*]] = alloca i1, align 1, addrspace(5)
// AMDGCN-NEXT:    [[PPPP_ADDR:%.*]] = alloca ptr, align 8, addrspace(5)
// AMDGCN-NEXT:    store ptr [[PPPP]], ptr addrspace(5) [[PPPP_ADDR]], align 8
// AMDGCN-NEXT:    [[TMP0:%.*]] = load ptr, ptr addrspace(5) [[PPPP_ADDR]], align 8
// AMDGCN-NEXT:    [[TMP1:%.*]] = call ptr addrspace(5) @__to_private(ptr [[TMP0]])
// AMDGCN-NEXT:    [[CMP:%.*]] = icmp eq ptr addrspace(5) [[TMP1]], addrspacecast (ptr null to ptr addrspace(5))
// AMDGCN-NEXT:    br i1 [[CMP]], label %[[IF_THEN:.*]], label %[[IF_END:.*]]
// AMDGCN:       [[IF_THEN]]:
// AMDGCN-NEXT:    store i1 false, ptr addrspace(5) [[RETVAL]], align 1
// AMDGCN-NEXT:    br label %[[RETURN:.*]]
// AMDGCN:       [[IF_END]]:
// AMDGCN-NEXT:    [[TMP2:%.*]] = load ptr, ptr addrspace(5) [[PPPP_ADDR]], align 8
// AMDGCN-NEXT:    [[TMP3:%.*]] = load i64, ptr [[TMP2]], align 8
// AMDGCN-NEXT:    [[CMP1:%.*]] = icmp ne i64 [[TMP3]], 5
// AMDGCN-NEXT:    br i1 [[CMP1]], label %[[IF_THEN2:.*]], label %[[IF_END3:.*]]
// AMDGCN:       [[IF_THEN2]]:
// AMDGCN-NEXT:    store i1 false, ptr addrspace(5) [[RETVAL]], align 1
// AMDGCN-NEXT:    br label %[[RETURN]]
// AMDGCN:       [[IF_END3]]:
// AMDGCN-NEXT:    store i1 true, ptr addrspace(5) [[RETVAL]], align 1
// AMDGCN-NEXT:    br label %[[RETURN]]
// AMDGCN:       [[RETURN]]:
// AMDGCN-NEXT:    [[TMP4:%.*]] = load i1, ptr addrspace(5) [[RETVAL]], align 1
// AMDGCN-NEXT:    ret i1 [[TMP4]]
//
bool helperFunction(long *pppp) {
  if (to_private(pppp) == NULL) {
    return false;
  }
  if (*pppp != 5) {
    return false;
  }
  return true;
}

// CHECK-LABEL: define dso_local spir_kernel void @testKernel(
// CHECK-SAME: ptr noundef align 4 [[RESULTS:%.*]]) #[[ATTR1:[0-9]+]] !kernel_arg_addr_space [[META3:![0-9]+]] !kernel_arg_access_qual [[META4:![0-9]+]] !kernel_arg_type [[META5:![0-9]+]] !kernel_arg_base_type [[META5]] !kernel_arg_type_qual [[META6:![0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[RESULTS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[VVVV:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[PPPP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TID:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[RESULTS]], ptr [[RESULTS_ADDR]], align 8
// CHECK-NEXT:    store i64 5, ptr [[VVVV]], align 8
// CHECK-NEXT:    store ptr [[VVVV]], ptr [[PPPP]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call i64 @_Z13get_global_idj(i32 noundef 0) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[CALL]] to i32
// CHECK-NEXT:    store i32 [[CONV]], ptr [[TID]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PPPP]], align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call zeroext i1 @helperFunction(ptr noundef [[TMP0]]) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    [[CONV2:%.*]] = zext i1 [[CALL1]] to i32
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[RESULTS_ADDR]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TID]], align 4
// CHECK-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP2]] to i64
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i32, ptr [[TMP1]], i64 [[IDXPROM]]
// CHECK-NEXT:    store i32 [[CONV2]], ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret void
//
// AMDGCN-LABEL: define dso_local amdgpu_kernel void @testKernel(
// AMDGCN-SAME: ptr addrspace(1) noundef align 4 [[RESULTS:%.*]]) #[[ATTR1:[0-9]+]] !kernel_arg_addr_space [[META4:![0-9]+]] !kernel_arg_access_qual [[META5:![0-9]+]] !kernel_arg_type [[META6:![0-9]+]] !kernel_arg_base_type [[META6]] !kernel_arg_type_qual [[META7:![0-9]+]] {
// AMDGCN-NEXT:  [[ENTRY:.*:]]
// AMDGCN-NEXT:    [[RESULTS_ADDR:%.*]] = alloca ptr addrspace(1), align 8, addrspace(5)
// AMDGCN-NEXT:    [[VVVV:%.*]] = alloca i64, align 8, addrspace(5)
// AMDGCN-NEXT:    [[PPPP:%.*]] = alloca ptr addrspace(5), align 4, addrspace(5)
// AMDGCN-NEXT:    [[TID:%.*]] = alloca i32, align 4, addrspace(5)
// AMDGCN-NEXT:    store ptr addrspace(1) [[RESULTS]], ptr addrspace(5) [[RESULTS_ADDR]], align 8
// AMDGCN-NEXT:    store i64 5, ptr addrspace(5) [[VVVV]], align 8
// AMDGCN-NEXT:    store ptr addrspace(5) [[VVVV]], ptr addrspace(5) [[PPPP]], align 4
// AMDGCN-NEXT:    [[CALL:%.*]] = call i64 @_Z13get_global_idj(i32 noundef 0) #[[ATTR3:[0-9]+]]
// AMDGCN-NEXT:    [[CONV:%.*]] = trunc i64 [[CALL]] to i32
// AMDGCN-NEXT:    store i32 [[CONV]], ptr addrspace(5) [[TID]], align 4
// AMDGCN-NEXT:    [[TMP0:%.*]] = load ptr addrspace(5), ptr addrspace(5) [[PPPP]], align 4
// AMDGCN-NEXT:    [[TMP1:%.*]] = addrspacecast ptr addrspace(5) [[TMP0]] to ptr
// AMDGCN-NEXT:    [[CALL1:%.*]] = call zeroext i1 @helperFunction(ptr noundef [[TMP1]]) #[[ATTR4:[0-9]+]]
// AMDGCN-NEXT:    [[CONV2:%.*]] = zext i1 [[CALL1]] to i32
// AMDGCN-NEXT:    [[TMP2:%.*]] = load ptr addrspace(1), ptr addrspace(5) [[RESULTS_ADDR]], align 8
// AMDGCN-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(5) [[TID]], align 4
// AMDGCN-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP3]] to i64
// AMDGCN-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i32, ptr addrspace(1) [[TMP2]], i64 [[IDXPROM]]
// AMDGCN-NEXT:    store i32 [[CONV2]], ptr addrspace(1) [[ARRAYIDX]], align 4
// AMDGCN-NEXT:    ret void
//
__kernel void testKernel(__global uint *results) {
  long vvvv = 5;
  __private long *pppp = &vvvv;

  uint tid = get_global_id(0);
  results[tid] = helperFunction(pppp);
}
//.
// CHECK: [[META3]] = !{i32 1}
// CHECK: [[META4]] = !{!"none"}
// CHECK: [[META5]] = !{!"uint*"}
// CHECK: [[META6]] = !{!""}
//.
// AMDGCN: [[META4]] = !{i32 1}
// AMDGCN: [[META5]] = !{!"none"}
// AMDGCN: [[META6]] = !{!"uint*"}
// AMDGCN: [[META7]] = !{!""}
//.
