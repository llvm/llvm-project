// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --prefix-filecheck-ir-name TMP_

// RUN: %clang_cc1 -O0 -triple x86_64 -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple x86_64 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

struct flex {
	unsigned char count;
	unsigned elems[__counted_by(count - 1)];
};

// CHECK-LABEL: @var_decl(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[F:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr null, ptr [[F]], align 8
// CHECK-NEXT:    ret void
//
void var_decl(void) {
	struct flex *__single f = 0;
}

// CHECK-LABEL: @assign(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[F:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr null, ptr [[F]], align 8, {{!annotation ![0-9]+}}
// CHECK-NEXT:    store ptr null, ptr [[F]], align 8
// CHECK-NEXT:    ret void
//
void assign(void) {
	struct flex *__single f;
	f = 0;
}

// CHECK-LABEL: @return_flex(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr null
//
struct flex *return_flex(void) {
   return 0;
}

void take_flex(struct flex *f);

// CHECK-LABEL: @give_flex(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @take_flex(ptr noundef null)
// CHECK-NEXT:    ret void
//
void give_flex(void) {
  take_flex(0);
}
