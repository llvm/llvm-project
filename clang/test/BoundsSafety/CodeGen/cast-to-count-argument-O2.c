// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"


// RUN: %clang_cc1 -O2  -fbounds-safety -triple x86_64 -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2  -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -triple x86_64 -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

typedef struct {
    int len;
    int *__counted_by(len) buf;
} S;

void Foo(int *__counted_by(len) buf, int len);
void Bar(int *__counted_by(10) ptr);

// CHECK-LABEL: @TestZeroCount(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestZeroCount(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    S s;
    s.len = 0;
    s.buf = end_ptr; // okay
}

// CHECK-LABEL: @TestCountPtrArgFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestCountPtrArgFail(void) {
    int arr[10];
    int *end_ptr = arr + 9;

    Foo(end_ptr, 10); // trap
}

// CHECK-LABEL: @TestCountPtrArgFail2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestCountPtrArgFail2(void) {
  int arr[10];
  int *end_ptr = arr + 11;

  Foo(end_ptr, 10); // trap
}

// CHECK-LABEL: @TestCountPtrArgFail3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestCountPtrArgFail3(void) {
  int arr[10];
  int n = 12;
  Foo(arr, n); // trap
}

// CHECK-LABEL: @TestCountPtrArgOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[ARR]]) #[[ATTR7:[0-9]+]]
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 40
// CHECK-NEXT:    call void @Foo(ptr noundef nonnull [[UPPER]], i32 noundef 0) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void TestCountPtrArgOK(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    Foo(end_ptr, 0); // ok
}

// CHECK-LABEL: @TestCountPtrArgOK2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 36
// CHECK-NEXT:    call void @Foo(ptr noundef nonnull [[BOUND_PTR_ARITH]], i32 noundef 1) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void TestCountPtrArgOK2(void) {
    int arr[10];
    int *end_ptr = arr + 9;

    Foo(end_ptr, 1); // ok
}

// CHECK-LABEL: @TestConstCountPtrArgFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestConstCountPtrArgFail(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    Bar(({end_ptr;})); // trap
}

// CHECK-LABEL: @TestConstCountPtrArgOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    call void @Bar(ptr noundef nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void TestConstCountPtrArgOK(void) {
    int arr[10];
    int *end_ptr = arr;

    Bar(({end_ptr;})); // ok
}

// CHECK-LABEL: @TestConstZeroCountOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestConstZeroCountOK(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    int *__counted_by(0) zero_buf;
    zero_buf = end_ptr; // ok
}

// CHECK-LABEL: @TestBidiOverBounds(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestBidiOverBounds() {
    int arr[10];
    Foo(arr + 11, 10);
}

// XXX: unexpectedly this still has a bounds check
// CHECK-LABEL: @TestBidiUnderBounds(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 40
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[ARR]], i64 -4
// CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp ugt ptr [[BOUND_PTR_ARITH]], [[UPPER]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[CMP27_NOT:%.*]] = icmp ugt ptr [[ARR]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP_NOT]], [[CMP27_NOT]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont:
// CHECK-NEXT:    call void @Foo(ptr noundef [[BOUND_PTR_ARITH]], i32 noundef 10) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void TestBidiUnderBounds() {
    int arr[10];
    Foo(arr - 1, 10);
}

// XXX: this might be just fine not to trap
// CHECK-LABEL: @TestConstZeroCountFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestConstZeroCountFail(void) {
    int arr[10];
    int *end_ptr = arr + 11;

    int *__counted_by(0) zero_buf;
    zero_buf = end_ptr; // trap
}
