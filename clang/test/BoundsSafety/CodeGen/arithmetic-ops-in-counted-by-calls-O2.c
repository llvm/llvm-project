// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"

// RUN: %clang_cc1 -O2  -fbounds-safety -triple arm64e-apple-iphoneos -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2  -fbounds-safety -triple arm64e-apple-iphoneos -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>
#include <stddef.h>

inline void param_with_count(int *__counted_by(len - 2) buf, int len) {}

// CHECK-LABEL: @count_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void count_ok(void) {
  int arr[10];
  param_with_count(arr, 12);
}

// CHECK-LABEL: @negative_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
void negative_count_trap(void) {
  int arr[10];
  int len = 0;
  param_with_count(arr, len);
}

// CHECK-LABEL: @too_big_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
void too_big_count_trap(void) {
  int arr[10];
  int n = 13;
  param_with_count(arr, n);
}

inline void param_with_unsigned_count(int *__counted_by(len - 2) buf, size_t len) {}

// CHECK-LABEL: @overflow_unsigned_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
void overflow_unsigned_count_trap(void) {
  int arr[10];
  int n = 0;
  param_with_unsigned_count(arr, n);
}

void *__sized_by(count * size) return_buf(size_t count, size_t size);

// CHECK-LABEL: @returned_buf_ok(
// CHECK-NEXT:  cont8:
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @return_buf(i64 noundef 4, i64 noundef 5) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[CALL]], i64 19
// CHECK-NEXT:    store i8 0, ptr [[TMP0]], align 1, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    ret void
//
void returned_buf_ok(void) {
  char *p = return_buf(4, 5);
  p[19] = 0;
}

// CHECK-LABEL: @oob_returned_buf_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @return_buf(i64 noundef 4, i64 noundef 5) #[[ATTR6]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
void oob_returned_buf_trap(void) {
  char *p = return_buf(4, 5);
  p[20] = 0;
}

// CHECK-LABEL: @overflow_returned_buf_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @return_buf(i64 noundef -1, i64 noundef -1) #[[ATTR6]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
void overflow_returned_buf_trap(void) {
  char *p = return_buf(__SIZE_MAX__, __SIZE_MAX__);
  p[1] = 0;
}

// CHECK-LABEL: @overflow_returned_buf_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @return_buf(i64 noundef -1, i64 noundef -1) #[[ATTR6]]
// CHECK-NEXT:    store i8 0, ptr [[CALL]], align 1, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    ret void
//
void overflow_returned_buf_ok(void) {
  char *p = return_buf(__SIZE_MAX__, __SIZE_MAX__);
  p[0] = 0;
}

// CHECK-LABEL: @too_big_returned_buf_undef(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @return_buf(i64 noundef -1, i64 noundef 1) #[[ATTR6]]
// CHECK-NEXT:    unreachable
//
void too_big_returned_buf_undef(void) {
  char *p = return_buf(__SIZE_MAX__, 1);
  p[0] = 0;
}

// XXX: In this case, the count argument already violates the assumption that the offset doesn't overflow in a signed sense.
// This should actually be caught already when the count is assigned in side the callee, but if the callee's definition is
// not -fbounds-safety'ed, there's not much we can do here. 
// CHECK-LABEL: @index_overflow_returned_buf_fixme(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @return_buf(i64 noundef 9223372036854775807, i64 noundef 1) #[[ATTR6]]
// CHECK-NEXT:    store i8 0, ptr [[CALL]], align 1, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    ret void
//
void index_overflow_returned_buf_fixme(void) {
  char *p = return_buf(__SIZE_MAX__ >> 1, 1);
  p[0] = 0;
}
