// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --prefix-filecheck-ir-name TMP_

// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s
#include <ptrcheck.h>
struct S {
    int *__ended_by(end) iter;
    int *end;
    int *__ended_by(iter) start;
};

void foo(void);

// CHECK-LABEL: @TestRangeOK1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestRangeOK1(void) {
  int arr[10];
  struct S s;
  s.start = arr;
  s.iter = arr;
  s.end = arr + 1;
}

// CHECK-LABEL: @TestRangeOK2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestRangeOK2(void) {
  int arr[10];
  struct S s;
  s.start = arr;
  s.iter = arr;
  s.end = arr;
}

// CHECK-LABEL: @TestRangeOK3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestRangeOK3(void) {
  int arr[10];
  struct S s;
  s.start = arr;
  s.iter = arr + 10;
  s.end = arr + 10;
}

// CHECK-LABEL: @TestRangeOK4(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestRangeOK4(void) {
  int arr[10];
  struct S s;
  s.start = arr + 10;
  s.iter = arr + 10;
  s.end = arr + 10;
}

// CHECK-LABEL: @TestIterFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH8:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 40
// CHECK-NEXT:    tail call void @foo() #[[ATTR6]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH60:%.*]] = getelementptr i8, ptr [[ARR]], i64 -4
// CHECK-NEXT:    [[CMP80_NOT:%.*]] = icmp ugt ptr [[BOUND_PTR_ARITH60]], [[BOUND_PTR_ARITH8]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[CMP95_NOT:%.*]] = icmp ugt ptr [[ARR]], [[BOUND_PTR_ARITH60]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP80_NOT]], [[CMP95_NOT]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT96:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR7:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont96:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void TestIterFail(void) {
    int arr[10];
    struct S s;
    s.start = arr;
    s.iter = arr + 2;
    s.end = arr + 10;
    foo();
    s.start = s.start;
    s.iter = s.iter - 3; // is prevented since s.iter - 3 < s.start
    s.end = s.end;
}

// XXX: Why this can be optimized when the next case can't?
// CHECK-LABEL: @TestStartFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestStartFail(void) {
  int arr[10];
  struct S s;
  s.start = arr - 1;
  s.iter = arr;
  s.end = arr + 1;
}

// CHECK-LABEL: @TestEndFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    [[UPPER3:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 40
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[ARR]], i64 44
// CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp ugt ptr [[BOUND_PTR_ARITH]], [[UPPER3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[CMP25_NOT:%.*]] = icmp ugt ptr [[ARR]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP_NOT]], [[CMP25_NOT]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT48:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont48:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void TestEndFail(void) {
  int arr[10];
  struct S s;
  s.start = arr;
  s.iter = arr;
  s.end = arr + 11;
}

// CHECK-LABEL: @TestRangeFail1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestRangeFail1(void) {
  int arr[10];
  struct S s;
  s.start = arr + 1;
  s.iter = arr;
  s.end = arr + 1;
}

// CHECK-LABEL: @TestRangeFail2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestRangeFail2(void) {
  int arr[10];
  struct S s;
  s.start = arr + 1;
  s.iter = arr + 2;
  s.end = arr + 1;
}

// CHECK-LABEL: @TestRangeFail3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestRangeFail3(void) {
  int arr[10];
  struct S s;
  s.start = arr - 1;
  s.iter = s.iter;
  s.end = s.end;
}

// CHECK-LABEL: @TestRangeFail4(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestRangeFail4(void) {
  int arr[10];
  struct S s;
  s.start = s.start;
  s.iter = s.iter;
  s.end = s.end + 1;
}
