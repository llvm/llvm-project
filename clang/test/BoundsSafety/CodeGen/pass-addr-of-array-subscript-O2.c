// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"


// RUN: %clang_cc1 -O2 -triple arm64e-apple-iphoneos -fbounds-safety -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK
// RUN: %clang_cc1 -O2 -triple arm64e-apple-iphoneos -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK

#include <ptrcheck.h>

void bar(void *__sized_by(len) buf, int len);

static void foo(int *__counted_by(len) elems, int len, int idx) {
  bar(&elems[idx], sizeof(elems[idx]));
}

// CHECK-LABEL: @oob(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void oob(void) {
  int arr[10];
  foo(arr, 10, 10);
}

// CHECK-LABEL: @oob2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 4
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    [[ADD_PTR_I:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 40
// CHECK-NEXT:    [[BOUND_PTR_ARITH_I:%.*]] = getelementptr i8, ptr [[ARR]], i64 -4, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[CMP_NOT_I:%.*]] = icmp ule ptr [[BOUND_PTR_ARITH_I]], [[ADD_PTR_I]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[CMP34_NOT_I:%.*]] = icmp ule ptr [[ARR]], [[BOUND_PTR_ARITH_I]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND_NOT76_I:%.*]] = and i1 [[CMP_NOT_I]], [[CMP34_NOT_I]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND_NOT76_I]], label [[FOO_EXIT:%.*]], label [[TRAP_I:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap.i:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       foo.exit:
// CHECK-NEXT:    call void @bar(ptr noundef [[BOUND_PTR_ARITH_I]], i32 noundef 4) #[[ATTR6]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void oob2(void) {
  int arr[10];
  foo(arr, 10, -1);
}


// CHECK-LABEL: @oob3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void oob3(void) {
  int arr[10];
  foo(arr, 10, 11);
}

// CHECK-LABEL: @good(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 4
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH_I:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 36, {{!annotation ![0-9]+}}
// CHECK-NEXT:    call void @bar(ptr noundef nonnull [[BOUND_PTR_ARITH_I]], i32 noundef 4) #[[ATTR6]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void good(void) {
  int arr[10];
  foo(arr, 10, 9);
}
