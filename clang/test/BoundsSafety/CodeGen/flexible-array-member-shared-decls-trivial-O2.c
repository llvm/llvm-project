// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5

// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -Wno-incompatible-pointer-types -emit-llvm %s -o - | FileCheck %s
// RN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

static char a[42];
static char b[42];

struct Inner {
    char * __counted_by(len) ptr;
    int len;
};
struct Outer {
    struct Inner hdr;
    char fam[__counted_by(hdr.len - sizeof(struct Inner))];
};

// CHECK-LABEL: define dso_local noundef nonnull ptr @good(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    store ptr @b, ptr @a, align 16, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    store i32 42, ptr getelementptr inbounds nuw (i8, ptr @a, i64 8), align 8, !tbaa [[TBAA8:![0-9]+]]
// CHECK-NEXT:    ret ptr @a
//
struct Outer * good(void) {
  struct Outer * p = a;
  p->hdr.ptr = b;
  p->hdr.len = 42;
  return p;
}

// CHECK-LABEL: define dso_local noundef nonnull ptr @good_recursive(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    store ptr @a, ptr @a, align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    store i32 42, ptr getelementptr inbounds nuw (i8, ptr @a, i64 8), align 8, !tbaa [[TBAA8]]
// CHECK-NEXT:    ret ptr @a
//
struct Outer * good_recursive(void) {
  struct Outer * p = a;
  p->hdr.ptr = p;
  p->hdr.len = 42;
  return p;
}

// CHECK-LABEL: define dso_local noundef nonnull ptr @good_margin(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    store ptr @b, ptr @a, align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    store i32 20, ptr getelementptr inbounds nuw (i8, ptr @a, i64 8), align 8, !tbaa [[TBAA8]]
// CHECK-NEXT:    ret ptr @a
//
struct Outer * good_margin(void) {
  struct Outer * p = a;
  p->hdr.ptr = b;
  p->hdr.len = 20;
  return p;
}

// CHECK-LABEL: define dso_local noundef nonnull ptr @good_no_fam(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    store ptr @b, ptr @a, align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    store i32 16, ptr getelementptr inbounds nuw (i8, ptr @a, i64 8), align 8, !tbaa [[TBAA8]]
// CHECK-NEXT:    ret ptr @a
//
struct Outer * good_no_fam(void) {
  struct Outer * p = a;
  p->hdr.ptr = b;
  p->hdr.len = 16;
  return p;
}

// CHECK-LABEL: define dso_local noalias noundef nonnull ptr @bad(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR2:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]], !annotation [[META9:![0-9]+]]
// CHECK-NEXT:    unreachable, !annotation [[META9]]
//
struct Outer * bad(void) {
  int len = 43;
  struct Outer * p = a;
  p->hdr.ptr = b;
  p->hdr.len = len;
  return p;
}

// CHECK-LABEL: define dso_local noalias noundef nonnull ptr @bad_neg_count(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR2]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    store ptr @b, ptr @a, align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    store i32 15, ptr getelementptr inbounds nuw (i8, ptr @a, i64 8), align 8, !tbaa [[TBAA8]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], !annotation [[META9]]
// CHECK-NEXT:    unreachable, !annotation [[META9]]
//
struct Outer * bad_neg_count(void) {
  struct Outer * p = a;
  p->hdr.ptr = b;
  p->hdr.len = 15; // fam has __counted_by(hdr.len - sizeof(struct Inner)), where sizeof(struct Inner) is 16
  return p;
}

// CHECK-LABEL: define dso_local noalias noundef nonnull ptr @bad_ptr(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR2]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], !annotation [[META9]]
// CHECK-NEXT:    unreachable, !annotation [[META9]]
//
struct Outer * bad_ptr(void) {
  struct Outer * p = a;
  p->hdr.ptr = b + 1;
  p->hdr.len = 42;
  return p;
}

// CHECK-LABEL: define dso_local noalias noundef nonnull ptr @bad_fam(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR2]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    store ptr @b, ptr getelementptr inbounds nuw (i8, ptr @a, i64 1), align 8, !tbaa [[TBAA2]]
// CHECK-NEXT:    store i32 42, ptr getelementptr inbounds nuw (i8, ptr @a, i64 9), align 8, !tbaa [[TBAA8]]
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], !annotation [[META9]]
// CHECK-NEXT:    unreachable, !annotation [[META9]]
//
struct Outer * bad_fam(void) {
  struct Outer * p = a + 1;
  p->hdr.ptr = b;
  p->hdr.len = 42;
  return p;
}
//.
// CHECK: [[TBAA2]] = !{[[META3:![0-9]+]], [[META4:![0-9]+]], i64 0}
// CHECK: [[META3]] = !{!"Inner", [[META4]], i64 0, [[META7:![0-9]+]], i64 8}
// CHECK: [[META4]] = !{!"p1 omnipotent char", [[META41:!.+]], i64 0}
// CHECK: [[META41]] = !{!"any pointer", [[META5:![0-9]+]], i64 0}
// CHECK: [[META5]] = !{!"omnipotent char", [[META6:![0-9]+]], i64 0}
// CHECK: [[META6]] = !{!"Simple C/C++ TBAA"}
// CHECK: [[META7]] = !{!"int", [[META5]], i64 0}
// CHECK: [[TBAA8]] = !{[[META3]], [[META7]], i64 8}
// CHECK: [[META9]] = !{!"bounds-safety-generic", !"bounds-safety-check-ptr-lt-upper-bound", !"bounds-safety-check-ptr-ge-lower-bound", !"bounds-safety-check-one-past-end-overflow", !"bounds-safety-check-ptr-le-upper-bound", !"bounds-safety-check-flexible-count-gt-bounds"}
//.
