// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"


// RUN: %clang_cc1 -emit-llvm -fbounds-safety -O0 -triple arm64 %s -o - | FileCheck %s
// RUN: %clang_cc1 -emit-llvm -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -O0 -triple arm64 %s -o - | FileCheck %s

#include <ptrcheck.h>

union Foo1 {
  int *__single foo__single;
  int b;
};

union Foo2 {
  int a;
  int *__indexable foo__indexable;
  int b;
};

union Foo3 {
  int *__single a;
  int *__single b;
  int *__single c;
};

// CHECK-LABEL: @main(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARGC_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[ARGV_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[F1:%.*]] = alloca [[UNION_FOO1:%.*]], align 8
// CHECK-NEXT:    [[F2:%.*]] = alloca [[UNION_FOO2:%.*]], align 8
// CHECK-NEXT:    [[F3:%.*]] = alloca [[UNION_FOO3:%.*]], align 8
// CHECK-NEXT:    store i32 [[ARGC:%.*]], ptr [[ARGC_ADDR]], align 4
// CHECK-NEXT:    store ptr [[ARGV:%.*]], ptr [[ARGV_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[F1]], i8 0, i64 8, i1 false), !annotation ![[ANNOT_BSS_ZEROINIT:[0-9]+]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[F2]], i8 0, i64 16, i1 false), !annotation ![[ANNOT_BSS_ZEROINIT]]
// CHECK-NEXT:    call void @llvm.memset.p0.i64(ptr align 8 [[F3]], i8 0, i64 8, i1 false), !annotation ![[ANNOT_BSS_ZEROINIT]]
// CHECK-NEXT:    ret i32 0
//
int main(int argc, char **argv) {
  union Foo1 f1;
  union Foo2 f2;
  union Foo3 f3;

// ...
// CHECK: ![[ANNOT_BSS_ZEROINIT]] = !{!"bounds-safety-zero-init"}
}
