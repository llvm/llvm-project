// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5


// RUN: %clang_cc1 -O2 -triple arm64-apple-iphoneos -fbounds-safety -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

struct Inner {
    int * __counted_by(len) ptr;
    int len;
};
struct Outer {
    struct Inner hdr;
    int fam[__counted_by(hdr.len)];
};

struct Outer * __sized_by(sizeof(struct Outer) + sizeof(int) * len) bar(int len);
int * __counted_by(len) baz(int len);

// CHECK-LABEL: define dso_local ptr @foo(
// CHECK-SAME: i32 noundef [[LEN:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @baz(i32 noundef [[LEN]]) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    [[IDX_EXT:%.*]] = sext i32 [[LEN]] to i64
// CHECK-NEXT:    [[CALL1:%.*]] = tail call ptr @bar(i32 noundef [[LEN]]) #[[ATTR4]]
// CHECK-NEXT:    [[MUL:%.*]] = shl nsw i64 [[IDX_EXT]], 2, !annotation [[META2:![0-9]+]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[LEN]], -5
// CHECK-NEXT:    tail call void @llvm.assume(i1 [[CMP]])
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[CALL1]], i64 [[MUL]]
// CHECK-NEXT:    [[ADD_PTR3:%.*]] = getelementptr i8, ptr [[TMP0]], i64 16
// CHECK-NEXT:    [[CMP9_NOT:%.*]] = icmp slt i32 [[LEN]], 0, !annotation [[META4:![0-9]+]]
// CHECK-NEXT:    br i1 [[CMP9_NOT]], label %[[TRAP:.*]], label %[[CONT:.*]], !annotation [[META4]]
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5:[0-9]+]], !annotation [[META5:![0-9]+]]
// CHECK-NEXT:    unreachable, !annotation [[META5]]
// CHECK:       [[CONT]]:
// CHECK-NEXT:    [[FLEX_BASE_NULL_CHECK_NOT:%.*]] = icmp eq ptr [[CALL1]], null, !annotation [[META6:![0-9]+]]
// CHECK-NEXT:    br i1 [[FLEX_BASE_NULL_CHECK_NOT]], label %[[CONT69:.*]], label %[[FLEX_BASE_NONNULL:.*]], !annotation [[META6]]
// CHECK:       [[FLEX_BASE_NONNULL]]:
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[CALL1]], i64 16
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[CALL1]], [[TMP1]], !annotation [[META7:![0-9]+]]
// CHECK-NEXT:    [[DOTNOT106:%.*]] = icmp ugt ptr [[CALL1]], [[TMP0]], !annotation [[META8:![0-9]+]]
// CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[DOTNOT]], i1 true, i1 [[DOTNOT106]], !annotation [[META8]]
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[TRAP]], label %[[CONT60:.*]], !annotation [[META7]]
// CHECK:       [[CONT60]]:
// CHECK-NEXT:    [[UPPER_INTPTR:%.*]] = ptrtoint ptr [[ADD_PTR3]] to i64, !annotation [[META9:![0-9]+]]
// CHECK-NEXT:    [[FAM_INTPTR:%.*]] = ptrtoint ptr [[TMP1]] to i64, !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT:%.*]] = sub nuw i64 [[UPPER_INTPTR]], [[FAM_INTPTR]], !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT_DIV:%.*]] = ashr exact i64 [[FLEX_AVAIL_COUNT]], 2, !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_COUNT_INTPTR:%.*]] = zext nneg i32 [[LEN]] to i64, !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_COUNT_CHECK_NOT:%.*]] = icmp uge i64 [[FLEX_AVAIL_COUNT_DIV]], [[FLEX_COUNT_INTPTR]], !annotation [[META9]]
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ult ptr [[CALL1]], [[ADD_PTR3]], !annotation [[META8]]
// CHECK-NEXT:    [[OR_COND108:%.*]] = select i1 [[FLEX_COUNT_CHECK_NOT]], i1 [[TMP2]], i1 false, !annotation [[META6]]
// CHECK-NEXT:    br i1 [[OR_COND108]], label %[[CONT69]], label %[[TRAP]], !annotation [[META9]]
// CHECK:       [[CONT69]]:
// CHECK-NEXT:    [[LEN70:%.*]] = getelementptr inbounds nuw i8, ptr [[CALL1]], i64 8
// CHECK-NEXT:    store i32 [[LEN]], ptr [[LEN70]], align 8, !tbaa [[TBAA10:![0-9]+]]
// CHECK-NEXT:    store ptr [[CALL]], ptr [[CALL1]], align 8, !tbaa [[TBAA16:![0-9]+]]
// CHECK-NEXT:    ret ptr [[CALL1]]
//
struct Outer *foo(int len) {
    int * p2 = baz(len);
    struct Outer * __single p = bar(len);
    p->hdr.len = len;
    p->hdr.ptr = p2;
    return p;
}

// CHECK-LABEL: define dso_local ptr @foo2(
// CHECK-SAME: i32 noundef [[LEN:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[CALL:%.*]] = tail call ptr @baz(i32 noundef [[LEN]]) #[[ATTR4]]
// CHECK-NEXT:    [[IDX_EXT:%.*]] = sext i32 [[LEN]] to i64
// CHECK-NEXT:    [[CALL1:%.*]] = tail call ptr @bar(i32 noundef [[LEN]]) #[[ATTR4]]
// CHECK-NEXT:    [[MUL:%.*]] = shl nsw i64 [[IDX_EXT]], 2, !annotation [[META2]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[LEN]], -5
// CHECK-NEXT:    tail call void @llvm.assume(i1 [[CMP]])
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[CALL1]], i64 [[MUL]]
// CHECK-NEXT:    [[ADD_PTR3:%.*]] = getelementptr i8, ptr [[TMP0]], i64 16
// CHECK-NEXT:    [[CMP9_NOT:%.*]] = icmp slt i32 [[LEN]], 0, !annotation [[META4]]
// CHECK-NEXT:    br i1 [[CMP9_NOT]], label %[[TRAP:.*]], label %[[CONT:.*]], !annotation [[META4]]
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR5]], !annotation [[META5]]
// CHECK-NEXT:    unreachable, !annotation [[META5]]
// CHECK:       [[CONT]]:
// CHECK-NEXT:    [[FLEX_BASE_NULL_CHECK_NOT:%.*]] = icmp eq ptr [[CALL1]], null, !annotation [[META6]]
// CHECK-NEXT:    br i1 [[FLEX_BASE_NULL_CHECK_NOT]], label %[[CONT69:.*]], label %[[FLEX_BASE_NONNULL:.*]], !annotation [[META6]]
// CHECK:       [[FLEX_BASE_NONNULL]]:
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[CALL1]], i64 16
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[CALL1]], [[TMP1]], !annotation [[META7]]
// CHECK-NEXT:    [[DOTNOT106:%.*]] = icmp ugt ptr [[CALL1]], [[TMP0]], !annotation [[META8]]
// CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[DOTNOT]], i1 true, i1 [[DOTNOT106]], !annotation [[META8]]
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[TRAP]], label %[[CONT60:.*]], !annotation [[META7]]
// CHECK:       [[CONT60]]:
// CHECK-NEXT:    [[UPPER_INTPTR:%.*]] = ptrtoint ptr [[ADD_PTR3]] to i64, !annotation [[META9]]
// CHECK-NEXT:    [[FAM_INTPTR:%.*]] = ptrtoint ptr [[TMP1]] to i64, !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT:%.*]] = sub nuw i64 [[UPPER_INTPTR]], [[FAM_INTPTR]], !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT_DIV:%.*]] = ashr exact i64 [[FLEX_AVAIL_COUNT]], 2, !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_COUNT_INTPTR:%.*]] = zext nneg i32 [[LEN]] to i64, !annotation [[META9]]
// CHECK-NEXT:    [[FLEX_COUNT_CHECK_NOT:%.*]] = icmp uge i64 [[FLEX_AVAIL_COUNT_DIV]], [[FLEX_COUNT_INTPTR]], !annotation [[META9]]
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ult ptr [[CALL1]], [[ADD_PTR3]], !annotation [[META8]]
// CHECK-NEXT:    [[OR_COND108:%.*]] = select i1 [[FLEX_COUNT_CHECK_NOT]], i1 [[TMP2]], i1 false, !annotation [[META6]]
// CHECK-NEXT:    br i1 [[OR_COND108]], label %[[CONT69]], label %[[TRAP]], !annotation [[META9]]
// CHECK:       [[CONT69]]:
// CHECK-NEXT:    store ptr [[CALL]], ptr [[CALL1]], align 8, !tbaa [[TBAA16]]
// CHECK-NEXT:    [[LEN78:%.*]] = getelementptr inbounds nuw i8, ptr [[CALL1]], i64 8
// CHECK-NEXT:    store i32 [[LEN]], ptr [[LEN78]], align 8, !tbaa [[TBAA10]]
// CHECK-NEXT:    ret ptr [[CALL1]]
//
struct Outer *foo2(int len) {
    int * p2 = baz(len);
    struct Outer * __single p = bar(len);
    p->hdr.ptr = p2;
    p->hdr.len = len;
    return p;
}
//.
// CHECK: [[META2]] = !{[[META3:![0-9]+]]}
// CHECK: [[META3]] = !{!"bounds-safety-missed-optimization-nuw", !"Check can not be removed because the arithmetic operation might wrap in the unsigned sense. Optimize the check by adding conditions to check for overflow before doing the operation"}
// CHECK: [[META4]] = !{!"bounds-safety-generic"}
// CHECK: [[META5]] = !{!"bounds-safety-generic", !"bounds-safety-check-one-past-end-overflow", !"bounds-safety-check-ptr-lt-upper-bound", !"bounds-safety-check-ptr-ge-lower-bound", !"bounds-safety-check-count-negative", !"bounds-safety-check-ptr-le-upper-bound", !"bounds-safety-check-flexible-count-gt-bounds"}
// CHECK: [[META6]] = !{!"bounds-safety-check-ptr-neq-null"}
// CHECK: [[META7]] = !{!"bounds-safety-check-one-past-end-overflow"}
// CHECK: [[META8]] = !{!"bounds-safety-check-ptr-lt-upper-bound"}
// CHECK: [[META9]] = !{!"bounds-safety-check-flexible-count-gt-bounds"}
// CHECK: [[TBAA10]] = !{[[META11:![0-9]+]], [[META15:![0-9]+]], i64 8}
// CHECK: [[META11]] = !{!"Inner", [[META12:![0-9]+]], i64 0, [[META15]], i64 8}
// CHECK: [[META12]] = !{!"any pointer", [[META13:![0-9]+]], i64 0}
// CHECK: [[META13]] = !{!"omnipotent char", [[META14:![0-9]+]], i64 0}
// CHECK: [[META14]] = !{!"Simple C/C++ TBAA"}
// CHECK: [[META15]] = !{!"int", [[META13]], i64 0}
// CHECK: [[TBAA16]] = !{[[META11]], [[META12]], i64 0}
//.
