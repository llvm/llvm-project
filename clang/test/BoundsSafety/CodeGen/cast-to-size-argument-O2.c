// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"


// RUN: %clang_cc1 -O2  -fbounds-safety -triple x86_64 -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2  -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -triple x86_64 -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

typedef struct {
    int len;
    int *__sized_by(len) buf;
} S;

void Foo(int *__sized_by(len) buf, int len);
void Bar(int *__sized_by(40) ptr);

// CHECK-LABEL: @TestZeroCount(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestZeroCount(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    S s;
    s.len = 0;
    s.buf = end_ptr; // okay
}

// CHECK-LABEL: @TestCountPtrArgFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestCountPtrArgFail(void) {
    int arr[10];
    int *end_ptr = arr + 9;

    Foo(end_ptr, 40); // trap
}

// CHECK-LABEL: @TestCountPtrArgFail2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestCountPtrArgFail2(void) {
  int arr[10];
  int *end_ptr = arr + 11;

  Foo(end_ptr, 40); // trap
}

// CHECK-LABEL: @TestCountPtrArgFail3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestCountPtrArgFail3(void) {
  int arr[10];
  int n = 41;
  Foo(arr, n); // trap
}

// CHECK-LABEL: @TestCountPtrArgOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7:[0-9]+]]
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 40
// CHECK-NEXT:    call void @Foo(ptr noundef nonnull [[UPPER]], i32 noundef 0) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void TestCountPtrArgOK(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    Foo(end_ptr, 0); // ok
}

// CHECK-LABEL: @TestCountPtrArgOK2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 36
// CHECK-NEXT:    call void @Foo(ptr noundef nonnull [[BOUND_PTR_ARITH]], i32 noundef 4) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void TestCountPtrArgOK2(void) {
    int arr[10];
    int *end_ptr = arr + 9;

    Foo(end_ptr, 4); // ok
}

// CHECK-LABEL: @TestConstCountPtrArgFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestConstCountPtrArgFail(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    Bar(({end_ptr;})); // trap
}

// CHECK-LABEL: @TestConstCountPtrArgOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    call void @Bar(ptr noundef nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void TestConstCountPtrArgOK(void) {
    int arr[10];
    int *end_ptr = arr;

    Bar(({end_ptr;})); // ok
}

// CHECK-LABEL: @TestConstZeroCountOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void TestConstZeroCountOK(void) {
    int arr[10];
    int *end_ptr = arr + 10;

    int *__sized_by(0) zero_buf;
    zero_buf = end_ptr; // ok
}

// XXX: this might be just fine not to trap
// CHECK-LABEL: @TestConstZeroCountFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void TestConstZeroCountFail(void) {
    int arr[10];
    int *end_ptr = arr + 11;

    int *__sized_by(0) zero_buf;
    zero_buf = end_ptr; // trap
}
