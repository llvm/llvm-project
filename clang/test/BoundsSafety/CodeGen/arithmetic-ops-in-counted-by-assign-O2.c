// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"

// RUN: %clang_cc1 -O2  -fbounds-safety -triple arm64e-apple-iphoneos -Wno-bounds-safety-init-list -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2  -fbounds-safety -triple arm64e-apple-iphoneos -Wno-bounds-safety-init-list -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>
#include <stddef.h>

// CHECK-LABEL: @count_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void count_ok(int *__counted_by(len - 2) buf, int len) {
  int arr[10];
  buf = arr;
  len = 12;
}

// CHECK-LABEL: @negative_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void negative_count_trap(int *__counted_by(len - 2) buf, int len) {
  int arr[10];
  int n = 0;
  len = n;
  buf = arr;
}

// CHECK-LABEL: @too_big_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void too_big_count_trap(int *__counted_by(len - 2) buf, int len) {
  int arr[10];
  int n = 13;
  buf = arr;
  len = n;
}

// CHECK-LABEL: @overflow_unsigned_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void overflow_unsigned_count_trap(int *__counted_by(len - 2) buf, size_t len) {
  int arr[10];
  int n = 0;
  buf = arr;
  len = n;
}

// CHECK-LABEL: @local_count_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void local_count_ok(void) {
  int arr[10];
  int len = 12;
  int *__counted_by(len - 2) buf = arr;
}

// CHECK-LABEL: @local_count_ok_2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void local_count_ok_2(void) {
  int arr[10];
  int len = 2;
  int *__counted_by(len - 2) buf;
  len = 12;
  buf = arr;
}

// CHECK-LABEL: @local_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void local_count_trap(void) {
  int arr[10];
  int n = 0;
  int len = n;
  int *__counted_by(len - 2) buf = arr;
}

// CHECK-LABEL: @loob_local_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 4
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7:[0-9]+]]
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds nuw i8, ptr [[ARR]], i64 40
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[ARR]], i64 -4
// CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp ugt ptr [[BOUND_PTR_ARITH]], [[UPPER]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[CMP16_NOT:%.*]] = icmp ugt ptr [[ARR]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP_NOT]], [[CMP16_NOT]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 40, ptr nonnull [[ARR]]) #[[ATTR7]]
// CHECK-NEXT:    ret void
//
void loob_local_count_trap(void) {
  int arr[10];
  int len = 12;
  int *__counted_by(len - 2) buf = arr - 1;
}

// CHECK-LABEL: @uoob_local_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void uoob_local_count_trap(void) {
  int arr[10];
  int len = 12;
  int *__counted_by(len - 2) buf = arr + 1;
}

// CHECK-LABEL: @too_big_local_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void too_big_local_count_trap(void) {
  int arr[10];
  int n = 13;
  int len = 2;
  int *__counted_by(len - 2) buf;
  buf = arr;
  len = n;
}

// CHECK-LABEL: @overflow_local_unsigned_count_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void overflow_local_unsigned_count_trap(void) {
  int arr[10];
  int n = 0;
  int len = n;
  int *__counted_by(len - 2) buf = arr;
}

// CHECK-LABEL: @overflow_unsigned_count_size_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void overflow_unsigned_count_size_ok(void *__sized_by(count * size) buf, size_t count, size_t size) {
  int arr[10];
  buf = arr;
  count = __SIZE_MAX__;
  size = __SIZE_MAX__;
}

// CHECK-LABEL: @overflow_unsigned_count_size_trap2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void overflow_unsigned_count_size_trap2(void *__sized_by(count * size) buf, size_t count, size_t size) {
  int arr[10];
  buf = arr;
  count = __SIZE_MAX__;
  size = __SIZE_MAX__;

  char *p = buf;
  p[1] = 0;
}

// CHECK-LABEL: @overflow_unsigned_count_size_index_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MUL:%.*]] = mul i64 [[SIZE:%.*]], [[COUNT:%.*]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i64 [[MUL]], -1
// CHECK-NEXT:    tail call void @llvm.assume(i1 [[CMP]])
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR6]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void overflow_unsigned_count_size_index_trap(int *__counted_by(count * size) buf, size_t count, size_t size) {
  buf = buf;
  count = (size_t)(__SIZE_MAX__ >> 2) + (size_t)1;
  size = 1;

  buf[0] = 0;
}
