// XFAIL: *
// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --prefix-filecheck-ir-name TMP_
// RUN: %clang_cc1 -O2 -triple arm64-apple-iphoneos -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2 -triple arm64-apple-iphoneos -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s


#include <ptrcheck.h>

typedef struct {
  int count;
  int elems[__counted_by(count)];
} flex_t;

// CHECK-LABEL: @test_under_base_fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_under_base_fail() {
  char arr[20];
  char *oob_ptr = arr - 1;
  flex_t *__single flex = oob_ptr;
}

// CHECK-LABEL: @test_under_base_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_under_base_ok() {
  char arr[20];
  char *oob_ptr = arr - 1;
  flex_t *flex = oob_ptr;
}


// CHECK-LABEL: @test_under_base_fail2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [20 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR10:[0-9]+]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[ARR]], i64 -1
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[ARR]], [[BOUND_PTR_ARITH]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[DOTNOT]], label [[TRAP:%.*]], label [[CONT8:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont8:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR10]]
// CHECK-NEXT:    ret void
//
void test_under_base_fail2() {
  char arr[20];
  char *oob_ptr = arr - 1;
  flex_t *flex = oob_ptr;
  int a = flex->count;
}


// CHECK-LABEL: @test_over_base_fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_over_base_fail() {
  char arr[20];
  char *oob_ptr = arr + 20;
  flex_t *__single flex = oob_ptr;
}

// CHECK-LABEL: @test_over_base_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_over_base_ok() {
  char arr[20];
  char *oob_ptr = arr + 20;
  flex_t *flex = oob_ptr;
}

// CHECK-LABEL: @test_over_base_fail2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [20 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR10]]
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds i8, ptr [[ARR]], i64 20
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[ARR]], i64 24
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[TMP0]], [[UPPER]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[DOTNOT]], label [[TRAP:%.*]], label [[CONT8:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont8:
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 20, ptr nonnull [[ARR]]) #[[ATTR10]]
// CHECK-NEXT:    ret void
//
void test_over_base_fail2() {
  char arr[20];
  char *oob_ptr = arr + 20;
  flex_t *flex = oob_ptr;
  int a = flex->count;
}

// XXX: Missing assumption?
// CHECK-LABEL: @test_small_base_fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [3 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 3, ptr nonnull [[ARR]]) #[[ATTR10]]
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds i8, ptr [[ARR]], i64 3
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr [[STRUCT_FLEX_T:%.*]], ptr [[ARR]], i64 1
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[ARR]], [[TMP0]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[DOTNOT46:%.*]] = icmp ugt ptr [[TMP0]], [[UPPER]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[DOTNOT]], i1 true, i1 [[DOTNOT46]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    call void @llvm.assume(i1 [[OR_COND]])
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_small_base_fail(flex_t *flex) {
  char arr[3];
  flex = arr;
}

// CHECK-LABEL: @test_small_base_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_small_base_ok() {
  char arr[3];
  flex_t *flex = arr;
}

// CHECK-LABEL: @test_small_base_fail2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [3 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 3, ptr nonnull [[ARR]]) #[[ATTR10]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr [[STRUCT_FLEX_T:%.*]], ptr [[ARR]], i64 1
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[ARR]], [[TMP0]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[UPPER:%.*]] = getelementptr inbounds i8, ptr [[ARR]], i64 3
// CHECK-NEXT:    [[DOTNOT49:%.*]] = icmp ugt ptr [[TMP0]], [[UPPER]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[DOTNOT]], i1 true, i1 [[DOTNOT49]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    call void @llvm.assume(i1 [[OR_COND]])
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_small_base_fail2() {
  char arr[3];
  flex_t *flex = arr;
  (void)(*flex);
}

// CHECK-LABEL: @test_count_from_buf_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_count_from_buf_ok() {
  char arr[20] = {4, 0};
  flex_t *__single flex = arr;
}

// CHECK-LABEL: @test_count_from_buf_ok2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_count_from_buf_ok2(flex_t *flex) {
  char arr[20] = {4, 0};
  flex = arr;
}

// CHECK-LABEL: @test_count_from_buf_fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_count_from_buf_fail() {
  char arr[20] = {5, 0};
  flex_t *__single flex = arr;
}

// CHECK-LABEL: @test_count_from_buf_fail2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_count_from_buf_fail2(flex_t *flex) {
  char arr[20] = {5, 0};
  flex = arr;
}

// CHECK-LABEL: @test_base_count_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_base_count_ok(flex_t *__single flex) {
  char arr[20];
  flex = arr;
  flex->count = 4;
}

// CHECK-LABEL: @test_base_count_fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_base_count_fail(flex_t *__single flex) {
  char arr[20];
  flex = arr;
  flex->count = 5;
}

// CHECK-LABEL: @test_base_fam_access(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_base_fam_access(flex_t *__single flex) {
  char arr[20];
  flex = arr;
  flex->count = 4;

  flex->elems[3] = 0;
}

// CHECK-LABEL: @test_base_fam_access_fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_base_fam_access_fail(flex_t *__single flex) {
  char arr[20];
  flex = arr;
  flex->count = 4;

  flex->elems[4] = 0;
}

typedef struct {
  unsigned dummy;
  flex_t *flex;
} flex_wrapper_t;

// CHECK-LABEL: @test_flex_init_list_ok(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_flex_init_list_ok() {
  char buf[20] = {4, 0};
  flex_wrapper_t flex_wrap = {0, buf};
}

// CHECK-LABEL: @test_flex_init_list_fail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_flex_init_list_fail() {
  char buf[20] = {5, 0};
  flex_wrapper_t flex_wrap = {0, buf};
}

void sink(flex_t *__single flex);

// CHECK-LABEL: @test_flex_argument_ok(
// CHECK-NEXT:  cont41:
// CHECK-NEXT:    [[BUF:%.*]] = alloca [20 x i8], align 1
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 20, ptr nonnull [[BUF]]) #[[ATTR10]]
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(20) [[BUF]], ptr noundef nonnull align 1 dereferenceable(20) @__const.test_flex_argument_ok.buf, i64 20, i1 false)
// CHECK-NEXT:    call void @sink(ptr noundef nonnull [[BUF]]) #[[ATTR10]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 20, ptr nonnull [[BUF]]) #[[ATTR10]]
// CHECK-NEXT:    ret void
//
void test_flex_argument_ok() {
  char buf[20] = {4, 0};
  sink(buf);
}

// CHECK-LABEL: @test_flex_argument_fail(
// CHECK-NEXT:  trap:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
void test_flex_argument_fail() {
  char buf[20] = {5, 0};
  sink(buf);
}
