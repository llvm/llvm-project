// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"

// RUN: %clang_cc1 -O0  -fbounds-safety -emit-llvm -fsanitize=alignment -fsanitize-trap=alignment -triple arm64 %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0  -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm -fsanitize=alignment -fsanitize-trap=alignment -triple arm64 %s -o - | FileCheck %s

#include <ptrcheck.h>

struct bstr {
  const unsigned char *__counted_by(length) data;
  unsigned long length;
};

// CHECK-LABEL: @test(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[SN_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[AGG_TEMP:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    store ptr [[SN:%.*]], ptr [[SN_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[SN_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[TMP0]] to i64, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP2:%.*]] = and i64 [[TMP1]], 7, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i64 [[TMP2]], 0, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP3]], label [[CONT:%.*]], label [[TRAP:%.*]], {{!nosanitize ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 22) #[[ATTR3:[0-9]+]], {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!nosanitize ![0-9]+}}
// CHECK:       cont:
// CHECK-NEXT:    [[LENGTH:%.*]] = getelementptr inbounds nuw [[STRUCT_BSTR:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[TMP4:%.*]] = ptrtoint ptr [[LENGTH]] to i64, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP5:%.*]] = and i64 [[TMP4]], 7, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i64 [[TMP5]], 0, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP6]], label [[CONT2:%.*]], label [[TRAP1:%.*]], {{!nosanitize ![0-9]+}}
// CHECK:       trap1:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 22) #[[ATTR3]], {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!nosanitize ![0-9]+}}
// CHECK:       cont2:
// CHECK-NEXT:    [[TMP7:%.*]] = load i64, ptr [[LENGTH]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = ptrtoint ptr [[TMP0]] to i64, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP9:%.*]] = and i64 [[TMP8]], 7, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i64 [[TMP9]], 0, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP10]], label [[CONT4:%.*]], label [[TRAP3:%.*]], {{!nosanitize ![0-9]+}}
// CHECK:       trap3:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 22) #[[ATTR3]], {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!nosanitize ![0-9]+}}
// CHECK:       cont4:
// CHECK-NEXT:    [[DATA:%.*]] = getelementptr inbounds nuw [[STRUCT_BSTR]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP11:%.*]] = ptrtoint ptr [[DATA]] to i64, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP12:%.*]] = and i64 [[TMP11]], 7, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    [[TMP13:%.*]] = icmp eq i64 [[TMP12]], 0, {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP13]], label [[CONT6:%.*]], label [[TRAP5:%.*]], {{!nosanitize ![0-9]+}}
// CHECK:       trap5:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 22) #[[ATTR3]], {{!nosanitize ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!nosanitize ![0-9]+}}
// CHECK:       cont6:
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[DATA]], align 8
// CHECK-NEXT:    [[CMP:%.*]] = icmp sge i64 [[TMP7]], 0
// CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw i8, ptr [[TMP14]], i64 [[TMP7]]
// CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[TMP14]], ptr [[TMP15]], align 8
// CHECK-NEXT:    [[TMP16:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[TMP16]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    store ptr [[TMP14]], ptr [[TMP17]], align 8
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP18:%.*]] = getelementptr i8, ptr [[WIDE_PTR_PTR]], i64 2
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR]], align 8
// CHECK-NEXT:    [[TMP19:%.*]] = icmp ult ptr [[TMP18]], [[WIDE_PTR_UB]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP19]], label [[CONT8:%.*]], label [[TRAP7:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap7:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont8:
// CHECK-NEXT:    [[TMP20:%.*]] = icmp uge ptr [[TMP18]], [[WIDE_PTR_LB]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP20]], label [[CONT10:%.*]], label [[TRAP9:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap9:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont10:
// CHECK-NEXT:    [[TMP21:%.*]] = load i8, ptr [[TMP18]], align 1
// CHECK-NEXT:    [[CONV:%.*]] = zext i8 [[TMP21]] to i32
// CHECK-NEXT:    [[CMP11:%.*]] = icmp eq i32 [[CONV]], 170
// CHECK-NEXT:    br i1 [[CMP11]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK:       if.then:
// CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       if.end:
// CHECK-NEXT:    store i32 1, ptr [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP22:%.*]] = load i32, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP22]]
//
int test(struct bstr *sn)
{
	if (sn->data[2] == 0xAA)
		return 0;
  return 1;
}
