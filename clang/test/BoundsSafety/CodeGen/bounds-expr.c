// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"


// RUN: %clang_cc1 -O0 -triple arm64e -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64e -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s
#include <ptrcheck.h>

int top_level_array[10];

int *__unsafe_indexable top_level_lower = __builtin_get_pointer_lower_bound(top_level_array);
int *__unsafe_indexable top_level_upper = __builtin_get_pointer_upper_bound(top_level_array);
// CHECK: @top_level_lower = global ptr @top_level_array, align 8
// CHECK: @top_level_upper = global ptr getelementptr (i8, ptr @top_level_array, i64 40), align 8

int *__unsafe_indexable top_level_added_lower = __builtin_get_pointer_lower_bound(top_level_array + 5);
int *__unsafe_indexable top_level_added_upper = __builtin_get_pointer_upper_bound(top_level_array + 5);
// CHECK: @top_level_added_lower = global ptr @top_level_array, align 8
// CHECK: @top_level_added_upper = global ptr getelementptr (i8, ptr @top_level_array, i64 40), align 8

int *__unsafe_indexable top_level_indexed_lower = __builtin_get_pointer_lower_bound(&top_level_array[5]);
int *__unsafe_indexable top_level_indexed_upper = __builtin_get_pointer_upper_bound(&top_level_array[5]);
// CHECK: @top_level_indexed_lower = global ptr @top_level_array, align 8
// CHECK: @top_level_indexed_upper = global ptr getelementptr (i8, ptr @top_level_array, i64 40), align 8


struct subobject_array {
    int foo;
    int array[10];
    int bar;
};

struct subobject_array subobj;

int *__unsafe_indexable subobject_lower = __builtin_get_pointer_lower_bound(subobj.array);
int *__unsafe_indexable subobject_upper = __builtin_get_pointer_upper_bound(subobj.array);
// CHECK: @subobject_lower = global ptr getelementptr (i8, ptr @subobj, i64 4), align 8
// CHECK: @subobject_upper = global ptr getelementptr (i8, ptr @subobj, i64 44), align 8

int *__unsafe_indexable subobject_added_lower = __builtin_get_pointer_lower_bound(subobj.array + 5);
int *__unsafe_indexable subobject_added_upper = __builtin_get_pointer_upper_bound(subobj.array + 5);
// CHECK: @subobject_added_lower = global ptr getelementptr (i8, ptr @subobj, i64 4), align 8
// CHECK: @subobject_added_upper = global ptr getelementptr (i8, ptr @subobj, i64 44), align 8

int *__unsafe_indexable subobject_indexed_lower = __builtin_get_pointer_lower_bound(&subobj.array[5]);
int *__unsafe_indexable subobject_indexed_upper = __builtin_get_pointer_upper_bound(&subobj.array[5]);
// CHECK: @subobject_indexed_lower = global ptr getelementptr (i8, ptr @subobj, i64 4), align 8
// CHECK: @subobject_indexed_upper = global ptr getelementptr (i8, ptr @subobj, i64 44), align 8

struct subobject_array *__unsafe_indexable lower = __builtin_get_pointer_lower_bound(&subobj);
struct subobject_array *__unsafe_indexable upper = __builtin_get_pointer_upper_bound(&subobj);
// CHECK: @lower = global ptr @subobj, align 8
// CHECK: @upper = global ptr getelementptr (i8, ptr @subobj, i64 48), align 8


// CHECK-LABEL: @getLowerBound(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PTR_INDIRECT_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[PTR:%.*]], ptr [[PTR_INDIRECT_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_RESULT:%.*]], ptr align 8 [[PTR]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_RESULT]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[WIDE_PTR_LB]], ptr [[TMP0]], align 8
// CHECK-NEXT:    ret void
//
int *__bidi_indexable getLowerBound(int *__bidi_indexable ptr) {
    return __builtin_get_pointer_lower_bound(ptr);
}


// CHECK-LABEL: @getUpperBound(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PTR_INDIRECT_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[PTR:%.*]], ptr [[PTR_INDIRECT_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_RESULT:%.*]], ptr align 8 [[PTR]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_RESULT]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds nuw %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_RESULT]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[WIDE_PTR_UB]], ptr [[TMP0]], align 8
// CHECK-NEXT:    ret void
//
int *__bidi_indexable getUpperBound(int *__bidi_indexable ptr) {
    return __builtin_get_pointer_upper_bound(ptr);
}

