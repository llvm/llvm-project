// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --prefix-filecheck-ir-name TMP_ --version 5


// RUN: %clang_cc1 -triple x86_64 -fbounds-safety -emit-llvm -fbounds-safety-bringup-missing-checks=indirect_count_update -DWITH -O2 %s -o - | FileCheck %s
// RUN: %clang_cc1 -triple x86_64 -fbounds-safety -emit-llvm -fno-bounds-safety-bringup-missing-checks=indirect_count_update -O2 %s -o - | FileCheck %s --check-prefix WITHOUT
#include <ptrcheck.h>

//
// WITHOUT-LABEL: define dso_local void @foo(
// WITHOUT-SAME: ptr noundef writeonly captures(none) initializes((0, 4)) [[X:%.*]], i32 noundef [[COUNT:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// WITHOUT-NEXT:  [[ENTRY:.*:]]
// WITHOUT-NEXT:    store i32 0, ptr [[X]], align 4, !tbaa [[TBAA2:![0-9]+]]
// WITHOUT-NEXT:    ret void
// CHECK-LABEL: define dso_local void @foo(
// CHECK-SAME: ptr noundef writeonly captures(address) [[X:%.*]], i32 noundef [[COUNT:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[COUNT]] to i64
// CHECK-NEXT:    [[ADD_PTR_IDX:%.*]] = shl nuw nsw i64 [[IDX_EXT]], 2, !annotation [[META2:![0-9]+]]
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw i8, ptr [[X]], i64 [[ADD_PTR_IDX]], !annotation [[META2]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[X]], i64 4
// CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp ugt ptr [[BOUND_PTR_ARITH]], [[ADD_PTR]], !annotation [[META2]]
// CHECK-NEXT:    [[CMP15_NOT:%.*]] = icmp ugt ptr [[X]], [[BOUND_PTR_ARITH]], !annotation [[META2]]
// CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP15_NOT]], [[CMP_NOT]], !annotation [[META2]]
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[TRAP:.*]], label %[[LAND_RHS:.*]], !annotation [[META2]]
// CHECK:       [[LAND_RHS]]:
// CHECK-NEXT:    [[SUB:%.*]] = add i32 [[COUNT]], -1, !annotation [[META3:![0-9]+]]
// CHECK-NEXT:    [[CONV:%.*]] = zext i32 [[SUB]] to i64, !annotation [[META2]]
// CHECK-NEXT:    [[GEPDIFF:%.*]] = add nsw i64 [[ADD_PTR_IDX]], -4, !annotation [[META5:![0-9]+]]
// CHECK-NEXT:    [[SUB_PTR_DIV:%.*]] = ashr exact i64 [[GEPDIFF]], 2, !annotation [[META2]]
// CHECK-NEXT:    [[CMP26_NOT:%.*]] = icmp slt i64 [[SUB_PTR_DIV]], [[CONV]], !annotation [[META2]]
// CHECK-NEXT:    br i1 [[CMP26_NOT]], label %[[TRAP]], label %[[CONT:.*]], !annotation [[META2]]
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR2:[0-9]+]], !annotation [[META2]]
// CHECK-NEXT:    unreachable, !annotation [[META2]]
// CHECK:       [[CONT]]:
// CHECK-NEXT:    store i32 0, ptr [[X]], align 4, !tbaa [[TBAA7:![0-9]+]]
// CHECK-NEXT:    ret void
//
void foo(int *__counted_by(count) x, unsigned count) {
	*x++ = 0;
    #ifdef WITH
    // NOTE: It's necessary to exclude the count update with
    // indirect_count_update disabled otherwise we'll get diagnostics about
    // the a missing assignment to `x`.
    count--;
    #endif
}

//
// WITHOUT-LABEL: define dso_local void @bar(
// WITHOUT-SAME: ptr noundef writeonly captures(none) initializes((4, 8)) [[X:%.*]], i32 noundef [[COUNT:%.*]]) local_unnamed_addr #[[ATTR0]] {
// WITHOUT-NEXT:  [[ENTRY:.*:]]
// WITHOUT-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[X]], i64 4
// WITHOUT-NEXT:    store i32 0, ptr [[BOUND_PTR_ARITH]], align 4, !tbaa [[TBAA2]]
// WITHOUT-NEXT:    ret void
// CHECK-LABEL: define dso_local void @bar(
// CHECK-SAME: ptr noundef writeonly captures(address) [[X:%.*]], i32 noundef [[COUNT:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[IDX_EXT:%.*]] = sext i32 [[COUNT]] to i64
// CHECK-NEXT:    [[ADD_PTR_IDX:%.*]] = shl nsw i64 [[IDX_EXT]], 2, !annotation [[META5]]
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr [[X]], i64 [[ADD_PTR_IDX]], !annotation [[META2]]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr i8, ptr [[X]], i64 4
// CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp ugt ptr [[BOUND_PTR_ARITH]], [[ADD_PTR]], !annotation [[META2]]
// CHECK-NEXT:    [[CMP15_NOT:%.*]] = icmp ugt ptr [[X]], [[BOUND_PTR_ARITH]], !annotation [[META2]]
// CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP15_NOT]], [[CMP_NOT]], !annotation [[META2]]
// CHECK-NEXT:    br i1 [[OR_COND]], label %[[TRAP:.*]], label %[[LAND_RHS:.*]], !annotation [[META2]]
// CHECK:       [[LAND_RHS]]:
// CHECK-NEXT:    [[SUB:%.*]] = add nsw i32 [[COUNT]], -1, !annotation [[META11:![0-9]+]]
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[SUB]] to i64, !annotation [[META2]]
// CHECK-NEXT:    [[GEPDIFF:%.*]] = add nsw i64 [[ADD_PTR_IDX]], -4, !annotation [[META5]]
// CHECK-NEXT:    [[SUB_PTR_DIV:%.*]] = ashr exact i64 [[GEPDIFF]], 2, !annotation [[META2]]
// CHECK-NEXT:    [[CMP26:%.*]] = icmp sge i64 [[SUB_PTR_DIV]], [[CONV]], !annotation [[META2]]
// CHECK-NEXT:    [[CMP29:%.*]] = icmp sgt i32 [[COUNT]], 0, !annotation [[META2]]
// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = and i1 [[CMP29]], [[CMP26]]
// CHECK-NEXT:    br i1 [[SPEC_SELECT]], label %[[CONT:.*]], label %[[TRAP]], !annotation [[META2]]
// CHECK:       [[TRAP]]:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR2]], !annotation [[META2]]
// CHECK-NEXT:    unreachable, !annotation [[META2]]
// CHECK:       [[CONT]]:
// CHECK-NEXT:    store i32 0, ptr [[BOUND_PTR_ARITH]], align 4, !tbaa [[TBAA7]]
// CHECK-NEXT:    ret void
//
void bar(int *__counted_by(count) x, int count) {
    #ifdef WITH
    // NOTE: It's necessary to exclude the count update with
    // indirect_count_update disabled otherwise we'll get diagnostics about
    // the a missing assignment to `x`.
    count = count - 1;
    #endif
	*(x = x+1) = 0;
}

// WITHOUT: [[TBAA2]] = !{[[META3:![0-9]+]], [[META3]], i64 0}
// WITHOUT: [[META3]] = !{!"int", [[META4:![0-9]+]], i64 0}
// WITHOUT: [[META4]] = !{!"omnipotent char", [[META5:![0-9]+]], i64 0}
// WITHOUT: [[META5]] = !{!"Simple C/C++ TBAA"}
//.
// CHECK: [[META2]] = !{!"bounds-safety-generic"}
// CHECK: [[META3]] = !{[[META4:![0-9]+]]}
// CHECK: [[META4]] = !{!"bounds-safety-missed-optimization-nsw", !"Check can not be removed because the arithmetic operation might wrap in the signed sense. Optimize the check by adding conditions to check for overflow before doing the operation"}
// CHECK: [[META5]] = !{!"bounds-safety-generic", [[META6:![0-9]+]]}
// CHECK: [[META6]] = !{!"bounds-safety-missed-optimization-nuw", !"Check can not be removed because the arithmetic operation might wrap in the unsigned sense. Optimize the check by adding conditions to check for overflow before doing the operation"}
// CHECK: [[TBAA7]] = !{[[META8:![0-9]+]], [[META8]], i64 0}
// CHECK: [[META8]] = !{!"int", [[META9:![0-9]+]], i64 0}
// CHECK: [[META9]] = !{!"omnipotent char", [[META10:![0-9]+]], i64 0}
// CHECK: [[META10]] = !{!"Simple C/C++ TBAA"}
// CHECK: [[META11]] = !{[[META6]]}
//.
