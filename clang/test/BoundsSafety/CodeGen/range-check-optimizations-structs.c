// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!llvm.loop ![0-9]+" "#[0-9]+"

//
// RUN: %clang_cc1 -O2 -fbounds-safety -fbounds-safety-bringup-missing-checks=all -emit-llvm -triple x86_64 %s -o - | FileCheck %s

#include <ptrcheck.h>

struct struct_1 {
    void *value;
};

// CHECK-LABEL: @access_struct_1_all_checks_removable(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_NOT24_NOT:%.*]] = icmp eq i32 [[SIZE:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_NOT24_NOT]], label [[CLEANUP14:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
// CHECK:       for.body.preheader:
// CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[SIZE]] to i64
// CHECK-NEXT:    br label [[FOR_BODY:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[INDVARS_IV_NEXT:%.*]] = add nuw nsw i64 [[INDVARS_IV:%.*]], 1
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[CLEANUP14]], label [[FOR_BODY]], {{!llvm.loop ![0-9]+}}
// CHECK:       for.body:
// CHECK-NEXT:    [[INDVARS_IV]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT]], [[FOR_COND:%.*]] ]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_STRUCT_1:%.*]], ptr [[SRC:%.*]], i64 [[INDVARS_IV]]
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[BOUND_PTR_ARITH]], align 8, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP3_NOT:%.*]] = icmp eq ptr [[TMP0]], [[VALUE:%.*]]
// CHECK-NEXT:    br i1 [[CMP3_NOT]], label [[CLEANUP14_LOOPEXIT_SPLIT_LOOP_EXIT:%.*]], label [[FOR_COND]]
// CHECK:       cleanup14.loopexit.split.loop.exit:
// CHECK-NEXT:    [[BOUND_PTR_ARITH_LE:%.*]] = getelementptr [[STRUCT_STRUCT_1]], ptr [[SRC]], i64 [[INDVARS_IV]]
// CHECK-NEXT:    br label [[CLEANUP14]]
// CHECK:       cleanup14:
// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = phi ptr [ null, [[ENTRY:%.*]] ], [ [[BOUND_PTR_ARITH_LE]], [[CLEANUP14_LOOPEXIT_SPLIT_LOOP_EXIT]] ], [ null, [[FOR_COND]] ]
// CHECK-NEXT:    ret ptr [[SPEC_SELECT]]
//
struct struct_1 * access_struct_1_all_checks_removable(
    struct struct_1 *__counted_by(size) src, unsigned size, void *value) {
  for (unsigned i = 0; i < size; i++) {
    struct struct_1 *value_entry = &src[i];
    if (value_entry->value == value)
        return value_entry;
  }
  return 0;
}

// CHECK-LABEL: @access_struct_1_checks_needed(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[SIZE:%.*]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds nuw [[STRUCT_STRUCT_1:%.*]], ptr [[SRC:%.*]], i64 [[IDX_EXT]]
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[CONT1:%.*]] ], [ 0, [[ENTRY:%.*]] ]
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV]], [[IDX_EXT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[CLEANUP14:%.*]], label [[FOR_BODY:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_STRUCT_1]], ptr [[SRC]], i64 [[INDVARS_IV_NEXT]]
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr [[BOUND_PTR_ARITH]], i64 8
// CHECK-NEXT:    [[DOTNOT25:%.*]] = icmp ugt ptr [[TMP0]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[DOTNOT25]], label [[TRAP:%.*]], label [[CONT1]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) {{#[0-9]+}}, {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont1:
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[BOUND_PTR_ARITH]], align 8, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP3_NOT:%.*]] = icmp eq ptr [[TMP1]], [[VALUE:%.*]]
// CHECK-NEXT:    br i1 [[CMP3_NOT]], label [[BOUNDSCHECK_NOTNULL:%.*]], label [[FOR_COND]]
// CHECK:       boundscheck.notnull:
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ugt ptr [[BOUND_PTR_ARITH]], [[TMP0]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[DOTNOT]], label [[TRAP]], label [[CLEANUP14]], {{!annotation ![0-9]+}}
// CHECK:       cleanup14:
// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = phi ptr [ [[BOUND_PTR_ARITH]], [[BOUNDSCHECK_NOTNULL]] ], [ null, [[FOR_COND]] ]
// CHECK-NEXT:    ret ptr [[SPEC_SELECT]]
//
struct struct_1 * access_struct_1_checks_needed(
    struct struct_1 *__counted_by(size) src, unsigned size, void *value) {
  for (unsigned i = 0; i < size; i++) {
    struct struct_1 *value_entry = &src[i+1];
    if (value_entry->value == value)
        return value_entry;
  }
  return 0;
}

struct struct_2 {
    int a;
    int b;
};

// CHECK-LABEL: @access_struct_2_all_checks_removable(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP_NOT38_NOT:%.*]] = icmp eq i32 [[SIZE:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP_NOT38_NOT]], label [[CLEANUP25:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
// CHECK:       for.body.preheader:
// CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[SIZE]] to i64
// CHECK-NEXT:    br label [[FOR_BODY:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC:%.*]] ]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_STRUCT_2:%.*]], ptr [[SRC:%.*]], i64 [[INDVARS_IV]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[BOUND_PTR_ARITH]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i32 [[TMP0]], [[A:%.*]]
// CHECK-NEXT:    br i1 [[CMP3]], label [[CONT12:%.*]], label [[FOR_INC]]
// CHECK:       cont12:
// CHECK-NEXT:    [[B13:%.*]] = getelementptr inbounds nuw i8, ptr [[BOUND_PTR_ARITH]], i64 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[B13]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[CMP14:%.*]] = icmp eq i32 [[TMP1]], [[B:%.*]]
// CHECK-NEXT:    br i1 [[CMP14]], label [[CLEANUP25]], label [[FOR_INC]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[CLEANUP25]], label [[FOR_BODY]], {{!llvm.loop ![0-9]+}}
// CHECK:       cleanup25:
// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = phi ptr [ null, [[ENTRY:%.*]] ], [ [[BOUND_PTR_ARITH]], [[CONT12]] ], [ null, [[FOR_INC]] ]
// CHECK-NEXT:    ret ptr [[SPEC_SELECT]]
//
struct struct_2 * access_struct_2_all_checks_removable(
    struct struct_2 *__counted_by(size) src, unsigned size, int a, int b) {
  for (unsigned i = 0; i < size; i++) {
   struct struct_2 *value_entry = &src[i];
    if (value_entry->a == a && value_entry->b == b)
        return value_entry;
  }
    return 0;
}

typedef struct {
  int f1;
  int f2;
  int f3;
} MyStruct;

// All runtime checks in the loop can be removed.
// CHECK-LABEL: @array_of_structs_all_checks_removable(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CMP29_NOT:%.*]] = icmp eq i32 [[NUMITEMS:%.*]], 0
// CHECK-NEXT:    br i1 [[CMP29_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
// CHECK:       for.body.preheader:
// CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[NUMITEMS]] to i64
// CHECK-NEXT:    br label [[FOR_BODY:%.*]]
// CHECK:       for.cond.cleanup:
// CHECK-NEXT:    [[RES_0_LCSSA:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD21:%.*]], [[FOR_BODY]] ]
// CHECK-NEXT:    ret i32 [[RES_0_LCSSA]]
// CHECK:       for.body:
// CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
// CHECK-NEXT:    [[RES_031:%.*]] = phi i32 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[ADD21]], [[FOR_BODY]] ]
// CHECK-NEXT:    [[BOUND_PTR_ARITH:%.*]] = getelementptr [[STRUCT_MYSTRUCT:%.*]], ptr [[ITEMS:%.*]], i64 [[INDVARS_IV]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[BOUND_PTR_ARITH]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[F2:%.*]] = getelementptr inbounds nuw i8, ptr [[BOUND_PTR_ARITH]], i64 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[F2]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[F3:%.*]] = getelementptr inbounds nuw i8, ptr [[BOUND_PTR_ARITH]], i64 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[F3]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[ADD:%.*]] = add i32 [[TMP0]], [[RES_031]]
// CHECK-NEXT:    [[ADD20:%.*]] = add i32 [[ADD]], [[TMP1]]
// CHECK-NEXT:    [[ADD21]] = add i32 [[ADD20]], [[TMP2]]
// CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
// CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
// CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], {{!llvm.loop ![0-9]+}}
//
int array_of_structs_all_checks_removable(MyStruct *__counted_by(numItems) items,
                                unsigned numItems) {
  int res = 0;
  for (unsigned i = 0; i < numItems; i++) {
    const MyStruct *ptr = &items[i];
    res += ptr->f1 + ptr->f2 + ptr->f3;
  }
  return res;
}
