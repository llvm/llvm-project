// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5

// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -x c -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x c -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x c++ -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x objective-c -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fexperimental-bounds-safety-attributes -x objective-c++ -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

#ifdef __cplusplus
extern "C" {
#endif

// CHECK-LABEL: define dso_local i32 @fn_deref(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[COUNT:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[COUNT_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[COUNT]], ptr [[COUNT_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[TMP0]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
int fn_deref(int *__counted_by(count) p, int count) {
  return *p;
}

// CHECK-LABEL: define dso_local i32 @fn_subscript(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[COUNT:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[COUNT_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[COUNT]], ptr [[COUNT_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[COUNT_ADDR]], align 4
// CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP1]], 1
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[SUB]] to i64
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[TMP0]], i64 [[IDXPROM]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
int fn_subscript(int *__counted_by(count) p, int count) {
  return p[count - 1];
}

// CHECK-LABEL: define dso_local ptr @fn_assign(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[COUNT:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[COUNT_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[P]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    store i32 [[COUNT]], ptr [[COUNT_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[COUNT_ADDR]], align 4
// CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP0]], 42
// CHECK-NEXT:    store i32 [[SUB]], ptr [[COUNT_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 42
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[P_ADDR]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[P_ADDR]], align 8
// CHECK-NEXT:    ret ptr [[TMP2]]
//
int *fn_assign(int *__counted_by(count) p, int count) {
  count = count - 42;
  p = p + 42;
  return p;
}

struct bar {
  int *__sized_by(size) q;
  int size;
};

// CHECK-LABEL: define dso_local i32 @struct_deref(
// CHECK-SAME: ptr noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR:%.*]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[Q]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
int struct_deref(struct bar *b) {
  return *b->q;
}

// CHECK-LABEL: define dso_local i32 @struct_subscript(
// CHECK-SAME: ptr noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR:%.*]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[Q]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[SIZE:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP2]], i32 0, i32 1
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[SIZE]], align 8
// CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP3]], 1
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[SUB]] to i64
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 [[IDXPROM]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret i32 [[TMP4]]
//
int struct_subscript(struct bar *b) {
  return b->q[b->size - 1];
}

// CHECK-LABEL: define dso_local void @struct_assign(
// CHECK-SAME: ptr noundef [[B:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[SIZE:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[SIZE]], align 8
// CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP1]], 42
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[SIZE1:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP2]], i32 0, i32 1
// CHECK-NEXT:    store i32 [[SUB]], ptr [[SIZE1]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP3]], i32 0, i32 0
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[Q]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i64 42
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[B_ADDR]], align 8
// CHECK-NEXT:    [[Q2:%.*]] = getelementptr inbounds nuw [[STRUCT_BAR]], ptr [[TMP5]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[Q2]], align 8
// CHECK-NEXT:    ret void
//
void struct_assign(struct bar *b) {
  b->size = b->size - 42;
  b->q = b->q + 42;
}

#ifdef __cplusplus
}
#endif
