// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --prefix-filecheck-ir-name TMP_

// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

// CHECK-LABEL: @check_upper_bound(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 0
//
int check_upper_bound(void) {
  int arr[10];
  void *p = arr;
  if ((char *)__ptr_upper_bound((void *)arr) - (char *)arr == 40)
    return 0;
  return -1;
}

// CHECK-LABEL: @check_forged_upper_bound(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 0
//
int check_forged_upper_bound(void) {
  int arr[10];
  void *p = arr;
  if ((char *)__ptr_upper_bound(__unsafe_forge_bidi_indexable(int *, arr, 99)) - (char *)arr == 99)
    return 0;
  return -1;
}

// CHECK-LABEL: @check_forged_upper_bound_void(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 0
//
int check_forged_upper_bound_void(void) {
  int arr[10];
  void *p = arr;
  if ((char *)__ptr_upper_bound(__unsafe_forge_bidi_indexable(void *, arr, 99)) - (char *)arr == 99)
    return 0;
  return -1;
}

void get_sized_by(void *__sized_by(40) buf);

// CHECK-LABEL: @int_array_to_void_good(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[ARR]]) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    call void @get_sized_by(ptr noundef nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void int_array_to_void_good(void) {
  int arr[10];
  get_sized_by(arr);
}

// CHECK-LABEL: @int_array_to_void_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR7:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
void int_array_to_void_trap(void) {
  int arr[9];
  int *p = arr;
  get_sized_by(p);
}

void get_counted_by(int *__counted_by(10) buf);

// CHECK-LABEL: @int_array_to_int_good(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    call void @llvm.lifetime.start.p0(ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    call void @get_counted_by(ptr noundef nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p0(ptr nonnull [[ARR]]) #[[ATTR6]]
// CHECK-NEXT:    ret void
//
void int_array_to_int_good(void) {
  int arr[10];
  get_counted_by(arr);
}

// CHECK-LABEL: @int_array_to_int_trap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
void int_array_to_int_trap(void) {
  int arr[9];
  int *p = arr;
  get_counted_by(p);
}
