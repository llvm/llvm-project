//===- CIRTypes.cpp - MLIR CIR Types --------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines the types in the CIR dialect.
//
//===----------------------------------------------------------------------===//

#include "clang/CIR/Dialect/IR/CIRTypes.h"
#include "clang/CIR/Dialect/IR/CIRAttrs.h"
#include "clang/CIR/Dialect/IR/CIRDialect.h"
#include "clang/CIR/Dialect/IR/CIRTypesDetails.h"
#include "clang/CIR/MissingFeatures.h"

#include "mlir/IR/Attributes.h"
#include "mlir/IR/BuiltinAttributes.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Diagnostics.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/Interfaces/DataLayoutInterfaces.h"
#include "mlir/Support/LLVM.h"
#include "mlir/Support/LogicalResult.h"

#include "clang/CIR/Interfaces/ASTAttrInterfaces.h"
#include "clang/CIR/Interfaces/CIRFPTypeInterface.h"
#include "llvm/ADT/APFloat.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/TypeSwitch.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/MathExtras.h"
#include <cassert>
#include <optional>

using cir::MissingFeatures;

//===----------------------------------------------------------------------===//
// CIR Custom Parser/Printer Signatures
//===----------------------------------------------------------------------===//

static mlir::ParseResult parseFuncType(mlir::AsmParser &p,
                                       mlir::Type &optionalReturnTypes,
                                       llvm::SmallVector<mlir::Type> &params,
                                       bool &isVarArg);

static void printFuncType(mlir::AsmPrinter &p, mlir::Type optionalReturnTypes,
                          mlir::ArrayRef<mlir::Type> params, bool isVarArg);
static mlir::ParseResult parsePointerAddrSpace(mlir::AsmParser &p,
                                               mlir::Attribute &addrSpaceAttr);
static void printPointerAddrSpace(mlir::AsmPrinter &p,
                                  mlir::Attribute addrSpaceAttr);

//===----------------------------------------------------------------------===//
// Get autogenerated stuff
//===----------------------------------------------------------------------===//

#define GET_TYPEDEF_CLASSES
#include "clang/CIR/Dialect/IR/CIROpsTypes.cpp.inc"

using namespace mlir;
using namespace cir;

//===----------------------------------------------------------------------===//
// General CIR parsing / printing
//===----------------------------------------------------------------------===//

Type CIRDialect::parseType(DialectAsmParser &parser) const {
  llvm::SMLoc typeLoc = parser.getCurrentLocation();
  llvm::StringRef mnemonic;
  Type genType;

  // Try to parse as a tablegen'd type.
  OptionalParseResult parseResult =
      generatedTypeParser(parser, &mnemonic, genType);
  if (parseResult.has_value())
    return genType;

  // Type is not tablegen'd: try to parse as a raw C++ type.
  return StringSwitch<function_ref<Type()>>(mnemonic)
      .Case("struct", [&] { return StructType::parse(parser); })
      .Default([&] {
        parser.emitError(typeLoc) << "unknown CIR type: " << mnemonic;
        return Type();
      })();
}

void CIRDialect::printType(Type type, DialectAsmPrinter &os) const {
  // Try to print as a tablegen'd type.
  if (generatedTypePrinter(type, os).succeeded())
    return;

  // Type is not tablegen'd: try printing as a raw C++ type.
  TypeSwitch<Type>(type)
      .Case<StructType>([&](StructType type) {
        os << type.getMnemonic();
        type.print(os);
      })
      .Default([](Type) {
        llvm::report_fatal_error("printer is missing a handler for this type");
      });
}

Type BoolType::parse(mlir::AsmParser &parser) {
  return get(parser.getContext());
}

void BoolType::print(mlir::AsmPrinter &printer) const {}

//===----------------------------------------------------------------------===//
// StructType Definitions
//===----------------------------------------------------------------------===//

/// Return the largest member of in the type.
///
/// Recurses into union members never returning a union as the largest member.
Type StructType::getLargestMember(const ::mlir::DataLayout &dataLayout) const {
  if (!layoutInfo)
    computeSizeAndAlignment(dataLayout);
  return mlir::cast<cir::StructLayoutAttr>(layoutInfo).getLargestMember();
}

Type StructType::parse(mlir::AsmParser &parser) {
  FailureOr<AsmParser::CyclicParseReset> cyclicParseGuard;
  const auto loc = parser.getCurrentLocation();
  const auto eLoc = parser.getEncodedSourceLoc(loc);
  bool packed = false;
  bool padded = false;
  RecordKind kind;
  auto *context = parser.getContext();

  if (parser.parseLess())
    return {};

  // TODO(cir): in the future we should probably separate types for different
  // source language declarations such as cir.class, cir.union, and cir.struct
  if (parser.parseOptionalKeyword("struct").succeeded())
    kind = RecordKind::Struct;
  else if (parser.parseOptionalKeyword("union").succeeded())
    kind = RecordKind::Union;
  else if (parser.parseOptionalKeyword("class").succeeded())
    kind = RecordKind::Class;
  else {
    parser.emitError(loc, "unknown struct type");
    return {};
  }

  mlir::StringAttr name;
  parser.parseOptionalAttribute(name);

  // Is a self reference: ensure referenced type was parsed.
  if (name && parser.parseOptionalGreater().succeeded()) {
    auto type = getChecked(eLoc, context, name, kind);
    if (succeeded(parser.tryStartCyclicParse(type))) {
      parser.emitError(loc, "invalid self-reference within record");
      return {};
    }
    return type;
  }

  // Is a named record definition: ensure name has not been parsed yet.
  if (name) {
    auto type = getChecked(eLoc, context, name, kind);
    cyclicParseGuard = parser.tryStartCyclicParse(type);
    if (failed(cyclicParseGuard)) {
      parser.emitError(loc, "record already defined");
      return {};
    }
  }

  if (parser.parseOptionalKeyword("packed").succeeded())
    packed = true;

  if (parser.parseOptionalKeyword("padded").succeeded())
    padded = true;

  // Parse record members or lack thereof.
  bool incomplete = true;
  llvm::SmallVector<mlir::Type> members;
  if (parser.parseOptionalKeyword("incomplete").failed()) {
    incomplete = false;
    const auto delimiter = AsmParser::Delimiter::Braces;
    const auto parseElementFn = [&parser, &members]() {
      return parser.parseType(members.emplace_back());
    };
    if (parser.parseCommaSeparatedList(delimiter, parseElementFn).failed())
      return {};
  }

  // Parse optional AST attribute. This is just a formality for now, since CIR
  // cannot yet read serialized AST.
  cir::ASTRecordDeclAttr ast = nullptr;
  parser.parseOptionalAttribute(ast);

  if (parser.parseGreater())
    return {};

  // Try to create the proper record type.
  ArrayRef<mlir::Type> membersRef(members); // Needed for template deduction.
  mlir::Type type = {};
  if (name && incomplete) { // Identified & incomplete
    type = getChecked(eLoc, context, name, kind);
  } else if (name && !incomplete) { // Identified & complete
    type = getChecked(eLoc, context, membersRef, name, packed, padded, kind);
    // If the record has a self-reference, its type already exists in a
    // incomplete state. In this case, we must complete it.
    if (mlir::cast<StructType>(type).isIncomplete())
      mlir::cast<StructType>(type).complete(membersRef, packed, padded, ast);
  } else if (!name && !incomplete) { // anonymous & complete
    type = getChecked(eLoc, context, membersRef, packed, padded, kind);
  } else { // anonymous & incomplete
    parser.emitError(loc, "anonymous structs must be complete");
    return {};
  }

  return type;
}

void StructType::print(mlir::AsmPrinter &printer) const {
  FailureOr<AsmPrinter::CyclicPrintReset> cyclicPrintGuard;
  printer << '<';

  switch (getKind()) {
  case RecordKind::Struct:
    printer << "struct ";
    break;
  case RecordKind::Union:
    printer << "union ";
    break;
  case RecordKind::Class:
    printer << "class ";
    break;
  }

  if (getName())
    printer << getName();

  // Current type has already been printed: print as self reference.
  cyclicPrintGuard = printer.tryStartCyclicPrint(*this);
  if (failed(cyclicPrintGuard)) {
    printer << '>';
    return;
  }

  // Type not yet printed: continue printing the entire record.
  printer << ' ';

  if (getPacked())
    printer << "packed ";

  if (getPadded())
    printer << "padded ";

  if (isIncomplete()) {
    printer << "incomplete";
  } else {
    printer << "{";
    llvm::interleaveComma(getMembers(), printer);
    printer << "}";
  }

  if (getAst()) {
    printer << " ";
    printer.printAttribute(getAst());
  }

  printer << '>';
}

mlir::LogicalResult StructType::verifyInvariants(
    llvm::function_ref<mlir::InFlightDiagnostic()> emitError,
    llvm::ArrayRef<mlir::Type> members, mlir::StringAttr name, bool incomplete,
    bool packed, bool padded, cir::StructType::RecordKind kind,
    ASTRecordDeclInterface ast) {
  if (name && name.getValue().empty()) {
    emitError() << "identified structs cannot have an empty name";
    return mlir::failure();
  }
  return mlir::success();
}

void StructType::dropAst() { getImpl()->ast = nullptr; }
StructType StructType::get(::mlir::MLIRContext *context, ArrayRef<Type> members,
                           StringAttr name, bool packed, bool padded,
                           RecordKind kind, ASTRecordDeclInterface ast) {
  return Base::get(context, members, name, /*incomplete=*/false, packed, padded,
                   kind, ast);
}

StructType StructType::getChecked(
    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError,
    ::mlir::MLIRContext *context, ArrayRef<Type> members, StringAttr name,
    bool packed, bool padded, RecordKind kind, ASTRecordDeclInterface ast) {
  return Base::getChecked(emitError, context, members, name,
                          /*incomplete=*/false, packed, padded, kind, ast);
}

StructType StructType::get(::mlir::MLIRContext *context, StringAttr name,
                           RecordKind kind) {
  return Base::get(context, /*members=*/ArrayRef<Type>{}, name,
                   /*incomplete=*/true, /*packed=*/false, /*padded=*/false,
                   kind,
                   /*ast=*/ASTRecordDeclInterface{});
}

StructType StructType::getChecked(
    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError,
    ::mlir::MLIRContext *context, StringAttr name, RecordKind kind) {
  return Base::getChecked(emitError, context, ArrayRef<Type>{}, name,
                          /*incomplete=*/true, /*packed=*/false,
                          /*padded=*/false, kind, ASTRecordDeclInterface{});
}

StructType StructType::get(::mlir::MLIRContext *context, ArrayRef<Type> members,
                           bool packed, bool padded, RecordKind kind,
                           ASTRecordDeclInterface ast) {
  return Base::get(context, members, StringAttr{}, /*incomplete=*/false, packed,
                   padded, kind, ast);
}

StructType StructType::getChecked(
    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError,
    ::mlir::MLIRContext *context, ArrayRef<Type> members, bool packed,
    bool padded, RecordKind kind, ASTRecordDeclInterface ast) {
  return Base::getChecked(emitError, context, members, StringAttr{},
                          /*incomplete=*/false, packed, padded, kind, ast);
}

::llvm::ArrayRef<mlir::Type> StructType::getMembers() const {
  return getImpl()->members;
}

bool StructType::isIncomplete() const { return getImpl()->incomplete; }

mlir::StringAttr StructType::getName() const { return getImpl()->name; }

bool StructType::getIncomplete() const { return getImpl()->incomplete; }

bool StructType::getPacked() const { return getImpl()->packed; }

bool StructType::getPadded() const { return getImpl()->padded; }

cir::StructType::RecordKind StructType::getKind() const {
  return getImpl()->kind;
}

ASTRecordDeclInterface StructType::getAst() const { return getImpl()->ast; }

void StructType::complete(ArrayRef<Type> members, bool packed, bool padded,
                          ASTRecordDeclInterface ast) {
  if (mutate(members, packed, padded, ast).failed())
    llvm_unreachable("failed to complete struct");
}

bool StructType::isLayoutIdentical(const StructType &other) {
  if (getImpl() == other.getImpl())
    return true;

  if (getPacked() != other.getPacked())
    return false;

  return getMembers() == other.getMembers();
}

//===----------------------------------------------------------------------===//
// Data Layout information for types
//===----------------------------------------------------------------------===//

llvm::TypeSize
BoolType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                            ::mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(8);
}

uint64_t
BoolType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                          ::mlir::DataLayoutEntryListRef params) const {
  return 1;
}

uint64_t
BoolType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                ::mlir::DataLayoutEntryListRef params) const {
  return 1;
}

llvm::TypeSize
PointerType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                               ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: improve this in face of address spaces
  return llvm::TypeSize::getFixed(64);
}

uint64_t
PointerType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                             ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: improve this in face of address spaces
  return 8;
}

uint64_t PointerType::getPreferredAlignment(
    const ::mlir::DataLayout &dataLayout,
    ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: improve this in face of address spaces
  return 8;
}

llvm::TypeSize
DataMemberType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                                  ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: consider size differences under different ABIs
  assert(!MissingFeatures::cxxABI());
  return llvm::TypeSize::getFixed(64);
}

uint64_t
DataMemberType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                                ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: consider alignment differences under different ABIs
  assert(!MissingFeatures::cxxABI());
  return 8;
}

uint64_t DataMemberType::getPreferredAlignment(
    const ::mlir::DataLayout &dataLayout,
    ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: consider alignment differences under different ABIs
  assert(!MissingFeatures::cxxABI());
  return 8;
}

llvm::TypeSize
ArrayType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                             ::mlir::DataLayoutEntryListRef params) const {
  return getSize() * dataLayout.getTypeSizeInBits(getEltType());
}

uint64_t
ArrayType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                           ::mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypeABIAlignment(getEltType());
}

uint64_t
ArrayType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                 ::mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypePreferredAlignment(getEltType());
}

llvm::TypeSize cir::VectorType::getTypeSizeInBits(
    const ::mlir::DataLayout &dataLayout,
    ::mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(getSize() *
                                  dataLayout.getTypeSizeInBits(getEltType()));
}

uint64_t
cir::VectorType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                                 ::mlir::DataLayoutEntryListRef params) const {
  return llvm::NextPowerOf2(dataLayout.getTypeSizeInBits(*this));
}

uint64_t cir::VectorType::getPreferredAlignment(
    const ::mlir::DataLayout &dataLayout,
    ::mlir::DataLayoutEntryListRef params) const {
  return llvm::NextPowerOf2(dataLayout.getTypeSizeInBits(*this));
}

llvm::TypeSize
StructType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                              ::mlir::DataLayoutEntryListRef params) const {
  if (!layoutInfo)
    computeSizeAndAlignment(dataLayout);
  return llvm::TypeSize::getFixed(
      mlir::cast<cir::StructLayoutAttr>(layoutInfo).getSize() * 8);
}

uint64_t
StructType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                            ::mlir::DataLayoutEntryListRef params) const {
  if (!layoutInfo)
    computeSizeAndAlignment(dataLayout);
  return mlir::cast<cir::StructLayoutAttr>(layoutInfo).getAlignment();
}

uint64_t
StructType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                  ::mlir::DataLayoutEntryListRef params) const {
  llvm_unreachable("NYI");
}

uint64_t StructType::getElementOffset(const ::mlir::DataLayout &dataLayout,
                                      unsigned idx) const {
  assert(idx < getMembers().size() && "access not valid");
  if (!layoutInfo)
    computeSizeAndAlignment(dataLayout);
  auto offsets = mlir::cast<cir::StructLayoutAttr>(layoutInfo).getOffsets();
  auto intAttr = mlir::cast<mlir::IntegerAttr>(offsets[idx]);
  return intAttr.getInt();
}

void StructType::computeSizeAndAlignment(
    const ::mlir::DataLayout &dataLayout) const {
  assert(isComplete() && "Cannot get layout of incomplete structs");
  // Do not recompute.
  if (layoutInfo)
    return;

  // This is a similar algorithm to LLVM's StructLayout.
  unsigned structSize = 0;
  llvm::Align structAlignment{1};
  bool isPadded = false;
  unsigned numElements = getNumElements();
  auto members = getMembers();
  mlir::Type largestMember;
  unsigned largestMemberSize = 0;
  llvm::SmallVector<mlir::Attribute, 4> memberOffsets;

  bool dontCountLastElt = isUnion() && getPadded();
  if (dontCountLastElt)
    numElements--;

  // Loop over each of the elements, placing them in memory.
  memberOffsets.reserve(numElements);

  for (unsigned i = 0, e = numElements; i != e; ++i) {
    auto ty = members[i];

    // Found a nested union: recurse into it to fetch its largest member.
    if (!largestMember ||
        dataLayout.getTypeABIAlignment(ty) >
            dataLayout.getTypeABIAlignment(largestMember) ||
        (dataLayout.getTypeABIAlignment(ty) ==
             dataLayout.getTypeABIAlignment(largestMember) &&
         dataLayout.getTypeSize(ty) > largestMemberSize)) {
      largestMember = ty;
      largestMemberSize = dataLayout.getTypeSize(largestMember);
    }

    // This matches LLVM since it uses the ABI instead of preferred alignment.
    const llvm::Align tyAlign =
        llvm::Align(getPacked() ? 1 : dataLayout.getTypeABIAlignment(ty));

    // Add padding if necessary to align the data element properly.
    if (!llvm::isAligned(tyAlign, structSize)) {
      isPadded = true;
      structSize = llvm::alignTo(structSize, tyAlign);
    }

    // Keep track of maximum alignment constraint.
    structAlignment = std::max(tyAlign, structAlignment);

    // Struct size up to each element is the element offset.
    memberOffsets.push_back(mlir::IntegerAttr::get(
        mlir::IntegerType::get(getContext(), 32), isUnion() ? 0 : structSize));

    // Consume space for this data item
    structSize += dataLayout.getTypeSize(ty);
  }

  // For unions, the size and aligment is that of the largest element.
  if (isUnion()) {
    structSize = largestMemberSize;
    if (getPadded()) {
      memberOffsets.push_back(mlir::IntegerAttr::get(
          mlir::IntegerType::get(getContext(), 32), structSize));
      auto ty = getMembers()[numElements];
      structSize += dataLayout.getTypeSize(ty);
      isPadded = true;
    } else {
      isPadded = false;
    }
  } else {
    // Add padding to the end of the struct so that it could be put in an array
    // and all array elements would be aligned correctly.
    if (!llvm::isAligned(structAlignment, structSize)) {
      isPadded = true;
      structSize = llvm::alignTo(structSize, structAlignment);
    }
  }

  auto offsets = mlir::ArrayAttr::get(getContext(), memberOffsets);
  layoutInfo = cir::StructLayoutAttr::get(getContext(), structSize,
                                          structAlignment.value(), isPadded,
                                          largestMember, offsets);
}

//===----------------------------------------------------------------------===//
// IntType Definitions
//===----------------------------------------------------------------------===//

Type IntType::parse(mlir::AsmParser &parser) {
  auto *context = parser.getBuilder().getContext();
  auto loc = parser.getCurrentLocation();
  bool isSigned;
  unsigned width;

  if (parser.parseLess())
    return {};

  // Fetch integer sign.
  llvm::StringRef sign;
  if (parser.parseKeyword(&sign))
    return {};
  if (sign == "s")
    isSigned = true;
  else if (sign == "u")
    isSigned = false;
  else {
    parser.emitError(loc, "expected 's' or 'u'");
    return {};
  }

  if (parser.parseComma())
    return {};

  // Fetch integer size.
  if (parser.parseInteger(width))
    return {};
  if (width < IntType::minBitwidth() || width > IntType::maxBitwidth()) {
    parser.emitError(loc, "expected integer width to be from ")
        << IntType::minBitwidth() << " up to " << IntType::maxBitwidth();
    return {};
  }

  if (parser.parseGreater())
    return {};

  return IntType::get(context, width, isSigned);
}

void IntType::print(mlir::AsmPrinter &printer) const {
  auto sign = isSigned() ? 's' : 'u';
  printer << '<' << sign << ", " << getWidth() << '>';
}

llvm::TypeSize
IntType::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                           mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(getWidth());
}

uint64_t IntType::getABIAlignment(const mlir::DataLayout &dataLayout,
                                  mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

uint64_t
IntType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                               ::mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

mlir::LogicalResult
IntType::verify(llvm::function_ref<mlir::InFlightDiagnostic()> emitError,
                unsigned width, bool isSigned) {

  if (width < IntType::minBitwidth() || width > IntType::maxBitwidth()) {
    emitError() << "IntType only supports widths from "
                << IntType::minBitwidth() << " up to "
                << IntType::maxBitwidth();
    return mlir::failure();
  }

  return mlir::success();
}

//===----------------------------------------------------------------------===//
// Floating-point type definitions
//===----------------------------------------------------------------------===//

const llvm::fltSemantics &SingleType::getFloatSemantics() const {
  return llvm::APFloat::IEEEsingle();
}

llvm::TypeSize
SingleType::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                              mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(getWidth());
}

uint64_t
SingleType::getABIAlignment(const mlir::DataLayout &dataLayout,
                            mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

uint64_t
SingleType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                  ::mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

const llvm::fltSemantics &DoubleType::getFloatSemantics() const {
  return llvm::APFloat::IEEEdouble();
}

llvm::TypeSize
DoubleType::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                              mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(getWidth());
}

uint64_t
DoubleType::getABIAlignment(const mlir::DataLayout &dataLayout,
                            mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

uint64_t
DoubleType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                  ::mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

const llvm::fltSemantics &FP16Type::getFloatSemantics() const {
  return llvm::APFloat::IEEEhalf();
}

llvm::TypeSize
FP16Type::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                            mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(getWidth());
}

uint64_t FP16Type::getABIAlignment(const mlir::DataLayout &dataLayout,
                                   mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

uint64_t
FP16Type::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                ::mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

const llvm::fltSemantics &BF16Type::getFloatSemantics() const {
  return llvm::APFloat::BFloat();
}

llvm::TypeSize
BF16Type::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                            mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(getWidth());
}

uint64_t BF16Type::getABIAlignment(const mlir::DataLayout &dataLayout,
                                   mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

uint64_t
BF16Type::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                ::mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

const llvm::fltSemantics &FP80Type::getFloatSemantics() const {
  return llvm::APFloat::x87DoubleExtended();
}

llvm::TypeSize
FP80Type::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                            mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(128);
}

uint64_t FP80Type::getABIAlignment(const mlir::DataLayout &dataLayout,
                                   mlir::DataLayoutEntryListRef params) const {
  return 16;
}

uint64_t
FP80Type::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                ::mlir::DataLayoutEntryListRef params) const {
  return 16;
}

const llvm::fltSemantics &FP128Type::getFloatSemantics() const {
  return llvm::APFloat::IEEEquad();
}

llvm::TypeSize
FP128Type::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                             mlir::DataLayoutEntryListRef params) const {
  // FIXME: We probably want it to return 128. But we're lacking a test now.
  return llvm::TypeSize::getFixed(16);
}

uint64_t FP128Type::getABIAlignment(const mlir::DataLayout &dataLayout,
                                    mlir::DataLayoutEntryListRef params) const {
  return 16;
}

uint64_t
FP128Type::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                 ::mlir::DataLayoutEntryListRef params) const {
  return 16;
}

const llvm::fltSemantics &LongDoubleType::getFloatSemantics() const {
  return mlir::cast<cir::CIRFPTypeInterface>(getUnderlying())
      .getFloatSemantics();
}

llvm::TypeSize
LongDoubleType::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                                  mlir::DataLayoutEntryListRef params) const {
  return mlir::cast<mlir::DataLayoutTypeInterface>(getUnderlying())
      .getTypeSizeInBits(dataLayout, params);
}

uint64_t
LongDoubleType::getABIAlignment(const mlir::DataLayout &dataLayout,
                                mlir::DataLayoutEntryListRef params) const {
  return mlir::cast<mlir::DataLayoutTypeInterface>(getUnderlying())
      .getABIAlignment(dataLayout, params);
}

uint64_t LongDoubleType::getPreferredAlignment(
    const ::mlir::DataLayout &dataLayout,
    mlir::DataLayoutEntryListRef params) const {
  return mlir::cast<mlir::DataLayoutTypeInterface>(getUnderlying())
      .getPreferredAlignment(dataLayout, params);
}

LogicalResult
LongDoubleType::verify(function_ref<InFlightDiagnostic()> emitError,
                       mlir::Type underlying) {
  if (!mlir::isa<DoubleType, FP80Type, FP128Type>(underlying)) {
    emitError() << "invalid underlying type for long double";
    return failure();
  }

  return success();
}

//===----------------------------------------------------------------------===//
// Floating-point type helpers
//===----------------------------------------------------------------------===//

bool cir::isAnyFloatingPointType(mlir::Type t) {
  return isa<cir::SingleType, cir::DoubleType, cir::LongDoubleType,
             cir::FP80Type>(t);
}

//===----------------------------------------------------------------------===//
// Floating-point and Float-point Vector type helpers
//===----------------------------------------------------------------------===//

bool cir::isFPOrFPVectorTy(mlir::Type t) {

  if (isa<cir::VectorType>(t)) {
    return isAnyFloatingPointType(
        mlir::dyn_cast<cir::VectorType>(t).getEltType());
  }
  return isAnyFloatingPointType(t);
}

//===----------------------------------------------------------------------===//
// CIR Integer and Integer Vector type helpers
//===----------------------------------------------------------------------===//

bool cir::isIntOrIntVectorTy(mlir::Type t) {

  if (isa<cir::VectorType>(t)) {
    return isa<cir::IntType>(mlir::dyn_cast<cir::VectorType>(t).getEltType());
  }
  return isa<cir::IntType>(t);
}

//===----------------------------------------------------------------------===//
// ComplexType Definitions
//===----------------------------------------------------------------------===//

mlir::LogicalResult cir::ComplexType::verify(
    llvm::function_ref<mlir::InFlightDiagnostic()> emitError,
    mlir::Type elementTy) {
  if (!mlir::isa<cir::IntType, cir::CIRFPTypeInterface>(elementTy)) {
    emitError() << "element type of !cir.complex must be either a "
                   "floating-point type or an integer type";
    return failure();
  }

  return success();
}

llvm::TypeSize
cir::ComplexType::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                                    mlir::DataLayoutEntryListRef params) const {
  // C17 6.2.5p13:
  //   Each complex type has the same representation and alignment requirements
  //   as an array type containing exactly two elements of the corresponding
  //   real type.

  auto elementTy = getElementTy();
  return dataLayout.getTypeSizeInBits(elementTy) * 2;
}

uint64_t
cir::ComplexType::getABIAlignment(const mlir::DataLayout &dataLayout,
                                  mlir::DataLayoutEntryListRef params) const {
  // C17 6.2.5p13:
  //   Each complex type has the same representation and alignment requirements
  //   as an array type containing exactly two elements of the corresponding
  //   real type.

  auto elementTy = getElementTy();
  return dataLayout.getTypeABIAlignment(elementTy);
}

uint64_t cir::ComplexType::getPreferredAlignment(
    const ::mlir::DataLayout &dataLayout,
    ::mlir::DataLayoutEntryListRef params) const {
  // C17 6.2.5p13:
  //   Each complex type has the same representation and alignment requirements
  //   as an array type containing exactly two elements of the corresponding
  //   real type.

  auto elementTy = getElementTy();
  return dataLayout.getTypePreferredAlignment(elementTy);
}

//===----------------------------------------------------------------------===//
// FuncType Definitions
//===----------------------------------------------------------------------===//

FuncType FuncType::clone(TypeRange inputs, TypeRange results) const {
  assert(results.size() == 1 && "expected exactly one result type");
  return get(llvm::to_vector(inputs), results[0], isVarArg());
}

// A special parser is needed for function returning void to handle the missing
// type.
static mlir::ParseResult parseFuncTypeReturn(mlir::AsmParser &p,
                                             mlir::Type &optionalReturnType) {
  if (succeeded(p.parseOptionalArrow())) {
    // `->` found. It must be followed by the return type.
    return p.parseType(optionalReturnType);
  }
  // Function has `void` return in C++, no return in MLIR.
  optionalReturnType = {};
  return success();
}

// A special pretty-printer for function returning or not a result.
static void printFuncTypeReturn(mlir::AsmPrinter &p,
                                mlir::Type optionalReturnType) {
  if (optionalReturnType)
    p << " -> " << optionalReturnType;
}

static mlir::ParseResult
parseFuncTypeArgs(mlir::AsmParser &p, llvm::SmallVector<mlir::Type> &params,
                  bool &isVarArg) {
  isVarArg = false;
  if (failed(p.parseLParen()))
    return failure();
  if (succeeded(p.parseOptionalRParen())) {
    // `()` empty argument list
    return mlir::success();
  }
  do {
    if (succeeded(p.parseOptionalEllipsis())) {
      // `...`, which must be the last thing in the list.
      isVarArg = true;
      break;
    } else {
      mlir::Type argType;
      if (failed(p.parseType(argType)))
        return failure();
      params.push_back(argType);
    }
  } while (succeeded(p.parseOptionalComma()));
  return p.parseRParen();
}

static void printFuncTypeArgs(mlir::AsmPrinter &p,
                              mlir::ArrayRef<mlir::Type> params,
                              bool isVarArg) {
  p << '(';
  llvm::interleaveComma(params, p,
                        [&p](mlir::Type type) { p.printType(type); });
  if (isVarArg) {
    if (!params.empty())
      p << ", ";
    p << "...";
  }
  p << ')';
}

// Use a custom parser to handle the optional return and argument types without
// an optional anchor.
static mlir::ParseResult parseFuncType(mlir::AsmParser &p,
                                       mlir::Type &optionalReturnType,
                                       llvm::SmallVector<mlir::Type> &params,
                                       bool &isVarArg) {
  if (failed(parseFuncTypeArgs(p, params, isVarArg)))
    return failure();
  return parseFuncTypeReturn(p, optionalReturnType);
}

static void printFuncType(mlir::AsmPrinter &p, mlir::Type optionalReturnType,
                          mlir::ArrayRef<mlir::Type> params, bool isVarArg) {
  printFuncTypeArgs(p, params, isVarArg);
  printFuncTypeReturn(p, optionalReturnType);
}

/// Get the C-style return type of the function, which is !cir.void if the
/// function returns nothing and the actual return type otherwise.
mlir::Type FuncType::getReturnType() const {
  if (hasVoidReturn())
    return cir::VoidType::get(getContext());
  return getOptionalReturnType();
}

/// Get the MLIR-style return type of the function, which is an empty
/// ArrayRef if the function returns nothing and a single-element ArrayRef
/// with the actual return type otherwise.
llvm::ArrayRef<mlir::Type> FuncType::getReturnTypes() const {
  if (hasVoidReturn())
    return {};
  // Can't use getOptionalReturnType() here because llvm::ArrayRef hold a
  // pointer to its elements and doesn't do lifetime extension.  That would
  // result in returning a pointer to a temporary that has gone out of scope.
  return getImpl()->optionalReturnType;
}

// Does the fuction type return nothing?
bool FuncType::hasVoidReturn() const { return !getOptionalReturnType(); }

mlir::LogicalResult
FuncType::verify(llvm::function_ref<mlir::InFlightDiagnostic()> emitError,
                 llvm::ArrayRef<mlir::Type> argTypes, mlir::Type returnType,
                 bool isVarArg) {
  if (returnType && mlir::isa<cir::VoidType>(returnType)) {
    emitError() << "!cir.func cannot have an explicit 'void' return type";
    return mlir::failure();
  }
  return mlir::success();
}

//===----------------------------------------------------------------------===//
// MethodType Definitions
//===----------------------------------------------------------------------===//

static mlir::Type getMethodLayoutType(mlir::MLIRContext *ctx) {
  // With Itanium ABI, member function pointers have the same layout as the
  // following struct: struct { fnptr_t, ptrdiff_t }, where fnptr_t is a
  // function pointer type.
  // TODO: consider member function pointer layout in other ABIs
  auto voidPtrTy = cir::PointerType::get(cir::VoidType::get(ctx));
  mlir::Type fields[2]{voidPtrTy, voidPtrTy};
  return cir::StructType::get(ctx, fields, /*packed=*/false,
                              /*padded=*/false, cir::StructType::Struct);
}

llvm::TypeSize
MethodType::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                              mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypeSizeInBits(getMethodLayoutType(getContext()));
}

uint64_t
MethodType::getABIAlignment(const mlir::DataLayout &dataLayout,
                            mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypeSizeInBits(getMethodLayoutType(getContext()));
}

uint64_t
MethodType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                  mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypeSizeInBits(getMethodLayoutType(getContext()));
}

//===----------------------------------------------------------------------===//
// PointerType Definitions
//===----------------------------------------------------------------------===//

mlir::LogicalResult
PointerType::verify(llvm::function_ref<mlir::InFlightDiagnostic()> emitError,
                    mlir::Type pointee, mlir::Attribute addrSpace) {
  if (addrSpace && !mlir::isa<cir::AddressSpaceAttr>(addrSpace)) {
    emitError() << "unexpected addrspace attribute type";
    return mlir::failure();
  }
  return mlir::success();
}

mlir::ParseResult parseAddrSpaceAttribute(mlir::AsmParser &p,
                                          mlir::Attribute &addrSpaceAttr) {
  using cir::AddressSpaceAttr;
  auto attrLoc = p.getCurrentLocation();

  llvm::StringRef addrSpaceKind;
  if (mlir::failed(p.parseOptionalKeyword(&addrSpaceKind))) {
    p.emitError(attrLoc, "expected keyword for addrspace kind");
    return mlir::failure();
  }

  if (addrSpaceKind == AddressSpaceAttr::kTargetKeyword) {
    int64_t targetValue = -1;
    if (p.parseLess() || p.parseInteger(targetValue) || p.parseGreater()) {
      return mlir::failure();
    }
    addrSpaceAttr = AddressSpaceAttr::get(
        p.getContext(), AddressSpaceAttr::kFirstTargetASValue + targetValue);
  } else {
    std::optional<int64_t> value =
        AddressSpaceAttr::parseValueFromString(addrSpaceKind);
    // not target AS, must be wrong keyword if no value
    if (!value.has_value()) {
      p.emitError(attrLoc, "invalid addrspace kind keyword: " + addrSpaceKind);
      return mlir::failure();
    }

    addrSpaceAttr = AddressSpaceAttr::get(p.getContext(), *value);
  }

  return mlir::success();
}

void printAddrSpaceAttribute(mlir::AsmPrinter &p,
                             mlir::Attribute rawAddrSpaceAttr) {
  using cir::AddressSpaceAttr;
  auto addrSpaceAttr = mlir::cast<AddressSpaceAttr>(rawAddrSpaceAttr);
  if (addrSpaceAttr.isTarget()) {
    p << AddressSpaceAttr::kTargetKeyword << "<"
      << addrSpaceAttr.getTargetValue() << ">";
  } else {
    p << AddressSpaceAttr::stringifyValue(addrSpaceAttr.getValue());
  }
}

mlir::ParseResult parsePointerAddrSpace(mlir::AsmParser &p,
                                        mlir::Attribute &addrSpaceAttr) {
  return parseAddrSpaceAttribute(p, addrSpaceAttr);
}

void printPointerAddrSpace(mlir::AsmPrinter &p,
                           mlir::Attribute rawAddrSpaceAttr) {
  printAddrSpaceAttribute(p, rawAddrSpaceAttr);
}

//===----------------------------------------------------------------------===//
// CIR Dialect
//===----------------------------------------------------------------------===//

void CIRDialect::registerTypes() {
  // Register tablegen'd types.
  addTypes<
#define GET_TYPEDEF_LIST
#include "clang/CIR/Dialect/IR/CIROpsTypes.cpp.inc"
      >();

  // Register raw C++ types.
  addTypes<StructType>();
}
