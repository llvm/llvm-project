<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>AST Matcher Reference</title>
<link type="text/css" rel="stylesheet" href="../menu.css" />
<link type="text/css" rel="stylesheet" href="../content.css" />
<style type="text/css">
td {
  padding: .33em;
}
td.doc {
  display: none;
  border-bottom: 1px solid black;
}
td.name:hover {
  color: blue;
  cursor: pointer;
}
span.mono { font-family: monospace; }

.traverse_compare, .traverse_compare td, .traverse_compare th {
  border: 1px solid black;
  border-collapse: collapse;
}
</style>
<script type="text/javascript">
function toggle(id) {
  if (!id) return;
  row = document.getElementById(id);
  if (row.style.display != 'table-cell')
    row.style.display = 'table-cell';
  else
    row.style.display = 'none';
}
</script>
</head>
<body onLoad="toggle(location.hash.substring(1, location.hash.length - 6))">

<!--#include virtual="../menu.html.incl"-->

<div id="content">

<h1>AST Matcher Reference</h1>

<p>This document shows all currently implemented matchers. The matchers are grouped
by category and node type they match. You can click on matcher names to show the
matcher's source documentation.</p>

<p>There are three different basic categories of matchers:
<ul>
<li><a href="#decl-matchers">Node Matchers:</a> Matchers that match a specific type of AST node.</li>
<li><a href="#narrowing-matchers">Narrowing Matchers:</a> Matchers that match attributes on AST nodes.</li>
<li><a href="#traversal-matchers">Traversal Matchers:</a> Matchers that allow traversal between AST nodes.</li>
</ul>
</p>

<p>Within each category the matchers are ordered by node type they match on.
Note that if a matcher can match multiple node types, it will appear
multiple times. This means that by searching for Matcher&lt;Stmt&gt; you can
find all matchers that can be used to match on Stmt nodes.</p>

<p>The exception to that rule are matchers that can match on any node. Those
are marked with a * and are listed in the beginning of each category.</p>

<p>Note that the categorization of matchers is a great help when you combine
them into matcher expressions. You will usually want to form matcher expressions
that read like english sentences by alternating between node matchers and
narrowing or traversal matchers, like this:
<pre>
recordDecl(hasDescendant(
    ifStmt(hasTrueExpression(
        expr(hasDescendant(
            ifStmt()))))))
</pre>
</p>

<!-- ======================================================================= -->
<h2 id="traverse-mode">Traverse Mode</h2>
<!-- ======================================================================= -->

<p>The default mode of operation of AST Matchers visits all nodes in the AST,
even if they are not spelled in the source. This is
<span class="mono">AsIs</span> mode.  This mode requires writing AST matchers
that explicitly traverse or ignore implicit nodes, such as parentheses
surrounding an expression or expressions with cleanups.  These implicit
nodes are not always obvious from the syntax of the source code, and so this
mode requires careful consideration and testing to get the desired behavior
from an AST matcher.
</p>

<p>In addition, because template instantiations are matched in the default mode,
transformations can be accidentally made to template declarations. Finally,
because implicit nodes are matched by default, transformations can be made on
entirely incorrect places in the code.</p>

<p>For these reasons, it is possible to ignore AST nodes which are not spelled
in the source using the <span class="mono">IgnoreUnlessSpelledInSource</span>
mode. This is likely to be far less error-prone for users who are not already
very familiar with where implicit nodes appear in the AST. It is also likely
to be less error-prone for experienced AST users, as difficult cases do not
need to be encountered and matcher expressions adjusted for these cases.</p>

<p>In clang-query, the mode can be changed with
<pre>
set traversal IgnoreUnlessSpelledInSource
</pre>
</p>
This affects both matchers and AST dump output in results.

<p>When using the C++ API such as in clang-tidy checks, the
<span class="mono">traverse()</span> matcher is used to set the mode:
<pre>
Finder->addMatcher(traverse(TK_IgnoreUnlessSpelledInSource,
  returnStmt(hasReturnValue(integerLiteral(equals(0))))
  ), this);
</pre>
</p>
<p>The following table compares the <span class="mono">AsIs</span> mode with
the <span class="mono">IgnoreUnlessSpelledInSource</span> mode:</p>

<table class="traverse_compare">
<tr>
<th></th>
<th><span class="mono">AsIs</span></th>
<th><span class="mono">IgnoreUnlessSpelledInSource</span></th>
</tr>
<tr>
  <td>AST dump of <span class="mono">func1</span>:
<pre>
struct B {
  B(int);
};

B func1() { return 42; }
</pre>

  </td>
  <td>
C++98 dialect:
<pre>
FunctionDecl
`-CompoundStmt
  `-ReturnStmt
    `-ExprWithCleanups
      `-CXXConstructExpr
        `-MaterializeTemporaryExpr
          `-ImplicitCastExpr
            `-ImplicitCastExpr
              `-CXXConstructExpr
                `-IntegerLiteral 'int' 42
</pre>
C++11, C++14 dialect:
<pre>
FunctionDecl
`-CompoundStmt
  `-ReturnStmt
    `-ExprWithCleanups
      `-CXXConstructExpr
        `-MaterializeTemporaryExpr
          `-ImplicitCastExpr
            `-CXXConstructExpr
              `-IntegerLiteral 'int' 42
</pre>
C++17, C++20 dialect:
<pre>
FunctionDecl
`-CompoundStmt
  `-ReturnStmt
    `-ImplicitCastExpr
      `-CXXConstructExpr
        `-IntegerLiteral 'int' 42
</pre>
</td>
  <td>
All dialects:
    <pre>
FunctionDecl
`-CompoundStmt
  `-ReturnStmt
    `-IntegerLiteral 'int' 42
</pre></td>
</tr>

<tr>
<td>Matcher for returned <span class="mono">42</span>:
<pre>
struct B {
  B(int);
};

B func1() { return 42; }
</pre>

  </td>
  <td>
All dialects:
<pre>
returnStmt(hasReturnValue(
    ignoringImplicit(
        ignoringElidableConstructorCall(
            ignoringImplicit(
                cxxConstructExpr(hasArgument(0,
                    ignoringImplicit(
                        integerLiteral().bind("returnVal")
                        )
                    ))
                )
            )
        )
    ))
</pre></td>
  <td>
All dialects:
<pre>
returnStmt(hasReturnValue(
    integerLiteral().bind("returnVal")
))
</pre></td>
</tr>
<tr>
<td>Match result for
<pre>implicitCastExpr()</pre>
given:
<pre>
struct B {
  B(int);
};

B func1() { return 42; }
</pre>

</td>
<td>
Match found.</td>
  <td>
No match.</td>
</tr>
<tr>
  <td>Match result for:
<pre>
cxxConstructorDecl(
  isCopyConstructor()
  ).bind("prepend_explicit")
</pre>
given:
<pre>
struct Other {};
struct Copyable {
  Other m_o;
  Copyable();
};
</pre>
</td>
<td>
Match found. Insertion produces incorrect output:
<pre>
struct Other {};
struct explicit Copyable {
  Other m_o;
  Copyable();
};
</pre>
</td>
<td>
No match found. Incorrect replacement not possible.
</td>
</tr>
<tr>
  <td>Replacement of <span class="mono">begin()</span>
    with <span class="mono">cbegin()</span>:
<pre>
cxxMemberCallExpr(
  on(ConstContainerExpr),
  callee(cxxMethodDecl(hasName("begin")))
  ).bind("replace_with_cbegin")
</pre>
given:
<pre>
void foo() {
  const Container c;
  c.begin();

  for (auto i : c) {
  }
}
</pre>
</td>
<td>
2 matches found. Replacement produces incorrect output:
<pre>
void foo() {
  const Container c;
  c.cbegin();

  for (auto i :.cbegin() c) {
  }
}
</pre>
</td>
<td>
1 match found. Replacement produces correct output:
<pre>
void foo() {
  const Container c;
  c.cbegin();

  for (auto i : c) {
  }
}
</pre>
</td>
</tr>
<tr>
  <td>Replacement of <span class="mono">int</span> member
    with <span class="mono">safe_int</span>:
<pre>
fieldDecl(
  hasType(asString("int"))
  ).bind("use_safe_int")
</pre>
given:
<pre>
struct S {
  int m_i;
};

template &lt;typename T&gt; struct TemplStruct {
  TemplStruct() {}
  ~TemplStruct() {}

private:
  T m_t;
};

void instantiate() { TemplStruct&lt;int&gt; ti; }
</pre>
</td>
<td>
2 matches found. Replacement produces incorrect output:
<pre>
struct S {
  safe_int m_i;
};

template &lt;typename T&gt; struct TemplStruct {
  TemplStruct() {}
  ~TemplStruct() {}

private:
  safe_int m_t;
};

void instantiate() { TemplStruct&lt;int&gt; ti; }
</pre>
</td>
<td>
1 match found. Replacement produces correct output:
<pre>
struct S {
  safe_int m_i;
};

template &lt;typename T&gt; struct TemplStruct {
  TemplStruct() {}
  ~TemplStruct() {}

private:
  T m_t;
};

void instantiate() { TemplStruct&lt;int&gt; ti; }
</pre>
</td>
</tr>
<tr>
  <td>Add prefix to member initializer
<pre>
cxxCtorInitializer(
  forField(fieldDecl())
  ).bind("add_prefix")
</pre>
given:
<pre>
struct Simple {};

struct Record {
  Record() : i(42) {}
private:
  int i;
  Simple s;
};
</pre>
</td>
<td>
2 matches found. Replacement produces incorrect output:
<pre>
struct Simple {};

struct Record {
  m_Record() : m_i(42) {}
private:
  int i;
  Simple s;
};
</pre>
</td>
<td>
1 match found. Replacement produces correct output:
<pre>
struct Simple {};

struct Record {
  Record() : m_i(42) {}
private:
  int i;
  Simple s;
};
</pre>
</td>
</tr>
<tr>
  <td>Ignored default arguments
<pre>
callExpr(
  callee(functionDecl(
    hasName("hasDefaultArg")
    )),
  argumentCountIs(1)
  ).bind("add_prefix")
</pre>
given:
<pre>
void hasDefaultArg(int i, int j = 0) {}
void callDefaultArg() { hasDefaultArg(42); }
</pre>
</td>
<td>
No match.
</td>
<td>
1 match found.
</td>
</tr>
<tr>
  <td>Lambda fields
<pre>
fieldDecl(
  hasType(asString("int"))
  ).bind("make_safe")
</pre>
given:
<pre>
struct S {
  int m_i;
};

void func() {
  int a = 0;
  int c = 0;

  auto l = [a, b = c](int d) { int e = d; };
  l(43);
}
</pre>
</td>
<td>
2 matches found. Replacement produces incorrect output:
<pre>
struct S {
  safe_int m_i;
};

void func() {
  int a = 0;
  int c = 0;

  auto l = [safe_a, safe_b = c](int d) { int e = d; };
  l(43);
}
</pre>
</td>
<td>
1 match found. Replacement produces correct output:
<pre>
struct S {
  safe_int m_i;
};

void func() {
  int a = 0;
  int c = 0;

  auto l = [a, b = c](int d) { int e = d; };
  l(43);
}
</pre>
</td>

</tr>





<tr>
  <td>Rewritten binary operators
<pre>
binaryOperator(
  hasOperatorName("&lt;"),
  hasRHS(hasDescendant(integerLiteral(equals(0))))
  )
</pre>
given:
<pre>
#include &lt;compare&gt;

class HasSpaceship {
public:
   int x;
   bool operator==(const HasSpaceship&) const = default;
   std::strong_ordering operator<=>(const HasSpaceship&) const = default;
};

bool isLess(const HasSpaceship& a, const HasSpaceship& b) {
   return a < b;
}
</pre>
</td>
<td>
1 match found.

<pre>
   return a < b;
          ^~~~~
</pre>

</td>
<td>
No match found.
</td>
</tr>
</table>

<!-- ======================================================================= -->
<h2 id="decl-matchers">Node Matchers</h2>
<!-- ======================================================================= -->

<p>Node matchers are at the core of matcher expressions - they specify the type
of node that is expected. Every match expression starts with a node matcher,
which can then be further refined with a narrowing or traversal matcher. All
traversal matchers take node matchers as their arguments.</p>

<p>For convenience, all node matchers take an arbitrary number of arguments
and implicitly act as allOf matchers.</p>

<p>Node matchers are the only matchers that support the bind("id") call to
bind the matched node to the given string, to be later retrieved from the
match callback.</p>

<p>It is important to remember that the arguments to node matchers are
predicates on the same node, just with additional information about the type.
This is often useful to make matcher expression more readable by inlining bind
calls into redundant node matchers inside another node matcher:
<pre>
// This binds the CXXRecordDecl to "id", as the decl() matcher will stay on
// the same node.
recordDecl(decl().bind("id"), hasName("::MyClass"))
</pre>
</p>

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
<!-- START_DECL_MATCHERS -->

<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Attr.html">Attr</a>&gt;</td><td class="name" onclick="toggle('attr0')"><a name="attr0Anchor">attr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Attr.html">Attr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="attr0"><pre>Matches attributes.
Attributes may be attached with a variety of different syntaxes (including
keywords, C++11 attributes, GNU ``__attribute``` and MSVC `__declspec``,
and ``#pragma``s). They may also be implicit.

Given
  struct [[nodiscard]] Foo{};
  void bar(int * __attribute__((nonnull)) );
  __declspec(noinline) void baz();

  #pragma omp declare simd
  int min();

The matcher attr()
matches nodiscard, nonnull, noinline, and
declare simd.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('cxxBaseSpecifier0')"><a name="cxxBaseSpecifier0Anchor">cxxBaseSpecifier</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxBaseSpecifier0"><pre>Matches class bases.

Given
  class B {};
  class C : public virtual B {};

The matcher cxxRecordDecl(hasDirectBase(cxxBaseSpecifier()))
matches C.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td><td class="name" onclick="toggle('cxxCtorInitializer0')"><a name="cxxCtorInitializer0Anchor">cxxCtorInitializer</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxCtorInitializer0"><pre>Matches constructor initializers.

Given
  class C {
    C() : i(42) {}
    int i;
  };

The matcher cxxCtorInitializer()
matches i(42).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('accessSpecDecl0')"><a name="accessSpecDecl0Anchor">accessSpecDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AccessSpecDecl.html">AccessSpecDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="accessSpecDecl0"><pre>Matches C++ access specifier declarations.

Given
  class C {
  public:
    int a;
  };

The matcher accessSpecDecl()
matches public:.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('bindingDecl0')"><a name="bindingDecl0Anchor">bindingDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BindingDecl.html">BindingDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="bindingDecl0"><pre>Matches binding declarations

Given
  struct pair { int x; int y; };
  pair make(int, int);
  auto [foo, bar] = make(42, 42);

The matcher bindingDecl()
matches foo and bar.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('blockDecl0')"><a name="blockDecl0Anchor">blockDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="blockDecl0"><pre>Matches block declarations.

Example matches the declaration of the nameless block printing an input
integer.

  myFunc(^(int p) {
    printf("%d", p);
  })

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('classTemplateDecl0')"><a name="classTemplateDecl0Anchor">classTemplateDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="classTemplateDecl0"><pre>Matches C++ class template declarations.

Given
  template&lt;class T&gt; class Z {};

The matcher classTemplateDecl()
matches Z.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('classTemplatePartialSpecializationDecl0')"><a name="classTemplatePartialSpecializationDecl0Anchor">classTemplatePartialSpecializationDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplatePartialSpecializationDecl.html">ClassTemplatePartialSpecializationDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="classTemplatePartialSpecializationDecl0"><pre>Matches C++ class template partial specializations.

Given
  template&lt;class T1, class T2, int I&gt;
  class A {};

  template&lt;class T, int I&gt; class A&lt;T, T*, I&gt; {};

  template&lt;&gt;
  class A&lt;int, int, 1&gt; {};

The matcher classTemplatePartialSpecializationDecl()
matches template&lt;class T, int I&gt; class A&lt;T, T*, I&gt; {},
but does not match A&lt;int, int, 1&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('classTemplateSpecializationDecl0')"><a name="classTemplateSpecializationDecl0Anchor">classTemplateSpecializationDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="classTemplateSpecializationDecl0"><pre>Matches C++ class template specializations.

Given
  template&lt;typename T&gt; class A {};
  template&lt;&gt; class A&lt;double&gt; {};
  A&lt;int&gt; a;

The matcher classTemplateSpecializationDecl()
matches class A&lt;int&gt;
and class A&lt;double&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('conceptDecl0')"><a name="conceptDecl0Anchor">conceptDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ConceptDecl.html">ConceptDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="conceptDecl0"><pre>Matches concept declarations.

Given
  template&lt;typename T&gt; concept my_concept = true;


The matcher conceptDecl()
matches template&lt;typename T&gt;
concept my_concept = true.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('cxxConstructorDecl0')"><a name="cxxConstructorDecl0Anchor">cxxConstructorDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxConstructorDecl0"><pre>Matches C++ constructor declarations.

Given
  class Foo {
   public:
    Foo();
    Foo(int);
    int DoSomething();
  };

  struct Bar {};


The matcher cxxConstructorDecl()
matches Foo() and Foo(int).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('cxxConversionDecl0')"><a name="cxxConversionDecl0Anchor">cxxConversionDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxConversionDecl0"><pre>Matches conversion operator declarations.

Given
  class X { operator int() const; };


The matcher cxxConversionDecl()
matches operator int() const.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('cxxDeductionGuideDecl0')"><a name="cxxDeductionGuideDecl0Anchor">cxxDeductionGuideDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxDeductionGuideDecl0"><pre>Matches user-defined and implicitly generated deduction guide.

Given
  template&lt;typename T&gt;
  class X { X(int); };
  X(int) -&gt; X&lt;int&gt;;


The matcher cxxDeductionGuideDecl()
matches the written deduction guide
auto (int) -&gt; X&lt;int&gt;,
the implicit copy deduction guide auto (int) -&gt; X&lt;T&gt;
and the implicitly declared deduction guide
auto (X&lt;T&gt;) -&gt; X&lt;T&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('cxxDestructorDecl0')"><a name="cxxDestructorDecl0Anchor">cxxDestructorDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDestructorDecl.html">CXXDestructorDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxDestructorDecl0"><pre>Matches explicit C++ destructor declarations.

Given
  class Foo {
   public:
    virtual ~Foo();
  };

  struct Bar {};


The matcher cxxDestructorDecl()
matches virtual ~Foo().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('cxxMethodDecl0')"><a name="cxxMethodDecl0Anchor">cxxMethodDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxMethodDecl0"><pre>Matches method declarations.

Given
  class X { void y(); };


The matcher cxxMethodDecl()
matches void y().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('cxxRecordDecl0')"><a name="cxxRecordDecl0Anchor">cxxRecordDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxRecordDecl0"><pre>Matches C++ class declarations.

Given
  class X;
  template&lt;class T&gt; class Z {};

The matcher cxxRecordDecl()
matches X and Z.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('decl0')"><a name="decl0Anchor">decl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="decl0"><pre>Matches declarations.

Given
  void X();
  class C {
    friend void X();
  };

The matcher decl()
matches void X(), C
and friend void X().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('declaratorDecl0')"><a name="declaratorDecl0Anchor">declaratorDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="declaratorDecl0"><pre>Matches declarator declarations (field, variable, function
and non-type template parameter declarations).

Given
  class X { int y; };

The matcher declaratorDecl()
matches int y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('decompositionDecl0')"><a name="decompositionDecl0Anchor">decompositionDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecompositionDecl.html">DecompositionDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="decompositionDecl0"><pre>Matches decomposition-declarations.

Given
  struct pair { int x; int y; };
  pair make(int, int);
  int number = 42;
  auto [foo, bar] = make(42, 42);

The matcher decompositionDecl()
matches auto [foo, bar] = make(42, 42),
but does not match number.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('enumConstantDecl0')"><a name="enumConstantDecl0Anchor">enumConstantDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumConstantDecl.html">EnumConstantDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="enumConstantDecl0"><pre>Matches enum constants.

Given
  enum X {
    A, B, C
  };
The matcher enumConstantDecl()
matches A, B and C.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('enumDecl0')"><a name="enumDecl0Anchor">enumDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumDecl.html">EnumDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="enumDecl0"><pre>Matches enum declarations.

Given
  enum X {
    A, B, C
  };

The matcher enumDecl()
matches the enum X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('fieldDecl0')"><a name="fieldDecl0Anchor">fieldDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FieldDecl.html">FieldDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="fieldDecl0"><pre>Matches field declarations.

Given
  int a;
  struct Foo {
    int x;
  };
  void bar(int val);

The matcher fieldDecl()
matches int x.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('friendDecl0')"><a name="friendDecl0Anchor">friendDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FriendDecl.html">FriendDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="friendDecl0"><pre>Matches friend declarations.

Given
  class X { friend void foo(); };

The matcher friendDecl()
matches friend void foo().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('functionDecl0')"><a name="functionDecl0Anchor">functionDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="functionDecl0"><pre>Matches function declarations.

Given
  void f();

The matcher functionDecl()
matches void f().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('functionTemplateDecl0')"><a name="functionTemplateDecl0Anchor">functionTemplateDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionTemplateDecl.html">FunctionTemplateDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="functionTemplateDecl0"><pre>Matches C++ function template declarations.

Example matches f
  template&lt;class T&gt; void f(T t) {}


The matcher functionTemplateDecl()
matches template&lt;class T&gt; void f(T t) {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('indirectFieldDecl0')"><a name="indirectFieldDecl0Anchor">indirectFieldDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IndirectFieldDecl.html">IndirectFieldDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="indirectFieldDecl0"><pre>Matches indirect field declarations.

Given
  struct X { struct { int a; }; };
The matcher indirectFieldDecl()
matches a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('labelDecl0')"><a name="labelDecl0Anchor">labelDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelDecl.html">LabelDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="labelDecl0"><pre>Matches a declaration of label.

Given
  void bar();
  void foo() {
    goto FOO;
    FOO: bar();
  }
The matcher labelDecl()
matches FOO: bar().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('linkageSpecDecl0')"><a name="linkageSpecDecl0Anchor">linkageSpecDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LinkageSpecDecl.html">LinkageSpecDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="linkageSpecDecl0"><pre>Matches a declaration of a linkage specification.

Given
  extern "C" {}

The matcher linkageSpecDecl()
matches extern "C" {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('namedDecl0')"><a name="namedDecl0Anchor">namedDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="namedDecl0"><pre>Matches a declaration of anything that could have a name.

Example matches X, S, the anonymous union type, i, and U;
Given
  typedef int X;
  struct S {
    union {
      int i;
    } U;
  };
The matcher namedDecl()
matches typedef int X, S, int i
 and U,
with S matching twice in C++.
Once for the injected class name and once for the declaration itself.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('namespaceAliasDecl0')"><a name="namespaceAliasDecl0Anchor">namespaceAliasDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamespaceAliasDecl.html">NamespaceAliasDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="namespaceAliasDecl0"><pre>Matches a declaration of a namespace alias.

Given
  namespace test {}
  namespace alias = ::test;

The matcher namespaceAliasDecl()
matches alias,
but does not match test.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('namespaceDecl0')"><a name="namespaceDecl0Anchor">namespaceDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamespaceDecl.html">NamespaceDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="namespaceDecl0"><pre>Matches a declaration of a namespace.

Given
  namespace {}
  namespace test {}

The matcher namespaceDecl()
matches namespace {} and namespace test {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('nonTypeTemplateParmDecl0')"><a name="nonTypeTemplateParmDecl0Anchor">nonTypeTemplateParmDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NonTypeTemplateParmDecl.html">NonTypeTemplateParmDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="nonTypeTemplateParmDecl0"><pre>Matches non-type template parameter declarations.

Given
  template &lt;typename T, int N&gt; struct C {};

The matcher nonTypeTemplateParmDecl()
matches int N,
but does not match typename T.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcCategoryDecl0')"><a name="objcCategoryDecl0Anchor">objcCategoryDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCCategoryDecl.html">ObjCCategoryDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcCategoryDecl0"><pre>Matches Objective-C category declarations.

Example matches Foo (Additions)
  @interface Foo (Additions)
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcCategoryImplDecl0')"><a name="objcCategoryImplDecl0Anchor">objcCategoryImplDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCCategoryImplDecl.html">ObjCCategoryImplDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcCategoryImplDecl0"><pre>Matches Objective-C category definitions.

Example matches Foo (Additions)
  @implementation Foo (Additions)
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcImplementationDecl0')"><a name="objcImplementationDecl0Anchor">objcImplementationDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCImplementationDecl.html">ObjCImplementationDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcImplementationDecl0"><pre>Matches Objective-C implementation declarations.

Example matches Foo
  @implementation Foo
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcInterfaceDecl0')"><a name="objcInterfaceDecl0Anchor">objcInterfaceDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcInterfaceDecl0"><pre>Matches Objective-C interface declarations.

Example matches Foo
  @interface Foo
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcIvarDecl0')"><a name="objcIvarDecl0Anchor">objcIvarDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCIvarDecl.html">ObjCIvarDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcIvarDecl0"><pre>Matches Objective-C instance variable declarations.

Example matches _enabled
  @implementation Foo {
    BOOL _enabled;
  }
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcMethodDecl0')"><a name="objcMethodDecl0Anchor">objcMethodDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcMethodDecl0"><pre>Matches Objective-C method declarations.

Example matches both declaration and definition of -[Foo method]
  @interface Foo
  - (void)method;
  @end

  @implementation Foo
  - (void)method {}
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcPropertyDecl0')"><a name="objcPropertyDecl0Anchor">objcPropertyDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcPropertyDecl0"><pre>Matches Objective-C property declarations.

Example matches enabled
  @interface Foo
  @property BOOL enabled;
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('objcProtocolDecl0')"><a name="objcProtocolDecl0Anchor">objcProtocolDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCProtocolDecl.html">ObjCProtocolDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcProtocolDecl0"><pre>Matches Objective-C protocol declarations.

Example matches FooDelegate
  @protocol FooDelegate
  @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('parmVarDecl0')"><a name="parmVarDecl0Anchor">parmVarDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="parmVarDecl0"><pre>Matches parameter variable declarations.

Given
  void f(int x);
The matcher parmVarDecl()
matches int x.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('recordDecl0')"><a name="recordDecl0Anchor">recordDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordDecl.html">RecordDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="recordDecl0"><pre>Matches class, struct, and union declarations.

Given
  class X;
  template&lt;class T&gt; class Z {};
  struct S {};
  union U {};

The matcher recordDecl()
matches X, Z,
S and U.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('staticAssertDecl0')"><a name="staticAssertDecl0Anchor">staticAssertDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1StaticAssertDecl.html">StaticAssertDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="staticAssertDecl0"><pre>Matches a C++ static_assert declaration.

Given
  struct S {
    int x;
  };
  static_assert(sizeof(S) == sizeof(int));


The matcher staticAssertDecl()
matches static_assert(sizeof(S) == sizeof(int)).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('tagDecl0')"><a name="tagDecl0Anchor">tagDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="tagDecl0"><pre>Matches tag declarations.

Given
  class X;
  template&lt;class T&gt; class Z {};
  struct S {};
  union U {};
  enum E { A, B, C };


The matcher tagDecl()
matches class X, class Z {}, the injected class name
class Z, struct S {},
the injected class name struct S, union U {},
the injected class name union U
and enum E { A, B, C }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('templateTemplateParmDecl0')"><a name="templateTemplateParmDecl0Anchor">templateTemplateParmDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTemplateParmDecl.html">TemplateTemplateParmDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateTemplateParmDecl0"><pre>Matches template template parameter declarations.

Given
  template &lt;template &lt;typename&gt; class Z, int N&gt; struct C {};

The matcher templateTemplateParmDecl()
matches template &lt;typename&gt; class Z,
but does not match int N.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('templateTypeParmDecl0')"><a name="templateTypeParmDecl0Anchor">templateTypeParmDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmDecl.html">TemplateTypeParmDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateTypeParmDecl0"><pre>Matches template type parameter declarations.

Given
  template &lt;typename T, int N&gt; struct C {};

The matcher templateTypeParmDecl()
matches typename T,
but does not int N.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('translationUnitDecl0')"><a name="translationUnitDecl0Anchor">translationUnitDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html">TranslationUnitDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="translationUnitDecl0"><pre>Matches the top declaration context.

Given
  int X;
  namespace NS {
    int Y;
  }  // namespace NS

The matcher namedDecl(hasDeclContext(translationUnitDecl()))
matches X and NS,
but does not match Y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('typeAliasDecl0')"><a name="typeAliasDecl0Anchor">typeAliasDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeAliasDecl.html">TypeAliasDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="typeAliasDecl0"><pre>Matches type alias declarations.

Given
  typedef int X;
  using Y = int;

The matcher typeAliasDecl()
matches using Y = int,
but does not match typedef int X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('typeAliasTemplateDecl0')"><a name="typeAliasTemplateDecl0Anchor">typeAliasTemplateDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeAliasTemplateDecl.html">TypeAliasTemplateDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="typeAliasTemplateDecl0"><pre>Matches type alias template declarations.

Given
  template &lt;typename T&gt; struct X {};
  template &lt;typename T&gt; using Y = X&lt;T&gt;;

The matcher typeAliasTemplateDecl()
matches template &lt;typename T&gt; using Y = X&lt;T&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('typedefDecl0')"><a name="typedefDecl0Anchor">typedefDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefDecl.html">TypedefDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="typedefDecl0"><pre>Matches typedef declarations.

Given
  typedef int X;
  using Y = int;

The matcher typedefDecl()
matches typedef int X,
but does not match using Y = int.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('typedefNameDecl0')"><a name="typedefNameDecl0Anchor">typedefNameDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="typedefNameDecl0"><pre>Matches typedef name declarations.

Given
  typedef int X;
  using Y = int;

The matcher typedefNameDecl()
matches typedef int X and using Y = int.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('unresolvedUsingTypenameDecl0')"><a name="unresolvedUsingTypenameDecl0Anchor">unresolvedUsingTypenameDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingTypenameDecl.html">UnresolvedUsingTypenameDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unresolvedUsingTypenameDecl0"><pre>Matches unresolved using value declarations that involve the
typename.

Given
  template &lt;typename T&gt;
  struct Base { typedef T Foo; };

  template&lt;typename T&gt;
  struct S : private Base&lt;T&gt; {
    using typename Base&lt;T&gt;::Foo;
  };

The matcher unresolvedUsingTypenameDecl()
  matches using typename Base&lt;T&gt;::Foo
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('unresolvedUsingValueDecl0')"><a name="unresolvedUsingValueDecl0Anchor">unresolvedUsingValueDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingValueDecl.html">UnresolvedUsingValueDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unresolvedUsingValueDecl0"><pre>Matches unresolved using value declarations.

Given
  template&lt;typename X&gt;
  class C : private X {
    using X::x;
  };

The matcher unresolvedUsingValueDecl()
  matches using X::x
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('usingDecl0')"><a name="usingDecl0Anchor">usingDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingDecl.html">UsingDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="usingDecl0"><pre>Matches using declarations.

Given
  namespace X { int x; }
  using X::x;

The matcher usingDecl()
  matches using X::x
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('usingDirectiveDecl0')"><a name="usingDirectiveDecl0Anchor">usingDirectiveDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingDirectiveDecl.html">UsingDirectiveDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="usingDirectiveDecl0"><pre>Matches using namespace declarations.

Given
  namespace X { int x; }
  using namespace X;

The matcher usingDirectiveDecl()
  matches using namespace X
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('usingEnumDecl0')"><a name="usingEnumDecl0Anchor">usingEnumDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingEnumDecl.html">UsingEnumDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="usingEnumDecl0"><pre>Matches using-enum declarations.

Given
  namespace X { enum x { val1, val2 }; }
  using enum X::x;

The matcher usingEnumDecl()
  matches using enum X::x
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('valueDecl0')"><a name="valueDecl0Anchor">valueDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="valueDecl0"><pre>Matches any value declaration.

Given
  enum X { A, B, C };
  void F();
  int V = 0;
The matcher valueDecl()
matches A, B, C, void F()
and int V = 0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('varDecl0')"><a name="varDecl0Anchor">varDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="varDecl0"><pre>Matches variable declarations.

Note: this does not match declarations of member variables, which are
"field" declarations in Clang parlance.

Example matches a
  int a;
  struct Foo {
    int x;
  };
  void bar(int val);

The matcher varDecl()
matches int a and int val, but not int x.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt;</td><td class="name" onclick="toggle('lambdaCapture0')"><a name="lambdaCapture0Anchor">lambdaCapture</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="lambdaCapture0"><pre>Matches lambda captures.

Given
  int main() {
    int x;
    auto f = [x](){};
    auto g = [x = 1](){};
  }

The matcher
lambdaExpr(hasAnyCapture(lambdaCapture().bind("capture"))),
matches [x](){} and [x = 1](){},
with lambdaCapture() matching
x and x = 1.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;</td><td class="name" onclick="toggle('nestedNameSpecifierLoc0')"><a name="nestedNameSpecifierLoc0Anchor">nestedNameSpecifierLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="nestedNameSpecifierLoc0"><pre>Same as nestedNameSpecifier but matches NestedNameSpecifierLoc.

Given
  namespace ns {
    struct A { static void f(); };
    void A::f() {}
    void g() { A::f(); }
  }
  ns::A a;


The matcher nestedNameSpecifierLoc() matches
A:: twice, and ns:: once.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;</td><td class="name" onclick="toggle('nestedNameSpecifier0')"><a name="nestedNameSpecifier0Anchor">nestedNameSpecifier</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="nestedNameSpecifier0"><pre>Matches nested name specifiers.

Given
  namespace ns {
    struct A { static void f(); };
    void A::f() {}
    void g() { A::f(); }
  }
  ns::A a;

The matcher nestedNameSpecifier()
matches ns and both A
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPClause.html">OMPClause</a>&gt;</td><td class="name" onclick="toggle('ompDefaultClause0')"><a name="ompDefaultClause0Anchor">ompDefaultClause</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="ompDefaultClause0"><pre>Matches OpenMP ``default`` clause.

Given
  void foo() {
    #pragma omp parallel default(none)
      ;
    #pragma omp parallel default(shared)
      ;
    #pragma omp parallel default(private)
      ;
    #pragma omp parallel default(firstprivate)
      ;
    #pragma omp parallel
      ;
  }


The matcher
ompExecutableDirective(hasAnyClause(ompDefaultClause())) matches
#pragma omp parallel default(none),
#pragma omp parallel default(shared),
#pragma omp parallel default(private) and
#pragma omp parallel default(firstprivate).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('qualType0')"><a name="qualType0Anchor">qualType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="qualType0"><pre>Matches QualTypes in the clang AST.

Given
  int a = 0;
  const int b = 1;

The matcher varDecl(hasType(qualType(isConstQualified())))
matches const int b = 1, but not int a = 0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('addrLabelExpr0')"><a name="addrLabelExpr0Anchor">addrLabelExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="addrLabelExpr0"><pre>Matches address of label statements (GNU extension).

Given
void bar();
void foo() {
  FOO: bar();
  void *ptr = &amp;&amp;FOO;
  goto *ptr;
}
The matcher addrLabelExpr()
matches &amp;&amp;FOO
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('arrayInitIndexExpr0')"><a name="arrayInitIndexExpr0Anchor">arrayInitIndexExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArrayInitIndexExpr.html">ArrayInitIndexExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="arrayInitIndexExpr0"><pre>The arrayInitIndexExpr consists of two subexpressions: a common expression
(the source array) that is evaluated once up-front, and a per-element
initializer that runs once for each array element. Within the per-element
initializer, the current index may be obtained via an ArrayInitIndexExpr.

Given
  void testStructuredBinding() {
    int a[2] = {1, 2};
    auto [x, y] = a;
  }


The matcher arrayInitIndexExpr() matches the array index
that implicitly iterates over the array `a` to copy each element to the
anonymous array that backs the structured binding.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('arrayInitLoopExpr0')"><a name="arrayInitLoopExpr0Anchor">arrayInitLoopExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArrayInitLoopExpr.html">ArrayInitLoopExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="arrayInitLoopExpr0"><pre>Matches a loop initializing the elements of an array in a number of
contexts:
 * in the implicit copy/move constructor for a class with an array member
 * when a lambda-expression captures an array by value
 * when a decomposition declaration decomposes an array

Given
  void testLambdaCapture() {
    int a[10];
    [a]() {};
  }

The matcher arrayInitLoopExpr() matches the implicit loop that
initializes each element of the implicit array field inside the lambda
object, that represents the array a captured by value.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('arraySubscriptExpr0')"><a name="arraySubscriptExpr0Anchor">arraySubscriptExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="arraySubscriptExpr0"><pre>Matches array subscript expressions.

Given
  void foo() {
    int a[2] = {0, 1};
    int i = a[1];
  }
The matcher arraySubscriptExpr()
matches a[1].
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('asmStmt0')"><a name="asmStmt0Anchor">asmStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AsmStmt.html">AsmStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="asmStmt0"><pre>Matches asm statements.

void foo() {
 int i = 100;
  __asm("mov %al, 2");
}
The matcher asmStmt()
matches __asm("mov %al, 2")
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('atomicExpr0')"><a name="atomicExpr0Anchor">atomicExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AtomicExpr.html">AtomicExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="atomicExpr0"><pre>Matches atomic builtins.

Given
  void foo() { int *ptr; __atomic_load_n(ptr, 1); }

The matcher atomicExpr() matches __atomic_load_n(ptr, 1).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('autoreleasePoolStmt0')"><a name="autoreleasePoolStmt0Anchor">autoreleasePoolStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCAutoreleasePoolStmt.html">ObjCAutoreleasePoolStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="autoreleasePoolStmt0"><pre>Matches an Objective-C autorelease pool statement.

Given
  @autoreleasepool {
    int x = 0;
  }

The matcher autoreleasePoolStmt(stmt()) matches the declaration of
int x = 0 inside the autorelease pool.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('binaryConditionalOperator0')"><a name="binaryConditionalOperator0Anchor">binaryConditionalOperator</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryConditionalOperator.html">BinaryConditionalOperator</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="binaryConditionalOperator0"><pre>Matches binary conditional operator expressions (GNU extension).

Given
  int f(int a, int b) {
    return (a ?: b) + 42;
  }

The matcher binaryConditionalOperator() matches a ?: b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('binaryOperator0')"><a name="binaryOperator0Anchor">binaryOperator</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="binaryOperator0"><pre>Matches binary operator expressions.

Given
  void foo(bool a, bool b) {
    !(a || b);
  }


The matcher binaryOperator() matches a || b.

See also the binaryOperation() matcher for more-general matching.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('blockExpr0')"><a name="blockExpr0Anchor">blockExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockExpr.html">BlockExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="blockExpr0"><pre>Matches a reference to a block.

Given
  void f() { ^{}(); }


The matcher blockExpr() matches ^{}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('breakStmt0')"><a name="breakStmt0Anchor">breakStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BreakStmt.html">BreakStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="breakStmt0"><pre>Matches break statements.

Given
void foo() {
  while (true) { break; }
}

The matcher breakStmt()
matches break
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cStyleCastExpr0')"><a name="cStyleCastExpr0Anchor">cStyleCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CStyleCastExpr.html">CStyleCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cStyleCastExpr0"><pre>Matches a C-style cast expression.

Given
  int i = (int) 2.2f;

The matcher cStyleCastExpr()
matches (int) 2.2f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('callExpr0')"><a name="callExpr0Anchor">callExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="callExpr0"><pre>Matches call expressions.

Example matches x.y() and y()
  struct X { void foo(); };
  void bar();
  void foobar() {
    X x;
    x.foo();
    bar();
  }

The matcher callExpr()
matches x.foo() and bar();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('caseStmt0')"><a name="caseStmt0Anchor">caseStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CaseStmt.html">CaseStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="caseStmt0"><pre>Matches case statements inside switch statements.

Given
void foo(int a) {
  switch(a) { case 42: break; default: break; }
}
The matcher caseStmt()
matches case 42: break.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('castExpr0')"><a name="castExpr0Anchor">castExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CastExpr.html">CastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="castExpr0"><pre>Matches any cast nodes of Clang's AST.

Given
  struct S {};
  const S* s;
  S* s2 = const_cast&lt;S*&gt;(s);

  const int val = 0;
  char val0 = 1;
  char val1 = (char)2;
  char val2 = static_cast&lt;char&gt;(3);
  int* val3 = reinterpret_cast&lt;int*&gt;(4);
  char val4 = char(5);


The matcher castExpr()
matches
const_cast&lt;S*&gt;(s) and the implicit l- to r-value cast for s,
the implicit cast to char for the initializer 1,
the c-style cast (char)2 and it's implicit cast to char
(part of the c-style cast) 2,
static_cast&lt;char&gt;(3) and it's implicit cast to char
(part of the static_cast) 3,
reinterpret_cast&lt;int*&gt;(4),
char(5) and it's implicit cast to char
(part of the functional cast) 5.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('characterLiteral0')"><a name="characterLiteral0Anchor">characterLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="characterLiteral0"><pre>Matches character literals (also matches wchar_t).

Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),
though.

Given
  char ch = 'a';
  wchar_t chw = L'a';


The matcher characterLiteral() matches 'a' and
L'a'.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('chooseExpr0')"><a name="chooseExpr0Anchor">chooseExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ChooseExpr.html">ChooseExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="chooseExpr0"><pre>Matches GNU __builtin_choose_expr.

Given
  void f() { (void)__builtin_choose_expr(1, 2, 3); }

The matcher chooseExpr() matches
__builtin_choose_expr(1, 2, 3).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('coawaitExpr0')"><a name="coawaitExpr0Anchor">coawaitExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CoawaitExpr.html">CoawaitExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="coawaitExpr0"><pre>Matches co_await expressions.

Given
  namespace std {
  template &lt;typename T = void&gt;
  struct coroutine_handle {
      static constexpr coroutine_handle from_address(void* addr) {
        return {};
      }
  };

  struct always_suspend {
      bool await_ready() const noexcept;
      bool await_resume() const noexcept;
      template &lt;typename T&gt;
      bool await_suspend(coroutine_handle&lt;T&gt;) const noexcept;
  };

  template &lt;typename T&gt;
  struct coroutine_traits {
      using promise_type = T::promise_type;
  };
  }  // namespace std

  struct generator {
      struct promise_type {
          std::always_suspend yield_value(int&amp;&amp;);
          std::always_suspend initial_suspend() const noexcept;
          std::always_suspend final_suspend() const noexcept;
          void return_void();
          void unhandled_exception();
          generator get_return_object();
      };
  };

  std::always_suspend h();

  generator g() { co_await h(); }

The matcher
coawaitExpr(has(callExpr(callee(functionDecl(hasName("h"))))))
matches co_await h().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('compoundLiteralExpr0')"><a name="compoundLiteralExpr0Anchor">compoundLiteralExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="compoundLiteralExpr0"><pre>Matches compound (i.e. non-scalar) literals

Example match: {1}, (1, 2)
  struct vector { int x; int y; };
  struct vector myvec = (struct vector){ 1, 2 };

The matcher compoundLiteralExpr()
matches (struct vector){ 1, 2 }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('compoundStmt0')"><a name="compoundStmt0Anchor">compoundStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html">CompoundStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="compoundStmt0"><pre>Matches compound statements.

Given
void foo() { for (;;) {{}} }

The matcher compoundStmt() matches
{ for (;;) {{}} }, {{}} and {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('conditionalOperator0')"><a name="conditionalOperator0Anchor">conditionalOperator</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ConditionalOperator.html">ConditionalOperator</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="conditionalOperator0"><pre>Matches conditional operator expressions.

Given
  int f(int a, int b, int c) {
    return (a ? b : c) + 42;
  }

The matcher conditionalOperator() matches a ? b : c.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('constantExpr0')"><a name="constantExpr0Anchor">constantExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ConstantExpr.html">ConstantExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="constantExpr0"><pre>Matches a constant expression wrapper.

Given
  void f(int a) {
    switch (a) {
      case 37: break;
    }
  }

The matcher constantExpr() matches 37.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('continueStmt0')"><a name="continueStmt0Anchor">continueStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ContinueStmt.html">ContinueStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="continueStmt0"><pre>Matches continue statements.

Given
void foo() {
  while (true) { continue; }
}

The matcher continueStmt()
matches continue
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('convertVectorExpr0')"><a name="convertVectorExpr0Anchor">convertVectorExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ConvertVectorExpr.html">ConvertVectorExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="convertVectorExpr0"><pre>Matches builtin function __builtin_convertvector.

Given
  typedef double vector4double __attribute__((__vector_size__(32)));
  typedef float  vector4float  __attribute__((__vector_size__(16)));
  vector4float vf;
  void f() { (void)__builtin_convertvector(vf, vector4double); }

The matcher convertVectorExpr() matches
__builtin_convertvector(vf, vector4double).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('coreturnStmt0')"><a name="coreturnStmt0Anchor">coreturnStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CoreturnStmt.html">CoreturnStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="coreturnStmt0"><pre>Matches co_return statements.

Given
  namespace std {
  template &lt;typename T = void&gt;
  struct coroutine_handle {
      static constexpr coroutine_handle from_address(void* addr) {
        return {};
      }
  };

  struct always_suspend {
      bool await_ready() const noexcept;
      bool await_resume() const noexcept;
      template &lt;typename T&gt;
      bool await_suspend(coroutine_handle&lt;T&gt;) const noexcept;
  };

  template &lt;typename T&gt;
  struct coroutine_traits {
      using promise_type = T::promise_type;
  };
  }  // namespace std

  struct generator {
      struct promise_type {
          void return_value(int v);
          std::always_suspend yield_value(int&amp;&amp;);
          std::always_suspend initial_suspend() const noexcept;
          std::always_suspend final_suspend() const noexcept;
          void unhandled_exception();
          generator get_return_object();
      };
  };

  generator f() {
      co_return 10;
  }


The matcher coreturnStmt(has(integerLiteral()))
matches co_return 10
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('coroutineBodyStmt0')"><a name="coroutineBodyStmt0Anchor">coroutineBodyStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CoroutineBodyStmt.html">CoroutineBodyStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="coroutineBodyStmt0"><pre>Matches coroutine body statements.

Given
  namespace std {
  template &lt;typename T = void&gt;
  struct coroutine_handle {
      static constexpr coroutine_handle from_address(void* addr) {
        return {};
      }
  };

  struct suspend_always {
      bool await_ready() const noexcept;
      bool await_resume() const noexcept;
      template &lt;typename T&gt;
      bool await_suspend(coroutine_handle&lt;T&gt;) const noexcept;
  };

  template &lt;typename...&gt;
  struct coroutine_traits {
      struct promise_type {
          std::suspend_always initial_suspend() const noexcept;
          std::suspend_always final_suspend() const noexcept;
          void return_void();
          void unhandled_exception();
          coroutine_traits get_return_object();
      };
  };
  }  // namespace std

  void f() { while (true) { co_return; } }



The matcher coroutineBodyStmt() matches
{ while (true) { co_return; } }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('coyieldExpr0')"><a name="coyieldExpr0Anchor">coyieldExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CoyieldExpr.html">CoyieldExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="coyieldExpr0"><pre>Matches co_yield expressions.

Given
  namespace std {
  template &lt;typename T = void&gt;
  struct coroutine_handle {
      static constexpr coroutine_handle from_address(void* addr) {
        return {};
      }
  };

  struct always_suspend {
      bool await_ready() const noexcept;
      bool await_resume() const noexcept;
      template &lt;typename T&gt;
      bool await_suspend(coroutine_handle&lt;T&gt;) const noexcept;
  };

  template &lt;typename T&gt;
  struct coroutine_traits {
      using promise_type = T::promise_type;
  };
  }  // namespace std

  struct generator {
      struct promise_type {
          std::always_suspend yield_value(int&amp;&amp;);
          std::always_suspend initial_suspend() const noexcept;
          std::always_suspend final_suspend() const noexcept;
          void return_void();
          void unhandled_exception();
          generator get_return_object();
      };
  };

  generator f() {
      while (true) {
          co_yield 10;
      }
  }

The matcher coyieldExpr()
matches co_yield 10
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cudaKernelCallExpr0')"><a name="cudaKernelCallExpr0Anchor">cudaKernelCallExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CUDAKernelCallExpr.html">CUDAKernelCallExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cudaKernelCallExpr0"><pre>Matches CUDA kernel call expression.

Given
  __global__ void kernel() {}
  void f() {
    kernel&lt;&lt;&lt;32,32&gt;&gt;&gt;();
  }

The matcher cudaKernelCallExpr()
matches kernel&lt;&lt;&lt;i, k&gt;&gt;&gt;()
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxBindTemporaryExpr0')"><a name="cxxBindTemporaryExpr0Anchor">cxxBindTemporaryExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBindTemporaryExpr.html">CXXBindTemporaryExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxBindTemporaryExpr0"><pre>Matches nodes where temporaries are created.

Given
  struct S {
    S() { }  // User defined constructor makes S non-POD.
    ~S() { } // User defined destructor makes it non-trivial.
  };
  void test() {
    const S &amp;s_ref = S(); // Requires a CXXBindTemporaryExpr.
  }

The matcher cxxBindTemporaryExpr()
matches the constructor call S().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxBoolLiteral0')"><a name="cxxBoolLiteral0Anchor">cxxBoolLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxBoolLiteral0"><pre>Matches bool literals.

Example matches true
  bool Flag = true;


The matcher cxxBoolLiteral() matches true.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxCatchStmt0')"><a name="cxxCatchStmt0Anchor">cxxCatchStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxCatchStmt0"><pre>Matches catch statements.

void foo() {
  try {} catch(int i) {}
}

The matcher cxxCatchStmt()
matches catch(int i) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxConstCastExpr0')"><a name="cxxConstCastExpr0Anchor">cxxConstCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstCastExpr.html">CXXConstCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxConstCastExpr0"><pre>Matches a const_cast expression.

Given
  int n = 42;
  const int &amp;r(n);
  int* p = const_cast&lt;int*&gt;(&amp;r);


The matcher cxxConstCastExpr()
matches const_cast&lt;int*&gt;(&amp;r).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxConstructExpr0')"><a name="cxxConstructExpr0Anchor">cxxConstructExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxConstructExpr0"><pre>Matches constructor call expressions (including implicit ones).

Given
  struct string {
    string(const char*);
    string(const char*s, int n);
  };
  void f(const string &amp;a, const string &amp;b);
  void foo(char *ptr, int n) {
    f(string(ptr, n), ptr);
  }


The matcher cxxConstructExpr() matches string(ptr, n)
and ptr within arguments of f .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxDefaultArgExpr0')"><a name="cxxDefaultArgExpr0Anchor">cxxDefaultArgExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDefaultArgExpr.html">CXXDefaultArgExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxDefaultArgExpr0"><pre>Matches the value of a default argument at the call site.

Given
  void f(int x, int y = 0);
  void g() {
    f(42);
  }


The matcher callExpr(has(cxxDefaultArgExpr()))
matches the CXXDefaultArgExpr placeholder inserted for the default value
of the second parameter in the call expression f(42).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxDeleteExpr0')"><a name="cxxDeleteExpr0Anchor">cxxDeleteExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDeleteExpr.html">CXXDeleteExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxDeleteExpr0"><pre>Matches delete expressions.

Given
  void* operator new(decltype(sizeof(void*)));
  void operator delete(void*);
  struct X {};
  void foo() {
    auto* x = new X;
    delete x;
  }


The matcher cxxDeleteExpr()
matches delete x.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxDependentScopeMemberExpr0')"><a name="cxxDependentScopeMemberExpr0Anchor">cxxDependentScopeMemberExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxDependentScopeMemberExpr0"><pre>Matches member expressions where the actual member referenced could not be
resolved because the base expression or the member name was dependent.

Given
  template &lt;class T&gt; void f() { T t; t.g(); }

The matcher cxxDependentScopeMemberExpr()
  matches t.g
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxDynamicCastExpr0')"><a name="cxxDynamicCastExpr0Anchor">cxxDynamicCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDynamicCastExpr.html">CXXDynamicCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxDynamicCastExpr0"><pre>Matches a dynamic_cast expression.

Given
  struct B { virtual ~B() {} }; struct D : B {};
  B b;
  D* p = dynamic_cast&lt;D*&gt;(&amp;b);


The matcher cxxDynamicCastExpr()
matches dynamic_cast&lt;D*&gt;(&amp;b).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxFoldExpr0')"><a name="cxxFoldExpr0Anchor">cxxFoldExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxFoldExpr0"><pre>Matches C++17 fold expressions.

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }


The matcher cxxFoldExpr() matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxForRangeStmt0')"><a name="cxxForRangeStmt0Anchor">cxxForRangeStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxForRangeStmt0"><pre>Matches range-based for statements.

Given
  void foo() {
    int i[] =  {1, 2, 3}; for (auto a : i);
    for(int j = 0; j &lt; 5; ++j);
  }

The matcher cxxForRangeStmt()
matches for (auto a : i);
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxFunctionalCastExpr0')"><a name="cxxFunctionalCastExpr0Anchor">cxxFunctionalCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxFunctionalCastExpr0"><pre>Matches functional cast expressions

Given
  struct Foo {
    Foo(int x);
  };

  void foo(int bar) {
    Foo f = bar;
    Foo g = (Foo) bar;
    Foo h = Foo(bar);
  }


The matcher cxxFunctionalCastExpr()
matches Foo(bar).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxMemberCallExpr0')"><a name="cxxMemberCallExpr0Anchor">cxxMemberCallExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxMemberCallExpr0"><pre>Matches member call expressions.

Given
  struct X {
    void y();
    void m() { y(); }
  };
  void f();
  void g() {
    X x;
    x.y();
    f();
  }


The matcher cxxMemberCallExpr() matches x.y() and
y(), but not f().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxNewExpr0')"><a name="cxxNewExpr0Anchor">cxxNewExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxNewExpr0"><pre>Matches new expressions.

Given
  void* operator new(decltype(sizeof(void*)));
  struct X {};
  void foo() {
    auto* x = new X;
  }


The matcher cxxNewExpr()
matches new X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxNoexceptExpr0')"><a name="cxxNoexceptExpr0Anchor">cxxNoexceptExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNoexceptExpr.html">CXXNoexceptExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxNoexceptExpr0"><pre>Matches noexcept expressions.

Given
  bool a() noexcept;
  bool b() noexcept(true);
  bool c() noexcept(false);
  bool d() noexcept(noexcept(a()));
  bool e = noexcept(b()) || noexcept(c());

The matcher cxxNoexceptExpr()
matches noexcept(a()), noexcept(b()) and
noexcept(c()), but does not match the noexcept specifier in the
declarations a, b, c or d.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxNullPtrLiteralExpr0')"><a name="cxxNullPtrLiteralExpr0Anchor">cxxNullPtrLiteralExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNullPtrLiteralExpr.html">CXXNullPtrLiteralExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxNullPtrLiteralExpr0"><pre>Matches nullptr literal.

Given
  int a = 0;
  int* b = 0;
  int *c = nullptr;


The matcher cxxNullPtrLiteralExpr() matches nullptr.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxOperatorCallExpr0')"><a name="cxxOperatorCallExpr0Anchor">cxxOperatorCallExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxOperatorCallExpr0"><pre>Matches overloaded operator calls.

Note that if an operator isn't overloaded, it won't match. Instead, use
binaryOperator matcher.
Currently it does not match operators such as new delete.
FIXME: figure out why these do not match?

Given
  struct ostream;
  ostream &amp;operator&lt;&lt; (ostream &amp;out, int i) { };
  void f(ostream&amp; o, int b, int c) {
    o &lt;&lt; b &lt;&lt; c;
  }


The matcher cxxOperatorCallExpr() matches o &lt;&lt; b &lt;&lt; c
and o &lt;&lt; b.
See also the binaryOperation() matcher for more-general matching of binary
uses of this AST node.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxReinterpretCastExpr0')"><a name="cxxReinterpretCastExpr0Anchor">cxxReinterpretCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXReinterpretCastExpr.html">CXXReinterpretCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxReinterpretCastExpr0"><pre>Matches a reinterpret_cast expression.

Either the source expression or the destination type can be matched
using has(), but hasDestinationType() is more specific and can be
more readable.

Example matches reinterpret_cast&lt;char*&gt;(&amp;p) in
  void* p = reinterpret_cast&lt;char*&gt;(&amp;p);


The matcher cxxReinterpretCastExpr()
matches reinterpret_cast&lt;char*&gt;(&amp;p).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxRewrittenBinaryOperator0')"><a name="cxxRewrittenBinaryOperator0Anchor">cxxRewrittenBinaryOperator</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxRewrittenBinaryOperator0"><pre>Matches rewritten binary operators

Example matches use of "&lt;":
  struct HasSpaceshipMem {
    int a;
    constexpr bool operator==(const HasSpaceshipMem&amp;) const = default;
  };
  void compare() {
    HasSpaceshipMem hs1, hs2;
    if (hs1 != hs2)
        return;
  }


The matcher cxxRewrittenBinaryOperator() matches
hs1 != hs2.

See also the binaryOperation() matcher for more-general matching
of this AST node.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxStaticCastExpr0')"><a name="cxxStaticCastExpr0Anchor">cxxStaticCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXStaticCastExpr.html">CXXStaticCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxStaticCastExpr0"><pre>Matches a C++ static_cast expression.

See also: hasDestinationType
See also: reinterpretCast

Given
  long eight(static_cast&lt;long&gt;(8));


The matcher cxxStaticCastExpr()
matches static_cast&lt;long&gt;(8).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxStdInitializerListExpr0')"><a name="cxxStdInitializerListExpr0Anchor">cxxStdInitializerListExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXStdInitializerListExpr.html">CXXStdInitializerListExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxStdInitializerListExpr0"><pre>Matches C++ initializer list expressions.

Given
  namespace std {
    template &lt;typename T&gt;
    class initializer_list {
      const T* begin;
      const T* end;
    };
  }
  template &lt;typename T&gt; class vector {
    public: vector(std::initializer_list&lt;T&gt;) {}
  };

  vector&lt;int&gt; a({ 1, 2, 3 });
  vector&lt;int&gt; b = { 4, 5 };
  int c[] = { 6, 7 };
  struct pair { int x; int y; };
  pair d = { 8, 9 };

The matcher cxxStdInitializerListExpr()
matches { 1, 2, 3 } and { 4, 5 }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxTemporaryObjectExpr0')"><a name="cxxTemporaryObjectExpr0Anchor">cxxTemporaryObjectExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxTemporaryObjectExpr0"><pre>Matches functional cast expressions having N != 1 arguments

Given
  struct Foo {
    Foo(int x, int y);
  };

  void foo(int bar) {
    Foo h = Foo(bar, bar);
  }


The matcher cxxTemporaryObjectExpr()
matches Foo(bar, bar).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxThisExpr0')"><a name="cxxThisExpr0Anchor">cxxThisExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXThisExpr.html">CXXThisExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxThisExpr0"><pre>Matches implicit and explicit this expressions.

Given
  struct foo {
    int i;
    int f() { return i; }
    int g() { return this-&gt;i; }
  };


The matcher cxxThisExpr()
matches this of this-&gt;i and the implicit this expression
of i.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxThrowExpr0')"><a name="cxxThrowExpr0Anchor">cxxThrowExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXThrowExpr.html">CXXThrowExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxThrowExpr0"><pre>Matches throw expressions.

void foo() {
  try { throw 5; } catch(int i) {}
}

The matcher cxxThrowExpr()
matches throw 5
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxTryStmt0')"><a name="cxxTryStmt0Anchor">cxxTryStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTryStmt.html">CXXTryStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxTryStmt0"><pre>Matches try statements.

void foo() {
  try {} catch(int i) {}
}

The matcher cxxTryStmt()
matches try {} catch(int i) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('cxxUnresolvedConstructExpr0')"><a name="cxxUnresolvedConstructExpr0Anchor">cxxUnresolvedConstructExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="cxxUnresolvedConstructExpr0"><pre>Matches unresolved constructor call expressions.

Given
  template &lt;typename T&gt;
  void f(const T&amp; t) { return T(t); }


The matcher cxxUnresolvedConstructExpr() matches
T(t).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('declRefExpr0')"><a name="declRefExpr0Anchor">declRefExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="declRefExpr0"><pre>Matches expressions that refer to declarations.

Given
  void f(bool x) {
    if (x) {}
  }


The matcher declRefExpr() matches x.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('declStmt0')"><a name="declStmt0Anchor">declStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html">DeclStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="declStmt0"><pre>Matches declaration statements.

Given
  void foo() {
    int a;
  }
The matcher declStmt()
matches int a;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('defaultStmt0')"><a name="defaultStmt0Anchor">defaultStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DefaultStmt.html">DefaultStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="defaultStmt0"><pre>Matches default statements inside switch statements.

Given
void foo(int a) {
  switch(a) { case 42: break; default: break; }
}
The matcher defaultStmt()
matches default: break.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('dependentCoawaitExpr0')"><a name="dependentCoawaitExpr0Anchor">dependentCoawaitExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DependentCoawaitExpr.html">DependentCoawaitExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="dependentCoawaitExpr0"><pre>Matches co_await expressions where the type of the promise is dependent

Given
  namespace std {
  template &lt;typename T = void&gt;
  struct coroutine_handle {
      static constexpr coroutine_handle from_address(void* addr) {
        return {};
      }
  };

  struct always_suspend {
      bool await_ready() const noexcept;
      bool await_resume() const noexcept;
      template &lt;typename T&gt;
      bool await_suspend(coroutine_handle&lt;T&gt;) const noexcept;
  };

  template &lt;typename T&gt;
  struct coroutine_traits {
      using promise_type = T::promise_type;
  };
  }  // namespace std

  template &lt;typename T&gt;
  struct generator {
      struct promise_type {
          std::always_suspend yield_value(int&amp;&amp;);
          std::always_suspend initial_suspend() const noexcept;
          std::always_suspend final_suspend() const noexcept;
          void return_void();
          void unhandled_exception();
          generator get_return_object();
      };
  };

  template &lt;typename T&gt;
  std::always_suspend h();

  template &lt;&gt;
  std::always_suspend h&lt;void&gt;();

  template&lt;typename T&gt;
  generator&lt;T&gt; g() { co_await h&lt;T&gt;(); }

The matcher dependentCoawaitExpr()
matches co_await h&lt;T&gt;().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('designatedInitExpr0')"><a name="designatedInitExpr0Anchor">designatedInitExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="designatedInitExpr0"><pre>Matches C99 designated initializer expressions [C99 6.7.8].

Example: Given
  struct point2 { double x; double y; };
  struct point2 ptarray[10] = { [0].x = 1.0 };
  struct point2 pt = { .x = 2.0 };

The matcher designatedInitExpr()
matches [0].x = 1.0 and .x = 2.0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('doStmt0')"><a name="doStmt0Anchor">doStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DoStmt.html">DoStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="doStmt0"><pre>Matches do statements.

Given
void foo() {
  do {} while (true);
}

The matcher doStmt()
matches do {} while (true)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('explicitCastExpr0')"><a name="explicitCastExpr0Anchor">explicitCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="explicitCastExpr0"><pre>Matches explicit cast expressions.

Matches any cast expression written in user code, whether it be a
C-style cast, a functional-style cast, or a keyword cast.

Does not match implicit conversions.

Note: the name "explicitCast" is chosen to match Clang's terminology, as
Clang uses the term "cast" to apply to implicit conversions as well as to
actual cast expressions.

See also: hasDestinationType.

  struct S {};
  const S* s;
  S* s2 = const_cast&lt;S*&gt;(s);

  const int val = 0;
  char val0 = val;
  char val1 = (char)val;
  char val2 = static_cast&lt;char&gt;(val);
  int* val3 = reinterpret_cast&lt;int*&gt;(val);
  char val4 = char(val);


The matcher explicitCastExpr()
matches (char)val, static_cast&lt;char&gt;(val),
reinterpret_cast&lt;int*&gt;(val), const_cast&lt;S*&gt;(s)
and char(val), but not the initialization of val0 with
val.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('expr0')"><a name="expr0Anchor">expr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="expr0"><pre>Matches expressions.

Given
  int f(int x, int y) { return x + y; }

The matcher expr() matches x + y once,
x twice and y twice, matching the
DeclRefExpr , and the ImplicitCastExpr that does an l- to r-value
cast.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('exprWithCleanups0')"><a name="exprWithCleanups0Anchor">exprWithCleanups</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExprWithCleanups.html">ExprWithCleanups</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="exprWithCleanups0"><pre>Matches expressions that introduce cleanups to be run at the end
of the sub-expression's evaluation.

Example matches std::string()
  struct A { ~A(); };
  void f(A);
  void g(A&amp;);
  void h() {
    A a = A{};
    f(A{});
    f(a);
    g(a);
  }


The matcher exprWithCleanups() matches A{},
f(A{}) and f(a),
but does not match passing g(a).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('fixedPointLiteral0')"><a name="fixedPointLiteral0Anchor">fixedPointLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FixedPointLiteral.html">FixedPointLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="fixedPointLiteral0"><pre>Matches fixed point literals

Given
  void f() {
    0.0k;
  }


The matcher fixedPointLiteral() matches 0.0k.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('floatLiteral0')"><a name="floatLiteral0Anchor">floatLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FloatingLiteral.html">FloatingLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="floatLiteral0"><pre>Matches float literals of all sizes / encodings, e.g.
1.0, 1.0f, 1.0L and 1e10.

Given
  int a = 1.0;
  int b = 1.0F;
  int c = 1.0L;
  int d = 1e10;
  int e = 1;

The matcher floatLiteral() matches
1.0, 1.0F, 1.0L and 1e10, but does not match
1.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('forStmt0')"><a name="forStmt0Anchor">forStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ForStmt.html">ForStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="forStmt0"><pre>Matches for statements.

Given
  void foo() {
    for (;;) {}
    int i[] =  {1, 2, 3}; for (auto a : i);
  }


The matcher forStmt() matches for (;;) {},
but not for (auto a : i);.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('genericSelectionExpr0')"><a name="genericSelectionExpr0Anchor">genericSelectionExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1GenericSelectionExpr.html">GenericSelectionExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="genericSelectionExpr0"><pre>Matches C11 _Generic expression.

Given
  double fdouble(double);
  float ffloat(float);
  #define GENERIC_MACRO(X) _Generic((X), double: fdouble, float: ffloat)(X)

  void f() {
      GENERIC_MACRO(0.0);
      GENERIC_MACRO(0.0F);
  }


The matcher genericSelectionExpr() matches
the generic selection expression that is expanded in
GENERIC_MACRO(0.0) and GENERIC_MACRO(0.0F).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('gnuNullExpr0')"><a name="gnuNullExpr0Anchor">gnuNullExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1GNUNullExpr.html">GNUNullExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="gnuNullExpr0"><pre>Matches GNU __null expression.

Given
  auto val = __null;


The matcher gnuNullExpr() matches __null.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('gotoStmt0')"><a name="gotoStmt0Anchor">gotoStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1GotoStmt.html">GotoStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="gotoStmt0"><pre>Matches goto statements.

Given
void bar();
void foo() {
  goto FOO;
  FOO: bar();
}
The matcher gotoStmt()
matches goto FOO
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('ifStmt0')"><a name="ifStmt0Anchor">ifStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="ifStmt0"><pre>Matches if statements.

Given
  void foo(int x) {
    if (x) {}
  }

The matcher ifStmt() matches if (x) {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('imaginaryLiteral0')"><a name="imaginaryLiteral0Anchor">imaginaryLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ImaginaryLiteral.html">ImaginaryLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="imaginaryLiteral0"><pre>Matches imaginary literals, which are based on integer and floating
point literals e.g.: 1i, 1.0i

Given
  auto a = 1i;
  auto b = 1.0i;


The matcher imaginaryLiteral() matches 1i and
1.0i.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('implicitCastExpr0')"><a name="implicitCastExpr0Anchor">implicitCastExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="implicitCastExpr0"><pre>Matches the implicit cast nodes of Clang's AST.

This matches many different places, including function call return value
eliding, as well as any type conversions.

void f(int);
void g(int val1, int val2) {
  unsigned int a = val1;
  f(val2);
}

The matcher implicitCastExpr()
matches val1 for the implicit cast from an l- to an r-value
and for the cast to int}, f for the function pointer
decay, and val2 for the cast from an l- to an r-value.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('implicitValueInitExpr0')"><a name="implicitValueInitExpr0Anchor">implicitValueInitExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ImplicitValueInitExpr.html">ImplicitValueInitExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="implicitValueInitExpr0"><pre>Matches implicit initializers of init list expressions.

Given
  struct point { double x; double y; };
  struct point pt = { .x = 42.0 };
The matcher
initListExpr(has(implicitValueInitExpr().bind("implicit")))
matches { .x = 42.0 }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('initListExpr0')"><a name="initListExpr0Anchor">initListExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InitListExpr.html">InitListExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="initListExpr0"><pre>Matches init list expressions.

Given
  int a[] = { 1, 2 };
  struct B { int x, y; };
  struct B b = { 5, 6 };
The matcher initListExpr()
matches { 1, 2 } and { 5, 6 }
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('integerLiteral0')"><a name="integerLiteral0Anchor">integerLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="integerLiteral0"><pre>Matches integer literals of all sizes / encodings, e.g.
1, 1L, 0x1 and 1U.

Does not match character-encoded integers such as L'a'.

Given
  int a = 1;
  int b = 1L;
  int c = 0x1;
  int d = 1U;
  int e = 1.0;

The matcher integerLiteral() matches
1, 1L, 0x1 and 1U, but does not match
1.0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('labelStmt0')"><a name="labelStmt0Anchor">labelStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="labelStmt0"><pre>Matches label statements.

Given
void bar();
void foo() {
  goto FOO;
  FOO: bar();
}
The matcher labelStmt()
matches FOO: bar()
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('lambdaExpr0')"><a name="lambdaExpr0Anchor">lambdaExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaExpr.html">LambdaExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="lambdaExpr0"><pre>Matches lambda expressions.

Given
  void f() {
    []() { return 5; };
  }


The matcher lambdaExpr() matches []() { return 5; }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('materializeTemporaryExpr0')"><a name="materializeTemporaryExpr0Anchor">materializeTemporaryExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MaterializeTemporaryExpr.html">MaterializeTemporaryExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="materializeTemporaryExpr0"><pre>Matches nodes where temporaries are materialized.

Example: Given
  struct T {void func();};
  T f();
  void g(T);
  void foo() {
    T u(f());
    g(f());
    f().func();
    f(); // does not match
  }

The matcher materializeTemporaryExpr() matches
f() three times before C++17 and it
matches f() time with C++17 and later, but
it does not match the f() in the last line in any version.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('memberExpr0')"><a name="memberExpr0Anchor">memberExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="memberExpr0"><pre>Matches member expressions.

Given
  class Y {
    void x() { this-&gt;x(); x(); Y y; y.x(); a; this-&gt;b; Y::b; }
    int a; static int b;
  };

The matcher memberExpr()
matches this-&gt;x, x, y.x, a, this-&gt;b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('nullStmt0')"><a name="nullStmt0Anchor">nullStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NullStmt.html">NullStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="nullStmt0"><pre>Matches null statements.

void foo() {
  foo();;
}
The matcher nullStmt()
matches the second ;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('objcCatchStmt0')"><a name="objcCatchStmt0Anchor">objcCatchStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCAtCatchStmt.html">ObjCAtCatchStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcCatchStmt0"><pre>Matches Objective-C @catch statements.

Example matches @catch
  @try {}
  @catch (...) {}

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('objcFinallyStmt0')"><a name="objcFinallyStmt0Anchor">objcFinallyStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCAtFinallyStmt.html">ObjCAtFinallyStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcFinallyStmt0"><pre>Matches Objective-C @finally statements.

Example matches @finally
  @try {}
  @finally {}

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('objcIvarRefExpr0')"><a name="objcIvarRefExpr0Anchor">objcIvarRefExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCIvarRefExpr.html">ObjCIvarRefExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcIvarRefExpr0"><pre>Matches a reference to an ObjCIvar.

Given
@implementation A {
  NSString *a;
}
- (void) init {
  a = @"hello";
}


The matcher objcIvarRefExpr() matches a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('objcMessageExpr0')"><a name="objcMessageExpr0Anchor">objcMessageExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcMessageExpr0"><pre>Matches ObjectiveC Message invocation expressions.

The innermost message send invokes the "alloc" class method on the
NSString class, while the outermost message send invokes the
"initWithString" instance method on the object returned from
NSString's "alloc". This matcher should match both message sends.
  [[NSString alloc] initWithString:@"Hello"]


The matcher objcMessageExpr() matches
[[NSString alloc] initWithString:@"Hello"]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('objcStringLiteral0')"><a name="objcStringLiteral0Anchor">objcStringLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCStringLiteral.html">ObjCStringLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcStringLiteral0"><pre>Matches ObjectiveC String literal expressions.

Example matches @"abcd"
  NSString *s = @"abcd";

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('objcThrowStmt0')"><a name="objcThrowStmt0Anchor">objcThrowStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCAtThrowStmt.html">ObjCAtThrowStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcThrowStmt0"><pre>Matches Objective-C statements.

Example matches @throw obj;

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('objcTryStmt0')"><a name="objcTryStmt0Anchor">objcTryStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCAtTryStmt.html">ObjCAtTryStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcTryStmt0"><pre>Matches Objective-C @try statements.

Example matches @try
  @try {}
  @catch (...) {}

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('ompExecutableDirective0')"><a name="ompExecutableDirective0Anchor">ompExecutableDirective</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="ompExecutableDirective0"><pre>Matches any ``#pragma omp`` executable directive.

Given
  void foo() {
    #pragma omp parallel
      {}
    #pragma omp parallel default(none)
      {
        #pragma omp taskyield
      }
  }

The matcher ompExecutableDirective()
matches #pragma omp parallel,
#pragma omp parallel default(none)
and #pragma omp taskyield.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('opaqueValueExpr0')"><a name="opaqueValueExpr0Anchor">opaqueValueExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="opaqueValueExpr0"><pre>Matches opaque value expressions. They are used as helpers
to reference another expressions and can be met
in BinaryConditionalOperators, for example.

Given
  int f(int a, int b) {
    return (a ?: b) + 42;
  }


The matcher opaqueValueExpr() matches a twice,
once for the check and once for the expression of the true path.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('parenExpr0')"><a name="parenExpr0Anchor">parenExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParenExpr.html">ParenExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="parenExpr0"><pre>Matches parentheses used in expressions.

Given
  int foo() { return 1; }
  int bar() {
    int a = (foo() + 1);
  }

The matcher parenExpr() matches (foo() + 1).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('parenListExpr0')"><a name="parenListExpr0Anchor">parenListExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParenListExpr.html">ParenListExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="parenListExpr0"><pre>Matches paren list expressions.
ParenListExprs don't have a predefined type and are used for late parsing.
In the final AST, they can be met in template declarations.

Given
  template&lt;typename T&gt; class X {
    void f() {
      X x(*this);
      int a = 0, b = 1; int i = (a, b);
    }
  };

The matcher parenListExpr()
matches (*this),
but does not match (a, b)
because (a, b) has a predefined type and is a ParenExpr, not a
ParenListExpr.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('predefinedExpr0')"><a name="predefinedExpr0Anchor">predefinedExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PredefinedExpr.html">PredefinedExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="predefinedExpr0"><pre>Matches predefined identifier expressions [C99 6.4.2.2].

Example: Matches __func__
  void f() {
    const char* func_name = __func__;
  }

The matcher predefinedExpr()
matches __func__.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('returnStmt0')"><a name="returnStmt0Anchor">returnStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReturnStmt.html">ReturnStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="returnStmt0"><pre>Matches return statements.

Given
int foo() {
  return 1;
}
The matcher returnStmt()
matches return 1
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('stmt0')"><a name="stmt0Anchor">stmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="stmt0"><pre>Matches statements.

Given
  void foo(int a) { { ++a; } }
The matcher stmt()
matches the function body itself { { ++a; } }, the compound
statement { ++a; }, the expression ++a and a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('stmtExpr0')"><a name="stmtExpr0Anchor">stmtExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1StmtExpr.html">StmtExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="stmtExpr0"><pre>Matches statement expression (GNU extension).

Given
  void f() {
    int C = ({ int X = 4; X; });
  }

The matcher stmtExpr() matches ({ int X = 4; X; }).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('stringLiteral0')"><a name="stringLiteral0Anchor">stringLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1StringLiteral.html">StringLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="stringLiteral0"><pre>Matches string literals (also matches wide string literals).

Given
  char *s = "abcd";
  wchar_t *ws = L"abcd";


The matcher stringLiteral() matches "abcd" and
L"abcd".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('substNonTypeTemplateParmExpr0')"><a name="substNonTypeTemplateParmExpr0Anchor">substNonTypeTemplateParmExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SubstNonTypeTemplateParmExpr.html">SubstNonTypeTemplateParmExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="substNonTypeTemplateParmExpr0"><pre>Matches substitutions of non-type template parameters.

Given
  template &lt;int N&gt;
  struct A { static const int n = N; };
  struct B : public A&lt;42&gt; {};

The matcher substNonTypeTemplateParmExpr()
matches N in the right-hand side of "static const int n = N;"
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('switchCase0')"><a name="switchCase0Anchor">switchCase</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SwitchCase.html">SwitchCase</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="switchCase0"><pre>Matches case and default statements inside switch statements.

Given
void foo(int a) {
  switch(a) { case 42: break; default: break; }
}
The matcher switchCase()
matches case 42: break and default: break
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('switchStmt0')"><a name="switchStmt0Anchor">switchStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SwitchStmt.html">SwitchStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="switchStmt0"><pre>Matches switch statements.

Given
void foo(int a) {
  switch(a) { case 42: break; default: break; }
}
The matcher switchStmt()
matches switch(a) { case 42: break; default: break; }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('unaryExprOrTypeTraitExpr0')"><a name="unaryExprOrTypeTraitExpr0Anchor">unaryExprOrTypeTraitExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unaryExprOrTypeTraitExpr0"><pre>Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)

Given
  int x = 42;
  int y = sizeof(x) + alignof(x);

The matcher unaryExprOrTypeTraitExpr()
matches sizeof(x) and alignof(x)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('unaryOperator0')"><a name="unaryOperator0Anchor">unaryOperator</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryOperator.html">UnaryOperator</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unaryOperator0"><pre>Matches unary operator expressions.

Example matches !a
  void foo(bool a, bool b) {
    !a || b;
  }


The matcher unaryOperator() matches !a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('unresolvedLookupExpr0')"><a name="unresolvedLookupExpr0Anchor">unresolvedLookupExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedLookupExpr.html">UnresolvedLookupExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unresolvedLookupExpr0"><pre>Matches reference to a name that can be looked up during parsing
but could not be resolved to a specific declaration.

Given
  template&lt;typename T&gt;
  T foo() { T a; return a; }
  template&lt;typename T&gt;
  void bar() {
    foo&lt;T&gt;();
  }

The matcher unresolvedLookupExpr()
matches foo&lt;T&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('unresolvedMemberExpr0')"><a name="unresolvedMemberExpr0Anchor">unresolvedMemberExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unresolvedMemberExpr0"><pre>Matches unresolved member expressions.

Given
  struct X {
    template &lt;class T&gt; void f();
    void g();
  };
  template &lt;class T&gt; void h() { X x; x.f&lt;T&gt;(); x.g(); }

The matcher unresolvedMemberExpr()
matches x.f&lt;T&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('userDefinedLiteral0')"><a name="userDefinedLiteral0Anchor">userDefinedLiteral</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UserDefinedLiteral.html">UserDefinedLiteral</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="userDefinedLiteral0"><pre>Matches user defined literal operator call.

Example match: "foo"_suffix
Given
  float operator ""_foo(long double);
  float a = 1234.5_foo;


The matcher userDefinedLiteral() matches 1234.5_foo.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('whileStmt0')"><a name="whileStmt0Anchor">whileStmt</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1WhileStmt.html">WhileStmt</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="whileStmt0"><pre>Matches while statements.

Given
void foo() {
  while (true) {}
}

The matcher whileStmt()
matches while (true) {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;</td><td class="name" onclick="toggle('templateArgumentLoc0')"><a name="templateArgumentLoc0Anchor">templateArgumentLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateArgumentLoc0"><pre>Matches template arguments (with location info).

Given
  template &lt;typename T&gt; struct C {};
  C&lt;int&gt; c;

The matcher templateArgumentLoc()
matches int in C&lt;int&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('templateArgument0')"><a name="templateArgument0Anchor">templateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateArgument0"><pre>Matches template arguments.

Given
  template &lt;typename T&gt; struct C {};
  C&lt;int&gt; c;

The matcher
templateSpecializationType(hasAnyTemplateArgument(templateArgument()))
matches C&lt;int&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateName.html">TemplateName</a>&gt;</td><td class="name" onclick="toggle('templateName0')"><a name="templateName0Anchor">templateName</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateName.html">TemplateName</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateName0"><pre>Matches template name.

Given
  template&lt;template &lt;typename&gt; class S&gt; class X {};
  template&lt;typename T&gt; class Y {};
  X&lt;Y&gt; xi;

The matcher
classTemplateSpecializationDecl(hasAnyTemplateArgument(
              refersToTemplate(templateName())))
matches the specialization class X&lt;Y&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('elaboratedTypeLoc0')"><a name="elaboratedTypeLoc0Anchor">elaboratedTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ElaboratedTypeLoc.html">ElaboratedTypeLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="elaboratedTypeLoc0"><pre>Matches C or C++ elaborated `TypeLoc`s.

Given
  struct s {};
  struct s ss;
The matcher elaboratedTypeLoc()
matches the type struct s of ss.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('pointerTypeLoc0')"><a name="pointerTypeLoc0Anchor">pointerTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerTypeLoc.html">PointerTypeLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="pointerTypeLoc0"><pre>Matches pointer `TypeLoc`s.

Given
  int* x;
The matcher pointerTypeLoc()
  matches int*.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('qualifiedTypeLoc0')"><a name="qualifiedTypeLoc0Anchor">qualifiedTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualifiedTypeLoc.html">QualifiedTypeLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="qualifiedTypeLoc0"><pre>Matches `QualifiedTypeLoc`s in the clang AST.

Given
  const int x = 0;

The matcher qualifiedTypeLoc()
matches the type of the variable declaration x . However, the
current implementation of QualifiedTypeLoc does not store the source
locations for the qualifiers of the type int.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('referenceTypeLoc0')"><a name="referenceTypeLoc0Anchor">referenceTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceTypeLoc.html">ReferenceTypeLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="referenceTypeLoc0"><pre>Matches reference `TypeLoc`s.

Given
  int x = 3;
  int&amp; l = x;
  int&amp;&amp; r = 3;


The matcher referenceTypeLoc()
  matches int&amp; and int&amp;&amp;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('templateSpecializationTypeLoc0')"><a name="templateSpecializationTypeLoc0Anchor">templateSpecializationTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateSpecializationTypeLoc0"><pre>Matches template specialization `TypeLoc`s.

Given
  template &lt;typename T&gt; class C {};
  C&lt;char&gt; var;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(typeLoc())))))
matches C&lt;char&gt; var.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('typeLoc0')"><a name="typeLoc0Anchor">typeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="typeLoc0"><pre>Matches TypeLocs in the clang AST.

That is, information about a type and where it was written.

  void foo(int val);

The matcher declaratorDecl(hasTypeLoc(typeLoc().bind("type")))
matches void foo(int val) and int val, with
typeLoc() matching void and
int respectively.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('arrayType0')"><a name="arrayType0Anchor">arrayType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArrayType.html">ArrayType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="arrayType0"><pre>Matches all kinds of arrays.

Given
  int a[] = { 2, 3 };
  int b[4];
  void f() { int c[a[0]]; }
The matcher arrayType()
int[4], int[a[0]] and
int[];
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('atomicType0')"><a name="atomicType0Anchor">atomicType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AtomicType.html">AtomicType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="atomicType0"><pre>Matches atomic types.

Given
  _Atomic(int) i;
The matcher atomicType()
_Atomic(int)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('autoType0')"><a name="autoType0Anchor">autoType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AutoType.html">AutoType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="autoType0"><pre>Matches types nodes representing C++11 auto types.

Given
  void foo() {
    auto n = 4;
    int v[] = { 2, 3 };
    for (auto i : v) { };
  }

The matcher autoType()
matches the auto of n and i ,
as well as the auto types for the implicitly generated code of the range-for
loop (for the range, the begin iterator and the end iterator).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('blockPointerType0')"><a name="blockPointerType0Anchor">blockPointerType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockPointerType.html">BlockPointerType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="blockPointerType0"><pre>Matches block pointer types, i.e. types syntactically represented as
"void (^)(int)".

The pointee is always required to be a FunctionType.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('builtinType0')"><a name="builtinType0Anchor">builtinType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BuiltinType.html">BuiltinType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="builtinType0"><pre>Matches builtin Types.

Given
  enum E { Ok };
  enum E e;
  int b;
  float c;
The matcher varDecl(hasType(builtinType()))
matches int b and float c.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('complexType0')"><a name="complexType0Anchor">complexType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ComplexType.html">ComplexType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="complexType0"><pre>Matches C99 complex types.

Given
  _Complex float f;
The matcher complexType()
_Complex float
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('constantArrayType0')"><a name="constantArrayType0Anchor">constantArrayType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ConstantArrayType.html">ConstantArrayType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="constantArrayType0"><pre>Matches C arrays with a specified constant size.

Given
  void foo() {
    int a[2];
    int b[] = { 2, 3 };
    int c[b[0]];
  }
The matcher constantArrayType()
int[2]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('decayedType0')"><a name="decayedType0Anchor">decayedType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecayedType.html">DecayedType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="decayedType0"><pre>Matches decayed type
  void f(int i[]) {
    i[1] = 0;
  }
The matcher
valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))
matches int i[] in declaration of The matcher
expr(hasType(decayedType(hasDecayedType(pointerType()))))
matches i in </pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('decltypeType0')"><a name="decltypeType0Anchor">decltypeType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecltypeType.html">DecltypeType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="decltypeType0"><pre>Matches types nodes representing C++11 decltype(&lt;expr&gt;) types.

Given
  short i = 1;
  int j = 42;
  decltype(i + j) result = i + j;

The matcher decltypeType()
decltype(i + j)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('deducedTemplateSpecializationType0')"><a name="deducedTemplateSpecializationType0Anchor">deducedTemplateSpecializationType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeducedTemplateSpecializationType.html">DeducedTemplateSpecializationType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="deducedTemplateSpecializationType0"><pre>Matches C++17 deduced template specialization types, e.g. deduced class
template types.

Given
  template &lt;typename T&gt;
  class C { public: C(T); };

  C c(123);

The matcher deducedTemplateSpecializationType() matches the type
C of the declaration of the variable c.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('dependentSizedArrayType0')"><a name="dependentSizedArrayType0Anchor">dependentSizedArrayType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DependentSizedArrayType.html">DependentSizedArrayType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="dependentSizedArrayType0"><pre>Matches C++ arrays whose size is a value-dependent expression.

Given
  template&lt;typename T, int Size&gt;
  class array {
    T data[Size];
  };

The matcher dependentSizedArrayType()
T[Size]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('dependentSizedExtVectorType0')"><a name="dependentSizedExtVectorType0Anchor">dependentSizedExtVectorType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DependentSizedExtVectorType.html">DependentSizedExtVectorType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="dependentSizedExtVectorType0"><pre>Matches C++ extended vector type where either the type or size is
dependent.

Given
  template&lt;typename T, int Size&gt;
  class vector {
    typedef T __attribute__((ext_vector_type(Size))) type;
  };

The matcher dependentSizedExtVectorType()
T __attribute__((ext_vector_type(Size)))
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('elaboratedType0')"><a name="elaboratedType0Anchor">elaboratedType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ElaboratedType.html">ElaboratedType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="elaboratedType0"><pre>Matches types specified with an elaborated type keyword or with a
qualified name.

Given
  namespace N {
    namespace M {
      class D {};
    }
  }
  class C {};

  C c;
  N::M::D d;


The matcher elaboratedType() matches the type
C three times. Once for the type of the
variable c, once for the type of the class definition and once for the
type in the injected class name. For D}, it matches
N::M::D of variable d and its class definition and
injected class name
D one time respectively.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('enumType0')"><a name="enumType0Anchor">enumType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="enumType0"><pre>Matches enum types.

Given
  enum C { Green };
  enum class S { Red };

  C c;
  S s;


The matcher enumType() matches the type
enum C of c ,
and the type enum S of s .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('functionProtoType0')"><a name="functionProtoType0Anchor">functionProtoType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionProtoType.html">FunctionProtoType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="functionProtoType0"><pre>Matches FunctionProtoType nodes.

Given
  int (*f)(int);
  void g();
The matcher functionProtoType()
matches the type int (int) of 'f' and the type
void (void) of 'g' in C++ mode.
In C, the type void () of 'g' is not
matched because it does not contain a prototype.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('functionType0')"><a name="functionType0Anchor">functionType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionType.html">FunctionType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="functionType0"><pre>Matches FunctionType nodes.

Given
  int (*f)(int);
  void g();
The matcher functionType()
int (int) and the type of
void (void) in C++ and in C23 and
later. Before C23, the function type for f will be matched the same way,
but the function type for g will match
void ().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('incompleteArrayType0')"><a name="incompleteArrayType0Anchor">incompleteArrayType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IncompleteArrayType.html">IncompleteArrayType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="incompleteArrayType0"><pre>Matches C arrays with unspecified size.

Given
  int a[] = { 2, 3 };
  int b[42];
  void f(int c[]) { int d[a[0]]; };
The matcher incompleteArrayType()
int[] and int[]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('injectedClassNameType0')"><a name="injectedClassNameType0Anchor">injectedClassNameType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="injectedClassNameType0"><pre>Matches injected class name types.

Given
  template &lt;typename T&gt; struct S {
    void f(S s);
    void g(S&lt;T&gt; s);
  };

The matcher
parmVarDecl(hasType(elaboratedType(namesType(injectedClassNameType()))))
matches S s, but not s}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('lValueReferenceType0')"><a name="lValueReferenceType0Anchor">lValueReferenceType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LValueReferenceType.html">LValueReferenceType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="lValueReferenceType0"><pre>Matches lvalue reference types.

Given
  int *a;
  int &amp;b = *a;
  int &amp;&amp;c = 1;
  auto &amp;d = b;
  auto &amp;&amp;e = c;
  auto &amp;&amp;f = 2;
  int g = 5;


The matcher lValueReferenceType() matches the type
int &amp; of b and the type auto &amp;
of d.
FIXME: figure out why auto changechange matches twice
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('macroQualifiedType0')"><a name="macroQualifiedType0Anchor">macroQualifiedType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MacroQualifiedType.html">MacroQualifiedType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="macroQualifiedType0"><pre>Matches qualified types when the qualifier is applied via a macro.

Given
  #define CDECL __attribute__((cdecl))
  typedef void (CDECL *X)();
  typedef void (__attribute__((cdecl)) *Y)();
The matcher macroQualifiedType()
matches the type CDECL void
(void) of the typedef declaration of X , unless when in C98-C17, there
CDECL void (),
but it does not match the type
__attribute((cdecl)) void () of Y .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('memberPointerType0')"><a name="memberPointerType0Anchor">memberPointerType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberPointerType.html">MemberPointerType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="memberPointerType0"><pre>Matches member pointer types.
Given
  struct A { int i; };
  int A::* ptr = &amp;A::i;

The matcher memberPointerType()
matches int struct A::*.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('objcObjectPointerType0')"><a name="objcObjectPointerType0Anchor">objcObjectPointerType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCObjectPointerType.html">ObjCObjectPointerType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="objcObjectPointerType0"><pre>Matches an Objective-C object pointer type, which is different from
a pointer type, despite being syntactically similar.

Given
  int *a;

  @interface Foo
  @end
  Foo *f;

The matcher pointerType()
matches Foo *, but does not match
int *.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('parenType0')"><a name="parenType0Anchor">parenType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParenType.html">ParenType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="parenType0"><pre>Matches ParenType nodes.

Given
  int (*ptr_to_array)[4];
  int *array_of_ptrs[4];

The matcher varDecl(hasType(pointsTo(parenType())))
  matches ptr_to_array but not
  array_of_ptrs.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('pointerType0')"><a name="pointerType0Anchor">pointerType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerType.html">PointerType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="pointerType0"><pre>Matches pointer types, but does not match Objective-C object pointer
types.

Given
  typedef int* int_ptr;
  void foo(char *str,
           int val,
           int *val_ptr,
           int_ptr not_a_ptr,
           int_ptr *ptr);

The matcher parmVarDecl(hasType(pointerType()))
matches char *str, int *val_ptr and
int_ptr *ptr.

  @interface Foo
  @end
  Foo *f;

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('rValueReferenceType0')"><a name="rValueReferenceType0Anchor">rValueReferenceType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RValueReferenceType.html">RValueReferenceType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="rValueReferenceType0"><pre>Matches rvalue reference types.

Given
  int *a;
  int &amp;b = *a;
  int &amp;&amp;c = 1;
  auto &amp;d = b;
  auto &amp;&amp;e = c;
  auto &amp;&amp;f = 2;
  int g = 5;


The matcher rValueReferenceType() matches the type
int &amp;&amp; of c and the type
auto &amp;&amp; of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('recordType0')"><a name="recordType0Anchor">recordType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="recordType0"><pre>Matches record types (e.g. structs, classes).

Given
  class C {};
  struct S {};

  C c;
  S s;


The matcher recordType() matches the type
class C of the variable declaration of c and
matches the type struct S of the variable
declaration of s.
Both of these types are matched three times, once for the type of the
variable, once for the definition of the class, and once for the type of the
injected class name.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('referenceType0')"><a name="referenceType0Anchor">referenceType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceType.html">ReferenceType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="referenceType0"><pre>Matches both lvalue and rvalue reference types.

Given
  int *a;
  int &amp;b = *a;
  int &amp;&amp;c = 1;
  auto &amp;d = b;
  auto &amp;&amp;e = c;
  auto &amp;&amp;f = 2;
  int g = 5;


The matcher referenceType() matches the type
int &amp; of b , the type int &amp;&amp; of
c, the type
auto &amp; d, and the type
auto &amp;&amp; of e and f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('substTemplateTypeParmType0')"><a name="substTemplateTypeParmType0Anchor">substTemplateTypeParmType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="substTemplateTypeParmType0"><pre>Matches types that represent the result of substituting a type for a
template type parameter.

Given
  template &lt;typename T&gt;
  void F(T t) {
    T local;
    int i = 1 + t;
  }
  void f() {
    F(0);
  }


The matcher varDecl(hasType(substTemplateTypeParmType()))
matches T t and T local for the substituted template type
int in the instantiation of F .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('tagType0')"><a name="tagType0Anchor">tagType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="tagType0"><pre>Matches tag types (record and enum types).

Given
  enum E { Ok };
  class C {};

  E e;
  C c;


The matcher tagType() matches the type
enum E of variable e and the type
class C three times, once for the type
of the variable c , once for the type of the class definition and once of
the type in the injected class name.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('templateSpecializationType0')"><a name="templateSpecializationType0Anchor">templateSpecializationType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateSpecializationType0"><pre>Matches template specialization types.

Given
  template &lt;typename T&gt;
  class C { };

  template class C&lt;int&gt;;
  C&lt;int&gt; intvar;
  C&lt;char&gt; charvar;


The matcher templateSpecializationType() matches the type
C&lt;int&gt; of the explicit instantiation in A and the
type C&lt;char&gt; of the variable declaration in
B.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('templateTypeParmType0')"><a name="templateTypeParmType0Anchor">templateTypeParmType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="templateTypeParmType0"><pre>Matches template type parameter types.

Given
  template &lt;typename T&gt; void f(int i);

The matcher templateTypeParmType() matches T,
but does not match int.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('type0')"><a name="type0Anchor">type</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="type0"><pre>Matches Types in the clang AST.

Given
  const int b = 1;

The matcher varDecl(hasType(type().bind("type")))
matches const int b = 1, with type()
matching int.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('typedefType0')"><a name="typedefType0Anchor">typedefType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="typedefType0"><pre>Matches typedef types.

Given
  typedef int X;
  X x = 0;
The matcher typedefType()
matches X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('unaryTransformType0')"><a name="unaryTransformType0Anchor">unaryTransformType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryTransformType.html">UnaryTransformType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="unaryTransformType0"><pre>Matches types nodes representing unary type transformations.

Given
  template &lt;typename T&gt; struct A {
    typedef __underlying_type(T) type;
  };

The matcher unaryTransformType()
matches __underlying_type(T)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('usingType0')"><a name="usingType0Anchor">usingType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingType.html">UsingType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="usingType0"><pre>Matches types specified through a using declaration.

Given
  namespace a { struct S {}; }
  using a::S;
  S s;


The matcher usingType() matches the type a::S
of the variable declaration of s.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('variableArrayType0')"><a name="variableArrayType0Anchor">variableArrayType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VariableArrayType.html">VariableArrayType</a>&gt;...</td></tr>
<tr><td colspan="4" class="doc" id="variableArrayType0"><pre>Matches C arrays with a specified size that is not an
integer-constant-expression.

Given
  void f() {
    int a[] = { 2, 3 };
    int b[42];
    int c[a[0]];
  }
The matcher variableArrayType()
int[a[0]]
</pre></td></tr>

<!--END_DECL_MATCHERS -->
</table>

<!-- ======================================================================= -->
<h2 id="narrowing-matchers">Narrowing Matchers</h2>
<!-- ======================================================================= -->

<p>Narrowing matchers match certain attributes on the current node, thus
narrowing down the set of nodes of the current type to match on.</p>

<p>There are special logical narrowing matchers (allOf, anyOf, anything and unless)
which allow users to create more powerful match expressions.</p>

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
<!-- START_NARROWING_MATCHERS -->

<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('allOf0')"><a name="allOf0Anchor">allOf</a></td><td>Matcher&lt;*&gt;, ..., Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="allOf0"><pre>Matches if all given matchers match.

Usable as: Any Matcher

  int v0 = 0;
  int v1 = 1;

The matcher varDecl(allOf(hasName("v0"), hasType(isInteger())))
matches int v0 = 0.
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('anyOf0')"><a name="anyOf0Anchor">anyOf</a></td><td>Matcher&lt;*&gt;, ..., Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="anyOf0"><pre>Matches if any of the given matchers matches.

Usable as: Any Matcher

  char v0 = 'a';
  int v1 = 1;
  float v2 = 2.0;

The matcher varDecl(anyOf(hasName("v0"), hasType(isInteger())))
matches char v0 = 'a' and int v1 = 1.
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('anything0')"><a name="anything0Anchor">anything</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="anything0"><pre>Matches any node.

Useful when another matcher requires a child matcher, but there's no
additional constraint. This will often be used with an explicit conversion
to an internal::Matcher&lt;&gt; type such as TypeMatcher.

Given
  int* p;
  void f();
The matcher decl(anything())
matches int* p and void f().
Usable as: Any Matcher
</pre></td></tr>


<tr><td><em>unspecified</em></td><td class="name" onclick="toggle('mapAnyOf0')"><a name="mapAnyOf0Anchor">mapAnyOf</a></td><td>nodeMatcherFunction...</td></tr>
<tr><td colspan="4" class="doc" id="mapAnyOf0"><pre>Matches any of the NodeMatchers with InnerMatchers nested within

Given
  void f() {
    if (true);
    for (; true; );
  }


The matcher stmt(mapAnyOf(ifStmt, forStmt).with(
    hasCondition(cxxBoolLiteral(equals(true)))
    )),
which is equivalent to
stmt(anyOf(
    ifStmt(hasCondition(cxxBoolLiteral(equals(true)))).bind("trueCond"),
    forStmt(hasCondition(cxxBoolLiteral(equals(true)))).bind("trueCond")
    )),
matches if (true); and for (; true; );.

The with() chain-call accepts zero or more matchers which are combined
as-if with allOf() in each of the node matchers.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('unless0')"><a name="unless0Anchor">unless</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="unless0"><pre>Matches if the provided matcher does not match.

Given
  class X {};
  class Y {};

The matcher cxxRecordDecl(unless(hasName("X")))
matches Y

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Attr.html">Attr</a>&gt;</td><td class="name" onclick="toggle('isImplicit1')"><a name="isImplicit1Anchor">isImplicit</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isImplicit1"><pre>Matches an entity that has been implicitly added by the compiler (e.g.
implicit default/copy constructors).

Given
  struct S {};
  void f(S obj) {
    S copy = obj;
    [&amp;](){ return copy; };
  }


The matcher cxxConstructorDecl(isImplicit(), isCopyConstructor())
matches the implicit copy constructor of S.
The matcher lambdaExpr(forEachLambdaCapture(
    lambdaCapture(isImplicit()))) matches [&amp;](){ return copy; },
because it implicitly captures copy .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasAnyOperatorName0')"><a name="hasAnyOperatorName0Anchor">hasAnyOperatorName</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyOperatorName0"><pre>Matches operator expressions (binary or unary) that have any of the
specified names.

It provides a compact way of writing if an operator has any of the specified
names:
The matcher
   hasAnyOperatorName("+", "-")
Is equivalent to
   hasOperatorName("-"))}

Given
void foo(bool a, bool b) {
  !(a || b);
 }

void bar(bool a, bool b) {
  a &amp;&amp; b;
 }

The matcher binaryOperator(hasAnyOperatorName("||", "&amp;&amp;"))
matches a || b and a &amp;&amp; b.
The matcher unaryOperator(hasAnyOperatorName("-", "!"))
matches !(a || b).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasOperatorName0')"><a name="hasOperatorName0Anchor">hasOperatorName</a></td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOperatorName0"><pre>Matches the operator Name of operator expressions and fold expressions
(binary or unary).

Given
void foo(bool a, bool b) {
  !(a || b);
 }

The matcher binaryOperator(hasOperatorName("||"))
matches a || b

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

The matcher cxxFoldExpr(hasOperatorName("+"))
 matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('isAssignmentOperator0')"><a name="isAssignmentOperator0Anchor">isAssignmentOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isAssignmentOperator0"><pre>Matches all kinds of assignment operators.

Given
void foo(int a, int b) {
  if (a == b)
    a += b;
}
The matcher binaryOperator(isAssignmentOperator())
matches a += b.

Given
  struct S { S&amp; operator=(const S&amp;); };
  void x() { S s1, s2; s1 = s2; }

The matcher cxxOperatorCallExpr(isAssignmentOperator())
matches s1 = s2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('isComparisonOperator0')"><a name="isComparisonOperator0Anchor">isComparisonOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isComparisonOperator0"><pre>Matches comparison operators.

Given
void foo(int a, int b) {
  if (a == b)
    a += b;
}
The matcher binaryOperator(isComparisonOperator())
matches a == b

Given
  struct S { bool operator&lt;(const S&amp; other); };
  void x(S s1, S s2) { bool b1 = s1 &lt; s2; }

The matcher cxxOperatorCallExpr(isComparisonOperator())
matches s1 &lt; s2
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('isPrivate1')"><a name="isPrivate1Anchor">isPrivate</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isPrivate1"><pre>Matches private C++ declarations and C++ base specifers that specify private
inheritance.

Given
  class C {
  public:    int a;
  protected: int b;
  private:   int c;
  };

The matcher fieldDecl(isPrivate())
matches c.

  struct Base {};
  struct Derived1 : private Base {}; // Base
  class Derived2 : Base {}; // Base

The matcher
cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(isPrivate()).bind("base")))
matches Derived1 and Derived2, with
cxxBaseSpecifier(isPrivate()) matching
Base.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('isProtected1')"><a name="isProtected1Anchor">isProtected</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isProtected1"><pre>Matches protected C++ declarations and C++ base specifers that specify
protected inheritance.

Given
  class C {
  public:    int a;
  protected: int b;
  private:   int c;
  };

The matcher fieldDecl(isProtected())
matches b.

  class Base {};
  class Derived : protected Base {};

The matcher
cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(isProtected()).bind("base")))
matches Derived, with
cxxBaseSpecifier(isProtected()) matching
Base.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('isPublic1')"><a name="isPublic1Anchor">isPublic</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isPublic1"><pre>Matches public C++ declarations and C++ base specifers that specify public
inheritance.

Given
  class C {
  public:    int a;
  protected: int b;
  private:   int c;
  };

The matcher fieldDecl(isPublic())
matches a.

Given
  class Base {};
  class Derived1 : public Base {};
  struct Derived2 : Base {};

The matcher
cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(isPublic()).bind("base")))
matches Derived1 and Derived2,
with cxxBaseSpecifier(isPublic()) matching
public Base and Base.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('isVirtual1')"><a name="isVirtual1Anchor">isVirtual</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isVirtual1"><pre>Matches declarations of virtual methods and C++ base specifers that specify
virtual inheritance.

Given
  class A {
   public:
    virtual void x(); // matches x
  };

The matcher cxxMethodDecl(isVirtual())
matches x.

Given
  struct Base {};
  struct DirectlyDerived : virtual Base {}; // matches Base
  struct IndirectlyDerived : DirectlyDerived, Base {}; // matches Base

The matcher
cxxRecordDecl(hasDirectBase(cxxBaseSpecifier(isVirtual())))
matches DirectlyDerived.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;</td><td class="name" onclick="toggle('equals5')"><a name="equals5Anchor">equals</a></td><td>bool Value</td></tr>
<tr><td colspan="4" class="doc" id="equals5"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;</td><td class="name" onclick="toggle('equals2')"><a name="equals2Anchor">equals</a></td><td>const ValueT  Value</td></tr>
<tr><td colspan="4" class="doc" id="equals2"><pre>Matches literals that are equal to the given value of type ValueT.

Given
void f(char, bool, double, int);
void foo() {
  f('false, 3.14, 42);
}

The matcher characterLiteral(equals(0U)) matches 'The matchers cxxBoolLiteral(equals(false)) and
cxxBoolLiteral(equals(0)) match false.
The matcher floatLiteral(equals(3.14)) matches 3.14.
The matcher integerLiteral(equals(42)) matches 42.

Note that you cannot directly match a negative numeric literal because the
minus sign is not part of the literal: It is a unary operator whose operand
is the positive numeric literal. Instead, you must use a unaryOperator()
matcher to match the minus sign:

Given
  int val = -1;

The matcher unaryOperator(hasOperatorName("-"),
              hasUnaryOperand(integerLiteral(equals(1))))
matches -1.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;,
           Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FloatingLiteral.html">FloatingLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;</td><td class="name" onclick="toggle('equals11')"><a name="equals11Anchor">equals</a></td><td>double Value</td></tr>
<tr><td colspan="4" class="doc" id="equals11"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;</td><td class="name" onclick="toggle('equals8')"><a name="equals8Anchor">equals</a></td><td>unsigned Value</td></tr>
<tr><td colspan="4" class="doc" id="equals8"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a>&gt;</td><td class="name" onclick="toggle('isCatchAll0')"><a name="isCatchAll0Anchor">isCatchAll</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isCatchAll0"><pre>Matches a C++ catch statement that has a catch-all handler.

Given
  void foo() {
    try {}
    catch (int) {}
    catch (...) {}
  }

The matcher cxxCatchStmt(isCatchAll())
matches catch (...) {}
but does not match catch(int)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountAtLeast1')"><a name="argumentCountAtLeast1Anchor">argumentCountAtLeast</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountAtLeast1"><pre>Checks that a call expression or a constructor call expression has at least
the specified number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void g(int x, int y, int z);
  void foo() {
    f(0, 0);
    g(0, 0, 0);
  }
The matcher callExpr(argumentCountAtLeast(2))
matches f(0, 0) and g(0, 0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountIs1')"><a name="argumentCountIs1Anchor">argumentCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountIs1"><pre>Checks that a call expression or a constructor call expression has
a specific number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void foo() {
    f(0, 0);
  }
The matcher callExpr(argumentCountIs(2))
matches f(0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('isListInitialization0')"><a name="isListInitialization0Anchor">isListInitialization</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isListInitialization0"><pre>Matches a constructor call expression which uses list initialization.

Given
  namespace std {
    template &lt;typename T&gt;
    class initializer_list {
      const T* begin;
      const T* end;
    };
  }
  template &lt;typename T&gt; class vector {
    public: vector(std::initializer_list&lt;T&gt;) {}
  };

  vector&lt;int&gt; a({ 1, 2, 3 });
  vector&lt;int&gt; b = { 4, 5 };
  int c[] = { 6, 7 };
  struct pair { int x; int y; };
  pair d = { 8, 9 };

The matcher cxxConstructExpr(isListInitialization())
matches { 4, 5 }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('requiresZeroInitialization0')"><a name="requiresZeroInitialization0Anchor">requiresZeroInitialization</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="requiresZeroInitialization0"><pre>Matches a constructor call expression which requires
zero initialization.

Given
void foo() {
  struct Foo {
    double x;
  };
  auto Val = Foo();
}

The matcher
cxxConstructExpr(requiresZeroInitialization())
matches Foo() because the x member has to be zero initialized.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('isCopyConstructor0')"><a name="isCopyConstructor0Anchor">isCopyConstructor</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isCopyConstructor0"><pre>Matches constructor declarations that are copy constructors.

Given
  struct S {
    S(); // #1
    S(const S &amp;); // #2
    S(S &amp;&amp;); // #3
  };

The matcher cxxConstructorDecl(isCopyConstructor())
matches S(const S &amp;),
but does not match S() or S(S &amp;&amp;).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('isDefaultConstructor0')"><a name="isDefaultConstructor0Anchor">isDefaultConstructor</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefaultConstructor0"><pre>Matches constructor declarations that are default constructors.

Given
  struct S {
    S(); // #1
    S(const S &amp;); // #2
    S(S &amp;&amp;); // #3
  };

The matcher cxxConstructorDecl(isDefaultConstructor())
matches S()
but does not match S(const S &amp;); or S(S &amp;&amp;);.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('isDelegatingConstructor0')"><a name="isDelegatingConstructor0Anchor">isDelegatingConstructor</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDelegatingConstructor0"><pre>Matches constructors that delegate to another constructor.

Given
  struct S {
    S(); // #1
    S(int) {} // #2
    S(S &amp;&amp;) : S() {} // #3
  };
  S::S() : S(0) {} // #4

The matcher cxxConstructorDecl(isDelegatingConstructor())
matches S(S &amp;&amp;) : S() {} and S::S() : S(0) {},
but does not match S() or S(int).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('isExplicit0')"><a name="isExplicit0Anchor">isExplicit</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicit0"><pre>Matches constructor, conversion function, and deduction guide declarations
that have an explicit specifier if this explicit specifier is resolved to
true.

Given
  template&lt;bool b&gt;
  struct S {
    S(int); // #1
    explicit S(double); // #2
    operator int(); // #3
    explicit operator bool(); // #4
    explicit(false) S(bool); // # 7
    explicit(true) S(char); // # 8
    explicit(b) S(float); // # 9
  };
  S(int) -&gt; S&lt;true&gt;; // #5
  explicit S(double) -&gt; S&lt;false&gt;; // #6

The matcher cxxConstructorDecl(isExplicit())
matches explicit S(double)
and explicit(true) S(char)
but does not match S(int);, explicit(false) S(bool); or
explicit(b) S(float)
The matcher cxxConversionDecl(isExplicit())
matches explicit operator bool()
but does not match operator int().
The matcher cxxDeductionGuideDecl(isExplicit())
matches the deduction guide explicit S(double) -&gt; S&lt;false&gt;,
the implicit copy deduction candiate
auto (double) -&gt; S&lt;b&gt; and
the implicitly generated deduction guide for explicit(true) S(char),
but does not match S(int) -&gt; S&lt;true&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('isInheritingConstructor0')"><a name="isInheritingConstructor0Anchor">isInheritingConstructor</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInheritingConstructor0"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('isMoveConstructor0')"><a name="isMoveConstructor0Anchor">isMoveConstructor</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isMoveConstructor0"><pre>Matches constructor declarations that are move constructors.

Given
  struct S {
    S(); // #1
    S(const S &amp;); // #2
    S(S &amp;&amp;); // #3
  };

The matcher cxxConstructorDecl(isMoveConstructor())
matches S(S &amp;&amp;)
but does not match S(); or S(S &amp;&amp;);
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a>&gt;</td><td class="name" onclick="toggle('isExplicit1')"><a name="isExplicit1Anchor">isExplicit</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicit1"><pre>Matches constructor, conversion function, and deduction guide declarations
that have an explicit specifier if this explicit specifier is resolved to
true.

Given
  template&lt;bool b&gt;
  struct S {
    S(int); // #1
    explicit S(double); // #2
    operator int(); // #3
    explicit operator bool(); // #4
    explicit(false) S(bool); // # 7
    explicit(true) S(char); // # 8
    explicit(b) S(float); // # 9
  };
  S(int) -&gt; S&lt;true&gt;; // #5
  explicit S(double) -&gt; S&lt;false&gt;; // #6

The matcher cxxConstructorDecl(isExplicit())
matches explicit S(double)
and explicit(true) S(char)
but does not match S(int);, explicit(false) S(bool); or
explicit(b) S(float)
The matcher cxxConversionDecl(isExplicit())
matches explicit operator bool()
but does not match operator int().
The matcher cxxDeductionGuideDecl(isExplicit())
matches the deduction guide explicit S(double) -&gt; S&lt;false&gt;,
the implicit copy deduction candiate
auto (double) -&gt; S&lt;b&gt; and
the implicitly generated deduction guide for explicit(true) S(char),
but does not match S(int) -&gt; S&lt;true&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td><td class="name" onclick="toggle('isBaseInitializer0')"><a name="isBaseInitializer0Anchor">isBaseInitializer</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isBaseInitializer0"><pre>Matches a constructor initializer if it is initializing a base, as
opposed to a member.

Given
  struct B {};
  struct D : B {
    int I;
    D(int i) : I(i) {}
  };
  struct E : B {
    E() : B() {}
  };

The matcher
cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer()))
matches E() : B() {} and D(int i) : I(i) {}.
The constructor of D is matched, because it implicitly has a constructor
initializer for B .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td><td class="name" onclick="toggle('isMemberInitializer0')"><a name="isMemberInitializer0Anchor">isMemberInitializer</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isMemberInitializer0"><pre>Matches a constructor initializer if it is initializing a member, as
opposed to a base.

Given
  struct B {};
  struct D : B {
    int I;
    D(int i) : I(i) {}
  };
  struct E : B {
    E() : B() {}
  };

The matcher
cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer()))
  will match D(int i) : I(i) {}, but not match E() : B()
  {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td><td class="name" onclick="toggle('isWritten0')"><a name="isWritten0Anchor">isWritten</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isWritten0"><pre>Matches a constructor initializer if it is explicitly written in
code (as opposed to implicitly added by the compiler).

Given
  struct Bar { explicit Bar(const char*); };
  struct Foo {
    Foo() { }
    Foo(int) : foo_("A") { }
    Bar foo_{""};
  };

The matcher
cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())) will
match Foo(int) : foo_("A") { }, but not Foo() { }
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a>&gt;</td><td class="name" onclick="toggle('isExplicit2')"><a name="isExplicit2Anchor">isExplicit</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicit2"><pre>Matches constructor, conversion function, and deduction guide declarations
that have an explicit specifier if this explicit specifier is resolved to
true.

Given
  template&lt;bool b&gt;
  struct S {
    S(int); // #1
    explicit S(double); // #2
    operator int(); // #3
    explicit operator bool(); // #4
    explicit(false) S(bool); // # 7
    explicit(true) S(char); // # 8
    explicit(b) S(float); // # 9
  };
  S(int) -&gt; S&lt;true&gt;; // #5
  explicit S(double) -&gt; S&lt;false&gt;; // #6

The matcher cxxConstructorDecl(isExplicit())
matches explicit S(double)
and explicit(true) S(char)
but does not match S(int);, explicit(false) S(bool); or
explicit(b) S(float)
The matcher cxxConversionDecl(isExplicit())
matches explicit operator bool()
but does not match operator int().
The matcher cxxDeductionGuideDecl(isExplicit())
matches the deduction guide explicit S(double) -&gt; S&lt;false&gt;,
the implicit copy deduction candiate
auto (double) -&gt; S&lt;b&gt; and
the implicitly generated deduction guide for explicit(true) S(char),
but does not match S(int) -&gt; S&lt;true&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>&gt;</td><td class="name" onclick="toggle('hasMemberName0')"><a name="hasMemberName0Anchor">hasMemberName</a></td><td>std::string N</td></tr>
<tr><td colspan="4" class="doc" id="hasMemberName0"><pre>Matches template-dependent, but known, member names.

In template declarations, dependent members are not resolved and so can
not be matched to particular named declarations.

This matcher allows to match on the known name of members.

Given
  template &lt;typename T&gt;
  struct S {
      void mem();
  };
  template &lt;typename T&gt;
  void x() {
      S&lt;T&gt; s;
      s.mem();
  }

The matcher cxxDependentScopeMemberExpr(hasMemberName("mem"))
matches s.mem.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>&gt;</td><td class="name" onclick="toggle('isArrow2')"><a name="isArrow2Anchor">isArrow</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isArrow2"><pre>Matches member expressions that are called with '-&gt;' as opposed
to '.'.

Member calls on the implicit this pointer match as called with '-&gt;'.

Given
  class Y {
    void x() { this-&gt;x(); x(); Y y; y.x(); a; this-&gt;b; Y::b; }
    template &lt;class T&gt; void f() { this-&gt;f&lt;T&gt;(); f&lt;T&gt;(); }
    int a;
    static int b;
  };
  template &lt;class T&gt;
  class Z {
    void x() {
      this-&gt;m;
      this-&gt;t;
      this-&gt;t-&gt;m;
    }
    int m;
    T* t;
  };

The matcher memberExpr(isArrow())
matches this-&gt;x, x, a,
this-&gt;b, this-&gt;m and two times this-&gt;t,
once for the standalone member expression, and once for the member
expression that later accesses m .
Additionally, it does not match this-&gt;t-&gt;t.
The matcher cxxDependentScopeMemberExpr(isArrow())
matches this-&gt;t-&gt;m, but not this-&gt;m or this-&gt;t.
The matcher unresolvedMemberExpr(isArrow())
matches this-&gt;f&lt;T&gt;, f&lt;T&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>&gt;</td><td class="name" onclick="toggle('memberHasSameNameAsBoundNode0')"><a name="memberHasSameNameAsBoundNode0Anchor">memberHasSameNameAsBoundNode</a></td><td>std::string BindingID</td></tr>
<tr><td colspan="4" class="doc" id="memberHasSameNameAsBoundNode0"><pre>Matches template-dependent, but known, member names against an already-bound
node

In template declarations, dependent members are not resolved and so can
not be matched to particular named declarations.

This matcher allows to match on the name of already-bound VarDecl, FieldDecl
and CXXMethodDecl nodes.

Given
  template &lt;typename T&gt;
  struct S {
      void mem();
  };
  template &lt;typename T&gt;
  void x() {
      S&lt;T&gt; s;
      s.mem();
  }

The matcher cxxDependentScopeMemberExpr(
  hasObjectExpression(declRefExpr(hasType(
    elaboratedType(namesType(templateSpecializationType(
      hasDeclaration(classTemplateDecl(has(cxxRecordDecl(has(
          cxxMethodDecl(hasName("mem")).bind("templMem")
          )))))
    )))
  ))),
  memberHasSameNameAsBoundNode("templMem")
)
matches s.mem, with the inner matcher
cxxMethodDecl(hasName("mem")) matching
void mem() of the S template.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('hasOperatorName3')"><a name="hasOperatorName3Anchor">hasOperatorName</a></td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOperatorName3"><pre>Matches the operator Name of operator expressions and fold expressions
(binary or unary).

Given
void foo(bool a, bool b) {
  !(a || b);
 }

The matcher binaryOperator(hasOperatorName("||"))
matches a || b

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

The matcher cxxFoldExpr(hasOperatorName("+"))
 matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('isBinaryFold0')"><a name="isBinaryFold0Anchor">isBinaryFold</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isBinaryFold0"><pre>Matches binary fold expressions, i.e. fold expressions with an initializer.

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ...);
  }


The matcher cxxFoldExpr(isBinaryFold())
matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('isLeftFold0')"><a name="isLeftFold0Anchor">isLeftFold</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isLeftFold0"><pre>Matches left-folding fold expressions.

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ... * 1);
  }


The matcher cxxFoldExpr(isLeftFold())
matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('isRightFold0')"><a name="isRightFold0Anchor">isRightFold</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isRightFold0"><pre>Matches right-folding fold expressions.

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ... * 1);
  }


The matcher cxxFoldExpr(isRightFold())
matches (args * ... * 1).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('isUnaryFold0')"><a name="isUnaryFold0Anchor">isUnaryFold</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isUnaryFold0"><pre>Matches unary fold expressions, i.e. fold expressions without an
initializer.

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ...);
  }


The matcher cxxFoldExpr(isUnaryFold())
matches (args * ...), but not (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isConst0')"><a name="isConst0Anchor">isConst</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConst0"><pre>Matches if the given method declaration is const.

Given
struct A {
  void foo() const;
  void bar();
};


The matcher cxxMethodDecl(isConst())
matches foo but not bar
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isCopyAssignmentOperator0')"><a name="isCopyAssignmentOperator0Anchor">isCopyAssignmentOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isCopyAssignmentOperator0"><pre>Matches if the given method declaration declares a copy assignment
operator.

Given
struct A {
  A &amp;operator=(const A &amp;);
  A &amp;operator=(A &amp;&amp;);
};


The matcher cxxMethodDecl(isCopyAssignmentOperator())
matches A &amp;operator=(const A &amp;)
but does not match A &amp;operator=(A &amp;&amp;)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isExplicitObjectMemberFunction0')"><a name="isExplicitObjectMemberFunction0Anchor">isExplicitObjectMemberFunction</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicitObjectMemberFunction0"><pre>Matches if the given method declaration declares a member function with an
explicit object parameter.

Given
struct A {
 int operator-(this A, int);
 void fun(this A &amp;&amp;self);
 static int operator()(int);
 int operator+(int);
};


The matcher cxxMethodDecl(isExplicitObjectMemberFunction())
matches int operator-(this A, int) and
void fun(this A &amp;&amp;self),
but not static int operator()(int) or
int operator+(int).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isFinal1')"><a name="isFinal1Anchor">isFinal</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isFinal1"><pre>Matches if the given method or class declaration is final.

Given
  class A final {};

  struct B {
    virtual void f();
  };

  struct C : B {
    void f() final;
  };

The matcher cxxRecordDecl(isFinal())
matches A,
but does not match B or C.
The matcher cxxMethodDecl(isFinal())
matches void f() final in C ,
but does not match virtual void f() in B .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isMoveAssignmentOperator0')"><a name="isMoveAssignmentOperator0Anchor">isMoveAssignmentOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isMoveAssignmentOperator0"><pre>Matches if the given method declaration declares a move assignment
operator.

Given
struct A {
  A &amp;operator=(const A &amp;);
  A &amp;operator=(A &amp;&amp;);
};


The matcher cxxMethodDecl(isMoveAssignmentOperator())
matches A &amp;operator=(A &amp;&amp;)
but does not match A &amp;operator=(const A &amp;)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isOverride0')"><a name="isOverride0Anchor">isOverride</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isOverride0"><pre>Matches if the given method declaration overrides another method.

Given
  class A {
   public:
    virtual void x();
  };
  class B : public A {
   public:
    void x() override;
  };

The matcher cxxMethodDecl(isOverride())
  matches void x() override
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isPure0')"><a name="isPure0Anchor">isPure</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isPure0"><pre>Matches if the given method declaration is pure.

Given
  class A {
   public:
    virtual void x() = 0;
  };

The matcher cxxMethodDecl(isPure())
matches virtual void x() = 0
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isUserProvided0')"><a name="isUserProvided0Anchor">isUserProvided</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isUserProvided0"><pre>Matches method declarations that are user-provided.

Given
  struct S {
    S(); // #1
    S(const S &amp;) = default; // #2
    S(S &amp;&amp;) = delete; // #3
  };

The matcher cxxConstructorDecl(isUserProvided())
will match S(), but not S &amp;) = default} or
&amp;&amp;) = delete}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isVirtual0')"><a name="isVirtual0Anchor">isVirtual</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isVirtual0"><pre>Matches declarations of virtual methods and C++ base specifers that specify
virtual inheritance.

Given
  class A {
   public:
    virtual void x(); // matches x
  };

The matcher cxxMethodDecl(isVirtual())
matches x.

Given
  struct Base {};
  struct DirectlyDerived : virtual Base {}; // matches Base
  struct IndirectlyDerived : DirectlyDerived, Base {}; // matches Base

The matcher
cxxRecordDecl(hasDirectBase(cxxBaseSpecifier(isVirtual())))
matches DirectlyDerived.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isVirtualAsWritten0')"><a name="isVirtualAsWritten0Anchor">isVirtualAsWritten</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isVirtualAsWritten0"><pre>Matches if the given method declaration has an explicit "virtual".

Given
  class A {
   public:
    virtual void x();
  };
  class B : public A {
   public:
    void x();
  };

The matcher cxxMethodDecl(isVirtualAsWritten())
matches virtual void x() of A,
but does not match x()} of B .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;</td><td class="name" onclick="toggle('isArray0')"><a name="isArray0Anchor">isArray</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isArray0"><pre>Matches array new expressions.

Given
  struct MyClass { int x; };
  MyClass *p1 = new MyClass[10];

The matcher cxxNewExpr(isArray())
matches new MyClass[10].
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyOperatorName1')"><a name="hasAnyOperatorName1Anchor">hasAnyOperatorName</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyOperatorName1"><pre>Matches operator expressions (binary or unary) that have any of the
specified names.

It provides a compact way of writing if an operator has any of the specified
names:
The matcher
   hasAnyOperatorName("+", "-")
Is equivalent to
   hasOperatorName("-"))}

Given
void foo(bool a, bool b) {
  !(a || b);
 }

void bar(bool a, bool b) {
  a &amp;&amp; b;
 }

The matcher binaryOperator(hasAnyOperatorName("||", "&amp;&amp;"))
matches a || b and a &amp;&amp; b.
The matcher unaryOperator(hasAnyOperatorName("-", "!"))
matches !(a || b).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyOverloadedOperatorName0')"><a name="hasAnyOverloadedOperatorName0Anchor">hasAnyOverloadedOperatorName</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyOverloadedOperatorName0"><pre>Matches overloaded operator names.

Matches overloaded operator names specified in strings without the
"operator" prefix: e.g. "&lt;&lt;".

  hasAnyOverloadedOperatorName("+", "-")

Given
  struct Point { double x; double y; };
  Point operator+(const Point&amp;, const Point&amp;);
  Point operator-(const Point&amp;, const Point&amp;);

  Point sub(Point a, Point b) {
    return b - a;
  }


The matcher functionDecl(hasAnyOverloadedOperatorName("+", "-")),
which is equivalent to
functionDecl(anyOf(hasAnyOverloadedOperatorName("+"),
hasOverloadedOperatorName("-"))),
matches Point operator+(const Point&amp;, const Point&amp;) and
Point operator-(const Point&amp;, const Point&amp;).
The matcher
cxxOperatorCallExpr(hasAnyOverloadedOperatorName("+", "-")),
which is equivalent to
cxxOperatorCallExpr(anyOf(hasOverloadedOperatorName("+"),
hasOverloadedOperatorName("-"))),
matches b - a.

Is equivalent to
  anyOf(hasOverloadedOperatorName("+"), hasOverloadedOperatorName("-"))
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasOperatorName1')"><a name="hasOperatorName1Anchor">hasOperatorName</a></td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOperatorName1"><pre>Matches the operator Name of operator expressions and fold expressions
(binary or unary).

Given
void foo(bool a, bool b) {
  !(a || b);
 }

The matcher binaryOperator(hasOperatorName("||"))
matches a || b

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

The matcher cxxFoldExpr(hasOperatorName("+"))
 matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasOverloadedOperatorName1')"><a name="hasOverloadedOperatorName1Anchor">hasOverloadedOperatorName</a></td><td>StringRef Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOverloadedOperatorName1"><pre>Matches overloaded operator names.

Matches overloaded operator names specified in strings without the
"operator" prefix: e.g. "&lt;&lt;".

Given
  struct A { int operator*(); };
  const A &amp;operator&lt;&lt;(const A &amp;a, const A &amp;b);
  void f(A a) {
    a &lt;&lt; a;   // &lt;-- This matches
  }


The matcher cxxOperatorCallExpr(hasOverloadedOperatorName("&lt;&lt;"))
matches a &lt;&lt; a.
The matcher
cxxRecordDecl(hasMethod(hasOverloadedOperatorName("*")))
matches struct A { int operator*(); }.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('isAssignmentOperator1')"><a name="isAssignmentOperator1Anchor">isAssignmentOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isAssignmentOperator1"><pre>Matches all kinds of assignment operators.

Given
void foo(int a, int b) {
  if (a == b)
    a += b;
}
The matcher binaryOperator(isAssignmentOperator())
matches a += b.

Given
  struct S { S&amp; operator=(const S&amp;); };
  void x() { S s1, s2; s1 = s2; }

The matcher cxxOperatorCallExpr(isAssignmentOperator())
matches s1 = s2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('isComparisonOperator1')"><a name="isComparisonOperator1Anchor">isComparisonOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isComparisonOperator1"><pre>Matches comparison operators.

Given
void foo(int a, int b) {
  if (a == b)
    a += b;
}
The matcher binaryOperator(isComparisonOperator())
matches a == b

Given
  struct S { bool operator&lt;(const S&amp; other); };
  void x(S s1, S s2) { bool b1 = s1 &lt; s2; }

The matcher cxxOperatorCallExpr(isComparisonOperator())
matches s1 &lt; s2
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('hasDefinition0')"><a name="hasDefinition0Anchor">hasDefinition</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasDefinition0"><pre>Matches a class declaration that is defined.

Given
class x {};
class y;

The matcher cxxRecordDecl(hasDefinition())
matches class x {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isDerivedFrom2')"><a name="isDerivedFrom2Anchor">isDerivedFrom</a></td><td>std::string BaseName</td></tr>
<tr><td colspan="4" class="doc" id="isDerivedFrom2"><pre>Overloaded method as shortcut for isDerivedFrom(hasName(...)).

Matches C++ classes that are directly or indirectly derived from a class
matching Base, or Objective-C classes that directly or indirectly
subclass a class matching Base.

Note that a class is not considered to be derived from itself.

Example matches Y, Z, C (Base == hasName("X"))
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

  class Foo {};
  typedef Foo Alias;
  class Bar : public Alias {};  // derived from Alias, which is a
                                // typedef of Foo


The matcher cxxRecordDecl(isDerivedFrom("X"))
matches Y, Z and C.
The matcher cxxRecordDecl(isDerivedFrom("Foo"))
matches Bar.

In the following example, Bar matches isDerivedFrom(hasName("NSObject"))
  @interface NSObject @end
  @interface Bar : NSObject @end


Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isDirectlyDerivedFrom2')"><a name="isDirectlyDerivedFrom2Anchor">isDirectlyDerivedFrom</a></td><td>std::string BaseName</td></tr>
<tr><td colspan="4" class="doc" id="isDirectlyDerivedFrom2"><pre>Overloaded method as shortcut for isDirectlyDerivedFrom(hasName(...)).

Given
  struct Base {};
  struct DirectlyDerived : public Base {};
  struct IndirectlyDerived : public DirectlyDerived {};


The matcher cxxRecordDecl(isDirectlyDerivedFrom("Base"))
matches DirectlyDerived, but not
IndirectlyDerived.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isExplicitTemplateSpecialization2')"><a name="isExplicitTemplateSpecialization2Anchor">isExplicitTemplateSpecialization</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicitTemplateSpecialization2"><pre>Matches explicit template specializations of function, class, or
static member variable template instantiations.

Given
  template&lt;typename T&gt; void A(T t) { }
  template&lt;&gt; void A(int N) { }

The matcher functionDecl(isExplicitTemplateSpecialization())
  matches the specialization template&lt;&gt; void A(int N) { }.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isFinal0')"><a name="isFinal0Anchor">isFinal</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isFinal0"><pre>Matches if the given method or class declaration is final.

Given
  class A final {};

  struct B {
    virtual void f();
  };

  struct C : B {
    void f() final;
  };

The matcher cxxRecordDecl(isFinal())
matches A,
but does not match B or C.
The matcher cxxMethodDecl(isFinal())
matches void f() final in C ,
but does not match virtual void f() in B .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isLambda0')"><a name="isLambda0Anchor">isLambda</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isLambda0"><pre>Matches the generated class of lambda expressions.

Given
  auto x = []{};


The matcher varDecl(hasType(cxxRecordDecl(isLambda())))
matches auto x = []{}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isSameOrDerivedFrom2')"><a name="isSameOrDerivedFrom2Anchor">isSameOrDerivedFrom</a></td><td>std::string BaseName</td></tr>
<tr><td colspan="4" class="doc" id="isSameOrDerivedFrom2"><pre>Similar to isDerivedFrom(), but also matches classes that directly
match Base.
Overloaded method as shortcut for
isSameOrDerivedFrom(hasName(...)).

Given
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

The matcher
cxxRecordDecl(isSameOrDerivedFrom("X"), isDefinition())
matches class X {}, class Y : public X {},
class Z : public Y {} and class C : public B {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isTemplateInstantiation2')"><a name="isTemplateInstantiation2Anchor">isTemplateInstantiation</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isTemplateInstantiation2"><pre>Matches template instantiations of function, class, or static
member variable template instantiations.

Given
  template &lt;typename T&gt; class X {};
  class A {};
  X&lt;A&gt; x;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches class X&lt;class A&gt;.
  template &lt;typename T&gt; class X {};
  class A {};
  template class X&lt;A&gt;;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches template class X&lt;A&gt;
  template &lt;typename T&gt; class X {};
  class A {};
  extern template class X&lt;A&gt;;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches extern template class X&lt;A&gt;

But given
  template &lt;typename T&gt;  class X {};
  class A {};
  template &lt;&gt; class X&lt;A&gt; {};
  X&lt;A&gt; x;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
  does not match, as X&lt;A&gt; is an explicit template specialization.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasAnyOperatorName2')"><a name="hasAnyOperatorName2Anchor">hasAnyOperatorName</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyOperatorName2"><pre>Matches operator expressions (binary or unary) that have any of the
specified names.

It provides a compact way of writing if an operator has any of the specified
names:
The matcher
   hasAnyOperatorName("+", "-")
Is equivalent to
   hasOperatorName("-"))}

Given
void foo(bool a, bool b) {
  !(a || b);
 }

void bar(bool a, bool b) {
  a &amp;&amp; b;
 }

The matcher binaryOperator(hasAnyOperatorName("||", "&amp;&amp;"))
matches a || b and a &amp;&amp; b.
The matcher unaryOperator(hasAnyOperatorName("-", "!"))
matches !(a || b).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasOperatorName2')"><a name="hasOperatorName2Anchor">hasOperatorName</a></td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOperatorName2"><pre>Matches the operator Name of operator expressions and fold expressions
(binary or unary).

Given
void foo(bool a, bool b) {
  !(a || b);
 }

The matcher binaryOperator(hasOperatorName("||"))
matches a || b

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

The matcher cxxFoldExpr(hasOperatorName("+"))
 matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('isAssignmentOperator2')"><a name="isAssignmentOperator2Anchor">isAssignmentOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isAssignmentOperator2"><pre>Matches all kinds of assignment operators.

Given
void foo(int a, int b) {
  if (a == b)
    a += b;
}
The matcher binaryOperator(isAssignmentOperator())
matches a += b.

Given
  struct S { S&amp; operator=(const S&amp;); };
  void x() { S s1, s2; s1 = s2; }

The matcher cxxOperatorCallExpr(isAssignmentOperator())
matches s1 = s2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('isComparisonOperator2')"><a name="isComparisonOperator2Anchor">isComparisonOperator</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isComparisonOperator2"><pre>Matches comparison operators.

Given
void foo(int a, int b) {
  if (a == b)
    a += b;
}
The matcher binaryOperator(isComparisonOperator())
matches a == b

Given
  struct S { bool operator&lt;(const S&amp; other); };
  void x(S s1, S s2) { bool b1 = s1 &lt; s2; }

The matcher cxxOperatorCallExpr(isComparisonOperator())
matches s1 &lt; s2
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountAtLeast2')"><a name="argumentCountAtLeast2Anchor">argumentCountAtLeast</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountAtLeast2"><pre>Checks that a call expression or a constructor call expression has at least
the specified number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void g(int x, int y, int z);
  void foo() {
    f(0, 0);
    g(0, 0, 0);
  }
The matcher callExpr(argumentCountAtLeast(2))
matches f(0, 0) and g(0, 0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountIs2')"><a name="argumentCountIs2Anchor">argumentCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountIs2"><pre>Checks that a call expression or a constructor call expression has
a specific number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void foo() {
    f(0, 0);
  }
The matcher callExpr(argumentCountIs(2))
matches f(0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountAtLeast0')"><a name="argumentCountAtLeast0Anchor">argumentCountAtLeast</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountAtLeast0"><pre>Checks that a call expression or a constructor call expression has at least
the specified number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void g(int x, int y, int z);
  void foo() {
    f(0, 0);
    g(0, 0, 0);
  }
The matcher callExpr(argumentCountAtLeast(2))
matches f(0, 0) and g(0, 0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountIs0')"><a name="argumentCountIs0Anchor">argumentCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountIs0"><pre>Checks that a call expression or a constructor call expression has
a specific number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void foo() {
    f(0, 0);
  }
The matcher callExpr(argumentCountIs(2))
matches f(0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('usesADL0')"><a name="usesADL0Anchor">usesADL</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="usesADL0"><pre>Matches call expressions which were resolved using ADL.

Given
  namespace NS {
    struct X {};
    void y(X);
  }

  void y(...);

  void test() {
    NS::X x;
    y(x); // Matches
    NS::y(x); // Doesn't match
    y(42); // Doesn't match
    using NS::y;
    y(x); // Found by both unqualified lookup and ADL, doesn't match
   }


The matcher callExpr(usesADL())
matches y(x), but not y(42) or NS::y(x).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CastExpr.html">CastExpr</a>&gt;</td><td class="name" onclick="toggle('hasCastKind0')"><a name="hasCastKind0Anchor">hasCastKind</a></td><td>CastKind Kind</td></tr>
<tr><td colspan="4" class="doc" id="hasCastKind0"><pre>Matches casts that has a given cast kind.

Given
  int *p = 0;
The matcher castExpr(hasCastKind(CK_NullToPointer))
matches the implicit cast around 0

If the matcher is use from clang-query, CastKind parameter
should be passed as a quoted string. e.g., hasCastKind("CK_NullToPointer").
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;</td><td class="name" onclick="toggle('equals4')"><a name="equals4Anchor">equals</a></td><td>bool Value</td></tr>
<tr><td colspan="4" class="doc" id="equals4"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;</td><td class="name" onclick="toggle('equals3')"><a name="equals3Anchor">equals</a></td><td>const ValueT  Value</td></tr>
<tr><td colspan="4" class="doc" id="equals3"><pre>Matches literals that are equal to the given value of type ValueT.

Given
void f(char, bool, double, int);
void foo() {
  f('false, 3.14, 42);
}

The matcher characterLiteral(equals(0U)) matches 'The matchers cxxBoolLiteral(equals(false)) and
cxxBoolLiteral(equals(0)) match false.
The matcher floatLiteral(equals(3.14)) matches 3.14.
The matcher integerLiteral(equals(42)) matches 42.

Note that you cannot directly match a negative numeric literal because the
minus sign is not part of the literal: It is a unary operator whose operand
is the positive numeric literal. Instead, you must use a unaryOperator()
matcher to match the minus sign:

Given
  int val = -1;

The matcher unaryOperator(hasOperatorName("-"),
              hasUnaryOperand(integerLiteral(equals(1))))
matches -1.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;,
           Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FloatingLiteral.html">FloatingLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;</td><td class="name" onclick="toggle('equals10')"><a name="equals10Anchor">equals</a></td><td>double Value</td></tr>
<tr><td colspan="4" class="doc" id="equals10"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;</td><td class="name" onclick="toggle('equals7')"><a name="equals7Anchor">equals</a></td><td>unsigned Value</td></tr>
<tr><td colspan="4" class="doc" id="equals7"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('templateArgumentCountIs0')"><a name="templateArgumentCountIs0Anchor">templateArgumentCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="templateArgumentCountIs0"><pre>Matches if the number of template arguments equals N.

Given
  template&lt;typename T&gt; struct C {};
  C&lt;int&gt; c;

The matcher
classTemplateSpecializationDecl(templateArgumentCountIs(1))
matches struct C&lt;int&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html">CompoundStmt</a>&gt;</td><td class="name" onclick="toggle('statementCountIs0')"><a name="statementCountIs0Anchor">statementCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="statementCountIs0"><pre>Checks that a compound statement contains a specific number of
child statements.

Example: Given
void foo() {
  { for (;;) {} }
}
The matcher compoundStmt(statementCountIs(0))
{}
  but does not match the outer compound statement.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ConstantArrayType.html">ConstantArrayType</a>&gt;</td><td class="name" onclick="toggle('hasSize0')"><a name="hasSize0Anchor">hasSize</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="hasSize0"><pre>Matches nodes that have the specified size.

Given
  int a[42];
  int b[2 * 21];
  int c[41], d[43];
  char *s = "abcd";
  wchar_t *ws = L"abcd";
  char *w = "a";

The matcher constantArrayType(hasSize(42))
matches int[42] twice.
The matcher stringLiteral(hasSize(4))
matches "abcd" and L"abcd".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html">DeclStmt</a>&gt;</td><td class="name" onclick="toggle('declCountIs0')"><a name="declCountIs0Anchor">declCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="declCountIs0"><pre>Matches declaration statements that contain a specific number of
declarations.

Given
  void foo() {
    int a, b;
    int c;
    int d = 2, e;
  }
The matcher declStmt(declCountIs(2))
matches int a, b; and int d = 2, e;,
but does not match int c;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('equalsBoundNode1')"><a name="equalsBoundNode1Anchor">equalsBoundNode</a></td><td>std::string ID</td></tr>
<tr><td colspan="4" class="doc" id="equalsBoundNode1"><pre>Matches if a node equals a previously bound node.

Matches a node if it equals the node previously bound to ID.

Given
  class X { int a; int b; };

The matcher cxxRecordDecl(
    has(fieldDecl(hasName("a"), hasType(type().bind("t")))),
    has(fieldDecl(hasName("b"), hasType(type(equalsBoundNode("t"))))))
  matches X, as a and b have the same type.

Note that when multiple matches are involved via forEach* matchers,
equalsBoundNodes acts as a filter.
For example:
compoundStmt(
    forEachDescendant(varDecl().bind("d")),
    forEachDescendant(declRefExpr(to(decl(equalsBoundNode("d"))))))
will trigger a match for each combination of variable declaration
and reference to that variable declaration within a compound statement.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('equalsNode0')"><a name="equalsNode0Anchor">equalsNode</a></td><td>const Decl * Other</td></tr>
<tr><td colspan="4" class="doc" id="equalsNode0"><pre>Matches if a node equals another node.

Decl has pointer identity in the AST.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('hasAttr0')"><a name="hasAttr0Anchor">hasAttr</a></td><td>attr::Kind AttrKind</td></tr>
<tr><td colspan="4" class="doc" id="hasAttr0"><pre>Matches declaration that has a given attribute.

Given
  __attribute__((device)) void f() {}

The matcher decl(hasAttr(clang::attr::CUDADevice))
matches f.
If the matcher is used from clang-query, attr::Kind
parameter should be passed as a quoted string. e.g.,
hasAttr("attr::CUDADevice").
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isExpandedFromMacro0')"><a name="isExpandedFromMacro0Anchor">isExpandedFromMacro</a></td><td>std::string MacroName</td></tr>
<tr><td colspan="4" class="doc" id="isExpandedFromMacro0"><pre>Matches statements that are (transitively) expanded from the named macro.
Does not match if only part of the statement is expanded from that macro or
if different parts of the statement are expanded from different
appearances of the macro.

Given
  #define A 0
  #define B A
  int c = B;

The matcher integerLiteral(isExpandedFromMacro("A"))
matches the literal expanded at the initializer B of the variable
c .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isExpansionInFileMatching0')"><a name="isExpansionInFileMatching0Anchor">isExpansionInFileMatching</a></td><td>StringRef RegExp, Regex::RegexFlags Flags = NoFlags</td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInFileMatching0"><pre>Matches AST nodes that were expanded within files whose name is
partially matching a given regex.

Given the headers Y.h
  #pragma once
  typedef int my_y_int;
and X.h
  #pragma once
  typedef int my_x_int;
and the source code
  #include "X.h"
  #include "Y.h"
  typedef int my_main_file_int;
  my_main_file_int a = 0;
  my_x_int b = 1;
  my_y_int c = 2;

The matcher
typedefDecl(isExpansionInFileMatching("Y.h"))
matches typedef int my_y_int,
but does not match typedef int my_main_file_int or
typedef int my_x_int.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;

If the matcher is used in clang-query, RegexFlags parameter
should be passed as a quoted string. e.g: "NoFlags".
Flags can be combined with '|' example "IgnoreCase | BasicRegex"
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isExpansionInMainFile0')"><a name="isExpansionInMainFile0Anchor">isExpansionInMainFile</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInMainFile0"><pre>Matches AST nodes that were expanded within the main-file.

Given the header Y.h
  #pragma once
  typedef int my_header_int;
and the source file
  #include "Y.h"
  typedef int my_main_file_int;
  my_main_file_int a = 0;
  my_header_int b = 1;

The matcher typedefDecl(isExpansionInMainFile())
matches typedef int my_main_file_int,
but does not match typedef int my_header_int.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isExpansionInSystemHeader0')"><a name="isExpansionInSystemHeader0Anchor">isExpansionInSystemHeader</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInSystemHeader0"><pre>Matches AST nodes that were expanded within system-header-files.

Given the header SystemHeader.h
  #pragma once
  int header();
and the source code
  #include &lt;SystemHeader.h&gt;
  static int main_file();


The matcher functionDecl(isExpansionInSystemHeader())
matches int header(),
but does not match static int main_file().

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isImplicit0')"><a name="isImplicit0Anchor">isImplicit</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isImplicit0"><pre>Matches an entity that has been implicitly added by the compiler (e.g.
implicit default/copy constructors).

Given
  struct S {};
  void f(S obj) {
    S copy = obj;
    [&amp;](){ return copy; };
  }


The matcher cxxConstructorDecl(isImplicit(), isCopyConstructor())
matches the implicit copy constructor of S.
The matcher lambdaExpr(forEachLambdaCapture(
    lambdaCapture(isImplicit()))) matches [&amp;](){ return copy; },
because it implicitly captures copy .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isInAnonymousNamespace0')"><a name="isInAnonymousNamespace0Anchor">isInAnonymousNamespace</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInAnonymousNamespace0"><pre>Matches declarations in an anonymous namespace.

Given
  class vector {};
  namespace foo {
    class vector {};
    namespace {
      class vector {}; // #1
    }
  }
  namespace {
    class vector {}; // #2
    namespace foo {
      class vector {}; // #3
    }
  }

The matcher cxxRecordDecl(hasName("vector"),
                        isInAnonymousNamespace())
matches vector,
twice per declaration at #1, #2 and #3.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isInStdNamespace0')"><a name="isInStdNamespace0Anchor">isInStdNamespace</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInStdNamespace0"><pre>Matches declarations in the namespace `std`, but not in nested namespaces.

Given
  class vector {};
  namespace foo {
    class vector {};
    namespace std {
      class vector {};
    }
  }
  namespace std {
    inline namespace __1 {
      class vector {}; // #1
      namespace experimental {
        class vector {};
      }
    }
  }

The matcher cxxRecordDecl(hasName("vector"), isInStdNamespace())
matches class vector {} inside of namespace std.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isInstantiated0')"><a name="isInstantiated0Anchor">isInstantiated</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInstantiated0"><pre>Matches declarations that are template instantiations or are inside
template instantiations.

Given
  template&lt;typename T&gt; void A(T t) { T i; }
  void foo() {
    A(0);
    A(0U);
  }

The matcher functionDecl(isInstantiated())
matches the two instantiations of void A(T t) { T i; } that
are generated for int , and for int}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isPrivate0')"><a name="isPrivate0Anchor">isPrivate</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isPrivate0"><pre>Matches private C++ declarations and C++ base specifers that specify private
inheritance.

Given
  class C {
  public:    int a;
  protected: int b;
  private:   int c;
  };

The matcher fieldDecl(isPrivate())
matches c.

  struct Base {};
  struct Derived1 : private Base {}; // Base
  class Derived2 : Base {}; // Base

The matcher
cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(isPrivate()).bind("base")))
matches Derived1 and Derived2, with
cxxBaseSpecifier(isPrivate()) matching
Base.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isProtected0')"><a name="isProtected0Anchor">isProtected</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isProtected0"><pre>Matches protected C++ declarations and C++ base specifers that specify
protected inheritance.

Given
  class C {
  public:    int a;
  protected: int b;
  private:   int c;
  };

The matcher fieldDecl(isProtected())
matches b.

  class Base {};
  class Derived : protected Base {};

The matcher
cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(isProtected()).bind("base")))
matches Derived, with
cxxBaseSpecifier(isProtected()) matching
Base.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('isPublic0')"><a name="isPublic0Anchor">isPublic</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isPublic0"><pre>Matches public C++ declarations and C++ base specifers that specify public
inheritance.

Given
  class C {
  public:    int a;
  protected: int b;
  private:   int c;
  };

The matcher fieldDecl(isPublic())
matches a.

Given
  class Base {};
  class Derived1 : public Base {};
  struct Derived2 : Base {};

The matcher
cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(isPublic()).bind("base")))
matches Derived1 and Derived2,
with cxxBaseSpecifier(isPublic()) matching
public Base and Base.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a>&gt;</td><td class="name" onclick="toggle('designatorCountIs0')"><a name="designatorCountIs0Anchor">designatorCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="designatorCountIs0"><pre>Matches designated initializer expressions that contain
a specific number of designators.

Example: Given
  struct point2 { double x; double y; };
  struct point2 ptarray[10] = { [0].x = 1.0 };
  struct point2 pt = { .x = 2.0 };

The matcher designatedInitExpr(designatorCountIs(2))
matches [0].x = 1.0, but not .x = 2.0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumDecl.html">EnumDecl</a>&gt;</td><td class="name" onclick="toggle('isScoped0')"><a name="isScoped0Anchor">isScoped</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isScoped0"><pre>Matches C++11 scoped enum declaration.

Given
enum X {};
enum class Y {};

The matcher enumDecl(isScoped())
matches enum class Y {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('isInstantiationDependent0')"><a name="isInstantiationDependent0Anchor">isInstantiationDependent</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInstantiationDependent0"><pre>Matches expressions that are instantiation-dependent even if it is
neither type- nor value-dependent.

In the following example, the expression sizeof(sizeof(T() + T()))
is instantiation-dependent (since it involves a template parameter T),
but is neither type- nor value-dependent, since the type of the inner
sizeof is known (std::size_t) and therefore the size of the outer
sizeof is known.
  template&lt;typename T&gt;
  void f(T x, T y) { sizeof(T() + T()); }

The matcher expr(isInstantiationDependent())
matches sizeof(T() + T()),
(T() + T()),
T() + T() and T().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('isTypeDependent0')"><a name="isTypeDependent0Anchor">isTypeDependent</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isTypeDependent0"><pre>Matches expressions that are type-dependent because the template type
is not yet instantiated.

For example, the expressions "x" and "x + y" are type-dependent in
the following code, but "y" is not type-dependent:
  template&lt;typename T&gt;
  void add(T x, int y) {
    x + y;
  }

The matcher expr(isTypeDependent())
matches x + y and x.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('isValueDependent0')"><a name="isValueDependent0Anchor">isValueDependent</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isValueDependent0"><pre>Matches expression that are value-dependent because they contain a
non-type template parameter.

For example, the array bound of "Chars" in the following example is
value-dependent.
  template&lt;int Size&gt; int f() { return Size; }

The matcher expr(isValueDependent())
matches the return value Size.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('nullPointerConstant0')"><a name="nullPointerConstant0Anchor">nullPointerConstant</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="nullPointerConstant0"><pre>Matches expressions that resolve to a null pointer constant, such as
GNU's __null, C++11's nullptr, or C's NULL macro.

Given
  #define NULL 0
  void *v1 = NULL;
  void *v2 = nullptr;
  void *v3 = __null; // GNU extension
  char *cp = (char *)0;
  int *ip = 0;
  int i = 0;

The matcher expr(nullPointerConstant())
matches the initializer NULL of v1,
matches the initializer nullptr of v2,
matches the initializer __null of v3,
matches the initializer 0 of cp and
matches the initializer 0 of ip,
but does not match the initializer i of i.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FieldDecl.html">FieldDecl</a>&gt;</td><td class="name" onclick="toggle('hasBitWidth0')"><a name="hasBitWidth0Anchor">hasBitWidth</a></td><td>unsigned Width</td></tr>
<tr><td colspan="4" class="doc" id="hasBitWidth0"><pre>Matches non-static data members that are bit-fields of the specified
bit width.

Given
  class C {
    int a : 2;
    int b : 4;
    int c : 2;
  };

The matcher fieldDecl(hasBitWidth(2))
matches a and c,
but not b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FieldDecl.html">FieldDecl</a>&gt;</td><td class="name" onclick="toggle('isBitField0')"><a name="isBitField0Anchor">isBitField</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isBitField0"><pre>Matches non-static data members that are bit-fields.

Given
  class C {
    int a : 2;
    int b;
  };

The matcher fieldDecl(isBitField())
matches a,
but does not match b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FloatingLiteral.html">FloatingLiteral</a>&gt;</td><td class="name" onclick="toggle('equals1')"><a name="equals1Anchor">equals</a></td><td>const ValueT  Value</td></tr>
<tr><td colspan="4" class="doc" id="equals1"><pre>Matches literals that are equal to the given value of type ValueT.

Given
void f(char, bool, double, int);
void foo() {
  f('false, 3.14, 42);
}

The matcher characterLiteral(equals(0U)) matches 'The matchers cxxBoolLiteral(equals(false)) and
cxxBoolLiteral(equals(0)) match false.
The matcher floatLiteral(equals(3.14)) matches 3.14.
The matcher integerLiteral(equals(42)) matches 42.

Note that you cannot directly match a negative numeric literal because the
minus sign is not part of the literal: It is a unary operator whose operand
is the positive numeric literal. Instead, you must use a unaryOperator()
matcher to match the minus sign:

Given
  int val = -1;

The matcher unaryOperator(hasOperatorName("-"),
              hasUnaryOperand(integerLiteral(equals(1))))
matches -1.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;,
           Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FloatingLiteral.html">FloatingLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FloatingLiteral.html">FloatingLiteral</a>&gt;</td><td class="name" onclick="toggle('equals12')"><a name="equals12Anchor">equals</a></td><td>double Value</td></tr>
<tr><td colspan="4" class="doc" id="equals12"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyOverloadedOperatorName1')"><a name="hasAnyOverloadedOperatorName1Anchor">hasAnyOverloadedOperatorName</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyOverloadedOperatorName1"><pre>Matches overloaded operator names.

Matches overloaded operator names specified in strings without the
"operator" prefix: e.g. "&lt;&lt;".

  hasAnyOverloadedOperatorName("+", "-")

Given
  struct Point { double x; double y; };
  Point operator+(const Point&amp;, const Point&amp;);
  Point operator-(const Point&amp;, const Point&amp;);

  Point sub(Point a, Point b) {
    return b - a;
  }


The matcher functionDecl(hasAnyOverloadedOperatorName("+", "-")),
which is equivalent to
functionDecl(anyOf(hasAnyOverloadedOperatorName("+"),
hasOverloadedOperatorName("-"))),
matches Point operator+(const Point&amp;, const Point&amp;) and
Point operator-(const Point&amp;, const Point&amp;).
The matcher
cxxOperatorCallExpr(hasAnyOverloadedOperatorName("+", "-")),
which is equivalent to
cxxOperatorCallExpr(anyOf(hasOverloadedOperatorName("+"),
hasOverloadedOperatorName("-"))),
matches b - a.

Is equivalent to
  anyOf(hasOverloadedOperatorName("+"), hasOverloadedOperatorName("-"))
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasDynamicExceptionSpec0')"><a name="hasDynamicExceptionSpec0Anchor">hasDynamicExceptionSpec</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasDynamicExceptionSpec0"><pre>Matches functions that have a dynamic exception specification.

Given
  void f(int);
  void g(int) noexcept;
  void h(int) noexcept(true);
  void i(int) noexcept(false);
  void j(int) throw();
  void k(int) throw(int);
  void l(int) throw(...);

The matcher functionDecl(hasDynamicExceptionSpec())
matches the declarations void j(int) throw(),
void k(int) throw(int)
and void l(int) throw(...),
but does not match void f(int), void g(int) noexcept,
void h(int) noexcept(true)
or void i(int) noexcept(true).
The matcher
functionProtoType(hasDynamicExceptionSpec()) matches
the type void (int) throw() of j ,
the type void (int) throw(int) of k and
the type void (int) throw(...) of l .
It does not match
the type void (int) noexcept of f ,
the type void (int) noexcept of g ,
the type void (int) noexcept(int) of h or
the type void (int) noexcept(...) of i .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasOverloadedOperatorName0')"><a name="hasOverloadedOperatorName0Anchor">hasOverloadedOperatorName</a></td><td>StringRef Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOverloadedOperatorName0"><pre>Matches overloaded operator names.

Matches overloaded operator names specified in strings without the
"operator" prefix: e.g. "&lt;&lt;".

Given
  struct A { int operator*(); };
  const A &amp;operator&lt;&lt;(const A &amp;a, const A &amp;b);
  void f(A a) {
    a &lt;&lt; a;   // &lt;-- This matches
  }


The matcher cxxOperatorCallExpr(hasOverloadedOperatorName("&lt;&lt;"))
matches a &lt;&lt; a.
The matcher
cxxRecordDecl(hasMethod(hasOverloadedOperatorName("*")))
matches struct A { int operator*(); }.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasTrailingReturn0')"><a name="hasTrailingReturn0Anchor">hasTrailingReturn</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasTrailingReturn0"><pre>Matches a function declared with a trailing return type.

Given
int X() {}
auto Y() -&gt; int {}

The matcher functionDecl(hasTrailingReturn())
matches auto Y() -&gt; int {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isConsteval0')"><a name="isConsteval0Anchor">isConsteval</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConsteval0"><pre>Matches consteval function declarations and if consteval/if ! consteval
statements.

Given
  consteval int a();
  void b() { if consteval {} }
  void c() { if ! consteval {} }
  void d() { if ! consteval {} else {} }

The matcher functionDecl(isConsteval())
matches a.
The matcher ifStmt(isConsteval())
matches the if statements
if consteval {}, if ! consteval {} and
if ! consteval {} else {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isConstexpr1')"><a name="isConstexpr1Anchor">isConstexpr</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConstexpr1"><pre>Matches constexpr variable and function declarations,
       and if constexpr.

Given
  constexpr int foo = 42;
  constexpr int bar();
  void baz() { if constexpr(1 &gt; 0) {} }

The matcher varDecl(isConstexpr())
matches foo.
The matcher functionDecl(isConstexpr())
matches bar.
The matcher ifStmt(isConstexpr())
matches if constexpr(1 &gt; 0) {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isDefaulted0')"><a name="isDefaulted0Anchor">isDefaulted</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefaulted0"><pre>Matches defaulted function declarations.

Given
  class A { ~A(); };
  class B { ~B() = default; };

The matcher functionDecl(isDefaulted())
  matches ~B() = default,
but does not match ~A().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isDefinition3')"><a name="isDefinition3Anchor">isDefinition</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefinition3"><pre>Matches if a declaration has a body attached.

Example matches A, va, fa
  class A {};
  class B;  // Doesn't match, as it has no body.
  int va;
  extern int vb;  // Doesn't match, as it doesn't define the variable.
  void fa() {}
  void fb();  // Doesn't match, as it has no body.

The matcher tagDecl(isDefinition())
matches A
The matcher varDecl(isDefinition())
matches va
The matcher functionDecl(isDefinition())
matches fa

  @interface X
  - (void)ma; // Doesn't match, interface is declaration.
  @end
  @implementation X
  - (void)ma {}
  @end

The matcher objcMethodDecl(isDefinition())
matches - (void)ma {}

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isDeleted0')"><a name="isDeleted0Anchor">isDeleted</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDeleted0"><pre>Matches deleted function declarations.

Given
  void Func();
  void DeletedFunc() = delete;

The matcher functionDecl(isDeleted())
matches DeletedFunc,
but does not match Func.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isExplicitTemplateSpecialization0')"><a name="isExplicitTemplateSpecialization0Anchor">isExplicitTemplateSpecialization</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicitTemplateSpecialization0"><pre>Matches explicit template specializations of function, class, or
static member variable template instantiations.

Given
  template&lt;typename T&gt; void A(T t) { }
  template&lt;&gt; void A(int N) { }

The matcher functionDecl(isExplicitTemplateSpecialization())
  matches the specialization template&lt;&gt; void A(int N) { }.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isExternC0')"><a name="isExternC0Anchor">isExternC</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExternC0"><pre>Matches extern "C" function or variable declarations.

Given
  extern "C" void f() {}
  extern "C" { void g() {} }
  void h() {}
  extern "C" int x = 1;
  extern "C" int y = 2;
  int z = 3;

The matcher functionDecl(isExternC())
matches f
and g.
The matcher varDecl(isExternC())
matches x
and y,
but does not match z.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isInline1')"><a name="isInline1Anchor">isInline</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInline1"><pre>Matches functions, variables and namespace declarations that are marked with
the inline keyword.

Given
  inline void f();
  void g();
  namespace n {
  inline namespace m {}
  }
  inline int Foo = 5;

The matcher functionDecl(isInline()) matches f.
The matcher namespaceDecl(isInline()) matches m.
The matcher varDecl(isInline()) matches Foo
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isMain0')"><a name="isMain0Anchor">isMain</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isMain0"><pre>Determines whether the function is "main", which is the entry point
into an executable program.

Given
  void f();
  int main() {}

The matcher functionDecl(isMain()) matches int main() {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isNoReturn0')"><a name="isNoReturn0Anchor">isNoReturn</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isNoReturn0"><pre>Matches FunctionDecls that have a noreturn attribute.

Given
  void nope();
  [[noreturn]] void a();
  __attribute__((noreturn)) void b();
  struct c { [[noreturn]] c(); };

The matcher functionDecl(isNoReturn())
match a, b
and c
but do not match nope
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isNoThrow0')"><a name="isNoThrow0Anchor">isNoThrow</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isNoThrow0"><pre>Matches functions that have a non-throwing exception specification.

Given
  void f(int);
  void g(int) noexcept;
  void h(int) noexcept(false);
  void i(int) throw();
  void j(int) throw(int);

The matcher functionDecl(isNoThrow())
matches the declaration void g(int) noexcept
and void i(int) throw(),
but does not match void f(int),
void h(int) noexcept(false)
or void j(int) throw(int).
The matcher
functionProtoType(isNoThrow())
matches the type void (int) throw() of i
and the type void (int) noexcept of g,
but does not match
the type void (int) of f ,
the type void (int) noexcept(false) of h or
the type void (int) throw(int) of j .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isStaticStorageClass0')"><a name="isStaticStorageClass0Anchor">isStaticStorageClass</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isStaticStorageClass0"><pre>Matches variable/function declarations that have "static" storage
class specifier ("static" keyword) written in the source.

Given
  static void f() {}
  static int i = 0;
  extern int j;
  int k;
The matcher functionDecl(isStaticStorageClass())
  matches f
The matcher varDecl(isStaticStorageClass())
  matches i
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isTemplateInstantiation0')"><a name="isTemplateInstantiation0Anchor">isTemplateInstantiation</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isTemplateInstantiation0"><pre>Matches template instantiations of function, class, or static
member variable template instantiations.

Given
  template &lt;typename T&gt; class X {};
  class A {};
  X&lt;A&gt; x;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches class X&lt;class A&gt;.
  template &lt;typename T&gt; class X {};
  class A {};
  template class X&lt;A&gt;;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches template class X&lt;A&gt;
  template &lt;typename T&gt; class X {};
  class A {};
  extern template class X&lt;A&gt;;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches extern template class X&lt;A&gt;

But given
  template &lt;typename T&gt;  class X {};
  class A {};
  template &lt;&gt; class X&lt;A&gt; {};
  X&lt;A&gt; x;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
  does not match, as X&lt;A&gt; is an explicit template specialization.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isVariadic0')"><a name="isVariadic0Anchor">isVariadic</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isVariadic0"><pre>Matches if a function declaration is variadic.

Example matches f, but not g or h. The function i will not match, even when
compiled in C mode.
  void f(...);
  void g(int);
  template &lt;typename... Ts&gt; void h(Ts...);
  void i();

The matcher functionDecl(isVariadic())
matches void f(...),
but does not match void g(int),
template &lt;typename... Ts&gt; void h(Ts...),
or void i().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('isWeak0')"><a name="isWeak0Anchor">isWeak</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isWeak0"><pre>Matches weak function declarations.

Given
  static void f();
  void g() __attribute__((weak));
The matcher functionDecl(isWeak())
  matches the weak declaration
void g() __attribute__((weak)),
but does not match static void foo_v1().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('parameterCountIs0')"><a name="parameterCountIs0Anchor">parameterCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="parameterCountIs0"><pre>Matches FunctionDecls and FunctionProtoTypes that have a
specific parameter count.

Given
  void f(int i) {}
  void g(int i, int j) {}
  void h(int i, int j);
  void j(int i);
  void k(int x, int y, int z, ...);
The matcher functionDecl(parameterCountIs(2))
matches g and h
The matcher functionProtoType(parameterCountIs(1))
matches the type void (int) of f and j.
The matcher functionProtoType(parameterCountIs(3)) matches the
type void (int, int, int, ...) of k.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionProtoType.html">FunctionProtoType</a>&gt;</td><td class="name" onclick="toggle('hasDynamicExceptionSpec1')"><a name="hasDynamicExceptionSpec1Anchor">hasDynamicExceptionSpec</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasDynamicExceptionSpec1"><pre>Matches functions that have a dynamic exception specification.

Given
  void f(int);
  void g(int) noexcept;
  void h(int) noexcept(true);
  void i(int) noexcept(false);
  void j(int) throw();
  void k(int) throw(int);
  void l(int) throw(...);

The matcher functionDecl(hasDynamicExceptionSpec())
matches the declarations void j(int) throw(),
void k(int) throw(int)
and void l(int) throw(...),
but does not match void f(int), void g(int) noexcept,
void h(int) noexcept(true)
or void i(int) noexcept(true).
The matcher
functionProtoType(hasDynamicExceptionSpec()) matches
the type void (int) throw() of j ,
the type void (int) throw(int) of k and
the type void (int) throw(...) of l .
It does not match
the type void (int) noexcept of f ,
the type void (int) noexcept of g ,
the type void (int) noexcept(int) of h or
the type void (int) noexcept(...) of i .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionProtoType.html">FunctionProtoType</a>&gt;</td><td class="name" onclick="toggle('isNoThrow1')"><a name="isNoThrow1Anchor">isNoThrow</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isNoThrow1"><pre>Matches functions that have a non-throwing exception specification.

Given
  void f(int);
  void g(int) noexcept;
  void h(int) noexcept(false);
  void i(int) throw();
  void j(int) throw(int);

The matcher functionDecl(isNoThrow())
matches the declaration void g(int) noexcept
and void i(int) throw(),
but does not match void f(int),
void h(int) noexcept(false)
or void j(int) throw(int).
The matcher
functionProtoType(isNoThrow())
matches the type void (int) throw() of i
and the type void (int) noexcept of g,
but does not match
the type void (int) of f ,
the type void (int) noexcept(false) of h or
the type void (int) throw(int) of j .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionProtoType.html">FunctionProtoType</a>&gt;</td><td class="name" onclick="toggle('parameterCountIs1')"><a name="parameterCountIs1Anchor">parameterCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="parameterCountIs1"><pre>Matches FunctionDecls and FunctionProtoTypes that have a
specific parameter count.

Given
  void f(int i) {}
  void g(int i, int j) {}
  void h(int i, int j);
  void j(int i);
  void k(int x, int y, int z, ...);
The matcher functionDecl(parameterCountIs(2))
matches g and h
The matcher functionProtoType(parameterCountIs(1))
matches the type void (int) of f and j.
The matcher functionProtoType(parameterCountIs(3)) matches the
type void (int, int, int, ...) of k.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;</td><td class="name" onclick="toggle('isConsteval1')"><a name="isConsteval1Anchor">isConsteval</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConsteval1"><pre>Matches consteval function declarations and if consteval/if ! consteval
statements.

Given
  consteval int a();
  void b() { if consteval {} }
  void c() { if ! consteval {} }
  void d() { if ! consteval {} else {} }

The matcher functionDecl(isConsteval())
matches a.
The matcher ifStmt(isConsteval())
matches the if statements
if consteval {}, if ! consteval {} and
if ! consteval {} else {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;</td><td class="name" onclick="toggle('isConstexpr2')"><a name="isConstexpr2Anchor">isConstexpr</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConstexpr2"><pre>Matches constexpr variable and function declarations,
       and if constexpr.

Given
  constexpr int foo = 42;
  constexpr int bar();
  void baz() { if constexpr(1 &gt; 0) {} }

The matcher varDecl(isConstexpr())
matches foo.
The matcher functionDecl(isConstexpr())
matches bar.
The matcher ifStmt(isConstexpr())
matches if constexpr(1 &gt; 0) {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;</td><td class="name" onclick="toggle('equals6')"><a name="equals6Anchor">equals</a></td><td>bool Value</td></tr>
<tr><td colspan="4" class="doc" id="equals6"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;</td><td class="name" onclick="toggle('equals0')"><a name="equals0Anchor">equals</a></td><td>const ValueT  Value</td></tr>
<tr><td colspan="4" class="doc" id="equals0"><pre>Matches literals that are equal to the given value of type ValueT.

Given
void f(char, bool, double, int);
void foo() {
  f('false, 3.14, 42);
}

The matcher characterLiteral(equals(0U)) matches 'The matchers cxxBoolLiteral(equals(false)) and
cxxBoolLiteral(equals(0)) match false.
The matcher floatLiteral(equals(3.14)) matches 3.14.
The matcher integerLiteral(equals(42)) matches 42.

Note that you cannot directly match a negative numeric literal because the
minus sign is not part of the literal: It is a unary operator whose operand
is the positive numeric literal. Instead, you must use a unaryOperator()
matcher to match the minus sign:

Given
  int val = -1;

The matcher unaryOperator(hasOperatorName("-"),
              hasUnaryOperand(integerLiteral(equals(1))))
matches -1.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CharacterLiteral.html">CharacterLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>&gt;,
           Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FloatingLiteral.html">FloatingLiteral</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;</td><td class="name" onclick="toggle('equals13')"><a name="equals13Anchor">equals</a></td><td>double Value</td></tr>
<tr><td colspan="4" class="doc" id="equals13"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IntegerLiteral.html">IntegerLiteral</a>&gt;</td><td class="name" onclick="toggle('equals9')"><a name="equals9Anchor">equals</a></td><td>unsigned Value</td></tr>
<tr><td colspan="4" class="doc" id="equals9"><pre></pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt;</td><td class="name" onclick="toggle('capturesThis0')"><a name="capturesThis0Anchor">capturesThis</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="capturesThis0"><pre>Matches a `LambdaCapture` that refers to 'this'.

Given
class C {
  int cc;
  int f() {
    auto l = [this]() { return cc; };
    return l();
  }
};

The matcher
lambdaExpr(hasAnyCapture(lambdaCapture(capturesThis())))
matches [this]() { return cc; }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt;</td><td class="name" onclick="toggle('isImplicit2')"><a name="isImplicit2Anchor">isImplicit</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isImplicit2"><pre>Matches an entity that has been implicitly added by the compiler (e.g.
implicit default/copy constructors).

Given
  struct S {};
  void f(S obj) {
    S copy = obj;
    [&amp;](){ return copy; };
  }


The matcher cxxConstructorDecl(isImplicit(), isCopyConstructor())
matches the implicit copy constructor of S.
The matcher lambdaExpr(forEachLambdaCapture(
    lambdaCapture(isImplicit()))) matches [&amp;](){ return copy; },
because it implicitly captures copy .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;</td><td class="name" onclick="toggle('isArrow0')"><a name="isArrow0Anchor">isArrow</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isArrow0"><pre>Matches member expressions that are called with '-&gt;' as opposed
to '.'.

Member calls on the implicit this pointer match as called with '-&gt;'.

Given
  class Y {
    void x() { this-&gt;x(); x(); Y y; y.x(); a; this-&gt;b; Y::b; }
    template &lt;class T&gt; void f() { this-&gt;f&lt;T&gt;(); f&lt;T&gt;(); }
    int a;
    static int b;
  };
  template &lt;class T&gt;
  class Z {
    void x() {
      this-&gt;m;
      this-&gt;t;
      this-&gt;t-&gt;m;
    }
    int m;
    T* t;
  };

The matcher memberExpr(isArrow())
matches this-&gt;x, x, a,
this-&gt;b, this-&gt;m and two times this-&gt;t,
once for the standalone member expression, and once for the member
expression that later accesses m .
Additionally, it does not match this-&gt;t-&gt;t.
The matcher cxxDependentScopeMemberExpr(isArrow())
matches this-&gt;t-&gt;m, but not this-&gt;m or this-&gt;t.
The matcher unresolvedMemberExpr(isArrow())
matches this-&gt;f&lt;T&gt;, f&lt;T&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyName0')"><a name="hasAnyName0Anchor">hasAnyName</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyName0"><pre>Matches NamedDecl nodes that have any of the specified names.

This matcher is only provided as a performance optimization of hasName.

Given
  void f(int a, int b);

The matcher namedDecl(hasAnyName("a", "b")),
which is equivalent to the matcher
namedDecl(hasAnyName("a", "b")),
matches int a and int b, but not
void f(int a, int b).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt;</td><td class="name" onclick="toggle('hasExternalFormalLinkage0')"><a name="hasExternalFormalLinkage0Anchor">hasExternalFormalLinkage</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasExternalFormalLinkage0"><pre>Matches a declaration that has external formal linkage.

Given
void f() {
  int a;
  static int b;
}
int c;
static int d;
The matcher varDecl(hasExternalFormalLinkage())
matches int c,
but not int a, static int b or int d.

Given
  namespace {
    void f() {}
  }
  void g() {}
  static void h() {}


The matcher functionDecl(hasExternalFormalLinkage())
matches void g() {}, but not void f() {} or
static void h() {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt;</td><td class="name" onclick="toggle('hasName0')"><a name="hasName0Anchor">hasName</a></td><td>StringRef Name</td></tr>
<tr><td colspan="4" class="doc" id="hasName0"><pre>Matches NamedDecl nodes that have the specified name.

Supports specifying enclosing namespaces or classes by prefixing the name
with '&lt;enclosing&gt;::'.
Does not match typedefs of an underlying type with the given name.

Given
  class X;


The matcher namedDecl(hasName("X"))
matches class X.

Given
  namespace a { namespace b { class X; } }


The matchers namedDecl(hasName("::a::b::X")),
namedDecl(hasName("a::b::X")),
namedDecl(hasName("b::X")) and
namedDecl(hasName("X"))
match class X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt;</td><td class="name" onclick="toggle('matchesName0')"><a name="matchesName0Anchor">matchesName</a></td><td>StringRef RegExp, Regex::RegexFlags Flags = NoFlags</td></tr>
<tr><td colspan="4" class="doc" id="matchesName0"><pre>Matches NamedDecl nodes whose fully qualified names contain
a substring matched by the given RegExp.

Supports specifying enclosing namespaces or classes by
prefixing the name with '&lt;enclosing&gt;::'.  Does not match typedefs
of an underlying type with the given name.

Given
  namespace foo { namespace bar { class X; } }


The matcher namedDecl(matchesName("^::foo:.*X"))
matches class X.

If the matcher is used in clang-query, RegexFlags parameter
should be passed as a quoted string. e.g: "NoFlags".
Flags can be combined with '|' example "IgnoreCase | BasicRegex"
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamespaceDecl.html">NamespaceDecl</a>&gt;</td><td class="name" onclick="toggle('isAnonymous0')"><a name="isAnonymous0Anchor">isAnonymous</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isAnonymous0"><pre>Matches anonymous namespace declarations.

Given
  namespace n {
  namespace {} // #1
  }

The matcher namespaceDecl(isAnonymous())
matches namespace {}, but not namespace n.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamespaceDecl.html">NamespaceDecl</a>&gt;</td><td class="name" onclick="toggle('isInline0')"><a name="isInline0Anchor">isInline</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInline0"><pre>Matches functions, variables and namespace declarations that are marked with
the inline keyword.

Given
  inline void f();
  void g();
  namespace n {
  inline namespace m {}
  }
  inline int Foo = 5;

The matcher functionDecl(isInline()) matches f.
The matcher namespaceDecl(isInline()) matches m.
The matcher varDecl(isInline()) matches Foo
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&gt;</td><td class="name" onclick="toggle('isFirstPrivateKind0')"><a name="isFirstPrivateKind0Anchor">isFirstPrivateKind</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isFirstPrivateKind0"><pre>Matches if the OpenMP ``default`` clause has ``firstprivate`` kind
specified.

Given
  void foo() {
    #pragma omp parallel
      ;
    #pragma omp parallel default(none)
      ;
    #pragma omp parallel default(shared)
      ;
    #pragma omp parallel default(private)
      ;
    #pragma omp parallel default(firstprivate)
      ;
  }


The matcher
ompExecutableDirective(hasAnyClause(ompDefaultClause(isFirstPrivateKind())))
matches #pragma omp parallel default(firstprivate).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&gt;</td><td class="name" onclick="toggle('isNoneKind0')"><a name="isNoneKind0Anchor">isNoneKind</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isNoneKind0"><pre>Matches if the OpenMP ``default`` clause has ``none`` kind specified.

Given
  void foo() {
    #pragma omp parallel
      ;
    #pragma omp parallel default(none)
      ;
    #pragma omp parallel default(shared)
      ;
    #pragma omp parallel default(private)
      ;
    #pragma omp parallel default(firstprivate)
      ;
  }


The matcher
ompExecutableDirective(hasAnyClause(ompDefaultClause(isNoneKind())))
matches only #pragma omp parallel default(none).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&gt;</td><td class="name" onclick="toggle('isPrivateKind0')"><a name="isPrivateKind0Anchor">isPrivateKind</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isPrivateKind0"><pre>Matches if the OpenMP ``default`` clause has ``private`` kind
specified.

Given
  void foo() {
    #pragma omp parallel
      ;
  #pragma omp parallel default(none)
      ;
  #pragma omp parallel default(shared)
      ;
  #pragma omp parallel default(private)
      ;
  #pragma omp parallel default(firstprivate)
      ;
  }


The matcher
ompExecutableDirective(hasAnyClause(ompDefaultClause(isPrivateKind())))
matches #pragma omp parallel default(private).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&gt;</td><td class="name" onclick="toggle('isSharedKind0')"><a name="isSharedKind0Anchor">isSharedKind</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isSharedKind0"><pre>Matches if the OpenMP ``default`` clause has ``shared`` kind specified.

Given
  void foo() {
    #pragma omp parallel
      ;
    #pragma omp parallel default(none)
      ;
  #pragma omp parallel default(shared)
      ;
  #pragma omp parallel default(private)
      ;
  #pragma omp parallel default(firstprivate)
      ;
  }


The matcher
ompExecutableDirective(hasAnyClause(ompDefaultClause(isSharedKind())))
matches #pragma omp parallel default(shared).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&gt;</td><td class="name" onclick="toggle('isAllowedToContainClauseKind0')"><a name="isAllowedToContainClauseKind0Anchor">isAllowedToContainClauseKind</a></td><td>OpenMPClauseKind CKind</td></tr>
<tr><td colspan="4" class="doc" id="isAllowedToContainClauseKind0"><pre>Matches if the OpenMP directive is allowed to contain the specified OpenMP
clause kind.

Given
  void foo() {
    #pragma omp parallel
      ;
    #pragma omp parallel for
      for (int i = 0; i &lt; 10; ++i) {}
    #pragma omp          for
      for (int i = 0; i &lt; 10; ++i) {}
  }


The matcher
ompExecutableDirective(isAllowedToContainClauseKind(
OpenMPClauseKind::OMPC_default))
matches #pragma omp parallel
and #pragma omp parallel for.

If the matcher is use from clang-query, ``OpenMPClauseKind`` parameter
should be passed as a quoted string. e.g.,
``isAllowedToContainClauseKind("OMPC_default").``
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&gt;</td><td class="name" onclick="toggle('isStandaloneDirective0')"><a name="isStandaloneDirective0Anchor">isStandaloneDirective</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isStandaloneDirective0"><pre>Matches standalone OpenMP directives,
i.e., directives that can't have a structured block.

Given
  void foo() {
    #pragma omp parallel
    {
      #pragma omp taskyield
    }
  }


The matcher ompExecutableDirective(isStandaloneDirective())
matches #pragma omp taskyield.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;</td><td class="name" onclick="toggle('isDerivedFrom3')"><a name="isDerivedFrom3Anchor">isDerivedFrom</a></td><td>std::string BaseName</td></tr>
<tr><td colspan="4" class="doc" id="isDerivedFrom3"><pre>Overloaded method as shortcut for isDerivedFrom(hasName(...)).

Matches C++ classes that are directly or indirectly derived from a class
matching Base, or Objective-C classes that directly or indirectly
subclass a class matching Base.

Note that a class is not considered to be derived from itself.

Example matches Y, Z, C (Base == hasName("X"))
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

  class Foo {};
  typedef Foo Alias;
  class Bar : public Alias {};  // derived from Alias, which is a
                                // typedef of Foo


The matcher cxxRecordDecl(isDerivedFrom("X"))
matches Y, Z and C.
The matcher cxxRecordDecl(isDerivedFrom("Foo"))
matches Bar.

In the following example, Bar matches isDerivedFrom(hasName("NSObject"))
  @interface NSObject @end
  @interface Bar : NSObject @end


Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;</td><td class="name" onclick="toggle('isDirectlyDerivedFrom3')"><a name="isDirectlyDerivedFrom3Anchor">isDirectlyDerivedFrom</a></td><td>std::string BaseName</td></tr>
<tr><td colspan="4" class="doc" id="isDirectlyDerivedFrom3"><pre>Overloaded method as shortcut for isDirectlyDerivedFrom(hasName(...)).

Given
  struct Base {};
  struct DirectlyDerived : public Base {};
  struct IndirectlyDerived : public DirectlyDerived {};


The matcher cxxRecordDecl(isDirectlyDerivedFrom("Base"))
matches DirectlyDerived, but not
IndirectlyDerived.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;</td><td class="name" onclick="toggle('isSameOrDerivedFrom3')"><a name="isSameOrDerivedFrom3Anchor">isSameOrDerivedFrom</a></td><td>std::string BaseName</td></tr>
<tr><td colspan="4" class="doc" id="isSameOrDerivedFrom3"><pre>Similar to isDerivedFrom(), but also matches classes that directly
match Base.
Overloaded method as shortcut for
isSameOrDerivedFrom(hasName(...)).

Given
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

The matcher
cxxRecordDecl(isSameOrDerivedFrom("X"), isDefinition())
matches class X {}, class Y : public X {},
class Z : public Y {} and class C : public B {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountAtLeast3')"><a name="argumentCountAtLeast3Anchor">argumentCountAtLeast</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountAtLeast3"><pre>Checks that a call expression or a constructor call expression has at least
the specified number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void g(int x, int y, int z);
  void foo() {
    f(0, 0);
    g(0, 0, 0);
  }
The matcher callExpr(argumentCountAtLeast(2))
matches f(0, 0) and g(0, 0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('argumentCountIs3')"><a name="argumentCountIs3Anchor">argumentCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="argumentCountIs3"><pre>Checks that a call expression or a constructor call expression has
a specific number of arguments (including absent default arguments).

Given
  void f(int x, int y);
  void foo() {
    f(0, 0);
  }
The matcher callExpr(argumentCountIs(2))
matches f(0, 0)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnySelector0')"><a name="hasAnySelector0Anchor">hasAnySelector</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnySelector0"><pre>Matches when at least one of the supplied string equals to the
Selector.getAsString()

    [myObj methodA:argA];
    [myObj methodB:argB];

 The matcher objCMessageExpr(hasSelector("methodA:", "methodB:"));
 matches [myObj methodA:argA]; and [myObj methodB:argB];
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasKeywordSelector0')"><a name="hasKeywordSelector0Anchor">hasKeywordSelector</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasKeywordSelector0"><pre>Matches when the selector is a keyword selector

Given
  UIWebView *webView = ...;
  CGRect bodyFrame = webView.frame;
  bodyFrame.size.height = self.bodyContentHeight;
  webView.frame = bodyFrame;
  //     ^---- matches here


The matcher objCMessageExpr(hasKeywordSelector()) matches the
generated setFrame message expression in
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasNullSelector0')"><a name="hasNullSelector0Anchor">hasNullSelector</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasNullSelector0"><pre>Matches when the selector is the empty selector

Matches only when the selector of the objCMessageExpr is NULL. This may
represent an error condition in the tree!
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasSelector0')"><a name="hasSelector0Anchor">hasSelector</a></td><td>std::string BaseName</td></tr>
<tr><td colspan="4" class="doc" id="hasSelector0"><pre>Matches when BaseName == Selector.getAsString()

    [self.bodyView loadHTMLString:html baseURL:NULL];

The matcher
objCMessageExpr(hasSelector("loadHTMLString:baseURL:")); matches
the outer message expr in the code below, but NOT the message invocation
for self.bodyView.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasUnarySelector0')"><a name="hasUnarySelector0Anchor">hasUnarySelector</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasUnarySelector0"><pre>Matches when the selector is a Unary Selector

Given
    [self.bodyView loadHTMLString:html baseURL:NULL];


 The matcher objCMessageExpr(matchesSelector(hasUnarySelector());
 matches self.bodyView, but does not match the outer message
 invocation of "loadHTMLString:baseURL:".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('isClassMessage0')"><a name="isClassMessage0Anchor">isClassMessage</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isClassMessage0"><pre>Returns true when the Objective-C message is sent to a class.

Given
  [NSString stringWithFormat:@"format"];
  NSString *x = @"hello";
  [x containsString:@"h"];

The matcher objcMessageExpr(isClassMessage())
matches [NSString stringWithFormat:@"format"];
but does not match [[x containsString:@"h"]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('isInstanceMessage0')"><a name="isInstanceMessage0Anchor">isInstanceMessage</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInstanceMessage0"><pre>Returns true when the Objective-C message is sent to an instance.

Given
  NSString *x = @"hello";
  [x containsString:@"h"];
  [NSString stringWithFormat:@"format"];

The matcher objcMessageExpr(isInstanceMessage())
matches [x containsString:@"h"];
but does not match [NSString stringWithFormat:@"format"];
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('matchesSelector0')"><a name="matchesSelector0Anchor">matchesSelector</a></td><td>StringRef RegExp, Regex::RegexFlags Flags = NoFlags</td></tr>
<tr><td colspan="4" class="doc" id="matchesSelector0"><pre>Matches ObjC selectors whose name contains
a substring matched by the given RegExp.

Given
    [self.bodyView loadHTMLString:html baseURL:NULL];


The matcher
objCMessageExpr(matchesSelector("loadHTMLStringmatches the outer message expr in the code below, but NOT the message
invocation for self.bodyView.

If the matcher is used in clang-query, RegexFlags parameter
should be passed as a quoted string. e.g: "NoFlags".
Flags can be combined with '|' example "IgnoreCase | BasicRegex"
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('numSelectorArgs0')"><a name="numSelectorArgs0Anchor">numSelectorArgs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="numSelectorArgs0"><pre>Matches when the selector has the specified number of arguments

    [self.bodyView loadHTMLString:html baseURL:NULL];

The matcher objCMessageExpr(numSelectorArgs(0))
matches self.bodyView.
The matcher objCMessageExpr(numSelectorArgs(2))
matches the invocation of loadHTMLString:baseURL:
but does not match self.bodyView
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isClassMethod0')"><a name="isClassMethod0Anchor">isClassMethod</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isClassMethod0"><pre>Returns true when the Objective-C method declaration is a class method.

Given
@interface I + (void)foo; @end
@interface I - (void)bar; @end

The matcher objcMethodDecl(isClassMethod())
matches @interface I + (void)foo; @end
but does not match interface I + (void)foo; @end
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isDefinition2')"><a name="isDefinition2Anchor">isDefinition</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefinition2"><pre>Matches if a declaration has a body attached.

Example matches A, va, fa
  class A {};
  class B;  // Doesn't match, as it has no body.
  int va;
  extern int vb;  // Doesn't match, as it doesn't define the variable.
  void fa() {}
  void fb();  // Doesn't match, as it has no body.

The matcher tagDecl(isDefinition())
matches A
The matcher varDecl(isDefinition())
matches va
The matcher functionDecl(isDefinition())
matches fa

  @interface X
  - (void)ma; // Doesn't match, interface is declaration.
  @end
  @implementation X
  - (void)ma {}
  @end

The matcher objcMethodDecl(isDefinition())
matches - (void)ma {}

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;</td><td class="name" onclick="toggle('isInstanceMethod0')"><a name="isInstanceMethod0Anchor">isInstanceMethod</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInstanceMethod0"><pre>Returns true when the Objective-C method declaration is an instance method.

Given
@interface I - (void)bar; @end
@interface I + (void)foo; @end

The matcher objcMethodDecl(isInstanceMethod())
matches @interface I - (void)bar; @end
but does not match @interface I - (void)foo; @end

</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt;</td><td class="name" onclick="toggle('hasDefaultArgument0')"><a name="hasDefaultArgument0Anchor">hasDefaultArgument</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasDefaultArgument0"><pre>Matches a declaration that has default arguments.

Given
  void x(int val) {}
  void y(int val = 0) {}


The matcher parmVarDecl(hasDefaultArgument())
matches int val = 0.

Deprecated. Use hasInitializer() instead to be able to
match on the contents of the default argument.  For example:

Given
  void x(int val = 7) {}
  void y(int val = 42) {}


The matcher
parmVarDecl(hasInitializer(integerLiteral(equals(42)))),
matches int val = 42.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt;</td><td class="name" onclick="toggle('isAtPosition0')"><a name="isAtPosition0Anchor">isAtPosition</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="isAtPosition0"><pre>Matches the ParmVarDecl nodes that are at the N'th position in the parameter
list. The parameter list could be that of either a block, function, or
objc-method.


Given

void f(int a, int b, int c) {
}

The matcher parmVarDecl(isAtPosition(0)) matches
a. The matcher parmVarDecl(isAtPosition(1))
matches b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('asString0')"><a name="asString0Anchor">asString</a></td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="asString0"><pre>Matches if the matched type is represented by the given string.

Given
  class Y { public: void x(); };
  void z() { Y* y; y-&gt;x(); }

The matcher cxxMemberCallExpr(on(hasType(asString("Y *"))))
matches y-&gt;x()
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('equalsBoundNode3')"><a name="equalsBoundNode3Anchor">equalsBoundNode</a></td><td>std::string ID</td></tr>
<tr><td colspan="4" class="doc" id="equalsBoundNode3"><pre>Matches if a node equals a previously bound node.

Matches a node if it equals the node previously bound to ID.

Given
  class X { int a; int b; };

The matcher cxxRecordDecl(
    has(fieldDecl(hasName("a"), hasType(type().bind("t")))),
    has(fieldDecl(hasName("b"), hasType(type(equalsBoundNode("t"))))))
  matches X, as a and b have the same type.

Note that when multiple matches are involved via forEach* matchers,
equalsBoundNodes acts as a filter.
For example:
compoundStmt(
    forEachDescendant(varDecl().bind("d")),
    forEachDescendant(declRefExpr(to(decl(equalsBoundNode("d"))))))
will trigger a match for each combination of variable declaration
and reference to that variable declaration within a compound statement.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('hasLocalQualifiers0')"><a name="hasLocalQualifiers0Anchor">hasLocalQualifiers</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasLocalQualifiers0"><pre>Matches QualType nodes that have local CV-qualifiers attached to
the node, not hidden within a typedef.

Given
  typedef const int const_int;
  const_int i = 0;
  int *const j = nullptr;
  int *volatile k;
  int m;


The matcher varDecl(hasType(hasLocalQualifiers())) matches only
j and k. is
const-qualified but the qualifier is not local.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('isAnyCharacter0')"><a name="isAnyCharacter0Anchor">isAnyCharacter</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isAnyCharacter0"><pre>Matches QualType nodes that are of character type.

Given
  void a(char);
  void b(wchar_t);
  void c(double);


The matcher
functionDecl(hasAnyParameter(hasType(isAnyCharacter())))
a, b, but not </pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('isAnyPointer0')"><a name="isAnyPointer0Anchor">isAnyPointer</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isAnyPointer0"><pre>Matches QualType nodes that are of any pointer type; this includes
the Objective-C object pointer type, which is different despite being
syntactically similar.

Given
  int *i = nullptr;

  @interface Foo
  @end
  Foo *f;

  int j;

The matcher varDecl(hasType(isAnyPointer()))
int *i and Foo *f, but not int j.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('isConstQualified0')"><a name="isConstQualified0Anchor">isConstQualified</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConstQualified0"><pre>Matches QualType nodes that are const-qualified, i.e., that
include "top-level" const.

Given
  void a(int);
  void b(int const);
  void c(const int);
  void d(const int*);
  void e(int const) {};
The matcher
functionDecl(hasAnyParameter(hasType(isConstQualified())))
  matches b, c and
  e.
  It does not match as there
  is no top-level const on the parameter type "const int *".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('isInteger0')"><a name="isInteger0Anchor">isInteger</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInteger0"><pre>Matches QualType nodes that are of integer type.

Given
  void a(int);
  void b(long);
  void c(double);
The matcher functionDecl(hasAnyParameter(hasType(isInteger())))
a, b, but not c.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('isSignedInteger0')"><a name="isSignedInteger0Anchor">isSignedInteger</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isSignedInteger0"><pre>Matches QualType nodes that are of signed integer type.

Given
  void a(int);
  void b(unsigned long);
  void c(double);
The matcher
functionDecl(hasAnyParameter(hasType(isSignedInteger()))) matches
a, but not and not
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('isUnsignedInteger0')"><a name="isUnsignedInteger0Anchor">isUnsignedInteger</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isUnsignedInteger0"><pre>Matches QualType nodes that are of unsigned integer type.

Given
  void a(int);
  void b(unsigned long);
  void c(double);
The matcher
functionDecl(hasAnyParameter(hasType(isUnsignedInteger())))
matches b,
but does not match a and c.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('isVolatileQualified0')"><a name="isVolatileQualified0Anchor">isVolatileQualified</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isVolatileQualified0"><pre>Matches QualType nodes that are volatile-qualified, i.e., that
include "top-level" volatile.

Given
  void a(int);
  void b(int volatile);
  void c(volatile int);
  void d(volatile int*);
  void e(int volatile) {};
The matcher
functionDecl(hasAnyParameter(hasType(isVolatileQualified())))
  matches b, c and
  e.
  It does not match as there
  is no top-level volatile on the parameter type "volatile int *".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('equalsBoundNode0')"><a name="equalsBoundNode0Anchor">equalsBoundNode</a></td><td>std::string ID</td></tr>
<tr><td colspan="4" class="doc" id="equalsBoundNode0"><pre>Matches if a node equals a previously bound node.

Matches a node if it equals the node previously bound to ID.

Given
  class X { int a; int b; };

The matcher cxxRecordDecl(
    has(fieldDecl(hasName("a"), hasType(type().bind("t")))),
    has(fieldDecl(hasName("b"), hasType(type(equalsBoundNode("t"))))))
  matches X, as a and b have the same type.

Note that when multiple matches are involved via forEach* matchers,
equalsBoundNodes acts as a filter.
For example:
compoundStmt(
    forEachDescendant(varDecl().bind("d")),
    forEachDescendant(declRefExpr(to(decl(equalsBoundNode("d"))))))
will trigger a match for each combination of variable declaration
and reference to that variable declaration within a compound statement.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('equalsNode1')"><a name="equalsNode1Anchor">equalsNode</a></td><td>const Stmt * Other</td></tr>
<tr><td colspan="4" class="doc" id="equalsNode1"><pre>Matches if a node equals another node.

Stmt has pointer identity in the AST.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('isExpandedFromMacro1')"><a name="isExpandedFromMacro1Anchor">isExpandedFromMacro</a></td><td>std::string MacroName</td></tr>
<tr><td colspan="4" class="doc" id="isExpandedFromMacro1"><pre>Matches statements that are (transitively) expanded from the named macro.
Does not match if only part of the statement is expanded from that macro or
if different parts of the statement are expanded from different
appearances of the macro.

Given
  #define A 0
  #define B A
  int c = B;

The matcher integerLiteral(isExpandedFromMacro("A"))
matches the literal expanded at the initializer B of the variable
c .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('isExpansionInFileMatching1')"><a name="isExpansionInFileMatching1Anchor">isExpansionInFileMatching</a></td><td>StringRef RegExp, Regex::RegexFlags Flags = NoFlags</td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInFileMatching1"><pre>Matches AST nodes that were expanded within files whose name is
partially matching a given regex.

Given the headers Y.h
  #pragma once
  typedef int my_y_int;
and X.h
  #pragma once
  typedef int my_x_int;
and the source code
  #include "X.h"
  #include "Y.h"
  typedef int my_main_file_int;
  my_main_file_int a = 0;
  my_x_int b = 1;
  my_y_int c = 2;

The matcher
typedefDecl(isExpansionInFileMatching("Y.h"))
matches typedef int my_y_int,
but does not match typedef int my_main_file_int or
typedef int my_x_int.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;

If the matcher is used in clang-query, RegexFlags parameter
should be passed as a quoted string. e.g: "NoFlags".
Flags can be combined with '|' example "IgnoreCase | BasicRegex"
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('isExpansionInMainFile1')"><a name="isExpansionInMainFile1Anchor">isExpansionInMainFile</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInMainFile1"><pre>Matches AST nodes that were expanded within the main-file.

Given the header Y.h
  #pragma once
  typedef int my_header_int;
and the source file
  #include "Y.h"
  typedef int my_main_file_int;
  my_main_file_int a = 0;
  my_header_int b = 1;

The matcher typedefDecl(isExpansionInMainFile())
matches typedef int my_main_file_int,
but does not match typedef int my_header_int.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('isExpansionInSystemHeader1')"><a name="isExpansionInSystemHeader1Anchor">isExpansionInSystemHeader</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInSystemHeader1"><pre>Matches AST nodes that were expanded within system-header-files.

Given the header SystemHeader.h
  #pragma once
  int header();
and the source code
  #include &lt;SystemHeader.h&gt;
  static int main_file();


The matcher functionDecl(isExpansionInSystemHeader())
matches int header(),
but does not match static int main_file().

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('isInTemplateInstantiation0')"><a name="isInTemplateInstantiation0Anchor">isInTemplateInstantiation</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInTemplateInstantiation0"><pre>Matches statements inside of a template instantiation.

Given
  int j;
  template&lt;typename T&gt; void A(T t) { T i; }
  void foo() {
    A(0);
    A(0U);
  }

The matcher declStmt(isInTemplateInstantiation())
matches T i; twice, once for int and once for
int}.
The matcher declStmt(unless(isInTemplateInstantiation())) will
match T i; once inside the template definition, but not for any of
the instantiated bodies.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1StringLiteral.html">StringLiteral</a>&gt;</td><td class="name" onclick="toggle('hasSize1')"><a name="hasSize1Anchor">hasSize</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="hasSize1"><pre>Matches nodes that have the specified size.

Given
  int a[42];
  int b[2 * 21];
  int c[41], d[43];
  char *s = "abcd";
  wchar_t *ws = L"abcd";
  char *w = "a";

The matcher constantArrayType(hasSize(42))
matches int[42] twice.
The matcher stringLiteral(hasSize(4))
matches "abcd" and L"abcd".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;</td><td class="name" onclick="toggle('isClass0')"><a name="isClass0Anchor">isClass</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isClass0"><pre>Matches TagDecl object that are spelled with "class."

Given
  struct S {};
  class C {};
  union U {};
  enum E { Ok };

The matcher tagDecl(isClass())
matches class C,
but does not match struct S,
union U
or enum E.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;</td><td class="name" onclick="toggle('isDefinition0')"><a name="isDefinition0Anchor">isDefinition</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefinition0"><pre>Matches if a declaration has a body attached.

Example matches A, va, fa
  class A {};
  class B;  // Doesn't match, as it has no body.
  int va;
  extern int vb;  // Doesn't match, as it doesn't define the variable.
  void fa() {}
  void fb();  // Doesn't match, as it has no body.

The matcher tagDecl(isDefinition())
matches A
The matcher varDecl(isDefinition())
matches va
The matcher functionDecl(isDefinition())
matches fa

  @interface X
  - (void)ma; // Doesn't match, interface is declaration.
  @end
  @implementation X
  - (void)ma {}
  @end

The matcher objcMethodDecl(isDefinition())
matches - (void)ma {}

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;</td><td class="name" onclick="toggle('isEnum0')"><a name="isEnum0Anchor">isEnum</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isEnum0"><pre>Matches TagDecl object that are spelled with "enum."

Given
  struct S {};
  class C {};
  union U {};
  enum E { Ok };

The matcher tagDecl(isEnum())
matches enum E { Ok },
but does not match struct S {},
class C {} or union U {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;</td><td class="name" onclick="toggle('isStruct0')"><a name="isStruct0Anchor">isStruct</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isStruct0"><pre>Matches TagDecl object that are spelled with "struct."

Example matches S, but not C, U or E.
  struct S {};
  class C {};
  union U {};
  enum E { Ok };

The matcher tagDecl(isStruct())
matches struct S,
but does not match class C,
union U
or enum E.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;</td><td class="name" onclick="toggle('isUnion0')"><a name="isUnion0Anchor">isUnion</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isUnion0"><pre>Matches TagDecl object that are spelled with "union."

Given
  struct S {};
  class C {};
  union U {};
  enum E { Ok };

The matcher tagDecl(isUnion())
matches union U,
does not match struct S,
class C
or enum E.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('equalsIntegralValue0')"><a name="equalsIntegralValue0Anchor">equalsIntegralValue</a></td><td>std::string Value</td></tr>
<tr><td colspan="4" class="doc" id="equalsIntegralValue0"><pre>Matches a TemplateArgument of integral type with a given value.

Note that 'Value' is a string as the template argument's value is
an arbitrary precision integer. 'Value' must be euqal to the canonical
representation of that integral value in base 10.

Given
  template&lt;int T&gt; struct C {};
  C&lt;42&gt; c;

The matcher classTemplateSpecializationDecl(
  hasAnyTemplateArgument(equalsIntegralValue("42")))
matches the implicitly declared specialization
struct C&lt;42&gt; from the instantiation for the type of the
variable c .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('isIntegral0')"><a name="isIntegral0Anchor">isIntegral</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isIntegral0"><pre>Matches a TemplateArgument that is an integral value.

Given
  template&lt;int T&gt; struct C {};
  C&lt;42&gt; c;

The matcher classTemplateSpecializationDecl(
  hasAnyTemplateArgument(isIntegral()))
matches the implicitly declared specialization
struct C&lt;42&gt; from the instantiation for the type of the
variable c .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;</td><td class="name" onclick="toggle('templateArgumentCountIs1')"><a name="templateArgumentCountIs1Anchor">templateArgumentCountIs</a></td><td>unsigned N</td></tr>
<tr><td colspan="4" class="doc" id="templateArgumentCountIs1"><pre>Matches if the number of template arguments equals N.

Given
  template&lt;typename T&gt; struct C {};
  C&lt;int&gt; c;

The matcher
classTemplateSpecializationDecl(templateArgumentCountIs(1))
matches struct C&lt;int&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('isExpandedFromMacro2')"><a name="isExpandedFromMacro2Anchor">isExpandedFromMacro</a></td><td>std::string MacroName</td></tr>
<tr><td colspan="4" class="doc" id="isExpandedFromMacro2"><pre>Matches statements that are (transitively) expanded from the named macro.
Does not match if only part of the statement is expanded from that macro or
if different parts of the statement are expanded from different
appearances of the macro.

Given
  #define A 0
  #define B A
  int c = B;

The matcher integerLiteral(isExpandedFromMacro("A"))
matches the literal expanded at the initializer B of the variable
c .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('isExpansionInFileMatching2')"><a name="isExpansionInFileMatching2Anchor">isExpansionInFileMatching</a></td><td>StringRef RegExp, Regex::RegexFlags Flags = NoFlags</td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInFileMatching2"><pre>Matches AST nodes that were expanded within files whose name is
partially matching a given regex.

Given the headers Y.h
  #pragma once
  typedef int my_y_int;
and X.h
  #pragma once
  typedef int my_x_int;
and the source code
  #include "X.h"
  #include "Y.h"
  typedef int my_main_file_int;
  my_main_file_int a = 0;
  my_x_int b = 1;
  my_y_int c = 2;

The matcher
typedefDecl(isExpansionInFileMatching("Y.h"))
matches typedef int my_y_int,
but does not match typedef int my_main_file_int or
typedef int my_x_int.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;

If the matcher is used in clang-query, RegexFlags parameter
should be passed as a quoted string. e.g: "NoFlags".
Flags can be combined with '|' example "IgnoreCase | BasicRegex"
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('isExpansionInMainFile2')"><a name="isExpansionInMainFile2Anchor">isExpansionInMainFile</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInMainFile2"><pre>Matches AST nodes that were expanded within the main-file.

Given the header Y.h
  #pragma once
  typedef int my_header_int;
and the source file
  #include "Y.h"
  typedef int my_main_file_int;
  my_main_file_int a = 0;
  my_header_int b = 1;

The matcher typedefDecl(isExpansionInMainFile())
matches typedef int my_main_file_int,
but does not match typedef int my_header_int.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('isExpansionInSystemHeader2')"><a name="isExpansionInSystemHeader2Anchor">isExpansionInSystemHeader</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExpansionInSystemHeader2"><pre>Matches AST nodes that were expanded within system-header-files.

Given the header SystemHeader.h
  #pragma once
  int header();
and the source code
  #include &lt;SystemHeader.h&gt;
  static int main_file();


The matcher functionDecl(isExpansionInSystemHeader())
matches int header(),
but does not match static int main_file().

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('booleanType0')"><a name="booleanType0Anchor">booleanType</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="booleanType0"><pre>Matches type bool.

Given
 struct S { bool func(); };

The matcher functionDecl(returns(booleanType()))
func
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('equalsBoundNode2')"><a name="equalsBoundNode2Anchor">equalsBoundNode</a></td><td>std::string ID</td></tr>
<tr><td colspan="4" class="doc" id="equalsBoundNode2"><pre>Matches if a node equals a previously bound node.

Matches a node if it equals the node previously bound to ID.

Given
  class X { int a; int b; };

The matcher cxxRecordDecl(
    has(fieldDecl(hasName("a"), hasType(type().bind("t")))),
    has(fieldDecl(hasName("b"), hasType(type(equalsBoundNode("t"))))))
  matches X, as a and b have the same type.

Note that when multiple matches are involved via forEach* matchers,
equalsBoundNodes acts as a filter.
For example:
compoundStmt(
    forEachDescendant(varDecl().bind("d")),
    forEachDescendant(declRefExpr(to(decl(equalsBoundNode("d"))))))
will trigger a match for each combination of variable declaration
and reference to that variable declaration within a compound statement.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('equalsNode2')"><a name="equalsNode2Anchor">equalsNode</a></td><td>const Type * Other</td></tr>
<tr><td colspan="4" class="doc" id="equalsNode2"><pre>Matches if a node equals another node.

Type has pointer identity in the AST.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('realFloatingPointType0')"><a name="realFloatingPointType0Anchor">realFloatingPointType</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="realFloatingPointType0"><pre>Matches any real floating-point type (float, double, long double).

Given
  int i;
  float f;
The matcher type(realFloatingPointType())
matches float
but does not match int.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('voidType0')"><a name="voidType0Anchor">voidType</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="voidType0"><pre>Matches type void.

Given
 struct S { void func(); };


The matcher functionDecl(returns(voidType()))
func
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>&gt;</td><td class="name" onclick="toggle('ofKind0')"><a name="ofKind0Anchor">ofKind</a></td><td>UnaryExprOrTypeTrait Kind</td></tr>
<tr><td colspan="4" class="doc" id="ofKind0"><pre>Matches unary expressions of a certain kind.

Given
  int x;
  int s = sizeof(x) + alignof(x);

The matcher unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))
matches sizeof(x)

If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter
should be passed as a quoted string. e.g., ofKind("UETT_SizeOf").
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryOperator.html">UnaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasAnyOperatorName3')"><a name="hasAnyOperatorName3Anchor">hasAnyOperatorName</a></td><td>StringRef, ..., StringRef</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyOperatorName3"><pre>Matches operator expressions (binary or unary) that have any of the
specified names.

It provides a compact way of writing if an operator has any of the specified
names:
The matcher
   hasAnyOperatorName("+", "-")
Is equivalent to
   hasOperatorName("-"))}

Given
void foo(bool a, bool b) {
  !(a || b);
 }

void bar(bool a, bool b) {
  a &amp;&amp; b;
 }

The matcher binaryOperator(hasAnyOperatorName("||", "&amp;&amp;"))
matches a || b and a &amp;&amp; b.
The matcher unaryOperator(hasAnyOperatorName("-", "!"))
matches !(a || b).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryOperator.html">UnaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasOperatorName4')"><a name="hasOperatorName4Anchor">hasOperatorName</a></td><td>std::string Name</td></tr>
<tr><td colspan="4" class="doc" id="hasOperatorName4"><pre>Matches the operator Name of operator expressions and fold expressions
(binary or unary).

Given
void foo(bool a, bool b) {
  !(a || b);
 }

The matcher binaryOperator(hasOperatorName("||"))
matches a || b

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

The matcher cxxFoldExpr(hasOperatorName("+"))
 matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a>&gt;</td><td class="name" onclick="toggle('isArrow1')"><a name="isArrow1Anchor">isArrow</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isArrow1"><pre>Matches member expressions that are called with '-&gt;' as opposed
to '.'.

Member calls on the implicit this pointer match as called with '-&gt;'.

Given
  class Y {
    void x() { this-&gt;x(); x(); Y y; y.x(); a; this-&gt;b; Y::b; }
    template &lt;class T&gt; void f() { this-&gt;f&lt;T&gt;(); f&lt;T&gt;(); }
    int a;
    static int b;
  };
  template &lt;class T&gt;
  class Z {
    void x() {
      this-&gt;m;
      this-&gt;t;
      this-&gt;t-&gt;m;
    }
    int m;
    T* t;
  };

The matcher memberExpr(isArrow())
matches this-&gt;x, x, a,
this-&gt;b, this-&gt;m and two times this-&gt;t,
once for the standalone member expression, and once for the member
expression that later accesses m .
Additionally, it does not match this-&gt;t-&gt;t.
The matcher cxxDependentScopeMemberExpr(isArrow())
matches this-&gt;t-&gt;m, but not this-&gt;m or this-&gt;t.
The matcher unresolvedMemberExpr(isArrow())
matches this-&gt;f&lt;T&gt;, f&lt;T&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('hasAutomaticStorageDuration0')"><a name="hasAutomaticStorageDuration0Anchor">hasAutomaticStorageDuration</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasAutomaticStorageDuration0"><pre>Matches a variable declaration that has automatic storage duration.

Given
void f() {
  int x;
  static int y;
  thread_local int z;
}
int a;

The matcher varDecl(hasAutomaticStorageDuration())
matches x
but does not match y, z or
a
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('hasGlobalStorage0')"><a name="hasGlobalStorage0Anchor">hasGlobalStorage</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasGlobalStorage0"><pre>Matches a variable declaration that does not have local storage.

Given
void f() {
  int x;
  static int y;
}
int z;
The matcher varDecl(hasGlobalStorage())
matches y and z
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('hasLocalStorage0')"><a name="hasLocalStorage0Anchor">hasLocalStorage</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasLocalStorage0"><pre>Matches a variable declaration that has function scope and is a
non-static local variable.

Given
void f() {
  int x;
  static int y;
}
int z;
The matcher varDecl(hasLocalStorage())
matches x
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('hasStaticStorageDuration0')"><a name="hasStaticStorageDuration0Anchor">hasStaticStorageDuration</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasStaticStorageDuration0"><pre>Matches a variable declaration that has static storage duration.
It includes the variable declared at namespace scope and those declared
with "static" and "extern" storage class specifiers.

void f() {
  int x;
  static int y;
  thread_local int z;
}
int a;
static int b;
extern int c;

The matcher varDecl(hasStaticStorageDuration())
matches y, a, b and
c
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('hasThreadStorageDuration0')"><a name="hasThreadStorageDuration0Anchor">hasThreadStorageDuration</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="hasThreadStorageDuration0"><pre>Matches a variable declaration that has thread storage duration.

Given
void f() {
  int x;
  static int y;
  thread_local int z;
}
int a;

The matcher varDecl(hasThreadStorageDuration())
matches z
but does not match x, z or
a
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isConstexpr0')"><a name="isConstexpr0Anchor">isConstexpr</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConstexpr0"><pre>Matches constexpr variable and function declarations,
       and if constexpr.

Given
  constexpr int foo = 42;
  constexpr int bar();
  void baz() { if constexpr(1 &gt; 0) {} }

The matcher varDecl(isConstexpr())
matches foo.
The matcher functionDecl(isConstexpr())
matches bar.
The matcher ifStmt(isConstexpr())
matches if constexpr(1 &gt; 0) {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isConstinit0')"><a name="isConstinit0Anchor">isConstinit</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isConstinit0"><pre>Matches constinit variable declarations.

Given
  constinit int foo = 42;
  constinit const char* bar = "bar";
  int baz = 42;
  [[clang::require_constant_initialization]] int xyz = 42;

The matcher varDecl(isConstinit())
matches the declaration of foo
and bar,
but does not match baz or
xyz.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isDefinition1')"><a name="isDefinition1Anchor">isDefinition</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isDefinition1"><pre>Matches if a declaration has a body attached.

Example matches A, va, fa
  class A {};
  class B;  // Doesn't match, as it has no body.
  int va;
  extern int vb;  // Doesn't match, as it doesn't define the variable.
  void fa() {}
  void fb();  // Doesn't match, as it has no body.

The matcher tagDecl(isDefinition())
matches A
The matcher varDecl(isDefinition())
matches va
The matcher functionDecl(isDefinition())
matches fa

  @interface X
  - (void)ma; // Doesn't match, interface is declaration.
  @end
  @implementation X
  - (void)ma {}
  @end

The matcher objcMethodDecl(isDefinition())
matches - (void)ma {}

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagDecl.html">TagDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isExceptionVariable0')"><a name="isExceptionVariable0Anchor">isExceptionVariable</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExceptionVariable0"><pre>Matches a variable declaration that is an exception variable from
a C++ catch block, or an Objective-C statement.

Given
void f(int y) {
  try {
  } catch (int x) {
  }
}

The matcher varDecl(isExceptionVariable())
matches x
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isExplicitTemplateSpecialization1')"><a name="isExplicitTemplateSpecialization1Anchor">isExplicitTemplateSpecialization</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExplicitTemplateSpecialization1"><pre>Matches explicit template specializations of function, class, or
static member variable template instantiations.

Given
  template&lt;typename T&gt; void A(T t) { }
  template&lt;&gt; void A(int N) { }

The matcher functionDecl(isExplicitTemplateSpecialization())
  matches the specialization template&lt;&gt; void A(int N) { }.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isExternC1')"><a name="isExternC1Anchor">isExternC</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isExternC1"><pre>Matches extern "C" function or variable declarations.

Given
  extern "C" void f() {}
  extern "C" { void g() {} }
  void h() {}
  extern "C" int x = 1;
  extern "C" int y = 2;
  int z = 3;

The matcher functionDecl(isExternC())
matches f
and g.
The matcher varDecl(isExternC())
matches x
and y,
but does not match z.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isInitCapture0')"><a name="isInitCapture0Anchor">isInitCapture</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInitCapture0"><pre>Matches a variable serving as the implicit variable for a lambda init-
capture.

Given
auto f = [x = 3]() { return x; };

The matcher varDecl(isInitCapture())
matches x = 3.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isInline2')"><a name="isInline2Anchor">isInline</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isInline2"><pre>Matches functions, variables and namespace declarations that are marked with
the inline keyword.

Given
  inline void f();
  void g();
  namespace n {
  inline namespace m {}
  }
  inline int Foo = 5;

The matcher functionDecl(isInline()) matches f.
The matcher namespaceDecl(isInline()) matches m.
The matcher varDecl(isInline()) matches Foo
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isStaticLocal0')"><a name="isStaticLocal0Anchor">isStaticLocal</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isStaticLocal0"><pre>Matches a static variable with local scope.

Given
void f() {
  int x;
  static int y;
}
static int z;
The matcher varDecl(isStaticLocal())
matches y
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isStaticStorageClass1')"><a name="isStaticStorageClass1Anchor">isStaticStorageClass</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isStaticStorageClass1"><pre>Matches variable/function declarations that have "static" storage
class specifier ("static" keyword) written in the source.

Given
  static void f() {}
  static int i = 0;
  extern int j;
  int k;
The matcher functionDecl(isStaticStorageClass())
  matches f
The matcher varDecl(isStaticStorageClass())
  matches i
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('isTemplateInstantiation1')"><a name="isTemplateInstantiation1Anchor">isTemplateInstantiation</a></td><td></td></tr>
<tr><td colspan="4" class="doc" id="isTemplateInstantiation1"><pre>Matches template instantiations of function, class, or static
member variable template instantiations.

Given
  template &lt;typename T&gt; class X {};
  class A {};
  X&lt;A&gt; x;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches class X&lt;class A&gt;.
  template &lt;typename T&gt; class X {};
  class A {};
  template class X&lt;A&gt;;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches template class X&lt;A&gt;
  template &lt;typename T&gt; class X {};
  class A {};
  extern template class X&lt;A&gt;;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
matches extern template class X&lt;A&gt;

But given
  template &lt;typename T&gt;  class X {};
  class A {};
  template &lt;&gt; class X&lt;A&gt; {};
  X&lt;A&gt; x;

The matcher cxxRecordDecl(hasName("::X"),
isTemplateInstantiation())
  does not match, as X&lt;A&gt; is an explicit template specialization.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;
</pre></td></tr>

<!--END_NARROWING_MATCHERS -->
</table>

<!-- ======================================================================= -->
<h2 id="traversal-matchers">AST Traversal Matchers</h2>
<!-- ======================================================================= -->

<p>Traversal matchers specify the relationship to other nodes that are
reachable from the current node.</p>

<p>Note that there are special traversal matchers (has, hasDescendant, forEach and
forEachDescendant) which work on all nodes and allow users to write more generic
match expressions.</p>

<table>
<tr style="text-align:left"><th>Return type</th><th>Name</th><th>Parameters</th></tr>
<!-- START_TRAVERSAL_MATCHERS -->

<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('binaryOperation0')"><a name="binaryOperation0Anchor">binaryOperation</a></td><td>Matcher&lt;*&gt;...Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="binaryOperation0"><pre>Matches nodes which can be used with binary operators.

A comparison of two expressions might be represented in the clang AST as a
binaryOperator, a cxxOperatorCallExpr or a
cxxRewrittenBinaryOperator, depending on

* whether the types of var1 and var2 are fundamental (binaryOperator) or at
  least one is a class type (cxxOperatorCallExpr)
* whether the code appears in a template declaration, if at least one of the
  vars is a dependent-type (binaryOperator)
* whether the code relies on a rewritten binary operator, such as a
spaceship operator or an inverted equality operator
(cxxRewrittenBinaryOperator)

This matcher elides details in places where the matchers for the nodes are
compatible.

Given
  struct S{
      bool operator!=(const S&amp;) const;
  };

  void foo()
  {
     1 != 2;
     S() != S();
  }

  template&lt;typename T&gt;
  void templ()
  {
     3 != 4;
     T() != S();
  }
  struct HasOpEq
  {
      friend bool
      operator==(const HasOpEq &amp;, const HasOpEq&amp;) noexcept = default;
  };

  void inverse()
  {
      HasOpEq e1;
      HasOpEq e2;
      if (e1 != e2)
          return;
  }

  struct HasSpaceship
  {
      friend bool
      operator&lt;=&gt;(const HasSpaceship &amp;,
                  const HasSpaceship&amp;) noexcept = default;
  };

  void use_spaceship()
  {
      HasSpaceship s1;
      HasSpaceship s2;
      if (s1 != s2)
          return;
  }


The matcher binaryOperation(
    hasOperatorName("!="),
    hasLHS(expr().bind("lhs")),
    hasRHS(expr().bind("rhs"))
  )
matches 1 != 2, S() != S(), 3 != 4,
T() != S(), e1 != e2 and s1 != s2.
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('eachOf0')"><a name="eachOf0Anchor">eachOf</a></td><td>Matcher&lt;*&gt;, ..., Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="eachOf0"><pre>Matches if any of the given matchers matches.

Unlike anyOf, eachOf will generate a match result for each
matching submatcher.

Given
  void f(int a, int b);


The matcher functionDecl(hasAnyParameter(
eachOf(parmVarDecl(hasName("a")).bind("v"),
       parmVarDecl(hasName("b")).bind("v"))))
matches void f(int a, int b),
with parmVarDecl(hasName("a")) matching a
for one match,
and with parmVarDecl(hasName("b")) matching
b for the other match.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('findAll0')"><a name="findAll0Anchor">findAll</a></td><td>Matcher&lt;*&gt;  Matcher</td></tr>
<tr><td colspan="4" class="doc" id="findAll0"><pre>Matches if the node or any descendant matches.

Generates results for each match.

For example, in:
  class A { class B {}; class C {}; };

The matcher
cxxRecordDecl(hasName("::A"),
                findAll(cxxRecordDecl(isDefinition()).bind("m")))
matches A three times,
with cxxRecordDecl(isDefinition()).bind("m")
matching A,
B and C.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('forEachDescendant0')"><a name="forEachDescendant0Anchor">forEachDescendant</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="forEachDescendant0"><pre>Matches AST nodes that have descendant AST nodes that match the
provided matcher.

Given
  class X {};
  class A { class X {}; };  // Matches A, because A::X is a class of name
                            // X inside A.
  class B { class C { class X {}; }; };

The matcher
cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName("X"))))
matches X, A,
B, class B::C
and class B::C::X

DescendantT must be an AST base type.

As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for
each result that matches instead of only on the first one.

Note: Recursively combined ForEachDescendant can cause many matches:
  struct A {
    struct B {
      struct C {};
      struct D {};
    };
  };


The matcher cxxRecordDecl(forEachDescendant(cxxRecordDecl(
    forEachDescendant(cxxRecordDecl().bind("inner"))
  ).bind("middle")))
will match 9 times:
It matches the definition of A with the definition of
B in the middle and the injected class name of
B as the innermost cxxRecordDecl.

It matches the definition of A with the definition of
C in the middle and the definition of
B as the innermost cxxRecordDecl.

It matches the definition of A with the definition of
C in the middle and the injected class name of
B as the innermost cxxRecordDecl.

It matches the definition of A with the definition of
B in the middle and the definition of
D as the innermost cxxRecordDecl.

It matches the definition of A with the definition of
B in the middle and the injected class name of
D as the innermost cxxRecordDecl.

It matches the definition of A with the definition of
C in the middle and the injected class name of
C as the innermost cxxRecordDecl.

It matches the definition of A with the definition of
D in the middle and the injected class name of
D as the innermost cxxRecordDecl.

It matches the definition of B with the definition of
C in the middle and the injected class name of
C as the innermost cxxRecordDecl.

It matches the definition of B with the definition of
D in the middle and the injected class name of
D as the innermost cxxRecordDecl.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('forEach0')"><a name="forEach0Anchor">forEach</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="forEach0"><pre>Matches AST nodes that have child AST nodes that match the
provided matcher.

Given
  class X {};
  class Y { class X {}; };  // Matches Y, because Y::X is a class of name X
                            // inside Y.
  class Z { class Y { class X {}; }; };  // Does not match Z.

The matcher cxxRecordDecl(forEach(cxxRecordDecl(hasName("X"))))
matches class X,
class Y,
class Y::X,
class Z::Y::X and class Z::Y

ChildT must be an AST base type.

As opposed to 'has', 'forEach' will cause a match for each result that
  matches instead of only on the first one.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('hasAncestor0')"><a name="hasAncestor0Anchor">hasAncestor</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasAncestor0"><pre>Matches AST nodes that have an ancestor that matches the provided
matcher.

Given
void f() { if (true) { int x = 42; } }
void g() { for (;;) { int x = 43; } }

The matcher expr(integerLiteral(hasAncestor(ifStmt())))
matches 42
but does not match 43

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('hasDescendant0')"><a name="hasDescendant0Anchor">hasDescendant</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasDescendant0"><pre>Matches AST nodes that have descendant AST nodes that match the
provided matcher.

Given
  class X {};  // Matches X, because X::X is a class of name X inside X.
  class Y { class X {}; };
  class Z { class Y { class X {}; }; };

The matcher
cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName("X"))))
matches class X {}, class Y { class X {}; }
and class Z { class Y { class X {}; }; }.

DescendantT must be an AST base type.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('has0')"><a name="has0Anchor">has</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="has0"><pre>Matches AST nodes that have child AST nodes that match the
provided matcher.

Given
  class X {};  // Matches X, because X::X is a class of name X inside X.
  class Y { class X {}; };
  class Z { class Y { class X {}; }; };  // Does not match Z.

The matcher cxxRecordDecl(has(cxxRecordDecl(hasName("X"))))
matches class X {} three times,
and class Y { class X {}; } two times.

ChildT must be an AST base type.

Usable as: Any Matcher
Note that has is direct matcher, so it also matches things like implicit
casts and paren casts. If you are matching with expr then you should
probably consider using ignoringParenImpCasts:

Given
  int x =0;
  double y = static_cast&lt;double&gt;(x);

The matcher
cxxStaticCastExpr(has(ignoringParenImpCasts(declRefExpr()))).
matches static_cast&lt;double&gt;(x)
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('hasParent0')"><a name="hasParent0Anchor">hasParent</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasParent0"><pre>Matches AST nodes that have a parent that matches the provided
matcher.

Given
void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }

The matcher compoundStmt(hasParent(ifStmt()))
matches { int x = 43; }

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('invocation0')"><a name="invocation0Anchor">invocation</a></td><td>Matcher&lt;*&gt;...Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="invocation0"><pre>Matches function calls and constructor calls

Because CallExpr and CXXConstructExpr do not share a common
base class with API accessing arguments etc, AST Matchers for code
which should match both are typically duplicated. This matcher
removes the need for duplication.

Given
struct ConstructorTakesInt
{
  ConstructorTakesInt(int i) {}
};

void callTakesInt(int i)
{
}

void doCall()
{
  callTakesInt(42);
}

void doConstruct()
{
  ConstructorTakesInt cti(42);
}


The matcher
expr(invocation(hasArgument(0, integerLiteral(equals(42)))))
matches the expressions callTakesInt(42)
and cti(42).
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('optionally0')"><a name="optionally0Anchor">optionally</a></td><td>Matcher&lt;*&gt;</td></tr>
<tr><td colspan="4" class="doc" id="optionally0"><pre>Matches any node regardless of the submatcher.

However, optionally will retain any bindings generated by the submatcher.
Useful when additional information which may or may not present about a main
matching node is desired.

Given
  int a = 0;
  int b;

The matcher varDecl(optionally(hasInitializer(expr())))
matches int a = 0 and int b.

Usable as: Any Matcher
</pre></td></tr>


<tr><td>Matcher&lt;*&gt;</td><td class="name" onclick="toggle('traverse0')"><a name="traverse0Anchor">traverse</a></td><td>TraversalKind TK, Matcher&lt;*&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="traverse0"><pre>Causes all nested matchers to be matched with the specified traversal kind.

Given
  void foo()
  {
      int i = 3.0;
  }
The matcher
traverse(TK_IgnoreUnlessSpelledInSource,
    varDecl(hasInitializer(floatLiteral().bind("init")))
  )
  matches int i = 3.0 with "init" bound to 3.0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>&gt;</td><td class="name" onclick="toggle('hasCondition5')"><a name="hasCondition5Anchor">hasCondition</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition5"><pre>Matches the condition expression of an if statement, for loop,
switch statement or conditional operator.

Given
void foo() {
  if (true) {}
}

The matcher ifStmt(hasCondition(cxxBoolLiteral(equals(true))))
if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>&gt;</td><td class="name" onclick="toggle('hasFalseExpression0')"><a name="hasFalseExpression0Anchor">hasFalseExpression</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasFalseExpression0"><pre>Matches the false branch expression of a conditional operator
(binary or ternary).

Example matches b
  void foo(bool condition, int a, int b) {
    condition ? a : b;
    condition ?: b;
  }

The matcher
conditionalOperator(hasFalseExpression(expr().bind("false")))
matches condition ? a : b,
with expr() matching b.
The matcher
binaryConditionalOperator(hasFalseExpression(expr().bind("false")))
matches condition ?: b,
with expr() matching b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>&gt;</td><td class="name" onclick="toggle('hasTrueExpression0')"><a name="hasTrueExpression0Anchor">hasTrueExpression</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTrueExpression0"><pre>Matches the true branch expression of a conditional operator.

Example 1 (conditional ternary operator): matches a
Given
  void foo(bool condition, int a, int b) {
    condition ? a : b;
  }

The matcher
conditionalOperator(hasTrueExpression(expr().bind("true")))
matches condition ? a : b,
with expr() matching a.

Example 2 (conditional binary operator): matches opaqueValueExpr(condition)
Given
  void foo(bool condition, int a, int b) {
    condition ?: b;
  }

The matcher binaryConditionalOperator(hasTrueExpression(expr()))
matches condition ?: b,
with expr() matching conditoin.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration15')"><a name="hasDeclaration15Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration15"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>&gt;</td><td class="name" onclick="toggle('hasBase0')"><a name="hasBase0Anchor">hasBase</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBase0"><pre>Matches the base expression of an array subscript expression.

Given
  int i[5];
  void f() { i[1] = 42; }
The matcher arraySubscriptExpr(hasBase(implicitCastExpr(
    hasSourceExpression(declRefExpr()))))
  matches i[1] with the declRefExpr() matching i
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>&gt;</td><td class="name" onclick="toggle('hasIndex0')"><a name="hasIndex0Anchor">hasIndex</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasIndex0"><pre>Matches the index expression of an array subscript expression.

Given
  int i[5];
  void f() { i[1] = 42; }
The matcher arraySubscriptExpr(hasIndex(integerLiteral()))
  matches i[1] with the integerLiteral() matching 1
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>&gt;</td><td class="name" onclick="toggle('hasLHS3')"><a name="hasLHS3Anchor">hasLHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLHS3"><pre>Matches the left hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasLHS(expr().bind("lhs")))
matches a || b,
with expr()
matching a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>&gt;</td><td class="name" onclick="toggle('hasRHS3')"><a name="hasRHS3Anchor">hasRHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasRHS3"><pre>Matches the right hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasRHS(expr().bind("rhs")))
matches a || b,
with expr()
matching b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArrayType.html">ArrayType</a>&gt;</td><td class="name" onclick="toggle('hasElementType0')"><a name="hasElementType0Anchor">hasElementType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasElementType0"><pre>Matches arrays and C99 complex types that have a specific element
type.

Given
  struct A {};
  A a[7];
  int b[7];


The matcher arrayType(hasElementType(builtinType()))
int[7]

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArrayType.html">ArrayType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ComplexType.html">ComplexType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AtomicType.html">AtomicType</a>&gt;</td><td class="name" onclick="toggle('hasValueType0')"><a name="hasValueType0Anchor">hasValueType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasValueType0"><pre>Matches atomic types with a specific value type.

Given
  _Atomic(int) i;
  _Atomic(float) f;
The matcher atomicType(hasValueType(isInteger()))
_Atomic(int).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AtomicType.html">AtomicType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AutoType.html">AutoType</a>&gt;</td><td class="name" onclick="toggle('hasDeducedType0')"><a name="hasDeducedType0Anchor">hasDeducedType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasDeducedType0"><pre>Matches AutoType nodes where the deduced type is a specific type.

Note: There is no TypeLoc for the deduced type and thus no
getDeducedLoc() matcher.

Given
  auto a = 1;
  auto b = 2.0;

The matcher
varDecl(hasType(autoType(hasDeducedType(isInteger()))))
matches auto a = 1, but does not match auto b = 2.0.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AutoType.html">AutoType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BaseUsingDecl.html">BaseUsingDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyUsingShadowDecl0')"><a name="hasAnyUsingShadowDecl0Anchor">hasAnyUsingShadowDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyUsingShadowDecl0"><pre>Matches any using shadow declaration.

Given
  namespace X { void b(); }
  using X::b;

The matcher usingDecl(hasAnyUsingShadowDecl(hasName("b")))
  matches using X::b
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasEitherOperand0')"><a name="hasEitherOperand0Anchor">hasEitherOperand</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasEitherOperand0"><pre>Matches if either the left hand side or the right hand side of a
binary operator or fold expression matches.

Given
  struct S {};
  bool operator ==(const S&amp;, const S&amp;);

  void f(int a, const S&amp;lhs, const S&amp;rhs) {
      a + 0;
      lhs == rhs;
      lhs != rhs;
  }

  template &lt;typename ...Ts&gt;
  auto sum(Ts... args) {
    return (0 + ... + args);
  }


The matcher binaryOperator(hasEitherOperand(integerLiteral()))
matches a + 0.
The matcher cxxOperatorCallExpr(hasEitherOperand(declRefExpr(to(
parmVarDecl(hasName("lhs")))))) matches lhs == rhs and
lhs != rhs.
The matcher cxxFoldExpr(hasEitherOperand(integerLiteral()))
matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasLHS0')"><a name="hasLHS0Anchor">hasLHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLHS0"><pre>Matches the left hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasLHS(expr().bind("lhs")))
matches a || b,
with expr()
matching a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasOperands0')"><a name="hasOperands0Anchor">hasOperands</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher1, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher2</td></tr>
<tr><td colspan="4" class="doc" id="hasOperands0"><pre>Matches if both matchers match with opposite sides of the binary operator
or fold expression.

Given
void foo() {
  1 + 2; // Match
  2 + 1; // Match
  1 + 1; // No match
  2 + 2; // No match
}
The matcher binaryOperator(hasOperands(integerLiteral(equals(1)),
                                            integerLiteral(equals(2))))
matches 1 + 2 and 2 + 1,
but does not match 1 + 1
or 2 + 2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BinaryOperator.html">BinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasRHS0')"><a name="hasRHS0Anchor">hasRHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasRHS0"><pre>Matches the right hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasRHS(expr().bind("rhs")))
matches a || b,
with expr()
matching b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BindingDecl.html">BindingDecl</a>&gt;</td><td class="name" onclick="toggle('forDecomposition0')"><a name="forDecomposition0Anchor">forDecomposition</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forDecomposition0"><pre>Matches the DecompositionDecl the binding belongs to.

Given
void foo()
{
    int arr[3];
    auto &amp;[f, s, t] = arr;

    f = 42;
}

The matcher bindingDecl(hasName("f"),
                forDecomposition(decompositionDecl()))
matches f in 'auto &amp;[f, s, t]'.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyParameter2')"><a name="hasAnyParameter2Anchor">hasAnyParameter</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyParameter2"><pre>Matches any parameter of a function or an ObjC method declaration or a
block.

Does not match the 'this' parameter of a method.

Given
  class X { void f(int x, int y, int z) {} };

The matcher cxxMethodDecl(hasAnyParameter(hasName("y")))
  matches f
with hasAnyParameter(...)
  matching int y

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end


the matcher objcMethodDecl(hasAnyParameter(hasName("y")))
  matches the declaration of method f with hasParameter
matching y.

For blocks, given
  b = ^(int y) { printf("%d", y) };


the matcher blockDecl(hasAnyParameter(hasName("y")))
  matches the declaration of the block b with hasParameter
matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;</td><td class="name" onclick="toggle('hasParameter2')"><a name="hasParameter2Anchor">hasParameter</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasParameter2"><pre>Matches the n'th parameter of a function or an ObjC method
declaration or a block.

Given
  class X { void f(int x) {} };

The matcher
cxxMethodDecl(hasParameter(0, hasType(asString("int"))))
matches f
with hasParameter(...)
matching int x.

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end


The matcher objcMethodDecl(hasParameter(0, hasName("y")))
matches the declaration of method f with hasParameter
matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc0')"><a name="hasTypeLoc0Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc0"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockPointerType.html">BlockPointerType</a>&gt;</td><td class="name" onclick="toggle('pointee0')"><a name="pointee0Anchor">pointee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="pointee0"><pre>Narrows PointerType (and similar) matchers to those where the
pointee matches a given matcher.

Given
  int *a;
  const int *b;
  int * const c = nullptr;
  const float *f;

The matcher pointerType(pointee(isConstQualified(), isInteger()))
matches const int *,
but does not match int * const
or const float *.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockPointerType.html">BlockPointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberPointerType.html">MemberPointerType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerType.html">PointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceType.html">ReferenceType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc1')"><a name="hasTypeLoc1Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc1"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('hasType8')"><a name="hasType8Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType8"><pre>Overloaded to match the declaration of the expression's or value
declaration's type.

In case of a value declaration (for example a variable declaration),
this resolves one layer of indirection. For example, in the value
declaration "X x;", cxxRecordDecl(hasName("X")) matches the declaration of
X, while varDecl(hasType(cxxRecordDecl(hasName("X")))) matches the
declaration of x.

 class X {};
 void y(X &amp;x) { x; X z; }
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z.
The matcher friendDecl(hasType(asString("class X")))
matches friend class X.
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches
class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.

Given
class Base {};
class Derived : Base {};

The matcher
cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName("Base")))))
matches class Derived : Base {}.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FriendDecl.html">FriendDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt;,
Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td><td class="name" onclick="toggle('hasType4')"><a name="hasType4Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType4"><pre>Matches if the expression's or declaration's type matches a type
matcher.

Exmaple
 class X {};
 void y(X &amp;x) { x; X z; }
 typedef int U;
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z
The matcher typedefDecl(hasType(asString("int")))
matches typedef int U
The matcher friendDecl(hasType(asString("class X")))
matches friend class X
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('forEachArgumentWithParam1')"><a name="forEachArgumentWithParam1Anchor">forEachArgumentWithParam</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; ArgMatcher, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; ParamMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachArgumentWithParam1"><pre>Matches all arguments and their respective ParmVarDecl.

Given
  void f(int i);
  int y;
  void foo() {
    f(y);
  }
The matcher callExpr(
  forEachArgumentWithParam(
    declRefExpr(to(varDecl(hasName("y")))),
    parmVarDecl(hasType(isInteger()))
))
  matches f(y);
with declRefExpr(...)
  matching int y
and parmVarDecl(...)
  matching int i
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('forEachArgumentWithParamType1')"><a name="forEachArgumentWithParamType1Anchor">forEachArgumentWithParamType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; ArgMatcher, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; ParamMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachArgumentWithParamType1"><pre>Matches all arguments and their respective types for a CallExpr or
CXXConstructExpr. It is very similar to forEachArgumentWithParam but
it works on calls through function pointers as well.

The difference is, that function pointers do not provide access to a
ParmVarDecl, but only the QualType for each argument.

Given
  void f(int i);
  void foo(int y) {
    f(y);
    void (*f_ptr)(int) = f;
    f_ptr(y);
  }
The matcher callExpr(
  forEachArgumentWithParamType(
    declRefExpr(to(varDecl(hasName("y")))),
    qualType(isInteger()).bind("type")
))
  matches f(y) and f_ptr(y)
with declRefExpr(...)
  matching int y
and qualType(...)
  matching int
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyArgument1')"><a name="hasAnyArgument1Anchor">hasAnyArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyArgument1"><pre>Matches any argument of a call expression or a constructor call
expression, or an ObjC-message-send expression.

Given
  void x(int, int, int) { int y = 42; x(1, y, 42); }
The matcher
callExpr(hasAnyArgument(ignoringImplicit(declRefExpr()))) matches
x(1, y, 42) with hasAnyArgument(...)
  matching y

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end
  void foo(I *i) { [i f:12]; }

The matcher
objcMessageExpr(hasAnyArgument(integerLiteral(equals(12))))
matches [i f:12]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('hasArgument1')"><a name="hasArgument1Anchor">hasArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArgument1"><pre>Matches the n'th argument of a call expression or a constructor
call expression.

Given
  void x(int) { int y; x(y); }
The matcher callExpr(hasArgument(0, declRefExpr().bind("arg")))
matches x(y),
with declRefExpr() matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration13')"><a name="hasDeclaration13Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration13"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('forEachConstructorInitializer0')"><a name="forEachConstructorInitializer0Anchor">forEachConstructorInitializer</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachConstructorInitializer0"><pre>Matches each constructor initializer in a constructor definition.

Given
  class A { A() : i(42), j(42) {} int i; int j; };

The matcher cxxConstructorDecl(forEachConstructorInitializer(
  forField(fieldDecl().bind("x"))))
matches the constructor of A twice, with
fieldDecl() matching i and
j respectively.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyConstructorInitializer0')"><a name="hasAnyConstructorInitializer0Anchor">hasAnyConstructorInitializer</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyConstructorInitializer0"><pre>Matches a constructor initializer.

Given
  struct Foo {
    Foo() : foo_(1) { }
    int foo_;
  };

The matcher cxxRecordDecl(has(cxxConstructorDecl(
  hasAnyConstructorInitializer(anything())
)))
matches Foo, hasAnyConstructorInitializer matches foo_(1)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td><td class="name" onclick="toggle('forField0')"><a name="forField0Anchor">forField</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FieldDecl.html">FieldDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forField0"><pre>Matches the field declaration of a constructor initializer.

Given
  struct Foo {
    Foo() : foo_(1) { }
    int foo_;
  };

The matcher
cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(
    forField(hasName("foo_"))))))
matches Foo
with forField matching foo_
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc2')"><a name="hasTypeLoc2Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc2"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td><td class="name" onclick="toggle('withInitializer0')"><a name="withInitializer0Anchor">withInitializer</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="withInitializer0"><pre>Matches the initializer expression of a constructor initializer.

Given
  struct Foo {
    Foo() : foo_(1) { }
    int foo_;
  };

The matcher
cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(
    withInitializer(integerLiteral(equals(1)))))))
matches Foo
with withInitializer matching (1)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>&gt;</td><td class="name" onclick="toggle('hasObjectExpression2')"><a name="hasObjectExpression2Anchor">hasObjectExpression</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasObjectExpression2"><pre>Matches a member expression where the object expression is matched by a
given matcher. Implicit object expressions are included; that is, it matches
use of implicit `this`.

Given
  struct X {
    int m;
    int f(X x) { x.m; return m; }
  };


The matcher
memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName("X")))))
matches x.m, but not m; however,
The matcher memberExpr(hasObjectExpression(hasType(pointsTo(
cxxRecordDecl(hasName("X"))))))
matches m (aka. this-&gt;m), but not x.m.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('callee1')"><a name="callee1Anchor">callee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="callee1"><pre>Matches if the call or fold expression's callee expression matches.

Given
  class Y { void x() { this-&gt;x(); x(); Y y; y.x(); } };
  void f() { f(); }

The matcher callExpr(callee(expr().bind("callee")))
matches this-&gt;x(), x(), y.x(), f()
with expr() inside of callee
matching this-&gt;x, x,
y.x, f respectively

Given
  struct Dummy {};
  // makes sure there is a callee, otherwise there would be no callee,
  // just a builtin operator
  Dummy operator+(Dummy, Dummy);
  // not defining a '*' operator

  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ... * 1);
  }

The matcher cxxFoldExpr(callee(expr().bind("op")))
matches (0 + ... + args)
with callee(...) matching *,
but does not match (args * ... * 1).
A CXXFoldExpr only has an UnresolvedLookupExpr as a callee.
When there are no define operators that could be used instead of builtin
ones, then there will be no callee .

Note: Callee cannot take the more general internal::Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;
because this introduces ambiguous overloads with calls to Callee taking a
internal::Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, as the matcher hierarchy is purely
implemented in terms of implicit casts.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('hasEitherOperand2')"><a name="hasEitherOperand2Anchor">hasEitherOperand</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasEitherOperand2"><pre>Matches if either the left hand side or the right hand side of a
binary operator or fold expression matches.

Given
  struct S {};
  bool operator ==(const S&amp;, const S&amp;);

  void f(int a, const S&amp;lhs, const S&amp;rhs) {
      a + 0;
      lhs == rhs;
      lhs != rhs;
  }

  template &lt;typename ...Ts&gt;
  auto sum(Ts... args) {
    return (0 + ... + args);
  }


The matcher binaryOperator(hasEitherOperand(integerLiteral()))
matches a + 0.
The matcher cxxOperatorCallExpr(hasEitherOperand(declRefExpr(to(
parmVarDecl(hasName("lhs")))))) matches lhs == rhs and
lhs != rhs.
The matcher cxxFoldExpr(hasEitherOperand(integerLiteral()))
matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('hasFoldInit0')"><a name="hasFoldInit0Anchor">hasFoldInit</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMacher</td></tr>
<tr><td colspan="4" class="doc" id="hasFoldInit0"><pre>Matches the operand that does not contain the parameter pack.

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ... * 1);
  }


The matcher cxxFoldExpr(hasFoldInit(expr().bind("init")))
matches (0 + ... + args) and (args * ... * 1)
with hasFoldInit(expr().bind("init")) matching
0 and 1.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('hasLHS4')"><a name="hasLHS4Anchor">hasLHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLHS4"><pre>Matches the left hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasLHS(expr().bind("lhs")))
matches a || b,
with expr()
matching a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('hasOperands2')"><a name="hasOperands2Anchor">hasOperands</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher1, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher2</td></tr>
<tr><td colspan="4" class="doc" id="hasOperands2"><pre>Matches if both matchers match with opposite sides of the binary operator
or fold expression.

Given
void foo() {
  1 + 2; // Match
  2 + 1; // Match
  1 + 1; // No match
  2 + 2; // No match
}
The matcher binaryOperator(hasOperands(integerLiteral(equals(1)),
                                            integerLiteral(equals(2))))
matches 1 + 2 and 2 + 1,
but does not match 1 + 1
or 2 + 2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('hasPattern0')"><a name="hasPattern0Anchor">hasPattern</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMacher</td></tr>
<tr><td colspan="4" class="doc" id="hasPattern0"><pre>Matches the operand that contains the parameter pack.

Given
  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ... * 1);
  }


The matcher cxxFoldExpr(hasPattern(expr().bind("pattern")))
matches (0 + ... + args) and (args * ... * 1),
with hasPattern(expr().bind("pattern")) matching
args two times.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFoldExpr.html">CXXFoldExpr</a>&gt;</td><td class="name" onclick="toggle('hasRHS4')"><a name="hasRHS4Anchor">hasRHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasRHS4"><pre>Matches the right hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasRHS(expr().bind("rhs")))
matches a || b,
with expr()
matching b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>&gt;</td><td class="name" onclick="toggle('hasBody3')"><a name="hasBody3Anchor">hasBody</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody3"><pre>Matches a 'for', 'while', 'while' statement or a function or coroutine
definition that has a given body. Note that in case of functions or
coroutines this matcher only matches the definition itself and not the
other declarations of the same function or coroutine.

Given
void foo() {
  for (;;) {}
}
The matcher forStmt(hasBody(compoundStmt().bind("body")))
matches for (;;) {}
with compoundStmt()
  matching {}

Given
  void f();
  void f() {}
The matcher functionDecl(hasBody(compoundStmt().bind("compound")))
f
with compoundStmt()
matching {}
but does not match void f();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>&gt;</td><td class="name" onclick="toggle('hasInitStatement2')"><a name="hasInitStatement2Anchor">hasInitStatement</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasInitStatement2"><pre>Matches selection statements with initializer.

Given
 struct vec { int* begin(); int* end(); };
 int foobar();
 vec&amp; get_range();
 void foo() {
   if (int i = foobar(); i &gt; 0) {}
   switch (int i = foobar(); i) {}
   for (auto&amp; a = get_range(); auto&amp; x : a) {}
 }
 void bar() {
   if (foobar() &gt; 0) {}
   switch (foobar()) {}
   for (auto&amp; x : get_range()) {}
 }

The matcher ifStmt(hasInitStatement(anything()))
  matches the if statement if (int i = foobar(); i &gt; 0) {}
  in foo but not if (foobar() &gt; 0) {} in bar.
The matcher switchStmt(hasInitStatement(anything()))
  matches the switch statement switch (int i = foobar(); i) {}
  in foo but not switch (foobar()) {} in bar.
The matcher cxxForRangeStmt(hasInitStatement(anything()))
  matches the range for statement
  for (auto&amp; a = get_range(); auto&amp; x : a) {} in foo
  but not for (auto&amp; x : get_range()) {} in bar.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>&gt;</td><td class="name" onclick="toggle('hasLoopVariable0')"><a name="hasLoopVariable0Anchor">hasLoopVariable</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLoopVariable0"><pre>Matches the initialization statement of a for loop.

Given
  void foo() {
    int a[42] = {};
    for (int x : a) { }
  }

The matcher cxxForRangeStmt(hasLoopVariable(anything()))
matches for (int x : a) { }
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>&gt;</td><td class="name" onclick="toggle('hasRangeInit0')"><a name="hasRangeInit0Anchor">hasRangeInit</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasRangeInit0"><pre>Matches the range initialization statement of a for loop.

Given
  void foo() {
    int a[42] = {};
    for (int x : a) { }
  }

The matcher cxxForRangeStmt(hasRangeInit(anything()))
matches for (int x : a) { }
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc3')"><a name="hasTypeLoc3Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc3"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&gt;</td><td class="name" onclick="toggle('onImplicitObjectArgument0')"><a name="onImplicitObjectArgument0Anchor">onImplicitObjectArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="onImplicitObjectArgument0"><pre>Matches on the implicit object argument of a member call expression. Unlike
`on`, matches the argument directly without stripping away anything.

Given
  class Y { public: void m(); };
  Y g();
  class X : public Y { public: void g(); };
  void z(Y y, X x) { y.m(); x.m(); x.g(); (g()).m(); }

The matcher cxxMemberCallExpr(onImplicitObjectArgument(hasType(
    cxxRecordDecl(hasName("Y")))))
matches y.m(), x.m() and (g()).m()
but does not match x.g().
The matcher cxxMemberCallExpr(on(callExpr()))
matches (g()).m(), because the parens are ignored.
FIXME: should they be ignored? (ignored bc of `on`)

FIXME: Overload to allow directly matching types?
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&gt;</td><td class="name" onclick="toggle('on0')"><a name="on0Anchor">on</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="on0"><pre>Matches on the implicit object argument of a member call expression, after
stripping off any parentheses or implicit casts.

Given
  class Y { public: void m(); };
  Y g();
  class X : public Y {};
  void z(Y y, X x) { y.m(); (g()).m(); x.m(); }

The matcher
cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName("Y")))))
  matches y.m() and (g()).m().
The matcher
cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName("X")))))
  matches x.m().
The matcher cxxMemberCallExpr(on(callExpr()))
  matches (g()).m().

FIXME: Overload to allow directly matching types?
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&gt;</td><td class="name" onclick="toggle('thisPointerType1')"><a name="thisPointerType1Anchor">thisPointerType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="thisPointerType1"><pre>Overloaded to match the type's declaration.

Given
  class Y { public: void m(); };
  class X : public Y { public: void g(); };
  void z() { Y y; y.m(); Y *p; p-&gt;m(); X x; x.m(); x.g(); }

The matcher cxxMemberCallExpr(thisPointerType(
    cxxRecordDecl(hasName("Y"))))
  matches y.m(), p-&gt;m() and x.m().
The matcher cxxMemberCallExpr(thisPointerType(
    cxxRecordDecl(hasName("X"))))
  matches x.g().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&gt;</td><td class="name" onclick="toggle('thisPointerType0')"><a name="thisPointerType0Anchor">thisPointerType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="thisPointerType0"><pre>Matches if the type of the expression's implicit object argument either
  matches the InnerMatcher, or is a pointer to a type that matches the
InnerMatcher.

Given
  class Y { public: void m() const; };
  class X : public Y { public: void g(); };
  void z() { const Y y; y.m(); const Y *p; p-&gt;m(); X x; x.m(); x.g(); }

The matcher
cxxMemberCallExpr(thisPointerType(isConstQualified()))
matches y.m(), x.m() and p-&gt;m(),
but not x.g().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('forEachOverridden0')"><a name="forEachOverridden0Anchor">forEachOverridden</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachOverridden0"><pre>Matches each method overridden by the given method. This matcher may
produce multiple matches.

Given
  class A { virtual void f(); };
  class B : public A { void f(); };
  class C : public B { void f(); };

The matcher cxxMethodDecl(ofClass(hasName("C")),
              forEachOverridden(cxxMethodDecl().bind("b")))
matches void f() of C ,
with cxxMethodDecl() matching
virtual void f() of A ,
but the matcher does not match void f() of B because
it is not overridden by C::f.

The check can produce multiple matches in case of multiple inheritance, e.g.
  class A1 { virtual void f(); };
  class A2 { virtual void f(); };
  class C : public A1, public A2 { void f(); };

The matcher cxxMethodDecl(ofClass(hasName("C")),
              forEachOverridden(cxxMethodDecl().bind("b")))
matches void f() of C with the inner
cxxMethodDecl() matching virtual void f()
inside of A1 , and void f() of C with the inner
cxxMethodDecl() matching virtual void f()
inside of A2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt;</td><td class="name" onclick="toggle('ofClass0')"><a name="ofClass0Anchor">ofClass</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ofClass0"><pre>Matches the class declaration that the given method declaration
belongs to.

FIXME: Generalize this for other kinds of declarations.
FIXME: What other kind of declarations would we need to generalize
this to?

Given
  class A {
   public:
    A();
    void foo();
  };

The matcher cxxMethodDecl(ofClass(hasName("A")))
matches A() and void foo().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyPlacementArg0')"><a name="hasAnyPlacementArg0Anchor">hasAnyPlacementArg</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyPlacementArg0"><pre>Matches any placement new expression arguments.

Given
  void* operator new(decltype(sizeof(void*)), void*);
  struct MyClass { int x; };
  unsigned char Storage[sizeof(MyClass) * 10];
  MyClass *p1 = new (Storage) MyClass();


The matcher cxxNewExpr(hasAnyPlacementArg(anything()))
matches new (Storage) MyClass().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;</td><td class="name" onclick="toggle('hasArraySize0')"><a name="hasArraySize0Anchor">hasArraySize</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArraySize0"><pre>Matches array new expressions with a given array size.

Given
  void* operator new(decltype(sizeof(void*)));
  struct MyClass { int x; };
  MyClass *p1 = new MyClass[10];


The matcher
cxxNewExpr(hasArraySize(
            ignoringImplicit(integerLiteral(equals(10)))))
matches new MyClass[10].
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration12')"><a name="hasDeclaration12Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration12"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;</td><td class="name" onclick="toggle('hasPlacementArg0')"><a name="hasPlacementArg0Anchor">hasPlacementArg</a></td><td>unsigned Index, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasPlacementArg0"><pre>Matches placement new expression arguments.

Given
  void *operator new(decltype(sizeof(void*)), int, void*);
  struct MyClass { int x; };
  unsigned char Storage[sizeof(MyClass) * 10];
  MyClass *p1 = new (16, Storage) MyClass();


The matcher cxxNewExpr(hasPlacementArg(0,
                      integerLiteral(equals(16))))
matches new (16, Storage) MyClass().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc4')"><a name="hasTypeLoc4Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc4"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasEitherOperand1')"><a name="hasEitherOperand1Anchor">hasEitherOperand</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasEitherOperand1"><pre>Matches if either the left hand side or the right hand side of a
binary operator or fold expression matches.

Given
  struct S {};
  bool operator ==(const S&amp;, const S&amp;);

  void f(int a, const S&amp;lhs, const S&amp;rhs) {
      a + 0;
      lhs == rhs;
      lhs != rhs;
  }

  template &lt;typename ...Ts&gt;
  auto sum(Ts... args) {
    return (0 + ... + args);
  }


The matcher binaryOperator(hasEitherOperand(integerLiteral()))
matches a + 0.
The matcher cxxOperatorCallExpr(hasEitherOperand(declRefExpr(to(
parmVarDecl(hasName("lhs")))))) matches lhs == rhs and
lhs != rhs.
The matcher cxxFoldExpr(hasEitherOperand(integerLiteral()))
matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasLHS1')"><a name="hasLHS1Anchor">hasLHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLHS1"><pre>Matches the left hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasLHS(expr().bind("lhs")))
matches a || b,
with expr()
matching a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasOperands1')"><a name="hasOperands1Anchor">hasOperands</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher1, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher2</td></tr>
<tr><td colspan="4" class="doc" id="hasOperands1"><pre>Matches if both matchers match with opposite sides of the binary operator
or fold expression.

Given
void foo() {
  1 + 2; // Match
  2 + 1; // Match
  1 + 1; // No match
  2 + 2; // No match
}
The matcher binaryOperator(hasOperands(integerLiteral(equals(1)),
                                            integerLiteral(equals(2))))
matches 1 + 2 and 2 + 1,
but does not match 1 + 1
or 2 + 2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasRHS1')"><a name="hasRHS1Anchor">hasRHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasRHS1"><pre>Matches the right hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasRHS(expr().bind("rhs")))
matches a || b,
with expr()
matching b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>&gt;</td><td class="name" onclick="toggle('hasUnaryOperand1')"><a name="hasUnaryOperand1Anchor">hasUnaryOperand</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasUnaryOperand1"><pre>Matches if the operand of a unary operator matches.

void foo() {
  !true;
}

The matcher
unaryOperator(hasUnaryOperand(cxxBoolLiteral(equals(true))))
matches !true.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyBase0')"><a name="hasAnyBase0Anchor">hasAnyBase</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt; BaseSpecMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyBase0"><pre>Matches C++ classes that have a direct or indirect base matching BaseSpecMatcher.

Given
  class Foo {};
  class Bar : Foo {};
  class Baz : Bar {};
  class SpecialBase {};
  class Proxy : SpecialBase {};  // matches Proxy
  class IndirectlyDerived : Proxy {};  //matches IndirectlyDerived


The matcher
cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName("SpecialBase")))))
matches Proxy and IndirectlyDerived
FIXME: Refactor this and isDerivedFrom to reuse implementation.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('hasDirectBase0')"><a name="hasDirectBase0Anchor">hasDirectBase</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt; BaseSpecMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDirectBase0"><pre>Matches C++ classes that have a direct base matching BaseSpecMatcher.

Given
  class Foo {};
  class Bar : Foo {};
  class Baz : Bar {};
  class SpecialBase {};
  class Proxy : SpecialBase {};  // matches Proxy
  class IndirectlyDerived : Proxy {};  // doesn't match

The matcher
cxxRecordDecl(hasDirectBase(hasType(cxxRecordDecl(hasName("SpecialBase")))))
matches Proxy
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('hasMethod0')"><a name="hasMethod0Anchor">hasMethod</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasMethod0"><pre>Matches the first method of a class or struct that satisfies InnerMatcher.

Given
  class A { void func(); };
  class B { void member(); };


The matcher cxxRecordDecl(hasMethod(hasName("func")))
matches the declaration of class A { void func(); }
but does not match class B { void member(); }
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isDerivedFrom0')"><a name="isDerivedFrom0Anchor">isDerivedFrom</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; Base</td></tr>
<tr><td colspan="4" class="doc" id="isDerivedFrom0"><pre>Matches C++ classes that are directly or indirectly derived from a class
matching Base, or Objective-C classes that directly or indirectly
subclass a class matching Base.

Note that a class is not considered to be derived from itself.

Example matches Y, Z, C (Base == hasName("X"))
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

  class Foo {};
  typedef Foo Alias;
  class Bar : public Alias {};
  // derived from a type that Alias is a typedef of Foo


The matcher cxxRecordDecl(isDerivedFrom(hasName("X")))
matches Y, Z and C.
The matcher cxxRecordDecl(isDerivedFrom(hasName("Foo")))
matches Bar.

In the following example, Bar matches isDerivedFrom(hasName("NSObject"))
  @interface NSObject @end
  @interface Bar : NSObject @end


Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isDirectlyDerivedFrom0')"><a name="isDirectlyDerivedFrom0Anchor">isDirectlyDerivedFrom</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; Base</td></tr>
<tr><td colspan="4" class="doc" id="isDirectlyDerivedFrom0"><pre>Matches C++ or Objective-C classes that are directly derived from a class
matching Base.

Note that a class is not considered to be derived from itself.

Given
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

The matcher
cxxRecordDecl(isDirectlyDerivedFrom(namedDecl(hasName("X"))))
matches Y and C (Base == hasName("X")

In the following example, Bar matches isDerivedFrom(hasName("X")):
  class Foo {};
  typedef Foo X;
  class Bar : public Foo {};  // derived from a type that X is a typedef of

The matcher cxxRecordDecl(isDerivedFrom(hasName("X")))
matches Bar
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;</td><td class="name" onclick="toggle('isSameOrDerivedFrom0')"><a name="isSameOrDerivedFrom0Anchor">isSameOrDerivedFrom</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; Base</td></tr>
<tr><td colspan="4" class="doc" id="isSameOrDerivedFrom0"><pre>Similar to isDerivedFrom(), but also matches classes that directly
match Base.

Given
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

The matcher
cxxRecordDecl(isSameOrDerivedFrom(cxxRecordDecl(hasName("X"))),
isDefinition())
matches class X {}, class Y : public X {},
class Z : public Y {} and class C : public B {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasEitherOperand3')"><a name="hasEitherOperand3Anchor">hasEitherOperand</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasEitherOperand3"><pre>Matches if either the left hand side or the right hand side of a
binary operator or fold expression matches.

Given
  struct S {};
  bool operator ==(const S&amp;, const S&amp;);

  void f(int a, const S&amp;lhs, const S&amp;rhs) {
      a + 0;
      lhs == rhs;
      lhs != rhs;
  }

  template &lt;typename ...Ts&gt;
  auto sum(Ts... args) {
    return (0 + ... + args);
  }


The matcher binaryOperator(hasEitherOperand(integerLiteral()))
matches a + 0.
The matcher cxxOperatorCallExpr(hasEitherOperand(declRefExpr(to(
parmVarDecl(hasName("lhs")))))) matches lhs == rhs and
lhs != rhs.
The matcher cxxFoldExpr(hasEitherOperand(integerLiteral()))
matches (0 + ... + args).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasLHS2')"><a name="hasLHS2Anchor">hasLHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLHS2"><pre>Matches the left hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasLHS(expr().bind("lhs")))
matches a || b,
with expr()
matching a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasOperands3')"><a name="hasOperands3Anchor">hasOperands</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher1, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; Matcher2</td></tr>
<tr><td colspan="4" class="doc" id="hasOperands3"><pre>Matches if both matchers match with opposite sides of the binary operator
or fold expression.

Given
void foo() {
  1 + 2; // Match
  2 + 1; // Match
  1 + 1; // No match
  2 + 2; // No match
}
The matcher binaryOperator(hasOperands(integerLiteral(equals(1)),
                                            integerLiteral(equals(2))))
matches 1 + 2 and 2 + 1,
but does not match 1 + 1
or 2 + 2.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasRHS2')"><a name="hasRHS2Anchor">hasRHS</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasRHS2"><pre>Matches the right hand side of binary operator expressions.

Given
void foo(bool a, bool b) {
  a || b;
}

The matcher binaryOperator(hasRHS(expr().bind("rhs")))
matches a || b,
with expr()
matching b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc5')"><a name="hasTypeLoc5Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc5"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyArgument2')"><a name="hasAnyArgument2Anchor">hasAnyArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyArgument2"><pre>Matches any argument of a call expression or a constructor call
expression, or an ObjC-message-send expression.

Given
  void x(int, int, int) { int y = 42; x(1, y, 42); }
The matcher
callExpr(hasAnyArgument(ignoringImplicit(declRefExpr()))) matches
x(1, y, 42) with hasAnyArgument(...)
  matching y

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end
  void foo(I *i) { [i f:12]; }

The matcher
objcMessageExpr(hasAnyArgument(integerLiteral(equals(12))))
matches [i f:12]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;</td><td class="name" onclick="toggle('hasArgument2')"><a name="hasArgument2Anchor">hasArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArgument2"><pre>Matches the n'th argument of a call expression or a constructor
call expression.

Given
  void x(int) { int y; x(y); }
The matcher callExpr(hasArgument(0, declRefExpr().bind("arg")))
matches x(y),
with declRefExpr() matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc6')"><a name="hasTypeLoc6Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc6"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('callee3')"><a name="callee3Anchor">callee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="callee3"><pre>Matches 1) if the call expression's callee's declaration matches the
given matcher; or 2) if the Obj-C message expression's callee's method
declaration matches the given matcher.

Example 1
  class Y { public: void x(); };
  void z() { Y y; y.x(); }

The matcher callExpr(callee(cxxMethodDecl(hasName("x"))))
matches y.x()

Example 2
  @interface I: NSObject
  +(void)foo;
  @end
  ...
  [I foo]

The matcher
objcMessageExpr(callee(objcMethodDecl(hasName("foo"))))
matches [I foo]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('callee0')"><a name="callee0Anchor">callee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="callee0"><pre>Matches if the call or fold expression's callee expression matches.

Given
  class Y { void x() { this-&gt;x(); x(); Y y; y.x(); } };
  void f() { f(); }

The matcher callExpr(callee(expr().bind("callee")))
matches this-&gt;x(), x(), y.x(), f()
with expr() inside of callee
matching this-&gt;x, x,
y.x, f respectively

Given
  struct Dummy {};
  // makes sure there is a callee, otherwise there would be no callee,
  // just a builtin operator
  Dummy operator+(Dummy, Dummy);
  // not defining a '*' operator

  template &lt;typename... Args&gt;
  auto sum(Args... args) {
      return (0 + ... + args);
  }

  template &lt;typename... Args&gt;
  auto multiply(Args... args) {
      return (args * ... * 1);
  }

The matcher cxxFoldExpr(callee(expr().bind("op")))
matches (0 + ... + args)
with callee(...) matching *,
but does not match (args * ... * 1).
A CXXFoldExpr only has an UnresolvedLookupExpr as a callee.
When there are no define operators that could be used instead of builtin
ones, then there will be no callee .

Note: Callee cannot take the more general internal::Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;
because this introduces ambiguous overloads with calls to Callee taking a
internal::Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;, as the matcher hierarchy is purely
implemented in terms of implicit casts.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('forEachArgumentWithParam0')"><a name="forEachArgumentWithParam0Anchor">forEachArgumentWithParam</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; ArgMatcher, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; ParamMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachArgumentWithParam0"><pre>Matches all arguments and their respective ParmVarDecl.

Given
  void f(int i);
  int y;
  void foo() {
    f(y);
  }
The matcher callExpr(
  forEachArgumentWithParam(
    declRefExpr(to(varDecl(hasName("y")))),
    parmVarDecl(hasType(isInteger()))
))
  matches f(y);
with declRefExpr(...)
  matching int y
and parmVarDecl(...)
  matching int i
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('forEachArgumentWithParamType0')"><a name="forEachArgumentWithParamType0Anchor">forEachArgumentWithParamType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; ArgMatcher, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; ParamMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachArgumentWithParamType0"><pre>Matches all arguments and their respective types for a CallExpr or
CXXConstructExpr. It is very similar to forEachArgumentWithParam but
it works on calls through function pointers as well.

The difference is, that function pointers do not provide access to a
ParmVarDecl, but only the QualType for each argument.

Given
  void f(int i);
  void foo(int y) {
    f(y);
    void (*f_ptr)(int) = f;
    f_ptr(y);
  }
The matcher callExpr(
  forEachArgumentWithParamType(
    declRefExpr(to(varDecl(hasName("y")))),
    qualType(isInteger()).bind("type")
))
  matches f(y) and f_ptr(y)
with declRefExpr(...)
  matching int y
and qualType(...)
  matching int
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyArgument0')"><a name="hasAnyArgument0Anchor">hasAnyArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyArgument0"><pre>Matches any argument of a call expression or a constructor call
expression, or an ObjC-message-send expression.

Given
  void x(int, int, int) { int y = 42; x(1, y, 42); }
The matcher
callExpr(hasAnyArgument(ignoringImplicit(declRefExpr()))) matches
x(1, y, 42) with hasAnyArgument(...)
  matching y

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end
  void foo(I *i) { [i f:12]; }

The matcher
objcMessageExpr(hasAnyArgument(integerLiteral(equals(12))))
matches [i f:12]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('hasArgument0')"><a name="hasArgument0Anchor">hasArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArgument0"><pre>Matches the n'th argument of a call expression or a constructor
call expression.

Given
  void x(int) { int y; x(y); }
The matcher callExpr(hasArgument(0, declRefExpr().bind("arg")))
matches x(y),
with declRefExpr() matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration14')"><a name="hasDeclaration14Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration14"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CaseStmt.html">CaseStmt</a>&gt;</td><td class="name" onclick="toggle('hasCaseConstant0')"><a name="hasCaseConstant0Anchor">hasCaseConstant</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCaseConstant0"><pre>If the given case statement does not use the GNU case range
extension, matches the constant given in the statement.

Given
  void foo() {
    switch (1) { case 1: break; case 1+1: break; case 3 ... 4: break; }
  }
The matcher
caseStmt(hasCaseConstant(constantExpr(has(integerLiteral()))))
matches case 1: break.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CastExpr.html">CastExpr</a>&gt;</td><td class="name" onclick="toggle('hasSourceExpression0')"><a name="hasSourceExpression0Anchor">hasSourceExpression</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSourceExpression0"><pre>Matches if the cast's source expression
or opaque value's source expression matches the given matcher.

Given
 struct URL { URL(const char*); };
 URL url = "a string";

The matcher castExpr(hasSourceExpression(cxxConstructExpr()))
matches "a string".

Given
void foo(bool b) {
  int a = b ?: 1;
}

The matcher
opaqueValueExpr(hasSourceExpression(
              implicitCastExpr(has(
                implicitCastExpr(has(declRefExpr()))))))
matches b twice, for the conditiona and the true expression.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('forEachTemplateArgument0')"><a name="forEachTemplateArgument0Anchor">forEachTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachTemplateArgument0"><pre>Matches templateSpecializationType, class template specialization,
variable template specialization, and function template specialization
nodes where the template argument matches the inner matcher. This matcher
may produce multiple matches.

Given
  template &lt;typename T, unsigned N, unsigned M&gt;
  struct Matrix {};

  constexpr unsigned R = 2;
  Matrix&lt;int, R * 2, R * 4&gt; M;

  template &lt;typename T, typename U&gt;
  void f(T&amp;&amp; t, U&amp;&amp; u) {}

  void foo() {
    bool B = false;
    f(R, B);
  }

The matcher
templateSpecializationType(forEachTemplateArgument(isExpr(expr().bind("t_arg"))))
matches Matrix&lt;int, R * 2, R * 4&gt; twice, with
expr() matching R * 2 and
R * 4.
The matcher
functionDecl(forEachTemplateArgument(refersToType(qualType().bind("type"))))
matches the specialization of f twice,
with qualType() matching
unsigned and
bool.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgumentLoc0')"><a name="hasAnyTemplateArgumentLoc0Anchor">hasAnyTemplateArgumentLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgumentLoc0"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
that have at least one `TemplateArgumentLoc` matching the given
`InnerMatcher`.

Given
  template&lt;typename T&gt; class A {};
  A&lt;int&gt; a;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc(
hasTypeLoc(loc(asString("int"))))))))) matches A&lt;int&gt; a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgument0')"><a name="hasAnyTemplateArgument0Anchor">hasAnyTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgument0"><pre>Matches templateSpecializationTypes, class template specializations,
variable template specializations, and function template specializations
that have at least one TemplateArgument matching the given InnerMatcher.

Given
  template&lt;typename T&gt; class A {};
  template&lt;&gt; class A&lt;double&gt; {};
  A&lt;int&gt; a;

  template&lt;typename T&gt; void f() {};
  void func() { f&lt;int&gt;(); };


The matcher classTemplateSpecializationDecl(
                        hasAnyTemplateArgument(
                          refersToType(asString("int"))))
matches class A&lt;int&gt;.

The matcher
functionDecl(hasAnyTemplateArgument(
              refersToType(asString("int"))))
matches the instantiation of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasSpecializedTemplate0')"><a name="hasSpecializedTemplate0Anchor">hasSpecializedTemplate</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSpecializedTemplate0"><pre>Matches the specialized template of a specialization declaration.

Given
  template&lt;typename T&gt; class A {}; // #1
  template&lt;&gt; class A&lt;int&gt; {}; // #2

The matcher
classTemplateSpecializationDecl(hasSpecializedTemplate(classTemplateDecl().bind("ctd")))
matches template&lt;&gt; class A&lt;int&gt; {},
with classTemplateDecl() matching the class template
declaration template &lt;typename T&gt; class A {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgumentLoc0')"><a name="hasTemplateArgumentLoc0Anchor">hasTemplateArgumentLoc</a></td><td>unsigned Index, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgumentLoc0"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
where the n'th `TemplateArgumentLoc` matches the given `InnerMatcher`.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,
hasTypeLoc(loc(asString("double")))))))))
matches A&lt;double, int&gt; b, but not double&gt; c}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgument0')"><a name="hasTemplateArgument0Anchor">hasTemplateArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgument0"><pre>Matches templateSpecializationType, class template specializations,
variable template specializations, and function template specializations
where the n'th TemplateArgument matches the given InnerMatcher.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

  template&lt;typename T&gt; void f() {}
  void func() { f&lt;int&gt;(); };

The matcher
classTemplateSpecializationDecl(hasTemplateArgument(
    1, refersToType(asString("int"))))
matches the specialization class A&lt;double, int&gt;.

The matcher functionDecl(hasTemplateArgument(0,
                        refersToType(asString("int"))))
matches the specialization of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ComplexType.html">ComplexType</a>&gt;</td><td class="name" onclick="toggle('hasElementType1')"><a name="hasElementType1Anchor">hasElementType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasElementType1"><pre>Matches arrays and C99 complex types that have a specific element
type.

Given
  struct A {};
  A a[7];
  int b[7];


The matcher arrayType(hasElementType(builtinType()))
int[7]

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ArrayType.html">ArrayType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ComplexType.html">ComplexType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc7')"><a name="hasTypeLoc7Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc7"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html">CompoundStmt</a>&gt;</td><td class="name" onclick="toggle('hasAnySubstatement0')"><a name="hasAnySubstatement0Anchor">hasAnySubstatement</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnySubstatement0"><pre>Matches compound statements where at least one substatement matches
a given matcher. Also matches StmtExprs that have CompoundStmt as children.

Given
void foo() { { {}; 1+2; } }
The matcher
compoundStmt(hasAnySubstatement(compoundStmt().bind("compound")))
{ {}; 1+2; } and { { {}; 1+2; } }
with compoundStmt()
matching {} and { {}; 1+2; }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CoroutineBodyStmt.html">CoroutineBodyStmt</a>&gt;</td><td class="name" onclick="toggle('hasBody5')"><a name="hasBody5Anchor">hasBody</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody5"><pre>Matches a 'for', 'while', 'while' statement or a function or coroutine
definition that has a given body. Note that in case of functions or
coroutines this matcher only matches the definition itself and not the
other declarations of the same function or coroutine.

Given
void foo() {
  for (;;) {}
}
The matcher forStmt(hasBody(compoundStmt().bind("body")))
matches for (;;) {}
with compoundStmt()
  matching {}

Given
  void f();
  void f() {}
The matcher functionDecl(hasBody(compoundStmt().bind("compound")))
f
with compoundStmt()
matching {}
but does not match void f();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecayedType.html">DecayedType</a>&gt;</td><td class="name" onclick="toggle('hasDecayedType0')"><a name="hasDecayedType0Anchor">hasDecayedType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerType</td></tr>
<tr><td colspan="4" class="doc" id="hasDecayedType0"><pre>Matches the decayed type, whoes decayed type matches InnerMatcher

Given
  void f(int i[]) {
    i[1] = 0;
  }

The matcher parmVarDecl(hasType(decayedType()))
matches int i[].
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgumentLoc3')"><a name="hasAnyTemplateArgumentLoc3Anchor">hasAnyTemplateArgumentLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgumentLoc3"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
that have at least one `TemplateArgumentLoc` matching the given
`InnerMatcher`.

Given
  template&lt;typename T&gt; class A {};
  A&lt;int&gt; a;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc(
hasTypeLoc(loc(asString("int"))))))))) matches A&lt;int&gt; a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration11')"><a name="hasDeclaration11Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration11"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgumentLoc3')"><a name="hasTemplateArgumentLoc3Anchor">hasTemplateArgumentLoc</a></td><td>unsigned Index, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgumentLoc3"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
where the n'th `TemplateArgumentLoc` matches the given `InnerMatcher`.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,
hasTypeLoc(loc(asString("double")))))))))
matches A&lt;double, int&gt; b, but not double&gt; c}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;</td><td class="name" onclick="toggle('throughUsingDecl0')"><a name="throughUsingDecl0Anchor">throughUsingDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="throughUsingDecl0"><pre>Matches if a node refers to a declaration through a specific
using shadow declaration.

Given
  namespace a { int f(); }
  using a::f;
  int x = f();

The matcher declRefExpr(throughUsingDecl(anything()))
matches f

  namespace a { class X{}; }
  using a::X;
  X x;

The matcher typeLoc(loc(usingType(throughUsingDecl(anything()))))
matches X

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingType.html">UsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;</td><td class="name" onclick="toggle('to0')"><a name="to0Anchor">to</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="to0"><pre>Matches a DeclRefExpr that refers to a declaration that matches the
specified matcher.

Given
  void foo() {
    bool x;
    if (x) {}
  }

The matcher declRefExpr(to(varDecl(hasName("x"))))
matches x inside the condition of the if-stmt.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html">DeclStmt</a>&gt;</td><td class="name" onclick="toggle('containsDeclaration0')"><a name="containsDeclaration0Anchor">containsDeclaration</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="containsDeclaration0"><pre>Matches the n'th declaration of a declaration statement.

Note that this does not work for global declarations because the AST
breaks up multiple-declaration DeclStmt's into multiple single-declaration
DeclStmt's.

Given non-global declarations
  void foo() {
    int a, b = 0;
    int c;
    int d = 2, e;
  }
The matcher declStmt(containsDeclaration(
      0, varDecl(hasInitializer(anything()))))
matches int d = 2, e;.
The matcher declStmt(containsDeclaration(1, varDecl()))
matches int a, b = 0; and int d = 2, e;
but does not match int c;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html">DeclStmt</a>&gt;</td><td class="name" onclick="toggle('hasSingleDecl0')"><a name="hasSingleDecl0Anchor">hasSingleDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSingleDecl0"><pre>Matches the Decl of a DeclStmt which has a single declaration.

Given
  void foo() {
    int a, b;
    int c;
  }
The matcher declStmt(hasSingleDecl(anything()))
matches int c;
but does not match int a, b;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc8')"><a name="hasTypeLoc8Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc8"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;</td><td class="name" onclick="toggle('hasDeclContext0')"><a name="hasDeclContext0Anchor">hasDeclContext</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclContext0"><pre>Matches declarations whose declaration context, interpreted as a
Decl, matches InnerMatcher.

Given
  namespace N {
    namespace M {
      class D {};
    }
  }


The matcher cxxRecordDecl(hasDeclContext(namedDecl(hasName("M"))))
  matches the declaration of D.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecltypeType.html">DecltypeType</a>&gt;</td><td class="name" onclick="toggle('hasUnderlyingType0')"><a name="hasUnderlyingType0Anchor">hasUnderlyingType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasUnderlyingType0"><pre>Matches DecltypeType or UsingType nodes to find the underlying type.

Given
  decltype(1) a = 1;
  decltype(2.0) b = 2.0;


The matcher decltypeType(hasUnderlyingType(isInteger()))
matches the type decltype(1) of the variable
declaration of a .

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecltypeType.html">DecltypeType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingType.html">UsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecompositionDecl.html">DecompositionDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyBinding0')"><a name="hasAnyBinding0Anchor">hasAnyBinding</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BindingDecl.html">BindingDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyBinding0"><pre>Matches any binding of a DecompositionDecl.

For example, in:
void foo()
{
    int arr[3];
    auto &amp;[f, s, t] = arr;

    f = 42;
}

The matcher
 decompositionDecl(hasAnyBinding(bindingDecl(hasName("f")).bind("fBinding")))
matches auto &amp;[f, s, t] = arr with 'f' bound to "fBinding".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecompositionDecl.html">DecompositionDecl</a>&gt;</td><td class="name" onclick="toggle('hasBinding0')"><a name="hasBinding0Anchor">hasBinding</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BindingDecl.html">BindingDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBinding0"><pre>Matches the Nth binding of a DecompositionDecl.

Given
void foo()
{
    int arr[3];
    auto &amp;[f, s, t] = arr;

    f = 42;
}

The matcher decompositionDecl(hasBinding(0,
  bindingDecl(hasName("f")).bind("fBinding")))
matches auto &amp;[f, s, t] = arr with 'f' bound to "fBinding".
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DoStmt.html">DoStmt</a>&gt;</td><td class="name" onclick="toggle('hasBody0')"><a name="hasBody0Anchor">hasBody</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody0"><pre>Matches a 'for', 'while', 'while' statement or a function or coroutine
definition that has a given body. Note that in case of functions or
coroutines this matcher only matches the definition itself and not the
other declarations of the same function or coroutine.

Given
void foo() {
  for (;;) {}
}
The matcher forStmt(hasBody(compoundStmt().bind("body")))
matches for (;;) {}
with compoundStmt()
  matching {}

Given
  void f();
  void f() {}
The matcher functionDecl(hasBody(compoundStmt().bind("compound")))
f
with compoundStmt()
matching {}
but does not match void f();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DoStmt.html">DoStmt</a>&gt;</td><td class="name" onclick="toggle('hasCondition3')"><a name="hasCondition3Anchor">hasCondition</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition3"><pre>Matches the condition expression of an if statement, for loop,
switch statement or conditional operator.

Given
void foo() {
  if (true) {}
}

The matcher ifStmt(hasCondition(cxxBoolLiteral(equals(true))))
if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ElaboratedTypeLoc.html">ElaboratedTypeLoc</a>&gt;</td><td class="name" onclick="toggle('hasNamedTypeLoc0')"><a name="hasNamedTypeLoc0Anchor">hasNamedTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasNamedTypeLoc0"><pre>Matches elaborated `TypeLoc`s that have a named `TypeLoc` matching
`InnerMatcher`.

Given
  template &lt;typename T&gt;
  class C {};
  class C&lt;int&gt; c;

  class D {};
  class D d;

The matcher
elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc()))
  matches class C&lt;int&gt;, but not D}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ElaboratedType.html">ElaboratedType</a>&gt;</td><td class="name" onclick="toggle('hasQualifier0')"><a name="hasQualifier0Anchor">hasQualifier</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasQualifier0"><pre>Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,
  matches InnerMatcher if the qualifier exists.

Given
  namespace N {
    namespace M {
      class D {};
    }
  }
  N::M::D d;


The matcher
elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName("N")))))
  matches the type N::M::D of the variable declaration
  of d.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ElaboratedType.html">ElaboratedType</a>&gt;</td><td class="name" onclick="toggle('namesType0')"><a name="namesType0Anchor">namesType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="namesType0"><pre>Matches ElaboratedTypes whose named type matches InnerMatcher.

Given
  namespace N {
    namespace M {
      enum E { Ok };
    }
  }
  N::M::E e = N::M::Ok;


The matcher elaboratedType(namesType(enumType()))
matches the type N::M::E of the declaration of e .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration10')"><a name="hasDeclaration10Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration10"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;</td><td class="name" onclick="toggle('hasDestinationType0')"><a name="hasDestinationType0Anchor">hasDestinationType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDestinationType0"><pre>Matches casts whose destination type matches a given matcher.

(Note: Clang's AST refers to other conversions as "casts" too, and calls
actual casts "explicit" casts.)

  unsigned int a = (unsigned int)0;

The matcher explicitCastExpr(hasDestinationType(
qualType(isUnsignedInteger()))) matches (unsigned int)0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc9')"><a name="hasTypeLoc9Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc9"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('hasType5')"><a name="hasType5Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType5"><pre>Overloaded to match the declaration of the expression's or value
declaration's type.

In case of a value declaration (for example a variable declaration),
this resolves one layer of indirection. For example, in the value
declaration "X x;", cxxRecordDecl(hasName("X")) matches the declaration of
X, while varDecl(hasType(cxxRecordDecl(hasName("X")))) matches the
declaration of x.

 class X {};
 void y(X &amp;x) { x; X z; }
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z.
The matcher friendDecl(hasType(asString("class X")))
matches friend class X.
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches
class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.

Given
class Base {};
class Derived : Base {};

The matcher
cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName("Base")))))
matches class Derived : Base {}.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FriendDecl.html">FriendDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt;,
Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('hasType0')"><a name="hasType0Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType0"><pre>Matches if the expression's or declaration's type matches a type
matcher.

Exmaple
 class X {};
 void y(X &amp;x) { x; X z; }
 typedef int U;
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z
The matcher typedefDecl(hasType(asString("int")))
matches typedef int U
The matcher friendDecl(hasType(asString("class X")))
matches friend class X
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('ignoringElidableConstructorCall0')"><a name="ignoringElidableConstructorCall0Anchor">ignoringElidableConstructorCall</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringElidableConstructorCall0"><pre>Matches expressions that match InnerMatcher that are possibly wrapped in an
elidable constructor and other corresponding bookkeeping nodes.

In C++17, elidable copy constructors are no longer being generated in the
AST as it is not permitted by the standard. They are, however, part of the
AST in C++14 and earlier. So, a matcher must abstract over these differences
to work in all language modes. This matcher skips elidable constructor-call
AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and
various implicit nodes inside the constructor calls, all of which will not
appear in the C++17 AST.

Given
struct H {};
H G();
void f() {
  H D = G();
}


The matcher
varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))
matches H D = G().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('ignoringImpCasts0')"><a name="ignoringImpCasts0Anchor">ignoringImpCasts</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringImpCasts0"><pre>Matches expressions that match InnerMatcher after any implicit casts
are stripped off.

Parentheses and explicit casts are not discarded.
Given
  int arr[5];
  const int a = 0;
  char b = 0;
  const int c = a;
  int *d = arr;
  long e = (long) 0l;
The matcher
varDecl(hasInitializer(ignoringImpCasts(integerLiteral())))
matches a and b,
but does not match e.
The matcher
varDecl(hasInitializer(ignoringImpCasts(declRefExpr())))
matches c and d.

The matcher
varDecl(hasInitializer(integerLiteral()))
matches a,
but does not match b or e.
The matcher varDecl(hasInitializer(declRefExpr()))
does not match c or d.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('ignoringImplicit0')"><a name="ignoringImplicit0Anchor">ignoringImplicit</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringImplicit0"><pre>Matches expressions that match InnerMatcher after any implicit AST
nodes are stripped off.

Parentheses and explicit casts are not discarded.

Given
  void f(int param) {
    int a = 0;
    int b = param;
    const int c = 0;
    const int d = param;
    int e = (0U);
    int f = (int)0.0;
    const int g = ((int)(((0))));
  }

The matcher
varDecl(hasInitializer(ignoringImplicit(integerLiteral())))
matches int a = 0 and const int c = 0,
but not int e = (0U) and ((int)(((0))).
The matcher
varDecl(hasInitializer(integerLiteral()))
matches int a = 0 and const int c = 0,
but not int e = (0U) and ((int)(((0))).

The matcher
varDecl(hasInitializer(ignoringImplicit(declRefExpr())))
matches int b = param and const int d = param.
The matcher
varDecl(hasInitializer(declRefExpr()))
matches neither int b = param nor const int d = param,
because an l-to-r-value cast happens.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('ignoringParenCasts0')"><a name="ignoringParenCasts0Anchor">ignoringParenCasts</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringParenCasts0"><pre>Matches expressions that match InnerMatcher after parentheses and
casts are stripped off.

Implicit and non-C Style casts are also discarded.
Given
  int a = 0;
  char b = (0);
  void* c = reinterpret_cast&lt;char*&gt;(0);
  char d = char(0);

The matcher
varDecl(hasInitializer(ignoringParenCasts(integerLiteral())))
matches a, b, c
and d.
The matcher
varDecl(hasInitializer(integerLiteral()))
matches a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('ignoringParenImpCasts0')"><a name="ignoringParenImpCasts0Anchor">ignoringParenImpCasts</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringParenImpCasts0"><pre>Matches expressions that match InnerMatcher after implicit casts and
parentheses are stripped off.

Explicit casts are not discarded.
Given
  int arr[5];
  int a = 0;
  char b = (0);
  const int c = a;
  int *d = (arr);
  long e = ((long) 0l);

The matcher
varDecl(hasInitializer(ignoringParenImpCasts(integerLiteral())))
matches a and b,
but does not match e.
The matcher
varDecl(hasInitializer(ignoringParenImpCasts(declRefExpr())))
matches c and d.

The matcher
varDecl(hasInitializer(integerLiteral()))
matches a,
but does not match b or e.
The matcher varDecl(hasInitializer(declRefExpr()))
does not match c, or d.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;</td><td class="name" onclick="toggle('ignoringParens1')"><a name="ignoringParens1Anchor">ignoringParens</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringParens1"><pre>Overload ignoringParens for Expr.

Given
  const char* str = ("my-string");
The matcher
implicitCastExpr(hasSourceExpression(ignoringParens(stringLiteral())))
would match the implicit cast resulting from the assignment
("my-string").
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FieldDecl.html">FieldDecl</a>&gt;</td><td class="name" onclick="toggle('hasInClassInitializer0')"><a name="hasInClassInitializer0Anchor">hasInClassInitializer</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasInClassInitializer0"><pre>Matches non-static data members that have an in-class initializer.

Given
  class C {
    int a = 2;
    int b = 3;
    int c;
  };

The matcher
fieldDecl(hasInClassInitializer(integerLiteral(equals(2))))
matches a,
but does not match b.
The matcher fieldDecl(hasInClassInitializer(anything()))
matches a and b,
but does not match c.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ForStmt.html">ForStmt</a>&gt;</td><td class="name" onclick="toggle('hasBody1')"><a name="hasBody1Anchor">hasBody</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody1"><pre>Matches a 'for', 'while', 'while' statement or a function or coroutine
definition that has a given body. Note that in case of functions or
coroutines this matcher only matches the definition itself and not the
other declarations of the same function or coroutine.

Given
void foo() {
  for (;;) {}
}
The matcher forStmt(hasBody(compoundStmt().bind("body")))
matches for (;;) {}
with compoundStmt()
  matching {}

Given
  void f();
  void f() {}
The matcher functionDecl(hasBody(compoundStmt().bind("compound")))
f
with compoundStmt()
matching {}
but does not match void f();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ForStmt.html">ForStmt</a>&gt;</td><td class="name" onclick="toggle('hasCondition1')"><a name="hasCondition1Anchor">hasCondition</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition1"><pre>Matches the condition expression of an if statement, for loop,
switch statement or conditional operator.

Given
void foo() {
  if (true) {}
}

The matcher ifStmt(hasCondition(cxxBoolLiteral(equals(true))))
if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ForStmt.html">ForStmt</a>&gt;</td><td class="name" onclick="toggle('hasIncrement0')"><a name="hasIncrement0Anchor">hasIncrement</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasIncrement0"><pre>Matches the increment statement of a for loop.

Given
void foo(int N) {
    for (int x = 0; x &lt; N; ++x) { }
}
The matcher
forStmt(hasIncrement(unaryOperator(hasOperatorName("++"))))
matches for (int x = 0; x &lt; N; ++x) { }
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ForStmt.html">ForStmt</a>&gt;</td><td class="name" onclick="toggle('hasLoopInit0')"><a name="hasLoopInit0Anchor">hasLoopInit</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasLoopInit0"><pre>Matches the initialization statement of a for loop.

Given
void foo(int N) {
    for (int x = 0; x &lt; N; ++x) { }
}
The matcher forStmt(hasLoopInit(declStmt()))
matches for (int x = 0; x &lt; N; ++x) { }
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FriendDecl.html">FriendDecl</a>&gt;</td><td class="name" onclick="toggle('hasType6')"><a name="hasType6Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType6"><pre>Overloaded to match the declaration of the expression's or value
declaration's type.

In case of a value declaration (for example a variable declaration),
this resolves one layer of indirection. For example, in the value
declaration "X x;", cxxRecordDecl(hasName("X")) matches the declaration of
X, while varDecl(hasType(cxxRecordDecl(hasName("X")))) matches the
declaration of x.

 class X {};
 void y(X &amp;x) { x; X z; }
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z.
The matcher friendDecl(hasType(asString("class X")))
matches friend class X.
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches
class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.

Given
class Base {};
class Derived : Base {};

The matcher
cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName("Base")))))
matches class Derived : Base {}.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FriendDecl.html">FriendDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt;,
Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FriendDecl.html">FriendDecl</a>&gt;</td><td class="name" onclick="toggle('hasType1')"><a name="hasType1Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType1"><pre>Matches if the expression's or declaration's type matches a type
matcher.

Exmaple
 class X {};
 void y(X &amp;x) { x; X z; }
 typedef int U;
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z
The matcher typedefDecl(hasType(asString("int")))
matches typedef int U
The matcher friendDecl(hasType(asString("class X")))
matches friend class X
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('forEachTemplateArgument2')"><a name="forEachTemplateArgument2Anchor">forEachTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachTemplateArgument2"><pre>Matches templateSpecializationType, class template specialization,
variable template specialization, and function template specialization
nodes where the template argument matches the inner matcher. This matcher
may produce multiple matches.

Given
  template &lt;typename T, unsigned N, unsigned M&gt;
  struct Matrix {};

  constexpr unsigned R = 2;
  Matrix&lt;int, R * 2, R * 4&gt; M;

  template &lt;typename T, typename U&gt;
  void f(T&amp;&amp; t, U&amp;&amp; u) {}

  void foo() {
    bool B = false;
    f(R, B);
  }

The matcher
templateSpecializationType(forEachTemplateArgument(isExpr(expr().bind("t_arg"))))
matches Matrix&lt;int, R * 2, R * 4&gt; twice, with
expr() matching R * 2 and
R * 4.
The matcher
functionDecl(forEachTemplateArgument(refersToType(qualType().bind("type"))))
matches the specialization of f twice,
with qualType() matching
unsigned and
bool.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyBody0')"><a name="hasAnyBody0Anchor">hasAnyBody</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyBody0"><pre>Matches a function declaration that has a given body present in the AST.
Note that this matcher matches all the declarations of a function whose
body is present in the AST.

Given
  void f();
  void f() {}
  void g();
The matcher functionDecl(hasAnyBody(compoundStmt()))
  matches f
  and f
with compoundStmt()
  matching {}
  but does not match void g();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyParameter0')"><a name="hasAnyParameter0Anchor">hasAnyParameter</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyParameter0"><pre>Matches any parameter of a function or an ObjC method declaration or a
block.

Does not match the 'this' parameter of a method.

Given
  class X { void f(int x, int y, int z) {} };

The matcher cxxMethodDecl(hasAnyParameter(hasName("y")))
  matches f
with hasAnyParameter(...)
  matching int y

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end


the matcher objcMethodDecl(hasAnyParameter(hasName("y")))
  matches the declaration of method f with hasParameter
matching y.

For blocks, given
  b = ^(int y) { printf("%d", y) };


the matcher blockDecl(hasAnyParameter(hasName("y")))
  matches the declaration of the block b with hasParameter
matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgumentLoc2')"><a name="hasAnyTemplateArgumentLoc2Anchor">hasAnyTemplateArgumentLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgumentLoc2"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
that have at least one `TemplateArgumentLoc` matching the given
`InnerMatcher`.

Given
  template&lt;typename T&gt; class A {};
  A&lt;int&gt; a;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc(
hasTypeLoc(loc(asString("int"))))))))) matches A&lt;int&gt; a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgument2')"><a name="hasAnyTemplateArgument2Anchor">hasAnyTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgument2"><pre>Matches templateSpecializationTypes, class template specializations,
variable template specializations, and function template specializations
that have at least one TemplateArgument matching the given InnerMatcher.

Given
  template&lt;typename T&gt; class A {};
  template&lt;&gt; class A&lt;double&gt; {};
  A&lt;int&gt; a;

  template&lt;typename T&gt; void f() {};
  void func() { f&lt;int&gt;(); };


The matcher classTemplateSpecializationDecl(
                        hasAnyTemplateArgument(
                          refersToType(asString("int"))))
matches class A&lt;int&gt;.

The matcher
functionDecl(hasAnyTemplateArgument(
              refersToType(asString("int"))))
matches the instantiation of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasBody4')"><a name="hasBody4Anchor">hasBody</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody4"><pre>Matches a 'for', 'while', 'while' statement or a function or coroutine
definition that has a given body. Note that in case of functions or
coroutines this matcher only matches the definition itself and not the
other declarations of the same function or coroutine.

Given
void foo() {
  for (;;) {}
}
The matcher forStmt(hasBody(compoundStmt().bind("body")))
matches for (;;) {}
with compoundStmt()
  matching {}

Given
  void f();
  void f() {}
The matcher functionDecl(hasBody(compoundStmt().bind("compound")))
f
with compoundStmt()
matching {}
but does not match void f();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasExplicitSpecifier0')"><a name="hasExplicitSpecifier0Anchor">hasExplicitSpecifier</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasExplicitSpecifier0"><pre>Matches the expression in an explicit specifier if present in the given
declaration.

Given
  template&lt;bool b&gt;
  struct S {
    S(int); // #1
    explicit S(double); // #2
    operator int(); // #3
    explicit operator bool(); // #4
    explicit(false) S(bool); // # 7
    explicit(true) S(char); // # 8
    explicit(b) S(float); // # 9
  };
  S(int) -&gt; S&lt;true&gt;; // #5
  explicit S(double) -&gt; S&lt;false&gt;; // #6

The matcher
cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) matches
explicit(false) S(bool) and explicit(true) S(char),
but does not match explicit(b) S(float), S(int) or
explicit S(double).
The matcher
cxxConversionDecl(hasExplicitSpecifier(constantExpr())) does not
match operator int() or explicit operator bool().
Matcher
The matcher
cxxDeductionGuideDecl(hasExplicitSpecifier(declRefExpr()))
matches the implicitly generated deduction guide
auto (float) -&gt; S&lt;b&gt; of the constructor
S(float)}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasParameter0')"><a name="hasParameter0Anchor">hasParameter</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasParameter0"><pre>Matches the n'th parameter of a function or an ObjC method
declaration or a block.

Given
  class X { void f(int x) {} };

The matcher
cxxMethodDecl(hasParameter(0, hasType(asString("int"))))
matches f
with hasParameter(...)
matching int x.

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end


The matcher objcMethodDecl(hasParameter(0, hasName("y")))
matches the declaration of method f with hasParameter
matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasReturnTypeLoc0')"><a name="hasReturnTypeLoc0Anchor">hasReturnTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; ReturnMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasReturnTypeLoc0"><pre>Matches a function declared with the specified return `TypeLoc`.

Given
  int f() { return 5; }
  void g() {}
The matcher functionDecl(hasReturnTypeLoc(loc(asString("int"))))
  matches the declaration of f, but not
  </pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgumentLoc2')"><a name="hasTemplateArgumentLoc2Anchor">hasTemplateArgumentLoc</a></td><td>unsigned Index, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgumentLoc2"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
where the n'th `TemplateArgumentLoc` matches the given `InnerMatcher`.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,
hasTypeLoc(loc(asString("double")))))))))
matches A&lt;double, int&gt; b, but not double&gt; c}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgument2')"><a name="hasTemplateArgument2Anchor">hasTemplateArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgument2"><pre>Matches templateSpecializationType, class template specializations,
variable template specializations, and function template specializations
where the n'th TemplateArgument matches the given InnerMatcher.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

  template&lt;typename T&gt; void f() {}
  void func() { f&lt;int&gt;(); };

The matcher
classTemplateSpecializationDecl(hasTemplateArgument(
    1, refersToType(asString("int"))))
matches the specialization class A&lt;double, int&gt;.

The matcher functionDecl(hasTemplateArgument(0,
                        refersToType(asString("int"))))
matches the specialization of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt;</td><td class="name" onclick="toggle('returns0')"><a name="returns0Anchor">returns</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="returns0"><pre>Matches the return type of a function declaration.

Given
  class X { int f() { return 1; } };

The matcher cxxMethodDecl(returns(asString("int")))
  matches f
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;</td><td class="name" onclick="toggle('hasCondition0')"><a name="hasCondition0Anchor">hasCondition</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition0"><pre>Matches the condition expression of an if statement, for loop,
switch statement or conditional operator.

Given
void foo() {
  if (true) {}
}

The matcher ifStmt(hasCondition(cxxBoolLiteral(equals(true))))
if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;</td><td class="name" onclick="toggle('hasConditionVariableStatement0')"><a name="hasConditionVariableStatement0Anchor">hasConditionVariableStatement</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html">DeclStmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasConditionVariableStatement0"><pre>Matches the condition variable statement in an if statement.

Given
struct A {};
A* GetAPointer();
void foo() {
  if (A* a = GetAPointer()) {}
}

The matcher ifStmt(hasConditionVariableStatement(declStmt()))
if (A* a = GetAPointer()) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;</td><td class="name" onclick="toggle('hasElse0')"><a name="hasElse0Anchor">hasElse</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasElse0"><pre>Matches the else-statement of an if statement.

Given
void foo() {
  if (false) false; else true;
}

The matcher ifStmt(hasElse(cxxBoolLiteral(equals(true))))
if (false) false; else true
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;</td><td class="name" onclick="toggle('hasInitStatement0')"><a name="hasInitStatement0Anchor">hasInitStatement</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasInitStatement0"><pre>Matches selection statements with initializer.

Given
 struct vec { int* begin(); int* end(); };
 int foobar();
 vec&amp; get_range();
 void foo() {
   if (int i = foobar(); i &gt; 0) {}
   switch (int i = foobar(); i) {}
   for (auto&amp; a = get_range(); auto&amp; x : a) {}
 }
 void bar() {
   if (foobar() &gt; 0) {}
   switch (foobar()) {}
   for (auto&amp; x : get_range()) {}
 }

The matcher ifStmt(hasInitStatement(anything()))
  matches the if statement if (int i = foobar(); i &gt; 0) {}
  in foo but not if (foobar() &gt; 0) {} in bar.
The matcher switchStmt(hasInitStatement(anything()))
  matches the switch statement switch (int i = foobar(); i) {}
  in foo but not switch (foobar()) {} in bar.
The matcher cxxForRangeStmt(hasInitStatement(anything()))
  matches the range for statement
  for (auto&amp; a = get_range(); auto&amp; x : a) {} in foo
  but not for (auto&amp; x : get_range()) {} in bar.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1IfStmt.html">IfStmt</a>&gt;</td><td class="name" onclick="toggle('hasThen0')"><a name="hasThen0Anchor">hasThen</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasThen0"><pre>Matches the then-statement of an if statement.

Given
void foo() {
  if (false) true; else false;
}

The matcher ifStmt(hasThen(cxxBoolLiteral(equals(true))))
if (false) true; else false
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a>&gt;</td><td class="name" onclick="toggle('hasImplicitDestinationType0')"><a name="hasImplicitDestinationType0Anchor">hasImplicitDestinationType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasImplicitDestinationType0"><pre>Matches implicit casts whose destination type matches a given
matcher.

Given
  unsigned int a = 0;

The matcher
implicitCastExpr(hasImplicitDestinationType(
qualType(isUnsignedInteger()))) matches 0.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InitListExpr.html">InitListExpr</a>&gt;</td><td class="name" onclick="toggle('hasInit0')"><a name="hasInit0Anchor">hasInit</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasInit0"><pre>Matches the n'th item of an initializer list expression.

Given
  int y = 42;
  int x{y};

The matcher initListExpr(hasInit(0, expr()))
matches {y}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InitListExpr.html">InitListExpr</a>&gt;</td><td class="name" onclick="toggle('hasSyntacticForm0')"><a name="hasSyntacticForm0Anchor">hasSyntacticForm</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSyntacticForm0"><pre>Matches the syntactic form of init list expressions
(if expression have it).

Given
  int a[] = { 1, 2 };
  struct B { int x, y; };
  struct B b = { 5, 6 };


The matcher
initListExpr(hasSyntacticForm(expr().bind("syntactic")))
matches { 1, 2 } and { 5, 6 }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration9')"><a name="hasDeclaration9Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration9"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration8')"><a name="hasDeclaration8Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration8"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt;</td><td class="name" onclick="toggle('capturesVar0')"><a name="capturesVar0Anchor">capturesVar</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="capturesVar0"><pre>Matches a `LambdaCapture` that refers to the specified `VarDecl`. The
`VarDecl` can be a separate variable that is captured by value or
reference, or a synthesized variable if the capture has an initializer.

Given
  void foo() {
    int x;
    auto f = [x](){};
    auto g = [x = 1](){};
  }

The matcher
lambdaExpr(hasAnyCapture(
    lambdaCapture(capturesVar(hasName("x"))).bind("capture")))
matches [x](){} and [x = 1](){}, with
lambdaCapture(capturesVar(hasName("x"))).bind("capture")
matching x and x = 1.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaExpr.html">LambdaExpr</a>&gt;</td><td class="name" onclick="toggle('forEachLambdaCapture0')"><a name="forEachLambdaCapture0Anchor">forEachLambdaCapture</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachLambdaCapture0"><pre>Matches each lambda capture in a lambda expression.

Given
  int main() {
    int x;
    int y;
    float z;
    auto f = [=]() { return x + y + z; };
  }

The matcher lambdaExpr(forEachLambdaCapture(
    lambdaCapture(capturesVar(
    varDecl(hasType(isInteger())).bind("captured")))))
matches [=]() { return x + y + z; } two times,
with varDecl(hasType(isInteger())) matching
int x and int y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaExpr.html">LambdaExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyCapture0')"><a name="hasAnyCapture0Anchor">hasAnyCapture</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyCapture0"><pre>Matches any capture in a lambda expression.

Given
  void foo() {
    int t = 5;
    auto f = [=](){ return t; };
  }

The matcher lambdaExpr(hasAnyCapture(lambdaCapture())) and
lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName("t")))))
  both match [=](){ return t; }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration7')"><a name="hasDeclaration7Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration7"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;</td><td class="name" onclick="toggle('hasObjectExpression0')"><a name="hasObjectExpression0Anchor">hasObjectExpression</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasObjectExpression0"><pre>Matches a member expression where the object expression is matched by a
given matcher. Implicit object expressions are included; that is, it matches
use of implicit `this`.

Given
  struct X {
    int m;
    int f(X x) { x.m; return m; }
  };


The matcher
memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName("X")))))
matches x.m, but not m; however,
The matcher memberExpr(hasObjectExpression(hasType(pointsTo(
cxxRecordDecl(hasName("X"))))))
matches m (aka. this-&gt;m), but not x.m.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;</td><td class="name" onclick="toggle('member0')"><a name="member0Anchor">member</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="member0"><pre>Matches a member expression where the member is matched by a
given matcher.

Given
  struct { int first = 0, second = 1; } first, second;
  int i = second.first;
  int j = first.second;


The matcher memberExpr(member(hasName("first")))
matches second.first
but not </pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberPointerType.html">MemberPointerType</a>&gt;</td><td class="name" onclick="toggle('pointee1')"><a name="pointee1Anchor">pointee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="pointee1"><pre>Narrows PointerType (and similar) matchers to those where the
pointee matches a given matcher.

Given
  int *a;
  const int *b;
  int * const c = nullptr;
  const float *f;

The matcher pointerType(pointee(isConstQualified(), isInteger()))
matches const int *,
but does not match int * const
or const float *.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockPointerType.html">BlockPointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberPointerType.html">MemberPointerType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerType.html">PointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceType.html">ReferenceType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt;</td><td class="name" onclick="toggle('hasUnderlyingDecl0')"><a name="hasUnderlyingDecl0Anchor">hasUnderlyingDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasUnderlyingDecl0"><pre>Matches a NamedDecl whose underlying declaration matches the given
matcher.

Given
  namespace N { template&lt;class T&gt; void f(T t); }
  template &lt;class T&gt; void g() { using N::f; f(T()); }

The matcher unresolvedLookupExpr(hasAnyDeclaration(
    namedDecl(hasUnderlyingDecl(hasName("::N::f")))))
  matches f in g().
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;</td><td class="name" onclick="toggle('hasPrefix1')"><a name="hasPrefix1Anchor">hasPrefix</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasPrefix1"><pre>Matches on the prefix of a NestedNameSpecifierLoc.

Given
  struct A { struct B { struct C {}; }; };
  A::B::C c;

The matcher
nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString(
"struct A"))))) matches A::B::.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;</td><td class="name" onclick="toggle('loc1')"><a name="loc1Anchor">loc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="loc1"><pre>Matches NestedNameSpecifierLocs for which the given inner
NestedNameSpecifier-matcher matches.

Given
  namespace ns {
    struct A { static void f(); };
    void A::f() {}
    void g() { A::f(); }
  }
  ns::A a;


The matcher nestedNameSpecifierLoc(loc(specifiesType(
hasDeclaration(namedDecl(hasName("A")))))) matches A::
twice.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;</td><td class="name" onclick="toggle('specifiesTypeLoc0')"><a name="specifiesTypeLoc0Anchor">specifiesTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="specifiesTypeLoc0"><pre>Matches nested name specifier locs that specify a type matching the
given TypeLoc.

Given
  struct A { struct B { struct C {}; }; };
  A::B::C c;

The matcher nestedNameSpecifierLoc(specifiesTypeLoc(loc(qualType(
  hasDeclaration(cxxRecordDecl(hasName("A")))))))
matches A::
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;</td><td class="name" onclick="toggle('hasPrefix0')"><a name="hasPrefix0Anchor">hasPrefix</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasPrefix0"><pre>Matches on the prefix of a NestedNameSpecifier.

Given
  struct A { struct B { struct C {}; }; };
  A::B::C c;

The matcher
nestedNameSpecifier(hasPrefix(specifiesType(asString(
"struct A")))) matches struct A::B
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;</td><td class="name" onclick="toggle('specifiesNamespace0')"><a name="specifiesNamespace0Anchor">specifiesNamespace</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamespaceDecl.html">NamespaceDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="specifiesNamespace0"><pre>Matches nested name specifiers that specify a namespace matching the
given namespace matcher.

Given
  namespace ns { struct A {}; }
  ns::A a;

The matcher
nestedNameSpecifier(specifiesNamespace(hasName("ns"))) matches
ns.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;</td><td class="name" onclick="toggle('specifiesType0')"><a name="specifiesType0Anchor">specifiesType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="specifiesType0"><pre>Matches nested name specifiers that specify a type matching the
given QualType matcher without qualifiers.

Given
  struct A { struct B { struct C {}; }; };
  A::B::C c;

The matcher nestedNameSpecifier(specifiesType(
  hasDeclaration(cxxRecordDecl(hasName("A")))
))
matches A.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&gt;</td><td class="name" onclick="toggle('hasAnyClause0')"><a name="hasAnyClause0Anchor">hasAnyClause</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPClause.html">OMPClause</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyClause0"><pre>Matches any clause in an OpenMP directive.

Given
  void foo() {
  #pragma omp parallel
    ;
  #pragma omp parallel default(none)
    ;
  }


The matcher ompExecutableDirective(hasAnyClause(anything()))
matches #pragma omp parallel default(none).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&gt;</td><td class="name" onclick="toggle('hasStructuredBlock0')"><a name="hasStructuredBlock0Anchor">hasStructuredBlock</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasStructuredBlock0"><pre>Matches the structured-block of the OpenMP executable directive

Prerequisite: the executable directive must not be standalone directive.
If it is, it will never match.

Given
  void foo() {
    #pragma omp parallel
    ;
    #pragma omp parallel
    {}
  }


The matcher
ompExecutableDirective(hasStructuredBlock(nullStmt().bind("stmt")))
matches #pragma omp parallel,
with stmtt() matching {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;</td><td class="name" onclick="toggle('isDerivedFrom1')"><a name="isDerivedFrom1Anchor">isDerivedFrom</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; Base</td></tr>
<tr><td colspan="4" class="doc" id="isDerivedFrom1"><pre>Matches C++ classes that are directly or indirectly derived from a class
matching Base, or Objective-C classes that directly or indirectly
subclass a class matching Base.

Note that a class is not considered to be derived from itself.

Example matches Y, Z, C (Base == hasName("X"))
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

  class Foo {};
  typedef Foo Alias;
  class Bar : public Alias {};
  // derived from a type that Alias is a typedef of Foo


The matcher cxxRecordDecl(isDerivedFrom(hasName("X")))
matches Y, Z and C.
The matcher cxxRecordDecl(isDerivedFrom(hasName("Foo")))
matches Bar.

In the following example, Bar matches isDerivedFrom(hasName("NSObject"))
  @interface NSObject @end
  @interface Bar : NSObject @end


Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;</td><td class="name" onclick="toggle('isDirectlyDerivedFrom1')"><a name="isDirectlyDerivedFrom1Anchor">isDirectlyDerivedFrom</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; Base</td></tr>
<tr><td colspan="4" class="doc" id="isDirectlyDerivedFrom1"><pre>Matches C++ or Objective-C classes that are directly derived from a class
matching Base.

Note that a class is not considered to be derived from itself.

Given
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

The matcher
cxxRecordDecl(isDirectlyDerivedFrom(namedDecl(hasName("X"))))
matches Y and C (Base == hasName("X")

In the following example, Bar matches isDerivedFrom(hasName("X")):
  class Foo {};
  typedef Foo X;
  class Bar : public Foo {};  // derived from a type that X is a typedef of

The matcher cxxRecordDecl(isDerivedFrom(hasName("X")))
matches Bar
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>&gt;</td><td class="name" onclick="toggle('isSameOrDerivedFrom1')"><a name="isSameOrDerivedFrom1Anchor">isSameOrDerivedFrom</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; Base</td></tr>
<tr><td colspan="4" class="doc" id="isSameOrDerivedFrom1"><pre>Similar to isDerivedFrom(), but also matches classes that directly
match Base.

Given
  class X {};
  class Y : public X {};  // directly derived
  class Z : public Y {};  // indirectly derived
  typedef X A;
  typedef A B;
  class C : public B {};  // derived from a typedef of X

The matcher
cxxRecordDecl(isSameOrDerivedFrom(cxxRecordDecl(hasName("X"))),
isDefinition())
matches class X {}, class Y : public X {},
class Z : public Y {} and class C : public B {}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('callee2')"><a name="callee2Anchor">callee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="callee2"><pre>Matches 1) if the call expression's callee's declaration matches the
given matcher; or 2) if the Obj-C message expression's callee's method
declaration matches the given matcher.

Example 1
  class Y { public: void x(); };
  void z() { Y y; y.x(); }

The matcher callExpr(callee(cxxMethodDecl(hasName("x"))))
matches y.x()

Example 2
  @interface I: NSObject
  +(void)foo;
  @end
  ...
  [I foo]

The matcher
objcMessageExpr(callee(objcMethodDecl(hasName("foo"))))
matches [I foo]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyArgument3')"><a name="hasAnyArgument3Anchor">hasAnyArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyArgument3"><pre>Matches any argument of a call expression or a constructor call
expression, or an ObjC-message-send expression.

Given
  void x(int, int, int) { int y = 42; x(1, y, 42); }
The matcher
callExpr(hasAnyArgument(ignoringImplicit(declRefExpr()))) matches
x(1, y, 42) with hasAnyArgument(...)
  matching y

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end
  void foo(I *i) { [i f:12]; }

The matcher
objcMessageExpr(hasAnyArgument(integerLiteral(equals(12))))
matches [i f:12]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasArgument3')"><a name="hasArgument3Anchor">hasArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArgument3"><pre>Matches the n'th argument of a call expression or a constructor
call expression.

Given
  void x(int) { int y; x(y); }
The matcher callExpr(hasArgument(0, declRefExpr().bind("arg")))
matches x(y),
with declRefExpr() matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasReceiver0')"><a name="hasReceiver0Anchor">hasReceiver</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasReceiver0"><pre>Matches if the Objective-C message is sent to an instance,
and the inner matcher matches on that instance.

Given
  NSString *x = @"hello";
  [x containsString:@"h"];

The matcher
objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName("x"))))))
matches [x containsString:@"h"];
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&gt;</td><td class="name" onclick="toggle('hasReceiverType0')"><a name="hasReceiverType0Anchor">hasReceiverType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasReceiverType0"><pre>Matches on the receiver of an ObjectiveC Message expression.

  NSString *webViewJavaScript = ...
  UIWebView *webView = ...
  [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];

The matcher objCMessageExpr(hasReceiverType(asString("UIWebView
*"))) matches
[webViewstringByEvaluatingJavaScriptFromString:webViewJavascript];
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyParameter1')"><a name="hasAnyParameter1Anchor">hasAnyParameter</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyParameter1"><pre>Matches any parameter of a function or an ObjC method declaration or a
block.

Does not match the 'this' parameter of a method.

Given
  class X { void f(int x, int y, int z) {} };

The matcher cxxMethodDecl(hasAnyParameter(hasName("y")))
  matches f
with hasAnyParameter(...)
  matching int y

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end


the matcher objcMethodDecl(hasAnyParameter(hasName("y")))
  matches the declaration of method f with hasParameter
matching y.

For blocks, given
  b = ^(int y) { printf("%d", y) };


the matcher blockDecl(hasAnyParameter(hasName("y")))
  matches the declaration of the block b with hasParameter
matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&gt;</td><td class="name" onclick="toggle('hasParameter1')"><a name="hasParameter1Anchor">hasParameter</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasParameter1"><pre>Matches the n'th parameter of a function or an ObjC method
declaration or a block.

Given
  class X { void f(int x) {} };

The matcher
cxxMethodDecl(hasParameter(0, hasType(asString("int"))))
matches f
with hasParameter(...)
matching int x.

For ObjectiveC, given
  @interface I - (void) f:(int) y; @end


The matcher objcMethodDecl(hasParameter(0, hasName("y")))
matches the declaration of method f with hasParameter
matching y.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc10')"><a name="hasTypeLoc10Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc10"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a>&gt;</td><td class="name" onclick="toggle('hasSourceExpression1')"><a name="hasSourceExpression1Anchor">hasSourceExpression</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSourceExpression1"><pre>Matches if the cast's source expression
or opaque value's source expression matches the given matcher.

Given
 struct URL { URL(const char*); };
 URL url = "a string";

The matcher castExpr(hasSourceExpression(cxxConstructExpr()))
matches "a string".

Given
void foo(bool b) {
  int a = b ?: 1;
}

The matcher
opaqueValueExpr(hasSourceExpression(
              implicitCastExpr(has(
                implicitCastExpr(has(declRefExpr()))))))
matches b twice, for the conditiona and the true expression.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1OverloadExpr.html">OverloadExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnyDeclaration0')"><a name="hasAnyDeclaration0Anchor">hasAnyDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyDeclaration0"><pre>Matches an OverloadExpr if any of the declarations in the set of
overloads matches the given matcher.

Given
  template &lt;typename T&gt; void foo(T);
  template &lt;typename T&gt; void bar(T);
  template &lt;typename T&gt; void baz(T t) {
    foo(t);
    bar(t);
  }

The matcher unresolvedLookupExpr(hasAnyDeclaration(
    functionTemplateDecl(hasName("foo"))))
matches foo in foo(t);
but does not match bar in bar(t);
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParenType.html">ParenType</a>&gt;</td><td class="name" onclick="toggle('innerType0')"><a name="innerType0Anchor">innerType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="innerType0"><pre>Matches ParenType nodes where the inner type is a specific type.

Given
  int (*ptr_to_array)[4];
  int (*ptr_to_func)(int);

The matcher
varDecl(hasType(pointsTo(parenType(innerType(functionType())))))
  matches ptr_to_func but not
  ptr_to_array.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ParenType.html">ParenType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerTypeLoc.html">PointerTypeLoc</a>&gt;</td><td class="name" onclick="toggle('hasPointeeLoc0')"><a name="hasPointeeLoc0Anchor">hasPointeeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; PointeeMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasPointeeLoc0"><pre>Matches pointer `TypeLoc`s that have a pointee `TypeLoc` matching
`PointeeMatcher`.

Given
  int* x;
The matcher pointerTypeLoc(hasPointeeLoc(loc(asString("int"))))
  matches int*.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerType.html">PointerType</a>&gt;</td><td class="name" onclick="toggle('pointee2')"><a name="pointee2Anchor">pointee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="pointee2"><pre>Narrows PointerType (and similar) matchers to those where the
pointee matches a given matcher.

Given
  int *a;
  const int *b;
  int * const c = nullptr;
  const float *f;

The matcher pointerType(pointee(isConstQualified(), isInteger()))
matches const int *,
but does not match int * const
or const float *.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockPointerType.html">BlockPointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberPointerType.html">MemberPointerType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerType.html">PointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceType.html">ReferenceType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('hasCanonicalType0')"><a name="hasCanonicalType0Anchor">hasCanonicalType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCanonicalType0"><pre>Matches QualTypes whose canonical type matches InnerMatcher.

Given
  typedef int &amp;int_ref;
  int a;
  int_ref b = a;

The matcher varDecl(hasType(qualType(referenceType())))
does not match int_ref b = a,
but the matcher
varDecl(hasType(qualType(hasCanonicalType(referenceType()))))
does match int_ref b = a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration6')"><a name="hasDeclaration6Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration6"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('ignoringParens0')"><a name="ignoringParens0Anchor">ignoringParens</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="ignoringParens0"><pre>Matches types that match InnerMatcher after any parens are stripped.

Given
  void (*fp)(void);
The matcher
varDecl(hasType(pointerType(pointee(ignoringParens(functionType())))))
matches fp.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('pointsTo1')"><a name="pointsTo1Anchor">pointsTo</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="pointsTo1"><pre>Matches if the matched type is a pointer type and the pointee type
  matches the specified matcher.
Overloaded to match the pointee type's declaration.

Given
  class Y { public: void x(); };
  void z() { Y *y; y-&gt;x(); }

The matcher cxxMemberCallExpr(on(hasType(pointsTo(
     cxxRecordDecl(hasName("Y"))))))
matches y-&gt;x()
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('pointsTo0')"><a name="pointsTo0Anchor">pointsTo</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="pointsTo0"><pre>Matches if the matched type is a pointer type and the pointee type
  matches the specified matcher.

Given
  class Y { public: void x(); };
  void z() { Y *y; y-&gt;x(); }

The matcher cxxMemberCallExpr(on(hasType(pointsTo(
     qualType()))))
matches y-&gt;x()
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('references1')"><a name="references1Anchor">references</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="references1"><pre>Matches if the matched type is a reference type and the referenced
type matches the specified matcher.
Overloaded to match the referenced type's declaration.

Given
  class X {
    void a(X b) {
      X &amp;x = b;
      const X &amp;y = b;
    }
  };

The matcher
varDecl(hasType(references(cxxRecordDecl(hasName("X"))))) matches
X &amp;x = b and const X &amp;y = b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;</td><td class="name" onclick="toggle('references0')"><a name="references0Anchor">references</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="references0"><pre>Matches if the matched type is a reference type and the referenced
type matches the specified matcher.

Given
  class X {
    void a(X b) {
      X &amp;x = b;
      const X &amp;y = b;
    }
  };

The matcher
varDecl(hasType(references(qualType()))) matches
X &amp;x = b and const X &amp;y = b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualifiedTypeLoc.html">QualifiedTypeLoc</a>&gt;</td><td class="name" onclick="toggle('hasUnqualifiedLoc0')"><a name="hasUnqualifiedLoc0Anchor">hasUnqualifiedLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasUnqualifiedLoc0"><pre>Matches `QualifiedTypeLoc`s that have an unqualified `TypeLoc` matching
`InnerMatcher`.

Given
  int* const x = nullptr;
  const int y = 0;


The matcher qualifiedTypeLoc(hasUnqualifiedLoc(pointerTypeLoc()))
matches the type int* of the variable declaration but
not </pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration5')"><a name="hasDeclaration5Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration5"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceTypeLoc.html">ReferenceTypeLoc</a>&gt;</td><td class="name" onclick="toggle('hasReferentLoc0')"><a name="hasReferentLoc0Anchor">hasReferentLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; ReferentMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasReferentLoc0"><pre>Matches reference `TypeLoc`s that have a referent `TypeLoc` matching
`ReferentMatcher`.

Given
  int x = 3;
  int&amp; xx = x;


The matcher referenceTypeLoc(hasReferentLoc(loc(asString("int"))))
  matches int&amp;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceType.html">ReferenceType</a>&gt;</td><td class="name" onclick="toggle('pointee3')"><a name="pointee3Anchor">pointee</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="pointee3"><pre>Narrows PointerType (and similar) matchers to those where the
pointee matches a given matcher.

Given
  int *a;
  const int *b;
  int * const c = nullptr;
  const float *f;

The matcher pointerType(pointee(isConstQualified(), isInteger()))
matches const int *,
but does not match int * const
or const float *.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockPointerType.html">BlockPointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberPointerType.html">MemberPointerType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1PointerType.html">PointerType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceType.html">ReferenceType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ReturnStmt.html">ReturnStmt</a>&gt;</td><td class="name" onclick="toggle('hasReturnValue0')"><a name="hasReturnValue0Anchor">hasReturnValue</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasReturnValue0"><pre>Matches the return value expression of a return statement

Given
  int foo(int a, int b) {
    return a + b;
  }
The matcher
returnStmt(hasReturnValue(binaryOperator().bind("op"))) matches
return a + b, with binaryOperator() matching
a + b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1StmtExpr.html">StmtExpr</a>&gt;</td><td class="name" onclick="toggle('hasAnySubstatement1')"><a name="hasAnySubstatement1Anchor">hasAnySubstatement</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnySubstatement1"><pre>Matches compound statements where at least one substatement matches
a given matcher. Also matches StmtExprs that have CompoundStmt as children.

Given
void foo() { { {}; 1+2; } }
The matcher
compoundStmt(hasAnySubstatement(compoundStmt().bind("compound")))
{ {}; 1+2; } and { { {}; 1+2; } }
with compoundStmt()
matching {} and { {}; 1+2; }.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('alignOfExpr0')"><a name="alignOfExpr0Anchor">alignOfExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="alignOfExpr0"><pre>Same as unaryExprOrTypeTraitExpr, but only matching
alignof.

Given
  int align = alignof(int);


The matcher alignOfExpr(expr())
matches alignof(int).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('forCallable0')"><a name="forCallable0Anchor">forCallable</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forCallable0"><pre>Matches declaration of the function, method, or block the statement
belongs to.

Given
struct F {
  F&amp; operator=(const F&amp; other) {
    []() { return 42 == 42; };
    return *this;
  }
};

The matcher returnStmt(forFunction(hasName("operator=")))
matches return *this
but does not match return 42 == 42.

Given
void foo {
  int x = 1;
  dispatch_sync(queue, ^{ int y = 2; });
}

The matcher declStmt(forCallable(objcMethodDecl()))
matches int x = 1
but does not match int y = 2.
The matcher declStmt(forCallable(blockDecl()))
matches int y = 2
but does not match int x = 1.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('forFunction0')"><a name="forFunction0Anchor">forFunction</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html">FunctionDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forFunction0"><pre>Matches declaration of the function the statement belongs to.

Deprecated. Use forCallable() to correctly handle the situation when
the declaration is not a function (but a block or an Objective-C method).
The matcher forFunction() not only fails to take non-functions
into account but also may match the wrong declaration in their presence.

Given
  struct F {
    F&amp; operator=(const F&amp; other) {
      []() { return 42 == 42; };
      return *this;
    }
  };


The matcher returnStmt(forFunction(hasName("operator=")))
matches return *this
but does not match return 42 == 42.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt;</td><td class="name" onclick="toggle('sizeOfExpr0')"><a name="sizeOfExpr0Anchor">sizeOfExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="sizeOfExpr0"><pre>Same as unaryExprOrTypeTraitExpr, but only matching
sizeof.

Given
  struct S { double x; double y; };
  int size = sizeof(struct S);

The matcher sizeOfExpr(expr())
matches sizeof(struct S).
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a>&gt;</td><td class="name" onclick="toggle('hasReplacementType0')"><a name="hasReplacementType0Anchor">hasReplacementType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasReplacementType0"><pre>Matches template type parameter substitutions that have a replacement
type that matches the provided matcher.

Given
  template &lt;typename T&gt;
  double F(T t);
  int i;
  double j = F(i);


The matcher substTemplateTypeParmType(hasReplacementType(type()))
matches int.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SwitchStmt.html">SwitchStmt</a>&gt;</td><td class="name" onclick="toggle('forEachSwitchCase0')"><a name="forEachSwitchCase0Anchor">forEachSwitchCase</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SwitchCase.html">SwitchCase</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachSwitchCase0"><pre>Matches each case or default statement belonging to the given switch
statement. This matcher may produce multiple matches.

Given
  void foo() {
    switch (1) { case 1: case 2: default: switch (2) { case 3: case 4: ; } }
  }
The matcher
switchStmt(forEachSwitchCase(caseStmt().bind("c")))
matches four times, matching
switch (1) { case 1: case 2: default: switch (2) { case 3:
case 4: ; } } and
switch (2) { case 3: case 4: ; }, with
caseStmt() matching each of case 1:,
case 2:, case 3:
and case 4:.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SwitchStmt.html">SwitchStmt</a>&gt;</td><td class="name" onclick="toggle('hasCondition4')"><a name="hasCondition4Anchor">hasCondition</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition4"><pre>Matches the condition expression of an if statement, for loop,
switch statement or conditional operator.

Given
void foo() {
  if (true) {}
}

The matcher ifStmt(hasCondition(cxxBoolLiteral(equals(true))))
if (true) {}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1SwitchStmt.html">SwitchStmt</a>&gt;</td><td class="name" onclick="toggle('hasInitStatement1')"><a name="hasInitStatement1Anchor">hasInitStatement</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasInitStatement1"><pre>Matches selection statements with initializer.

Given
 struct vec { int* begin(); int* end(); };
 int foobar();
 vec&amp; get_range();
 void foo() {
   if (int i = foobar(); i &gt; 0) {}
   switch (int i = foobar(); i) {}
   for (auto&amp; a = get_range(); auto&amp; x : a) {}
 }
 void bar() {
   if (foobar() &gt; 0) {}
   switch (foobar()) {}
   for (auto&amp; x : get_range()) {}
 }

The matcher ifStmt(hasInitStatement(anything()))
  matches the if statement if (int i = foobar(); i &gt; 0) {}
  in foo but not if (foobar() &gt; 0) {} in bar.
The matcher switchStmt(hasInitStatement(anything()))
  matches the switch statement switch (int i = foobar(); i) {}
  in foo but not switch (foobar()) {} in bar.
The matcher cxxForRangeStmt(hasInitStatement(anything()))
  matches the range for statement
  for (auto&amp; a = get_range(); auto&amp; x : a) {} in foo
  but not for (auto&amp; x : get_range()) {} in bar.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration4')"><a name="hasDeclaration4Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration4"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc11')"><a name="hasTypeLoc11Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc11"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('isExpr0')"><a name="isExpr0Anchor">isExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="isExpr0"><pre>Matches a sugar TemplateArgument that refers to a certain expression.

Given
  struct B { int next; };
  template&lt;int(B::*next_ptr)&gt; struct A {};
  A&lt;&amp;B::next&gt; a;

The matcher
templateSpecializationType(hasAnyTemplateArgument(
  isExpr(hasDescendant(declRefExpr(to(fieldDecl(hasName("next")).bind("next")))))))
matches the specialization A&lt;&amp;struct B::next&gt;
with fieldDecl(hasName("next")) matching
B::next.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('refersToDeclaration0')"><a name="refersToDeclaration0Anchor">refersToDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="refersToDeclaration0"><pre>Matches a canonical TemplateArgument that refers to a certain
declaration.

Given
  struct B { int next; };
  template&lt;int(B::*next_ptr)&gt; struct A {};
  A&lt;&amp;B::next&gt; a;

The matcher
classTemplateSpecializationDecl(hasAnyTemplateArgument(
    refersToDeclaration(fieldDecl(hasName("next")).bind("next"))))
matches the specialization struct A&lt;&amp;B::next&gt;
with fieldDecl(hasName("next")) matching
B::next.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('refersToIntegralType0')"><a name="refersToIntegralType0Anchor">refersToIntegralType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="refersToIntegralType0"><pre>Matches a TemplateArgument that refers to an integral type.

Given
  template&lt;int T&gt; struct C {};
  C&lt;42&gt; c;

The matcher classTemplateSpecializationDecl(
  hasAnyTemplateArgument(refersToIntegralType(asString("int"))))
matches the implicitly declared specialization
struct C&lt;42&gt; from the instantiation for the type of the
variable c .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('refersToTemplate0')"><a name="refersToTemplate0Anchor">refersToTemplate</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateName.html">TemplateName</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="refersToTemplate0"><pre>Matches a TemplateArgument that refers to a certain template.

Given
  template&lt;template &lt;typename&gt; class S&gt; class X {};
  template&lt;typename T&gt; class Y {};
  X&lt;Y&gt; xi;

The matcher
classTemplateSpecializationDecl(hasAnyTemplateArgument(
              refersToTemplate(templateName())))
matches the specialization class X&lt;Y&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td><td class="name" onclick="toggle('refersToType0')"><a name="refersToType0Anchor">refersToType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="refersToType0"><pre>Matches a TemplateArgument that refers to a certain type.

Given
  struct X {};
  template&lt;typename T&gt; struct A {};
  A&lt;X&gt; a;

The matcher
classTemplateSpecializationDecl(hasAnyTemplateArgument(refersToType(
            recordType(hasDeclaration(recordDecl(hasName("X")))))))
matches the specialization struct A&lt;struct X&gt;.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgumentLoc4')"><a name="hasAnyTemplateArgumentLoc4Anchor">hasAnyTemplateArgumentLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgumentLoc4"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
that have at least one `TemplateArgumentLoc` matching the given
`InnerMatcher`.

Given
  template&lt;typename T&gt; class A {};
  A&lt;int&gt; a;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc(
hasTypeLoc(loc(asString("int"))))))))) matches A&lt;int&gt; a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgumentLoc4')"><a name="hasTemplateArgumentLoc4Anchor">hasTemplateArgumentLoc</a></td><td>unsigned Index, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgumentLoc4"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
where the n'th `TemplateArgumentLoc` matches the given `InnerMatcher`.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,
hasTypeLoc(loc(asString("double")))))))))
matches A&lt;double, int&gt; b, but not double&gt; c}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;</td><td class="name" onclick="toggle('forEachTemplateArgument3')"><a name="forEachTemplateArgument3Anchor">forEachTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachTemplateArgument3"><pre>Matches templateSpecializationType, class template specialization,
variable template specialization, and function template specialization
nodes where the template argument matches the inner matcher. This matcher
may produce multiple matches.

Given
  template &lt;typename T, unsigned N, unsigned M&gt;
  struct Matrix {};

  constexpr unsigned R = 2;
  Matrix&lt;int, R * 2, R * 4&gt; M;

  template &lt;typename T, typename U&gt;
  void f(T&amp;&amp; t, U&amp;&amp; u) {}

  void foo() {
    bool B = false;
    f(R, B);
  }

The matcher
templateSpecializationType(forEachTemplateArgument(isExpr(expr().bind("t_arg"))))
matches Matrix&lt;int, R * 2, R * 4&gt; twice, with
expr() matching R * 2 and
R * 4.
The matcher
functionDecl(forEachTemplateArgument(refersToType(qualType().bind("type"))))
matches the specialization of f twice,
with qualType() matching
unsigned and
bool.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgument3')"><a name="hasAnyTemplateArgument3Anchor">hasAnyTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgument3"><pre>Matches templateSpecializationTypes, class template specializations,
variable template specializations, and function template specializations
that have at least one TemplateArgument matching the given InnerMatcher.

Given
  template&lt;typename T&gt; class A {};
  template&lt;&gt; class A&lt;double&gt; {};
  A&lt;int&gt; a;

  template&lt;typename T&gt; void f() {};
  void func() { f&lt;int&gt;(); };


The matcher classTemplateSpecializationDecl(
                        hasAnyTemplateArgument(
                          refersToType(asString("int"))))
matches class A&lt;int&gt;.

The matcher
functionDecl(hasAnyTemplateArgument(
              refersToType(asString("int"))))
matches the instantiation of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration3')"><a name="hasDeclaration3Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration3"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgument3')"><a name="hasTemplateArgument3Anchor">hasTemplateArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgument3"><pre>Matches templateSpecializationType, class template specializations,
variable template specializations, and function template specializations
where the n'th TemplateArgument matches the given InnerMatcher.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

  template&lt;typename T&gt; void f() {}
  void func() { f&lt;int&gt;(); };

The matcher
classTemplateSpecializationDecl(hasTemplateArgument(
    1, refersToType(asString("int"))))
matches the specialization class A&lt;double, int&gt;.

The matcher functionDecl(hasTemplateArgument(0,
                        refersToType(asString("int"))))
matches the specialization of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration2')"><a name="hasDeclaration2Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration2"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td><td class="name" onclick="toggle('loc0')"><a name="loc0Anchor">loc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="loc0"><pre>Matches TypeLocs for which the given inner
QualType-matcher matches.

  int a = 10;

The matcher typeLoc(loc(qualType(isInteger())))
matches the int of a .
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;</td><td class="name" onclick="toggle('hasTypeLoc12')"><a name="hasTypeLoc12Anchor">hasTypeLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypeLoc.html">TypeLoc</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="hasTypeLoc12"><pre>Matches if the type location of a node matches the inner matcher.

Given
  int x;
The matcher declaratorDecl(hasTypeLoc(loc(asString("int"))))
matches int x.

Given
struct point { point(double, double); };
point p = point(1.0, -1.0);

The matcher
cxxTemporaryObjectExpr(hasTypeLoc(loc(asString("point"))))
matches point(1.0, -1.0).

Given
struct Foo { Foo(int, int); };
Foo x = Foo(1, 2);

The matcher cxxTemporaryObjectExpr(hasTypeLoc(
                          loc(asString("Foo"))))
matches Foo(1, 2).

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1BlockDecl.html">BlockDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>&gt;</td><td class="name" onclick="toggle('hasType2')"><a name="hasType2Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType2"><pre>Matches if the expression's or declaration's type matches a type
matcher.

Exmaple
 class X {};
 void y(X &amp;x) { x; X z; }
 typedef int U;
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z
The matcher typedefDecl(hasType(asString("int")))
matches typedef int U
The matcher friendDecl(hasType(asString("class X")))
matches friend class X
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration1')"><a name="hasDeclaration1Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration1"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td><td class="name" onclick="toggle('hasUnqualifiedDesugaredType0')"><a name="hasUnqualifiedDesugaredType0Anchor">hasUnqualifiedDesugaredType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasUnqualifiedDesugaredType0"><pre>Matches if the matched type matches the unqualified desugared
type of the matched node.

For example, in:
  class A {};
  using B = A;
  B b;

The matcher
varDecl(hasType(hasUnqualifiedDesugaredType(recordType())))
matches B b.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>&gt;</td><td class="name" onclick="toggle('hasArgumentOfType0')"><a name="hasArgumentOfType0Anchor">hasArgumentOfType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasArgumentOfType0"><pre>Matches unary expressions that have a specific type of argument.

Given
  int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);

The matcher
unaryExprOrTypeTraitExpr(hasArgumentOfType(asString("int")))
matches sizeof(a) and alignof(c)
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnaryOperator.html">UnaryOperator</a>&gt;</td><td class="name" onclick="toggle('hasUnaryOperand0')"><a name="hasUnaryOperand0Anchor">hasUnaryOperand</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasUnaryOperand0"><pre>Matches if the operand of a unary operator matches.

void foo() {
  !true;
}

The matcher
unaryOperator(hasUnaryOperand(cxxBoolLiteral(equals(true))))
matches !true.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a>&gt;</td><td class="name" onclick="toggle('hasObjectExpression1')"><a name="hasObjectExpression1Anchor">hasObjectExpression</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasObjectExpression1"><pre>Matches a member expression where the object expression is matched by a
given matcher. Implicit object expressions are included; that is, it matches
use of implicit `this`.

Given
  struct X {
    int m;
    int f(X x) { x.m; return m; }
  };


The matcher
memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName("X")))))
matches x.m, but not m; however,
The matcher memberExpr(hasObjectExpression(hasType(pointsTo(
cxxRecordDecl(hasName("X"))))))
matches m (aka. this-&gt;m), but not x.m.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;</td><td class="name" onclick="toggle('hasDeclaration0')"><a name="hasDeclaration0Anchor">hasDeclaration</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt;  InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasDeclaration0"><pre>Matches a node if the declaration associated with that node
  matches the given matcher.

The associated declaration is:
- for type nodes, the declaration of the underlying type
- for CallExpr, the declaration of the callee
- for MemberExpr, the declaration of the referenced member
- for CXXConstructExpr, the declaration of the constructor
- for CXXNewExpr, the declaration of the operator new
- for ObjCIvarExpr, the declaration of the ivar

Given
  class X {};
  typedef X Y;
  Y y;

For type nodes, hasDeclaration will generally match the declaration of the
sugared type, i.e., the matcher
varDecl(hasType(qualType(hasDeclaration(decl().bind("d"))))),
matches Y y, with
the matcher decl() matching
typedef X Y;.
A common use case is to match the underlying, desugared type.
This can be achieved by using the hasUnqualifiedDesugaredType matcher:
varDecl(hasType(hasUnqualifiedDesugaredType(
      recordType(hasDeclaration(decl().bind("d"))))))
matches Y y.
In this matcher, the matcher decl() will match the
CXXRecordDecl
class X {};.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CallExpr.html">CallExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1EnumType.html">EnumType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1LabelStmt.html">LabelStmt</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1MemberExpr.html">MemberExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1RecordType.html">RecordType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TagType.html">TagType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>&gt;,
  Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UnresolvedUsingType.html">UnresolvedUsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a>&gt;</td><td class="name" onclick="toggle('hasTargetDecl0')"><a name="hasTargetDecl0Anchor">hasTargetDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1NamedDecl.html">NamedDecl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTargetDecl0"><pre>Matches a using shadow declaration where the target declaration is
matched by the given matcher.

Given
  namespace X { int a; void b(); }
  using X::a;
  using X::b;

The matcher
usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl())))
  matches using X::b
  but not X::a}
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingType.html">UsingType</a>&gt;</td><td class="name" onclick="toggle('hasUnderlyingType1')"><a name="hasUnderlyingType1Anchor">hasUnderlyingType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>&gt;</td></tr>
<tr><td colspan="4" class="doc" id="hasUnderlyingType1"><pre>Matches DecltypeType or UsingType nodes to find the underlying type.

Given
  decltype(1) a = 1;
  decltype(2.0) b = 2.0;


The matcher decltypeType(hasUnderlyingType(isInteger()))
matches the type decltype(1) of the variable
declaration of a .

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DecltypeType.html">DecltypeType</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingType.html">UsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingType.html">UsingType</a>&gt;</td><td class="name" onclick="toggle('throughUsingDecl1')"><a name="throughUsingDecl1Anchor">throughUsingDecl</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a>&gt; Inner</td></tr>
<tr><td colspan="4" class="doc" id="throughUsingDecl1"><pre>Matches if a node refers to a declaration through a specific
using shadow declaration.

Given
  namespace a { int f(); }
  using a::f;
  int x = f();

The matcher declRefExpr(throughUsingDecl(anything()))
matches f

  namespace a { class X{}; }
  using a::X;
  X x;

The matcher typeLoc(loc(usingType(throughUsingDecl(anything()))))
matches X

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1UsingType.html">UsingType</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt;</td><td class="name" onclick="toggle('hasType7')"><a name="hasType7Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType7"><pre>Overloaded to match the declaration of the expression's or value
declaration's type.

In case of a value declaration (for example a variable declaration),
this resolves one layer of indirection. For example, in the value
declaration "X x;", cxxRecordDecl(hasName("X")) matches the declaration of
X, while varDecl(hasType(cxxRecordDecl(hasName("X")))) matches the
declaration of x.

 class X {};
 void y(X &amp;x) { x; X z; }
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z.
The matcher friendDecl(hasType(asString("class X")))
matches friend class X.
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches
class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.

Given
class Base {};
class Derived : Base {};

The matcher
cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName("Base")))))
matches class Derived : Base {}.

Usable as: Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1FriendDecl.html">FriendDecl</a>&gt;, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt;,
Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1ValueDecl.html">ValueDecl</a>&gt;</td><td class="name" onclick="toggle('hasType3')"><a name="hasType3Anchor">hasType</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1QualType.html">QualType</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasType3"><pre>Matches if the expression's or declaration's type matches a type
matcher.

Exmaple
 class X {};
 void y(X &amp;x) { x; X z; }
 typedef int U;
 class Y { friend class X; };
 class Z : public virtual X {};

The matcher expr(hasType(cxxRecordDecl(hasName("X"))))
matches x and z.
The matcher varDecl(hasType(cxxRecordDecl(hasName("X"))))
matches z
The matcher typedefDecl(hasType(asString("int")))
matches typedef int U
The matcher friendDecl(hasType(asString("class X")))
matches friend class X
The matcher cxxRecordDecl(hasAnyBase(cxxBaseSpecifier(hasType(
asString("X"))).bind("b"))) matches class Z : public virtual X {},
with cxxBaseSpecifier(...)
matching public virtual X.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarDecl.html">VarDecl</a>&gt;</td><td class="name" onclick="toggle('hasInitializer0')"><a name="hasInitializer0Anchor">hasInitializer</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasInitializer0"><pre>Matches a variable declaration that has an initializer expression
that matches the given matcher.

Given
  int y() { return 0; }
  void foo() {
    int x = y();
  }
The matcher varDecl(hasInitializer(callExpr()))
matches x
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarTemplateSpecializationDecl.html">VarTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('forEachTemplateArgument1')"><a name="forEachTemplateArgument1Anchor">forEachTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="forEachTemplateArgument1"><pre>Matches templateSpecializationType, class template specialization,
variable template specialization, and function template specialization
nodes where the template argument matches the inner matcher. This matcher
may produce multiple matches.

Given
  template &lt;typename T, unsigned N, unsigned M&gt;
  struct Matrix {};

  constexpr unsigned R = 2;
  Matrix&lt;int, R * 2, R * 4&gt; M;

  template &lt;typename T, typename U&gt;
  void f(T&amp;&amp; t, U&amp;&amp; u) {}

  void foo() {
    bool B = false;
    f(R, B);
  }

The matcher
templateSpecializationType(forEachTemplateArgument(isExpr(expr().bind("t_arg"))))
matches Matrix&lt;int, R * 2, R * 4&gt; twice, with
expr() matching R * 2 and
R * 4.
The matcher
functionDecl(forEachTemplateArgument(refersToType(qualType().bind("type"))))
matches the specialization of f twice,
with qualType() matching
unsigned and
bool.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarTemplateSpecializationDecl.html">VarTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgumentLoc1')"><a name="hasAnyTemplateArgumentLoc1Anchor">hasAnyTemplateArgumentLoc</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgumentLoc1"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
that have at least one `TemplateArgumentLoc` matching the given
`InnerMatcher`.

Given
  template&lt;typename T&gt; class A {};
  A&lt;int&gt; a;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc(
hasTypeLoc(loc(asString("int"))))))))) matches A&lt;int&gt; a.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarTemplateSpecializationDecl.html">VarTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasAnyTemplateArgument1')"><a name="hasAnyTemplateArgument1Anchor">hasAnyTemplateArgument</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasAnyTemplateArgument1"><pre>Matches templateSpecializationTypes, class template specializations,
variable template specializations, and function template specializations
that have at least one TemplateArgument matching the given InnerMatcher.

Given
  template&lt;typename T&gt; class A {};
  template&lt;&gt; class A&lt;double&gt; {};
  A&lt;int&gt; a;

  template&lt;typename T&gt; void f() {};
  void func() { f&lt;int&gt;(); };


The matcher classTemplateSpecializationDecl(
                        hasAnyTemplateArgument(
                          refersToType(asString("int"))))
matches class A&lt;int&gt;.

The matcher
functionDecl(hasAnyTemplateArgument(
              refersToType(asString("int"))))
matches the instantiation of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarTemplateSpecializationDecl.html">VarTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgumentLoc1')"><a name="hasTemplateArgumentLoc1Anchor">hasTemplateArgumentLoc</a></td><td>unsigned Index, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgumentLoc1"><pre>Matches template specialization `TypeLoc`s, class template specializations,
variable template specializations, and function template specializations
where the n'th `TemplateArgumentLoc` matches the given `InnerMatcher`.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

The matcher
varDecl(hasTypeLoc(elaboratedTypeLoc(hasNamedTypeLoc(
templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,
hasTypeLoc(loc(asString("double")))))))))
matches A&lt;double, int&gt; b, but not double&gt; c}.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VarTemplateSpecializationDecl.html">VarTemplateSpecializationDecl</a>&gt;</td><td class="name" onclick="toggle('hasTemplateArgument1')"><a name="hasTemplateArgument1Anchor">hasTemplateArgument</a></td><td>unsigned N, Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasTemplateArgument1"><pre>Matches templateSpecializationType, class template specializations,
variable template specializations, and function template specializations
where the n'th TemplateArgument matches the given InnerMatcher.

Given
  template&lt;typename T, typename U&gt; class A {};
  A&lt;double, int&gt; b;
  A&lt;int, double&gt; c;

  template&lt;typename T&gt; void f() {}
  void func() { f&lt;int&gt;(); };

The matcher
classTemplateSpecializationDecl(hasTemplateArgument(
    1, refersToType(asString("int"))))
matches the specialization class A&lt;double, int&gt;.

The matcher functionDecl(hasTemplateArgument(0,
                        refersToType(asString("int"))))
matches the specialization of f.
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1VariableArrayType.html">VariableArrayType</a>&gt;</td><td class="name" onclick="toggle('hasSizeExpr0')"><a name="hasSizeExpr0Anchor">hasSizeExpr</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasSizeExpr0"><pre>Matches VariableArrayType nodes that have a specific size
expression.

Given
  void f(int b) {
    int a[b];
  }
The matcher
variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(
  varDecl(hasName("b")))))))
matches int[b]
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1WhileStmt.html">WhileStmt</a>&gt;</td><td class="name" onclick="toggle('hasBody2')"><a name="hasBody2Anchor">hasBody</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasBody2"><pre>Matches a 'for', 'while', 'while' statement or a function or coroutine
definition that has a given body. Note that in case of functions or
coroutines this matcher only matches the definition itself and not the
other declarations of the same function or coroutine.

Given
void foo() {
  for (;;) {}
}
The matcher forStmt(hasBody(compoundStmt().bind("body")))
matches for (;;) {}
with compoundStmt()
  matching {}

Given
  void f();
  void f() {}
The matcher functionDecl(hasBody(compoundStmt().bind("compound")))
f
with compoundStmt()
matching {}
but does not match void f();
</pre></td></tr>


<tr><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1WhileStmt.html">WhileStmt</a>&gt;</td><td class="name" onclick="toggle('hasCondition2')"><a name="hasCondition2Anchor">hasCondition</a></td><td>Matcher&lt;<a href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>&gt; InnerMatcher</td></tr>
<tr><td colspan="4" class="doc" id="hasCondition2"><pre>Matches the condition expression of an if statement, for loop,
switch statement or conditional operator.

Given
void foo() {
  if (true) {}
}

The matcher ifStmt(hasCondition(cxxBoolLiteral(equals(true))))
if (true) {}
</pre></td></tr>

<!--END_TRAVERSAL_MATCHERS -->
</table>

</div>
</body>
</html>


