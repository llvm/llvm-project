# REQUIRES: x86

## Check that DTLTO creates imports lists if requested.

RUN: rm -rf %t && split-file %s %t && cd %t

RUN: opt -thinlto-bc t1.ll -o t1.bc
RUN: opt -thinlto-bc t2.ll -o t2.bc

## Generate object files for mock.py to return.
RUN: llc t1.ll --filetype=obj -o t1.o
RUN: llc t2.ll --filetype=obj -o t2.o

## Common command-line arguments. Note that mock.py does not do any compilation;
## instead, it simply writes the contents of the object files supplied on the
## command line into the output object files in job order.
RUN: echo "t1.bc t2.bc \
RUN:   --thinlto-distributor=%python \
RUN:   --thinlto-distributor-arg=%llvm_src_root/utils/dtlto/mock.py \
RUN:   --thinlto-distributor-arg=t1.o \
RUN:   --thinlto-distributor-arg=t2.o" > l.rsp

## Check that imports files are not created normally.
RUN: ld.lld @l.rsp
RUN: ls | FileCheck %s --check-prefix=NOIMPORTSFILES
NOIMPORTSFILES-NOT: .imports

## Check that imports files are created with --thinlto-emit-imports-files.
RUN: ld.lld @l.rsp --thinlto-emit-imports-files
RUN: ls | sort | FileCheck %s --check-prefix=IMPORTSFILES
IMPORTSFILES: {{^}}t1.bc.imports{{$}}
IMPORTSFILES: {{^}}t2.bc.imports{{$}}

#--- t1.ll
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @t1() {
  ret void
}

#--- t2.ll
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare void @t1(...)

define void @t2() {
  call void (...) @t1()
  ret void
}
