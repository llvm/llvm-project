# REQUIRES: x86

## Check that DTLTO creates individual summary index files if requested.

RUN: rm -rf %t && split-file %s %t && cd %t

## Generate ThinLTO bitcode files.
RUN: opt -thinlto-bc t1.ll -o t1.bc
RUN: opt -thinlto-bc t1.ll -o t2.bc

## Generate object files for mock.py to return.
RUN: llc t1.ll --filetype=obj -o t1.o --relocation-model=pic

## Use a response file for the common command-line arguments.
## Note that mock.py does not perform any compilation; instead, it copies the
## contents of the specified object files into the output object files, in the
## order the jobs are received.
## The "--start-lib/--end-lib" options are used to exercise the special case
## where unused lazy object inputs result in empty index files.
RUN: echo "t1.bc --start-lib t2.bc --end-lib \
RUN:   --thinlto-distributor=%python \
RUN:   --thinlto-distributor-arg=%llvm_src_root/utils/dtlto/mock.py \
RUN:   --thinlto-distributor-arg=t1.o \
RUN:   --thinlto-distributor-arg=t2.o" > l.rsp

## Check that index files are not created normally.
RUN: ld.lld @l.rsp
RUN: ls | FileCheck %s --check-prefix=NOINDEXFILES
NOINDEXFILES-NOT: .thinlto.bc

## Check that index files are created with --thinlto-emit-index-files.
RUN: ld.lld @l.rsp --thinlto-emit-index-files
RUN: ls | sort | FileCheck %s --check-prefix=INDEXFILES
INDEXFILES: {{^}}t1.bc.thinlto.bc{{$}}
INDEXFILES: {{^}}t2.bc.thinlto.bc{{$}}

#--- t1.ll
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @t1() {
entry:
  ret void
}
