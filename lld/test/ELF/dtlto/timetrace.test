REQUIRES: x86

## Test that DTLTO-specific LTO input file handling time-trace output is
## produced as expected.

RUN: rm -rf %t && split-file %s %t && cd %t

RUN: sed 's/@t1/@t2/g' t1.ll > t2.ll

## Generate ThinLTO bitcode files.
RUN: opt -thinlto-bc t1.ll -o t1.bc
RUN: opt -thinlto-bc t2.ll -o t2.bc

## Create archives.
RUN: llvm-ar rcs t1.a t1.bc
RUN: llvm-ar rcsT t2.thin.a t2.bc

## Generate object files for mock.py to return.
RUN: llc t1.ll --filetype=obj -o t1.o
RUN: llc t2.ll --filetype=obj -o t2.o

## Link and generate a time-trace.
## Note: mock.py doesn't compile; it copies the specified object files to the
## outputs in job order.
RUN: ld.lld --whole-archive t1.a t2.thin.a -o my.elf \
RUN:   --thinlto-distributor=%python \
RUN:   --thinlto-distributor-arg=%llvm_src_root/utils/dtlto/mock.py \
RUN:   --thinlto-distributor-arg=t1.o --thinlto-distributor-arg=t2.o \
RUN:   --time-trace-granularity=0 --time-trace=%t.json
RUN: %python filter_order_and_pprint.py %t.json | FileCheck %s

## Check that DTLTO add input file events are recorded.
CHECK:      "name": "Add input for DTLTO"
CHECK:      "name": "Add input for DTLTO"
CHECK:      "name": "Remove temporary inputs for DTLTO"
CHECK:      "name": "Save input archive member for DTLTO"
CHECK-SAME:   "detail": "t1.a(t1.bc at [[#ARCHIVE_OFFSET:]]).1.[[PID:[A-F0-9]+]].o"
CHECK:      "name": "Total Add input for DTLTO"
CHECK-SAME:   "count": 2,
CHECK:      "name": "Total Remove temporary inputs for DTLTO"
CHECK-SAME:   "count": 1,
CHECK:      "name": "Total Save input archive member for DTLTO"
CHECK-SAME:   "count": 1,

#--- t1.ll
target triple = "x86_64-unknown-linux-gnu"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

define void @t1() {
  ret void
}

#--- filter_order_and_pprint.py
import json, sys

data = json.load(open(sys.argv[1], "r", encoding="utf-8"))

# Get DTLTO events.
events = [e for e in data["traceEvents"] if "DTLTO" in e["name"]]
events.sort(key=lambda e: (e["name"], str(e.get("args", {}).get("detail", ""))))

# Print an event per line. Ensure 'name' is the first key.
for ev in events:
    name = ev.pop("name")
    print(json.dumps({"name": name, **ev}))
