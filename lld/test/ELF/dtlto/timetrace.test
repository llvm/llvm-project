REQUIRES: x86

## Test that the LLD produces expected time trace output for DTLTO.

RUN: rm -rf %t && split-file %s %t && cd %t

RUN: sed 's/@t1/@t2/g' t1.ll > t2.ll

## Generate ThinLTO bitcode files.
RUN: opt -thinlto-bc t1.ll -o t1.bc
RUN: opt -thinlto-bc t2.ll -o t2.bc

## Generate object files for mock.py to return.
RUN: llc t1.ll --filetype=obj -o t1.o
RUN: llc t2.ll --filetype=obj -o t2.o

## Link and generate a time trace.
## Note: mock.py doesnâ€™t compile; it copies the specified object files to the
## outputs in job order.
RUN: ld.lld t1.bc t2.bc -o my.elf \
RUN:   --thinlto-distributor=%python \
RUN:   --thinlto-distributor-arg=%llvm_src_root/utils/dtlto/mock.py \
RUN:   --thinlto-distributor-arg=t1.o --thinlto-distributor-arg=t2.o \
RUN:   --time-trace-granularity=0 --time-trace=%t.json
RUN: %python filter_order_and_pprint.py %t.json | FileCheck %s

## Check that DTLTO events are recorded.
CHECK-NOT:  "name"
CHECK:      "name": "Add DTLTO files to the link"
CHECK-SAME:   "pid": [[#PID:]],
CHECK-NEXT: "name": "Emit DTLTO JSON"
CHECK-NEXT: "name": "Emit individual index for DTLTO"
CHECK-SAME:   t1.1.[[#PID]].native.o.thinlto.bc"
CHECK-NEXT: "name": "Emit individual index for DTLTO"
CHECK-SAME:   t2.2.[[#PID]].native.o.thinlto.bc"
CHECK-NEXT: "name": "Execute DTLTO distributor", "{{.*}}"
CHECK-NEXT: "name": "Remove DTLTO temporary files"
CHECK-NEXT: "name": "Total Add DTLTO files to the link"
CHECK-SAME:   "count": 1,
CHECK-NEXT: "name": "Total Emit DTLTO JSON"
CHECK-SAME:   "count": 1,
CHECK-NEXT: "name": "Total Emit individual index for DTLTO"
CHECK-SAME:   "count": 2,
CHECK-NEXT: "name": "Total Execute DTLTO distributor"
CHECK-SAME:   "count": 1,
CHECK-NEXT: "name": "Total Remove DTLTO temporary files"
CHECK-SAME:   "count": 1,
CHECK-NOT:  "name"

#--- t1.ll
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @t1() {
  ret void
}

#--- filter_order_and_pprint.py
import json, sys

data = json.load(open(sys.argv[1], "r", encoding="utf-8"))

# Get DTLTO events.
events = [e for e in data["traceEvents"] if "DTLTO" in e["name"]]
events.sort(key=lambda e: (e["name"], str(e.get("args", {}).get("detail", ""))))

# Print an event per line. Ensure 'name' is the first key.
for ev in events:
    name = ev.pop("name")
    print(json.dumps({"name": name, **ev}))
